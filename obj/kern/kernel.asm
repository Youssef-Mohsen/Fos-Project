
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 b0 17 00 	lgdtl  0x17b018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 b0 17 f0       	mov    $0xf017b000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 34 ca 5e f0 01 	movl   $0x1,0xf05eca34
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 84 c9 5e f0 01 	movl   $0x1,0xf05ec984
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 50 f6 60 f0       	mov    $0xf060f650,%edx
f010006a:	b8 4c 37 5c f0       	mov    $0xf05c374c,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 4c 37 5c f0       	push   $0xf05c374c
f010007e:	e8 5a e9 01 00       	call   f011e9dd <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 e0 0f 12 f0       	push   $0xf0120fe0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 27 10 12 f0       	push   $0xf0121027
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 3b 10 12 f0       	push   $0xf012103b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 4f 10 12 f0       	push   $0xf012104f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 d1 6f 00 00       	call   f01070ab <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 5b 10 12 f0       	push   $0xf012105b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 63 10 12 f0       	push   $0xf0121063
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 16 79 00 00       	call   f0107a18 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 b7 74 00 00       	call   f01075be <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 57 7c 00 00       	call   f0107d63 <initialize_paging>
		sharing_init();
f010010c:	e8 c8 88 00 00       	call   f01089d9 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 e4 89 00 00       	call   f0108b0c <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 89 e2 00 00       	call   f010e3b9 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 72 e3 00 00       	call   f010e4b6 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 4d e3 00 00       	call   f010e49e <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 6d e3 00 00       	call   f010e4ce <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 cb ed 01 00       	call   f011ef34 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 71 10 12 f0       	push   $0xf0121071
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 53 9b 00 00       	call   f0109cd1 <env_init>
		ts_init();
f010017e:	e8 ec bb 00 00       	call   f010bd6f <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 5b 10 12 f0       	push   $0xf012105b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 84 10 12 f0       	push   $0xf0121084
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 ef 6b 00 00       	call   f0106d97 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ad 10 12 f0       	push   $0xf01210ad
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 c7 6d 00 00       	call   f0106f89 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 c3 10 12 f0       	push   $0xf01210c3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 aa 6d 00 00       	call   f0106f89 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 e0 10 12 f0       	push   $0xf01210e0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 8d 6d 00 00       	call   f0106f89 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 ff 10 12 f0       	push   $0xf01210ff
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 1c 11 12 f0       	push   $0xf012111c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 72 49 00 00       	call   f0104b96 <kclock_init>
		sched_init() ;
f0100224:	e8 a2 64 00 00       	call   f01066cb <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 40 11 12 f0       	push   $0xf0121140
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 b0 17 f0       	mov    $0xf017b000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 60 11 12 f0       	push   $0xf0121160
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 84 11 12 f0       	push   $0xf0121184
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 7c cc 5e f0 00 	movl   $0x0,0xf05ecc7c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 cc 11 12 f0       	push   $0xf01211cc
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 f8 11 12 f0       	push   $0xf01211f8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 1d 12 12 f0       	push   $0xf012121d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 24 12 12 f0       	push   $0xf0121224
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 6c 12 12 f0       	push   $0xf012126c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 b4 12 12 f0       	push   $0xf01212b4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 6c 12 12 f0       	push   $0xf012126c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 24 12 12 f0       	push   $0xf0121224
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 f9 12 12 f0       	push   $0xf01212f9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 9e a5 00 00       	call   f010a8e2 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 60 37 5c f0       	mov    %eax,0xf05c3760

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 00 13 12 f0       	push   $0xf0121300
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 25 13 12 f0       	push   $0xf0121325
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 fa a4 00 00       	call   f010a8a0 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 27 13 12 f0       	push   $0xf0121327
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 60 37 5c f0       	mov    %eax,0xf05c3760

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 31 13 12 f0       	push   $0xf0121331
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 25 13 12 f0       	push   $0xf0121325
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 47 6d 00 00       	call   f0107164 <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 7f 6c 00 00       	call   f01070a1 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 80 6d 00 00       	call   f01071b6 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 32 60 00 00       	call   f0106473 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 9c a4 00 00       	call   f010a8e2 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 41 a4 00 00       	call   f010a8a0 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 60 37 5c f0       	mov    %eax,0xf05c3760

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 31 13 12 f0       	push   $0xf0121331
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 25 13 12 f0       	push   $0xf0121325
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 2a a4 00 00       	call   f010a8e2 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 cf a3 00 00       	call   f010a8a0 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 4a 13 12 f0       	push   $0xf012134a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 25 13 12 f0       	push   $0xf0121325
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 84 37 5c f0       	mov    0xf05c3784,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 68 13 12 f0       	push   $0xf0121368
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 84 37 5c f0       	mov    %eax,0xf05c3784
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 fe c9 00 00       	call   f010d073 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 88 37 5c f0 b4 	movl   $0x3b4,0xf05c3788
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 88 37 5c f0 d4 	movl   $0x3d4,0xf05c3788
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 88 37 5c f0       	mov    0xf05c3788,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 88 37 5c f0       	mov    0xf05c3788,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 88 37 5c f0       	mov    0xf05c3788,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 88 37 5c f0       	mov    0xf05c3788,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 8c 37 5c f0       	mov    %eax,0xf05c378c
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 8c 37 5c f0    	mov    0xf05c378c,%edx
f010087a:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
		text_length = 0;
f01008a6:	c7 05 80 37 5c f0 00 	movl   $0x0,0xf05c3780
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d 90 37 5c f0 	mov    0xf05c3790,%cx
f01008b7:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d 8c 37 5c f0    	mov    0xf05c378c,%ecx
f0100972:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 90 37 5c f0 	mov    %dx,0xf05c3790
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 80 37 5c f0    	mov    0xf05c3780,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 80 37 5c f0       	mov    0xf05c3780,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 80 37 5c f0       	mov    %eax,0xf05c3780
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 8c 37 5c f0       	mov    0xf05c378c,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 8c 37 5c f0       	mov    0xf05c378c,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 22 e0 01 00       	call   f011ea0d <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 8c 37 5c f0    	mov    0xf05c378c,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 90 37 5c f0    	mov    %ax,0xf05c3790
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 88 37 5c f0       	mov    0xf05c3788,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 88 37 5c f0    	mov    0xf05c3788,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 88 37 5c f0       	mov    0xf05c3788,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 88 37 5c f0    	mov    0xf05c3788,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 a8 39 5c f0       	mov    %eax,0xf05c39a8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 b0 17 f0    	mov    -0xfe84fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 a8 39 5c f0       	mov    %eax,0xf05c39a8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 a8 39 5c f0       	mov    %eax,0xf05c39a8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 b0 17 f0    	mov    -0xfe84fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 a8 39 5c f0       	mov    %eax,0xf05c39a8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 b1 17 f0    	mov    -0xfe84ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 a8 39 5c f0       	mov    %eax,0xf05c39a8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 b5 17 f0 	mov    -0xfe84ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 80 37 5c f0       	mov    0xf05c3780,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 80 37 5c f0    	mov    0xf05c3780,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 80 37 5c f0       	mov    0xf05c3780,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 80 37 5c f0       	mov    %eax,0xf05c3780
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 90 37 5c f0    	mov    0xf05c3790,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 8c 37 5c f0    	mov    0xf05c378c,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 8c 37 5c f0       	mov    0xf05c378c,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 80 37 5c f0       	mov    0xf05c3780,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 a8 39 5c f0       	mov    0xf05c39a8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 7b 13 12 f0       	push   $0xf012137b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 5e c3 00 00       	call   f010d073 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 a4 39 5c f0       	mov    0xf05c39a4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 a4 39 5c f0    	mov    %edx,0xf05c39a4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 a0 37 5c f0    	mov    %dl,-0xfa3c860(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 a4 39 5c f0       	mov    0xf05c39a4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 a4 39 5c f0 00 	movl   $0x0,0xf05c39a4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 a0 39 5c f0    	mov    0xf05c39a0,%edx
f0100d7f:	a1 a4 39 5c f0       	mov    0xf05c39a4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 a0 39 5c f0       	mov    0xf05c39a0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 a0 39 5c f0    	mov    %edx,0xf05c39a0
f0100d96:	8a 80 a0 37 5c f0    	mov    -0xfa3c860(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 a0 39 5c f0       	mov    0xf05c39a0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 a0 39 5c f0 00 	movl   $0x0,0xf05c39a0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 a0 39 5c f0    	mov    0xf05c39a0,%edx
f0100dd0:	a1 a4 39 5c f0       	mov    0xf05c39a4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 a0 39 5c f0       	mov    0xf05c39a0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 a0 39 5c f0    	mov    %edx,0xf05c39a0
f0100de7:	8a 80 a0 37 5c f0    	mov    -0xfa3c860(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 a0 39 5c f0       	mov    0xf05c39a0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 a0 39 5c f0 00 	movl   $0x0,0xf05c39a0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 84 37 5c f0       	mov    0xf05c3784,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 87 13 12 f0       	push   $0xf0121387
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 9d 3d 00 00       	call   f0104c58 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 21 9a 00 00       	call   f010a8e2 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 a4 13 12 f0       	push   $0xf01213a4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 cb 13 12 f0       	push   $0xf01213cb
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 56 3d 00 00       	call   f0104c58 <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 da 99 00 00       	call   f010a8e2 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 e0 13 12 f0       	push   $0xf01213e0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 cb 13 12 f0       	push   $0xf01213cb
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 aa d1 01 00       	call   f011e12d <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 ce 61 00 00       	call   f0107164 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 00 62 00 00       	call   f01071b6 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 40 5d 60 f0       	add    $0xf0605d40,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 f7 d7 01 00       	call   f011e7ef <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 60 ad 60 f0       	push   $0xf060ad60
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 fa d9 01 00       	call   f011ea0d <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 40 5d 60 f0       	add    $0xf0605d40,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 40 5d 60 f0       	add    $0xf0605d40,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 35 d7 01 00       	call   f011e7ef <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 60 ad 60 f0       	push   $0xf060ad60
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 38 d9 01 00       	call   f011ea0d <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 40 cd 5e f0       	add    $0xf05ecd40,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 75 d8 01 00       	call   f011e9dd <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 0c 14 12 f0       	push   $0xf012140c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 0f 14 12 f0       	push   $0xf012140f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 40 cd 5e f0       	push   $0xf05ecd40
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 1a d5 01 00       	call   f011e7ef <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 2f d5 01 00       	call   f011e83e <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 d2 d4 01 00       	call   f011e7ef <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 1f 14 12 f0       	push   $0xf012141f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 ad da 01 00       	call   f011ee04 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 24 14 12 f0       	push   $0xf0121424
f010137e:	50                   	push   %eax
f010137f:	e8 77 d5 01 00       	call   f011e8fb <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 28 14 12 f0       	push   $0xf0121428
f0101399:	50                   	push   %eax
f010139a:	e8 5c d5 01 00       	call   f011e8fb <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 2d 14 12 f0       	push   $0xf012142d
f01013b4:	50                   	push   %eax
f01013b5:	e8 41 d5 01 00       	call   f011e8fb <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 2d 14 12 f0       	push   $0xf012142d
f01013d5:	50                   	push   %eax
f01013d6:	e8 20 d5 01 00       	call   f011e8fb <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 c8 d3 01 00       	call   f011e7ef <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 ca d3 01 00       	call   f011e83e <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 a9 d3 01 00       	call   f011e83e <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 26 d3 01 00       	call   f011e7ef <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 41 d4 01 00       	call   f011e933 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 76 d2 01 00       	call   f011e7ef <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 40 cd 5e f0       	add    $0xf05ecd40,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 41 d4 01 00       	call   f011e9dd <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 40 cd 5e f0    	add    $0xf05ecd40,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 ac d2 01 00       	call   f011e86c <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 ec d1 01 00       	call   f011e7ef <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 bc 17 f0    	mov    0xf017bce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 04 d3 01 00       	call   f011e933 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 4f d1 01 00       	call   f011e7ef <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 bc 17 f0    	mov    0xf017bce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 bc 17 f0    	mov    0xf017bce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 ef d0 01 00       	call   f011e7ef <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 40 cd 5e f0       	add    $0xf05ecd40,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 ba d2 01 00       	call   f011e9dd <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 40 cd 5e f0    	add    $0xf05ecd40,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 25 d1 01 00       	call   f011e86c <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 67 d0 01 00       	call   f011e7ef <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 82 d1 01 00       	call   f011e933 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 cd cf 01 00       	call   f011e7ef <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 73 cf 01 00       	call   f011e7ef <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 40 cd 5e f0       	add    $0xf05ecd40,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 3e d1 01 00       	call   f011e9dd <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 40 cd 5e f0    	add    $0xf05ecd40,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 a9 cf 01 00       	call   f011e86c <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 bd 17 f0       	mov    0xf017bdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 40 cd 5e f0       	add    $0xf05ecd40,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 40 cd 5e f0       	push   $0xf05ecd40
f0101929:	e8 c1 ce 01 00       	call   f011e7ef <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 68 ce 01 00       	call   f011e7ef <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 55 ce 01 00       	call   f011e7ef <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 40 cd 5e f0    	lea    -0xfa132c0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 40 cd 5e f0       	add    $0xf05ecd40,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 fa cd 01 00       	call   f011e7ef <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 40 5d 60 f0    	lea    -0xf9fa2c0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 40 5d 60 f0       	add    $0xf0605d40,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 ef cd 01 00       	call   f011ea0d <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 40 a9 60 f0       	push   $0xf060a940
f0101c3a:	e8 ce cd 01 00       	call   f011ea0d <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 40 5d 60 f0       	add    $0xf0605d40,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 9e cc 01 00       	call   f011e8fb <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 b5 17 f0       	mov    %eax,0xf017b530
f0101c6f:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 40 5d 60 f0       	add    $0xf0605d40,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 80 cd 01 00       	call   f011ea0d <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 7c cc 5e f0       	mov    0xf05ecc7c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 37 14 12 f0       	mov    $0xf0121437,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 37 18 12 f0       	mov    $0xf0121837,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 37 1c 12 f0       	mov    $0xf0121c37,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 7c cc 5e f0 00 	movl   $0x0,0xf05ecc7c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 f4 cb 5e f0 00 	movl   $0x0,0xf05ecbf4
f0101d59:	00 00 00 
f0101d5c:	c7 05 f8 cb 5e f0 00 	movl   $0x0,0xf05ecbf8
f0101d63:	00 00 00 
f0101d66:	c7 05 00 cc 5e f0 00 	movl   $0x0,0xf05ecc00
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 57 cc 01 00       	call   f011e9dd <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 31 14 12 f0       	push   $0xf0121431
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 88 8d 00 00       	call   f010ab67 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 bd 52 00 00       	call   f01070a1 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 20 cd 5e f0       	mov    %eax,0xf05ecd20
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 40 ad 60 f0       	mov    %eax,0xf060ad40
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 20 cd 5e f0       	mov    0xf05ecd20,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 20 cd 5e f0    	mov    %edx,0xf05ecd20
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 40 ad 60 f0       	mov    0xf060ad40,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 40 ad 60 f0       	mov    %eax,0xf060ad40
f0101e98:	a1 40 ad 60 f0       	mov    0xf060ad40,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 20 cd 5e f0       	mov    %eax,0xf05ecd20
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 40 ad 60 f0       	mov    %eax,0xf060ad40
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 20 cd 5e f0       	mov    0xf05ecd20,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 20 cd 5e f0    	mov    %edx,0xf05ecd20
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 40 ad 60 f0       	mov    0xf060ad40,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 40 ad 60 f0       	mov    %eax,0xf060ad40
f0101ed4:	a1 40 ad 60 f0       	mov    0xf060ad40,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 1f 14 12 f0       	push   $0xf012141f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 ee ce 01 00       	call   f011ee04 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 37 20 12 f0       	push   $0xf0122037
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 00 cc 5e f0       	mov    0xf05ecc00,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 50 20 12 f0       	push   $0xf0122050
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 a1 20 12 f0       	push   $0xf01220a1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 bc 20 12 f0       	push   $0xf01220bc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 00 cc 5e f0       	mov    0xf05ecc00,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 ec 20 12 f0       	push   $0xf01220ec
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 a1 20 12 f0       	push   $0xf01220a1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 16 21 12 f0       	push   $0xf0122116
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 fc cb 5e f0       	mov    %eax,0xf05ecbfc
f010203b:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 20 21 12 f0       	push   $0xf0122120
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 83 21 12 f0       	push   $0xf0122183
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 8c 21 12 f0       	push   $0xf012218c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 fc cb 5e f0       	mov    %eax,0xf05ecbfc
f010218b:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 b5 17 f0       	add    $0xf017b548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 94 21 12 f0       	push   $0xf0122194
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 a1 20 12 f0       	push   $0xf01220a1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 f8 cb 5e f0       	mov    %eax,0xf05ecbf8
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 f4 cb 5e f0       	mov    %eax,0xf05ecbf4
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 00 cc 5e f0       	mov    0xf05ecc00,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 00 cc 5e f0       	mov    %eax,0xf05ecc00

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 fc cb 5e f0       	mov    %eax,0xf05ecbfc
f0102292:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 1d c6 01 00       	call   f011e8fb <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c b5 17 f0       	add    $0xf017b54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c b5 17 f0       	add    $0xf017b54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 f4 cb 5e f0    	mov    0xf05ecbf4,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 f4 cb 5e f0    	mov    0xf05ecbf4,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f010238d:	a3 f8 cb 5e f0       	mov    %eax,0xf05ecbf8
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01023a3:	a3 f4 cb 5e f0       	mov    %eax,0xf05ecbf4
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 b5 17 f0       	add    $0xf017b554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 00 cc 5e f0       	mov    0xf05ecc00,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 00 cc 5e f0       	mov    %eax,0xf05ecc00
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 f4 cb 5e f0    	mov    0xf05ecbf4,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 f4 cb 5e f0    	mov    0xf05ecbf4,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f010248c:	a3 f8 cb 5e f0       	mov    %eax,0xf05ecbf8
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01024a2:	a3 f4 cb 5e f0       	mov    %eax,0xf05ecbf4
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 b5 17 f0       	add    $0xf017b554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 00 cc 5e f0       	mov    0xf05ecc00,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 00 cc 5e f0       	mov    %eax,0xf05ecc00
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 34 ca 5e f0 00 	movl   $0x0,0xf05eca34
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 34 ca 5e f0 01 	movl   $0x1,0xf05eca34
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 34 ca 5e f0 02 	movl   $0x2,0xf05eca34
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 34 ca 5e f0 03 	movl   $0x3,0xf05eca34
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 34 ca 5e f0 04 	movl   $0x4,0xf05eca34
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 84 c9 5e f0 01 	movl   $0x1,0xf05ec984
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 84 c9 5e f0 02 	movl   $0x2,0xf05ec984
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 84 c9 5e f0 03 	movl   $0x3,0xf05ec984
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 84 c9 5e f0 04 	movl   $0x4,0xf05ec984
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 84 c9 5e f0       	mov    0xf05ec984,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 84 c9 5e f0       	mov    0xf05ec984,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 84 c9 5e f0       	mov    0xf05ec984,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 84 c9 5e f0       	mov    0xf05ec984,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 b4 21 12 f0       	push   $0xf01221b4
f0102662:	6a 55                	push   $0x55
f0102664:	68 dc 21 12 f0       	push   $0xf01221dc
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 a0 c9 5e f0    	mov    0xf05ec9a0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 b5 17 f0       	add    $0xf017b544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 5f 2a 12 f0       	push   $0xf0122a5f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 68 2a 12 f0       	push   $0xf0122a68
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 bc 17 f0    	mov    0xf017bce0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 bc 17 f0    	mov    0xf017bce0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 7d 2a 12 f0       	push   $0xf0122a7d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 99 2a 12 f0       	push   $0xf0122a99
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 b4 2a 12 f0       	push   $0xf0122ab4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 c5 0f 12 00       	mov    $0x120fc5,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 c5 0f 12 f0       	push   $0xf0120fc5
f010278e:	68 f0 2a 12 f0       	push   $0xf0122af0
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 4c 37 5c 00       	mov    $0x5c374c,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 4c 37 5c f0       	push   $0xf05c374c
f01027a9:	68 2c 2b 12 f0       	push   $0xf0122b2c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 50 f6 60 00       	mov    $0x60f650,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 50 f6 60 f0       	push   $0xf060f650
f01027c4:	68 74 2b 12 f0       	push   $0xf0122b74
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 50 f6 60 f0       	mov    $0xf060f650,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 b0 2b 12 f0       	push   $0xf0122bb0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 25 c3 01 00       	call   f011eb4f <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 e4 c2 01 00       	call   f011eb4f <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 a9 80 00 00       	call   f010a932 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 ae c2 01 00       	call   f011eb4f <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 dc 2b 12 f0       	push   $0xf0122bdc
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 28 c2 01 00       	call   f011eb4f <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 a5 be 01 00       	call   f011e7ef <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 aa c1 01 00       	call   f011eb4f <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 06 2c 12 f0       	push   $0xf0122c06
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 5e c1 01 00       	call   f011eb4f <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 23 7f 00 00       	call   f010a932 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 28 c1 01 00       	call   f011eb4f <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 06 2c 12 f0       	push   $0xf0122c06
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 20 2c 12 f0       	push   $0xf0122c20
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 97 c0 01 00       	call   f011eb4f <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 4a 2c 12 f0       	push   $0xf0122c4a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 4d 2c 12 f0       	push   $0xf0122c4d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 3a c0 01 00       	call   f011eb4f <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 ff 7d 00 00       	call   f010a932 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 04 c0 01 00       	call   f011eb4f <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 e9 bf 01 00       	call   f011eb4f <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 4f 2c 12 f0       	push   $0xf0122c4f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 4d bf 01 00       	call   f011eb4f <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 12 7d 00 00       	call   f010a932 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 06 bf 01 00       	call   f011eb4f <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 db 60 00 00       	call   f0108d60 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 95 60 00 00       	call   f0108d26 <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 e0 55 00 00       	call   f010829b <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 60 2c 12 f0       	push   $0xf0122c60
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 11 be 01 00       	call   f011eb4f <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 d6 7b 00 00       	call   f010a932 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 ca bd 01 00       	call   f011eb4f <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 b0 53 00 00       	call   f0108147 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 8a 2c 12 f0       	push   $0xf0122c8a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 3c 58 00 00       	call   f0108614 <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 a4 2c 12 f0       	push   $0xf0122ca4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 ad 57 00 00       	call   f0108614 <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 71 5a 00 00       	call   f01088f6 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 e8 2c 12 f0       	push   $0xf0122ce8
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 50 cb 5e f0       	mov    0xf05ecb50,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 40 2d 12 f0       	push   $0xf0122d40
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 e2 b4 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 7c 2d 12 f0       	push   $0xf0122d7c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 fa bb 01 00       	call   f011eb4f <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 df bb 01 00       	call   f011eb4f <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 c4 bb 01 00       	call   f011eb4f <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 61 b4 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 93 bb 01 00       	call   f011eb4f <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 76 bb 01 00       	call   f011eb4f <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 5b bb 01 00       	call   f011eb4f <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 fb b3 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 28 2e 12 f0       	push   $0xf0122e28
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 13 bb 01 00       	call   f011eb4f <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 b8 2e 12 f0       	push   $0xf0122eb8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 99 b3 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 50 2f 12 f0       	push   $0xf0122f50
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 a8 2f 12 f0       	push   $0xf0122fa8
f010309d:	68 ed 2f 12 f0       	push   $0xf0122fed
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 02 30 12 f0       	push   $0xf0123002
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 a8 2f 12 f0       	push   $0xf0122fa8
f01030bc:	68 ed 2f 12 f0       	push   $0xf0122fed
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 02 30 12 f0       	push   $0xf0123002
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 7d 6d 00 00       	call   f0109e64 <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 16 30 12 f0       	push   $0xf0123016
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 28 30 12 f0       	push   $0xf0123028
f0103117:	68 ed 2f 12 f0       	push   $0xf0122fed
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 02 30 12 f0       	push   $0xf0123002
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 eb 34 00 00       	call   f0106624 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 58 30 12 f0       	push   $0xf0123058
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 30 25 00 00       	call   f01056ba <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 50 cb 5e f0 00 	movl   $0x0,0xf05ecb50
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 6a 25 00 00       	call   f0105710 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 84 b9 01 00       	call   f011eb4f <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 79 28 00 00       	call   f0105a56 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 a1 24 00 00       	call   f01056ba <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 58 30 12 f0       	push   $0xf0123058
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 50 cb 5e f0 00 	movl   $0x0,0xf05ecb50
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 c4 2d 00 00       	call   f0106013 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 91 2b 00 00       	call   f0105df2 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 35 2e 00 00       	call   f01060a8 <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 70 30 12 f0       	push   $0xf0123070
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 9a b8 01 00       	call   f011eb4f <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 aa b0 00 00       	call   f010e376 <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 d0 30 12 f0       	push   $0xf01230d0
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 84 b0 00 00       	call   f010e376 <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 14 31 12 f0       	push   $0xf0123114
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 54 31 12 f0       	push   $0xf0123154
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 0f b8 01 00       	call   f011eb4f <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 98 b0 00 00       	call   f010e3e9 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 a8 31 12 f0       	push   $0xf01231a8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 33 b0 00 00       	call   f010e3a9 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 dc 31 12 f0       	push   $0xf01231dc
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 21 b0 00 00       	call   f010e3b9 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 08 32 12 f0       	push   $0xf0123208
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 0f b0 00 00       	call   f010e3c9 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 30 32 12 f0       	push   $0xf0123230
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 63 b7 01 00       	call   f011eb4f <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 3d 35 00 00       	call   f010693c <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 64 32 12 f0       	push   $0xf0123264
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 0f b7 01 00       	call   f011eb4f <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 dc b6 01 00       	call   f011eb4f <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 54 35 00 00       	call   f01069ea <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 9c 32 12 f0       	push   $0xf012329c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 64 c8 5e f0    	mov    0xf05ec864,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 c9 32 12 f0       	push   $0xf01232c9
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 4d 2c 12 f0       	push   $0xf0122c4d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 37 b6 01 00       	call   f011eb4f <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 1c b6 01 00       	call   f011eb4f <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 c7 34 00 00       	call   f0106a12 <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 d0 32 12 f0       	push   $0xf01232d0
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 4d 2c 12 f0       	push   $0xf0122c4d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 0b 31 00 00       	call   f0106695 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 0c 33 12 f0       	push   $0xf012330c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 64 c8 5e f0    	mov    0xf05ec864,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 c9 32 12 f0       	push   $0xf01232c9
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 4d 2c 12 f0       	push   $0xf0122c4d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 8c 30 00 00       	call   f010667b <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 40 33 12 f0       	push   $0xf0123340
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 9b 30 00 00       	call   f01066b0 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 d0 32 12 f0       	push   $0xf01232d0
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 7c 33 12 f0       	push   $0xf012337c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 de b4 01 00       	call   f011eb4f <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 bd a2 01 00       	call   f011d943 <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 a4 33 12 f0       	push   $0xf01233a4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 cc 33 12 f0       	push   $0xf01233cc
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 4e ad 00 00       	call   f010e417 <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 f0 33 12 f0       	push   $0xf01233f0
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 15 ad 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 18 34 12 f0       	push   $0xf0123418
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 f2 ac 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 58 34 12 f0       	push   $0xf0123458
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 05 ad 00 00       	call   f010e432 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 94 34 12 f0       	push   $0xf0123494
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 05 ad 00 00       	call   f010e44d <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 b8 34 12 f0       	push   $0xf01234b8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 e8 34 12 f0       	push   $0xf01234e8
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 14 35 12 f0       	push   $0xf0123514
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 44 35 12 f0       	push   $0xf0123544
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 74 35 12 f0       	push   $0xf0123574
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 a4 35 12 f0       	push   $0xf01235a4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 d4 35 12 f0       	push   $0xf01235d4
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 00 36 12 f0       	push   $0xf0123600
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 2c 36 12 f0       	push   $0xf012362c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 58 36 12 f0       	push   $0xf0123658
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 84 36 12 f0       	push   $0xf0123684
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 b0 36 12 f0       	push   $0xf01236b0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 b0 36 12 f0       	push   $0xf01236b0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 e4 36 12 f0       	push   $0xf01236e4
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 14 37 12 f0       	push   $0xf0123714
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 44 37 12 f0       	push   $0xf0123744
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 78 37 12 f0       	push   $0xf0123778
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 b4 37 12 f0       	push   $0xf01237b4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 e4 37 12 f0       	push   $0xf01237e4
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 10 38 12 f0       	push   $0xf0123810
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 3c 38 12 f0       	push   $0xf012383c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 6c 38 12 f0       	push   $0xf012386c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 e5 aa 00 00       	call   f010e4c4 <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 9c 38 12 f0       	push   $0xf012389c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 9f aa 00 00       	call   f010e49e <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 d8 38 12 f0       	push   $0xf01238d8
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 a0 aa 00 00       	call   f010e4c4 <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 9c 38 12 f0       	push   $0xf012389c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 5a aa 00 00       	call   f010e49e <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 fc 38 12 f0       	push   $0xf01238fc
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 48 aa 00 00       	call   f010e4b6 <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 23 aa 00 00       	call   f010e49e <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 1c 39 12 f0       	push   $0xf012391c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 11 aa 00 00       	call   f010e4b6 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 ec a9 00 00       	call   f010e49e <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 22 aa 00 00       	call   f010e4dc <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 38 39 12 f0       	push   $0xf0123938
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 68 39 12 f0       	push   $0xf0123968
f0103ada:	e8 08 ab 01 00       	call   f011e5e7 <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 5d b0 01 00       	call   f011eb4f <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 d0 a9 00 00       	call   f010e4ce <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 d6 a9 00 00       	call   f010e4dc <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 94 39 12 f0       	push   $0xf0123994
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 b9 39 12 f0       	push   $0xf01239b9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 8b a9 00 00       	call   f010e4c4 <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 d4 39 12 f0       	push   $0xf01239d4
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 58 a9 00 00       	call   f010e4ac <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 24 3a 12 f0       	push   $0xf0123a24
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 d2 af 01 00       	call   f011eb4f <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 45 a9 00 00       	call   f010e4ce <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 4b a9 00 00       	call   f010e4dc <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 94 39 12 f0       	push   $0xf0123994
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 10 a9 00 00       	call   f010e4c4 <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 d4 39 12 f0       	push   $0xf01239d4
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 dd a8 00 00       	call   f010e4ac <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 24 3a 12 f0       	push   $0xf0123a24
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 f4 a8 00 00       	call   f010e4dc <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 6a 3a 12 f0       	push   $0xf0123a6a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 35 b2 00 00       	call   f010ee49 <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 9a b3 01 00       	call   f011efd7 <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 ab b4 01 00       	call   f011f117 <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 88 3a 12 f0       	push   $0xf0123a88
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 60 cb 5e f0 00 	movl   $0x0,0xf05ecb60
f0103c9f:	00 00 00 
f0103ca2:	c7 05 64 cb 5e f0 00 	movl   $0x0,0xf05ecb64
f0103ca9:	00 00 00 
f0103cac:	c7 05 6c cb 5e f0 00 	movl   $0x0,0xf05ecb6c
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 4d 44 00 00       	call   f010812c <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 bc 3a 12 f0       	push   $0xf0123abc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 60 cb 5e f0    	mov    0xf05ecb60,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 60 cb 5e f0    	mov    0xf05ecb60,%edx
f0103d36:	8b 1d 60 c2 5e f0    	mov    0xf05ec260,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 64 cb 5e f0       	mov    %eax,0xf05ecb64
f0103d68:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 60 cb 5e f0       	mov    %eax,0xf05ecb60
f0103d81:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 6c cb 5e f0       	mov    0xf05ecb6c,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 6c cb 5e f0       	mov    %eax,0xf05ecb6c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 60 c2 5e f0    	mov    0xf05ec260,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 70 cb 5e f0       	push   $0xf05ecb70
f0103e0a:	e8 53 aa 00 00       	call   f010e862 <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 60 cb 5e f0       	mov    0xf05ecb60,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 df 3a 12 f0       	push   $0xf0123adf
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 64 cb 5e f0       	mov    %eax,0xf05ecb64
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 60 cb 5e f0       	mov    %eax,0xf05ecb60
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 6c cb 5e f0       	mov    0xf05ecb6c,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 6c cb 5e f0       	mov    %eax,0xf05ecb6c
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 76 42 00 00       	call   f010812c <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 70 cb 5e f0       	push   $0xf05ecb70
f0103ed6:	e8 0e aa 00 00       	call   f010e8e9 <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 70 cb 5e f0       	push   $0xf05ecb70
f0103efc:	e8 61 a9 00 00       	call   f010e862 <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 bc 3a 12 f0       	push   $0xf0123abc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 60 cb 5e f0    	mov    0xf05ecb60,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 60 cb 5e f0    	mov    0xf05ecb60,%edx
f0103f5b:	8b 1d 60 c2 5e f0    	mov    0xf05ec260,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 64 cb 5e f0       	mov    %eax,0xf05ecb64
f0103f8d:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 60 cb 5e f0       	mov    %eax,0xf05ecb60
f0103fa6:	8b 0d 60 c2 5e f0    	mov    0xf05ec260,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 6c cb 5e f0       	mov    0xf05ecb6c,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 6c cb 5e f0       	mov    %eax,0xf05ecb6c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 70 cb 5e f0       	push   $0xf05ecb70
f0103fd4:	e8 10 a9 00 00       	call   f010e8e9 <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 44 4d 00 00       	call   f0108d60 <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 00 3b 12 f0       	push   $0xf0123b00
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 83 4c 00 00       	call   f0108d0c <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 7f 4c 00 00       	call   f0108d43 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 fc a8 01 00       	call   f011e9dd <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 a8 05 00 00    	mov    0x5a8(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 a8 05 00 00    	mov    %edx,0x5a8(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 38 ca 5e f0       	mov    0xf05eca38,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b2 00 00 00       	call   f010422e <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 a8 00 00 00       	jmp    f010422c <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 30 3b 12 f0       	push   $0xf0123b30
f0104192:	68 56 3b 12 f0       	push   $0xf0123b56
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 9f 3a 12 f0       	push   $0xf0123a9f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 c0 74             	add    $0x74,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 95 05 00 00       	call   f010474d <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 40 74             	mov    0x74(%eax),%eax
f01041c1:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c4:	52                   	push   %edx
f01041c5:	6a 01                	push   $0x1
f01041c7:	ff 75 0c             	pushl  0xc(%ebp)
f01041ca:	50                   	push   %eax
f01041cb:	e8 14 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d0:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041d9:	c1 ea 0c             	shr    $0xc,%edx
f01041dc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e2:	c1 e2 02             	shl    $0x2,%edx
f01041e5:	01 d0                	add    %edx,%eax
f01041e7:	8b 00                	mov    (%eax),%eax
f01041e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041ef:	85 c0                	test   %eax,%eax
f01041f1:	75 34                	jne    f0104227 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f3:	83 ec 0c             	sub    $0xc,%esp
f01041f6:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041f9:	50                   	push   %eax
f01041fa:	e8 f6 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01041ff:	83 c4 10             	add    $0x10,%esp
f0104202:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104205:	75 07                	jne    f010420e <pf_add_empty_env_page+0x10e>
f0104207:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420c:	eb 1e                	jmp    f010422c <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f010420e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104211:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104214:	c1 ea 0c             	shr    $0xc,%edx
f0104217:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010421d:	c1 e2 02             	shl    $0x2,%edx
f0104220:	01 c2                	add    %eax,%edx
f0104222:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104225:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0104227:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422c:	c9                   	leave  
f010422d:	c3                   	ret    

f010422e <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f010422e:	55                   	push   %ebp
f010422f:	89 e5                	mov    %esp,%ebp
f0104231:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104234:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423b:	76 19                	jbe    f0104256 <pf_add_env_page+0x28>
f010423d:	68 30 3b 12 f0       	push   $0xf0123b30
f0104242:	68 56 3b 12 f0       	push   $0xf0123b56
f0104247:	68 f1 00 00 00       	push   $0xf1
f010424c:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0104251:	e8 e3 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104256:	8b 45 08             	mov    0x8(%ebp),%eax
f0104259:	83 c0 74             	add    $0x74,%eax
f010425c:	83 ec 08             	sub    $0x8,%esp
f010425f:	50                   	push   %eax
f0104260:	ff 75 08             	pushl  0x8(%ebp)
f0104263:	e8 e5 04 00 00       	call   f010474d <get_disk_page_directory>
f0104268:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426b:	8b 45 08             	mov    0x8(%ebp),%eax
f010426e:	8b 40 74             	mov    0x74(%eax),%eax
f0104271:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104274:	52                   	push   %edx
f0104275:	6a 01                	push   $0x1
f0104277:	ff 75 0c             	pushl  0xc(%ebp)
f010427a:	50                   	push   %eax
f010427b:	e8 64 fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104280:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104283:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104286:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104289:	c1 ea 0c             	shr    $0xc,%edx
f010428c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104292:	c1 e2 02             	shl    $0x2,%edx
f0104295:	01 d0                	add    %edx,%eax
f0104297:	8b 00                	mov    (%eax),%eax
f0104299:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f010429c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010429f:	85 c0                	test   %eax,%eax
f01042a1:	75 34                	jne    f01042d7 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a3:	83 ec 0c             	sub    $0xc,%esp
f01042a6:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042a9:	50                   	push   %eax
f01042aa:	e8 46 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042af:	83 c4 10             	add    $0x10,%esp
f01042b2:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042b5:	75 07                	jne    f01042be <pf_add_env_page+0x90>
f01042b7:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042bc:	eb 31                	jmp    f01042ef <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042c4:	c1 ea 0c             	shr    $0xc,%edx
f01042c7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042cd:	c1 e2 02             	shl    $0x2,%edx
f01042d0:	01 c2                	add    %eax,%edx
f01042d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042d5:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042da:	83 ec 08             	sub    $0x8,%esp
f01042dd:	ff 75 10             	pushl  0x10(%ebp)
f01042e0:	50                   	push   %eax
f01042e1:	e8 62 f9 ff ff       	call   f0103c48 <write_disk_page>
f01042e6:	83 c4 10             	add    $0x10,%esp
f01042e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042ef:	c9                   	leave  
f01042f0:	c3                   	ret    

f01042f1 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f1:	55                   	push   %ebp
f01042f2:	89 e5                	mov    %esp,%ebp
f01042f4:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042f7:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01042fe:	76 19                	jbe    f0104319 <pf_update_env_page+0x28>
f0104300:	68 30 3b 12 f0       	push   $0xf0123b30
f0104305:	68 56 3b 12 f0       	push   $0xf0123b56
f010430a:	68 13 01 00 00       	push   $0x113
f010430f:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0104314:	e8 20 c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104319:	8b 45 08             	mov    0x8(%ebp),%eax
f010431c:	83 c0 74             	add    $0x74,%eax
f010431f:	83 ec 08             	sub    $0x8,%esp
f0104322:	50                   	push   %eax
f0104323:	ff 75 08             	pushl  0x8(%ebp)
f0104326:	e8 22 04 00 00       	call   f010474d <get_disk_page_directory>
f010432b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010432e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104331:	8b 40 74             	mov    0x74(%eax),%eax
f0104334:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104337:	52                   	push   %edx
f0104338:	6a 00                	push   $0x0
f010433a:	ff 75 0c             	pushl  0xc(%ebp)
f010433d:	50                   	push   %eax
f010433e:	e8 a1 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f0104343:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104346:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104349:	85 c0                	test   %eax,%eax
f010434b:	74 29                	je     f0104376 <pf_update_env_page+0x85>
f010434d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104350:	85 c0                	test   %eax,%eax
f0104352:	0f 84 c5 00 00 00    	je     f010441d <pf_update_env_page+0x12c>
f0104358:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010435b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010435e:	c1 ea 0c             	shr    $0xc,%edx
f0104361:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104367:	c1 e2 02             	shl    $0x2,%edx
f010436a:	01 d0                	add    %edx,%eax
f010436c:	8b 00                	mov    (%eax),%eax
f010436e:	85 c0                	test   %eax,%eax
f0104370:	0f 85 a7 00 00 00    	jne    f010441d <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0104376:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104379:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f010437c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010437f:	85 c0                	test   %eax,%eax
f0104381:	79 09                	jns    f010438c <pf_update_env_page+0x9b>
f0104383:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f010438a:	76 30                	jbe    f01043bc <pf_update_env_page+0xcb>
f010438c:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0104393:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104396:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010439b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010439e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043a1:	ba 00 00 00 00       	mov    $0x0,%edx
f01043a6:	f7 75 f0             	divl   -0x10(%ebp)
f01043a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043ac:	29 d0                	sub    %edx,%eax
f01043ae:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043b1:	77 53                	ja     f0104406 <pf_update_env_page+0x115>
f01043b3:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043ba:	77 4a                	ja     f0104406 <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043bc:	83 ec 04             	sub    $0x4,%esp
f01043bf:	6a 00                	push   $0x0
f01043c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01043c4:	ff 75 08             	pushl  0x8(%ebp)
f01043c7:	e8 34 fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043cc:	83 c4 10             	add    $0x10,%esp
f01043cf:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043d2:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043d6:	75 17                	jne    f01043ef <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043d8:	83 ec 04             	sub    $0x4,%esp
f01043db:	68 6c 3b 12 f0       	push   $0xf0123b6c
f01043e0:	68 43 01 00 00       	push   $0x143
f01043e5:	68 9f 3a 12 f0       	push   $0xf0123a9f
f01043ea:	e8 4a bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01043f2:	8b 80 a8 05 00 00    	mov    0x5a8(%eax),%eax
f01043f8:	8d 50 01             	lea    0x1(%eax),%edx
f01043fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fe:	89 90 a8 05 00 00    	mov    %edx,0x5a8(%eax)
f0104404:	eb 17                	jmp    f010441d <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f0104406:	83 ec 04             	sub    $0x4,%esp
f0104409:	68 b8 3b 12 f0       	push   $0xf0123bb8
f010440e:	68 4c 01 00 00       	push   $0x14c
f0104413:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0104418:	e8 1c bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010441d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104420:	8b 40 74             	mov    0x74(%eax),%eax
f0104423:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104426:	52                   	push   %edx
f0104427:	6a 00                	push   $0x0
f0104429:	ff 75 0c             	pushl  0xc(%ebp)
f010442c:	50                   	push   %eax
f010442d:	e8 b2 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f0104432:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104435:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104438:	8b 55 0c             	mov    0xc(%ebp),%edx
f010443b:	c1 ea 0c             	shr    $0xc,%edx
f010443e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104444:	c1 e2 02             	shl    $0x2,%edx
f0104447:	01 d0                	add    %edx,%eax
f0104449:	8b 00                	mov    (%eax),%eax
f010444b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010444e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104451:	8b 40 64             	mov    0x64(%eax),%eax
f0104454:	6a 00                	push   $0x0
f0104456:	68 00 00 80 ef       	push   $0xef800000
f010445b:	ff 75 10             	pushl  0x10(%ebp)
f010445e:	50                   	push   %eax
f010445f:	e8 b0 41 00 00       	call   f0108614 <map_frame>
f0104464:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104467:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010446e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104471:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104476:	83 ec 08             	sub    $0x8,%esp
f0104479:	50                   	push   %eax
f010447a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010447d:	e8 c6 f7 ff ff       	call   f0103c48 <write_disk_page>
f0104482:	83 c4 10             	add    $0x10,%esp
f0104485:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104488:	8b 45 10             	mov    0x10(%ebp),%eax
f010448b:	8b 40 08             	mov    0x8(%eax),%eax
f010448e:	40                   	inc    %eax
f010448f:	8b 55 10             	mov    0x10(%ebp),%edx
f0104492:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f0104496:	8b 45 08             	mov    0x8(%ebp),%eax
f0104499:	8b 40 64             	mov    0x64(%eax),%eax
f010449c:	83 ec 08             	sub    $0x8,%esp
f010449f:	68 00 00 80 ef       	push   $0xef800000
f01044a4:	50                   	push   %eax
f01044a5:	e8 ca 42 00 00       	call   f0108774 <unmap_frame>
f01044aa:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044ad:	8b 45 10             	mov    0x10(%ebp),%eax
f01044b0:	8b 40 08             	mov    0x8(%eax),%eax
f01044b3:	48                   	dec    %eax
f01044b4:	8b 55 10             	mov    0x10(%ebp),%edx
f01044b7:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01044be:	8b 80 a4 05 00 00    	mov    0x5a4(%eax),%eax
f01044c4:	8d 50 01             	lea    0x1(%eax),%edx
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	89 90 a4 05 00 00    	mov    %edx,0x5a4(%eax)
	//======================

	return ret;
f01044d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044d3:	c9                   	leave  
f01044d4:	c3                   	ret    

f01044d5 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044d5:	55                   	push   %ebp
f01044d6:	89 e5                	mov    %esp,%ebp
f01044d8:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044e4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044e9:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ef:	8b 40 74             	mov    0x74(%eax),%eax
f01044f2:	85 c0                	test   %eax,%eax
f01044f4:	75 0a                	jne    f0104500 <pf_read_env_page+0x2b>
f01044f6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01044fb:	e9 90 00 00 00       	jmp    f0104590 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f0104500:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104503:	8b 45 08             	mov    0x8(%ebp),%eax
f0104506:	8b 40 74             	mov    0x74(%eax),%eax
f0104509:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010450c:	51                   	push   %ecx
f010450d:	6a 00                	push   $0x0
f010450f:	52                   	push   %edx
f0104510:	50                   	push   %eax
f0104511:	e8 ce fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104516:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104519:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010451c:	85 c0                	test   %eax,%eax
f010451e:	75 07                	jne    f0104527 <pf_read_env_page+0x52>
f0104520:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104525:	eb 69                	jmp    f0104590 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104527:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010452d:	c1 ea 0c             	shr    $0xc,%edx
f0104530:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104536:	c1 e2 02             	shl    $0x2,%edx
f0104539:	01 d0                	add    %edx,%eax
f010453b:	8b 00                	mov    (%eax),%eax
f010453d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104540:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104544:	75 07                	jne    f010454d <pf_read_env_page+0x78>
f0104546:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010454b:	eb 43                	jmp    f0104590 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010454d:	83 ec 08             	sub    $0x8,%esp
f0104550:	ff 75 0c             	pushl  0xc(%ebp)
f0104553:	ff 75 f0             	pushl  -0x10(%ebp)
f0104556:	e8 be f6 ff ff       	call   f0103c19 <read_disk_page>
f010455b:	83 c4 10             	add    $0x10,%esp
f010455e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104561:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104564:	8b 45 08             	mov    0x8(%ebp),%eax
f0104567:	8b 40 64             	mov    0x64(%eax),%eax
f010456a:	6a 40                	push   $0x40
f010456c:	6a 00                	push   $0x0
f010456e:	52                   	push   %edx
f010456f:	50                   	push   %eax
f0104570:	e8 12 48 00 00       	call   f0108d87 <pt_set_page_permissions>
f0104575:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0104578:	8b 45 08             	mov    0x8(%ebp),%eax
f010457b:	8b 80 a0 05 00 00    	mov    0x5a0(%eax),%eax
f0104581:	8d 50 01             	lea    0x1(%eax),%edx
f0104584:	8b 45 08             	mov    0x8(%ebp),%eax
f0104587:	89 90 a0 05 00 00    	mov    %edx,0x5a0(%eax)
	//======================

	return disk_read_error;
f010458d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104590:	c9                   	leave  
f0104591:	c3                   	ret    

f0104592 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104592:	55                   	push   %ebp
f0104593:	89 e5                	mov    %esp,%ebp
f0104595:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104598:	8b 45 08             	mov    0x8(%ebp),%eax
f010459b:	8b 40 74             	mov    0x74(%eax),%eax
f010459e:	85 c0                	test   %eax,%eax
f01045a0:	74 62                	je     f0104604 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01045a5:	8b 40 74             	mov    0x74(%eax),%eax
f01045a8:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045ab:	52                   	push   %edx
f01045ac:	6a 00                	push   $0x0
f01045ae:	ff 75 0c             	pushl  0xc(%ebp)
f01045b1:	50                   	push   %eax
f01045b2:	e8 2d fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045b7:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045bd:	85 c0                	test   %eax,%eax
f01045bf:	74 46                	je     f0104607 <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045c4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045c7:	c1 ea 0c             	shr    $0xc,%edx
f01045ca:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045d0:	c1 e2 02             	shl    $0x2,%edx
f01045d3:	01 d0                	add    %edx,%eax
f01045d5:	8b 00                	mov    (%eax),%eax
f01045d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045e0:	c1 ea 0c             	shr    $0xc,%edx
f01045e3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e9:	c1 e2 02             	shl    $0x2,%edx
f01045ec:	01 d0                	add    %edx,%eax
f01045ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01045f4:	83 ec 0c             	sub    $0xc,%esp
f01045f7:	ff 75 f4             	pushl  -0xc(%ebp)
f01045fa:	e8 e4 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01045ff:	83 c4 10             	add    $0x10,%esp
f0104602:	eb 04                	jmp    f0104608 <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104604:	90                   	nop
f0104605:	eb 01                	jmp    f0104608 <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f0104607:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104608:	c9                   	leave  
f0104609:	c3                   	ret    

f010460a <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f010460a:	55                   	push   %ebp
f010460b:	89 e5                	mov    %esp,%ebp
f010460d:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104610:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104617:	e9 b8 00 00 00       	jmp    f01046d4 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f010461c:	8b 45 08             	mov    0x8(%ebp),%eax
f010461f:	8b 40 74             	mov    0x74(%eax),%eax
f0104622:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104625:	c1 e2 02             	shl    $0x2,%edx
f0104628:	01 d0                	add    %edx,%eax
f010462a:	8b 00                	mov    (%eax),%eax
f010462c:	83 e0 01             	and    $0x1,%eax
f010462f:	85 c0                	test   %eax,%eax
f0104631:	0f 84 99 00 00 00    	je     f01046d0 <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104637:	8b 45 08             	mov    0x8(%ebp),%eax
f010463a:	8b 40 74             	mov    0x74(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010464c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010464f:	83 ec 0c             	sub    $0xc,%esp
f0104652:	ff 75 ec             	pushl  -0x14(%ebp)
f0104655:	e8 06 47 00 00       	call   f0108d60 <kheap_virtual_address>
f010465a:	83 c4 10             	add    $0x10,%esp
f010465d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0104660:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104667:	eb 3a                	jmp    f01046a3 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104669:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010466c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104673:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104676:	01 d0                	add    %edx,%eax
f0104678:	8b 00                	mov    (%eax),%eax
f010467a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010467d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104680:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104687:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010468a:	01 d0                	add    %edx,%eax
f010468c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0104692:	83 ec 0c             	sub    $0xc,%esp
f0104695:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104698:	e8 46 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f010469d:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046a0:	ff 45 f0             	incl   -0x10(%ebp)
f01046a3:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046aa:	76 bd                	jbe    f0104669 <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01046af:	8b 40 74             	mov    0x74(%eax),%eax
f01046b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046b5:	c1 e2 02             	shl    $0x2,%edx
f01046b8:	01 d0                	add    %edx,%eax
f01046ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046c0:	83 ec 0c             	sub    $0xc,%esp
f01046c3:	ff 75 e8             	pushl  -0x18(%ebp)
f01046c6:	e8 5b 46 00 00       	call   f0108d26 <kfree>
f01046cb:	83 c4 10             	add    $0x10,%esp
f01046ce:	eb 01                	jmp    f01046d1 <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046d0:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046d1:	ff 45 f4             	incl   -0xc(%ebp)
f01046d4:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046db:	0f 86 3b ff ff ff    	jbe    f010461c <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01046e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01046e4:	8b 40 74             	mov    0x74(%eax),%eax
f01046e7:	83 ec 0c             	sub    $0xc,%esp
f01046ea:	50                   	push   %eax
f01046eb:	e8 36 46 00 00       	call   f0108d26 <kfree>
f01046f0:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f01046f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01046f6:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01046fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0104700:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104707:	8b 45 08             	mov    0x8(%ebp),%eax
f010470a:	8b 40 7c             	mov    0x7c(%eax),%eax
f010470d:	85 c0                	test   %eax,%eax
f010470f:	74 39                	je     f010474a <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f0104711:	83 ec 0c             	sub    $0xc,%esp
f0104714:	ff 75 08             	pushl  0x8(%ebp)
f0104717:	e8 f1 02 00 00       	call   f0104a0d <__pf_remove_env_all_tables>
f010471c:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010471f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104722:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104725:	83 ec 0c             	sub    $0xc,%esp
f0104728:	50                   	push   %eax
f0104729:	e8 f8 45 00 00       	call   f0108d26 <kfree>
f010472e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f010473b:	8b 45 08             	mov    0x8(%ebp),%eax
f010473e:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104745:	00 00 00 
f0104748:	eb 01                	jmp    f010474b <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010474a:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010474b:	c9                   	leave  
f010474c:	c3                   	ret    

f010474d <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010474d:	55                   	push   %ebp
f010474e:	89 e5                	mov    %esp,%ebp
f0104750:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104753:	8b 45 08             	mov    0x8(%ebp),%eax
f0104756:	8b 50 74             	mov    0x74(%eax),%edx
f0104759:	8b 45 0c             	mov    0xc(%ebp),%eax
f010475c:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f010475e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104761:	8b 00                	mov    (%eax),%eax
f0104763:	85 c0                	test   %eax,%eax
f0104765:	75 58                	jne    f01047bf <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f0104767:	83 ec 0c             	sub    $0xc,%esp
f010476a:	68 00 10 00 00       	push   $0x1000
f010476f:	e8 98 45 00 00       	call   f0108d0c <kmalloc>
f0104774:	83 c4 10             	add    $0x10,%esp
f0104777:	89 c2                	mov    %eax,%edx
f0104779:	8b 45 0c             	mov    0xc(%ebp),%eax
f010477c:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f010477e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104781:	8b 00                	mov    (%eax),%eax
f0104783:	85 c0                	test   %eax,%eax
f0104785:	75 07                	jne    f010478e <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f0104787:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010478c:	eb 36                	jmp    f01047c4 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f010478e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104791:	8b 00                	mov    (%eax),%eax
f0104793:	83 ec 0c             	sub    $0xc,%esp
f0104796:	50                   	push   %eax
f0104797:	e8 a7 45 00 00       	call   f0108d43 <kheap_physical_address>
f010479c:	83 c4 10             	add    $0x10,%esp
f010479f:	89 c2                	mov    %eax,%edx
f01047a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a4:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047aa:	8b 00                	mov    (%eax),%eax
f01047ac:	83 ec 04             	sub    $0x4,%esp
f01047af:	68 00 10 00 00       	push   $0x1000
f01047b4:	6a 00                	push   $0x0
f01047b6:	50                   	push   %eax
f01047b7:	e8 21 a2 01 00       	call   f011e9dd <memset>
f01047bc:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047c4:	c9                   	leave  
f01047c5:	c3                   	ret    

f01047c6 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047c6:	55                   	push   %ebp
f01047c7:	89 e5                	mov    %esp,%ebp
f01047c9:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f01047cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01047d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01047da:	eb 78                	jmp    f0104854 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f01047dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01047df:	8b 40 74             	mov    0x74(%eax),%eax
f01047e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01047e5:	c1 e2 02             	shl    $0x2,%edx
f01047e8:	01 d0                	add    %edx,%eax
f01047ea:	8b 00                	mov    (%eax),%eax
f01047ec:	83 e0 01             	and    $0x1,%eax
f01047ef:	85 c0                	test   %eax,%eax
f01047f1:	74 5d                	je     f0104850 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01047f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01047f6:	8b 40 74             	mov    0x74(%eax),%eax
f01047f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01047fc:	c1 e2 02             	shl    $0x2,%edx
f01047ff:	01 d0                	add    %edx,%eax
f0104801:	8b 00                	mov    (%eax),%eax
f0104803:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104808:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010480b:	83 ec 0c             	sub    $0xc,%esp
f010480e:	ff 75 e8             	pushl  -0x18(%ebp)
f0104811:	e8 4a 45 00 00       	call   f0108d60 <kheap_virtual_address>
f0104816:	83 c4 10             	add    $0x10,%esp
f0104819:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010481c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104823:	eb 20                	jmp    f0104845 <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104825:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104828:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010482f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104832:	01 d0                	add    %edx,%eax
f0104834:	8b 00                	mov    (%eax),%eax
f0104836:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104839:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010483d:	74 03                	je     f0104842 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f010483f:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104842:	ff 45 ec             	incl   -0x14(%ebp)
f0104845:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010484c:	76 d7                	jbe    f0104825 <pf_calculate_allocated_pages+0x5f>
f010484e:	eb 01                	jmp    f0104851 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104850:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104851:	ff 45 f4             	incl   -0xc(%ebp)
f0104854:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010485b:	0f 86 7b ff ff ff    	jbe    f01047dc <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104861:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104864:	c9                   	leave  
f0104865:	c3                   	ret    

f0104866 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104866:	55                   	push   %ebp
f0104867:	89 e5                	mov    %esp,%ebp
f0104869:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f010486c:	83 ec 0c             	sub    $0xc,%esp
f010486f:	68 70 cb 5e f0       	push   $0xf05ecb70
f0104874:	e8 e9 9f 00 00       	call   f010e862 <acquire_spinlock>
f0104879:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010487c:	a1 6c cb 5e f0       	mov    0xf05ecb6c,%eax
f0104881:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104884:	83 ec 0c             	sub    $0xc,%esp
f0104887:	68 70 cb 5e f0       	push   $0xf05ecb70
f010488c:	e8 58 a0 00 00       	call   f010e8e9 <release_spinlock>
f0104891:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104894:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104897:	c9                   	leave  
f0104898:	c3                   	ret    

f0104899 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104899:	55                   	push   %ebp
f010489a:	89 e5                	mov    %esp,%ebp
f010489c:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f010489f:	8b 45 08             	mov    0x8(%ebp),%eax
f01048a2:	8b 50 7c             	mov    0x7c(%eax),%edx
f01048a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048a8:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ad:	8b 00                	mov    (%eax),%eax
f01048af:	85 c0                	test   %eax,%eax
f01048b1:	75 5b                	jne    f010490e <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048b3:	83 ec 0c             	sub    $0xc,%esp
f01048b6:	68 00 10 00 00       	push   $0x1000
f01048bb:	e8 4c 44 00 00       	call   f0108d0c <kmalloc>
f01048c0:	83 c4 10             	add    $0x10,%esp
f01048c3:	89 c2                	mov    %eax,%edx
f01048c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048c8:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f01048ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048cd:	8b 00                	mov    (%eax),%eax
f01048cf:	85 c0                	test   %eax,%eax
f01048d1:	75 07                	jne    f01048da <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f01048d3:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01048d8:	eb 39                	jmp    f0104913 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f01048da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048dd:	8b 00                	mov    (%eax),%eax
f01048df:	83 ec 0c             	sub    $0xc,%esp
f01048e2:	50                   	push   %eax
f01048e3:	e8 5b 44 00 00       	call   f0108d43 <kheap_physical_address>
f01048e8:	83 c4 10             	add    $0x10,%esp
f01048eb:	89 c2                	mov    %eax,%edx
f01048ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01048f0:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01048f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048f9:	8b 00                	mov    (%eax),%eax
f01048fb:	83 ec 04             	sub    $0x4,%esp
f01048fe:	68 00 10 00 00       	push   $0x1000
f0104903:	6a 00                	push   $0x0
f0104905:	50                   	push   %eax
f0104906:	e8 d2 a0 01 00       	call   f011e9dd <memset>
f010490b:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010490e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104913:	c9                   	leave  
f0104914:	c3                   	ret    

f0104915 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104915:	55                   	push   %ebp
f0104916:	89 e5                	mov    %esp,%ebp
f0104918:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010491b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104922:	76 19                	jbe    f010493d <__pf_write_env_table+0x28>
f0104924:	68 30 3b 12 f0       	push   $0xf0123b30
f0104929:	68 56 3b 12 f0       	push   $0xf0123b56
f010492e:	68 91 02 00 00       	push   $0x291
f0104933:	68 9f 3a 12 f0       	push   $0xf0123a9f
f0104938:	e8 fc b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010493d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104940:	83 c0 7c             	add    $0x7c,%eax
f0104943:	83 ec 08             	sub    $0x8,%esp
f0104946:	50                   	push   %eax
f0104947:	ff 75 08             	pushl  0x8(%ebp)
f010494a:	e8 4a ff ff ff       	call   f0104899 <get_disk_table_directory>
f010494f:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104952:	8b 45 08             	mov    0x8(%ebp),%eax
f0104955:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104958:	8b 55 0c             	mov    0xc(%ebp),%edx
f010495b:	c1 ea 16             	shr    $0x16,%edx
f010495e:	c1 e2 02             	shl    $0x2,%edx
f0104961:	01 d0                	add    %edx,%eax
f0104963:	8b 00                	mov    (%eax),%eax
f0104965:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104968:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010496b:	85 c0                	test   %eax,%eax
f010496d:	75 31                	jne    f01049a0 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010496f:	83 ec 0c             	sub    $0xc,%esp
f0104972:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104975:	50                   	push   %eax
f0104976:	e8 7a f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f010497b:	83 c4 10             	add    $0x10,%esp
f010497e:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104981:	75 07                	jne    f010498a <__pf_write_env_table+0x75>
f0104983:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104988:	eb 2e                	jmp    f01049b8 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f010498a:	8b 45 08             	mov    0x8(%ebp),%eax
f010498d:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104990:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104993:	c1 ea 16             	shr    $0x16,%edx
f0104996:	c1 e2 02             	shl    $0x2,%edx
f0104999:	01 c2                	add    %eax,%edx
f010499b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010499e:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049a3:	83 ec 08             	sub    $0x8,%esp
f01049a6:	ff 75 10             	pushl  0x10(%ebp)
f01049a9:	50                   	push   %eax
f01049aa:	e8 99 f2 ff ff       	call   f0103c48 <write_disk_page>
f01049af:	83 c4 10             	add    $0x10,%esp
f01049b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01049b8:	c9                   	leave  
f01049b9:	c3                   	ret    

f01049ba <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01049ba:	55                   	push   %ebp
f01049bb:	89 e5                	mov    %esp,%ebp
f01049bd:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01049c3:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049c6:	85 c0                	test   %eax,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_read_env_table+0x17>
f01049ca:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049cf:	eb 3a                	jmp    f0104a0b <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049d7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049da:	c1 ea 16             	shr    $0x16,%edx
f01049dd:	c1 e2 02             	shl    $0x2,%edx
f01049e0:	01 d0                	add    %edx,%eax
f01049e2:	8b 00                	mov    (%eax),%eax
f01049e4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01049eb:	75 07                	jne    f01049f4 <__pf_read_env_table+0x3a>
f01049ed:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049f2:	eb 17                	jmp    f0104a0b <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f01049f4:	83 ec 08             	sub    $0x8,%esp
f01049f7:	ff 75 10             	pushl  0x10(%ebp)
f01049fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01049fd:	e8 17 f2 ff ff       	call   f0103c19 <read_disk_page>
f0104a02:	83 c4 10             	add    $0x10,%esp
f0104a05:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a08:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a0b:	c9                   	leave  
f0104a0c:	c3                   	ret    

f0104a0d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a0d:	55                   	push   %ebp
f0104a0e:	89 e5                	mov    %esp,%ebp
f0104a10:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a13:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a16:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a19:	85 c0                	test   %eax,%eax
f0104a1b:	74 4c                	je     f0104a69 <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a24:	eb 38                	jmp    f0104a5e <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a26:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a29:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a2f:	c1 e2 02             	shl    $0x2,%edx
f0104a32:	01 d0                	add    %edx,%eax
f0104a34:	8b 00                	mov    (%eax),%eax
f0104a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a3c:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a42:	c1 e2 02             	shl    $0x2,%edx
f0104a45:	01 d0                	add    %edx,%eax
f0104a47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104a4d:	83 ec 0c             	sub    $0xc,%esp
f0104a50:	ff 75 f0             	pushl  -0x10(%ebp)
f0104a53:	e8 8b f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104a58:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a5b:	ff 45 f4             	incl   -0xc(%ebp)
f0104a5e:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a65:	76 bf                	jbe    f0104a26 <__pf_remove_env_all_tables+0x19>
f0104a67:	eb 01                	jmp    f0104a6a <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a69:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104a6a:	c9                   	leave  
f0104a6b:	c3                   	ret    

f0104a6c <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104a6c:	55                   	push   %ebp
f0104a6d:	89 e5                	mov    %esp,%ebp
f0104a6f:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104a72:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104a76:	75 10                	jne    f0104a88 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104a78:	83 ec 0c             	sub    $0xc,%esp
f0104a7b:	68 34 3c 12 f0       	push   $0xf0123c34
f0104a80:	e8 06 c5 ff ff       	call   f0100f8b <cprintf>
f0104a85:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a88:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a8b:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a8e:	85 c0                	test   %eax,%eax
f0104a90:	74 3d                	je     f0104acf <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a95:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a98:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a9b:	c1 ea 16             	shr    $0x16,%edx
f0104a9e:	c1 e2 02             	shl    $0x2,%edx
f0104aa1:	01 d0                	add    %edx,%eax
f0104aa3:	8b 00                	mov    (%eax),%eax
f0104aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104aa8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104aab:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104aae:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ab1:	c1 ea 16             	shr    $0x16,%edx
f0104ab4:	c1 e2 02             	shl    $0x2,%edx
f0104ab7:	01 d0                	add    %edx,%eax
f0104ab9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104abf:	83 ec 0c             	sub    $0xc,%esp
f0104ac2:	ff 75 f4             	pushl  -0xc(%ebp)
f0104ac5:	e8 19 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104aca:	83 c4 10             	add    $0x10,%esp
f0104acd:	eb 01                	jmp    f0104ad0 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104acf:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104ad0:	c9                   	leave  
f0104ad1:	c3                   	ret    

f0104ad2 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104ad2:	55                   	push   %ebp
f0104ad3:	89 e5                	mov    %esp,%ebp
f0104ad5:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104ad8:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104adf:	eb 1f                	jmp    f0104b00 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ae4:	83 ec 04             	sub    $0x4,%esp
f0104ae7:	6a 08                	push   $0x8
f0104ae9:	ff 75 08             	pushl  0x8(%ebp)
f0104aec:	50                   	push   %eax
f0104aed:	e8 25 a6 01 00       	call   f011f117 <ide_write>
f0104af2:	83 c4 10             	add    $0x10,%esp
f0104af5:	85 c0                	test   %eax,%eax
f0104af7:	75 12                	jne    f0104b0b <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104af9:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b00:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b07:	7e d8                	jle    f0104ae1 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b09:	eb 01                	jmp    f0104b0c <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b0b:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b0c:	90                   	nop
f0104b0d:	c9                   	leave  
f0104b0e:	c3                   	ret    

f0104b0f <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b0f:	55                   	push   %ebp
  pushl %eax
f0104b10:	50                   	push   %eax
  pushl %ebx
f0104b11:	53                   	push   %ebx
  pushl %ecx
f0104b12:	51                   	push   %ecx
  pushl %edx
f0104b13:	52                   	push   %edx
  pushl %esi
f0104b14:	56                   	push   %esi
  pushl %edi
f0104b15:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b16:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b1a:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b1e:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b20:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b22:	5f                   	pop    %edi
  popl %esi
f0104b23:	5e                   	pop    %esi
  popl %edx
f0104b24:	5a                   	pop    %edx
  popl %ecx
f0104b25:	59                   	pop    %ecx
  popl %ebx
f0104b26:	5b                   	pop    %ebx
  popl %eax
f0104b27:	58                   	pop    %eax
  popl %ebp
f0104b28:	5d                   	pop    %ebp
  ret
f0104b29:	c3                   	ret    

f0104b2a <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b2a:	55                   	push   %ebp
f0104b2b:	89 e5                	mov    %esp,%ebp
f0104b2d:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b30:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b33:	0f b6 c0             	movzbl %al,%eax
f0104b36:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b3d:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b40:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b43:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b46:	ee                   	out    %al,(%dx)
f0104b47:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104b51:	89 c2                	mov    %eax,%edx
f0104b53:	ec                   	in     (%dx),%al
f0104b54:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104b57:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104b5a:	0f b6 c0             	movzbl %al,%eax
}
f0104b5d:	c9                   	leave  
f0104b5e:	c3                   	ret    

f0104b5f <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104b5f:	55                   	push   %ebp
f0104b60:	89 e5                	mov    %esp,%ebp
f0104b62:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b65:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b68:	0f b6 c0             	movzbl %al,%eax
f0104b6b:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b72:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b75:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b78:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b7b:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104b7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b7f:	0f b6 c0             	movzbl %al,%eax
f0104b82:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104b89:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104b8c:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104b8f:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104b92:	ee                   	out    %al,(%dx)
}
f0104b93:	90                   	nop
f0104b94:	c9                   	leave  
f0104b95:	c3                   	ret    

f0104b96 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104b96:	55                   	push   %ebp
f0104b97:	89 e5                	mov    %esp,%ebp
f0104b99:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104b9c:	c7 05 48 cb 5e f0 00 	movl   $0x0,0xf05ecb48
f0104ba3:	00 00 00 
f0104ba6:	c7 05 4c cb 5e f0 00 	movl   $0x0,0xf05ecb4c
f0104bad:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104bb0:	83 ec 08             	sub    $0x8,%esp
f0104bb3:	68 54 6b 10 f0       	push   $0xf0106b54
f0104bb8:	6a 00                	push   $0x0
f0104bba:	e8 b4 84 00 00       	call   f010d073 <irq_install_handler>
f0104bbf:	83 c4 10             	add    $0x10,%esp
}
f0104bc2:	90                   	nop
f0104bc3:	c9                   	leave  
f0104bc4:	c3                   	ret    

f0104bc5 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104bc5:	55                   	push   %ebp
f0104bc6:	89 e5                	mov    %esp,%ebp
f0104bc8:	53                   	push   %ebx
f0104bc9:	83 ec 24             	sub    $0x24,%esp
f0104bcc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bcf:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104bd2:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104bd9:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104bdd:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104be0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104be3:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104be4:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104be8:	77 48                	ja     f0104c32 <kclock_start+0x6d>
f0104bea:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104bf1:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104bf5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104bf8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104bfb:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104bfc:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c00:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c05:	99                   	cltd   
f0104c06:	f7 fb                	idiv   %ebx
f0104c08:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c0e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c12:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c17:	99                   	cltd   
f0104c18:	f7 fb                	idiv   %ebx
f0104c1a:	89 c3                	mov    %eax,%ebx
f0104c1c:	89 c8                	mov    %ecx,%eax
f0104c1e:	99                   	cltd   
f0104c1f:	f7 fb                	idiv   %ebx
f0104c21:	0f b7 c0             	movzwl %ax,%eax
f0104c24:	83 ec 0c             	sub    $0xc,%esp
f0104c27:	50                   	push   %eax
f0104c28:	e8 b3 01 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104c2d:	83 c4 10             	add    $0x10,%esp
f0104c30:	eb 13                	jmp    f0104c45 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c32:	6a 35                	push   $0x35
f0104c34:	68 58 3c 12 f0       	push   $0xf0123c58
f0104c39:	6a 41                	push   $0x41
f0104c3b:	68 b4 3c 12 f0       	push   $0xf0123cb4
f0104c40:	e8 f4 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104c45:	83 ec 0c             	sub    $0xc,%esp
f0104c48:	6a 00                	push   $0x0
f0104c4a:	e8 3a 23 00 00       	call   f0106f89 <irq_clear_mask>
f0104c4f:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104c52:	90                   	nop
f0104c53:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104c56:	c9                   	leave  
f0104c57:	c3                   	ret    

f0104c58 <kclock_stop>:

void
kclock_stop(void)
{
f0104c58:	55                   	push   %ebp
f0104c59:	89 e5                	mov    %esp,%ebp
f0104c5b:	83 ec 18             	sub    $0x18,%esp
f0104c5e:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c65:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104c69:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104c6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c6f:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104c70:	83 ec 0c             	sub    $0xc,%esp
f0104c73:	6a 00                	push   $0x0
f0104c75:	e8 9a 22 00 00       	call   f0106f14 <irq_set_mask>
f0104c7a:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104c7d:	90                   	nop
f0104c7e:	c9                   	leave  
f0104c7f:	c3                   	ret    

f0104c80 <kclock_resume>:

void
kclock_resume(void)
{
f0104c80:	55                   	push   %ebp
f0104c81:	89 e5                	mov    %esp,%ebp
f0104c83:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104c86:	e8 f5 01 00 00       	call   f0104e80 <kclock_read_cnt0_latch>
f0104c8b:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104c8f:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104c94:	77 06                	ja     f0104c9c <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104c96:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104c9c:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104ca0:	83 e0 01             	and    $0x1,%eax
f0104ca3:	66 85 c0             	test   %ax,%ax
f0104ca6:	74 09                	je     f0104cb1 <kclock_resume+0x31>
		cnt0++;
f0104ca8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104cac:	40                   	inc    %eax
f0104cad:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104cb1:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104cb8:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104cbc:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104cbf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104cc2:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104cc3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104cc7:	83 ec 0c             	sub    $0xc,%esp
f0104cca:	50                   	push   %eax
f0104ccb:	e8 10 01 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104cd0:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104cd3:	83 ec 0c             	sub    $0xc,%esp
f0104cd6:	6a 00                	push   $0x0
f0104cd8:	e8 ac 22 00 00       	call   f0106f89 <irq_clear_mask>
f0104cdd:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104ce0:	90                   	nop
f0104ce1:	c9                   	leave  
f0104ce2:	c3                   	ret    

f0104ce3 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104ce3:	55                   	push   %ebp
f0104ce4:	89 e5                	mov    %esp,%ebp
f0104ce6:	83 ec 28             	sub    $0x28,%esp
f0104ce9:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cec:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104cef:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cf6:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104cfa:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cfd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d00:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d01:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d05:	83 ec 0c             	sub    $0xc,%esp
f0104d08:	50                   	push   %eax
f0104d09:	e8 d2 00 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104d0e:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d11:	83 ec 0c             	sub    $0xc,%esp
f0104d14:	6a 00                	push   $0x0
f0104d16:	e8 6e 22 00 00       	call   f0106f89 <irq_clear_mask>
f0104d1b:	83 c4 10             	add    $0x10,%esp
}
f0104d1e:	90                   	nop
f0104d1f:	c9                   	leave  
f0104d20:	c3                   	ret    

f0104d21 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d21:	55                   	push   %ebp
f0104d22:	89 e5                	mov    %esp,%ebp
f0104d24:	56                   	push   %esi
f0104d25:	53                   	push   %ebx
f0104d26:	83 ec 20             	sub    $0x20,%esp
f0104d29:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d2c:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d2f:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d33:	0f 87 8a 00 00 00    	ja     f0104dc3 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d39:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d3d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d42:	99                   	cltd   
f0104d43:	f7 fe                	idiv   %esi
f0104d45:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d4b:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104d4f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d54:	99                   	cltd   
f0104d55:	f7 fb                	idiv   %ebx
f0104d57:	89 c6                	mov    %eax,%esi
f0104d59:	89 c8                	mov    %ecx,%eax
f0104d5b:	99                   	cltd   
f0104d5c:	f7 fe                	idiv   %esi
f0104d5e:	89 c3                	mov    %eax,%ebx
f0104d60:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104d64:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d69:	99                   	cltd   
f0104d6a:	f7 f9                	idiv   %ecx
f0104d6c:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d72:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d76:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d7b:	99                   	cltd   
f0104d7c:	f7 fe                	idiv   %esi
f0104d7e:	89 c6                	mov    %eax,%esi
f0104d80:	89 c8                	mov    %ecx,%eax
f0104d82:	99                   	cltd   
f0104d83:	f7 fe                	idiv   %esi
f0104d85:	25 01 00 00 80       	and    $0x80000001,%eax
f0104d8a:	85 c0                	test   %eax,%eax
f0104d8c:	79 05                	jns    f0104d93 <kclock_set_quantum+0x72>
f0104d8e:	48                   	dec    %eax
f0104d8f:	83 c8 fe             	or     $0xfffffffe,%eax
f0104d92:	40                   	inc    %eax
f0104d93:	01 d8                	add    %ebx,%eax
f0104d95:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104d98:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d9f:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104da3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104da6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104da9:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104dad:	0f b7 c0             	movzwl %ax,%eax
f0104db0:	83 ec 0c             	sub    $0xc,%esp
f0104db3:	50                   	push   %eax
f0104db4:	e8 27 00 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104db9:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104dbc:	e8 97 fe ff ff       	call   f0104c58 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104dc1:	eb 16                	jmp    f0104dd9 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104dc3:	6a 35                	push   $0x35
f0104dc5:	68 58 3c 12 f0       	push   $0xf0123c58
f0104dca:	68 ea 00 00 00       	push   $0xea
f0104dcf:	68 b4 3c 12 f0       	push   $0xf0123cb4
f0104dd4:	e8 60 b5 ff ff       	call   f0100339 <_panic>
	}
}
f0104dd9:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104ddc:	5b                   	pop    %ebx
f0104ddd:	5e                   	pop    %esi
f0104dde:	5d                   	pop    %ebp
f0104ddf:	c3                   	ret    

f0104de0 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104de0:	55                   	push   %ebp
f0104de1:	89 e5                	mov    %esp,%ebp
f0104de3:	83 ec 28             	sub    $0x28,%esp
f0104de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0104de9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104ded:	e8 72 23 00 00       	call   f0107164 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104df2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104df5:	0f b6 c0             	movzbl %al,%eax
f0104df8:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104dff:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e02:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e08:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e0c:	66 c1 e8 08          	shr    $0x8,%ax
f0104e10:	0f b6 c0             	movzbl %al,%eax
f0104e13:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e1a:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e1d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e20:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e23:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e24:	e8 8d 23 00 00       	call   f01071b6 <popcli>

}
f0104e29:	90                   	nop
f0104e2a:	c9                   	leave  
f0104e2b:	c3                   	ret    

f0104e2c <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e2c:	55                   	push   %ebp
f0104e2d:	89 e5                	mov    %esp,%ebp
f0104e2f:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e32:	e8 2d 23 00 00       	call   f0107164 <pushcli>
f0104e37:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e41:	89 c2                	mov    %eax,%edx
f0104e43:	ec                   	in     (%dx),%al
f0104e44:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104e47:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104e4a:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104e4d:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e54:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104e57:	89 c2                	mov    %eax,%edx
f0104e59:	ec                   	in     (%dx),%al
f0104e5a:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104e5d:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104e60:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104e63:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104e67:	c1 e0 08             	shl    $0x8,%eax
f0104e6a:	89 c2                	mov    %eax,%edx
f0104e6c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104e70:	09 d0                	or     %edx,%eax
f0104e72:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104e76:	e8 3b 23 00 00       	call   f01071b6 <popcli>
	return cnt0 ;
f0104e7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104e7e:	c9                   	leave  
f0104e7f:	c3                   	ret    

f0104e80 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104e80:	55                   	push   %ebp
f0104e81:	89 e5                	mov    %esp,%ebp
f0104e83:	83 ec 30             	sub    $0x30,%esp
f0104e86:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104e90:	89 c2                	mov    %eax,%edx
f0104e92:	ec                   	in     (%dx),%al
f0104e93:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104e96:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104e99:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104e9c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104ea3:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ea7:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ead:	ee                   	out    %al,(%dx)
f0104eae:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104eb8:	89 c2                	mov    %eax,%edx
f0104eba:	ec                   	in     (%dx),%al
f0104ebb:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104ebe:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104ec1:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104ec4:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ecb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104ece:	89 c2                	mov    %eax,%edx
f0104ed0:	ec                   	in     (%dx),%al
f0104ed1:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104ed4:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ed7:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104eda:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104ede:	c1 e0 08             	shl    $0x8,%eax
f0104ee1:	89 c2                	mov    %eax,%edx
f0104ee3:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104ee7:	09 d0                	or     %edx,%eax
f0104ee9:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104eed:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104ef1:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104ef8:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104efb:	8a 45 df             	mov    -0x21(%ebp),%al
f0104efe:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f01:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f02:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f05:	c9                   	leave  
f0104f06:	c3                   	ret    

f0104f07 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f07:	55                   	push   %ebp
f0104f08:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f0a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f0e:	74 1d                	je     f0104f2d <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f10:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f19:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f1c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f23:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f26:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f2d:	90                   	nop
f0104f2e:	5d                   	pop    %ebp
f0104f2f:	c3                   	ret    

f0104f30 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f30:	55                   	push   %ebp
f0104f31:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f33:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f37:	74 08                	je     f0104f41 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f3c:	8b 40 0c             	mov    0xc(%eax),%eax
f0104f3f:	eb 05                	jmp    f0104f46 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104f41:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104f46:	5d                   	pop    %ebp
f0104f47:	c3                   	ret    

f0104f48 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104f48:	55                   	push   %ebp
f0104f49:	89 e5                	mov    %esp,%ebp
f0104f4b:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104f4e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f52:	75 16                	jne    f0104f6a <enqueue+0x22>
f0104f54:	68 c8 3c 12 f0       	push   $0xf0123cc8
f0104f59:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0104f5e:	6a 34                	push   $0x34
f0104f60:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0104f65:	e8 cf b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104f6a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f6e:	74 66                	je     f0104fd6 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104f70:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f74:	75 14                	jne    f0104f8a <enqueue+0x42>
f0104f76:	83 ec 04             	sub    $0x4,%esp
f0104f79:	68 04 3d 12 f0       	push   $0xf0123d04
f0104f7e:	6a 37                	push   $0x37
f0104f80:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0104f85:	e8 af b3 ff ff       	call   f0100339 <_panic>
f0104f8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f8d:	8b 10                	mov    (%eax),%edx
f0104f8f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104f92:	89 50 08             	mov    %edx,0x8(%eax)
f0104f95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104f98:	8b 40 08             	mov    0x8(%eax),%eax
f0104f9b:	85 c0                	test   %eax,%eax
f0104f9d:	74 0d                	je     f0104fac <enqueue+0x64>
f0104f9f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fa2:	8b 00                	mov    (%eax),%eax
f0104fa4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fa7:	89 50 0c             	mov    %edx,0xc(%eax)
f0104faa:	eb 09                	jmp    f0104fb5 <enqueue+0x6d>
f0104fac:	8b 45 08             	mov    0x8(%ebp),%eax
f0104faf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fb2:	89 50 04             	mov    %edx,0x4(%eax)
f0104fb5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fb8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fbb:	89 10                	mov    %edx,(%eax)
f0104fbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fc0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104fc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fca:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fcd:	8d 50 01             	lea    0x1(%eax),%edx
f0104fd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fd3:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104fd6:	90                   	nop
f0104fd7:	c9                   	leave  
f0104fd8:	c3                   	ret    

f0104fd9 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0104fd9:	55                   	push   %ebp
f0104fda:	89 e5                	mov    %esp,%ebp
f0104fdc:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0104fdf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fe3:	75 0a                	jne    f0104fef <dequeue+0x16>
f0104fe5:	b8 00 00 00 00       	mov    $0x0,%eax
f0104fea:	e9 a0 00 00 00       	jmp    f010508f <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0104fef:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ff2:	8b 40 04             	mov    0x4(%eax),%eax
f0104ff5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0104ff8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104ffc:	0f 84 8a 00 00 00    	je     f010508c <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105002:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105006:	75 14                	jne    f010501c <dequeue+0x43>
f0105008:	83 ec 04             	sub    $0x4,%esp
f010500b:	68 27 3d 12 f0       	push   $0xf0123d27
f0105010:	6a 44                	push   $0x44
f0105012:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105017:	e8 1d b3 ff ff       	call   f0100339 <_panic>
f010501c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010501f:	8b 40 08             	mov    0x8(%eax),%eax
f0105022:	85 c0                	test   %eax,%eax
f0105024:	74 11                	je     f0105037 <dequeue+0x5e>
f0105026:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105029:	8b 40 08             	mov    0x8(%eax),%eax
f010502c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010502f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105032:	89 50 0c             	mov    %edx,0xc(%eax)
f0105035:	eb 0c                	jmp    f0105043 <dequeue+0x6a>
f0105037:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010503a:	8b 50 0c             	mov    0xc(%eax),%edx
f010503d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105040:	89 50 04             	mov    %edx,0x4(%eax)
f0105043:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105046:	8b 40 0c             	mov    0xc(%eax),%eax
f0105049:	85 c0                	test   %eax,%eax
f010504b:	74 11                	je     f010505e <dequeue+0x85>
f010504d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105050:	8b 40 0c             	mov    0xc(%eax),%eax
f0105053:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105056:	8b 52 08             	mov    0x8(%edx),%edx
f0105059:	89 50 08             	mov    %edx,0x8(%eax)
f010505c:	eb 0b                	jmp    f0105069 <dequeue+0x90>
f010505e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105061:	8b 50 08             	mov    0x8(%eax),%edx
f0105064:	8b 45 08             	mov    0x8(%ebp),%eax
f0105067:	89 10                	mov    %edx,(%eax)
f0105069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010506c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105073:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105076:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010507d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105080:	8b 40 0c             	mov    0xc(%eax),%eax
f0105083:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105086:	8b 45 08             	mov    0x8(%ebp),%eax
f0105089:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f010508c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010508f:	c9                   	leave  
f0105090:	c3                   	ret    

f0105091 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0105091:	55                   	push   %ebp
f0105092:	89 e5                	mov    %esp,%ebp
f0105094:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0105097:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010509b:	75 16                	jne    f01050b3 <remove_from_queue+0x22>
f010509d:	68 c8 3c 12 f0       	push   $0xf0123cc8
f01050a2:	68 d6 3c 12 f0       	push   $0xf0123cd6
f01050a7:	6a 4e                	push   $0x4e
f01050a9:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01050ae:	e8 86 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f01050b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050b7:	0f 84 8a 00 00 00    	je     f0105147 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f01050bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050c1:	75 14                	jne    f01050d7 <remove_from_queue+0x46>
f01050c3:	83 ec 04             	sub    $0x4,%esp
f01050c6:	68 27 3d 12 f0       	push   $0xf0123d27
f01050cb:	6a 52                	push   $0x52
f01050cd:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01050d2:	e8 62 b2 ff ff       	call   f0100339 <_panic>
f01050d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050da:	8b 40 08             	mov    0x8(%eax),%eax
f01050dd:	85 c0                	test   %eax,%eax
f01050df:	74 11                	je     f01050f2 <remove_from_queue+0x61>
f01050e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050e4:	8b 40 08             	mov    0x8(%eax),%eax
f01050e7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01050ea:	8b 52 0c             	mov    0xc(%edx),%edx
f01050ed:	89 50 0c             	mov    %edx,0xc(%eax)
f01050f0:	eb 0c                	jmp    f01050fe <remove_from_queue+0x6d>
f01050f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050f5:	8b 50 0c             	mov    0xc(%eax),%edx
f01050f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050fb:	89 50 04             	mov    %edx,0x4(%eax)
f01050fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105101:	8b 40 0c             	mov    0xc(%eax),%eax
f0105104:	85 c0                	test   %eax,%eax
f0105106:	74 11                	je     f0105119 <remove_from_queue+0x88>
f0105108:	8b 45 0c             	mov    0xc(%ebp),%eax
f010510b:	8b 40 0c             	mov    0xc(%eax),%eax
f010510e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105111:	8b 52 08             	mov    0x8(%edx),%edx
f0105114:	89 50 08             	mov    %edx,0x8(%eax)
f0105117:	eb 0b                	jmp    f0105124 <remove_from_queue+0x93>
f0105119:	8b 45 0c             	mov    0xc(%ebp),%eax
f010511c:	8b 50 08             	mov    0x8(%eax),%edx
f010511f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105122:	89 10                	mov    %edx,(%eax)
f0105124:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105127:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010512e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105131:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105138:	8b 45 08             	mov    0x8(%ebp),%eax
f010513b:	8b 40 0c             	mov    0xc(%eax),%eax
f010513e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105141:	8b 45 08             	mov    0x8(%ebp),%eax
f0105144:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105147:	90                   	nop
f0105148:	c9                   	leave  
f0105149:	c3                   	ret    

f010514a <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010514a:	55                   	push   %ebp
f010514b:	89 e5                	mov    %esp,%ebp
f010514d:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0105150:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105154:	75 07                	jne    f010515d <find_env_in_queue+0x13>
f0105156:	b8 00 00 00 00       	mov    $0x0,%eax
f010515b:	eb 58                	jmp    f01051b5 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f010515d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0105164:	8b 45 08             	mov    0x8(%ebp),%eax
f0105167:	8b 00                	mov    (%eax),%eax
f0105169:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010516c:	eb 19                	jmp    f0105187 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f010516e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105171:	8b 40 10             	mov    0x10(%eax),%eax
f0105174:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105177:	75 05                	jne    f010517e <find_env_in_queue+0x34>
		{
			return ptr_env;
f0105179:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010517c:	eb 37                	jmp    f01051b5 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f010517e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105181:	8b 40 08             	mov    0x8(%eax),%eax
f0105184:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0105187:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010518b:	74 08                	je     f0105195 <find_env_in_queue+0x4b>
f010518d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105190:	8b 40 08             	mov    0x8(%eax),%eax
f0105193:	eb 05                	jmp    f010519a <find_env_in_queue+0x50>
f0105195:	b8 00 00 00 00       	mov    $0x0,%eax
f010519a:	8b 55 08             	mov    0x8(%ebp),%edx
f010519d:	89 42 08             	mov    %eax,0x8(%edx)
f01051a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a3:	8b 40 08             	mov    0x8(%eax),%eax
f01051a6:	85 c0                	test   %eax,%eax
f01051a8:	75 c4                	jne    f010516e <find_env_in_queue+0x24>
f01051aa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ae:	75 be                	jne    f010516e <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f01051b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01051b5:	c9                   	leave  
f01051b6:	c3                   	ret    

f01051b7 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f01051b7:	55                   	push   %ebp
f01051b8:	89 e5                	mov    %esp,%ebp
f01051ba:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f01051bd:	83 ec 0c             	sub    $0xc,%esp
f01051c0:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01051c5:	e8 98 96 00 00       	call   f010e862 <acquire_spinlock>
f01051ca:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f01051cd:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01051d2:	85 c0                	test   %eax,%eax
f01051d4:	74 11                	je     f01051e7 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f01051d6:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01051db:	83 ec 0c             	sub    $0xc,%esp
f01051de:	50                   	push   %eax
f01051df:	e8 42 3b 00 00       	call   f0108d26 <kfree>
f01051e4:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f01051e7:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f01051ec:	85 c0                	test   %eax,%eax
f01051ee:	74 11                	je     f0105201 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f01051f0:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f01051f5:	83 ec 0c             	sub    $0xc,%esp
f01051f8:	50                   	push   %eax
f01051f9:	e8 28 3b 00 00       	call   f0108d26 <kfree>
f01051fe:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105201:	83 ec 0c             	sub    $0xc,%esp
f0105204:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105209:	e8 db 96 00 00       	call   f010e8e9 <release_spinlock>
f010520e:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105211:	90                   	nop
f0105212:	c9                   	leave  
f0105213:	c3                   	ret    

f0105214 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105214:	55                   	push   %ebp
f0105215:	89 e5                	mov    %esp,%ebp
f0105217:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010521a:	83 ec 0c             	sub    $0xc,%esp
f010521d:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105222:	e8 54 98 00 00       	call   f010ea7b <holding_spinlock>
f0105227:	83 c4 10             	add    $0x10,%esp
f010522a:	85 c0                	test   %eax,%eax
f010522c:	75 17                	jne    f0105245 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010522e:	83 ec 04             	sub    $0x4,%esp
f0105231:	68 48 3d 12 f0       	push   $0xf0123d48
f0105236:	68 85 00 00 00       	push   $0x85
f010523b:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105240:	e8 f4 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105245:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105249:	75 19                	jne    f0105264 <sched_insert_ready0+0x50>
f010524b:	68 89 3d 12 f0       	push   $0xf0123d89
f0105250:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0105255:	68 88 00 00 00       	push   $0x88
f010525a:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010525f:	e8 d5 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105264:	8b 45 08             	mov    0x8(%ebp),%eax
f0105267:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f010526e:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105273:	83 ec 08             	sub    $0x8,%esp
f0105276:	ff 75 08             	pushl  0x8(%ebp)
f0105279:	50                   	push   %eax
f010527a:	e8 c9 fc ff ff       	call   f0104f48 <enqueue>
f010527f:	83 c4 10             	add    $0x10,%esp
	}
}
f0105282:	90                   	nop
f0105283:	c9                   	leave  
f0105284:	c3                   	ret    

f0105285 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105285:	55                   	push   %ebp
f0105286:	89 e5                	mov    %esp,%ebp
f0105288:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010528b:	83 ec 0c             	sub    $0xc,%esp
f010528e:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105293:	e8 e3 97 00 00       	call   f010ea7b <holding_spinlock>
f0105298:	83 c4 10             	add    $0x10,%esp
f010529b:	85 c0                	test   %eax,%eax
f010529d:	75 17                	jne    f01052b6 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010529f:	83 ec 04             	sub    $0x4,%esp
f01052a2:	68 48 3d 12 f0       	push   $0xf0123d48
f01052a7:	68 97 00 00 00       	push   $0x97
f01052ac:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01052b1:	e8 83 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f01052b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ba:	74 0b                	je     f01052c7 <sched_remove_ready+0x42>
f01052bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01052bf:	8b 40 18             	mov    0x18(%eax),%eax
f01052c2:	83 f8 01             	cmp    $0x1,%eax
f01052c5:	74 19                	je     f01052e0 <sched_remove_ready+0x5b>
f01052c7:	68 98 3d 12 f0       	push   $0xf0123d98
f01052cc:	68 d6 3c 12 f0       	push   $0xf0123cd6
f01052d1:	68 9a 00 00 00       	push   $0x9a
f01052d6:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01052db:	e8 59 b0 ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01052e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01052e7:	e9 e4 00 00 00       	jmp    f01053d0 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01052ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01052ef:	8b 40 10             	mov    0x10(%eax),%eax
f01052f2:	89 c2                	mov    %eax,%edx
f01052f4:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01052f9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01052fc:	c1 e1 04             	shl    $0x4,%ecx
f01052ff:	01 c8                	add    %ecx,%eax
f0105301:	83 ec 08             	sub    $0x8,%esp
f0105304:	52                   	push   %edx
f0105305:	50                   	push   %eax
f0105306:	e8 3f fe ff ff       	call   f010514a <find_env_in_queue>
f010530b:	83 c4 10             	add    $0x10,%esp
f010530e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105311:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105315:	0f 84 b2 00 00 00    	je     f01053cd <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010531b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531f:	75 17                	jne    f0105338 <sched_remove_ready+0xb3>
f0105321:	83 ec 04             	sub    $0x4,%esp
f0105324:	68 27 3d 12 f0       	push   $0xf0123d27
f0105329:	68 a1 00 00 00       	push   $0xa1
f010532e:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105333:	e8 01 b0 ff ff       	call   f0100339 <_panic>
f0105338:	8b 45 08             	mov    0x8(%ebp),%eax
f010533b:	8b 40 08             	mov    0x8(%eax),%eax
f010533e:	85 c0                	test   %eax,%eax
f0105340:	74 11                	je     f0105353 <sched_remove_ready+0xce>
f0105342:	8b 45 08             	mov    0x8(%ebp),%eax
f0105345:	8b 40 08             	mov    0x8(%eax),%eax
f0105348:	8b 55 08             	mov    0x8(%ebp),%edx
f010534b:	8b 52 0c             	mov    0xc(%edx),%edx
f010534e:	89 50 0c             	mov    %edx,0xc(%eax)
f0105351:	eb 16                	jmp    f0105369 <sched_remove_ready+0xe4>
f0105353:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105358:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010535b:	c1 e2 04             	shl    $0x4,%edx
f010535e:	01 c2                	add    %eax,%edx
f0105360:	8b 45 08             	mov    0x8(%ebp),%eax
f0105363:	8b 40 0c             	mov    0xc(%eax),%eax
f0105366:	89 42 04             	mov    %eax,0x4(%edx)
f0105369:	8b 45 08             	mov    0x8(%ebp),%eax
f010536c:	8b 40 0c             	mov    0xc(%eax),%eax
f010536f:	85 c0                	test   %eax,%eax
f0105371:	74 11                	je     f0105384 <sched_remove_ready+0xff>
f0105373:	8b 45 08             	mov    0x8(%ebp),%eax
f0105376:	8b 40 0c             	mov    0xc(%eax),%eax
f0105379:	8b 55 08             	mov    0x8(%ebp),%edx
f010537c:	8b 52 08             	mov    0x8(%edx),%edx
f010537f:	89 50 08             	mov    %edx,0x8(%eax)
f0105382:	eb 15                	jmp    f0105399 <sched_remove_ready+0x114>
f0105384:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105389:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010538c:	c1 e2 04             	shl    $0x4,%edx
f010538f:	01 c2                	add    %eax,%edx
f0105391:	8b 45 08             	mov    0x8(%ebp),%eax
f0105394:	8b 40 08             	mov    0x8(%eax),%eax
f0105397:	89 02                	mov    %eax,(%edx)
f0105399:	8b 45 08             	mov    0x8(%ebp),%eax
f010539c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01053a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01053ad:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01053b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053b5:	c1 e2 04             	shl    $0x4,%edx
f01053b8:	01 d0                	add    %edx,%eax
f01053ba:	8b 50 0c             	mov    0xc(%eax),%edx
f01053bd:	4a                   	dec    %edx
f01053be:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f01053c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c4:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f01053cb:	eb 14                	jmp    f01053e1 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01053cd:	ff 45 f4             	incl   -0xc(%ebp)
f01053d0:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f01053d5:	0f b6 c0             	movzbl %al,%eax
f01053d8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01053db:	0f 8f 0b ff ff ff    	jg     f01052ec <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01053e1:	c9                   	leave  
f01053e2:	c3                   	ret    

f01053e3 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01053e3:	55                   	push   %ebp
f01053e4:	89 e5                	mov    %esp,%ebp
f01053e6:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01053e9:	83 ec 0c             	sub    $0xc,%esp
f01053ec:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01053f1:	e8 85 96 00 00       	call   f010ea7b <holding_spinlock>
f01053f6:	83 c4 10             	add    $0x10,%esp
f01053f9:	85 c0                	test   %eax,%eax
f01053fb:	75 17                	jne    f0105414 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01053fd:	83 ec 04             	sub    $0x4,%esp
f0105400:	68 48 3d 12 f0       	push   $0xf0123d48
f0105405:	68 b0 00 00 00       	push   $0xb0
f010540a:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010540f:	e8 25 af ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105414:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105418:	75 19                	jne    f0105433 <sched_insert_new+0x50>
f010541a:	68 89 3d 12 f0       	push   $0xf0123d89
f010541f:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0105424:	68 b3 00 00 00       	push   $0xb3
f0105429:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010542e:	e8 06 af ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105433:	8b 45 08             	mov    0x8(%ebp),%eax
f0105436:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010543d:	83 ec 08             	sub    $0x8,%esp
f0105440:	ff 75 08             	pushl  0x8(%ebp)
f0105443:	68 10 c5 5e f0       	push   $0xf05ec510
f0105448:	e8 fb fa ff ff       	call   f0104f48 <enqueue>
f010544d:	83 c4 10             	add    $0x10,%esp
	}
}
f0105450:	90                   	nop
f0105451:	c9                   	leave  
f0105452:	c3                   	ret    

f0105453 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105453:	55                   	push   %ebp
f0105454:	89 e5                	mov    %esp,%ebp
f0105456:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105459:	83 ec 0c             	sub    $0xc,%esp
f010545c:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105461:	e8 15 96 00 00       	call   f010ea7b <holding_spinlock>
f0105466:	83 c4 10             	add    $0x10,%esp
f0105469:	85 c0                	test   %eax,%eax
f010546b:	75 17                	jne    f0105484 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010546d:	83 ec 04             	sub    $0x4,%esp
f0105470:	68 48 3d 12 f0       	push   $0xf0123d48
f0105475:	68 c1 00 00 00       	push   $0xc1
f010547a:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010547f:	e8 b5 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105484:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105488:	74 0b                	je     f0105495 <sched_remove_new+0x42>
f010548a:	8b 45 08             	mov    0x8(%ebp),%eax
f010548d:	8b 40 18             	mov    0x18(%eax),%eax
f0105490:	83 f8 04             	cmp    $0x4,%eax
f0105493:	74 19                	je     f01054ae <sched_remove_new+0x5b>
f0105495:	68 c4 3d 12 f0       	push   $0xf0123dc4
f010549a:	68 d6 3c 12 f0       	push   $0xf0123cd6
f010549f:	68 c4 00 00 00       	push   $0xc4
f01054a4:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01054a9:	e8 8b ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f01054ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054b2:	75 17                	jne    f01054cb <sched_remove_new+0x78>
f01054b4:	83 ec 04             	sub    $0x4,%esp
f01054b7:	68 27 3d 12 f0       	push   $0xf0123d27
f01054bc:	68 c6 00 00 00       	push   $0xc6
f01054c1:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01054c6:	e8 6e ae ff ff       	call   f0100339 <_panic>
f01054cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ce:	8b 40 08             	mov    0x8(%eax),%eax
f01054d1:	85 c0                	test   %eax,%eax
f01054d3:	74 11                	je     f01054e6 <sched_remove_new+0x93>
f01054d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01054d8:	8b 40 08             	mov    0x8(%eax),%eax
f01054db:	8b 55 08             	mov    0x8(%ebp),%edx
f01054de:	8b 52 0c             	mov    0xc(%edx),%edx
f01054e1:	89 50 0c             	mov    %edx,0xc(%eax)
f01054e4:	eb 0b                	jmp    f01054f1 <sched_remove_new+0x9e>
f01054e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054e9:	8b 40 0c             	mov    0xc(%eax),%eax
f01054ec:	a3 14 c5 5e f0       	mov    %eax,0xf05ec514
f01054f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01054f4:	8b 40 0c             	mov    0xc(%eax),%eax
f01054f7:	85 c0                	test   %eax,%eax
f01054f9:	74 11                	je     f010550c <sched_remove_new+0xb9>
f01054fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01054fe:	8b 40 0c             	mov    0xc(%eax),%eax
f0105501:	8b 55 08             	mov    0x8(%ebp),%edx
f0105504:	8b 52 08             	mov    0x8(%edx),%edx
f0105507:	89 50 08             	mov    %edx,0x8(%eax)
f010550a:	eb 0b                	jmp    f0105517 <sched_remove_new+0xc4>
f010550c:	8b 45 08             	mov    0x8(%ebp),%eax
f010550f:	8b 40 08             	mov    0x8(%eax),%eax
f0105512:	a3 10 c5 5e f0       	mov    %eax,0xf05ec510
f0105517:	8b 45 08             	mov    0x8(%ebp),%eax
f010551a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105521:	8b 45 08             	mov    0x8(%ebp),%eax
f0105524:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010552b:	a1 1c c5 5e f0       	mov    0xf05ec51c,%eax
f0105530:	48                   	dec    %eax
f0105531:	a3 1c c5 5e f0       	mov    %eax,0xf05ec51c
		env->env_status = ENV_UNKNOWN;
f0105536:	8b 45 08             	mov    0x8(%ebp),%eax
f0105539:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105540:	90                   	nop
f0105541:	c9                   	leave  
f0105542:	c3                   	ret    

f0105543 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105543:	55                   	push   %ebp
f0105544:	89 e5                	mov    %esp,%ebp
f0105546:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105549:	83 ec 0c             	sub    $0xc,%esp
f010554c:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105551:	e8 25 95 00 00       	call   f010ea7b <holding_spinlock>
f0105556:	83 c4 10             	add    $0x10,%esp
f0105559:	85 c0                	test   %eax,%eax
f010555b:	75 17                	jne    f0105574 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010555d:	83 ec 04             	sub    $0x4,%esp
f0105560:	68 48 3d 12 f0       	push   $0xf0123d48
f0105565:	68 d2 00 00 00       	push   $0xd2
f010556a:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010556f:	e8 c5 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105574:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105578:	75 19                	jne    f0105593 <sched_insert_exit+0x50>
f010557a:	68 89 3d 12 f0       	push   $0xf0123d89
f010557f:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0105584:	68 d5 00 00 00       	push   $0xd5
f0105589:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010558e:	e8 a6 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105593:	e8 2c 8f 00 00       	call   f010e4c4 <isBufferingEnabled>
f0105598:	84 c0                	test   %al,%al
f010559a:	74 0e                	je     f01055aa <sched_insert_exit+0x67>
f010559c:	83 ec 0c             	sub    $0xc,%esp
f010559f:	ff 75 08             	pushl  0x8(%ebp)
f01055a2:	e8 b5 64 00 00       	call   f010ba5c <cleanup_buffers>
f01055a7:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f01055aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01055ad:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f01055b4:	83 ec 08             	sub    $0x8,%esp
f01055b7:	ff 75 08             	pushl  0x8(%ebp)
f01055ba:	68 20 c5 5e f0       	push   $0xf05ec520
f01055bf:	e8 84 f9 ff ff       	call   f0104f48 <enqueue>
f01055c4:	83 c4 10             	add    $0x10,%esp
	}
}
f01055c7:	90                   	nop
f01055c8:	c9                   	leave  
f01055c9:	c3                   	ret    

f01055ca <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01055ca:	55                   	push   %ebp
f01055cb:	89 e5                	mov    %esp,%ebp
f01055cd:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055d0:	83 ec 0c             	sub    $0xc,%esp
f01055d3:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01055d8:	e8 9e 94 00 00       	call   f010ea7b <holding_spinlock>
f01055dd:	83 c4 10             	add    $0x10,%esp
f01055e0:	85 c0                	test   %eax,%eax
f01055e2:	75 17                	jne    f01055fb <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055e4:	83 ec 04             	sub    $0x4,%esp
f01055e7:	68 48 3d 12 f0       	push   $0xf0123d48
f01055ec:	68 e3 00 00 00       	push   $0xe3
f01055f1:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01055f6:	e8 3e ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01055fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ff:	74 0b                	je     f010560c <sched_remove_exit+0x42>
f0105601:	8b 45 08             	mov    0x8(%ebp),%eax
f0105604:	8b 40 18             	mov    0x18(%eax),%eax
f0105607:	83 f8 05             	cmp    $0x5,%eax
f010560a:	74 19                	je     f0105625 <sched_remove_exit+0x5b>
f010560c:	68 f0 3d 12 f0       	push   $0xf0123df0
f0105611:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0105616:	68 e6 00 00 00       	push   $0xe6
f010561b:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105620:	e8 14 ad ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105625:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105629:	75 17                	jne    f0105642 <sched_remove_exit+0x78>
f010562b:	83 ec 04             	sub    $0x4,%esp
f010562e:	68 27 3d 12 f0       	push   $0xf0123d27
f0105633:	68 e8 00 00 00       	push   $0xe8
f0105638:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010563d:	e8 f7 ac ff ff       	call   f0100339 <_panic>
f0105642:	8b 45 08             	mov    0x8(%ebp),%eax
f0105645:	8b 40 08             	mov    0x8(%eax),%eax
f0105648:	85 c0                	test   %eax,%eax
f010564a:	74 11                	je     f010565d <sched_remove_exit+0x93>
f010564c:	8b 45 08             	mov    0x8(%ebp),%eax
f010564f:	8b 40 08             	mov    0x8(%eax),%eax
f0105652:	8b 55 08             	mov    0x8(%ebp),%edx
f0105655:	8b 52 0c             	mov    0xc(%edx),%edx
f0105658:	89 50 0c             	mov    %edx,0xc(%eax)
f010565b:	eb 0b                	jmp    f0105668 <sched_remove_exit+0x9e>
f010565d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105660:	8b 40 0c             	mov    0xc(%eax),%eax
f0105663:	a3 24 c5 5e f0       	mov    %eax,0xf05ec524
f0105668:	8b 45 08             	mov    0x8(%ebp),%eax
f010566b:	8b 40 0c             	mov    0xc(%eax),%eax
f010566e:	85 c0                	test   %eax,%eax
f0105670:	74 11                	je     f0105683 <sched_remove_exit+0xb9>
f0105672:	8b 45 08             	mov    0x8(%ebp),%eax
f0105675:	8b 40 0c             	mov    0xc(%eax),%eax
f0105678:	8b 55 08             	mov    0x8(%ebp),%edx
f010567b:	8b 52 08             	mov    0x8(%edx),%edx
f010567e:	89 50 08             	mov    %edx,0x8(%eax)
f0105681:	eb 0b                	jmp    f010568e <sched_remove_exit+0xc4>
f0105683:	8b 45 08             	mov    0x8(%ebp),%eax
f0105686:	8b 40 08             	mov    0x8(%eax),%eax
f0105689:	a3 20 c5 5e f0       	mov    %eax,0xf05ec520
f010568e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105691:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105698:	8b 45 08             	mov    0x8(%ebp),%eax
f010569b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01056a2:	a1 2c c5 5e f0       	mov    0xf05ec52c,%eax
f01056a7:	48                   	dec    %eax
f01056a8:	a3 2c c5 5e f0       	mov    %eax,0xf05ec52c
		env->env_status = ENV_UNKNOWN;
f01056ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b0:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01056b7:	90                   	nop
f01056b8:	c9                   	leave  
f01056b9:	c3                   	ret    

f01056ba <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f01056ba:	55                   	push   %ebp
f01056bb:	89 e5                	mov    %esp,%ebp
f01056bd:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056c0:	83 ec 0c             	sub    $0xc,%esp
f01056c3:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01056c8:	e8 95 91 00 00       	call   f010e862 <acquire_spinlock>
f01056cd:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01056d0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056d4:	75 19                	jne    f01056ef <sched_new_env+0x35>
f01056d6:	68 1b 3e 12 f0       	push   $0xf0123e1b
f01056db:	68 d6 3c 12 f0       	push   $0xf0123cd6
f01056e0:	68 f6 00 00 00       	push   $0xf6
f01056e5:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01056ea:	e8 4a ac ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f01056ef:	83 ec 0c             	sub    $0xc,%esp
f01056f2:	ff 75 08             	pushl  0x8(%ebp)
f01056f5:	e8 e9 fc ff ff       	call   f01053e3 <sched_insert_new>
f01056fa:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056fd:	83 ec 0c             	sub    $0xc,%esp
f0105700:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105705:	e8 df 91 00 00       	call   f010e8e9 <release_spinlock>
f010570a:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010570d:	90                   	nop
f010570e:	c9                   	leave  
f010570f:	c3                   	ret    

f0105710 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105710:	55                   	push   %ebp
f0105711:	89 e5                	mov    %esp,%ebp
f0105713:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105716:	83 ec 0c             	sub    $0xc,%esp
f0105719:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010571e:	e8 3f 91 00 00       	call   f010e862 <acquire_spinlock>
f0105723:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105726:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010572d:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f0105732:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105735:	eb 53                	jmp    f010578a <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105737:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010573a:	8b 40 10             	mov    0x10(%eax),%eax
f010573d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105740:	75 40                	jne    f0105782 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105742:	83 ec 0c             	sub    $0xc,%esp
f0105745:	ff 75 f4             	pushl  -0xc(%ebp)
f0105748:	e8 06 fd ff ff       	call   f0105453 <sched_remove_new>
f010574d:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f0105750:	83 ec 0c             	sub    $0xc,%esp
f0105753:	ff 75 f4             	pushl  -0xc(%ebp)
f0105756:	e8 b9 fa ff ff       	call   f0105214 <sched_insert_ready0>
f010575b:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010575e:	e8 3e 19 00 00       	call   f01070a1 <mycpu>
f0105763:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105769:	85 c0                	test   %eax,%eax
f010576b:	75 46                	jne    f01057b3 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010576d:	83 ec 0c             	sub    $0xc,%esp
f0105770:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105775:	e8 6f 91 00 00       	call   f010e8e9 <release_spinlock>
f010577a:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f010577d:	e8 ad 0f 00 00       	call   f010672f <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105782:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105787:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010578a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010578e:	74 08                	je     f0105798 <sched_run_env+0x88>
f0105790:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105793:	8b 40 08             	mov    0x8(%eax),%eax
f0105796:	eb 05                	jmp    f010579d <sched_run_env+0x8d>
f0105798:	b8 00 00 00 00       	mov    $0x0,%eax
f010579d:	a3 18 c5 5e f0       	mov    %eax,0xf05ec518
f01057a2:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f01057a7:	85 c0                	test   %eax,%eax
f01057a9:	75 8c                	jne    f0105737 <sched_run_env+0x27>
f01057ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057af:	75 86                	jne    f0105737 <sched_run_env+0x27>
f01057b1:	eb 01                	jmp    f01057b4 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f01057b3:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057b4:	83 ec 0c             	sub    $0xc,%esp
f01057b7:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01057bc:	e8 28 91 00 00       	call   f010e8e9 <release_spinlock>
f01057c1:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f01057c4:	90                   	nop
f01057c5:	c9                   	leave  
f01057c6:	c3                   	ret    

f01057c7 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f01057c7:	55                   	push   %ebp
f01057c8:	89 e5                	mov    %esp,%ebp
f01057ca:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f01057cd:	83 ec 0c             	sub    $0xc,%esp
f01057d0:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01057d5:	e8 a1 92 00 00       	call   f010ea7b <holding_spinlock>
f01057da:	83 c4 10             	add    $0x10,%esp
f01057dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01057e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01057e4:	75 10                	jne    f01057f6 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01057e6:	83 ec 0c             	sub    $0xc,%esp
f01057e9:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01057ee:	e8 6f 90 00 00       	call   f010e862 <acquire_spinlock>
f01057f3:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01057f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01057fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105804:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105808:	75 59                	jne    f0105863 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010580a:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f010580f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105812:	eb 28                	jmp    f010583c <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105817:	8b 40 10             	mov    0x10(%eax),%eax
f010581a:	3b 45 08             	cmp    0x8(%ebp),%eax
f010581d:	75 15                	jne    f0105834 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f010581f:	83 ec 0c             	sub    $0xc,%esp
f0105822:	ff 75 f4             	pushl  -0xc(%ebp)
f0105825:	e8 29 fc ff ff       	call   f0105453 <sched_remove_new>
f010582a:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010582d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105834:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105839:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010583c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105840:	74 08                	je     f010584a <sched_exit_env+0x83>
f0105842:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105845:	8b 40 08             	mov    0x8(%eax),%eax
f0105848:	eb 05                	jmp    f010584f <sched_exit_env+0x88>
f010584a:	b8 00 00 00 00       	mov    $0x0,%eax
f010584f:	a3 18 c5 5e f0       	mov    %eax,0xf05ec518
f0105854:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105859:	85 c0                	test   %eax,%eax
f010585b:	75 b7                	jne    f0105814 <sched_exit_env+0x4d>
f010585d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105861:	75 b1                	jne    f0105814 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105863:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105867:	0f 85 67 01 00 00    	jne    f01059d4 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010586d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105874:	e9 47 01 00 00       	jmp    f01059c0 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105879:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010587e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105881:	c1 e2 04             	shl    $0x4,%edx
f0105884:	01 d0                	add    %edx,%eax
f0105886:	8b 00                	mov    (%eax),%eax
f0105888:	85 c0                	test   %eax,%eax
f010588a:	0f 84 27 01 00 00    	je     f01059b7 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105890:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105897:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010589c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010589f:	c1 e2 04             	shl    $0x4,%edx
f01058a2:	01 d0                	add    %edx,%eax
f01058a4:	8b 00                	mov    (%eax),%eax
f01058a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01058a9:	e9 d1 00 00 00       	jmp    f010597f <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f01058ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058b1:	8b 40 10             	mov    0x10(%eax),%eax
f01058b4:	3b 45 08             	cmp    0x8(%ebp),%eax
f01058b7:	0f 85 af 00 00 00    	jne    f010596c <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01058bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c1:	75 17                	jne    f01058da <sched_exit_env+0x113>
f01058c3:	83 ec 04             	sub    $0x4,%esp
f01058c6:	68 27 3d 12 f0       	push   $0xf0123d27
f01058cb:	68 44 01 00 00       	push   $0x144
f01058d0:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01058d5:	e8 5f aa ff ff       	call   f0100339 <_panic>
f01058da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058dd:	8b 40 08             	mov    0x8(%eax),%eax
f01058e0:	85 c0                	test   %eax,%eax
f01058e2:	74 11                	je     f01058f5 <sched_exit_env+0x12e>
f01058e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058e7:	8b 40 08             	mov    0x8(%eax),%eax
f01058ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058ed:	8b 52 0c             	mov    0xc(%edx),%edx
f01058f0:	89 50 0c             	mov    %edx,0xc(%eax)
f01058f3:	eb 16                	jmp    f010590b <sched_exit_env+0x144>
f01058f5:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01058fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058fd:	c1 e2 04             	shl    $0x4,%edx
f0105900:	01 c2                	add    %eax,%edx
f0105902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105905:	8b 40 0c             	mov    0xc(%eax),%eax
f0105908:	89 42 04             	mov    %eax,0x4(%edx)
f010590b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010590e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105911:	85 c0                	test   %eax,%eax
f0105913:	74 11                	je     f0105926 <sched_exit_env+0x15f>
f0105915:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105918:	8b 40 0c             	mov    0xc(%eax),%eax
f010591b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010591e:	8b 52 08             	mov    0x8(%edx),%edx
f0105921:	89 50 08             	mov    %edx,0x8(%eax)
f0105924:	eb 15                	jmp    f010593b <sched_exit_env+0x174>
f0105926:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010592b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010592e:	c1 e2 04             	shl    $0x4,%edx
f0105931:	01 c2                	add    %eax,%edx
f0105933:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105936:	8b 40 08             	mov    0x8(%eax),%eax
f0105939:	89 02                	mov    %eax,(%edx)
f010593b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105945:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105948:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010594f:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105954:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105957:	c1 e2 04             	shl    $0x4,%edx
f010595a:	01 d0                	add    %edx,%eax
f010595c:	8b 50 0c             	mov    0xc(%eax),%edx
f010595f:	4a                   	dec    %edx
f0105960:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105963:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f010596a:	eb 4b                	jmp    f01059b7 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010596c:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105971:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105974:	c1 e2 04             	shl    $0x4,%edx
f0105977:	01 d0                	add    %edx,%eax
f0105979:	8b 40 08             	mov    0x8(%eax),%eax
f010597c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010597f:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105984:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105987:	c1 e2 04             	shl    $0x4,%edx
f010598a:	01 d0                	add    %edx,%eax
f010598c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105990:	74 08                	je     f010599a <sched_exit_env+0x1d3>
f0105992:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105995:	8b 52 08             	mov    0x8(%edx),%edx
f0105998:	eb 05                	jmp    f010599f <sched_exit_env+0x1d8>
f010599a:	ba 00 00 00 00       	mov    $0x0,%edx
f010599f:	89 50 08             	mov    %edx,0x8(%eax)
f01059a2:	8b 40 08             	mov    0x8(%eax),%eax
f01059a5:	85 c0                	test   %eax,%eax
f01059a7:	0f 85 01 ff ff ff    	jne    f01058ae <sched_exit_env+0xe7>
f01059ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059b1:	0f 85 f7 fe ff ff    	jne    f01058ae <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059bb:	75 16                	jne    f01059d3 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01059bd:	ff 45 ec             	incl   -0x14(%ebp)
f01059c0:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f01059c5:	0f b6 c0             	movzbl %al,%eax
f01059c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01059cb:	0f 8f a8 fe ff ff    	jg     f0105879 <sched_exit_env+0xb2>
f01059d1:	eb 01                	jmp    f01059d4 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059d3:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01059d4:	e8 09 4f 00 00       	call   f010a8e2 <get_cpu_proc>
f01059d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01059dc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01059e0:	75 19                	jne    f01059fb <sched_exit_env+0x234>
f01059e2:	68 23 3e 12 f0       	push   $0xf0123e23
f01059e7:	68 d6 3c 12 f0       	push   $0xf0123cd6
f01059ec:	68 4e 01 00 00       	push   $0x14e
f01059f1:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01059f6:	e8 3e a9 ff ff       	call   f0100339 <_panic>
	if (!found)
f01059fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059ff:	75 18                	jne    f0105a19 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a04:	8b 40 10             	mov    0x10(%eax),%eax
f0105a07:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a0a:	75 0d                	jne    f0105a19 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a12:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	74 1e                	je     f0105a3d <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a1f:	83 ec 0c             	sub    $0xc,%esp
f0105a22:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a25:	e8 19 fb ff ff       	call   f0105543 <sched_insert_exit>
f0105a2a:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a30:	8b 40 10             	mov    0x10(%eax),%eax
f0105a33:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a36:	75 05                	jne    f0105a3d <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a38:	e8 1e 50 00 00       	call   f010aa5b <sched>
		}
	}
	if (!lock_already_held)
f0105a3d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105a41:	75 10                	jne    f0105a53 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105a43:	83 ec 0c             	sub    $0xc,%esp
f0105a46:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105a4b:	e8 99 8e 00 00       	call   f010e8e9 <release_spinlock>
f0105a50:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105a53:	90                   	nop
f0105a54:	c9                   	leave  
f0105a55:	c3                   	ret    

f0105a56 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105a56:	55                   	push   %ebp
f0105a57:	89 e5                	mov    %esp,%ebp
f0105a59:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a5c:	83 ec 0c             	sub    $0xc,%esp
f0105a5f:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105a64:	e8 f9 8d 00 00       	call   f010e862 <acquire_spinlock>
f0105a69:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105a6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105a73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105a7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7e:	75 79                	jne    f0105af9 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a80:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f0105a85:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a88:	eb 48                	jmp    f0105ad2 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a8d:	8b 40 10             	mov    0x10(%eax),%eax
f0105a90:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a93:	75 35                	jne    f0105aca <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a98:	8d 50 20             	lea    0x20(%eax),%edx
f0105a9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a9e:	8b 40 10             	mov    0x10(%eax),%eax
f0105aa1:	83 ec 04             	sub    $0x4,%esp
f0105aa4:	52                   	push   %edx
f0105aa5:	50                   	push   %eax
f0105aa6:	68 34 3e 12 f0       	push   $0xf0123e34
f0105aab:	e8 db b4 ff ff       	call   f0100f8b <cprintf>
f0105ab0:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105ab3:	83 ec 0c             	sub    $0xc,%esp
f0105ab6:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ab9:	e8 95 f9 ff ff       	call   f0105453 <sched_remove_new>
f0105abe:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105ac1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105ac8:	eb 2f                	jmp    f0105af9 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105aca:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105acf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ad2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ad6:	74 08                	je     f0105ae0 <sched_kill_env+0x8a>
f0105ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105adb:	8b 40 08             	mov    0x8(%eax),%eax
f0105ade:	eb 05                	jmp    f0105ae5 <sched_kill_env+0x8f>
f0105ae0:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ae5:	a3 18 c5 5e f0       	mov    %eax,0xf05ec518
f0105aea:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105aef:	85 c0                	test   %eax,%eax
f0105af1:	75 97                	jne    f0105a8a <sched_kill_env+0x34>
f0105af3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105af7:	75 91                	jne    f0105a8a <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105af9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105afd:	0f 85 85 01 00 00    	jne    f0105c88 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b0a:	e9 65 01 00 00       	jmp    f0105c74 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b0f:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105b14:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b17:	c1 e2 04             	shl    $0x4,%edx
f0105b1a:	01 d0                	add    %edx,%eax
f0105b1c:	8b 00                	mov    (%eax),%eax
f0105b1e:	85 c0                	test   %eax,%eax
f0105b20:	0f 84 45 01 00 00    	je     f0105c6b <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b2d:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105b32:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b35:	c1 e2 04             	shl    $0x4,%edx
f0105b38:	01 d0                	add    %edx,%eax
f0105b3a:	8b 00                	mov    (%eax),%eax
f0105b3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b3f:	e9 ef 00 00 00       	jmp    f0105c33 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b47:	8b 40 10             	mov    0x10(%eax),%eax
f0105b4a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b4d:	0f 85 cd 00 00 00    	jne    f0105c20 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b56:	8d 50 20             	lea    0x20(%eax),%edx
f0105b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b5c:	8b 40 10             	mov    0x10(%eax),%eax
f0105b5f:	ff 75 ec             	pushl  -0x14(%ebp)
f0105b62:	52                   	push   %edx
f0105b63:	50                   	push   %eax
f0105b64:	68 5c 3e 12 f0       	push   $0xf0123e5c
f0105b69:	e8 1d b4 ff ff       	call   f0100f8b <cprintf>
f0105b6e:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b71:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b75:	75 17                	jne    f0105b8e <sched_kill_env+0x138>
f0105b77:	83 ec 04             	sub    $0x4,%esp
f0105b7a:	68 27 3d 12 f0       	push   $0xf0123d27
f0105b7f:	68 91 01 00 00       	push   $0x191
f0105b84:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105b89:	e8 ab a7 ff ff       	call   f0100339 <_panic>
f0105b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b91:	8b 40 08             	mov    0x8(%eax),%eax
f0105b94:	85 c0                	test   %eax,%eax
f0105b96:	74 11                	je     f0105ba9 <sched_kill_env+0x153>
f0105b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b9b:	8b 40 08             	mov    0x8(%eax),%eax
f0105b9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ba1:	8b 52 0c             	mov    0xc(%edx),%edx
f0105ba4:	89 50 0c             	mov    %edx,0xc(%eax)
f0105ba7:	eb 16                	jmp    f0105bbf <sched_kill_env+0x169>
f0105ba9:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105bae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bb1:	c1 e2 04             	shl    $0x4,%edx
f0105bb4:	01 c2                	add    %eax,%edx
f0105bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb9:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bbc:	89 42 04             	mov    %eax,0x4(%edx)
f0105bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bc2:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bc5:	85 c0                	test   %eax,%eax
f0105bc7:	74 11                	je     f0105bda <sched_kill_env+0x184>
f0105bc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bcc:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bd2:	8b 52 08             	mov    0x8(%edx),%edx
f0105bd5:	89 50 08             	mov    %edx,0x8(%eax)
f0105bd8:	eb 15                	jmp    f0105bef <sched_kill_env+0x199>
f0105bda:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105bdf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105be2:	c1 e2 04             	shl    $0x4,%edx
f0105be5:	01 c2                	add    %eax,%edx
f0105be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bea:	8b 40 08             	mov    0x8(%eax),%eax
f0105bed:	89 02                	mov    %eax,(%edx)
f0105bef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105bf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c03:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105c08:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c0b:	c1 e2 04             	shl    $0x4,%edx
f0105c0e:	01 d0                	add    %edx,%eax
f0105c10:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c13:	4a                   	dec    %edx
f0105c14:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c17:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c1e:	eb 4b                	jmp    f0105c6b <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c20:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105c25:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c28:	c1 e2 04             	shl    $0x4,%edx
f0105c2b:	01 d0                	add    %edx,%eax
f0105c2d:	8b 40 08             	mov    0x8(%eax),%eax
f0105c30:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c33:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105c38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c3b:	c1 e2 04             	shl    $0x4,%edx
f0105c3e:	01 d0                	add    %edx,%eax
f0105c40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c44:	74 08                	je     f0105c4e <sched_kill_env+0x1f8>
f0105c46:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c49:	8b 52 08             	mov    0x8(%edx),%edx
f0105c4c:	eb 05                	jmp    f0105c53 <sched_kill_env+0x1fd>
f0105c4e:	ba 00 00 00 00       	mov    $0x0,%edx
f0105c53:	89 50 08             	mov    %edx,0x8(%eax)
f0105c56:	8b 40 08             	mov    0x8(%eax),%eax
f0105c59:	85 c0                	test   %eax,%eax
f0105c5b:	0f 85 e3 fe ff ff    	jne    f0105b44 <sched_kill_env+0xee>
f0105c61:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c65:	0f 85 d9 fe ff ff    	jne    f0105b44 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105c6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c6f:	75 16                	jne    f0105c87 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105c71:	ff 45 ec             	incl   -0x14(%ebp)
f0105c74:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f0105c79:	0f b6 c0             	movzbl %al,%eax
f0105c7c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105c7f:	0f 8f 8a fe ff ff    	jg     f0105b0f <sched_kill_env+0xb9>
f0105c85:	eb 01                	jmp    f0105c88 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105c87:	90                   	nop
		}
	}
	if (!found)
f0105c88:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c8c:	0f 85 80 00 00 00    	jne    f0105d12 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105c92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105c99:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f0105c9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ca1:	eb 48                	jmp    f0105ceb <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ca6:	8b 40 10             	mov    0x10(%eax),%eax
f0105ca9:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cac:	75 35                	jne    f0105ce3 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105cae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cb1:	8d 50 20             	lea    0x20(%eax),%edx
f0105cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cb7:	8b 40 10             	mov    0x10(%eax),%eax
f0105cba:	83 ec 04             	sub    $0x4,%esp
f0105cbd:	52                   	push   %edx
f0105cbe:	50                   	push   %eax
f0105cbf:	68 88 3e 12 f0       	push   $0xf0123e88
f0105cc4:	e8 c2 b2 ff ff       	call   f0100f8b <cprintf>
f0105cc9:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105ccc:	83 ec 0c             	sub    $0xc,%esp
f0105ccf:	ff 75 f4             	pushl  -0xc(%ebp)
f0105cd2:	e8 f3 f8 ff ff       	call   f01055ca <sched_remove_exit>
f0105cd7:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105cda:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105ce1:	eb 2f                	jmp    f0105d12 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ce3:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f0105ce8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ceb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cef:	74 08                	je     f0105cf9 <sched_kill_env+0x2a3>
f0105cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cf4:	8b 40 08             	mov    0x8(%eax),%eax
f0105cf7:	eb 05                	jmp    f0105cfe <sched_kill_env+0x2a8>
f0105cf9:	b8 00 00 00 00       	mov    $0x0,%eax
f0105cfe:	a3 28 c5 5e f0       	mov    %eax,0xf05ec528
f0105d03:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f0105d08:	85 c0                	test   %eax,%eax
f0105d0a:	75 97                	jne    f0105ca3 <sched_kill_env+0x24d>
f0105d0c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d10:	75 91                	jne    f0105ca3 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d12:	83 ec 0c             	sub    $0xc,%esp
f0105d15:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105d1a:	e8 ca 8b 00 00       	call   f010e8e9 <release_spinlock>
f0105d1f:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d22:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d26:	74 23                	je     f0105d4b <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d28:	83 ec 0c             	sub    $0xc,%esp
f0105d2b:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d2e:	e8 67 4b 00 00       	call   f010a89a <env_free>
f0105d33:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d36:	83 ec 0c             	sub    $0xc,%esp
f0105d39:	68 ae 3e 12 f0       	push   $0xf0123eae
f0105d3e:	e8 48 b2 ff ff       	call   f0100f8b <cprintf>
f0105d43:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105d46:	e9 a4 00 00 00       	jmp    f0105def <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105d4b:	e8 92 4b 00 00       	call   f010a8e2 <get_cpu_proc>
f0105d50:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105d53:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d57:	75 19                	jne    f0105d72 <sched_kill_env+0x31c>
f0105d59:	68 23 3e 12 f0       	push   $0xf0123e23
f0105d5e:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0105d63:	68 b3 01 00 00       	push   $0x1b3
f0105d68:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105d6d:	e8 c7 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105d72:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105d75:	8b 40 10             	mov    0x10(%eax),%eax
f0105d78:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d7b:	75 72                	jne    f0105def <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105d7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105d83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d86:	8b 40 18             	mov    0x18(%eax),%eax
f0105d89:	83 f8 02             	cmp    $0x2,%eax
f0105d8c:	74 19                	je     f0105da7 <sched_kill_env+0x351>
f0105d8e:	68 b4 3e 12 f0       	push   $0xf0123eb4
f0105d93:	68 d6 3c 12 f0       	push   $0xf0123cd6
f0105d98:	68 b8 01 00 00       	push   $0x1b8
f0105d9d:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0105da2:	e8 92 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105da7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105daa:	8d 50 20             	lea    0x20(%eax),%edx
f0105dad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105db0:	8b 40 10             	mov    0x10(%eax),%eax
f0105db3:	83 ec 04             	sub    $0x4,%esp
f0105db6:	52                   	push   %edx
f0105db7:	50                   	push   %eax
f0105db8:	68 d8 3e 12 f0       	push   $0xf0123ed8
f0105dbd:	e8 c9 b1 ff ff       	call   f0100f8b <cprintf>
f0105dc2:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105dc5:	83 ec 0c             	sub    $0xc,%esp
f0105dc8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105dcb:	e8 ca 4a 00 00       	call   f010a89a <env_free>
f0105dd0:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105dd3:	83 ec 0c             	sub    $0xc,%esp
f0105dd6:	68 ae 3e 12 f0       	push   $0xf0123eae
f0105ddb:	e8 ab b1 ff ff       	call   f0100f8b <cprintf>
f0105de0:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105de3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105dea:	e8 6c 4c 00 00       	call   f010aa5b <sched>
		}
	}

}
f0105def:	90                   	nop
f0105df0:	c9                   	leave  
f0105df1:	c3                   	ret    

f0105df2 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105df2:	55                   	push   %ebp
f0105df3:	89 e5                	mov    %esp,%ebp
f0105df5:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105df8:	83 ec 0c             	sub    $0xc,%esp
f0105dfb:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0105e00:	e8 5d 8a 00 00       	call   f010e862 <acquire_spinlock>
f0105e05:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e08:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f0105e0d:	85 c0                	test   %eax,%eax
f0105e0f:	74 69                	je     f0105e7a <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e11:	83 ec 0c             	sub    $0xc,%esp
f0105e14:	68 04 3f 12 f0       	push   $0xf0123f04
f0105e19:	e8 6d b1 ff ff       	call   f0100f8b <cprintf>
f0105e1e:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e21:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f0105e26:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e29:	eb 26                	jmp    f0105e51 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e2e:	8d 50 20             	lea    0x20(%eax),%edx
f0105e31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e34:	8b 40 10             	mov    0x10(%eax),%eax
f0105e37:	83 ec 04             	sub    $0x4,%esp
f0105e3a:	52                   	push   %edx
f0105e3b:	50                   	push   %eax
f0105e3c:	68 26 3f 12 f0       	push   $0xf0123f26
f0105e41:	e8 45 b1 ff ff       	call   f0100f8b <cprintf>
f0105e46:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e49:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105e4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e55:	74 08                	je     f0105e5f <sched_print_all+0x6d>
f0105e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5a:	8b 40 08             	mov    0x8(%eax),%eax
f0105e5d:	eb 05                	jmp    f0105e64 <sched_print_all+0x72>
f0105e5f:	b8 00 00 00 00       	mov    $0x0,%eax
f0105e64:	a3 18 c5 5e f0       	mov    %eax,0xf05ec518
f0105e69:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0105e6e:	85 c0                	test   %eax,%eax
f0105e70:	75 b9                	jne    f0105e2b <sched_print_all+0x39>
f0105e72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e76:	75 b3                	jne    f0105e2b <sched_print_all+0x39>
f0105e78:	eb 10                	jmp    f0105e8a <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105e7a:	83 ec 0c             	sub    $0xc,%esp
f0105e7d:	68 30 3f 12 f0       	push   $0xf0123f30
f0105e82:	e8 04 b1 ff ff       	call   f0100f8b <cprintf>
f0105e87:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105e8a:	83 ec 0c             	sub    $0xc,%esp
f0105e8d:	68 4c 3f 12 f0       	push   $0xf0123f4c
f0105e92:	e8 f4 b0 ff ff       	call   f0100f8b <cprintf>
f0105e97:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105e9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105ea1:	e9 c7 00 00 00       	jmp    f0105f6d <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ea6:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105eab:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105eae:	c1 e2 04             	shl    $0x4,%edx
f0105eb1:	01 d0                	add    %edx,%eax
f0105eb3:	8b 00                	mov    (%eax),%eax
f0105eb5:	85 c0                	test   %eax,%eax
f0105eb7:	0f 84 8a 00 00 00    	je     f0105f47 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105ebd:	83 ec 08             	sub    $0x8,%esp
f0105ec0:	ff 75 f0             	pushl  -0x10(%ebp)
f0105ec3:	68 80 3f 12 f0       	push   $0xf0123f80
f0105ec8:	e8 be b0 ff ff       	call   f0100f8b <cprintf>
f0105ecd:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105ed0:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105ed5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ed8:	c1 e2 04             	shl    $0x4,%edx
f0105edb:	01 d0                	add    %edx,%eax
f0105edd:	8b 00                	mov    (%eax),%eax
f0105edf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ee2:	eb 31                	jmp    f0105f15 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ee7:	8d 50 20             	lea    0x20(%eax),%edx
f0105eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eed:	8b 40 10             	mov    0x10(%eax),%eax
f0105ef0:	83 ec 04             	sub    $0x4,%esp
f0105ef3:	52                   	push   %edx
f0105ef4:	50                   	push   %eax
f0105ef5:	68 26 3f 12 f0       	push   $0xf0123f26
f0105efa:	e8 8c b0 ff ff       	call   f0100f8b <cprintf>
f0105eff:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f02:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105f07:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f0a:	c1 e2 04             	shl    $0x4,%edx
f0105f0d:	01 d0                	add    %edx,%eax
f0105f0f:	8b 40 08             	mov    0x8(%eax),%eax
f0105f12:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f15:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0105f1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f1d:	c1 e2 04             	shl    $0x4,%edx
f0105f20:	01 d0                	add    %edx,%eax
f0105f22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f26:	74 08                	je     f0105f30 <sched_print_all+0x13e>
f0105f28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f2b:	8b 52 08             	mov    0x8(%edx),%edx
f0105f2e:	eb 05                	jmp    f0105f35 <sched_print_all+0x143>
f0105f30:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f35:	89 50 08             	mov    %edx,0x8(%eax)
f0105f38:	8b 40 08             	mov    0x8(%eax),%eax
f0105f3b:	85 c0                	test   %eax,%eax
f0105f3d:	75 a5                	jne    f0105ee4 <sched_print_all+0xf2>
f0105f3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f43:	75 9f                	jne    f0105ee4 <sched_print_all+0xf2>
f0105f45:	eb 13                	jmp    f0105f5a <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105f47:	83 ec 08             	sub    $0x8,%esp
f0105f4a:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f4d:	68 a8 3f 12 f0       	push   $0xf0123fa8
f0105f52:	e8 34 b0 ff ff       	call   f0100f8b <cprintf>
f0105f57:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105f5a:	83 ec 0c             	sub    $0xc,%esp
f0105f5d:	68 4c 3f 12 f0       	push   $0xf0123f4c
f0105f62:	e8 24 b0 ff ff       	call   f0100f8b <cprintf>
f0105f67:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f6a:	ff 45 f0             	incl   -0x10(%ebp)
f0105f6d:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f0105f72:	0f b6 c0             	movzbl %al,%eax
f0105f75:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105f78:	0f 8f 28 ff ff ff    	jg     f0105ea6 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105f7e:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f0105f83:	85 c0                	test   %eax,%eax
f0105f85:	74 69                	je     f0105ff0 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105f87:	83 ec 0c             	sub    $0xc,%esp
f0105f8a:	68 cc 3f 12 f0       	push   $0xf0123fcc
f0105f8f:	e8 f7 af ff ff       	call   f0100f8b <cprintf>
f0105f94:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105f97:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f0105f9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f9f:	eb 26                	jmp    f0105fc7 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fa4:	8d 50 20             	lea    0x20(%eax),%edx
f0105fa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105faa:	8b 40 10             	mov    0x10(%eax),%eax
f0105fad:	83 ec 04             	sub    $0x4,%esp
f0105fb0:	52                   	push   %edx
f0105fb1:	50                   	push   %eax
f0105fb2:	68 26 3f 12 f0       	push   $0xf0123f26
f0105fb7:	e8 cf af ff ff       	call   f0100f8b <cprintf>
f0105fbc:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fbf:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f0105fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fc7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fcb:	74 08                	je     f0105fd5 <sched_print_all+0x1e3>
f0105fcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fd0:	8b 40 08             	mov    0x8(%eax),%eax
f0105fd3:	eb 05                	jmp    f0105fda <sched_print_all+0x1e8>
f0105fd5:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fda:	a3 28 c5 5e f0       	mov    %eax,0xf05ec528
f0105fdf:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f0105fe4:	85 c0                	test   %eax,%eax
f0105fe6:	75 b9                	jne    f0105fa1 <sched_print_all+0x1af>
f0105fe8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fec:	75 b3                	jne    f0105fa1 <sched_print_all+0x1af>
f0105fee:	eb 10                	jmp    f0106000 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0105ff0:	83 ec 0c             	sub    $0xc,%esp
f0105ff3:	68 ee 3f 12 f0       	push   $0xf0123fee
f0105ff8:	e8 8e af ff ff       	call   f0100f8b <cprintf>
f0105ffd:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106000:	83 ec 0c             	sub    $0xc,%esp
f0106003:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106008:	e8 dc 88 00 00       	call   f010e8e9 <release_spinlock>
f010600d:	83 c4 10             	add    $0x10,%esp
}
f0106010:	90                   	nop
f0106011:	c9                   	leave  
f0106012:	c3                   	ret    

f0106013 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106013:	55                   	push   %ebp
f0106014:	89 e5                	mov    %esp,%ebp
f0106016:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106019:	83 ec 0c             	sub    $0xc,%esp
f010601c:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106021:	e8 3c 88 00 00       	call   f010e862 <acquire_spinlock>
f0106026:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106029:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106030:	a1 1c c5 5e f0       	mov    0xf05ec51c,%eax
f0106035:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0106038:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010603f:	eb 24                	jmp    f0106065 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0106041:	83 ec 0c             	sub    $0xc,%esp
f0106044:	68 10 c5 5e f0       	push   $0xf05ec510
f0106049:	e8 8b ef ff ff       	call   f0104fd9 <dequeue>
f010604e:	83 c4 10             	add    $0x10,%esp
f0106051:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f0106054:	83 ec 0c             	sub    $0xc,%esp
f0106057:	ff 75 f0             	pushl  -0x10(%ebp)
f010605a:	e8 b5 f1 ff ff       	call   f0105214 <sched_insert_ready0>
f010605f:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0106062:	ff 45 f4             	incl   -0xc(%ebp)
f0106065:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106068:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010606b:	7c d4                	jl     f0106041 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010606d:	83 ec 0c             	sub    $0xc,%esp
f0106070:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106075:	e8 6f 88 00 00       	call   f010e8e9 <release_spinlock>
f010607a:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010607d:	e8 1f 10 00 00       	call   f01070a1 <mycpu>
f0106082:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106088:	85 c0                	test   %eax,%eax
f010608a:	75 05                	jne    f0106091 <sched_run_all+0x7e>
		fos_scheduler();
f010608c:	e8 9e 06 00 00       	call   f010672f <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0106091:	83 ec 04             	sub    $0x4,%esp
f0106094:	68 0c 40 12 f0       	push   $0xf012400c
f0106099:	68 15 02 00 00       	push   $0x215
f010609e:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01060a3:	e8 91 a2 ff ff       	call   f0100339 <_panic>

f01060a8 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f01060a8:	55                   	push   %ebp
f01060a9:	89 e5                	mov    %esp,%ebp
f01060ab:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060ae:	83 ec 0c             	sub    $0xc,%esp
f01060b1:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01060b6:	e8 a7 87 00 00       	call   f010e862 <acquire_spinlock>
f01060bb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060be:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f01060c3:	85 c0                	test   %eax,%eax
f01060c5:	0f 84 95 00 00 00    	je     f0106160 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01060cb:	83 ec 0c             	sub    $0xc,%esp
f01060ce:	68 48 40 12 f0       	push   $0xf0124048
f01060d3:	e8 b3 ae ff ff       	call   f0100f8b <cprintf>
f01060d8:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01060db:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f01060e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060e3:	eb 52                	jmp    f0106137 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01060e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060e8:	8d 50 20             	lea    0x20(%eax),%edx
f01060eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ee:	8b 40 10             	mov    0x10(%eax),%eax
f01060f1:	83 ec 04             	sub    $0x4,%esp
f01060f4:	52                   	push   %edx
f01060f5:	50                   	push   %eax
f01060f6:	68 74 40 12 f0       	push   $0xf0124074
f01060fb:	e8 8b ae ff ff       	call   f0100f8b <cprintf>
f0106100:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106103:	83 ec 0c             	sub    $0xc,%esp
f0106106:	ff 75 f4             	pushl  -0xc(%ebp)
f0106109:	e8 45 f3 ff ff       	call   f0105453 <sched_remove_new>
f010610e:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106111:	83 ec 0c             	sub    $0xc,%esp
f0106114:	ff 75 f4             	pushl  -0xc(%ebp)
f0106117:	e8 7e 47 00 00       	call   f010a89a <env_free>
f010611c:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f010611f:	83 ec 0c             	sub    $0xc,%esp
f0106122:	68 ae 3e 12 f0       	push   $0xf0123eae
f0106127:	e8 5f ae ff ff       	call   f0100f8b <cprintf>
f010612c:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010612f:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0106134:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106137:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010613b:	74 08                	je     f0106145 <sched_kill_all+0x9d>
f010613d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106140:	8b 40 08             	mov    0x8(%eax),%eax
f0106143:	eb 05                	jmp    f010614a <sched_kill_all+0xa2>
f0106145:	b8 00 00 00 00       	mov    $0x0,%eax
f010614a:	a3 18 c5 5e f0       	mov    %eax,0xf05ec518
f010614f:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f0106154:	85 c0                	test   %eax,%eax
f0106156:	75 8d                	jne    f01060e5 <sched_kill_all+0x3d>
f0106158:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010615c:	75 87                	jne    f01060e5 <sched_kill_all+0x3d>
f010615e:	eb 10                	jmp    f0106170 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0106160:	83 ec 0c             	sub    $0xc,%esp
f0106163:	68 87 40 12 f0       	push   $0xf0124087
f0106168:	e8 1e ae ff ff       	call   f0100f8b <cprintf>
f010616d:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106170:	83 ec 0c             	sub    $0xc,%esp
f0106173:	68 4c 3f 12 f0       	push   $0xf0123f4c
f0106178:	e8 0e ae ff ff       	call   f0100f8b <cprintf>
f010617d:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106187:	e9 96 01 00 00       	jmp    f0106322 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010618c:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106191:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106194:	c1 e2 04             	shl    $0x4,%edx
f0106197:	01 d0                	add    %edx,%eax
f0106199:	8b 00                	mov    (%eax),%eax
f010619b:	85 c0                	test   %eax,%eax
f010619d:	0f 84 59 01 00 00    	je     f01062fc <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f01061a3:	83 ec 08             	sub    $0x8,%esp
f01061a6:	ff 75 f0             	pushl  -0x10(%ebp)
f01061a9:	68 a4 40 12 f0       	push   $0xf01240a4
f01061ae:	e8 d8 ad ff ff       	call   f0100f8b <cprintf>
f01061b3:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061b6:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01061bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061be:	c1 e2 04             	shl    $0x4,%edx
f01061c1:	01 d0                	add    %edx,%eax
f01061c3:	8b 00                	mov    (%eax),%eax
f01061c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061c8:	e9 f5 00 00 00       	jmp    f01062c2 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01061cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061d0:	8d 50 20             	lea    0x20(%eax),%edx
f01061d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061d6:	8b 40 10             	mov    0x10(%eax),%eax
f01061d9:	83 ec 04             	sub    $0x4,%esp
f01061dc:	52                   	push   %edx
f01061dd:	50                   	push   %eax
f01061de:	68 74 40 12 f0       	push   $0xf0124074
f01061e3:	e8 a3 ad ff ff       	call   f0100f8b <cprintf>
f01061e8:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01061eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061ef:	75 17                	jne    f0106208 <sched_kill_all+0x160>
f01061f1:	83 ec 04             	sub    $0x4,%esp
f01061f4:	68 27 3d 12 f0       	push   $0xf0123d27
f01061f9:	68 37 02 00 00       	push   $0x237
f01061fe:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0106203:	e8 31 a1 ff ff       	call   f0100339 <_panic>
f0106208:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010620b:	8b 40 08             	mov    0x8(%eax),%eax
f010620e:	85 c0                	test   %eax,%eax
f0106210:	74 11                	je     f0106223 <sched_kill_all+0x17b>
f0106212:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106215:	8b 40 08             	mov    0x8(%eax),%eax
f0106218:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010621b:	8b 52 0c             	mov    0xc(%edx),%edx
f010621e:	89 50 0c             	mov    %edx,0xc(%eax)
f0106221:	eb 16                	jmp    f0106239 <sched_kill_all+0x191>
f0106223:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106228:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010622b:	c1 e2 04             	shl    $0x4,%edx
f010622e:	01 c2                	add    %eax,%edx
f0106230:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106233:	8b 40 0c             	mov    0xc(%eax),%eax
f0106236:	89 42 04             	mov    %eax,0x4(%edx)
f0106239:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010623c:	8b 40 0c             	mov    0xc(%eax),%eax
f010623f:	85 c0                	test   %eax,%eax
f0106241:	74 11                	je     f0106254 <sched_kill_all+0x1ac>
f0106243:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106246:	8b 40 0c             	mov    0xc(%eax),%eax
f0106249:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010624c:	8b 52 08             	mov    0x8(%edx),%edx
f010624f:	89 50 08             	mov    %edx,0x8(%eax)
f0106252:	eb 15                	jmp    f0106269 <sched_kill_all+0x1c1>
f0106254:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106259:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010625c:	c1 e2 04             	shl    $0x4,%edx
f010625f:	01 c2                	add    %eax,%edx
f0106261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106264:	8b 40 08             	mov    0x8(%eax),%eax
f0106267:	89 02                	mov    %eax,(%edx)
f0106269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106276:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010627d:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106282:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106285:	c1 e2 04             	shl    $0x4,%edx
f0106288:	01 d0                	add    %edx,%eax
f010628a:	8b 50 0c             	mov    0xc(%eax),%edx
f010628d:	4a                   	dec    %edx
f010628e:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0106291:	83 ec 0c             	sub    $0xc,%esp
f0106294:	ff 75 f4             	pushl  -0xc(%ebp)
f0106297:	e8 fe 45 00 00       	call   f010a89a <env_free>
f010629c:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f010629f:	83 ec 0c             	sub    $0xc,%esp
f01062a2:	68 ae 3e 12 f0       	push   $0xf0123eae
f01062a7:	e8 df ac ff ff       	call   f0100f8b <cprintf>
f01062ac:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01062af:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01062b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062b7:	c1 e2 04             	shl    $0x4,%edx
f01062ba:	01 d0                	add    %edx,%eax
f01062bc:	8b 40 08             	mov    0x8(%eax),%eax
f01062bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01062c2:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01062c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062ca:	c1 e2 04             	shl    $0x4,%edx
f01062cd:	01 d0                	add    %edx,%eax
f01062cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062d3:	74 08                	je     f01062dd <sched_kill_all+0x235>
f01062d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062d8:	8b 52 08             	mov    0x8(%edx),%edx
f01062db:	eb 05                	jmp    f01062e2 <sched_kill_all+0x23a>
f01062dd:	ba 00 00 00 00       	mov    $0x0,%edx
f01062e2:	89 50 08             	mov    %edx,0x8(%eax)
f01062e5:	8b 40 08             	mov    0x8(%eax),%eax
f01062e8:	85 c0                	test   %eax,%eax
f01062ea:	0f 85 dd fe ff ff    	jne    f01061cd <sched_kill_all+0x125>
f01062f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062f4:	0f 85 d3 fe ff ff    	jne    f01061cd <sched_kill_all+0x125>
f01062fa:	eb 13                	jmp    f010630f <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01062fc:	83 ec 08             	sub    $0x8,%esp
f01062ff:	ff 75 f0             	pushl  -0x10(%ebp)
f0106302:	68 a8 3f 12 f0       	push   $0xf0123fa8
f0106307:	e8 7f ac ff ff       	call   f0100f8b <cprintf>
f010630c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f010630f:	83 ec 0c             	sub    $0xc,%esp
f0106312:	68 4c 3f 12 f0       	push   $0xf0123f4c
f0106317:	e8 6f ac ff ff       	call   f0100f8b <cprintf>
f010631c:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010631f:	ff 45 f0             	incl   -0x10(%ebp)
f0106322:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f0106327:	0f b6 c0             	movzbl %al,%eax
f010632a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010632d:	0f 8f 59 fe ff ff    	jg     f010618c <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106333:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f0106338:	85 c0                	test   %eax,%eax
f010633a:	0f 84 95 00 00 00    	je     f01063d5 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0106340:	83 ec 0c             	sub    $0xc,%esp
f0106343:	68 d8 40 12 f0       	push   $0xf01240d8
f0106348:	e8 3e ac ff ff       	call   f0100f8b <cprintf>
f010634d:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106350:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f0106355:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106358:	eb 52                	jmp    f01063ac <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010635a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010635d:	8d 50 20             	lea    0x20(%eax),%edx
f0106360:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106363:	8b 40 10             	mov    0x10(%eax),%eax
f0106366:	83 ec 04             	sub    $0x4,%esp
f0106369:	52                   	push   %edx
f010636a:	50                   	push   %eax
f010636b:	68 74 40 12 f0       	push   $0xf0124074
f0106370:	e8 16 ac ff ff       	call   f0100f8b <cprintf>
f0106375:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0106378:	83 ec 0c             	sub    $0xc,%esp
f010637b:	ff 75 f4             	pushl  -0xc(%ebp)
f010637e:	e8 47 f2 ff ff       	call   f01055ca <sched_remove_exit>
f0106383:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106386:	83 ec 0c             	sub    $0xc,%esp
f0106389:	ff 75 f4             	pushl  -0xc(%ebp)
f010638c:	e8 09 45 00 00       	call   f010a89a <env_free>
f0106391:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106394:	83 ec 0c             	sub    $0xc,%esp
f0106397:	68 ae 3e 12 f0       	push   $0xf0123eae
f010639c:	e8 ea ab ff ff       	call   f0100f8b <cprintf>
f01063a1:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063a4:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f01063a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01063b0:	74 08                	je     f01063ba <sched_kill_all+0x312>
f01063b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063b5:	8b 40 08             	mov    0x8(%eax),%eax
f01063b8:	eb 05                	jmp    f01063bf <sched_kill_all+0x317>
f01063ba:	b8 00 00 00 00       	mov    $0x0,%eax
f01063bf:	a3 28 c5 5e f0       	mov    %eax,0xf05ec528
f01063c4:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f01063c9:	85 c0                	test   %eax,%eax
f01063cb:	75 8d                	jne    f010635a <sched_kill_all+0x2b2>
f01063cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01063d1:	75 87                	jne    f010635a <sched_kill_all+0x2b2>
f01063d3:	eb 10                	jmp    f01063e5 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01063d5:	83 ec 0c             	sub    $0xc,%esp
f01063d8:	68 ee 3f 12 f0       	push   $0xf0123fee
f01063dd:	e8 a9 ab ff ff       	call   f0100f8b <cprintf>
f01063e2:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01063e5:	e8 f8 44 00 00       	call   f010a8e2 <get_cpu_proc>
f01063ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01063ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01063f1:	74 6b                	je     f010645e <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01063f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01063f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01063f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063fc:	8b 40 18             	mov    0x18(%eax),%eax
f01063ff:	83 f8 02             	cmp    $0x2,%eax
f0106402:	74 19                	je     f010641d <sched_kill_all+0x375>
f0106404:	68 b4 3e 12 f0       	push   $0xf0123eb4
f0106409:	68 d6 3c 12 f0       	push   $0xf0123cd6
f010640e:	68 57 02 00 00       	push   $0x257
f0106413:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0106418:	e8 1c 9f ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010641d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106420:	8d 50 20             	lea    0x20(%eax),%edx
f0106423:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106426:	8b 40 10             	mov    0x10(%eax),%eax
f0106429:	83 ec 04             	sub    $0x4,%esp
f010642c:	52                   	push   %edx
f010642d:	50                   	push   %eax
f010642e:	68 d8 3e 12 f0       	push   $0xf0123ed8
f0106433:	e8 53 ab ff ff       	call   f0100f8b <cprintf>
f0106438:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010643b:	83 ec 0c             	sub    $0xc,%esp
f010643e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106441:	e8 54 44 00 00       	call   f010a89a <env_free>
f0106446:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106449:	83 ec 0c             	sub    $0xc,%esp
f010644c:	68 ae 3e 12 f0       	push   $0xf0123eae
f0106451:	e8 35 ab ff ff       	call   f0100f8b <cprintf>
f0106456:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f0106459:	e8 fd 45 00 00       	call   f010aa5b <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010645e:	83 ec 0c             	sub    $0xc,%esp
f0106461:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106466:	e8 7e 84 00 00       	call   f010e8e9 <release_spinlock>
f010646b:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f010646e:	e8 4f b9 ff ff       	call   f0101dc2 <get_into_prompt>

f0106473 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106473:	55                   	push   %ebp
f0106474:	89 e5                	mov    %esp,%ebp
f0106476:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106479:	83 ec 0c             	sub    $0xc,%esp
f010647c:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106481:	e8 dc 83 00 00       	call   f010e862 <acquire_spinlock>
f0106486:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106489:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106490:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106497:	e9 37 01 00 00       	jmp    f01065d3 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010649c:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01064a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064a4:	c1 e2 04             	shl    $0x4,%edx
f01064a7:	01 d0                	add    %edx,%eax
f01064a9:	8b 00                	mov    (%eax),%eax
f01064ab:	85 c0                	test   %eax,%eax
f01064ad:	0f 84 1d 01 00 00    	je     f01065d0 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f01064b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01064ba:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01064bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064c2:	c1 e2 04             	shl    $0x4,%edx
f01064c5:	01 d0                	add    %edx,%eax
f01064c7:	8b 00                	mov    (%eax),%eax
f01064c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01064cc:	e9 c7 00 00 00       	jmp    f0106598 <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01064d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01064d5:	75 17                	jne    f01064ee <sched_exit_all_ready_envs+0x7b>
f01064d7:	83 ec 04             	sub    $0x4,%esp
f01064da:	68 27 3d 12 f0       	push   $0xf0123d27
f01064df:	68 79 02 00 00       	push   $0x279
f01064e4:	68 eb 3c 12 f0       	push   $0xf0123ceb
f01064e9:	e8 4b 9e ff ff       	call   f0100339 <_panic>
f01064ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064f1:	8b 40 08             	mov    0x8(%eax),%eax
f01064f4:	85 c0                	test   %eax,%eax
f01064f6:	74 11                	je     f0106509 <sched_exit_all_ready_envs+0x96>
f01064f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064fb:	8b 40 08             	mov    0x8(%eax),%eax
f01064fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106501:	8b 52 0c             	mov    0xc(%edx),%edx
f0106504:	89 50 0c             	mov    %edx,0xc(%eax)
f0106507:	eb 16                	jmp    f010651f <sched_exit_all_ready_envs+0xac>
f0106509:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010650e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106511:	c1 e2 04             	shl    $0x4,%edx
f0106514:	01 c2                	add    %eax,%edx
f0106516:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106519:	8b 40 0c             	mov    0xc(%eax),%eax
f010651c:	89 42 04             	mov    %eax,0x4(%edx)
f010651f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106522:	8b 40 0c             	mov    0xc(%eax),%eax
f0106525:	85 c0                	test   %eax,%eax
f0106527:	74 11                	je     f010653a <sched_exit_all_ready_envs+0xc7>
f0106529:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010652c:	8b 40 0c             	mov    0xc(%eax),%eax
f010652f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106532:	8b 52 08             	mov    0x8(%edx),%edx
f0106535:	89 50 08             	mov    %edx,0x8(%eax)
f0106538:	eb 15                	jmp    f010654f <sched_exit_all_ready_envs+0xdc>
f010653a:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010653f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106542:	c1 e2 04             	shl    $0x4,%edx
f0106545:	01 c2                	add    %eax,%edx
f0106547:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010654a:	8b 40 08             	mov    0x8(%eax),%eax
f010654d:	89 02                	mov    %eax,(%edx)
f010654f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106552:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106559:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106563:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106568:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010656b:	c1 e2 04             	shl    $0x4,%edx
f010656e:	01 d0                	add    %edx,%eax
f0106570:	8b 50 0c             	mov    0xc(%eax),%edx
f0106573:	4a                   	dec    %edx
f0106574:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0106577:	83 ec 0c             	sub    $0xc,%esp
f010657a:	ff 75 f4             	pushl  -0xc(%ebp)
f010657d:	e8 c1 ef ff ff       	call   f0105543 <sched_insert_exit>
f0106582:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106585:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010658a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010658d:	c1 e2 04             	shl    $0x4,%edx
f0106590:	01 d0                	add    %edx,%eax
f0106592:	8b 40 08             	mov    0x8(%eax),%eax
f0106595:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106598:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f010659d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a0:	c1 e2 04             	shl    $0x4,%edx
f01065a3:	01 d0                	add    %edx,%eax
f01065a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065a9:	74 08                	je     f01065b3 <sched_exit_all_ready_envs+0x140>
f01065ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065ae:	8b 52 08             	mov    0x8(%edx),%edx
f01065b1:	eb 05                	jmp    f01065b8 <sched_exit_all_ready_envs+0x145>
f01065b3:	ba 00 00 00 00       	mov    $0x0,%edx
f01065b8:	89 50 08             	mov    %edx,0x8(%eax)
f01065bb:	8b 40 08             	mov    0x8(%eax),%eax
f01065be:	85 c0                	test   %eax,%eax
f01065c0:	0f 85 0b ff ff ff    	jne    f01064d1 <sched_exit_all_ready_envs+0x5e>
f01065c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065ca:	0f 85 01 ff ff ff    	jne    f01064d1 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01065d0:	ff 45 f0             	incl   -0x10(%ebp)
f01065d3:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f01065d8:	0f b6 c0             	movzbl %al,%eax
f01065db:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01065de:	0f 8f b8 fe ff ff    	jg     f010649c <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01065e4:	83 ec 0c             	sub    $0xc,%esp
f01065e7:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f01065ec:	e8 f8 82 00 00       	call   f010e8e9 <release_spinlock>
f01065f1:	83 c4 10             	add    $0x10,%esp
}
f01065f4:	90                   	nop
f01065f5:	c9                   	leave  
f01065f6:	c3                   	ret    

f01065f7 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01065f7:	55                   	push   %ebp
f01065f8:	89 e5                	mov    %esp,%ebp
	return ticks;
f01065fa:	a1 48 cb 5e f0       	mov    0xf05ecb48,%eax
f01065ff:	8b 15 4c cb 5e f0    	mov    0xf05ecb4c,%edx
}
f0106605:	5d                   	pop    %ebp
f0106606:	c3                   	ret    

f0106607 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106607:	55                   	push   %ebp
f0106608:	89 e5                	mov    %esp,%ebp
f010660a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010660d:	83 ec 04             	sub    $0x4,%esp
f0106610:	68 04 41 12 f0       	push   $0xf0124104
f0106615:	68 8c 02 00 00       	push   $0x28c
f010661a:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010661f:	e8 15 9d ff ff       	call   f0100339 <_panic>

f0106624 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106624:	55                   	push   %ebp
f0106625:	89 e5                	mov    %esp,%ebp
f0106627:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010662a:	83 ec 04             	sub    $0x4,%esp
f010662d:	68 04 41 12 f0       	push   $0xf0124104
f0106632:	68 94 02 00 00       	push   $0x294
f0106637:	68 eb 3c 12 f0       	push   $0xf0123ceb
f010663c:	e8 f8 9c ff ff       	call   f0100339 <_panic>

f0106641 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f0106641:	55                   	push   %ebp
f0106642:	89 e5                	mov    %esp,%ebp
f0106644:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106647:	83 ec 04             	sub    $0x4,%esp
f010664a:	68 04 41 12 f0       	push   $0xf0124104
f010664f:	68 9c 02 00 00       	push   $0x29c
f0106654:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0106659:	e8 db 9c ff ff       	call   f0100339 <_panic>

f010665e <get_load_average>:
}
int get_load_average()
{
f010665e:	55                   	push   %ebp
f010665f:	89 e5                	mov    %esp,%ebp
f0106661:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106664:	83 ec 04             	sub    $0x4,%esp
f0106667:	68 04 41 12 f0       	push   $0xf0124104
f010666c:	68 a4 02 00 00       	push   $0x2a4
f0106671:	68 eb 3c 12 f0       	push   $0xf0123ceb
f0106676:	e8 be 9c ff ff       	call   f0100339 <_panic>

f010667b <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f010667b:	55                   	push   %ebp
f010667c:	89 e5                	mov    %esp,%ebp
f010667e:	a1 94 c9 5e f0       	mov    0xf05ec994,%eax
f0106683:	85 c0                	test   %eax,%eax
f0106685:	75 07                	jne    f010668e <isSchedMethodRR+0x13>
f0106687:	b8 01 00 00 00       	mov    $0x1,%eax
f010668c:	eb 05                	jmp    f0106693 <isSchedMethodRR+0x18>
f010668e:	b8 00 00 00 00       	mov    $0x0,%eax
f0106693:	5d                   	pop    %ebp
f0106694:	c3                   	ret    

f0106695 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f0106695:	55                   	push   %ebp
f0106696:	89 e5                	mov    %esp,%ebp
f0106698:	a1 94 c9 5e f0       	mov    0xf05ec994,%eax
f010669d:	83 f8 01             	cmp    $0x1,%eax
f01066a0:	75 07                	jne    f01066a9 <isSchedMethodMLFQ+0x14>
f01066a2:	b8 01 00 00 00       	mov    $0x1,%eax
f01066a7:	eb 05                	jmp    f01066ae <isSchedMethodMLFQ+0x19>
f01066a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01066ae:	5d                   	pop    %ebp
f01066af:	c3                   	ret    

f01066b0 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f01066b0:	55                   	push   %ebp
f01066b1:	89 e5                	mov    %esp,%ebp
f01066b3:	a1 94 c9 5e f0       	mov    0xf05ec994,%eax
f01066b8:	83 f8 02             	cmp    $0x2,%eax
f01066bb:	75 07                	jne    f01066c4 <isSchedMethodBSD+0x14>
f01066bd:	b8 01 00 00 00       	mov    $0x1,%eax
f01066c2:	eb 05                	jmp    f01066c9 <isSchedMethodBSD+0x19>
f01066c4:	b8 00 00 00 00       	mov    $0x0,%eax
f01066c9:	5d                   	pop    %ebp
f01066ca:	c3                   	ret    

f01066cb <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01066cb:	55                   	push   %ebp
f01066cc:	89 e5                	mov    %esp,%ebp
f01066ce:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01066d1:	c7 05 78 c6 5e f0 00 	movl   $0x0,0xf05ec678
f01066d8:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01066db:	83 ec 0c             	sub    $0xc,%esp
f01066de:	6a 0a                	push   $0xa
f01066e0:	e8 57 02 00 00       	call   f010693c <sched_init_RR>
f01066e5:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f01066e8:	83 ec 0c             	sub    $0xc,%esp
f01066eb:	68 10 c5 5e f0       	push   $0xf05ec510
f01066f0:	e8 12 e8 ff ff       	call   f0104f07 <init_queue>
f01066f5:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f01066f8:	83 ec 0c             	sub    $0xc,%esp
f01066fb:	68 20 c5 5e f0       	push   $0xf05ec520
f0106700:	e8 02 e8 ff ff       	call   f0104f07 <init_queue>
f0106705:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106708:	e8 94 09 00 00       	call   f01070a1 <mycpu>
f010670d:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106714:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106717:	83 ec 08             	sub    $0x8,%esp
f010671a:	68 18 41 12 f0       	push   $0xf0124118
f010671f:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106724:	e8 08 81 00 00       	call   f010e831 <init_spinlock>
f0106729:	83 c4 10             	add    $0x10,%esp
}
f010672c:	90                   	nop
f010672d:	c9                   	leave  
f010672e:	c3                   	ret    

f010672f <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f010672f:	55                   	push   %ebp
f0106730:	89 e5                	mov    %esp,%ebp
f0106732:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106735:	9c                   	pushf  
f0106736:	58                   	pop    %eax
f0106737:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010673a:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f010673d:	25 00 02 00 00       	and    $0x200,%eax
f0106742:	85 c0                	test   %eax,%eax
f0106744:	74 14                	je     f010675a <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f0106746:	83 ec 04             	sub    $0x4,%esp
f0106749:	68 2c 41 12 f0       	push   $0xf012412c
f010674e:	6a 37                	push   $0x37
f0106750:	68 62 41 12 f0       	push   $0xf0124162
f0106755:	e8 df 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f010675a:	e8 42 09 00 00       	call   f01070a1 <mycpu>
f010675f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106762:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106765:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010676c:	00 00 00 

	chk1();
f010676f:	e8 37 72 01 00       	call   f011d9ab <chk1>
	c->scheduler_status = SCH_STARTED;
f0106774:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106777:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f010677e:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106781:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f0106788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010678f:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106790:	83 ec 0c             	sub    $0xc,%esp
f0106793:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106798:	e8 c5 80 00 00       	call   f010e862 <acquire_spinlock>
f010679d:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f01067a0:	a1 94 c9 5e f0       	mov    0xf05ec994,%eax
f01067a5:	8b 04 85 4c b9 17 f0 	mov    -0xfe846b4(,%eax,4),%eax
f01067ac:	ff d0                	call   *%eax
f01067ae:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f01067b1:	e8 2c 41 00 00       	call   f010a8e2 <get_cpu_proc>
f01067b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f01067b9:	83 ec 0c             	sub    $0xc,%esp
f01067bc:	ff 75 e8             	pushl  -0x18(%ebp)
f01067bf:	e8 47 41 00 00       	call   f010a90b <set_cpu_proc>
f01067c4:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f01067c7:	83 ec 0c             	sub    $0xc,%esp
f01067ca:	ff 75 e8             	pushl  -0x18(%ebp)
f01067cd:	e8 df 71 01 00       	call   f011d9b1 <chk2>
f01067d2:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f01067d5:	83 ec 0c             	sub    $0xc,%esp
f01067d8:	ff 75 e0             	pushl  -0x20(%ebp)
f01067db:	e8 2b 41 00 00       	call   f010a90b <set_cpu_proc>
f01067e0:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f01067e3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01067e7:	0f 84 d6 00 00 00    	je     f01068c3 <fos_scheduler+0x194>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f01067ed:	83 ec 0c             	sub    $0xc,%esp
f01067f0:	ff 75 e8             	pushl  -0x18(%ebp)
f01067f3:	e8 13 41 00 00       	call   f010a90b <set_cpu_proc>
f01067f8:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f01067fb:	83 ec 0c             	sub    $0xc,%esp
f01067fe:	ff 75 e8             	pushl  -0x18(%ebp)
f0106801:	e8 78 43 00 00       	call   f010ab7e <switchuvm>
f0106806:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106809:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010680c:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106813:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106816:	8b 40 04             	mov    0x4(%eax),%eax
f0106819:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010681c:	83 c2 04             	add    $0x4,%edx
f010681f:	83 ec 08             	sub    $0x8,%esp
f0106822:	50                   	push   %eax
f0106823:	52                   	push   %edx
f0106824:	e8 e6 e2 ff ff       	call   f0104b0f <context_switch>
f0106829:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010682c:	9c                   	pushf  
f010682d:	58                   	pop    %eax
f010682e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106831:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106834:	25 00 02 00 00       	and    $0x200,%eax
f0106839:	85 c0                	test   %eax,%eax
f010683b:	74 14                	je     f0106851 <fos_scheduler+0x122>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f010683d:	83 ec 04             	sub    $0x4,%esp
f0106840:	68 74 41 12 f0       	push   $0xf0124174
f0106845:	6a 74                	push   $0x74
f0106847:	68 62 41 12 f0       	push   $0xf0124162
f010684c:	e8 e8 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0106851:	e8 02 e4 ff ff       	call   f0104c58 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0106856:	e8 87 40 00 00       	call   f010a8e2 <get_cpu_proc>
f010685b:	89 c2                	mov    %eax,%edx
f010685d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106860:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106866:	39 c2                	cmp    %eax,%edx
f0106868:	74 16                	je     f0106880 <fos_scheduler+0x151>
f010686a:	68 ab 41 12 f0       	push   $0xf01241ab
f010686f:	68 c5 41 12 f0       	push   $0xf01241c5
f0106874:	6a 7d                	push   $0x7d
f0106876:	68 62 41 12 f0       	push   $0xf0124162
f010687b:	e8 b9 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106880:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106883:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106889:	8b 40 18             	mov    0x18(%eax),%eax
f010688c:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f010688f:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106893:	75 16                	jne    f01068ab <fos_scheduler+0x17c>
f0106895:	68 da 41 12 f0       	push   $0xf01241da
f010689a:	68 c5 41 12 f0       	push   $0xf01241c5
f010689f:	6a 7f                	push   $0x7f
f01068a1:	68 62 41 12 f0       	push   $0xf0124162
f01068a6:	e8 8e 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f01068ab:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f01068af:	74 12                	je     f01068c3 <fos_scheduler+0x194>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f01068b1:	e8 b1 42 00 00       	call   f010ab67 <switchkvm>
					set_cpu_proc(NULL);
f01068b6:	83 ec 0c             	sub    $0xc,%esp
f01068b9:	6a 00                	push   $0x0
f01068bb:	e8 4b 40 00 00       	call   f010a90b <set_cpu_proc>
f01068c0:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f01068c3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01068c7:	0f 85 d3 fe ff ff    	jne    f01067a0 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f01068cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f01068d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01068db:	eb 36                	jmp    f0106913 <fos_scheduler+0x1e4>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f01068dd:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f01068e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01068e6:	89 d0                	mov    %edx,%eax
f01068e8:	c1 e0 02             	shl    $0x2,%eax
f01068eb:	01 d0                	add    %edx,%eax
f01068ed:	01 c0                	add    %eax,%eax
f01068ef:	01 d0                	add    %edx,%eax
f01068f1:	c1 e0 02             	shl    $0x2,%eax
f01068f4:	01 d0                	add    %edx,%eax
f01068f6:	01 c0                	add    %eax,%eax
f01068f8:	01 d0                	add    %edx,%eax
f01068fa:	c1 e0 04             	shl    $0x4,%eax
f01068fd:	01 c8                	add    %ecx,%eax
f01068ff:	8b 40 18             	mov    0x18(%eax),%eax
f0106902:	83 f8 03             	cmp    $0x3,%eax
f0106905:	75 09                	jne    f0106910 <fos_scheduler+0x1e1>
			{
				is_any_blocked = 1;
f0106907:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010690e:	eb 0d                	jmp    f010691d <fos_scheduler+0x1ee>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106910:	ff 45 f0             	incl   -0x10(%ebp)
f0106913:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106916:	3d cf 02 00 00       	cmp    $0x2cf,%eax
f010691b:	76 c0                	jbe    f01068dd <fos_scheduler+0x1ae>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f010691d:	83 ec 0c             	sub    $0xc,%esp
f0106920:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106925:	e8 bf 7f 00 00       	call   f010e8e9 <release_spinlock>
f010692a:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f010692d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106931:	0f 8f 58 fe ff ff    	jg     f010678f <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0106937:	e8 86 b4 ff ff       	call   f0101dc2 <get_into_prompt>

f010693c <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f010693c:	55                   	push   %ebp
f010693d:	89 e5                	mov    %esp,%ebp
f010693f:	83 ec 28             	sub    $0x28,%esp
f0106942:	8b 45 08             	mov    0x8(%ebp),%eax
f0106945:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0106948:	c6 05 e4 cb 5e f0 01 	movb   $0x1,0xf05ecbe4
#if USE_KHEAP
	sched_delete_ready_queues();
f010694f:	e8 63 e8 ff ff       	call   f01051b7 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0106954:	83 ec 0c             	sub    $0xc,%esp
f0106957:	6a 10                	push   $0x10
f0106959:	e8 ae 23 00 00       	call   f0108d0c <kmalloc>
f010695e:	83 c4 10             	add    $0x10,%esp
f0106961:	a3 30 c5 5e f0       	mov    %eax,0xf05ec530
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106966:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f010696b:	0f b6 c0             	movzbl %al,%eax
f010696e:	83 ec 0c             	sub    $0xc,%esp
f0106971:	50                   	push   %eax
f0106972:	e8 95 23 00 00       	call   f0108d0c <kmalloc>
f0106977:	83 c4 10             	add    $0x10,%esp
f010697a:	a3 64 c8 5e f0       	mov    %eax,0xf05ec864
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f010697f:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f0106984:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106987:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106989:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f010698e:	8a 00                	mov    (%eax),%al
f0106990:	0f b6 c0             	movzbl %al,%eax
f0106993:	83 ec 0c             	sub    $0xc,%esp
f0106996:	50                   	push   %eax
f0106997:	e8 85 e3 ff ff       	call   f0104d21 <kclock_set_quantum>
f010699c:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f010699f:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f01069a4:	83 ec 0c             	sub    $0xc,%esp
f01069a7:	50                   	push   %eax
f01069a8:	e8 5a e5 ff ff       	call   f0104f07 <init_queue>
f01069ad:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f01069b0:	e8 cb e4 ff ff       	call   f0104e80 <kclock_read_cnt0_latch>
f01069b5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f01069b9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f01069bd:	83 ec 08             	sub    $0x8,%esp
f01069c0:	50                   	push   %eax
f01069c1:	68 f0 41 12 f0       	push   $0xf01241f0
f01069c6:	e8 c0 a5 ff ff       	call   f0100f8b <cprintf>
f01069cb:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f01069ce:	e8 ce 06 00 00       	call   f01070a1 <mycpu>
f01069d3:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01069da:	00 00 00 
	scheduler_method = SCH_RR;
f01069dd:	c7 05 94 c9 5e f0 00 	movl   $0x0,0xf05ec994
f01069e4:	00 00 00 
	//=========================================
	//=========================================
}
f01069e7:	90                   	nop
f01069e8:	c9                   	leave  
f01069e9:	c3                   	ret    

f01069ea <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f01069ea:	55                   	push   %ebp
f01069eb:	89 e5                	mov    %esp,%ebp
f01069ed:	83 ec 18             	sub    $0x18,%esp
f01069f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01069f3:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f01069f6:	e8 bc e7 ff ff       	call   f01051b7 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01069fb:	83 ec 04             	sub    $0x4,%esp
f01069fe:	68 18 42 12 f0       	push   $0xf0124218
f0106a03:	68 ce 00 00 00       	push   $0xce
f0106a08:	68 62 41 12 f0       	push   $0xf0124162
f0106a0d:	e8 27 99 ff ff       	call   f0100339 <_panic>

f0106a12 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a12:	55                   	push   %ebp
f0106a13:	89 e5                	mov    %esp,%ebp
f0106a15:	83 ec 18             	sub    $0x18,%esp
f0106a18:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a1e:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a21:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a24:	83 ec 04             	sub    $0x4,%esp
f0106a27:	68 18 42 12 f0       	push   $0xf0124218
f0106a2c:	68 e4 00 00 00       	push   $0xe4
f0106a31:	68 62 41 12 f0       	push   $0xf0124162
f0106a36:	e8 fe 98 ff ff       	call   f0100339 <_panic>

f0106a3b <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106a3b:	55                   	push   %ebp
f0106a3c:	89 e5                	mov    %esp,%ebp
f0106a3e:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106a41:	83 ec 0c             	sub    $0xc,%esp
f0106a44:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106a49:	e8 2d 80 00 00       	call   f010ea7b <holding_spinlock>
f0106a4e:	83 c4 10             	add    $0x10,%esp
f0106a51:	85 c0                	test   %eax,%eax
f0106a53:	75 17                	jne    f0106a6c <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106a55:	83 ec 04             	sub    $0x4,%esp
f0106a58:	68 2c 42 12 f0       	push   $0xf012422c
f0106a5d:	68 fe 00 00 00       	push   $0xfe
f0106a62:	68 62 41 12 f0       	push   $0xf0124162
f0106a67:	e8 cd 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106a6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106a73:	e8 6a 3e 00 00       	call   f010a8e2 <get_cpu_proc>
f0106a78:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106a7f:	74 14                	je     f0106a95 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106a81:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106a86:	83 ec 08             	sub    $0x8,%esp
f0106a89:	ff 75 f0             	pushl  -0x10(%ebp)
f0106a8c:	50                   	push   %eax
f0106a8d:	e8 b6 e4 ff ff       	call   f0104f48 <enqueue>
f0106a92:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106a95:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f0106a9a:	83 ec 0c             	sub    $0xc,%esp
f0106a9d:	50                   	push   %eax
f0106a9e:	e8 36 e5 ff ff       	call   f0104fd9 <dequeue>
f0106aa3:	83 c4 10             	add    $0x10,%esp
f0106aa6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106aa9:	a1 64 c8 5e f0       	mov    0xf05ec864,%eax
f0106aae:	8a 00                	mov    (%eax),%al
f0106ab0:	0f b6 c0             	movzbl %al,%eax
f0106ab3:	83 ec 0c             	sub    $0xc,%esp
f0106ab6:	50                   	push   %eax
f0106ab7:	e8 65 e2 ff ff       	call   f0104d21 <kclock_set_quantum>
f0106abc:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106ac2:	c9                   	leave  
f0106ac3:	c3                   	ret    

f0106ac4 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106ac4:	55                   	push   %ebp
f0106ac5:	89 e5                	mov    %esp,%ebp
f0106ac7:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aca:	83 ec 0c             	sub    $0xc,%esp
f0106acd:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106ad2:	e8 a4 7f 00 00       	call   f010ea7b <holding_spinlock>
f0106ad7:	83 c4 10             	add    $0x10,%esp
f0106ada:	85 c0                	test   %eax,%eax
f0106adc:	75 17                	jne    f0106af5 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106ade:	83 ec 04             	sub    $0x4,%esp
f0106ae1:	68 78 42 12 f0       	push   $0xf0124278
f0106ae6:	68 1d 01 00 00       	push   $0x11d
f0106aeb:	68 62 41 12 f0       	push   $0xf0124162
f0106af0:	e8 44 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106af5:	83 ec 04             	sub    $0x4,%esp
f0106af8:	68 18 42 12 f0       	push   $0xf0124218
f0106afd:	68 23 01 00 00       	push   $0x123
f0106b02:	68 62 41 12 f0       	push   $0xf0124162
f0106b07:	e8 2d 98 ff ff       	call   f0100339 <_panic>

f0106b0c <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b0c:	55                   	push   %ebp
f0106b0d:	89 e5                	mov    %esp,%ebp
f0106b0f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b12:	83 ec 0c             	sub    $0xc,%esp
f0106b15:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f0106b1a:	e8 5c 7f 00 00       	call   f010ea7b <holding_spinlock>
f0106b1f:	83 c4 10             	add    $0x10,%esp
f0106b22:	85 c0                	test   %eax,%eax
f0106b24:	75 17                	jne    f0106b3d <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b26:	83 ec 04             	sub    $0x4,%esp
f0106b29:	68 c8 42 12 f0       	push   $0xf01242c8
f0106b2e:	68 2e 01 00 00       	push   $0x12e
f0106b33:	68 62 41 12 f0       	push   $0xf0124162
f0106b38:	e8 fc 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b3d:	83 ec 04             	sub    $0x4,%esp
f0106b40:	68 18 42 12 f0       	push   $0xf0124218
f0106b45:	68 34 01 00 00       	push   $0x134
f0106b4a:	68 62 41 12 f0       	push   $0xf0124162
f0106b4f:	e8 e5 97 ff ff       	call   f0100339 <_panic>

f0106b54 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106b54:	55                   	push   %ebp
f0106b55:	89 e5                	mov    %esp,%ebp
f0106b57:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106b5a:	e8 51 fb ff ff       	call   f01066b0 <isSchedMethodBSD>
f0106b5f:	85 c0                	test   %eax,%eax
f0106b61:	74 17                	je     f0106b7a <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106b63:	83 ec 04             	sub    $0x4,%esp
f0106b66:	68 18 42 12 f0       	push   $0xf0124218
f0106b6b:	68 43 01 00 00       	push   $0x143
f0106b70:	68 62 41 12 f0       	push   $0xf0124162
f0106b75:	e8 bf 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106b7a:	a1 48 cb 5e f0       	mov    0xf05ecb48,%eax
f0106b7f:	8b 15 4c cb 5e f0    	mov    0xf05ecb4c,%edx
f0106b85:	83 c0 01             	add    $0x1,%eax
f0106b88:	83 d2 00             	adc    $0x0,%edx
f0106b8b:	a3 48 cb 5e f0       	mov    %eax,0xf05ecb48
f0106b90:	89 15 4c cb 5e f0    	mov    %edx,0xf05ecb4c
	struct Env* p = get_cpu_proc();
f0106b96:	e8 47 3d 00 00       	call   f010a8e2 <get_cpu_proc>
f0106b9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106b9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ba2:	74 30                	je     f0106bd4 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ba7:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0106bad:	8d 50 01             	lea    0x1(%eax),%edx
f0106bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bb3:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106bb9:	83 ec 0c             	sub    $0xc,%esp
f0106bbc:	6a 01                	push   $0x1
f0106bbe:	e8 3e 78 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0106bc3:	83 c4 10             	add    $0x10,%esp
f0106bc6:	85 c0                	test   %eax,%eax
f0106bc8:	74 05                	je     f0106bcf <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106bca:	e8 08 00 00 00       	call   f0106bd7 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106bcf:	e8 28 3e 00 00       	call   f010a9fc <yield>
	}
	/*****************************************/
}
f0106bd4:	90                   	nop
f0106bd5:	c9                   	leave  
f0106bd6:	c3                   	ret    

f0106bd7 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106bd7:	55                   	push   %ebp
f0106bd8:	89 e5                	mov    %esp,%ebp
f0106bda:	53                   	push   %ebx
f0106bdb:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106bde:	e8 ff 3c 00 00       	call   f010a8e2 <get_cpu_proc>
f0106be3:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106be6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106bea:	0f 84 a1 01 00 00    	je     f0106d91 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106bf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106bf3:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0106bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106bfc:	eb 78                	jmp    f0106c76 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c01:	8b 00                	mov    (%eax),%eax
f0106c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c09:	8b 40 64             	mov    0x64(%eax),%eax
f0106c0c:	83 ec 08             	sub    $0x8,%esp
f0106c0f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c12:	50                   	push   %eax
f0106c13:	e8 33 22 00 00       	call   f0108e4b <pt_get_page_permissions>
f0106c18:	83 c4 10             	add    $0x10,%esp
f0106c1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c21:	8b 40 08             	mov    0x8(%eax),%eax
f0106c24:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c2a:	83 e0 20             	and    $0x20,%eax
f0106c2d:	85 c0                	test   %eax,%eax
f0106c2f:	74 2b                	je     f0106c5c <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c31:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c34:	c1 e8 02             	shr    $0x2,%eax
f0106c37:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106c3c:	89 c2                	mov    %eax,%edx
f0106c3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c41:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106c44:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c47:	8b 40 64             	mov    0x64(%eax),%eax
f0106c4a:	6a 20                	push   $0x20
f0106c4c:	6a 00                	push   $0x0
f0106c4e:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c51:	50                   	push   %eax
f0106c52:	e8 30 21 00 00       	call   f0108d87 <pt_set_page_permissions>
f0106c57:	83 c4 10             	add    $0x10,%esp
f0106c5a:	eb 0e                	jmp    f0106c6a <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106c5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c5f:	c1 e8 02             	shr    $0x2,%eax
f0106c62:	89 c2                	mov    %eax,%edx
f0106c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c67:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c6d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0106c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c76:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c7a:	74 08                	je     f0106c84 <update_WS_time_stamps+0xad>
f0106c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c7f:	8b 40 10             	mov    0x10(%eax),%eax
f0106c82:	eb 05                	jmp    f0106c89 <update_WS_time_stamps+0xb2>
f0106c84:	b8 00 00 00 00       	mov    $0x0,%eax
f0106c89:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c8c:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0106c92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c95:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0106c9b:	85 c0                	test   %eax,%eax
f0106c9d:	0f 85 5b ff ff ff    	jne    f0106bfe <update_WS_time_stamps+0x27>
f0106ca3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ca7:	0f 85 51 ff ff ff    	jne    f0106bfe <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106cad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106cb4:	e9 ce 00 00 00       	jmp    f0106d87 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106cb9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106cbc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cbf:	89 d0                	mov    %edx,%eax
f0106cc1:	01 c0                	add    %eax,%eax
f0106cc3:	01 d0                	add    %edx,%eax
f0106cc5:	c1 e0 03             	shl    $0x3,%eax
f0106cc8:	01 c8                	add    %ecx,%eax
f0106cca:	05 a4 00 00 00       	add    $0xa4,%eax
f0106ccf:	8a 00                	mov    (%eax),%al
f0106cd1:	3c 01                	cmp    $0x1,%al
f0106cd3:	0f 84 ab 00 00 00    	je     f0106d84 <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106cd9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106cdc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cdf:	89 d0                	mov    %edx,%eax
f0106ce1:	01 c0                	add    %eax,%eax
f0106ce3:	01 d0                	add    %edx,%eax
f0106ce5:	c1 e0 03             	shl    $0x3,%eax
f0106ce8:	01 c8                	add    %ecx,%eax
f0106cea:	05 a0 00 00 00       	add    $0xa0,%eax
f0106cef:	8b 00                	mov    (%eax),%eax
f0106cf1:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106cf4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106cf7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cfa:	89 d0                	mov    %edx,%eax
f0106cfc:	01 c0                	add    %eax,%eax
f0106cfe:	01 d0                	add    %edx,%eax
f0106d00:	c1 e0 03             	shl    $0x3,%eax
f0106d03:	01 c8                	add    %ecx,%eax
f0106d05:	05 a8 00 00 00       	add    $0xa8,%eax
f0106d0a:	8b 00                	mov    (%eax),%eax
f0106d0c:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d12:	8b 40 64             	mov    0x64(%eax),%eax
f0106d15:	83 ec 08             	sub    $0x8,%esp
f0106d18:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d1b:	50                   	push   %eax
f0106d1c:	e8 06 22 00 00       	call   f0108f27 <pd_is_table_used>
f0106d21:	83 c4 10             	add    $0x10,%esp
f0106d24:	85 c0                	test   %eax,%eax
f0106d26:	74 3c                	je     f0106d64 <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d28:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d2b:	c1 e8 02             	shr    $0x2,%eax
f0106d2e:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d33:	89 c1                	mov    %eax,%ecx
f0106d35:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106d38:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d3b:	89 d0                	mov    %edx,%eax
f0106d3d:	01 c0                	add    %eax,%eax
f0106d3f:	01 d0                	add    %edx,%eax
f0106d41:	c1 e0 03             	shl    $0x3,%eax
f0106d44:	01 d8                	add    %ebx,%eax
f0106d46:	05 a8 00 00 00       	add    $0xa8,%eax
f0106d4b:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d50:	8b 40 64             	mov    0x64(%eax),%eax
f0106d53:	83 ec 08             	sub    $0x8,%esp
f0106d56:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d59:	50                   	push   %eax
f0106d5a:	e8 ec 21 00 00       	call   f0108f4b <pd_set_table_unused>
f0106d5f:	83 c4 10             	add    $0x10,%esp
f0106d62:	eb 20                	jmp    f0106d84 <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106d64:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d67:	c1 e8 02             	shr    $0x2,%eax
f0106d6a:	89 c1                	mov    %eax,%ecx
f0106d6c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106d6f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d72:	89 d0                	mov    %edx,%eax
f0106d74:	01 c0                	add    %eax,%eax
f0106d76:	01 d0                	add    %edx,%eax
f0106d78:	c1 e0 03             	shl    $0x3,%eax
f0106d7b:	01 d8                	add    %ebx,%eax
f0106d7d:	05 a8 00 00 00       	add    $0xa8,%eax
f0106d82:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d84:	ff 45 f0             	incl   -0x10(%ebp)
f0106d87:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106d8b:	0f 8e 28 ff ff ff    	jle    f0106cb9 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106d91:	90                   	nop
f0106d92:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106d95:	c9                   	leave  
f0106d96:	c3                   	ret    

f0106d97 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106d97:	55                   	push   %ebp
f0106d98:	89 e5                	mov    %esp,%ebp
f0106d9a:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106d9d:	c7 05 ac 39 5c f0 01 	movl   $0x1,0xf05c39ac
f0106da4:	00 00 00 
f0106da7:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106dae:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106db2:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106db5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106db8:	ee                   	out    %al,(%dx)
f0106db9:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106dc0:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106dc4:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106dc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106dca:	ee                   	out    %al,(%dx)
f0106dcb:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106dd2:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106dd6:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106dd9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106ddc:	ee                   	out    %al,(%dx)
f0106ddd:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106de4:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106de8:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106deb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106dee:	ee                   	out    %al,(%dx)
f0106def:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106df6:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106dfa:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106dfd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e00:	ee                   	out    %al,(%dx)
f0106e01:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e08:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e0c:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e0f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e12:	ee                   	out    %al,(%dx)
f0106e13:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e1a:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e1e:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e21:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e24:	ee                   	out    %al,(%dx)
f0106e25:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e2c:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e30:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e33:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106e36:	ee                   	out    %al,(%dx)
f0106e37:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106e3e:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106e42:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106e45:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106e48:	ee                   	out    %al,(%dx)
f0106e49:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106e50:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106e54:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106e57:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106e5a:	ee                   	out    %al,(%dx)
f0106e5b:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106e62:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106e66:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106e69:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106e6c:	ee                   	out    %al,(%dx)
f0106e6d:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106e74:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106e78:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106e7b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106e7e:	ee                   	out    %al,(%dx)
f0106e7f:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106e86:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106e8a:	8a 45 be             	mov    -0x42(%ebp),%al
f0106e8d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106e90:	ee                   	out    %al,(%dx)
f0106e91:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106e98:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106e9c:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106e9f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106ea2:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106ea3:	66 a1 58 b9 17 f0    	mov    0xf017b958,%ax
f0106ea9:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106ead:	74 15                	je     f0106ec4 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106eaf:	66 a1 58 b9 17 f0    	mov    0xf017b958,%ax
f0106eb5:	0f b7 c0             	movzwl %ax,%eax
f0106eb8:	83 ec 0c             	sub    $0xc,%esp
f0106ebb:	50                   	push   %eax
f0106ebc:	e8 06 00 00 00       	call   f0106ec7 <irq_setmask_8259A>
f0106ec1:	83 c4 10             	add    $0x10,%esp
}
f0106ec4:	90                   	nop
f0106ec5:	c9                   	leave  
f0106ec6:	c3                   	ret    

f0106ec7 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106ec7:	55                   	push   %ebp
f0106ec8:	89 e5                	mov    %esp,%ebp
f0106eca:	83 ec 14             	sub    $0x14,%esp
f0106ecd:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ed0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106ed4:	a1 ac 39 5c f0       	mov    0xf05c39ac,%eax
f0106ed9:	85 c0                	test   %eax,%eax
f0106edb:	74 34                	je     f0106f11 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ee0:	0f b6 c0             	movzbl %al,%eax
f0106ee3:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106eea:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106eed:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106ef0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106ef3:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106ef4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ef7:	66 c1 e8 08          	shr    $0x8,%ax
f0106efb:	0f b6 c0             	movzbl %al,%eax
f0106efe:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f05:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f08:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f0b:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f0e:	ee                   	out    %al,(%dx)
f0106f0f:	eb 01                	jmp    f0106f12 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f11:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f12:	c9                   	leave  
f0106f13:	c3                   	ret    

f0106f14 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f14:	55                   	push   %ebp
f0106f15:	89 e5                	mov    %esp,%ebp
f0106f17:	53                   	push   %ebx
f0106f18:	83 ec 14             	sub    $0x14,%esp
f0106f1b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f1e:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f21:	a1 ac 39 5c f0       	mov    0xf05c39ac,%eax
f0106f26:	85 c0                	test   %eax,%eax
f0106f28:	74 58                	je     f0106f82 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f2a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f2e:	77 08                	ja     f0106f38 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f30:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106f36:	eb 0a                	jmp    f0106f42 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106f38:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106f3e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106f42:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106f46:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106f49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f4c:	89 c2                	mov    %eax,%edx
f0106f4e:	ec                   	in     (%dx),%al
f0106f4f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106f52:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106f55:	88 c2                	mov    %al,%dl
f0106f57:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106f5b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106f60:	88 c1                	mov    %al,%cl
f0106f62:	d3 e3                	shl    %cl,%ebx
f0106f64:	89 d8                	mov    %ebx,%eax
f0106f66:	09 d0                	or     %edx,%eax
f0106f68:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106f6b:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106f6f:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106f73:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106f76:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106f79:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106f7f:	ee                   	out    %al,(%dx)
f0106f80:	eb 01                	jmp    f0106f83 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106f82:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106f83:	83 c4 14             	add    $0x14,%esp
f0106f86:	5b                   	pop    %ebx
f0106f87:	5d                   	pop    %ebp
f0106f88:	c3                   	ret    

f0106f89 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106f89:	55                   	push   %ebp
f0106f8a:	89 e5                	mov    %esp,%ebp
f0106f8c:	53                   	push   %ebx
f0106f8d:	83 ec 14             	sub    $0x14,%esp
f0106f90:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f93:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f96:	a1 ac 39 5c f0       	mov    0xf05c39ac,%eax
f0106f9b:	85 c0                	test   %eax,%eax
f0106f9d:	74 5a                	je     f0106ff9 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f9f:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106fa3:	77 08                	ja     f0106fad <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0106fa5:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fab:	eb 0a                	jmp    f0106fb7 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fad:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fb3:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0106fb7:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fbb:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fc1:	89 c2                	mov    %eax,%edx
f0106fc3:	ec                   	in     (%dx),%al
f0106fc4:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fc7:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fca:	88 c2                	mov    %al,%dl
f0106fcc:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fd0:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fd5:	88 c1                	mov    %al,%cl
f0106fd7:	d3 e3                	shl    %cl,%ebx
f0106fd9:	89 d8                	mov    %ebx,%eax
f0106fdb:	f7 d0                	not    %eax
f0106fdd:	21 d0                	and    %edx,%eax
f0106fdf:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fe2:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fe6:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fea:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fed:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106ff0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106ff3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ff6:	ee                   	out    %al,(%dx)
f0106ff7:	eb 01                	jmp    f0106ffa <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106ff9:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0106ffa:	83 c4 14             	add    $0x14,%esp
f0106ffd:	5b                   	pop    %ebx
f0106ffe:	5d                   	pop    %ebp
f0106fff:	c3                   	ret    

f0107000 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107000:	55                   	push   %ebp
f0107001:	89 e5                	mov    %esp,%ebp
f0107003:	53                   	push   %ebx
f0107004:	83 ec 14             	sub    $0x14,%esp
f0107007:	8b 45 08             	mov    0x8(%ebp),%eax
f010700a:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010700d:	a1 ac 39 5c f0       	mov    0xf05c39ac,%eax
f0107012:	85 c0                	test   %eax,%eax
f0107014:	75 07                	jne    f010701d <irq_get_mask+0x1d>
		return -1;
f0107016:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010701b:	eb 45                	jmp    f0107062 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010701d:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107021:	77 08                	ja     f010702b <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107023:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107029:	eb 0a                	jmp    f0107035 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f010702b:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107031:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0107035:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107039:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010703c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010703f:	89 c2                	mov    %eax,%edx
f0107041:	ec                   	in     (%dx),%al
f0107042:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0107045:	8a 45 f3             	mov    -0xd(%ebp),%al
f0107048:	88 c2                	mov    %al,%dl
f010704a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010704e:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107053:	88 c1                	mov    %al,%cl
f0107055:	d3 e3                	shl    %cl,%ebx
f0107057:	89 d8                	mov    %ebx,%eax
f0107059:	21 d0                	and    %edx,%eax
f010705b:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f010705e:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0107062:	83 c4 14             	add    $0x14,%esp
f0107065:	5b                   	pop    %ebx
f0107066:	5d                   	pop    %ebp
f0107067:	c3                   	ret    

f0107068 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0107068:	55                   	push   %ebp
f0107069:	89 e5                	mov    %esp,%ebp
f010706b:	83 ec 14             	sub    $0x14,%esp
f010706e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107071:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0107074:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0107078:	76 12                	jbe    f010708c <pic_sendEOI+0x24>
f010707a:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107081:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107085:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107088:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010708b:	ee                   	out    %al,(%dx)
f010708c:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107093:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107097:	8a 45 f6             	mov    -0xa(%ebp),%al
f010709a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010709d:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f010709e:	90                   	nop
f010709f:	c9                   	leave  
f01070a0:	c3                   	ret    

f01070a1 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f01070a1:	55                   	push   %ebp
f01070a2:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f01070a4:	b8 80 c6 5e f0       	mov    $0xf05ec680,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f01070a9:	5d                   	pop    %ebp
f01070aa:	c3                   	ret    

f01070ab <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f01070ab:	55                   	push   %ebp
f01070ac:	89 e5                	mov    %esp,%ebp
f01070ae:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f01070b1:	e8 eb ff ff ff       	call   f01070a1 <mycpu>
f01070b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f01070b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070bc:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01070c3:	00 00 00 
  c->ncli = 0;
f01070c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070c9:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f01070d0:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01070d3:	9c                   	pushf  
f01070d4:	58                   	pop    %eax
f01070d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f01070d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f01070db:	25 00 02 00 00       	and    $0x200,%eax
f01070e0:	85 c0                	test   %eax,%eax
f01070e2:	0f 95 c0             	setne  %al
f01070e5:	0f b6 d0             	movzbl %al,%edx
f01070e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070eb:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f01070f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070f4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f01070fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070fe:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107105:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107108:	8b 45 08             	mov    0x8(%ebp),%eax
f010710b:	40                   	inc    %eax
f010710c:	c1 e0 0f             	shl    $0xf,%eax
f010710f:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107114:	29 c2                	sub    %eax,%edx
f0107116:	89 d0                	mov    %edx,%eax
f0107118:	89 c2                	mov    %eax,%edx
f010711a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010711d:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0107120:	e8 18 01 00 00       	call   f010723d <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107125:	e8 80 4d 00 00       	call   f010beaa <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f010712a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010712d:	83 c0 0c             	add    $0xc,%eax
f0107130:	83 ec 04             	sub    $0x4,%esp
f0107133:	6a 68                	push   $0x68
f0107135:	6a 00                	push   $0x0
f0107137:	50                   	push   %eax
f0107138:	e8 a0 78 01 00       	call   f011e9dd <memset>
f010713d:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f0107140:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107143:	05 a4 00 00 00       	add    $0xa4,%eax
f0107148:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010714b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0107152:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107155:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107158:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010715b:	f0 87 02             	lock xchg %eax,(%edx)
f010715e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0107161:	90                   	nop
f0107162:	c9                   	leave  
f0107163:	c3                   	ret    

f0107164 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0107164:	55                   	push   %ebp
f0107165:	89 e5                	mov    %esp,%ebp
f0107167:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010716a:	9c                   	pushf  
f010716b:	58                   	pop    %eax
f010716c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f010716f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0107172:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0107175:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0107176:	e8 26 ff ff ff       	call   f01070a1 <mycpu>
f010717b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f010717e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107181:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107187:	85 c0                	test   %eax,%eax
f0107189:	75 13                	jne    f010719e <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f010718b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010718e:	25 00 02 00 00       	and    $0x200,%eax
f0107193:	89 c2                	mov    %eax,%edx
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f010719e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071a1:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071a7:	8d 50 01             	lea    0x1(%eax),%edx
f01071aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ad:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f01071b3:	90                   	nop
f01071b4:	c9                   	leave  
f01071b5:	c3                   	ret    

f01071b6 <popcli>:

void popcli(void)
{
f01071b6:	55                   	push   %ebp
f01071b7:	89 e5                	mov    %esp,%ebp
f01071b9:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071bc:	9c                   	pushf  
f01071bd:	58                   	pop    %eax
f01071be:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f01071c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f01071c4:	25 00 02 00 00       	and    $0x200,%eax
f01071c9:	85 c0                	test   %eax,%eax
f01071cb:	74 14                	je     f01071e1 <popcli+0x2b>
    panic("popcli - interruptible");
f01071cd:	83 ec 04             	sub    $0x4,%esp
f01071d0:	68 15 43 12 f0       	push   $0xf0124315
f01071d5:	6a 5e                	push   $0x5e
f01071d7:	68 2c 43 12 f0       	push   $0xf012432c
f01071dc:	e8 58 91 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f01071e1:	e8 bb fe ff ff       	call   f01070a1 <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	8d 50 ff             	lea    -0x1(%eax),%edx
f01071f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071f8:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f01071fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107201:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107207:	85 c0                	test   %eax,%eax
f0107209:	79 14                	jns    f010721f <popcli+0x69>
    panic("popcli");
f010720b:	83 ec 04             	sub    $0x4,%esp
f010720e:	68 3b 43 12 f0       	push   $0xf012433b
f0107213:	6a 61                	push   $0x61
f0107215:	68 2c 43 12 f0       	push   $0xf012432c
f010721a:	e8 1a 91 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010721f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107222:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107228:	85 c0                	test   %eax,%eax
f010722a:	75 0e                	jne    f010723a <popcli+0x84>
f010722c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010722f:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0107235:	85 c0                	test   %eax,%eax
f0107237:	74 01                	je     f010723a <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0107239:	fb                   	sti    
    sti();
}
f010723a:	90                   	nop
f010723b:	c9                   	leave  
f010723c:	c3                   	ret    

f010723d <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f010723d:	55                   	push   %ebp
f010723e:	89 e5                	mov    %esp,%ebp
f0107240:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0107243:	e8 1c ff ff ff       	call   f0107164 <pushcli>

	c = mycpu();
f0107248:	e8 54 fe ff ff       	call   f01070a1 <mycpu>
f010724d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f0107250:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107253:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f010725a:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0107261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107264:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f010726a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726d:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0107273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107276:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f010727d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107280:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107286:	83 e2 f0             	and    $0xfffffff0,%edx
f0107289:	83 ca 0a             	or     $0xa,%edx
f010728c:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107295:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010729b:	83 ca 10             	or     $0x10,%edx
f010729e:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072a7:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072ad:	83 e2 9f             	and    $0xffffff9f,%edx
f01072b0:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072b9:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072bf:	83 ca 80             	or     $0xffffff80,%edx
f01072c2:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cb:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01072d1:	83 ca 0f             	or     $0xf,%edx
f01072d4:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01072da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072dd:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01072e3:	83 e2 ef             	and    $0xffffffef,%edx
f01072e6:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01072ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ef:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01072f5:	83 e2 df             	and    $0xffffffdf,%edx
f01072f8:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01072fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107301:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107307:	83 ca 40             	or     $0x40,%edx
f010730a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107310:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107313:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107319:	83 ca 80             	or     $0xffffff80,%edx
f010731c:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107322:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107325:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f010732c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010732f:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0107336:	ff ff 
f0107338:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010733b:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f0107342:	00 00 
f0107344:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107347:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f010734e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107351:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107357:	83 e2 f0             	and    $0xfffffff0,%edx
f010735a:	83 ca 02             	or     $0x2,%edx
f010735d:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107363:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107366:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010736c:	83 ca 10             	or     $0x10,%edx
f010736f:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107375:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107378:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010737e:	83 e2 9f             	and    $0xffffff9f,%edx
f0107381:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107387:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010738a:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107390:	83 ca 80             	or     $0xffffff80,%edx
f0107393:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107399:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073a2:	83 ca 0f             	or     $0xf,%edx
f01073a5:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073ae:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073b4:	83 e2 ef             	and    $0xffffffef,%edx
f01073b7:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073c0:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073c6:	83 e2 df             	and    $0xffffffdf,%edx
f01073c9:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d2:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073d8:	83 ca 40             	or     $0x40,%edx
f01073db:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e4:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073ea:	83 ca 80             	or     $0xffffff80,%edx
f01073ed:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f6:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f01073fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107400:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107407:	ff ff 
f0107409:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010740c:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f0107413:	00 00 
f0107415:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107418:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010741f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107422:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107428:	83 e2 f0             	and    $0xfffffff0,%edx
f010742b:	83 ca 0a             	or     $0xa,%edx
f010742e:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107434:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107437:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010743d:	83 ca 10             	or     $0x10,%edx
f0107440:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107446:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107449:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010744f:	83 ca 60             	or     $0x60,%edx
f0107452:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107458:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010745b:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107461:	83 ca 80             	or     $0xffffff80,%edx
f0107464:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010746a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746d:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107473:	83 ca 0f             	or     $0xf,%edx
f0107476:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010747c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010747f:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107485:	83 e2 ef             	and    $0xffffffef,%edx
f0107488:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010748e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107491:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107497:	83 e2 df             	and    $0xffffffdf,%edx
f010749a:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a3:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074a9:	83 ca 40             	or     $0x40,%edx
f01074ac:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b5:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074bb:	83 ca 80             	or     $0xffffff80,%edx
f01074be:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c7:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f01074ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d1:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f01074d8:	ff ff 
f01074da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074dd:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f01074e4:	00 00 
f01074e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074e9:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f01074f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074f3:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01074f9:	83 e2 f0             	and    $0xfffffff0,%edx
f01074fc:	83 ca 02             	or     $0x2,%edx
f01074ff:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107505:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107508:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010750e:	83 ca 10             	or     $0x10,%edx
f0107511:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107517:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010751a:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107520:	83 ca 60             	or     $0x60,%edx
f0107523:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107529:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752c:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107532:	83 ca 80             	or     $0xffffff80,%edx
f0107535:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010753b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753e:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107544:	83 ca 0f             	or     $0xf,%edx
f0107547:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010754d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107550:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107556:	83 e2 ef             	and    $0xffffffef,%edx
f0107559:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010755f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107562:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107568:	83 e2 df             	and    $0xffffffdf,%edx
f010756b:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107571:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107574:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010757a:	83 ca 40             	or     $0x40,%edx
f010757d:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107583:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107586:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010758c:	83 ca 80             	or     $0xffffff80,%edx
f010758f:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107595:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107598:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010759f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a2:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f01075a9:	00 00 00 
f01075ac:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f01075b3:	00 00 00 

	popcli();	//enable interrupt
f01075b6:	e8 fb fb ff ff       	call   f01071b6 <popcli>


}
f01075bb:	90                   	nop
f01075bc:	c9                   	leave  
f01075bd:	c3                   	ret    

f01075be <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f01075be:	55                   	push   %ebp
f01075bf:	89 e5                	mov    %esp,%ebp
f01075c1:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f01075c4:	83 ec 08             	sub    $0x8,%esp
f01075c7:	68 00 10 00 00       	push   $0x1000
f01075cc:	68 00 10 00 00       	push   $0x1000
f01075d1:	e8 42 02 00 00       	call   f0107818 <boot_allocate_space>
f01075d6:	83 c4 10             	add    $0x10,%esp
f01075d9:	a3 5c cb 5e f0       	mov    %eax,0xf05ecb5c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01075de:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f01075e3:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01075e6:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f01075ed:	77 14                	ja     f0107603 <initialize_kernel_VM+0x45>
f01075ef:	ff 75 e0             	pushl  -0x20(%ebp)
f01075f2:	68 44 43 12 f0       	push   $0xf0124344
f01075f7:	6a 57                	push   $0x57
f01075f9:	68 78 43 12 f0       	push   $0xf0124378
f01075fe:	e8 36 8d ff ff       	call   f0100339 <_panic>
f0107603:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107606:	05 00 00 00 10       	add    $0x10000000,%eax
f010760b:	a3 84 cc 5e f0       	mov    %eax,0xf05ecc84
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f0107610:	c7 45 dc 00 30 17 f0 	movl   $0xf0173000,-0x24(%ebp)
f0107617:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010761e:	77 14                	ja     f0107634 <initialize_kernel_VM+0x76>
f0107620:	ff 75 dc             	pushl  -0x24(%ebp)
f0107623:	68 44 43 12 f0       	push   $0xf0124344
f0107628:	6a 63                	push   $0x63
f010762a:	68 78 43 12 f0       	push   $0xf0124378
f010762f:	e8 05 8d ff ff       	call   f0100339 <_panic>
f0107634:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107637:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010763d:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107642:	83 ec 0c             	sub    $0xc,%esp
f0107645:	6a 02                	push   $0x2
f0107647:	52                   	push   %edx
f0107648:	68 00 80 00 00       	push   $0x8000
f010764d:	68 00 80 bf ef       	push   $0xefbf8000
f0107652:	50                   	push   %eax
f0107653:	e8 34 02 00 00       	call   f010788c <boot_map_range>
f0107658:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f010765b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107662:	eb 24                	jmp    f0107688 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0107664:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107667:	40                   	inc    %eax
f0107668:	c1 e0 0f             	shl    $0xf,%eax
f010766b:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107670:	29 c2                	sub    %eax,%edx
f0107672:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107677:	6a 01                	push   $0x1
f0107679:	6a 00                	push   $0x0
f010767b:	52                   	push   %edx
f010767c:	50                   	push   %eax
f010767d:	e8 05 17 00 00       	call   f0108d87 <pt_set_page_permissions>
f0107682:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107685:	ff 45 f4             	incl   -0xc(%ebp)
f0107688:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010768c:	7e d6                	jle    f0107664 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f010768e:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107695:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f010769c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076a3:	eb 25                	jmp    f01076ca <initialize_kernel_VM+0x10c>
	{
		++nTables;
f01076a5:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f01076a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01076ab:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f01076b0:	83 ec 04             	sub    $0x4,%esp
f01076b3:	6a 01                	push   $0x1
f01076b5:	52                   	push   %edx
f01076b6:	50                   	push   %eax
f01076b7:	e8 44 02 00 00       	call   f0107900 <boot_get_page_table>
f01076bc:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076bf:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f01076c6:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f01076ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076ce:	72 d5                	jb     f01076a5 <initialize_kernel_VM+0xe7>
f01076d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076d4:	77 06                	ja     f01076dc <initialize_kernel_VM+0x11e>
f01076d6:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f01076da:	76 c9                	jbe    f01076a5 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f01076dc:	8b 15 38 c7 5e f0    	mov    0xf05ec738,%edx
f01076e2:	89 d0                	mov    %edx,%eax
f01076e4:	01 c0                	add    %eax,%eax
f01076e6:	01 d0                	add    %edx,%eax
f01076e8:	c1 e0 03             	shl    $0x3,%eax
f01076eb:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f01076ee:	83 ec 08             	sub    $0x8,%esp
f01076f1:	68 00 10 00 00       	push   $0x1000
f01076f6:	ff 75 d8             	pushl  -0x28(%ebp)
f01076f9:	e8 1a 01 00 00       	call   f0107818 <boot_allocate_space>
f01076fe:	83 c4 10             	add    $0x10,%esp
f0107701:	a3 a0 c9 5e f0       	mov    %eax,0xf05ec9a0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107706:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f010770d:	83 ec 08             	sub    $0x8,%esp
f0107710:	68 00 10 00 00       	push   $0x1000
f0107715:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107718:	e8 fb 00 00 00       	call   f0107818 <boot_allocate_space>
f010771d:	83 c4 10             	add    $0x10,%esp
f0107720:	a3 60 c2 5e f0       	mov    %eax,0xf05ec260
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107725:	e8 05 05 00 00       	call   f0107c2f <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f010772a:	83 ec 0c             	sub    $0xc,%esp
f010772d:	68 d0 02 00 00       	push   $0x2d0
f0107732:	e8 16 56 01 00       	call   f011cd4d <nearest_pow2_ceil>
f0107737:	83 c4 10             	add    $0x10,%esp
f010773a:	83 ec 04             	sub    $0x4,%esp
f010773d:	50                   	push   %eax
f010773e:	68 d0 02 00 00       	push   $0x2d0
f0107743:	68 98 43 12 f0       	push   $0xf0124398
f0107748:	e8 3e 98 ff ff       	call   f0100f8b <cprintf>
f010774d:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0107750:	c7 45 d0 00 ff 0f 00 	movl   $0xfff00,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107757:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010775a:	83 ec 08             	sub    $0x8,%esp
f010775d:	68 00 10 00 00       	push   $0x1000
f0107762:	50                   	push   %eax
f0107763:	e8 b0 00 00 00       	call   f0107818 <boot_allocate_space>
f0107768:	83 c4 10             	add    $0x10,%esp
f010776b:	a3 b0 39 5c f0       	mov    %eax,0xf05c39b0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0107770:	a1 b0 39 5c f0       	mov    0xf05c39b0,%eax
f0107775:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107778:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f010777f:	77 17                	ja     f0107798 <initialize_kernel_VM+0x1da>
f0107781:	ff 75 cc             	pushl  -0x34(%ebp)
f0107784:	68 44 43 12 f0       	push   $0xf0124344
f0107789:	68 b1 00 00 00       	push   $0xb1
f010778e:	68 78 43 12 f0       	push   $0xf0124378
f0107793:	e8 a1 8b ff ff       	call   f0100339 <_panic>
f0107798:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010779b:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01077a1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01077a4:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f01077a9:	83 ec 0c             	sub    $0xc,%esp
f01077ac:	6a 04                	push   $0x4
f01077ae:	51                   	push   %ecx
f01077af:	52                   	push   %edx
f01077b0:	68 00 00 c0 ee       	push   $0xeec00000
f01077b5:	50                   	push   %eax
f01077b6:	e8 d1 00 00 00       	call   f010788c <boot_map_range>
f01077bb:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f01077be:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f01077c3:	05 ec 0e 00 00       	add    $0xeec,%eax
f01077c8:	8b 15 5c cb 5e f0    	mov    0xf05ecb5c,%edx
f01077ce:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f01077d4:	8b 12                	mov    (%edx),%edx
f01077d6:	83 ca 05             	or     $0x5,%edx
f01077d9:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f01077db:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f01077e0:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01077e6:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f01077eb:	83 ec 0c             	sub    $0xc,%esp
f01077ee:	6a 02                	push   $0x2
f01077f0:	6a 00                	push   $0x0
f01077f2:	52                   	push   %edx
f01077f3:	68 00 00 00 f0       	push   $0xf0000000
f01077f8:	50                   	push   %eax
f01077f9:	e8 8e 00 00 00       	call   f010788c <boot_map_range>
f01077fe:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107801:	e8 1a 65 01 00       	call   f011dd20 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107806:	c7 05 70 c6 5e f0 19 	movl   $0x19,0xf05ec670
f010780d:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107810:	e8 e6 02 00 00       	call   f0107afb <turn_on_paging>
}
f0107815:	90                   	nop
f0107816:	c9                   	leave  
f0107817:	c3                   	ret    

f0107818 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107818:	55                   	push   %ebp
f0107819:	89 e5                	mov    %esp,%ebp
f010781b:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f010781e:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f0107823:	85 c0                	test   %eax,%eax
f0107825:	75 0a                	jne    f0107831 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107827:	c7 05 58 cb 5e f0 50 	movl   $0xf060f650,0xf05ecb58
f010782e:	f6 60 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107831:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107834:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107837:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f010783c:	89 c2                	mov    %eax,%edx
f010783e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107841:	01 d0                	add    %edx,%eax
f0107843:	48                   	dec    %eax
f0107844:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107847:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010784a:	ba 00 00 00 00       	mov    $0x0,%edx
f010784f:	f7 75 f4             	divl   -0xc(%ebp)
f0107852:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107855:	29 d0                	sub    %edx,%eax
f0107857:	a3 58 cb 5e f0       	mov    %eax,0xf05ecb58

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f010785c:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f0107861:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107864:	8b 15 58 cb 5e f0    	mov    0xf05ecb58,%edx
f010786a:	8b 45 08             	mov    0x8(%ebp),%eax
f010786d:	01 d0                	add    %edx,%eax
f010786f:	a3 58 cb 5e f0       	mov    %eax,0xf05ecb58

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107874:	83 ec 04             	sub    $0x4,%esp
f0107877:	ff 75 08             	pushl  0x8(%ebp)
f010787a:	6a 00                	push   $0x0
f010787c:	ff 75 ec             	pushl  -0x14(%ebp)
f010787f:	e8 59 71 01 00       	call   f011e9dd <memset>
f0107884:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107887:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f010788a:	c9                   	leave  
f010788b:	c3                   	ret    

f010788c <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f010788c:	55                   	push   %ebp
f010788d:	89 e5                	mov    %esp,%ebp
f010788f:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0107892:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107899:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01078a0:	eb 53                	jmp    f01078f5 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f01078a2:	83 ec 04             	sub    $0x4,%esp
f01078a5:	6a 01                	push   $0x1
f01078a7:	ff 75 0c             	pushl  0xc(%ebp)
f01078aa:	ff 75 08             	pushl  0x8(%ebp)
f01078ad:	e8 4e 00 00 00       	call   f0107900 <boot_get_page_table>
f01078b2:	83 c4 10             	add    $0x10,%esp
f01078b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f01078b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01078bb:	c1 e8 0c             	shr    $0xc,%eax
f01078be:	25 ff 03 00 00       	and    $0x3ff,%eax
f01078c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f01078c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01078c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01078d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078d3:	01 c2                	add    %eax,%edx
f01078d5:	8b 45 18             	mov    0x18(%ebp),%eax
f01078d8:	0b 45 14             	or     0x14(%ebp),%eax
f01078db:	83 c8 01             	or     $0x1,%eax
f01078de:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f01078e0:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f01078e7:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01078ee:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01078f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078f8:	3b 45 10             	cmp    0x10(%ebp),%eax
f01078fb:	72 a5                	jb     f01078a2 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f01078fd:	90                   	nop
f01078fe:	c9                   	leave  
f01078ff:	c3                   	ret    

f0107900 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107900:	55                   	push   %ebp
f0107901:	89 e5                	mov    %esp,%ebp
f0107903:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107906:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107909:	c1 e8 16             	shr    $0x16,%eax
f010790c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010790f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107912:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107919:	8b 45 08             	mov    0x8(%ebp),%eax
f010791c:	01 d0                	add    %edx,%eax
f010791e:	8b 00                	mov    (%eax),%eax
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107923:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107926:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010792b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f010792e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107931:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107934:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107937:	c1 e8 0c             	shr    $0xc,%eax
f010793a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010793d:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f0107942:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107945:	72 17                	jb     f010795e <boot_get_page_table+0x5e>
f0107947:	ff 75 e8             	pushl  -0x18(%ebp)
f010794a:	68 c0 43 12 f0       	push   $0xf01243c0
f010794f:	68 33 01 00 00       	push   $0x133
f0107954:	68 78 43 12 f0       	push   $0xf0124378
f0107959:	e8 db 89 ff ff       	call   f0100339 <_panic>
f010795e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107961:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0107966:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0107969:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010796d:	75 72                	jne    f01079e1 <boot_get_page_table+0xe1>
	{
		if (create)
f010796f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107973:	74 65                	je     f01079da <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107975:	83 ec 08             	sub    $0x8,%esp
f0107978:	68 00 10 00 00       	push   $0x1000
f010797d:	68 00 10 00 00       	push   $0x1000
f0107982:	e8 91 fe ff ff       	call   f0107818 <boot_allocate_space>
f0107987:	83 c4 10             	add    $0x10,%esp
f010798a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f010798d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107990:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107993:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010799a:	77 17                	ja     f01079b3 <boot_get_page_table+0xb3>
f010799c:	ff 75 dc             	pushl  -0x24(%ebp)
f010799f:	68 44 43 12 f0       	push   $0xf0124344
f01079a4:	68 39 01 00 00       	push   $0x139
f01079a9:	68 78 43 12 f0       	push   $0xf0124378
f01079ae:	e8 86 89 ff ff       	call   f0100339 <_panic>
f01079b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01079b6:	05 00 00 00 10       	add    $0x10000000,%eax
f01079bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f01079be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079c1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01079c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01079cb:	01 d0                	add    %edx,%eax
f01079cd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01079d0:	83 ca 03             	or     $0x3,%edx
f01079d3:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f01079d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079d8:	eb 0a                	jmp    f01079e4 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f01079da:	b8 00 00 00 00       	mov    $0x0,%eax
f01079df:	eb 03                	jmp    f01079e4 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f01079e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01079e4:	c9                   	leave  
f01079e5:	c3                   	ret    

f01079e6 <nvram_read>:


int nvram_read(int r)
{
f01079e6:	55                   	push   %ebp
f01079e7:	89 e5                	mov    %esp,%ebp
f01079e9:	53                   	push   %ebx
f01079ea:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f01079ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01079f0:	83 ec 0c             	sub    $0xc,%esp
f01079f3:	50                   	push   %eax
f01079f4:	e8 31 d1 ff ff       	call   f0104b2a <mc146818_read>
f01079f9:	83 c4 10             	add    $0x10,%esp
f01079fc:	89 c3                	mov    %eax,%ebx
f01079fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a01:	40                   	inc    %eax
f0107a02:	83 ec 0c             	sub    $0xc,%esp
f0107a05:	50                   	push   %eax
f0107a06:	e8 1f d1 ff ff       	call   f0104b2a <mc146818_read>
f0107a0b:	83 c4 10             	add    $0x10,%esp
f0107a0e:	c1 e0 08             	shl    $0x8,%eax
f0107a11:	09 d8                	or     %ebx,%eax
}
f0107a13:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a16:	c9                   	leave  
f0107a17:	c3                   	ret    

f0107a18 <detect_memory>:

void detect_memory()
{
f0107a18:	55                   	push   %ebp
f0107a19:	89 e5                	mov    %esp,%ebp
f0107a1b:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a1e:	83 ec 0c             	sub    $0xc,%esp
f0107a21:	6a 15                	push   $0x15
f0107a23:	e8 be ff ff ff       	call   f01079e6 <nvram_read>
f0107a28:	83 c4 10             	add    $0x10,%esp
f0107a2b:	c1 e0 0a             	shl    $0xa,%eax
f0107a2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a31:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a34:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a39:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107a3c:	83 ec 0c             	sub    $0xc,%esp
f0107a3f:	6a 17                	push   $0x17
f0107a41:	e8 a0 ff ff ff       	call   f01079e6 <nvram_read>
f0107a46:	83 c4 10             	add    $0x10,%esp
f0107a49:	c1 e0 0a             	shl    $0xa,%eax
f0107a4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107a4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107a52:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a57:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107a5a:	83 ec 0c             	sub    $0xc,%esp
f0107a5d:	6a 34                	push   $0x34
f0107a5f:	e8 82 ff ff ff       	call   f01079e6 <nvram_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	c1 e0 10             	shl    $0x10,%eax
f0107a6a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107a6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a70:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a75:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107a78:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107a7c:	74 18                	je     f0107a96 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107a7e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a81:	05 00 00 00 01       	add    $0x1000000,%eax
f0107a86:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107a89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a8c:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107a91:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107a94:	eb 19                	jmp    f0107aaf <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107a96:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107a9a:	74 0d                	je     f0107aa9 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107a9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107a9f:	05 00 00 10 00       	add    $0x100000,%eax
f0107aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107aa7:	eb 06                	jmp    f0107aaf <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107aa9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107aac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107aaf:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107ab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ab9:	c1 e8 0c             	shr    $0xc,%eax
f0107abc:	a3 38 c7 5e f0       	mov    %eax,0xf05ec738

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ac4:	c1 e8 0a             	shr    $0xa,%eax
f0107ac7:	83 ec 08             	sub    $0x8,%esp
f0107aca:	50                   	push   %eax
f0107acb:	68 f0 43 12 f0       	push   $0xf01243f0
f0107ad0:	e8 b6 94 ff ff       	call   f0100f8b <cprintf>
f0107ad5:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107adb:	c1 e8 0a             	shr    $0xa,%eax
f0107ade:	89 c2                	mov    %eax,%edx
f0107ae0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107ae3:	c1 e8 0a             	shr    $0xa,%eax
f0107ae6:	83 ec 04             	sub    $0x4,%esp
f0107ae9:	52                   	push   %edx
f0107aea:	50                   	push   %eax
f0107aeb:	68 13 44 12 f0       	push   $0xf0124413
f0107af0:	e8 96 94 ff ff       	call   f0100f8b <cprintf>
f0107af5:	83 c4 10             	add    $0x10,%esp
}
f0107af8:	90                   	nop
f0107af9:	c9                   	leave  
f0107afa:	c3                   	ret    

f0107afb <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107afb:	55                   	push   %ebp
f0107afc:	89 e5                	mov    %esp,%ebp
f0107afe:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b01:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b0f:	eb 24                	jmp    f0107b35 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b11:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107b16:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b19:	c1 e2 02             	shl    $0x2,%edx
f0107b1c:	01 c2                	add    %eax,%edx
f0107b1e:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107b23:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b26:	c1 e1 02             	shl    $0x2,%ecx
f0107b29:	01 c8                	add    %ecx,%eax
f0107b2b:	8b 00                	mov    (%eax),%eax
f0107b2d:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b2f:	ff 45 f4             	incl   -0xc(%ebp)
f0107b32:	ff 45 f0             	incl   -0x10(%ebp)
f0107b35:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f0107b3a:	c1 e8 16             	shr    $0x16,%eax
f0107b3d:	89 c2                	mov    %eax,%edx
f0107b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b42:	39 c2                	cmp    %eax,%edx
f0107b44:	77 cb                	ja     f0107b11 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107b46:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f0107b4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107b4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107b51:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107b54:	0f 20 c0             	mov    %cr0,%eax
f0107b57:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107b5a:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107b5d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107b60:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107b67:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107b6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107b6e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107b71:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107b74:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107b77:	e8 e8 f5 ff ff       	call   f0107164 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107b7c:	e8 20 f5 ff ff       	call   f01070a1 <mycpu>
f0107b81:	83 c0 74             	add    $0x74,%eax
f0107b84:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107b87:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107b8e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107b91:	48                   	dec    %eax
f0107b92:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107b96:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107b99:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107b9d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107ba0:	c1 e8 10             	shr    $0x10,%eax
f0107ba3:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107ba7:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107baa:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107bad:	e8 04 f6 ff ff       	call   f01071b6 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107bb2:	b8 23 00 00 00       	mov    $0x23,%eax
f0107bb7:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107bb9:	b8 23 00 00 00       	mov    $0x23,%eax
f0107bbe:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107bc0:	b8 10 00 00 00       	mov    $0x10,%eax
f0107bc5:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107bc7:	b8 10 00 00 00       	mov    $0x10,%eax
f0107bcc:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107bce:	b8 10 00 00 00       	mov    $0x10,%eax
f0107bd3:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107bd5:	ea dc 7b 10 f0 08 00 	ljmp   $0x8,$0xf0107bdc
	asm volatile("lldt %%ax" :: "a" (0));
f0107bdc:	b8 00 00 00 00       	mov    $0x0,%eax
f0107be1:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107be4:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107beb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107bf2:	eb 19                	jmp    f0107c0d <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107bf4:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107bf9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107bfc:	c1 e2 02             	shl    $0x2,%edx
f0107bff:	01 d0                	add    %edx,%eax
f0107c01:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c07:	ff 45 ec             	incl   -0x14(%ebp)
f0107c0a:	ff 45 e8             	incl   -0x18(%ebp)
f0107c0d:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f0107c12:	c1 e8 16             	shr    $0x16,%eax
f0107c15:	89 c2                	mov    %eax,%edx
f0107c17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c1a:	39 c2                	cmp    %eax,%edx
f0107c1c:	77 d6                	ja     f0107bf4 <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c1e:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f0107c23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c29:	0f 22 d8             	mov    %eax,%cr3

}
f0107c2c:	90                   	nop
f0107c2d:	c9                   	leave  
f0107c2e:	c3                   	ret    

f0107c2f <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c2f:	55                   	push   %ebp
f0107c30:	89 e5                	mov    %esp,%ebp
f0107c32:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107c35:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107c3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107c3d:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107c44:	77 17                	ja     f0107c5d <setup_listing_to_all_page_tables_entries+0x2e>
f0107c46:	ff 75 f4             	pushl  -0xc(%ebp)
f0107c49:	68 44 43 12 f0       	push   $0xf0124344
f0107c4e:	68 cf 01 00 00       	push   $0x1cf
f0107c53:	68 78 43 12 f0       	push   $0xf0124378
f0107c58:	e8 dc 86 ff ff       	call   f0100339 <_panic>
f0107c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c60:	05 00 00 00 10       	add    $0x10000000,%eax
f0107c65:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107c68:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107c6d:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107c72:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107c75:	83 ca 03             	or     $0x3,%edx
f0107c78:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107c7a:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107c7f:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107c85:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0107c8a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107c8d:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107c94:	77 17                	ja     f0107cad <setup_listing_to_all_page_tables_entries+0x7e>
f0107c96:	ff 75 ec             	pushl  -0x14(%ebp)
f0107c99:	68 44 43 12 f0       	push   $0xf0124344
f0107c9e:	68 d4 01 00 00       	push   $0x1d4
f0107ca3:	68 78 43 12 f0       	push   $0xf0124378
f0107ca8:	e8 8c 86 ff ff       	call   f0100339 <_panic>
f0107cad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107cb0:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cb5:	83 c8 05             	or     $0x5,%eax
f0107cb8:	89 02                	mov    %eax,(%edx)

}
f0107cba:	90                   	nop
f0107cbb:	c9                   	leave  
f0107cbc:	c3                   	ret    

f0107cbd <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107cbd:	55                   	push   %ebp
f0107cbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107cc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cc3:	8b 15 a0 c9 5e f0    	mov    0xf05ec9a0,%edx
f0107cc9:	29 d0                	sub    %edx,%eax
f0107ccb:	c1 f8 03             	sar    $0x3,%eax
f0107cce:	89 c2                	mov    %eax,%edx
f0107cd0:	89 d0                	mov    %edx,%eax
f0107cd2:	c1 e0 02             	shl    $0x2,%eax
f0107cd5:	01 d0                	add    %edx,%eax
f0107cd7:	c1 e0 02             	shl    $0x2,%eax
f0107cda:	01 d0                	add    %edx,%eax
f0107cdc:	c1 e0 02             	shl    $0x2,%eax
f0107cdf:	01 d0                	add    %edx,%eax
f0107ce1:	89 c1                	mov    %eax,%ecx
f0107ce3:	c1 e1 08             	shl    $0x8,%ecx
f0107ce6:	01 c8                	add    %ecx,%eax
f0107ce8:	89 c1                	mov    %eax,%ecx
f0107cea:	c1 e1 10             	shl    $0x10,%ecx
f0107ced:	01 c8                	add    %ecx,%eax
f0107cef:	01 c0                	add    %eax,%eax
f0107cf1:	01 d0                	add    %edx,%eax
}
f0107cf3:	5d                   	pop    %ebp
f0107cf4:	c3                   	ret    

f0107cf5 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107cf5:	55                   	push   %ebp
f0107cf6:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107cf8:	ff 75 08             	pushl  0x8(%ebp)
f0107cfb:	e8 bd ff ff ff       	call   f0107cbd <to_frame_number>
f0107d00:	83 c4 04             	add    $0x4,%esp
f0107d03:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d06:	c9                   	leave  
f0107d07:	c3                   	ret    

f0107d08 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d08:	55                   	push   %ebp
f0107d09:	89 e5                	mov    %esp,%ebp
f0107d0b:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d11:	c1 e8 0c             	shr    $0xc,%eax
f0107d14:	89 c2                	mov    %eax,%edx
f0107d16:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f0107d1b:	39 c2                	cmp    %eax,%edx
f0107d1d:	72 14                	jb     f0107d33 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d1f:	83 ec 04             	sub    $0x4,%esp
f0107d22:	68 30 44 12 f0       	push   $0xf0124430
f0107d27:	6a 55                	push   $0x55
f0107d29:	68 55 44 12 f0       	push   $0xf0124455
f0107d2e:	e8 06 86 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d33:	8b 15 a0 c9 5e f0    	mov    0xf05ec9a0,%edx
f0107d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d3c:	c1 e8 0c             	shr    $0xc,%eax
f0107d3f:	89 c1                	mov    %eax,%ecx
f0107d41:	89 c8                	mov    %ecx,%eax
f0107d43:	01 c0                	add    %eax,%eax
f0107d45:	01 c8                	add    %ecx,%eax
f0107d47:	c1 e0 03             	shl    $0x3,%eax
f0107d4a:	01 d0                	add    %edx,%eax
}
f0107d4c:	c9                   	leave  
f0107d4d:	c3                   	ret    

f0107d4e <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107d4e:	55                   	push   %ebp
f0107d4f:	89 e5                	mov    %esp,%ebp
f0107d51:	83 ec 10             	sub    $0x10,%esp
f0107d54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107d57:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107d5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107d5d:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107d60:	90                   	nop
f0107d61:	c9                   	leave  
f0107d62:	c3                   	ret    

f0107d63 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107d63:	55                   	push   %ebp
f0107d64:	89 e5                	mov    %esp,%ebp
f0107d66:	53                   	push   %ebx
f0107d67:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107d6a:	c7 05 40 c5 5e f0 00 	movl   $0x0,0xf05ec540
f0107d71:	00 00 00 
f0107d74:	c7 05 44 c5 5e f0 00 	movl   $0x0,0xf05ec544
f0107d7b:	00 00 00 
f0107d7e:	c7 05 4c c5 5e f0 00 	movl   $0x0,0xf05ec54c
f0107d85:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107d88:	c7 05 50 c5 5e f0 00 	movl   $0x0,0xf05ec550
f0107d8f:	00 00 00 
f0107d92:	c7 05 54 c5 5e f0 00 	movl   $0x0,0xf05ec554
f0107d99:	00 00 00 
f0107d9c:	c7 05 5c c5 5e f0 00 	movl   $0x0,0xf05ec55c
f0107da3:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107da6:	83 ec 08             	sub    $0x8,%esp
f0107da9:	68 6f 44 12 f0       	push   $0xf012446f
f0107dae:	68 60 c5 5e f0       	push   $0xf05ec560
f0107db3:	e8 79 6a 00 00       	call   f010e831 <init_spinlock>
f0107db8:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107dbb:	a1 a0 c9 5e f0       	mov    0xf05ec9a0,%eax
f0107dc0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107dc6:	a1 a0 c9 5e f0       	mov    0xf05ec9a0,%eax
f0107dcb:	83 c0 18             	add    $0x18,%eax
f0107dce:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107dd4:	a1 a0 c9 5e f0       	mov    0xf05ec9a0,%eax
f0107dd9:	83 c0 30             	add    $0x30,%eax
f0107ddc:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107de2:	c7 05 38 ca 5e f0 00 	movl   $0xf0001000,0xf05eca38
f0107de9:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107dec:	c7 05 ec cb 5e f0 00 	movl   $0xf0002000,0xf05ecbec
f0107df3:	20 00 f0 
	i =0;
f0107df6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107dfd:	eb 1f                	jmp    f0107e1e <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107dff:	8b 15 38 ca 5e f0    	mov    0xf05eca38,%edx
f0107e05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e08:	01 d0                	add    %edx,%eax
f0107e0a:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e0d:	8b 15 ec cb 5e f0    	mov    0xf05ecbec,%edx
f0107e13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e16:	01 d0                	add    %edx,%eax
f0107e18:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e1b:	ff 45 f4             	incl   -0xc(%ebp)
f0107e1e:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e25:	7e d8                	jle    f0107dff <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e27:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e31:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107e36:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107e39:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107e3c:	ba 00 00 00 00       	mov    $0x0,%edx
f0107e41:	f7 75 f0             	divl   -0x10(%ebp)
f0107e44:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107e47:	29 d0                	sub    %edx,%eax
f0107e49:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107e4c:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107e53:	e9 e8 00 00 00       	jmp    f0107f40 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107e58:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107e5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e61:	89 d0                	mov    %edx,%eax
f0107e63:	01 c0                	add    %eax,%eax
f0107e65:	01 d0                	add    %edx,%eax
f0107e67:	c1 e0 03             	shl    $0x3,%eax
f0107e6a:	01 c8                	add    %ecx,%eax
f0107e6c:	83 ec 0c             	sub    $0xc,%esp
f0107e6f:	50                   	push   %eax
f0107e70:	e8 b7 02 00 00       	call   f010812c <initialize_frame_info>
f0107e75:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107e78:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107e7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e81:	89 d0                	mov    %edx,%eax
f0107e83:	01 c0                	add    %eax,%eax
f0107e85:	01 d0                	add    %edx,%eax
f0107e87:	c1 e0 03             	shl    $0x3,%eax
f0107e8a:	01 c8                	add    %ecx,%eax
f0107e8c:	85 c0                	test   %eax,%eax
f0107e8e:	75 14                	jne    f0107ea4 <initialize_paging+0x141>
f0107e90:	83 ec 04             	sub    $0x4,%esp
f0107e93:	68 80 44 12 f0       	push   $0xf0124480
f0107e98:	6a 60                	push   $0x60
f0107e9a:	68 a3 44 12 f0       	push   $0xf01244a3
f0107e9f:	e8 95 84 ff ff       	call   f0100339 <_panic>
f0107ea4:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ead:	89 d0                	mov    %edx,%eax
f0107eaf:	01 c0                	add    %eax,%eax
f0107eb1:	01 d0                	add    %edx,%eax
f0107eb3:	c1 e0 03             	shl    $0x3,%eax
f0107eb6:	01 c8                	add    %ecx,%eax
f0107eb8:	8b 15 40 c5 5e f0    	mov    0xf05ec540,%edx
f0107ebe:	89 10                	mov    %edx,(%eax)
f0107ec0:	8b 00                	mov    (%eax),%eax
f0107ec2:	85 c0                	test   %eax,%eax
f0107ec4:	74 1f                	je     f0107ee5 <initialize_paging+0x182>
f0107ec6:	8b 15 40 c5 5e f0    	mov    0xf05ec540,%edx
f0107ecc:	8b 1d a0 c9 5e f0    	mov    0xf05ec9a0,%ebx
f0107ed2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107ed5:	89 c8                	mov    %ecx,%eax
f0107ed7:	01 c0                	add    %eax,%eax
f0107ed9:	01 c8                	add    %ecx,%eax
f0107edb:	c1 e0 03             	shl    $0x3,%eax
f0107ede:	01 d8                	add    %ebx,%eax
f0107ee0:	89 42 04             	mov    %eax,0x4(%edx)
f0107ee3:	eb 19                	jmp    f0107efe <initialize_paging+0x19b>
f0107ee5:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107eeb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eee:	89 d0                	mov    %edx,%eax
f0107ef0:	01 c0                	add    %eax,%eax
f0107ef2:	01 d0                	add    %edx,%eax
f0107ef4:	c1 e0 03             	shl    $0x3,%eax
f0107ef7:	01 c8                	add    %ecx,%eax
f0107ef9:	a3 44 c5 5e f0       	mov    %eax,0xf05ec544
f0107efe:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107f04:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f07:	89 d0                	mov    %edx,%eax
f0107f09:	01 c0                	add    %eax,%eax
f0107f0b:	01 d0                	add    %edx,%eax
f0107f0d:	c1 e0 03             	shl    $0x3,%eax
f0107f10:	01 c8                	add    %ecx,%eax
f0107f12:	a3 40 c5 5e f0       	mov    %eax,0xf05ec540
f0107f17:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107f1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f20:	89 d0                	mov    %edx,%eax
f0107f22:	01 c0                	add    %eax,%eax
f0107f24:	01 d0                	add    %edx,%eax
f0107f26:	c1 e0 03             	shl    $0x3,%eax
f0107f29:	01 c8                	add    %ecx,%eax
f0107f2b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f32:	a1 4c c5 5e f0       	mov    0xf05ec54c,%eax
f0107f37:	40                   	inc    %eax
f0107f38:	a3 4c c5 5e f0       	mov    %eax,0xf05ec54c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107f3d:	ff 45 f4             	incl   -0xc(%ebp)
f0107f40:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107f43:	85 c0                	test   %eax,%eax
f0107f45:	79 05                	jns    f0107f4c <initialize_paging+0x1e9>
f0107f47:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107f4c:	c1 f8 0c             	sar    $0xc,%eax
f0107f4f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107f52:	0f 8f 00 ff ff ff    	jg     f0107e58 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107f58:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107f5f:	eb 1d                	jmp    f0107f7e <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107f61:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107f67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f6a:	89 d0                	mov    %edx,%eax
f0107f6c:	01 c0                	add    %eax,%eax
f0107f6e:	01 d0                	add    %edx,%eax
f0107f70:	c1 e0 03             	shl    $0x3,%eax
f0107f73:	01 c8                	add    %ecx,%eax
f0107f75:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107f7b:	ff 45 f4             	incl   -0xc(%ebp)
f0107f7e:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107f85:	7e da                	jle    f0107f61 <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107f87:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107f8e:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f0107f93:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107f96:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107f9d:	77 14                	ja     f0107fb3 <initialize_paging+0x250>
f0107f9f:	ff 75 e0             	pushl  -0x20(%ebp)
f0107fa2:	68 c0 44 12 f0       	push   $0xf01244c0
f0107fa7:	6a 68                	push   $0x68
f0107fa9:	68 a3 44 12 f0       	push   $0xf01244a3
f0107fae:	e8 86 83 ff ff       	call   f0100339 <_panic>
f0107fb3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107fb6:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fbf:	01 d0                	add    %edx,%eax
f0107fc1:	48                   	dec    %eax
f0107fc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107fc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107fc8:	ba 00 00 00 00       	mov    $0x0,%edx
f0107fcd:	f7 75 e4             	divl   -0x1c(%ebp)
f0107fd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107fd3:	29 d0                	sub    %edx,%eax
f0107fd5:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107fd8:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0107fdf:	eb 1d                	jmp    f0107ffe <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0107fe1:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f0107fe7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fea:	89 d0                	mov    %edx,%eax
f0107fec:	01 c0                	add    %eax,%eax
f0107fee:	01 d0                	add    %edx,%eax
f0107ff0:	c1 e0 03             	shl    $0x3,%eax
f0107ff3:	01 c8                	add    %ecx,%eax
f0107ff5:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107ffb:	ff 45 f4             	incl   -0xc(%ebp)
f0107ffe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108001:	85 c0                	test   %eax,%eax
f0108003:	79 05                	jns    f010800a <initialize_paging+0x2a7>
f0108005:	05 ff 0f 00 00       	add    $0xfff,%eax
f010800a:	c1 f8 0c             	sar    $0xc,%eax
f010800d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108010:	7f cf                	jg     f0107fe1 <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108012:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108015:	85 c0                	test   %eax,%eax
f0108017:	79 05                	jns    f010801e <initialize_paging+0x2bb>
f0108019:	05 ff 0f 00 00       	add    $0xfff,%eax
f010801e:	c1 f8 0c             	sar    $0xc,%eax
f0108021:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108024:	e9 e8 00 00 00       	jmp    f0108111 <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108029:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f010802f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108032:	89 d0                	mov    %edx,%eax
f0108034:	01 c0                	add    %eax,%eax
f0108036:	01 d0                	add    %edx,%eax
f0108038:	c1 e0 03             	shl    $0x3,%eax
f010803b:	01 c8                	add    %ecx,%eax
f010803d:	83 ec 0c             	sub    $0xc,%esp
f0108040:	50                   	push   %eax
f0108041:	e8 e6 00 00 00       	call   f010812c <initialize_frame_info>
f0108046:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108049:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f010804f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108052:	89 d0                	mov    %edx,%eax
f0108054:	01 c0                	add    %eax,%eax
f0108056:	01 d0                	add    %edx,%eax
f0108058:	c1 e0 03             	shl    $0x3,%eax
f010805b:	01 c8                	add    %ecx,%eax
f010805d:	85 c0                	test   %eax,%eax
f010805f:	75 14                	jne    f0108075 <initialize_paging+0x312>
f0108061:	83 ec 04             	sub    $0x4,%esp
f0108064:	68 80 44 12 f0       	push   $0xf0124480
f0108069:	6a 74                	push   $0x74
f010806b:	68 a3 44 12 f0       	push   $0xf01244a3
f0108070:	e8 c4 82 ff ff       	call   f0100339 <_panic>
f0108075:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f010807b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010807e:	89 d0                	mov    %edx,%eax
f0108080:	01 c0                	add    %eax,%eax
f0108082:	01 d0                	add    %edx,%eax
f0108084:	c1 e0 03             	shl    $0x3,%eax
f0108087:	01 c8                	add    %ecx,%eax
f0108089:	8b 15 40 c5 5e f0    	mov    0xf05ec540,%edx
f010808f:	89 10                	mov    %edx,(%eax)
f0108091:	8b 00                	mov    (%eax),%eax
f0108093:	85 c0                	test   %eax,%eax
f0108095:	74 1f                	je     f01080b6 <initialize_paging+0x353>
f0108097:	8b 15 40 c5 5e f0    	mov    0xf05ec540,%edx
f010809d:	8b 1d a0 c9 5e f0    	mov    0xf05ec9a0,%ebx
f01080a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01080a6:	89 c8                	mov    %ecx,%eax
f01080a8:	01 c0                	add    %eax,%eax
f01080aa:	01 c8                	add    %ecx,%eax
f01080ac:	c1 e0 03             	shl    $0x3,%eax
f01080af:	01 d8                	add    %ebx,%eax
f01080b1:	89 42 04             	mov    %eax,0x4(%edx)
f01080b4:	eb 19                	jmp    f01080cf <initialize_paging+0x36c>
f01080b6:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f01080bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bf:	89 d0                	mov    %edx,%eax
f01080c1:	01 c0                	add    %eax,%eax
f01080c3:	01 d0                	add    %edx,%eax
f01080c5:	c1 e0 03             	shl    $0x3,%eax
f01080c8:	01 c8                	add    %ecx,%eax
f01080ca:	a3 44 c5 5e f0       	mov    %eax,0xf05ec544
f01080cf:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f01080d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080d8:	89 d0                	mov    %edx,%eax
f01080da:	01 c0                	add    %eax,%eax
f01080dc:	01 d0                	add    %edx,%eax
f01080de:	c1 e0 03             	shl    $0x3,%eax
f01080e1:	01 c8                	add    %ecx,%eax
f01080e3:	a3 40 c5 5e f0       	mov    %eax,0xf05ec540
f01080e8:	8b 0d a0 c9 5e f0    	mov    0xf05ec9a0,%ecx
f01080ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080f1:	89 d0                	mov    %edx,%eax
f01080f3:	01 c0                	add    %eax,%eax
f01080f5:	01 d0                	add    %edx,%eax
f01080f7:	c1 e0 03             	shl    $0x3,%eax
f01080fa:	01 c8                	add    %ecx,%eax
f01080fc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108103:	a1 4c c5 5e f0       	mov    0xf05ec54c,%eax
f0108108:	40                   	inc    %eax
f0108109:	a3 4c c5 5e f0       	mov    %eax,0xf05ec54c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010810e:	ff 45 f4             	incl   -0xc(%ebp)
f0108111:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108114:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f0108119:	39 c2                	cmp    %eax,%edx
f010811b:	0f 82 08 ff ff ff    	jb     f0108029 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f0108121:	e8 6b bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108126:	90                   	nop
f0108127:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010812a:	c9                   	leave  
f010812b:	c3                   	ret    

f010812c <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f010812c:	55                   	push   %ebp
f010812d:	89 e5                	mov    %esp,%ebp
f010812f:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0108132:	83 ec 04             	sub    $0x4,%esp
f0108135:	6a 18                	push   $0x18
f0108137:	6a 00                	push   $0x0
f0108139:	ff 75 08             	pushl  0x8(%ebp)
f010813c:	e8 9c 68 01 00       	call   f011e9dd <memset>
f0108141:	83 c4 10             	add    $0x10,%esp
}
f0108144:	90                   	nop
f0108145:	c9                   	leave  
f0108146:	c3                   	ret    

f0108147 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0108147:	55                   	push   %ebp
f0108148:	89 e5                	mov    %esp,%ebp
f010814a:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010814d:	83 ec 0c             	sub    $0xc,%esp
f0108150:	68 60 c5 5e f0       	push   $0xf05ec560
f0108155:	e8 21 69 00 00       	call   f010ea7b <holding_spinlock>
f010815a:	83 c4 10             	add    $0x10,%esp
f010815d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0108160:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108164:	75 10                	jne    f0108176 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108166:	83 ec 0c             	sub    $0xc,%esp
f0108169:	68 60 c5 5e f0       	push   $0xf05ec560
f010816e:	e8 ef 66 00 00       	call   f010e862 <acquire_spinlock>
f0108173:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0108176:	8b 15 40 c5 5e f0    	mov    0xf05ec540,%edx
f010817c:	8b 45 08             	mov    0x8(%ebp),%eax
f010817f:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0108181:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f0108188:	8b 45 08             	mov    0x8(%ebp),%eax
f010818b:	8b 00                	mov    (%eax),%eax
f010818d:	85 c0                	test   %eax,%eax
f010818f:	75 17                	jne    f01081a8 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0108191:	83 ec 04             	sub    $0x4,%esp
f0108194:	68 f4 44 12 f0       	push   $0xf01244f4
f0108199:	68 a2 00 00 00       	push   $0xa2
f010819e:	68 a3 44 12 f0       	push   $0xf01244a3
f01081a3:	e8 91 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01081a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ab:	8b 00                	mov    (%eax),%eax
f01081ad:	85 c0                	test   %eax,%eax
f01081af:	75 17                	jne    f01081c8 <allocate_frame+0x81>
f01081b1:	83 ec 04             	sub    $0x4,%esp
f01081b4:	68 41 45 12 f0       	push   $0xf0124541
f01081b9:	68 a8 00 00 00       	push   $0xa8
f01081be:	68 a3 44 12 f0       	push   $0xf01244a3
f01081c3:	e8 71 81 ff ff       	call   f0100339 <_panic>
f01081c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01081cb:	8b 00                	mov    (%eax),%eax
f01081cd:	8b 00                	mov    (%eax),%eax
f01081cf:	85 c0                	test   %eax,%eax
f01081d1:	74 14                	je     f01081e7 <allocate_frame+0xa0>
f01081d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081d6:	8b 00                	mov    (%eax),%eax
f01081d8:	8b 00                	mov    (%eax),%eax
f01081da:	8b 55 08             	mov    0x8(%ebp),%edx
f01081dd:	8b 12                	mov    (%edx),%edx
f01081df:	8b 52 04             	mov    0x4(%edx),%edx
f01081e2:	89 50 04             	mov    %edx,0x4(%eax)
f01081e5:	eb 0d                	jmp    f01081f4 <allocate_frame+0xad>
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	8b 00                	mov    (%eax),%eax
f01081ec:	8b 40 04             	mov    0x4(%eax),%eax
f01081ef:	a3 44 c5 5e f0       	mov    %eax,0xf05ec544
f01081f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f7:	8b 00                	mov    (%eax),%eax
f01081f9:	8b 40 04             	mov    0x4(%eax),%eax
f01081fc:	85 c0                	test   %eax,%eax
f01081fe:	74 13                	je     f0108213 <allocate_frame+0xcc>
f0108200:	8b 45 08             	mov    0x8(%ebp),%eax
f0108203:	8b 00                	mov    (%eax),%eax
f0108205:	8b 40 04             	mov    0x4(%eax),%eax
f0108208:	8b 55 08             	mov    0x8(%ebp),%edx
f010820b:	8b 12                	mov    (%edx),%edx
f010820d:	8b 12                	mov    (%edx),%edx
f010820f:	89 10                	mov    %edx,(%eax)
f0108211:	eb 0c                	jmp    f010821f <allocate_frame+0xd8>
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	8b 00                	mov    (%eax),%eax
f010821a:	a3 40 c5 5e f0       	mov    %eax,0xf05ec540
f010821f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108222:	8b 00                	mov    (%eax),%eax
f0108224:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010822a:	8b 45 08             	mov    0x8(%ebp),%eax
f010822d:	8b 00                	mov    (%eax),%eax
f010822f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108236:	a1 4c c5 5e f0       	mov    0xf05ec54c,%eax
f010823b:	48                   	dec    %eax
f010823c:	a3 4c c5 5e f0       	mov    %eax,0xf05ec54c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f0108241:	8b 45 08             	mov    0x8(%ebp),%eax
f0108244:	8b 00                	mov    (%eax),%eax
f0108246:	8a 40 14             	mov    0x14(%eax),%al
f0108249:	84 c0                	test   %al,%al
f010824b:	74 20                	je     f010826d <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f010824d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108250:	8b 00                	mov    (%eax),%eax
f0108252:	8b 50 10             	mov    0x10(%eax),%edx
f0108255:	8b 45 08             	mov    0x8(%ebp),%eax
f0108258:	8b 00                	mov    (%eax),%eax
f010825a:	8b 40 0c             	mov    0xc(%eax),%eax
f010825d:	8b 40 64             	mov    0x64(%eax),%eax
f0108260:	83 ec 08             	sub    $0x8,%esp
f0108263:	52                   	push   %edx
f0108264:	50                   	push   %eax
f0108265:	e8 2a 0c 00 00       	call   f0108e94 <pt_clear_page_table_entry>
f010826a:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f010826d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108270:	8b 00                	mov    (%eax),%eax
f0108272:	83 ec 0c             	sub    $0xc,%esp
f0108275:	50                   	push   %eax
f0108276:	e8 b1 fe ff ff       	call   f010812c <initialize_frame_info>
f010827b:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f010827e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108282:	75 10                	jne    f0108294 <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108284:	83 ec 0c             	sub    $0xc,%esp
f0108287:	68 60 c5 5e f0       	push   $0xf05ec560
f010828c:	e8 58 66 00 00       	call   f010e8e9 <release_spinlock>
f0108291:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0108294:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108299:	c9                   	leave  
f010829a:	c3                   	ret    

f010829b <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f010829b:	55                   	push   %ebp
f010829c:	89 e5                	mov    %esp,%ebp
f010829e:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01082a1:	83 ec 0c             	sub    $0xc,%esp
f01082a4:	68 60 c5 5e f0       	push   $0xf05ec560
f01082a9:	e8 cd 67 00 00       	call   f010ea7b <holding_spinlock>
f01082ae:	83 c4 10             	add    $0x10,%esp
f01082b1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01082b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082b8:	75 10                	jne    f01082ca <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01082ba:	83 ec 0c             	sub    $0xc,%esp
f01082bd:	68 60 c5 5e f0       	push   $0xf05ec560
f01082c2:	e8 9b 65 00 00       	call   f010e862 <acquire_spinlock>
f01082c7:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f01082ca:	83 ec 0c             	sub    $0xc,%esp
f01082cd:	ff 75 08             	pushl  0x8(%ebp)
f01082d0:	e8 57 fe ff ff       	call   f010812c <initialize_frame_info>
f01082d5:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f01082d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01082dc:	75 17                	jne    f01082f5 <free_frame+0x5a>
f01082de:	83 ec 04             	sub    $0x4,%esp
f01082e1:	68 80 44 12 f0       	push   $0xf0124480
f01082e6:	68 cf 00 00 00       	push   $0xcf
f01082eb:	68 a3 44 12 f0       	push   $0xf01244a3
f01082f0:	e8 44 80 ff ff       	call   f0100339 <_panic>
f01082f5:	8b 15 40 c5 5e f0    	mov    0xf05ec540,%edx
f01082fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01082fe:	89 10                	mov    %edx,(%eax)
f0108300:	8b 45 08             	mov    0x8(%ebp),%eax
f0108303:	8b 00                	mov    (%eax),%eax
f0108305:	85 c0                	test   %eax,%eax
f0108307:	74 0d                	je     f0108316 <free_frame+0x7b>
f0108309:	a1 40 c5 5e f0       	mov    0xf05ec540,%eax
f010830e:	8b 55 08             	mov    0x8(%ebp),%edx
f0108311:	89 50 04             	mov    %edx,0x4(%eax)
f0108314:	eb 08                	jmp    f010831e <free_frame+0x83>
f0108316:	8b 45 08             	mov    0x8(%ebp),%eax
f0108319:	a3 44 c5 5e f0       	mov    %eax,0xf05ec544
f010831e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108321:	a3 40 c5 5e f0       	mov    %eax,0xf05ec540
f0108326:	8b 45 08             	mov    0x8(%ebp),%eax
f0108329:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108330:	a1 4c c5 5e f0       	mov    0xf05ec54c,%eax
f0108335:	40                   	inc    %eax
f0108336:	a3 4c c5 5e f0       	mov    %eax,0xf05ec54c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f010833b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010833f:	75 10                	jne    f0108351 <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108341:	83 ec 0c             	sub    $0xc,%esp
f0108344:	68 60 c5 5e f0       	push   $0xf05ec560
f0108349:	e8 9b 65 00 00       	call   f010e8e9 <release_spinlock>
f010834e:	83 c4 10             	add    $0x10,%esp
	}
}
f0108351:	90                   	nop
f0108352:	c9                   	leave  
f0108353:	c3                   	ret    

f0108354 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0108354:	55                   	push   %ebp
f0108355:	89 e5                	mov    %esp,%ebp
f0108357:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f010835a:	8b 45 08             	mov    0x8(%ebp),%eax
f010835d:	8b 40 08             	mov    0x8(%eax),%eax
f0108360:	48                   	dec    %eax
f0108361:	8b 55 08             	mov    0x8(%ebp),%edx
f0108364:	66 89 42 08          	mov    %ax,0x8(%edx)
f0108368:	8b 45 08             	mov    0x8(%ebp),%eax
f010836b:	8b 40 08             	mov    0x8(%eax),%eax
f010836e:	66 85 c0             	test   %ax,%ax
f0108371:	75 0e                	jne    f0108381 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0108373:	83 ec 0c             	sub    $0xc,%esp
f0108376:	ff 75 08             	pushl  0x8(%ebp)
f0108379:	e8 1d ff ff ff       	call   f010829b <free_frame>
f010837e:	83 c4 10             	add    $0x10,%esp
}
f0108381:	90                   	nop
f0108382:	c9                   	leave  
f0108383:	c3                   	ret    

f0108384 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108384:	55                   	push   %ebp
f0108385:	89 e5                	mov    %esp,%ebp
f0108387:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010838a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010838d:	c1 e8 16             	shr    $0x16,%eax
f0108390:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108397:	8b 45 08             	mov    0x8(%ebp),%eax
f010839a:	01 d0                	add    %edx,%eax
f010839c:	8b 00                	mov    (%eax),%eax
f010839e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f01083a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083a4:	83 e0 01             	and    $0x1,%eax
f01083a7:	85 c0                	test   %eax,%eax
f01083a9:	74 74                	je     f010841f <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01083ab:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01083b2:	77 1d                	ja     f01083d1 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01083b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01083bc:	83 ec 0c             	sub    $0xc,%esp
f01083bf:	50                   	push   %eax
f01083c0:	e8 9b 09 00 00       	call   f0108d60 <kheap_virtual_address>
f01083c5:	83 c4 10             	add    $0x10,%esp
f01083c8:	89 c2                	mov    %eax,%edx
f01083ca:	8b 45 10             	mov    0x10(%ebp),%eax
f01083cd:	89 10                	mov    %edx,(%eax)
f01083cf:	eb 44                	jmp    f0108415 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01083d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083d4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01083d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01083dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01083df:	c1 e8 0c             	shr    $0xc,%eax
f01083e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01083e5:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f01083ea:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01083ed:	72 17                	jb     f0108406 <get_page_table+0x82>
f01083ef:	ff 75 f0             	pushl  -0x10(%ebp)
f01083f2:	68 60 45 12 f0       	push   $0xf0124560
f01083f7:	68 fb 00 00 00       	push   $0xfb
f01083fc:	68 a3 44 12 f0       	push   $0xf01244a3
f0108401:	e8 33 7f ff ff       	call   f0100339 <_panic>
f0108406:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108409:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010840e:	89 c2                	mov    %eax,%edx
f0108410:	8b 45 10             	mov    0x10(%ebp),%eax
f0108413:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108415:	b8 00 00 00 00       	mov    $0x0,%eax
f010841a:	e9 b9 00 00 00       	jmp    f01084d8 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010841f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108423:	0f 84 a1 00 00 00    	je     f01084ca <get_page_table+0x146>
f0108429:	8b 45 0c             	mov    0xc(%ebp),%eax
f010842c:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010842f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108432:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108435:	83 ec 0c             	sub    $0xc,%esp
f0108438:	6a 00                	push   $0x0
f010843a:	e8 a7 60 00 00       	call   f010e4e6 <fault_handler>
f010843f:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108442:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108445:	c1 e8 16             	shr    $0x16,%eax
f0108448:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010844f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108452:	01 d0                	add    %edx,%eax
f0108454:	8b 00                	mov    (%eax),%eax
f0108456:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108459:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108460:	77 1d                	ja     f010847f <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108462:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108465:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010846a:	83 ec 0c             	sub    $0xc,%esp
f010846d:	50                   	push   %eax
f010846e:	e8 ed 08 00 00       	call   f0108d60 <kheap_virtual_address>
f0108473:	83 c4 10             	add    $0x10,%esp
f0108476:	89 c2                	mov    %eax,%edx
f0108478:	8b 45 10             	mov    0x10(%ebp),%eax
f010847b:	89 10                	mov    %edx,(%eax)
f010847d:	eb 44                	jmp    f01084c3 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010847f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108482:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108487:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010848a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010848d:	c1 e8 0c             	shr    $0xc,%eax
f0108490:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108493:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f0108498:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010849b:	72 17                	jb     f01084b4 <get_page_table+0x130>
f010849d:	ff 75 e8             	pushl  -0x18(%ebp)
f01084a0:	68 60 45 12 f0       	push   $0xf0124560
f01084a5:	68 13 01 00 00       	push   $0x113
f01084aa:	68 a3 44 12 f0       	push   $0xf01244a3
f01084af:	e8 85 7e ff ff       	call   f0100339 <_panic>
f01084b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084b7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01084bc:	89 c2                	mov    %eax,%edx
f01084be:	8b 45 10             	mov    0x10(%ebp),%eax
f01084c1:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01084c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01084c8:	eb 0e                	jmp    f01084d8 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f01084ca:	8b 45 10             	mov    0x10(%ebp),%eax
f01084cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01084d3:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01084d8:	c9                   	leave  
f01084d9:	c3                   	ret    

f01084da <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01084da:	55                   	push   %ebp
f01084db:	89 e5                	mov    %esp,%ebp
f01084dd:	53                   	push   %ebx
f01084de:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f01084e1:	83 ec 0c             	sub    $0xc,%esp
f01084e4:	68 00 10 00 00       	push   $0x1000
f01084e9:	e8 1e 08 00 00       	call   f0108d0c <kmalloc>
f01084ee:	83 c4 10             	add    $0x10,%esp
f01084f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f01084f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01084f8:	75 17                	jne    f0108511 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f01084fa:	83 ec 04             	sub    $0x4,%esp
f01084fd:	68 8f 45 12 f0       	push   $0xf012458f
f0108502:	68 33 01 00 00       	push   $0x133
f0108507:	68 a3 44 12 f0       	push   $0xf01244a3
f010850c:	e8 28 7e ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0108511:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108514:	c1 e8 16             	shr    $0x16,%eax
f0108517:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010851e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108521:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f0108524:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108527:	83 ec 0c             	sub    $0xc,%esp
f010852a:	50                   	push   %eax
f010852b:	e8 13 08 00 00       	call   f0108d43 <kheap_physical_address>
f0108530:	83 c4 10             	add    $0x10,%esp
f0108533:	83 c8 07             	or     $0x7,%eax
f0108536:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0108538:	83 ec 04             	sub    $0x4,%esp
f010853b:	68 00 10 00 00       	push   $0x1000
f0108540:	6a 00                	push   $0x0
f0108542:	ff 75 f4             	pushl  -0xc(%ebp)
f0108545:	e8 93 64 01 00       	call   f011e9dd <memset>
f010854a:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010854d:	0f 20 d8             	mov    %cr3,%eax
f0108550:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108553:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108556:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0108559:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010855c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010855f:	c9                   	leave  
f0108560:	c3                   	ret    

f0108561 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108561:	55                   	push   %ebp
f0108562:	89 e5                	mov    %esp,%ebp
f0108564:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0108567:	83 ec 0c             	sub    $0xc,%esp
f010856a:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010856d:	50                   	push   %eax
f010856e:	e8 d4 fb ff ff       	call   f0108147 <allocate_frame>
f0108573:	83 c4 10             	add    $0x10,%esp
f0108576:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0108579:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010857c:	83 ec 0c             	sub    $0xc,%esp
f010857f:	50                   	push   %eax
f0108580:	e8 70 f7 ff ff       	call   f0107cf5 <to_physical_address>
f0108585:	83 c4 10             	add    $0x10,%esp
f0108588:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010858b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010858e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108591:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108594:	c1 e8 0c             	shr    $0xc,%eax
f0108597:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010859a:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f010859f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f01085a2:	72 17                	jb     f01085bb <__static_cpt+0x5a>
f01085a4:	ff 75 ec             	pushl  -0x14(%ebp)
f01085a7:	68 60 45 12 f0       	push   $0xf0124560
f01085ac:	68 4e 01 00 00       	push   $0x14e
f01085b1:	68 a3 44 12 f0       	push   $0xf01244a3
f01085b6:	e8 7e 7d ff ff       	call   f0100339 <_panic>
f01085bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085be:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01085c3:	89 c2                	mov    %eax,%edx
f01085c5:	8b 45 10             	mov    0x10(%ebp),%eax
f01085c8:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f01085ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085cd:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01085d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01085d6:	c1 e8 16             	shr    $0x16,%eax
f01085d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01085e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01085e3:	01 d0                	add    %edx,%eax
f01085e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01085e8:	83 ca 07             	or     $0x7,%edx
f01085eb:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01085ed:	8b 45 10             	mov    0x10(%ebp),%eax
f01085f0:	8b 00                	mov    (%eax),%eax
f01085f2:	83 ec 04             	sub    $0x4,%esp
f01085f5:	68 00 10 00 00       	push   $0x1000
f01085fa:	6a 00                	push   $0x0
f01085fc:	50                   	push   %eax
f01085fd:	e8 db 63 01 00       	call   f011e9dd <memset>
f0108602:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108605:	0f 20 d8             	mov    %cr3,%eax
f0108608:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010860b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010860e:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108611:	90                   	nop
f0108612:	c9                   	leave  
f0108613:	c3                   	ret    

f0108614 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108614:	55                   	push   %ebp
f0108615:	89 e5                	mov    %esp,%ebp
f0108617:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f010861a:	ff 75 0c             	pushl  0xc(%ebp)
f010861d:	e8 d3 f6 ff ff       	call   f0107cf5 <to_physical_address>
f0108622:	83 c4 04             	add    $0x4,%esp
f0108625:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108628:	83 ec 04             	sub    $0x4,%esp
f010862b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010862e:	50                   	push   %eax
f010862f:	ff 75 10             	pushl  0x10(%ebp)
f0108632:	ff 75 08             	pushl  0x8(%ebp)
f0108635:	e8 4a fd ff ff       	call   f0108384 <get_page_table>
f010863a:	83 c4 10             	add    $0x10,%esp
f010863d:	83 f8 01             	cmp    $0x1,%eax
f0108640:	75 1b                	jne    f010865d <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0108642:	83 ec 08             	sub    $0x8,%esp
f0108645:	ff 75 10             	pushl  0x10(%ebp)
f0108648:	ff 75 08             	pushl  0x8(%ebp)
f010864b:	e8 8a fe ff ff       	call   f01084da <create_page_table>
f0108650:	83 c4 10             	add    $0x10,%esp
f0108653:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0108656:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f010865d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108660:	8b 55 10             	mov    0x10(%ebp),%edx
f0108663:	c1 ea 0c             	shr    $0xc,%edx
f0108666:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010866c:	c1 e2 02             	shl    $0x2,%edx
f010866f:	01 d0                	add    %edx,%eax
f0108671:	8b 00                	mov    (%eax),%eax
f0108673:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108676:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108679:	83 e0 01             	and    $0x1,%eax
f010867c:	85 c0                	test   %eax,%eax
f010867e:	74 25                	je     f01086a5 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108680:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108683:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108688:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010868b:	75 07                	jne    f0108694 <map_frame+0x80>
			return 0;
f010868d:	b8 00 00 00 00       	mov    $0x0,%eax
f0108692:	eb 68                	jmp    f01086fc <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108694:	83 ec 08             	sub    $0x8,%esp
f0108697:	ff 75 10             	pushl  0x10(%ebp)
f010869a:	ff 75 08             	pushl  0x8(%ebp)
f010869d:	e8 d2 00 00 00       	call   f0108774 <unmap_frame>
f01086a2:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f01086a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01086a8:	8b 40 08             	mov    0x8(%eax),%eax
f01086ab:	40                   	inc    %eax
f01086ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f01086af:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01086b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086b6:	8b 55 10             	mov    0x10(%ebp),%edx
f01086b9:	c1 ea 0c             	shr    $0xc,%edx
f01086bc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086c2:	c1 e2 02             	shl    $0x2,%edx
f01086c5:	01 d0                	add    %edx,%eax
f01086c7:	8b 00                	mov    (%eax),%eax
f01086c9:	25 00 0e 00 00       	and    $0xe00,%eax
f01086ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f01086d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086d4:	8b 55 10             	mov    0x10(%ebp),%edx
f01086d7:	c1 ea 0c             	shr    $0xc,%edx
f01086da:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086e0:	c1 e2 02             	shl    $0x2,%edx
f01086e3:	01 c2                	add    %eax,%edx
f01086e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086e8:	0b 45 e8             	or     -0x18(%ebp),%eax
f01086eb:	89 c1                	mov    %eax,%ecx
f01086ed:	8b 45 14             	mov    0x14(%ebp),%eax
f01086f0:	09 c8                	or     %ecx,%eax
f01086f2:	83 c8 01             	or     $0x1,%eax
f01086f5:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01086f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01086fc:	c9                   	leave  
f01086fd:	c3                   	ret    

f01086fe <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01086fe:	55                   	push   %ebp
f01086ff:	89 e5                	mov    %esp,%ebp
f0108701:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0108704:	83 ec 04             	sub    $0x4,%esp
f0108707:	ff 75 10             	pushl  0x10(%ebp)
f010870a:	ff 75 0c             	pushl  0xc(%ebp)
f010870d:	ff 75 08             	pushl  0x8(%ebp)
f0108710:	e8 6f fc ff ff       	call   f0108384 <get_page_table>
f0108715:	83 c4 10             	add    $0x10,%esp
f0108718:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f010871b:	8b 45 10             	mov    0x10(%ebp),%eax
f010871e:	8b 00                	mov    (%eax),%eax
f0108720:	85 c0                	test   %eax,%eax
f0108722:	74 49                	je     f010876d <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f0108724:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108727:	c1 e8 0c             	shr    $0xc,%eax
f010872a:	25 ff 03 00 00       	and    $0x3ff,%eax
f010872f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0108732:	8b 45 10             	mov    0x10(%ebp),%eax
f0108735:	8b 00                	mov    (%eax),%eax
f0108737:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010873a:	c1 e2 02             	shl    $0x2,%edx
f010873d:	01 d0                	add    %edx,%eax
f010873f:	8b 00                	mov    (%eax),%eax
f0108741:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108744:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108747:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010874c:	85 c0                	test   %eax,%eax
f010874e:	74 16                	je     f0108766 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0108750:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108753:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108758:	83 ec 0c             	sub    $0xc,%esp
f010875b:	50                   	push   %eax
f010875c:	e8 a7 f5 ff ff       	call   f0107d08 <to_frame_info>
f0108761:	83 c4 10             	add    $0x10,%esp
f0108764:	eb 0c                	jmp    f0108772 <get_frame_info+0x74>
		}
		return 0;
f0108766:	b8 00 00 00 00       	mov    $0x0,%eax
f010876b:	eb 05                	jmp    f0108772 <get_frame_info+0x74>
	}
	return 0;
f010876d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108772:	c9                   	leave  
f0108773:	c3                   	ret    

f0108774 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108774:	55                   	push   %ebp
f0108775:	89 e5                	mov    %esp,%ebp
f0108777:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f010877a:	83 ec 04             	sub    $0x4,%esp
f010877d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108780:	50                   	push   %eax
f0108781:	ff 75 0c             	pushl  0xc(%ebp)
f0108784:	ff 75 08             	pushl  0x8(%ebp)
f0108787:	e8 72 ff ff ff       	call   f01086fe <get_frame_info>
f010878c:	83 c4 10             	add    $0x10,%esp
f010878f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108796:	74 7d                	je     f0108815 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108798:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010879b:	8a 40 14             	mov    0x14(%eax),%al
f010879e:	84 c0                	test   %al,%al
f01087a0:	74 1c                	je     f01087be <unmap_frame+0x4a>
f01087a2:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01087a9:	77 13                	ja     f01087be <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f01087ab:	83 ec 08             	sub    $0x8,%esp
f01087ae:	ff 75 0c             	pushl  0xc(%ebp)
f01087b1:	68 ac 45 12 f0       	push   $0xf01245ac
f01087b6:	e8 d0 87 ff ff       	call   f0100f8b <cprintf>
f01087bb:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f01087be:	83 ec 0c             	sub    $0xc,%esp
f01087c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01087c4:	e8 8b fb ff ff       	call   f0108354 <decrement_references>
f01087c9:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01087cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087cf:	8b 55 0c             	mov    0xc(%ebp),%edx
f01087d2:	c1 ea 0c             	shr    $0xc,%edx
f01087d5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087db:	c1 e2 02             	shl    $0x2,%edx
f01087de:	01 d0                	add    %edx,%eax
f01087e0:	8b 00                	mov    (%eax),%eax
f01087e2:	25 00 0e 00 00       	and    $0xe00,%eax
f01087e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01087ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087ed:	8b 55 0c             	mov    0xc(%ebp),%edx
f01087f0:	c1 ea 0c             	shr    $0xc,%edx
f01087f3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087f9:	c1 e2 02             	shl    $0x2,%edx
f01087fc:	01 c2                	add    %eax,%edx
f01087fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108801:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0108803:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108806:	83 ec 08             	sub    $0x8,%esp
f0108809:	50                   	push   %eax
f010880a:	ff 75 08             	pushl  0x8(%ebp)
f010880d:	e8 3c f5 ff ff       	call   f0107d4e <tlb_invalidate>
f0108812:	83 c4 10             	add    $0x10,%esp
	}
}
f0108815:	90                   	nop
f0108816:	c9                   	leave  
f0108817:	c3                   	ret    

f0108818 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108818:	55                   	push   %ebp
f0108819:	89 e5                	mov    %esp,%ebp
f010881b:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f010881e:	ff 75 0c             	pushl  0xc(%ebp)
f0108821:	e8 cf f4 ff ff       	call   f0107cf5 <to_physical_address>
f0108826:	83 c4 04             	add    $0x4,%esp
f0108829:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010882c:	8b 45 10             	mov    0x10(%ebp),%eax
f010882f:	c1 e8 16             	shr    $0x16,%eax
f0108832:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108839:	8b 45 08             	mov    0x8(%ebp),%eax
f010883c:	01 d0                	add    %edx,%eax
f010883e:	8b 00                	mov    (%eax),%eax
f0108840:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108843:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010884a:	77 19                	ja     f0108865 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010884c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010884f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108854:	83 ec 0c             	sub    $0xc,%esp
f0108857:	50                   	push   %eax
f0108858:	e8 03 05 00 00       	call   f0108d60 <kheap_virtual_address>
f010885d:	83 c4 10             	add    $0x10,%esp
f0108860:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108863:	eb 40                	jmp    f01088a5 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108865:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108868:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010886d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108870:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108873:	c1 e8 0c             	shr    $0xc,%eax
f0108876:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108879:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f010887e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108881:	72 17                	jb     f010889a <loadtime_map_frame+0x82>
f0108883:	ff 75 e8             	pushl  -0x18(%ebp)
f0108886:	68 60 45 12 f0       	push   $0xf0124560
f010888b:	68 f9 01 00 00       	push   $0x1f9
f0108890:	68 a3 44 12 f0       	push   $0xf01244a3
f0108895:	e8 9f 7a ff ff       	call   f0100339 <_panic>
f010889a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010889d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01088a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f01088a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01088a9:	75 14                	jne    f01088bf <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f01088ab:	83 ec 08             	sub    $0x8,%esp
f01088ae:	ff 75 10             	pushl  0x10(%ebp)
f01088b1:	ff 75 08             	pushl  0x8(%ebp)
f01088b4:	e8 21 fc ff ff       	call   f01084da <create_page_table>
f01088b9:	83 c4 10             	add    $0x10,%esp
f01088bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f01088bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088c2:	8b 40 08             	mov    0x8(%eax),%eax
f01088c5:	40                   	inc    %eax
f01088c6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01088c9:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f01088cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01088d0:	c1 e8 0c             	shr    $0xc,%eax
f01088d3:	25 ff 03 00 00       	and    $0x3ff,%eax
f01088d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088e2:	01 c2                	add    %eax,%edx
f01088e4:	8b 45 14             	mov    0x14(%ebp),%eax
f01088e7:	0b 45 f0             	or     -0x10(%ebp),%eax
f01088ea:	83 c8 01             	or     $0x1,%eax
f01088ed:	89 02                	mov    %eax,(%edx)

	return 0;
f01088ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01088f4:	c9                   	leave  
f01088f5:	c3                   	ret    

f01088f6 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f01088f6:	55                   	push   %ebp
f01088f7:	89 e5                	mov    %esp,%ebp
f01088f9:	57                   	push   %edi
f01088fa:	56                   	push   %esi
f01088fb:	53                   	push   %ebx
f01088fc:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01088ff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108906:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f010890d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108914:	83 ec 0c             	sub    $0xc,%esp
f0108917:	68 60 c5 5e f0       	push   $0xf05ec560
f010891c:	e8 5a 61 00 00       	call   f010ea7b <holding_spinlock>
f0108921:	83 c4 10             	add    $0x10,%esp
f0108924:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108927:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010892b:	75 10                	jne    f010893d <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f010892d:	83 ec 0c             	sub    $0xc,%esp
f0108930:	68 60 c5 5e f0       	push   $0xf05ec560
f0108935:	e8 28 5f 00 00       	call   f010e862 <acquire_spinlock>
f010893a:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f010893d:	a1 40 c5 5e f0       	mov    0xf05ec540,%eax
f0108942:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108945:	eb 1a                	jmp    f0108961 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0108947:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010894a:	8a 40 14             	mov    0x14(%eax),%al
f010894d:	84 c0                	test   %al,%al
f010894f:	74 05                	je     f0108956 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108951:	ff 45 dc             	incl   -0x24(%ebp)
f0108954:	eb 03                	jmp    f0108959 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0108956:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108959:	a1 48 c5 5e f0       	mov    0xf05ec548,%eax
f010895e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108961:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108965:	74 07                	je     f010896e <calculate_available_frames+0x78>
f0108967:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010896a:	8b 00                	mov    (%eax),%eax
f010896c:	eb 05                	jmp    f0108973 <calculate_available_frames+0x7d>
f010896e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108973:	a3 48 c5 5e f0       	mov    %eax,0xf05ec548
f0108978:	a1 48 c5 5e f0       	mov    0xf05ec548,%eax
f010897d:	85 c0                	test   %eax,%eax
f010897f:	75 c6                	jne    f0108947 <calculate_available_frames+0x51>
f0108981:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108985:	75 c0                	jne    f0108947 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108987:	a1 5c c5 5e f0       	mov    0xf05ec55c,%eax
f010898c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f010898f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108993:	75 10                	jne    f01089a5 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108995:	83 ec 0c             	sub    $0xc,%esp
f0108998:	68 60 c5 5e f0       	push   $0xf05ec560
f010899d:	e8 47 5f 00 00       	call   f010e8e9 <release_spinlock>
f01089a2:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f01089a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01089a8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f01089ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01089ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f01089b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01089b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f01089b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01089ba:	89 c3                	mov    %eax,%ebx
f01089bc:	8d 45 c8             	lea    -0x38(%ebp),%eax
f01089bf:	ba 03 00 00 00       	mov    $0x3,%edx
f01089c4:	89 df                	mov    %ebx,%edi
f01089c6:	89 c6                	mov    %eax,%esi
f01089c8:	89 d1                	mov    %edx,%ecx
f01089ca:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01089cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01089cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01089d2:	5b                   	pop    %ebx
f01089d3:	5e                   	pop    %esi
f01089d4:	5f                   	pop    %edi
f01089d5:	5d                   	pop    %ebp
f01089d6:	c2 04 00             	ret    $0x4

f01089d9 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f01089d9:	55                   	push   %ebp
f01089da:	89 e5                	mov    %esp,%ebp
f01089dc:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f01089df:	c7 05 00 c4 5e f0 00 	movl   $0x0,0xf05ec400
f01089e6:	00 00 00 
f01089e9:	c7 05 04 c4 5e f0 00 	movl   $0x0,0xf05ec404
f01089f0:	00 00 00 
f01089f3:	c7 05 0c c4 5e f0 00 	movl   $0x0,0xf05ec40c
f01089fa:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f01089fd:	83 ec 08             	sub    $0x8,%esp
f0108a00:	68 dc 45 12 f0       	push   $0xf01245dc
f0108a05:	68 10 c4 5e f0       	push   $0xf05ec410
f0108a0a:	e8 22 5e 00 00       	call   f010e831 <init_spinlock>
f0108a0f:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a12:	90                   	nop
f0108a13:	c9                   	leave  
f0108a14:	c3                   	ret    

f0108a15 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a15:	55                   	push   %ebp
f0108a16:	89 e5                	mov    %esp,%ebp
f0108a18:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a1b:	83 ec 08             	sub    $0x8,%esp
f0108a1e:	ff 75 0c             	pushl  0xc(%ebp)
f0108a21:	ff 75 08             	pushl  0x8(%ebp)
f0108a24:	e8 55 00 00 00       	call   f0108a7e <get_share>
f0108a29:	83 c4 10             	add    $0x10,%esp
f0108a2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a2f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a33:	75 07                	jne    f0108a3c <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108a35:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108a3a:	eb 06                	jmp    f0108a42 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a3f:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108a42:	c9                   	leave  
f0108a43:	c3                   	ret    

f0108a44 <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f0108a4a:	83 ec 04             	sub    $0x4,%esp
f0108a4d:	68 e8 45 12 f0       	push   $0xf01245e8
f0108a52:	6a 45                	push   $0x45
f0108a54:	68 18 46 12 f0       	push   $0xf0124618
f0108a59:	e8 db 78 ff ff       	call   f0100339 <_panic>

f0108a5e <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108a5e:	55                   	push   %ebp
f0108a5f:	89 e5                	mov    %esp,%ebp
f0108a61:	83 ec 18             	sub    $0x18,%esp
f0108a64:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a67:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f0108a6a:	83 ec 04             	sub    $0x4,%esp
f0108a6d:	68 3c 46 12 f0       	push   $0xf012463c
f0108a72:	6a 54                	push   $0x54
f0108a74:	68 18 46 12 f0       	push   $0xf0124618
f0108a79:	e8 bb 78 ff ff       	call   f0100339 <_panic>

f0108a7e <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108a7e:	55                   	push   %ebp
f0108a7f:	89 e5                	mov    %esp,%ebp
f0108a81:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f0108a84:	83 ec 04             	sub    $0x4,%esp
f0108a87:	68 60 46 12 f0       	push   $0xf0124660
f0108a8c:	6a 64                	push   $0x64
f0108a8e:	68 18 46 12 f0       	push   $0xf0124618
f0108a93:	e8 a1 78 ff ff       	call   f0100339 <_panic>

f0108a98 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108a98:	55                   	push   %ebp
f0108a99:	89 e5                	mov    %esp,%ebp
f0108a9b:	83 ec 18             	sub    $0x18,%esp
f0108a9e:	8b 45 14             	mov    0x14(%ebp),%eax
f0108aa1:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f0108aa4:	83 ec 04             	sub    $0x4,%esp
f0108aa7:	68 84 46 12 f0       	push   $0xf0124684
f0108aac:	6a 70                	push   $0x70
f0108aae:	68 18 46 12 f0       	push   $0xf0124618
f0108ab3:	e8 81 78 ff ff       	call   f0100339 <_panic>

f0108ab8 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108ab8:	55                   	push   %ebp
f0108ab9:	89 e5                	mov    %esp,%ebp
f0108abb:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f0108abe:	83 ec 04             	sub    $0x4,%esp
f0108ac1:	68 b0 46 12 f0       	push   $0xf01246b0
f0108ac6:	6a 7e                	push   $0x7e
f0108ac8:	68 18 46 12 f0       	push   $0xf0124618
f0108acd:	e8 67 78 ff ff       	call   f0100339 <_panic>

f0108ad2 <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108ad2:	55                   	push   %ebp
f0108ad3:	89 e5                	mov    %esp,%ebp
f0108ad5:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f0108ad8:	83 ec 04             	sub    $0x4,%esp
f0108adb:	68 d8 46 12 f0       	push   $0xf01246d8
f0108ae0:	68 91 00 00 00       	push   $0x91
f0108ae5:	68 18 46 12 f0       	push   $0xf0124618
f0108aea:	e8 4a 78 ff ff       	call   f0100339 <_panic>

f0108aef <freeSharedObject>:
}
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108aef:	55                   	push   %ebp
f0108af0:	89 e5                	mov    %esp,%ebp
f0108af2:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108af5:	83 ec 04             	sub    $0x4,%esp
f0108af8:	68 fc 46 12 f0       	push   $0xf01246fc
f0108afd:	68 9c 00 00 00       	push   $0x9c
f0108b02:	68 18 46 12 f0       	push   $0xf0124618
f0108b07:	e8 2d 78 ff ff       	call   f0100339 <_panic>

f0108b0c <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108b0c:	55                   	push   %ebp
f0108b0d:	89 e5                	mov    %esp,%ebp
f0108b0f:	83 ec 38             	sub    $0x38,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f0108b12:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b15:	a3 e8 cb 5e f0       	mov    %eax,0xf05ecbe8
	hard_limit = daLimit;
f0108b1a:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b1d:	a3 30 ca 5e f0       	mov    %eax,0xf05eca30
	brk = daStart + initSizeToAllocate;
f0108b22:	8b 55 08             	mov    0x8(%ebp),%edx
f0108b25:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b28:	01 d0                	add    %edx,%eax
f0108b2a:	a3 e0 cb 5e f0       	mov    %eax,0xf05ecbe0

	if(initSizeToAllocate > daLimit) panic("exceeds Limit");
f0108b2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b32:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108b35:	76 14                	jbe    f0108b4b <initialize_kheap_dynamic_allocator+0x3f>
f0108b37:	83 ec 04             	sub    $0x4,%esp
f0108b3a:	68 24 47 12 f0       	push   $0xf0124724
f0108b3f:	6a 16                	push   $0x16
f0108b41:	68 32 47 12 f0       	push   $0xf0124732
f0108b46:	e8 ee 77 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0108b4b:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f0108b52:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b55:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 struct FrameInfo * start_page_area = (struct FrameInfo*) (daLimit + PAGE_SIZE);
f0108b58:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b5b:	05 00 10 00 00       	add    $0x1000,%eax
f0108b60:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 struct FrameInfo * end_page_area = (struct FrameInfo*) KERNEL_HEAP_MAX;
f0108b63:	c7 45 e4 00 f0 ff ff 	movl   $0xfffff000,-0x1c(%ebp)

	 uint32 page_area_size = (uint32)daStart+(uint32)brk;
f0108b6a:	8b 15 e0 cb 5e f0    	mov    0xf05ecbe0,%edx
f0108b70:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b73:	01 d0                	add    %edx,%eax
f0108b75:	89 45 e0             	mov    %eax,-0x20(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f0108b78:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108b7b:	c1 e8 0c             	shr    $0xc,%eax
f0108b7e:	89 45 dc             	mov    %eax,-0x24(%ebp)


	 for(int i=0;i<no_pages;i++)
f0108b81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108b88:	eb 54                	jmp    f0108bde <initialize_kheap_dynamic_allocator+0xd2>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0108b8a:	83 ec 0c             	sub    $0xc,%esp
f0108b8d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108b90:	50                   	push   %eax
f0108b91:	e8 b1 f5 ff ff       	call   f0108147 <allocate_frame>
f0108b96:	83 c4 10             	add    $0x10,%esp
f0108b99:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(ret != E_NO_MEM)
f0108b9c:	83 7d d8 fc          	cmpl   $0xfffffffc,-0x28(%ebp)
f0108ba0:	74 28                	je     f0108bca <initialize_kheap_dynamic_allocator+0xbe>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_page_area+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
f0108ba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ba5:	c1 e0 0c             	shl    $0xc,%eax
f0108ba8:	89 c2                	mov    %eax,%edx
f0108baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bad:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0108bb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108bb3:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0108bb8:	6a 06                	push   $0x6
f0108bba:	51                   	push   %ecx
f0108bbb:	52                   	push   %edx
f0108bbc:	50                   	push   %eax
f0108bbd:	e8 52 fa ff ff       	call   f0108614 <map_frame>
f0108bc2:	83 c4 10             	add    $0x10,%esp

	 uint32 page_area_size = (uint32)daStart+(uint32)brk;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0108bc5:	ff 45 f4             	incl   -0xc(%ebp)
f0108bc8:	eb 14                	jmp    f0108bde <initialize_kheap_dynamic_allocator+0xd2>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_page_area+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
		}
		else
		{
			panic("No Memory");
f0108bca:	83 ec 04             	sub    $0x4,%esp
f0108bcd:	68 43 47 12 f0       	push   $0xf0124743
f0108bd2:	6a 2c                	push   $0x2c
f0108bd4:	68 32 47 12 f0       	push   $0xf0124732
f0108bd9:	e8 5b 77 ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = (uint32)daStart+(uint32)brk;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0108bde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108be1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108be4:	72 a4                	jb     f0108b8a <initialize_kheap_dynamic_allocator+0x7e>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0108be6:	83 ec 08             	sub    $0x8,%esp
f0108be9:	ff 75 0c             	pushl  0xc(%ebp)
f0108bec:	ff 75 08             	pushl  0x8(%ebp)
f0108bef:	e8 ca 67 01 00       	call   f011f3be <initialize_dynamic_allocator>
f0108bf4:	83 c4 10             	add    $0x10,%esp

	return 0;
f0108bf7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108bfc:	c9                   	leave  
f0108bfd:	c3                   	ret    

f0108bfe <sbrk>:

void* sbrk(int numOfPages)
{
f0108bfe:	55                   	push   %ebp
f0108bff:	89 e5                	mov    %esp,%ebp
f0108c01:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f0108c04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108c08:	0f 8e db 00 00 00    	jle    f0108ce9 <sbrk+0xeb>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f0108c0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c11:	c1 e0 0c             	shl    $0xc,%eax
f0108c14:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 prev_brk=brk;
f0108c17:	a1 e0 cb 5e f0       	mov    0xf05ecbe0,%eax
f0108c1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		brk += size;
f0108c1f:	8b 15 e0 cb 5e f0    	mov    0xf05ecbe0,%edx
f0108c25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c28:	01 d0                	add    %edx,%eax
f0108c2a:	a3 e0 cb 5e f0       	mov    %eax,0xf05ecbe0
		if((char *)brk > (char *)hard_limit) return (void *)-1;
f0108c2f:	a1 e0 cb 5e f0       	mov    0xf05ecbe0,%eax
f0108c34:	89 c2                	mov    %eax,%edx
f0108c36:	a1 30 ca 5e f0       	mov    0xf05eca30,%eax
f0108c3b:	39 c2                	cmp    %eax,%edx
f0108c3d:	76 0a                	jbe    f0108c49 <sbrk+0x4b>
f0108c3f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108c44:	e9 c1 00 00 00       	jmp    f0108d0a <sbrk+0x10c>
		struct Block_Start_End* end_block = (struct Block_Start_End*) (brk);
f0108c49:	a1 e0 cb 5e f0       	mov    0xf05ecbe0,%eax
f0108c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		end_block->info = 1;
f0108c51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108c54:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

		if((char *)LIST_LAST(&freeBlocksList) < (char *)prev_brk)
f0108c5a:	8b 15 d4 c5 5e f0    	mov    0xf05ec5d4,%edx
f0108c60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c63:	39 c2                	cmp    %eax,%edx
f0108c65:	73 19                	jae    f0108c80 <sbrk+0x82>
		{
				merging(LIST_LAST(&freeBlocksList), NULL, (void *)prev_brk);
f0108c67:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108c6a:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f0108c6f:	83 ec 04             	sub    $0x4,%esp
f0108c72:	52                   	push   %edx
f0108c73:	6a 00                	push   $0x0
f0108c75:	50                   	push   %eax
f0108c76:	e8 d9 72 01 00       	call   f011ff54 <merging>
f0108c7b:	83 c4 10             	add    $0x10,%esp
f0108c7e:	eb 13                	jmp    f0108c93 <sbrk+0x95>
		}
		else
		{
			merging(NULL, NULL, (void *)prev_brk);
f0108c80:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c83:	83 ec 04             	sub    $0x4,%esp
f0108c86:	50                   	push   %eax
f0108c87:	6a 00                	push   $0x0
f0108c89:	6a 00                	push   $0x0
f0108c8b:	e8 c4 72 01 00       	call   f011ff54 <merging>
f0108c90:	83 c4 10             	add    $0x10,%esp
		}
		for(int i=0;i<numOfPages;i++)
f0108c93:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0108c9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c9d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108ca0:	7d 54                	jge    f0108cf6 <sbrk+0xf8>
		{
		struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0108ca2:	83 ec 0c             	sub    $0xc,%esp
f0108ca5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108ca8:	50                   	push   %eax
f0108ca9:	e8 99 f4 ff ff       	call   f0108147 <allocate_frame>
f0108cae:	83 c4 10             	add    $0x10,%esp
f0108cb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret != E_NO_MEM)
f0108cb4:	83 7d e4 fc          	cmpl   $0xfffffffc,-0x1c(%ebp)
f0108cb8:	74 28                	je     f0108ce2 <sbrk+0xe4>
		{
			map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
f0108cba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108cbd:	c1 e0 0c             	shl    $0xc,%eax
f0108cc0:	89 c2                	mov    %eax,%edx
f0108cc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108cc5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0108cc8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108ccb:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0108cd0:	6a 06                	push   $0x6
f0108cd2:	51                   	push   %ecx
f0108cd3:	52                   	push   %edx
f0108cd4:	50                   	push   %eax
f0108cd5:	e8 3a f9 ff ff       	call   f0108614 <map_frame>
f0108cda:	83 c4 10             	add    $0x10,%esp
			return (void *)prev_brk;
f0108cdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ce0:	eb 28                	jmp    f0108d0a <sbrk+0x10c>
		}
		else
		{
			return (void *)-1;
f0108ce2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108ce7:	eb 21                	jmp    f0108d0a <sbrk+0x10c>
		}
		}

	}
	else if(numOfPages == 0)
f0108ce9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108ced:	75 07                	jne    f0108cf6 <sbrk+0xf8>
	{
		return (void *) brk;
f0108cef:	a1 e0 cb 5e f0       	mov    0xf05ecbe0,%eax
f0108cf4:	eb 14                	jmp    f0108d0a <sbrk+0x10c>
	}

		panic("can't be negative");
f0108cf6:	83 ec 04             	sub    $0x4,%esp
f0108cf9:	68 4d 47 12 f0       	push   $0xf012474d
f0108cfe:	6a 6e                	push   $0x6e
f0108d00:	68 32 47 12 f0       	push   $0xf0124732
f0108d05:	e8 2f 76 ff ff       	call   f0100339 <_panic>
		return (void *)-1;

}
f0108d0a:	c9                   	leave  
f0108d0b:	c3                   	ret    

f0108d0c <kmalloc>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator

void* kmalloc(unsigned int size)
{
f0108d0c:	55                   	push   %ebp
f0108d0d:	89 e5                	mov    %esp,%ebp
f0108d0f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	// Write your code here, remove the panic and write your code
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f0108d12:	83 ec 04             	sub    $0x4,%esp
f0108d15:	68 60 47 12 f0       	push   $0xf0124760
f0108d1a:	6a 79                	push   $0x79
f0108d1c:	68 32 47 12 f0       	push   $0xf0124732
f0108d21:	e8 3e 77 ff ff       	call   f0100464 <_panic_into_prompt>

f0108d26 <kfree>:
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

}

void kfree(void* virtual_address)
{
f0108d26:	55                   	push   %ebp
f0108d27:	89 e5                	mov    %esp,%ebp
f0108d29:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #04] [1] KERNEL HEAP - kfree
	// Write your code here, remove the panic and write your code
	panic("kfree() is not implemented yet...!!");
f0108d2c:	83 ec 04             	sub    $0x4,%esp
f0108d2f:	68 88 47 12 f0       	push   $0xf0124788
f0108d34:	68 83 00 00 00       	push   $0x83
f0108d39:	68 32 47 12 f0       	push   $0xf0124732
f0108d3e:	e8 f6 75 ff ff       	call   f0100339 <_panic>

f0108d43 <kheap_physical_address>:
	//refer to the project presentation and documentation for details

}

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0108d43:	55                   	push   %ebp
f0108d44:	89 e5                	mov    %esp,%ebp
f0108d46:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #05] [1] KERNEL HEAP - kheap_physical_address
	// Write your code here, remove the panic and write your code
	panic("kheap_physical_address() is not implemented yet...!!");
f0108d49:	83 ec 04             	sub    $0x4,%esp
f0108d4c:	68 ac 47 12 f0       	push   $0xf01247ac
f0108d51:	68 8e 00 00 00       	push   $0x8e
f0108d56:	68 32 47 12 f0       	push   $0xf0124732
f0108d5b:	e8 d9 75 ff ff       	call   f0100339 <_panic>

f0108d60 <kheap_virtual_address>:

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
}

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0108d60:	55                   	push   %ebp
f0108d61:	89 e5                	mov    %esp,%ebp
f0108d63:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #06] [1] KERNEL HEAP - kheap_virtual_address
	// Write your code here, remove the panic and write your code
	panic("kheap_virtual_address() is not implemented yet...!!");
f0108d66:	83 ec 04             	sub    $0x4,%esp
f0108d69:	68 e4 47 12 f0       	push   $0xf01247e4
f0108d6e:	68 9a 00 00 00       	push   $0x9a
f0108d73:	68 32 47 12 f0       	push   $0xf0124732
f0108d78:	e8 bc 75 ff ff       	call   f0100339 <_panic>

f0108d7d <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f0108d7d:	55                   	push   %ebp
f0108d7e:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	// Write your code here, remove the panic and write your code
	return NULL;
f0108d80:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f0108d85:	5d                   	pop    %ebp
f0108d86:	c3                   	ret    

f0108d87 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0108d87:	55                   	push   %ebp
f0108d88:	89 e5                	mov    %esp,%ebp
f0108d8a:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108d8d:	83 ec 04             	sub    $0x4,%esp
f0108d90:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108d93:	50                   	push   %eax
f0108d94:	ff 75 0c             	pushl  0xc(%ebp)
f0108d97:	ff 75 08             	pushl  0x8(%ebp)
f0108d9a:	e8 e5 f5 ff ff       	call   f0108384 <get_page_table>
f0108d9f:	83 c4 10             	add    $0x10,%esp
f0108da2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108da5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108da8:	85 c0                	test   %eax,%eax
f0108daa:	74 64                	je     f0108e10 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0108dac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108daf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108db2:	c1 ea 0c             	shr    $0xc,%edx
f0108db5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108dbb:	c1 e2 02             	shl    $0x2,%edx
f0108dbe:	01 c2                	add    %eax,%edx
f0108dc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108dc3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108dc6:	c1 e9 0c             	shr    $0xc,%ecx
f0108dc9:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108dcf:	c1 e1 02             	shl    $0x2,%ecx
f0108dd2:	01 c8                	add    %ecx,%eax
f0108dd4:	8b 00                	mov    (%eax),%eax
f0108dd6:	0b 45 10             	or     0x10(%ebp),%eax
f0108dd9:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0108ddb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108dde:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108de1:	c1 ea 0c             	shr    $0xc,%edx
f0108de4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108dea:	c1 e2 02             	shl    $0x2,%edx
f0108ded:	01 d0                	add    %edx,%eax
f0108def:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108df2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108df5:	c1 e9 0c             	shr    $0xc,%ecx
f0108df8:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108dfe:	c1 e1 02             	shl    $0x2,%ecx
f0108e01:	01 ca                	add    %ecx,%edx
f0108e03:	8b 12                	mov    (%edx),%edx
f0108e05:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0108e08:	f7 d1                	not    %ecx
f0108e0a:	21 ca                	and    %ecx,%edx
f0108e0c:	89 10                	mov    %edx,(%eax)
f0108e0e:	eb 27                	jmp    f0108e37 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0108e10:	83 ec 08             	sub    $0x8,%esp
f0108e13:	ff 75 0c             	pushl  0xc(%ebp)
f0108e16:	68 18 48 12 f0       	push   $0xf0124818
f0108e1b:	e8 6b 81 ff ff       	call   f0100f8b <cprintf>
f0108e20:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0108e23:	83 ec 04             	sub    $0x4,%esp
f0108e26:	68 40 48 12 f0       	push   $0xf0124840
f0108e2b:	6a 1c                	push   $0x1c
f0108e2d:	68 b4 48 12 f0       	push   $0xf01248b4
f0108e32:	e8 02 75 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108e37:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108e3a:	83 ec 08             	sub    $0x8,%esp
f0108e3d:	50                   	push   %eax
f0108e3e:	6a 00                	push   $0x0
f0108e40:	e8 09 ef ff ff       	call   f0107d4e <tlb_invalidate>
f0108e45:	83 c4 10             	add    $0x10,%esp
}
f0108e48:	90                   	nop
f0108e49:	c9                   	leave  
f0108e4a:	c3                   	ret    

f0108e4b <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0108e4b:	55                   	push   %ebp
f0108e4c:	89 e5                	mov    %esp,%ebp
f0108e4e:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108e51:	83 ec 04             	sub    $0x4,%esp
f0108e54:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108e57:	50                   	push   %eax
f0108e58:	ff 75 0c             	pushl  0xc(%ebp)
f0108e5b:	ff 75 08             	pushl  0x8(%ebp)
f0108e5e:	e8 21 f5 ff ff       	call   f0108384 <get_page_table>
f0108e63:	83 c4 10             	add    $0x10,%esp
f0108e66:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0108e69:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e6c:	85 c0                	test   %eax,%eax
f0108e6e:	74 1d                	je     f0108e8d <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0108e70:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e73:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e76:	c1 ea 0c             	shr    $0xc,%edx
f0108e79:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108e7f:	c1 e2 02             	shl    $0x2,%edx
f0108e82:	01 d0                	add    %edx,%eax
f0108e84:	8b 00                	mov    (%eax),%eax
f0108e86:	25 ff 0f 00 00       	and    $0xfff,%eax
f0108e8b:	eb 05                	jmp    f0108e92 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0108e8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0108e92:	c9                   	leave  
f0108e93:	c3                   	ret    

f0108e94 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0108e94:	55                   	push   %ebp
f0108e95:	89 e5                	mov    %esp,%ebp
f0108e97:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108e9a:	83 ec 04             	sub    $0x4,%esp
f0108e9d:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108ea0:	50                   	push   %eax
f0108ea1:	ff 75 0c             	pushl  0xc(%ebp)
f0108ea4:	ff 75 08             	pushl  0x8(%ebp)
f0108ea7:	e8 d8 f4 ff ff       	call   f0108384 <get_page_table>
f0108eac:	83 c4 10             	add    $0x10,%esp
f0108eaf:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108eb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108eb5:	85 c0                	test   %eax,%eax
f0108eb7:	74 46                	je     f0108eff <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0108eb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ebc:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108ebf:	c1 ea 0c             	shr    $0xc,%edx
f0108ec2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108ec8:	c1 e2 02             	shl    $0x2,%edx
f0108ecb:	01 d0                	add    %edx,%eax
f0108ecd:	8b 00                	mov    (%eax),%eax
f0108ecf:	83 ec 04             	sub    $0x4,%esp
f0108ed2:	50                   	push   %eax
f0108ed3:	ff 75 0c             	pushl  0xc(%ebp)
f0108ed6:	68 d0 48 12 f0       	push   $0xf01248d0
f0108edb:	e8 ab 80 ff ff       	call   f0100f8b <cprintf>
f0108ee0:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0108ee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ee6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108ee9:	c1 ea 0c             	shr    $0xc,%edx
f0108eec:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108ef2:	c1 e2 02             	shl    $0x2,%edx
f0108ef5:	01 d0                	add    %edx,%eax
f0108ef7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108efd:	eb 14                	jmp    f0108f13 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0108eff:	83 ec 04             	sub    $0x4,%esp
f0108f02:	68 f8 48 12 f0       	push   $0xf01248f8
f0108f07:	6a 47                	push   $0x47
f0108f09:	68 b4 48 12 f0       	push   $0xf01248b4
f0108f0e:	e8 26 74 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108f13:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108f16:	83 ec 08             	sub    $0x8,%esp
f0108f19:	50                   	push   %eax
f0108f1a:	6a 00                	push   $0x0
f0108f1c:	e8 2d ee ff ff       	call   f0107d4e <tlb_invalidate>
f0108f21:	83 c4 10             	add    $0x10,%esp
}
f0108f24:	90                   	nop
f0108f25:	c9                   	leave  
f0108f26:	c3                   	ret    

f0108f27 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0108f27:	55                   	push   %ebp
f0108f28:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0108f2a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108f2d:	c1 e8 16             	shr    $0x16,%eax
f0108f30:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108f37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f3a:	01 d0                	add    %edx,%eax
f0108f3c:	8b 00                	mov    (%eax),%eax
f0108f3e:	83 e0 20             	and    $0x20,%eax
f0108f41:	85 c0                	test   %eax,%eax
f0108f43:	0f 95 c0             	setne  %al
f0108f46:	0f b6 c0             	movzbl %al,%eax
}
f0108f49:	5d                   	pop    %ebp
f0108f4a:	c3                   	ret    

f0108f4b <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0108f4b:	55                   	push   %ebp
f0108f4c:	89 e5                	mov    %esp,%ebp
f0108f4e:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0108f51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108f54:	c1 e8 16             	shr    $0x16,%eax
f0108f57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108f5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f61:	01 d0                	add    %edx,%eax
f0108f63:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f66:	c1 ea 16             	shr    $0x16,%edx
f0108f69:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0108f70:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f73:	01 ca                	add    %ecx,%edx
f0108f75:	8b 12                	mov    (%edx),%edx
f0108f77:	83 e2 df             	and    $0xffffffdf,%edx
f0108f7a:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108f7f:	83 ec 08             	sub    $0x8,%esp
f0108f82:	50                   	push   %eax
f0108f83:	6a 00                	push   $0x0
f0108f85:	e8 c4 ed ff ff       	call   f0107d4e <tlb_invalidate>
f0108f8a:	83 c4 10             	add    $0x10,%esp
}
f0108f8d:	90                   	nop
f0108f8e:	c9                   	leave  
f0108f8f:	c3                   	ret    

f0108f90 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0108f90:	55                   	push   %ebp
f0108f91:	89 e5                	mov    %esp,%ebp
f0108f93:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0108f96:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108f99:	c1 e8 16             	shr    $0x16,%eax
f0108f9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108fa3:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fa6:	01 d0                	add    %edx,%eax
f0108fa8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108fae:	0f 20 d8             	mov    %cr3,%eax
f0108fb1:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108fb4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108fb7:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108fba:	90                   	nop
f0108fbb:	c9                   	leave  
f0108fbc:	c3                   	ret    

f0108fbd <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0108fbd:	55                   	push   %ebp
f0108fbe:	89 e5                	mov    %esp,%ebp
f0108fc0:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("env_page_ws_list_create_element is not implemented yet");
f0108fc3:	83 ec 04             	sub    $0x4,%esp
f0108fc6:	68 70 49 12 f0       	push   $0xf0124970
f0108fcb:	6a 16                	push   $0x16
f0108fcd:	68 a8 49 12 f0       	push   $0xf01249a8
f0108fd2:	e8 62 73 ff ff       	call   f0100339 <_panic>

f0108fd7 <env_page_ws_invalidate>:
	//Your Code is Here...

}
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0108fd7:	55                   	push   %ebp
f0108fd8:	89 e5                	mov    %esp,%ebp
f0108fda:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0108fdd:	83 ec 0c             	sub    $0xc,%esp
f0108fe0:	6a 02                	push   $0x2
f0108fe2:	e8 1a 54 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0108fe7:	83 c4 10             	add    $0x10,%esp
f0108fea:	85 c0                	test   %eax,%eax
f0108fec:	0f 84 e5 03 00 00    	je     f01093d7 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0108ff2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0108ff9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109000:	8b 45 08             	mov    0x8(%ebp),%eax
f0109003:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0109009:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010900c:	e9 3b 02 00 00       	jmp    f010924c <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109011:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109014:	8b 00                	mov    (%eax),%eax
f0109016:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109019:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010901c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109021:	89 c2                	mov    %eax,%edx
f0109023:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109026:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109029:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010902c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109031:	39 c2                	cmp    %eax,%edx
f0109033:	0f 85 07 02 00 00    	jne    f0109240 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109039:	8b 45 08             	mov    0x8(%ebp),%eax
f010903c:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109042:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109045:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109048:	8b 10                	mov    (%eax),%edx
f010904a:	8b 45 08             	mov    0x8(%ebp),%eax
f010904d:	8b 40 64             	mov    0x64(%eax),%eax
f0109050:	83 ec 08             	sub    $0x8,%esp
f0109053:	52                   	push   %edx
f0109054:	50                   	push   %eax
f0109055:	e8 1a f7 ff ff       	call   f0108774 <unmap_frame>
f010905a:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010905d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109061:	75 14                	jne    f0109077 <env_page_ws_invalidate+0xa0>
f0109063:	83 ec 04             	sub    $0x4,%esp
f0109066:	68 c7 49 12 f0       	push   $0xf01249c7
f010906b:	6a 27                	push   $0x27
f010906d:	68 a8 49 12 f0       	push   $0xf01249a8
f0109072:	e8 c2 72 ff ff       	call   f0100339 <_panic>
f0109077:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010907a:	8b 40 10             	mov    0x10(%eax),%eax
f010907d:	85 c0                	test   %eax,%eax
f010907f:	74 11                	je     f0109092 <env_page_ws_invalidate+0xbb>
f0109081:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109084:	8b 40 10             	mov    0x10(%eax),%eax
f0109087:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010908a:	8b 52 14             	mov    0x14(%edx),%edx
f010908d:	89 50 14             	mov    %edx,0x14(%eax)
f0109090:	eb 0f                	jmp    f01090a1 <env_page_ws_invalidate+0xca>
f0109092:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109095:	8b 50 14             	mov    0x14(%eax),%edx
f0109098:	8b 45 08             	mov    0x8(%ebp),%eax
f010909b:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f01090a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090a4:	8b 40 14             	mov    0x14(%eax),%eax
f01090a7:	85 c0                	test   %eax,%eax
f01090a9:	74 11                	je     f01090bc <env_page_ws_invalidate+0xe5>
f01090ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090ae:	8b 40 14             	mov    0x14(%eax),%eax
f01090b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01090b4:	8b 52 10             	mov    0x10(%edx),%edx
f01090b7:	89 50 10             	mov    %edx,0x10(%eax)
f01090ba:	eb 0f                	jmp    f01090cb <env_page_ws_invalidate+0xf4>
f01090bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090bf:	8b 50 10             	mov    0x10(%eax),%edx
f01090c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01090c5:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f01090cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090ce:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01090d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090d8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01090df:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e2:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01090e8:	8d 50 ff             	lea    -0x1(%eax),%edx
f01090eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01090ee:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f01090f4:	83 ec 0c             	sub    $0xc,%esp
f01090f7:	ff 75 f0             	pushl  -0x10(%ebp)
f01090fa:	e8 27 fc ff ff       	call   f0108d26 <kfree>
f01090ff:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f0109102:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109106:	0f 84 2b 01 00 00    	je     f0109237 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010910c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109110:	75 14                	jne    f0109126 <env_page_ws_invalidate+0x14f>
f0109112:	83 ec 04             	sub    $0x4,%esp
f0109115:	68 c7 49 12 f0       	push   $0xf01249c7
f010911a:	6a 2d                	push   $0x2d
f010911c:	68 a8 49 12 f0       	push   $0xf01249a8
f0109121:	e8 13 72 ff ff       	call   f0100339 <_panic>
f0109126:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109129:	8b 40 10             	mov    0x10(%eax),%eax
f010912c:	85 c0                	test   %eax,%eax
f010912e:	74 11                	je     f0109141 <env_page_ws_invalidate+0x16a>
f0109130:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109133:	8b 40 10             	mov    0x10(%eax),%eax
f0109136:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109139:	8b 52 14             	mov    0x14(%edx),%edx
f010913c:	89 50 14             	mov    %edx,0x14(%eax)
f010913f:	eb 0f                	jmp    f0109150 <env_page_ws_invalidate+0x179>
f0109141:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109144:	8b 50 14             	mov    0x14(%eax),%edx
f0109147:	8b 45 08             	mov    0x8(%ebp),%eax
f010914a:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f0109150:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109153:	8b 40 14             	mov    0x14(%eax),%eax
f0109156:	85 c0                	test   %eax,%eax
f0109158:	74 11                	je     f010916b <env_page_ws_invalidate+0x194>
f010915a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010915d:	8b 40 14             	mov    0x14(%eax),%eax
f0109160:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109163:	8b 52 10             	mov    0x10(%edx),%edx
f0109166:	89 50 10             	mov    %edx,0x10(%eax)
f0109169:	eb 0f                	jmp    f010917a <env_page_ws_invalidate+0x1a3>
f010916b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010916e:	8b 50 10             	mov    0x10(%eax),%edx
f0109171:	8b 45 08             	mov    0x8(%ebp),%eax
f0109174:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010917a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010917d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109184:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109187:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010918e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109191:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109197:	8d 50 ff             	lea    -0x1(%eax),%edx
f010919a:	8b 45 08             	mov    0x8(%ebp),%eax
f010919d:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f01091a3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01091a7:	75 14                	jne    f01091bd <env_page_ws_invalidate+0x1e6>
f01091a9:	83 ec 04             	sub    $0x4,%esp
f01091ac:	68 e8 49 12 f0       	push   $0xf01249e8
f01091b1:	6a 2e                	push   $0x2e
f01091b3:	68 a8 49 12 f0       	push   $0xf01249a8
f01091b8:	e8 7c 71 ff ff       	call   f0100339 <_panic>
f01091bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01091c0:	8b 90 58 05 00 00    	mov    0x558(%eax),%edx
f01091c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091c9:	89 50 14             	mov    %edx,0x14(%eax)
f01091cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091cf:	8b 40 14             	mov    0x14(%eax),%eax
f01091d2:	85 c0                	test   %eax,%eax
f01091d4:	74 11                	je     f01091e7 <env_page_ws_invalidate+0x210>
f01091d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d9:	8b 80 58 05 00 00    	mov    0x558(%eax),%eax
f01091df:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01091e2:	89 50 10             	mov    %edx,0x10(%eax)
f01091e5:	eb 0c                	jmp    f01091f3 <env_page_ws_invalidate+0x21c>
f01091e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01091ea:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01091ed:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f01091f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01091f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01091f9:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f01091ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109202:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109209:	8b 45 08             	mov    0x8(%ebp),%eax
f010920c:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109212:	8d 50 01             	lea    0x1(%eax),%edx
f0109215:	8b 45 08             	mov    0x8(%ebp),%eax
f0109218:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010921e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109221:	8b 10                	mov    (%eax),%edx
f0109223:	8b 45 08             	mov    0x8(%ebp),%eax
f0109226:	8b 40 64             	mov    0x64(%eax),%eax
f0109229:	6a 00                	push   $0x0
f010922b:	6a 01                	push   $0x1
f010922d:	52                   	push   %edx
f010922e:	50                   	push   %eax
f010922f:	e8 53 fb ff ff       	call   f0108d87 <pt_set_page_permissions>
f0109234:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f0109237:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010923e:	eb 43                	jmp    f0109283 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109240:	8b 45 08             	mov    0x8(%ebp),%eax
f0109243:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f0109249:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010924c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109250:	74 08                	je     f010925a <env_page_ws_invalidate+0x283>
f0109252:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109255:	8b 40 10             	mov    0x10(%eax),%eax
f0109258:	eb 05                	jmp    f010925f <env_page_ws_invalidate+0x288>
f010925a:	b8 00 00 00 00       	mov    $0x0,%eax
f010925f:	8b 55 08             	mov    0x8(%ebp),%edx
f0109262:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f0109268:	8b 45 08             	mov    0x8(%ebp),%eax
f010926b:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f0109271:	85 c0                	test   %eax,%eax
f0109273:	0f 85 98 fd ff ff    	jne    f0109011 <env_page_ws_invalidate+0x3a>
f0109279:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010927d:	0f 85 8e fd ff ff    	jne    f0109011 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f0109283:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109287:	0f 85 a4 02 00 00    	jne    f0109531 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010928d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109294:	8b 45 08             	mov    0x8(%ebp),%eax
f0109297:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010929d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01092a0:	e9 f6 00 00 00       	jmp    f010939b <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f01092a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092a8:	8b 00                	mov    (%eax),%eax
f01092aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01092ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01092b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01092b5:	89 c2                	mov    %eax,%edx
f01092b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092ba:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01092bd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01092c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01092c5:	39 c2                	cmp    %eax,%edx
f01092c7:	0f 85 c2 00 00 00    	jne    f010938f <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f01092cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092d0:	8b 10                	mov    (%eax),%edx
f01092d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01092d5:	8b 40 64             	mov    0x64(%eax),%eax
f01092d8:	83 ec 08             	sub    $0x8,%esp
f01092db:	52                   	push   %edx
f01092dc:	50                   	push   %eax
f01092dd:	e8 92 f4 ff ff       	call   f0108774 <unmap_frame>
f01092e2:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f01092e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01092e9:	75 14                	jne    f01092ff <env_page_ws_invalidate+0x328>
f01092eb:	83 ec 04             	sub    $0x4,%esp
f01092ee:	68 c7 49 12 f0       	push   $0xf01249c7
f01092f3:	6a 3e                	push   $0x3e
f01092f5:	68 a8 49 12 f0       	push   $0xf01249a8
f01092fa:	e8 3a 70 ff ff       	call   f0100339 <_panic>
f01092ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109302:	8b 40 10             	mov    0x10(%eax),%eax
f0109305:	85 c0                	test   %eax,%eax
f0109307:	74 11                	je     f010931a <env_page_ws_invalidate+0x343>
f0109309:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010930c:	8b 40 10             	mov    0x10(%eax),%eax
f010930f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109312:	8b 52 14             	mov    0x14(%edx),%edx
f0109315:	89 50 14             	mov    %edx,0x14(%eax)
f0109318:	eb 0f                	jmp    f0109329 <env_page_ws_invalidate+0x352>
f010931a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010931d:	8b 50 14             	mov    0x14(%eax),%edx
f0109320:	8b 45 08             	mov    0x8(%ebp),%eax
f0109323:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f0109329:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010932c:	8b 40 14             	mov    0x14(%eax),%eax
f010932f:	85 c0                	test   %eax,%eax
f0109331:	74 11                	je     f0109344 <env_page_ws_invalidate+0x36d>
f0109333:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109336:	8b 40 14             	mov    0x14(%eax),%eax
f0109339:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010933c:	8b 52 10             	mov    0x10(%edx),%edx
f010933f:	89 50 10             	mov    %edx,0x10(%eax)
f0109342:	eb 0f                	jmp    f0109353 <env_page_ws_invalidate+0x37c>
f0109344:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109347:	8b 50 10             	mov    0x10(%eax),%edx
f010934a:	8b 45 08             	mov    0x8(%ebp),%eax
f010934d:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109353:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109356:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010935d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109360:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109367:	8b 45 08             	mov    0x8(%ebp),%eax
f010936a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109370:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109373:	8b 45 08             	mov    0x8(%ebp),%eax
f0109376:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

					kfree(ptr_WS_element);
f010937c:	83 ec 0c             	sub    $0xc,%esp
f010937f:	ff 75 f0             	pushl  -0x10(%ebp)
f0109382:	e8 9f f9 ff ff       	call   f0108d26 <kfree>
f0109387:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010938a:	e9 a2 01 00 00       	jmp    f0109531 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010938f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109392:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109398:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010939b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010939f:	74 08                	je     f01093a9 <env_page_ws_invalidate+0x3d2>
f01093a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093a4:	8b 40 10             	mov    0x10(%eax),%eax
f01093a7:	eb 05                	jmp    f01093ae <env_page_ws_invalidate+0x3d7>
f01093a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01093ae:	8b 55 08             	mov    0x8(%ebp),%edx
f01093b1:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f01093b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01093ba:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f01093c0:	85 c0                	test   %eax,%eax
f01093c2:	0f 85 dd fe ff ff    	jne    f01092a5 <env_page_ws_invalidate+0x2ce>
f01093c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01093cc:	0f 85 d3 fe ff ff    	jne    f01092a5 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f01093d2:	e9 5a 01 00 00       	jmp    f0109531 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f01093d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01093da:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01093e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01093e3:	e9 10 01 00 00       	jmp    f01094f8 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f01093e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01093eb:	8b 00                	mov    (%eax),%eax
f01093ed:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01093f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01093f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01093f8:	89 c2                	mov    %eax,%edx
f01093fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01093fd:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109400:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109403:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109408:	39 c2                	cmp    %eax,%edx
f010940a:	0f 85 dc 00 00 00    	jne    f01094ec <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f0109410:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109413:	8b 10                	mov    (%eax),%edx
f0109415:	8b 45 08             	mov    0x8(%ebp),%eax
f0109418:	8b 40 64             	mov    0x64(%eax),%eax
f010941b:	83 ec 08             	sub    $0x8,%esp
f010941e:	52                   	push   %edx
f010941f:	50                   	push   %eax
f0109420:	e8 4f f3 ff ff       	call   f0108774 <unmap_frame>
f0109425:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f0109428:	8b 45 08             	mov    0x8(%ebp),%eax
f010942b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0109431:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109434:	75 0f                	jne    f0109445 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f0109436:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109439:	8b 50 10             	mov    0x10(%eax),%edx
f010943c:	8b 45 08             	mov    0x8(%ebp),%eax
f010943f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f0109445:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109449:	75 14                	jne    f010945f <env_page_ws_invalidate+0x488>
f010944b:	83 ec 04             	sub    $0x4,%esp
f010944e:	68 c7 49 12 f0       	push   $0xf01249c7
f0109453:	6a 54                	push   $0x54
f0109455:	68 a8 49 12 f0       	push   $0xf01249a8
f010945a:	e8 da 6e ff ff       	call   f0100339 <_panic>
f010945f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109462:	8b 40 10             	mov    0x10(%eax),%eax
f0109465:	85 c0                	test   %eax,%eax
f0109467:	74 11                	je     f010947a <env_page_ws_invalidate+0x4a3>
f0109469:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010946c:	8b 40 10             	mov    0x10(%eax),%eax
f010946f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109472:	8b 52 14             	mov    0x14(%edx),%edx
f0109475:	89 50 14             	mov    %edx,0x14(%eax)
f0109478:	eb 0f                	jmp    f0109489 <env_page_ws_invalidate+0x4b2>
f010947a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010947d:	8b 50 14             	mov    0x14(%eax),%edx
f0109480:	8b 45 08             	mov    0x8(%ebp),%eax
f0109483:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f0109489:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010948c:	8b 40 14             	mov    0x14(%eax),%eax
f010948f:	85 c0                	test   %eax,%eax
f0109491:	74 11                	je     f01094a4 <env_page_ws_invalidate+0x4cd>
f0109493:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109496:	8b 40 14             	mov    0x14(%eax),%eax
f0109499:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010949c:	8b 52 10             	mov    0x10(%edx),%edx
f010949f:	89 50 10             	mov    %edx,0x10(%eax)
f01094a2:	eb 0f                	jmp    f01094b3 <env_page_ws_invalidate+0x4dc>
f01094a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094a7:	8b 50 10             	mov    0x10(%eax),%edx
f01094aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01094ad:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f01094b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094b6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01094bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094c0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01094c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01094ca:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01094d0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01094d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01094d6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f01094dc:	83 ec 0c             	sub    $0xc,%esp
f01094df:	ff 75 ec             	pushl  -0x14(%ebp)
f01094e2:	e8 3f f8 ff ff       	call   f0108d26 <kfree>
f01094e7:	83 c4 10             	add    $0x10,%esp

				break;
f01094ea:	eb 45                	jmp    f0109531 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f01094ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01094ef:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01094f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01094f8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01094fc:	74 08                	je     f0109506 <env_page_ws_invalidate+0x52f>
f01094fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109501:	8b 40 10             	mov    0x10(%eax),%eax
f0109504:	eb 05                	jmp    f010950b <env_page_ws_invalidate+0x534>
f0109506:	b8 00 00 00 00       	mov    $0x0,%eax
f010950b:	8b 55 08             	mov    0x8(%ebp),%edx
f010950e:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0109514:	8b 45 08             	mov    0x8(%ebp),%eax
f0109517:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010951d:	85 c0                	test   %eax,%eax
f010951f:	0f 85 c3 fe ff ff    	jne    f01093e8 <env_page_ws_invalidate+0x411>
f0109525:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109529:	0f 85 b9 fe ff ff    	jne    f01093e8 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010952f:	eb 00                	jmp    f0109531 <env_page_ws_invalidate+0x55a>
f0109531:	90                   	nop
f0109532:	c9                   	leave  
f0109533:	c3                   	ret    

f0109534 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f0109534:	55                   	push   %ebp
f0109535:	89 e5                	mov    %esp,%ebp
f0109537:	53                   	push   %ebx
f0109538:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010953b:	83 ec 0c             	sub    $0xc,%esp
f010953e:	6a 02                	push   $0x2
f0109540:	e8 bc 4e 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0109545:	83 c4 10             	add    $0x10,%esp
f0109548:	85 c0                	test   %eax,%eax
f010954a:	0f 84 fe 00 00 00    	je     f010964e <env_page_ws_print+0x11a>
	{
		int i = 0;
f0109550:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0109557:	83 ec 0c             	sub    $0xc,%esp
f010955a:	68 0b 4a 12 f0       	push   $0xf0124a0b
f010955f:	e8 27 7a ff ff       	call   f0100f8b <cprintf>
f0109564:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109567:	8b 45 08             	mov    0x8(%ebp),%eax
f010956a:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0109570:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109573:	eb 2c                	jmp    f01095a1 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109575:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109578:	8b 10                	mov    (%eax),%edx
f010957a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010957d:	8d 48 01             	lea    0x1(%eax),%ecx
f0109580:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109583:	83 ec 04             	sub    $0x4,%esp
f0109586:	52                   	push   %edx
f0109587:	50                   	push   %eax
f0109588:	68 25 4a 12 f0       	push   $0xf0124a25
f010958d:	e8 f9 79 ff ff       	call   f0100f8b <cprintf>
f0109592:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109595:	8b 45 08             	mov    0x8(%ebp),%eax
f0109598:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010959e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01095a1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01095a5:	74 08                	je     f01095af <env_page_ws_print+0x7b>
f01095a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095aa:	8b 40 10             	mov    0x10(%eax),%eax
f01095ad:	eb 05                	jmp    f01095b4 <env_page_ws_print+0x80>
f01095af:	b8 00 00 00 00       	mov    $0x0,%eax
f01095b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01095b7:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f01095bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01095c0:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f01095c6:	85 c0                	test   %eax,%eax
f01095c8:	75 ab                	jne    f0109575 <env_page_ws_print+0x41>
f01095ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01095ce:	75 a5                	jne    f0109575 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f01095d0:	83 ec 0c             	sub    $0xc,%esp
f01095d3:	68 2d 4a 12 f0       	push   $0xf0124a2d
f01095d8:	e8 ae 79 ff ff       	call   f0100f8b <cprintf>
f01095dd:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f01095e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01095e3:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f01095e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01095ec:	eb 2c                	jmp    f010961a <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f01095ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095f1:	8b 10                	mov    (%eax),%edx
f01095f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01095f6:	8d 48 01             	lea    0x1(%eax),%ecx
f01095f9:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f01095fc:	83 ec 04             	sub    $0x4,%esp
f01095ff:	52                   	push   %edx
f0109600:	50                   	push   %eax
f0109601:	68 25 4a 12 f0       	push   $0xf0124a25
f0109606:	e8 80 79 ff ff       	call   f0100f8b <cprintf>
f010960b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010960e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109611:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109617:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010961a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010961e:	74 08                	je     f0109628 <env_page_ws_print+0xf4>
f0109620:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109623:	8b 40 10             	mov    0x10(%eax),%eax
f0109626:	eb 05                	jmp    f010962d <env_page_ws_print+0xf9>
f0109628:	b8 00 00 00 00       	mov    $0x0,%eax
f010962d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109630:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f0109636:	8b 45 08             	mov    0x8(%ebp),%eax
f0109639:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010963f:	85 c0                	test   %eax,%eax
f0109641:	75 ab                	jne    f01095ee <env_page_ws_print+0xba>
f0109643:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109647:	75 a5                	jne    f01095ee <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109649:	e9 5a 01 00 00       	jmp    f01097a8 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010964e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f0109655:	83 ec 0c             	sub    $0xc,%esp
f0109658:	68 48 4a 12 f0       	push   $0xf0124a48
f010965d:	e8 29 79 ff ff       	call   f0100f8b <cprintf>
f0109662:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f0109665:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010966c:	8b 45 08             	mov    0x8(%ebp),%eax
f010966f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0109675:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109678:	e9 d1 00 00 00       	jmp    f010974e <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010967d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109680:	8b 00                	mov    (%eax),%eax
f0109682:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f0109685:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109688:	8b 40 08             	mov    0x8(%eax),%eax
f010968b:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010968e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109691:	8b 40 64             	mov    0x64(%eax),%eax
f0109694:	83 ec 08             	sub    $0x8,%esp
f0109697:	ff 75 e4             	pushl  -0x1c(%ebp)
f010969a:	50                   	push   %eax
f010969b:	e8 ab f7 ff ff       	call   f0108e4b <pt_get_page_permissions>
f01096a0:	83 c4 10             	add    $0x10,%esp
f01096a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f01096a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01096a9:	83 e0 40             	and    $0x40,%eax
f01096ac:	85 c0                	test   %eax,%eax
f01096ae:	0f 95 c0             	setne  %al
f01096b1:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f01096b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01096b7:	83 e0 20             	and    $0x20,%eax
f01096ba:	85 c0                	test   %eax,%eax
f01096bc:	0f 95 c0             	setne  %al
f01096bf:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f01096c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01096c5:	25 00 02 00 00       	and    $0x200,%eax
f01096ca:	85 c0                	test   %eax,%eax
f01096cc:	0f 95 c0             	setne  %al
f01096cf:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f01096d2:	83 ec 04             	sub    $0x4,%esp
f01096d5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01096d8:	ff 75 ec             	pushl  -0x14(%ebp)
f01096db:	68 52 4a 12 f0       	push   $0xf0124a52
f01096e0:	e8 a6 78 ff ff       	call   f0100f8b <cprintf>
f01096e5:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f01096e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01096eb:	8b 58 0c             	mov    0xc(%eax),%ebx
f01096ee:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f01096f2:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f01096f6:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f01096fa:	83 ec 08             	sub    $0x8,%esp
f01096fd:	53                   	push   %ebx
f01096fe:	ff 75 e0             	pushl  -0x20(%ebp)
f0109701:	51                   	push   %ecx
f0109702:	52                   	push   %edx
f0109703:	50                   	push   %eax
f0109704:	68 5c 4a 12 f0       	push   $0xf0124a5c
f0109709:	e8 7d 78 ff ff       	call   f0100f8b <cprintf>
f010970e:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f0109711:	8b 45 08             	mov    0x8(%ebp),%eax
f0109714:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010971a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010971d:	75 10                	jne    f010972f <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010971f:	83 ec 0c             	sub    $0xc,%esp
f0109722:	68 a3 4a 12 f0       	push   $0xf0124aa3
f0109727:	e8 5f 78 ff ff       	call   f0100f8b <cprintf>
f010972c:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010972f:	83 ec 0c             	sub    $0xc,%esp
f0109732:	68 a8 4a 12 f0       	push   $0xf0124aa8
f0109737:	e8 4f 78 ff ff       	call   f0100f8b <cprintf>
f010973c:	83 c4 10             	add    $0x10,%esp
			i++;
f010973f:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109742:	8b 45 08             	mov    0x8(%ebp),%eax
f0109745:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010974b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010974e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109752:	74 08                	je     f010975c <env_page_ws_print+0x228>
f0109754:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109757:	8b 40 10             	mov    0x10(%eax),%eax
f010975a:	eb 05                	jmp    f0109761 <env_page_ws_print+0x22d>
f010975c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109761:	8b 55 08             	mov    0x8(%ebp),%edx
f0109764:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010976a:	8b 45 08             	mov    0x8(%ebp),%eax
f010976d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109773:	85 c0                	test   %eax,%eax
f0109775:	0f 85 02 ff ff ff    	jne    f010967d <env_page_ws_print+0x149>
f010977b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010977f:	0f 85 f8 fe ff ff    	jne    f010967d <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109785:	eb 13                	jmp    f010979a <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f0109787:	83 ec 0c             	sub    $0xc,%esp
f010978a:	68 aa 4a 12 f0       	push   $0xf0124aaa
f010978f:	e8 f7 77 ff ff       	call   f0100f8b <cprintf>
f0109794:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109797:	ff 45 ec             	incl   -0x14(%ebp)
f010979a:	8b 45 08             	mov    0x8(%ebp),%eax
f010979d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01097a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01097a6:	77 df                	ja     f0109787 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f01097a8:	90                   	nop
f01097a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01097ac:	c9                   	leave  
f01097ad:	c3                   	ret    

f01097ae <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f01097ae:	55                   	push   %ebp
f01097af:	89 e5                	mov    %esp,%ebp
f01097b1:	53                   	push   %ebx
f01097b2:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f01097b5:	83 ec 0c             	sub    $0xc,%esp
f01097b8:	68 bc 4a 12 f0       	push   $0xf0124abc
f01097bd:	e8 c9 77 ff ff       	call   f0100f8b <cprintf>
f01097c2:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f01097c5:	83 ec 0c             	sub    $0xc,%esp
f01097c8:	68 f1 4a 12 f0       	push   $0xf0124af1
f01097cd:	e8 b9 77 ff ff       	call   f0100f8b <cprintf>
f01097d2:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f01097d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01097dc:	e9 16 01 00 00       	jmp    f01098f7 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f01097e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01097e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01097e7:	89 d0                	mov    %edx,%eax
f01097e9:	01 c0                	add    %eax,%eax
f01097eb:	01 d0                	add    %edx,%eax
f01097ed:	c1 e0 03             	shl    $0x3,%eax
f01097f0:	01 c8                	add    %ecx,%eax
f01097f2:	05 a4 00 00 00       	add    $0xa4,%eax
f01097f7:	8a 00                	mov    (%eax),%al
f01097f9:	84 c0                	test   %al,%al
f01097fb:	74 43                	je     f0109840 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f01097fd:	83 ec 0c             	sub    $0xc,%esp
f0109800:	68 fc 4a 12 f0       	push   $0xf0124afc
f0109805:	e8 81 77 ff ff       	call   f0100f8b <cprintf>
f010980a:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010980d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109810:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f0109816:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109819:	75 10                	jne    f010982b <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010981b:	83 ec 0c             	sub    $0xc,%esp
f010981e:	68 0b 4b 12 f0       	push   $0xf0124b0b
f0109823:	e8 63 77 ff ff       	call   f0100f8b <cprintf>
f0109828:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010982b:	83 ec 0c             	sub    $0xc,%esp
f010982e:	68 a8 4a 12 f0       	push   $0xf0124aa8
f0109833:	e8 53 77 ff ff       	call   f0100f8b <cprintf>
f0109838:	83 c4 10             	add    $0x10,%esp
			continue;
f010983b:	e9 b4 00 00 00       	jmp    f01098f4 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f0109840:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109843:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109846:	89 d0                	mov    %edx,%eax
f0109848:	01 c0                	add    %eax,%eax
f010984a:	01 d0                	add    %edx,%eax
f010984c:	c1 e0 03             	shl    $0x3,%eax
f010984f:	01 c8                	add    %ecx,%eax
f0109851:	05 a0 00 00 00       	add    $0xa0,%eax
f0109856:	8b 00                	mov    (%eax),%eax
f0109858:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010985b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010985e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109861:	89 d0                	mov    %edx,%eax
f0109863:	01 c0                	add    %eax,%eax
f0109865:	01 d0                	add    %edx,%eax
f0109867:	c1 e0 03             	shl    $0x3,%eax
f010986a:	01 c8                	add    %ecx,%eax
f010986c:	05 a0 00 00 00       	add    $0xa0,%eax
f0109871:	8b 00                	mov    (%eax),%eax
f0109873:	83 ec 04             	sub    $0x4,%esp
f0109876:	50                   	push   %eax
f0109877:	ff 75 f4             	pushl  -0xc(%ebp)
f010987a:	68 11 4b 12 f0       	push   $0xf0124b11
f010987f:	e8 07 77 ff ff       	call   f0100f8b <cprintf>
f0109884:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f0109887:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010988a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010988d:	89 d0                	mov    %edx,%eax
f010988f:	01 c0                	add    %eax,%eax
f0109891:	01 d0                	add    %edx,%eax
f0109893:	c1 e0 03             	shl    $0x3,%eax
f0109896:	01 c8                	add    %ecx,%eax
f0109898:	05 a8 00 00 00       	add    $0xa8,%eax
f010989d:	8b 18                	mov    (%eax),%ebx
f010989f:	8b 45 08             	mov    0x8(%ebp),%eax
f01098a2:	8b 40 64             	mov    0x64(%eax),%eax
f01098a5:	83 ec 08             	sub    $0x8,%esp
f01098a8:	ff 75 f0             	pushl  -0x10(%ebp)
f01098ab:	50                   	push   %eax
f01098ac:	e8 76 f6 ff ff       	call   f0108f27 <pd_is_table_used>
f01098b1:	83 c4 10             	add    $0x10,%esp
f01098b4:	83 ec 04             	sub    $0x4,%esp
f01098b7:	53                   	push   %ebx
f01098b8:	50                   	push   %eax
f01098b9:	68 28 4b 12 f0       	push   $0xf0124b28
f01098be:	e8 c8 76 ff ff       	call   f0100f8b <cprintf>
f01098c3:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f01098c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01098c9:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f01098cf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01098d2:	75 10                	jne    f01098e4 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f01098d4:	83 ec 0c             	sub    $0xc,%esp
f01098d7:	68 a3 4a 12 f0       	push   $0xf0124aa3
f01098dc:	e8 aa 76 ff ff       	call   f0100f8b <cprintf>
f01098e1:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f01098e4:	83 ec 0c             	sub    $0xc,%esp
f01098e7:	68 a8 4a 12 f0       	push   $0xf0124aa8
f01098ec:	e8 9a 76 ff ff       	call   f0100f8b <cprintf>
f01098f1:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f01098f4:	ff 45 f4             	incl   -0xc(%ebp)
f01098f7:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f01098fb:	0f 86 e0 fe ff ff    	jbe    f01097e1 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f0109901:	90                   	nop
f0109902:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109905:	c9                   	leave  
f0109906:	c3                   	ret    

f0109907 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f0109907:	55                   	push   %ebp
f0109908:	89 e5                	mov    %esp,%ebp
f010990a:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010990d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0109914:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010991b:	eb 22                	jmp    f010993f <env_table_ws_get_size+0x38>
f010991d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109920:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0109923:	89 d0                	mov    %edx,%eax
f0109925:	01 c0                	add    %eax,%eax
f0109927:	01 d0                	add    %edx,%eax
f0109929:	c1 e0 03             	shl    $0x3,%eax
f010992c:	01 c8                	add    %ecx,%eax
f010992e:	05 a4 00 00 00       	add    $0xa4,%eax
f0109933:	8a 00                	mov    (%eax),%al
f0109935:	84 c0                	test   %al,%al
f0109937:	75 03                	jne    f010993c <env_table_ws_get_size+0x35>
f0109939:	ff 45 f8             	incl   -0x8(%ebp)
f010993c:	ff 45 fc             	incl   -0x4(%ebp)
f010993f:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f0109943:	7e d8                	jle    f010991d <env_table_ws_get_size+0x16>
	return counter;
f0109945:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0109948:	c9                   	leave  
f0109949:	c3                   	ret    

f010994a <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010994a:	55                   	push   %ebp
f010994b:	89 e5                	mov    %esp,%ebp
f010994d:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0109950:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0109957:	eb 4e                	jmp    f01099a7 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109959:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010995c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010995f:	89 d0                	mov    %edx,%eax
f0109961:	01 c0                	add    %eax,%eax
f0109963:	01 d0                	add    %edx,%eax
f0109965:	c1 e0 03             	shl    $0x3,%eax
f0109968:	01 c8                	add    %ecx,%eax
f010996a:	05 a0 00 00 00       	add    $0xa0,%eax
f010996f:	8b 00                	mov    (%eax),%eax
f0109971:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109974:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109977:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010997c:	89 c2                	mov    %eax,%edx
f010997e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109981:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109984:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109987:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010998c:	39 c2                	cmp    %eax,%edx
f010998e:	75 14                	jne    f01099a4 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f0109990:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109993:	83 ec 08             	sub    $0x8,%esp
f0109996:	50                   	push   %eax
f0109997:	ff 75 08             	pushl  0x8(%ebp)
f010999a:	e8 bc 00 00 00       	call   f0109a5b <env_table_ws_clear_entry>
f010999f:	83 c4 10             	add    $0x10,%esp
			break;
f01099a2:	eb 09                	jmp    f01099ad <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f01099a4:	ff 45 f4             	incl   -0xc(%ebp)
f01099a7:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f01099ab:	7e ac                	jle    f0109959 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f01099ad:	90                   	nop
f01099ae:	c9                   	leave  
f01099af:	c3                   	ret    

f01099b0 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f01099b0:	55                   	push   %ebp
f01099b1:	89 e5                	mov    %esp,%ebp
f01099b3:	53                   	push   %ebx
f01099b4:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01099b7:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01099bb:	76 19                	jbe    f01099d6 <env_table_ws_set_entry+0x26>
f01099bd:	68 4c 4b 12 f0       	push   $0xf0124b4c
f01099c2:	68 7d 4b 12 f0       	push   $0xf0124b7d
f01099c7:	68 37 01 00 00       	push   $0x137
f01099cc:	68 a8 49 12 f0       	push   $0xf01249a8
f01099d1:	e8 63 69 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f01099d6:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01099dd:	76 19                	jbe    f01099f8 <env_table_ws_set_entry+0x48>
f01099df:	68 94 4b 12 f0       	push   $0xf0124b94
f01099e4:	68 7d 4b 12 f0       	push   $0xf0124b7d
f01099e9:	68 38 01 00 00       	push   $0x138
f01099ee:	68 a8 49 12 f0       	push   $0xf01249a8
f01099f3:	e8 41 69 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f01099f8:	8b 45 10             	mov    0x10(%ebp),%eax
f01099fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01099fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109a01:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109a06:	89 c1                	mov    %eax,%ecx
f0109a08:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109a0b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109a0e:	89 d0                	mov    %edx,%eax
f0109a10:	01 c0                	add    %eax,%eax
f0109a12:	01 d0                	add    %edx,%eax
f0109a14:	c1 e0 03             	shl    $0x3,%eax
f0109a17:	01 d8                	add    %ebx,%eax
f0109a19:	05 a0 00 00 00       	add    $0xa0,%eax
f0109a1e:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f0109a20:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109a23:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109a26:	89 d0                	mov    %edx,%eax
f0109a28:	01 c0                	add    %eax,%eax
f0109a2a:	01 d0                	add    %edx,%eax
f0109a2c:	c1 e0 03             	shl    $0x3,%eax
f0109a2f:	01 c8                	add    %ecx,%eax
f0109a31:	05 a4 00 00 00       	add    $0xa4,%eax
f0109a36:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109a39:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109a3c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109a3f:	89 d0                	mov    %edx,%eax
f0109a41:	01 c0                	add    %eax,%eax
f0109a43:	01 d0                	add    %edx,%eax
f0109a45:	c1 e0 03             	shl    $0x3,%eax
f0109a48:	01 c8                	add    %ecx,%eax
f0109a4a:	05 a8 00 00 00       	add    $0xa8,%eax
f0109a4f:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f0109a55:	90                   	nop
}
f0109a56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109a59:	c9                   	leave  
f0109a5a:	c3                   	ret    

f0109a5b <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109a5b:	55                   	push   %ebp
f0109a5c:	89 e5                	mov    %esp,%ebp
f0109a5e:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109a61:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109a65:	76 19                	jbe    f0109a80 <env_table_ws_clear_entry+0x25>
f0109a67:	68 4c 4b 12 f0       	push   $0xf0124b4c
f0109a6c:	68 7d 4b 12 f0       	push   $0xf0124b7d
f0109a71:	68 43 01 00 00       	push   $0x143
f0109a76:	68 a8 49 12 f0       	push   $0xf01249a8
f0109a7b:	e8 b9 68 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f0109a80:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109a83:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109a86:	89 d0                	mov    %edx,%eax
f0109a88:	01 c0                	add    %eax,%eax
f0109a8a:	01 d0                	add    %edx,%eax
f0109a8c:	c1 e0 03             	shl    $0x3,%eax
f0109a8f:	01 c8                	add    %ecx,%eax
f0109a91:	05 a0 00 00 00       	add    $0xa0,%eax
f0109a96:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f0109a9c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109a9f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109aa2:	89 d0                	mov    %edx,%eax
f0109aa4:	01 c0                	add    %eax,%eax
f0109aa6:	01 d0                	add    %edx,%eax
f0109aa8:	c1 e0 03             	shl    $0x3,%eax
f0109aab:	01 c8                	add    %ecx,%eax
f0109aad:	05 a4 00 00 00       	add    $0xa4,%eax
f0109ab2:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f0109ab5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109ab8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109abb:	89 d0                	mov    %edx,%eax
f0109abd:	01 c0                	add    %eax,%eax
f0109abf:	01 d0                	add    %edx,%eax
f0109ac1:	c1 e0 03             	shl    $0x3,%eax
f0109ac4:	01 c8                	add    %ecx,%eax
f0109ac6:	05 a8 00 00 00       	add    $0xa8,%eax
f0109acb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0109ad1:	90                   	nop
f0109ad2:	c9                   	leave  
f0109ad3:	c3                   	ret    

f0109ad4 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0109ad4:	55                   	push   %ebp
f0109ad5:	89 e5                	mov    %esp,%ebp
f0109ad7:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109ada:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109ade:	76 19                	jbe    f0109af9 <env_table_ws_get_virtual_address+0x25>
f0109ae0:	68 4c 4b 12 f0       	push   $0xf0124b4c
f0109ae5:	68 7d 4b 12 f0       	push   $0xf0124b7d
f0109aea:	68 4b 01 00 00       	push   $0x14b
f0109aef:	68 a8 49 12 f0       	push   $0xf01249a8
f0109af4:	e8 40 68 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0109af9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109afc:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109aff:	89 d0                	mov    %edx,%eax
f0109b01:	01 c0                	add    %eax,%eax
f0109b03:	01 d0                	add    %edx,%eax
f0109b05:	c1 e0 03             	shl    $0x3,%eax
f0109b08:	01 c8                	add    %ecx,%eax
f0109b0a:	05 a0 00 00 00       	add    $0xa0,%eax
f0109b0f:	8b 00                	mov    (%eax),%eax
f0109b11:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b17:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0109b1c:	c9                   	leave  
f0109b1d:	c3                   	ret    

f0109b1e <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0109b1e:	55                   	push   %ebp
f0109b1f:	89 e5                	mov    %esp,%ebp
f0109b21:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109b24:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109b28:	76 19                	jbe    f0109b43 <env_table_ws_get_time_stamp+0x25>
f0109b2a:	68 4c 4b 12 f0       	push   $0xf0124b4c
f0109b2f:	68 7d 4b 12 f0       	push   $0xf0124b7d
f0109b34:	68 52 01 00 00       	push   $0x152
f0109b39:	68 a8 49 12 f0       	push   $0xf01249a8
f0109b3e:	e8 f6 67 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f0109b43:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109b46:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109b49:	89 d0                	mov    %edx,%eax
f0109b4b:	01 c0                	add    %eax,%eax
f0109b4d:	01 d0                	add    %edx,%eax
f0109b4f:	c1 e0 03             	shl    $0x3,%eax
f0109b52:	01 c8                	add    %ecx,%eax
f0109b54:	05 a8 00 00 00       	add    $0xa8,%eax
f0109b59:	8b 00                	mov    (%eax),%eax
}
f0109b5b:	c9                   	leave  
f0109b5c:	c3                   	ret    

f0109b5d <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0109b5d:	55                   	push   %ebp
f0109b5e:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f0109b60:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109b63:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109b66:	89 d0                	mov    %edx,%eax
f0109b68:	01 c0                	add    %eax,%eax
f0109b6a:	01 d0                	add    %edx,%eax
f0109b6c:	c1 e0 03             	shl    $0x3,%eax
f0109b6f:	01 c8                	add    %ecx,%eax
f0109b71:	05 a4 00 00 00       	add    $0xa4,%eax
f0109b76:	8a 00                	mov    (%eax),%al
f0109b78:	0f b6 c0             	movzbl %al,%eax
}
f0109b7b:	5d                   	pop    %ebp
f0109b7c:	c3                   	ret    

f0109b7d <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f0109b7d:	55                   	push   %ebp
f0109b7e:	89 e5                	mov    %esp,%ebp
f0109b80:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109b83:	83 ec 04             	sub    $0x4,%esp
f0109b86:	68 c7 4b 12 f0       	push   $0xf0124bc7
f0109b8b:	68 62 01 00 00       	push   $0x162
f0109b90:	68 a8 49 12 f0       	push   $0xf01249a8
f0109b95:	e8 9f 67 ff ff       	call   f0100339 <_panic>

f0109b9a <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f0109b9a:	55                   	push   %ebp
f0109b9b:	89 e5                	mov    %esp,%ebp
f0109b9d:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109ba0:	83 ec 04             	sub    $0x4,%esp
f0109ba3:	68 c7 4b 12 f0       	push   $0xf0124bc7
f0109ba8:	68 67 01 00 00       	push   $0x167
f0109bad:	68 a8 49 12 f0       	push   $0xf01249a8
f0109bb2:	e8 82 67 ff ff       	call   f0100339 <_panic>

f0109bb7 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f0109bb7:	55                   	push   %ebp
f0109bb8:	89 e5                	mov    %esp,%ebp
f0109bba:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f0109bbd:	83 ec 04             	sub    $0x4,%esp
f0109bc0:	68 d8 4b 12 f0       	push   $0xf0124bd8
f0109bc5:	6a 21                	push   $0x21
f0109bc7:	68 06 4c 12 f0       	push   $0xf0124c06
f0109bcc:	e8 68 67 ff ff       	call   f0100339 <_panic>

f0109bd1 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f0109bd1:	55                   	push   %ebp
f0109bd2:	89 e5                	mov    %esp,%ebp
f0109bd4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f0109bd7:	83 ec 04             	sub    $0x4,%esp
f0109bda:	68 24 4c 12 f0       	push   $0xf0124c24
f0109bdf:	6a 34                	push   $0x34
f0109be1:	68 06 4c 12 f0       	push   $0xf0124c06
f0109be6:	e8 4e 67 ff ff       	call   f0100339 <_panic>

f0109beb <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f0109beb:	55                   	push   %ebp
f0109bec:	89 e5                	mov    %esp,%ebp
f0109bee:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f0109bf1:	83 ec 04             	sub    $0x4,%esp
f0109bf4:	68 54 4c 12 f0       	push   $0xf0124c54
f0109bf9:	6a 44                	push   $0x44
f0109bfb:	68 06 4c 12 f0       	push   $0xf0124c06
f0109c00:	e8 34 67 ff ff       	call   f0100339 <_panic>

f0109c05 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f0109c05:	55                   	push   %ebp
f0109c06:	89 e5                	mov    %esp,%ebp
f0109c08:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f0109c0b:	83 ec 04             	sub    $0x4,%esp
f0109c0e:	68 80 4c 12 f0       	push   $0xf0124c80
f0109c13:	6a 52                	push   $0x52
f0109c15:	68 06 4c 12 f0       	push   $0xf0124c06
f0109c1a:	e8 1a 67 ff ff       	call   f0100339 <_panic>

f0109c1f <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f0109c1f:	55                   	push   %ebp
f0109c20:	89 e5                	mov    %esp,%ebp
f0109c22:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f0109c25:	83 ec 04             	sub    $0x4,%esp
f0109c28:	68 b0 4c 12 f0       	push   $0xf0124cb0
f0109c2d:	6a 5c                	push   $0x5c
f0109c2f:	68 06 4c 12 f0       	push   $0xf0124c06
f0109c34:	e8 00 67 ff ff       	call   f0100339 <_panic>

f0109c39 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109c39:	55                   	push   %ebp
f0109c3a:	89 e5                	mov    %esp,%ebp
f0109c3c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f0109c3f:	83 ec 04             	sub    $0x4,%esp
f0109c42:	68 e8 4c 12 f0       	push   $0xf0124ce8
f0109c47:	6a 69                	push   $0x69
f0109c49:	68 06 4c 12 f0       	push   $0xf0124c06
f0109c4e:	e8 e6 66 ff ff       	call   f0100339 <_panic>

f0109c53 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f0109c53:	55                   	push   %ebp
f0109c54:	89 e5                	mov    %esp,%ebp
	 */

	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f0109c56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit


}
f0109c5b:	5d                   	pop    %ebp
f0109c5c:	c3                   	ret    

f0109c5d <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109c5d:	55                   	push   %ebp
f0109c5e:	89 e5                	mov    %esp,%ebp
f0109c60:	83 ec 08             	sub    $0x8,%esp
//	return;
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
f0109c63:	83 ec 04             	sub    $0x4,%esp
f0109c66:	68 20 4d 12 f0       	push   $0xf0124d20
f0109c6b:	68 a2 00 00 00       	push   $0xa2
f0109c70:	68 06 4c 12 f0       	push   $0xf0124c06
f0109c75:	e8 bf 66 ff ff       	call   f0100339 <_panic>

f0109c7a <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109c7a:	55                   	push   %ebp
f0109c7b:	89 e5                	mov    %esp,%ebp
f0109c7d:	83 ec 08             	sub    $0x8,%esp
//	return;
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
f0109c80:	83 ec 04             	sub    $0x4,%esp
f0109c83:	68 50 4d 12 f0       	push   $0xf0124d50
f0109c88:	68 b2 00 00 00       	push   $0xb2
f0109c8d:	68 06 4c 12 f0       	push   $0xf0124c06
f0109c92:	e8 a2 66 ff ff       	call   f0100339 <_panic>

f0109c97 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109c97:	55                   	push   %ebp
f0109c98:	89 e5                	mov    %esp,%ebp
f0109c9a:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f0109c9d:	83 ec 04             	sub    $0x4,%esp
f0109ca0:	68 7c 4d 12 f0       	push   $0xf0124d7c
f0109ca5:	68 be 00 00 00       	push   $0xbe
f0109caa:	68 06 4c 12 f0       	push   $0xf0124c06
f0109caf:	e8 85 66 ff ff       	call   f0100339 <_panic>

f0109cb4 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f0109cb4:	55                   	push   %ebp
f0109cb5:	89 e5                	mov    %esp,%ebp
f0109cb7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f0109cba:	83 ec 04             	sub    $0x4,%esp
f0109cbd:	68 bc 4d 12 f0       	push   $0xf0124dbc
f0109cc2:	68 c8 00 00 00       	push   $0xc8
f0109cc7:	68 06 4c 12 f0       	push   $0xf0124c06
f0109ccc:	e8 68 66 ff ff       	call   f0100339 <_panic>

f0109cd1 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f0109cd1:	55                   	push   %ebp
f0109cd2:	89 e5                	mov    %esp,%ebp
f0109cd4:	53                   	push   %ebx
f0109cd5:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f0109cd8:	c7 45 f4 cf 02 00 00 	movl   $0x2cf,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f0109cdf:	e9 70 01 00 00       	jmp    f0109e54 <env_init+0x183>
	{
		envs[iEnv].env_status = ENV_FREE;
f0109ce4:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109cea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109ced:	89 d0                	mov    %edx,%eax
f0109cef:	c1 e0 02             	shl    $0x2,%eax
f0109cf2:	01 d0                	add    %edx,%eax
f0109cf4:	01 c0                	add    %eax,%eax
f0109cf6:	01 d0                	add    %edx,%eax
f0109cf8:	c1 e0 02             	shl    $0x2,%eax
f0109cfb:	01 d0                	add    %edx,%eax
f0109cfd:	01 c0                	add    %eax,%eax
f0109cff:	01 d0                	add    %edx,%eax
f0109d01:	c1 e0 04             	shl    $0x4,%eax
f0109d04:	01 c8                	add    %ecx,%eax
f0109d06:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f0109d0d:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109d13:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109d16:	89 d0                	mov    %edx,%eax
f0109d18:	c1 e0 02             	shl    $0x2,%eax
f0109d1b:	01 d0                	add    %edx,%eax
f0109d1d:	01 c0                	add    %eax,%eax
f0109d1f:	01 d0                	add    %edx,%eax
f0109d21:	c1 e0 02             	shl    $0x2,%eax
f0109d24:	01 d0                	add    %edx,%eax
f0109d26:	01 c0                	add    %eax,%eax
f0109d28:	01 d0                	add    %edx,%eax
f0109d2a:	c1 e0 04             	shl    $0x4,%eax
f0109d2d:	01 c8                	add    %ecx,%eax
f0109d2f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f0109d36:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109d3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109d3f:	89 d0                	mov    %edx,%eax
f0109d41:	c1 e0 02             	shl    $0x2,%eax
f0109d44:	01 d0                	add    %edx,%eax
f0109d46:	01 c0                	add    %eax,%eax
f0109d48:	01 d0                	add    %edx,%eax
f0109d4a:	c1 e0 02             	shl    $0x2,%eax
f0109d4d:	01 d0                	add    %edx,%eax
f0109d4f:	01 c0                	add    %eax,%eax
f0109d51:	01 d0                	add    %edx,%eax
f0109d53:	c1 e0 04             	shl    $0x4,%eax
f0109d56:	01 c8                	add    %ecx,%eax
f0109d58:	85 c0                	test   %eax,%eax
f0109d5a:	75 14                	jne    f0109d70 <env_init+0x9f>
f0109d5c:	83 ec 04             	sub    $0x4,%esp
f0109d5f:	68 e8 4d 12 f0       	push   $0xf0124de8
f0109d64:	6a 64                	push   $0x64
f0109d66:	68 0b 4e 12 f0       	push   $0xf0124e0b
f0109d6b:	e8 c9 65 ff ff       	call   f0100339 <_panic>
f0109d70:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109d76:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109d79:	89 d0                	mov    %edx,%eax
f0109d7b:	c1 e0 02             	shl    $0x2,%eax
f0109d7e:	01 d0                	add    %edx,%eax
f0109d80:	01 c0                	add    %eax,%eax
f0109d82:	01 d0                	add    %edx,%eax
f0109d84:	c1 e0 02             	shl    $0x2,%eax
f0109d87:	01 d0                	add    %edx,%eax
f0109d89:	01 c0                	add    %eax,%eax
f0109d8b:	01 d0                	add    %edx,%eax
f0109d8d:	c1 e0 04             	shl    $0x4,%eax
f0109d90:	01 c8                	add    %ecx,%eax
f0109d92:	8b 15 b4 39 5c f0    	mov    0xf05c39b4,%edx
f0109d98:	89 50 08             	mov    %edx,0x8(%eax)
f0109d9b:	8b 40 08             	mov    0x8(%eax),%eax
f0109d9e:	85 c0                	test   %eax,%eax
f0109da0:	74 2d                	je     f0109dcf <env_init+0xfe>
f0109da2:	8b 0d b4 39 5c f0    	mov    0xf05c39b4,%ecx
f0109da8:	8b 1d b0 39 5c f0    	mov    0xf05c39b0,%ebx
f0109dae:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109db1:	89 d0                	mov    %edx,%eax
f0109db3:	c1 e0 02             	shl    $0x2,%eax
f0109db6:	01 d0                	add    %edx,%eax
f0109db8:	01 c0                	add    %eax,%eax
f0109dba:	01 d0                	add    %edx,%eax
f0109dbc:	c1 e0 02             	shl    $0x2,%eax
f0109dbf:	01 d0                	add    %edx,%eax
f0109dc1:	01 c0                	add    %eax,%eax
f0109dc3:	01 d0                	add    %edx,%eax
f0109dc5:	c1 e0 04             	shl    $0x4,%eax
f0109dc8:	01 d8                	add    %ebx,%eax
f0109dca:	89 41 0c             	mov    %eax,0xc(%ecx)
f0109dcd:	eb 27                	jmp    f0109df6 <env_init+0x125>
f0109dcf:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109dd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109dd8:	89 d0                	mov    %edx,%eax
f0109dda:	c1 e0 02             	shl    $0x2,%eax
f0109ddd:	01 d0                	add    %edx,%eax
f0109ddf:	01 c0                	add    %eax,%eax
f0109de1:	01 d0                	add    %edx,%eax
f0109de3:	c1 e0 02             	shl    $0x2,%eax
f0109de6:	01 d0                	add    %edx,%eax
f0109de8:	01 c0                	add    %eax,%eax
f0109dea:	01 d0                	add    %edx,%eax
f0109dec:	c1 e0 04             	shl    $0x4,%eax
f0109def:	01 c8                	add    %ecx,%eax
f0109df1:	a3 b8 39 5c f0       	mov    %eax,0xf05c39b8
f0109df6:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109dfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109dff:	89 d0                	mov    %edx,%eax
f0109e01:	c1 e0 02             	shl    $0x2,%eax
f0109e04:	01 d0                	add    %edx,%eax
f0109e06:	01 c0                	add    %eax,%eax
f0109e08:	01 d0                	add    %edx,%eax
f0109e0a:	c1 e0 02             	shl    $0x2,%eax
f0109e0d:	01 d0                	add    %edx,%eax
f0109e0f:	01 c0                	add    %eax,%eax
f0109e11:	01 d0                	add    %edx,%eax
f0109e13:	c1 e0 04             	shl    $0x4,%eax
f0109e16:	01 c8                	add    %ecx,%eax
f0109e18:	a3 b4 39 5c f0       	mov    %eax,0xf05c39b4
f0109e1d:	8b 0d b0 39 5c f0    	mov    0xf05c39b0,%ecx
f0109e23:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109e26:	89 d0                	mov    %edx,%eax
f0109e28:	c1 e0 02             	shl    $0x2,%eax
f0109e2b:	01 d0                	add    %edx,%eax
f0109e2d:	01 c0                	add    %eax,%eax
f0109e2f:	01 d0                	add    %edx,%eax
f0109e31:	c1 e0 02             	shl    $0x2,%eax
f0109e34:	01 d0                	add    %edx,%eax
f0109e36:	01 c0                	add    %eax,%eax
f0109e38:	01 d0                	add    %edx,%eax
f0109e3a:	c1 e0 04             	shl    $0x4,%eax
f0109e3d:	01 c8                	add    %ecx,%eax
f0109e3f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0109e46:	a1 c0 39 5c f0       	mov    0xf05c39c0,%eax
f0109e4b:	40                   	inc    %eax
f0109e4c:	a3 c0 39 5c f0       	mov    %eax,0xf05c39c0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f0109e51:	ff 4d f4             	decl   -0xc(%ebp)
f0109e54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109e58:	0f 89 86 fe ff ff    	jns    f0109ce4 <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f0109e5e:	90                   	nop
f0109e5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109e62:	c9                   	leave  
f0109e63:	c3                   	ret    

f0109e64 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f0109e64:	55                   	push   %ebp
f0109e65:	89 e5                	mov    %esp,%ebp
f0109e67:	57                   	push   %edi
f0109e68:	56                   	push   %esi
f0109e69:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f0109e6f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f0109e76:	83 ec 0c             	sub    $0xc,%esp
f0109e79:	ff 75 08             	pushl  0x8(%ebp)
f0109e7c:	e8 b0 1d 00 00       	call   f010bc31 <get_user_program_info>
f0109e81:	83 c4 10             	add    $0x10,%esp
f0109e84:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f0109e87:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0109e8b:	75 0a                	jne    f0109e97 <env_create+0x33>
	{
		return NULL;
f0109e8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0109e92:	e9 aa 09 00 00       	jmp    f010a841 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f0109e97:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109e9a:	8b 40 08             	mov    0x8(%eax),%eax
f0109e9d:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f0109ea0:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f0109ea7:	00 00 00 
	if(allocate_environment(&e) < 0)
f0109eaa:	83 ec 0c             	sub    $0xc,%esp
f0109ead:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f0109eb3:	50                   	push   %eax
f0109eb4:	e8 8e 0e 00 00       	call   f010ad47 <allocate_environment>
f0109eb9:	83 c4 10             	add    $0x10,%esp
f0109ebc:	85 c0                	test   %eax,%eax
f0109ebe:	79 0a                	jns    f0109eca <env_create+0x66>
	{
		return NULL;
f0109ec0:	b8 00 00 00 00       	mov    $0x0,%eax
f0109ec5:	e9 77 09 00 00       	jmp    f010a841 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f0109eca:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109ecd:	8b 00                	mov    (%eax),%eax
f0109ecf:	83 ec 0c             	sub    $0xc,%esp
f0109ed2:	50                   	push   %eax
f0109ed3:	e8 17 49 01 00       	call   f011e7ef <strlen>
f0109ed8:	83 c4 10             	add    $0x10,%esp
f0109edb:	83 f8 3f             	cmp    $0x3f,%eax
f0109ede:	7f 1d                	jg     f0109efd <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f0109ee0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109ee3:	8b 00                	mov    (%eax),%eax
f0109ee5:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f0109eeb:	83 c2 20             	add    $0x20,%edx
f0109eee:	83 ec 08             	sub    $0x8,%esp
f0109ef1:	50                   	push   %eax
f0109ef2:	52                   	push   %edx
f0109ef3:	e8 46 49 01 00       	call   f011e83e <strcpy>
f0109ef8:	83 c4 10             	add    $0x10,%esp
f0109efb:	eb 1d                	jmp    f0109f1a <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f0109efd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109f00:	8b 00                	mov    (%eax),%eax
f0109f02:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f0109f08:	83 c2 20             	add    $0x20,%edx
f0109f0b:	83 ec 04             	sub    $0x4,%esp
f0109f0e:	6a 3f                	push   $0x3f
f0109f10:	50                   	push   %eax
f0109f11:	52                   	push   %edx
f0109f12:	e8 55 49 01 00       	call   f011e86c <strncpy>
f0109f17:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f0109f1a:	e8 f4 13 00 00       	call   f010b313 <create_user_directory>
f0109f1f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f0109f22:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109f25:	83 ec 0c             	sub    $0xc,%esp
f0109f28:	50                   	push   %eax
f0109f29:	e8 15 ee ff ff       	call   f0108d43 <kheap_physical_address>
f0109f2e:	83 c4 10             	add    $0x10,%esp
f0109f31:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f0109f34:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109f3a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109f3d:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109f43:	83 ec 0c             	sub    $0xc,%esp
f0109f46:	6a 02                	push   $0x2
f0109f48:	e8 b4 44 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f0109f4d:	83 c4 10             	add    $0x10,%esp
f0109f50:	85 c0                	test   %eax,%eax
f0109f52:	74 21                	je     f0109f75 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f0109f54:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109f5a:	8b 55 10             	mov    0x10(%ebp),%edx
f0109f5d:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f0109f63:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109f69:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109f6c:	2b 55 10             	sub    0x10(%ebp),%edx
f0109f6f:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f0109f75:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109f79:	75 12                	jne    f0109f8d <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f0109f7b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109f81:	c7 80 80 05 00 00 0a 	movl   $0xa,0x580(%eax)
f0109f88:	00 00 00 
f0109f8b:	eb 0f                	jmp    f0109f9c <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f0109f8d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109f93:	8b 55 14             	mov    0x14(%ebp),%edx
f0109f96:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f0109f9c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109fa2:	83 ec 04             	sub    $0x4,%esp
f0109fa5:	ff 75 bc             	pushl  -0x44(%ebp)
f0109fa8:	ff 75 c0             	pushl  -0x40(%ebp)
f0109fab:	50                   	push   %eax
f0109fac:	e8 dd 13 00 00       	call   f010b38e <initialize_environment>
f0109fb1:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f0109fb4:	e8 ab d1 ff ff       	call   f0107164 <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0109fb9:	0f 20 d8             	mov    %cr3,%eax
f0109fbc:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f0109fbf:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f0109fc2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f0109fc5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109fcb:	8b 40 68             	mov    0x68(%eax),%eax
f0109fce:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0109fd4:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f0109fda:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f0109fdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f0109fe4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f0109feb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109ff1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0109ff7:	48                   	dec    %eax
f0109ff8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f0109ffb:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010a002:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a005:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010a00b:	83 ec 08             	sub    $0x8,%esp
f010a00e:	ff 75 c8             	pushl  -0x38(%ebp)
f010a011:	50                   	push   %eax
f010a012:	e8 2c 19 00 00       	call   f010b943 <PROGRAM_SEGMENT_FIRST>
f010a017:	83 c4 0c             	add    $0xc,%esp
f010a01a:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a020:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010a026:	b9 05 00 00 00       	mov    $0x5,%ecx
f010a02b:	89 c7                	mov    %eax,%edi
f010a02d:	89 d6                	mov    %edx,%esi
f010a02f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a031:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a037:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a03a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a03d:	8b 40 10             	mov    0x10(%eax),%eax
f010a040:	83 f8 ff             	cmp    $0xffffffff,%eax
f010a043:	75 07                	jne    f010a04c <env_create+0x1e8>
f010a045:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010a04c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a04f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a052:	e9 fa 02 00 00       	jmp    f010a351 <env_create+0x4ed>
		{
			segment_counter++;
f010a057:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010a05a:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010a061:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010a064:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a06a:	83 ec 0c             	sub    $0xc,%esp
f010a06d:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010a073:	52                   	push   %edx
f010a074:	ff 75 ec             	pushl  -0x14(%ebp)
f010a077:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010a07d:	52                   	push   %edx
f010a07e:	ff 75 f4             	pushl  -0xc(%ebp)
f010a081:	50                   	push   %eax
f010a082:	e8 7e 0d 00 00       	call   f010ae05 <program_segment_alloc_map_copy_workingset>
f010a087:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010a08a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a090:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010a093:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a096:	8b 00                	mov    (%eax),%eax
f010a098:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010a09b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a09e:	8b 40 0c             	mov    0xc(%eax),%eax
f010a0a1:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010a0a4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a0a7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010a0aa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010a0ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a0b2:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010a0b5:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010a0bc:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010a0bf:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a0c2:	01 d0                	add    %edx,%eax
f010a0c4:	48                   	dec    %eax
f010a0c5:	89 45 98             	mov    %eax,-0x68(%ebp)
f010a0c8:	8b 45 98             	mov    -0x68(%ebp),%eax
f010a0cb:	ba 00 00 00 00       	mov    $0x0,%edx
f010a0d0:	f7 75 9c             	divl   -0x64(%ebp)
f010a0d3:	8b 45 98             	mov    -0x68(%ebp),%eax
f010a0d6:	29 d0                	sub    %edx,%eax
f010a0d8:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010a0db:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a0de:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010a0e1:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010a0e4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010a0e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010a0ea:	8b 15 ec cb 5e f0    	mov    0xf05ecbec,%edx
f010a0f0:	8b 45 90             	mov    -0x70(%ebp),%eax
f010a0f3:	01 d0                	add    %edx,%eax
f010a0f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010a0f8:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010a0fc:	74 73                	je     f010a171 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010a0fe:	a1 ec cb 5e f0       	mov    0xf05ecbec,%eax
f010a103:	83 ec 04             	sub    $0x4,%esp
f010a106:	68 00 10 00 00       	push   $0x1000
f010a10b:	6a 00                	push   $0x0
f010a10d:	50                   	push   %eax
f010a10e:	e8 ca 48 01 00       	call   f011e9dd <memset>
f010a113:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010a116:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a119:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a11c:	eb 13                	jmp    f010a131 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010a11e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a121:	8a 10                	mov    (%eax),%dl
f010a123:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a126:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010a128:	ff 45 dc             	incl   -0x24(%ebp)
f010a12b:	ff 45 e4             	incl   -0x1c(%ebp)
f010a12e:	ff 45 e0             	incl   -0x20(%ebp)
f010a131:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a134:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010a137:	72 e5                	jb     f010a11e <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010a139:	8b 15 ec cb 5e f0    	mov    0xf05ecbec,%edx
f010a13f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a145:	83 ec 04             	sub    $0x4,%esp
f010a148:	52                   	push   %edx
f010a149:	ff 75 a0             	pushl  -0x60(%ebp)
f010a14c:	50                   	push   %eax
f010a14d:	e8 dc a0 ff ff       	call   f010422e <pf_add_env_page>
f010a152:	83 c4 10             	add    $0x10,%esp
f010a155:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a158:	75 17                	jne    f010a171 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a15a:	83 ec 04             	sub    $0x4,%esp
f010a15d:	68 28 4e 12 f0       	push   $0xf0124e28
f010a162:	68 f4 00 00 00       	push   $0xf4
f010a167:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a16c:	e8 c8 61 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010a171:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a174:	8b 50 04             	mov    0x4(%eax),%edx
f010a177:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a17a:	01 d0                	add    %edx,%eax
f010a17c:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010a17f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010a182:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a187:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010a18a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a18d:	8b 50 04             	mov    0x4(%eax),%edx
f010a190:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a193:	01 d0                	add    %edx,%eax
f010a195:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010a198:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010a19b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a19e:	eb 43                	jmp    f010a1e3 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010a1a0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010a1a3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a1a9:	83 ec 04             	sub    $0x4,%esp
f010a1ac:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a1af:	52                   	push   %edx
f010a1b0:	50                   	push   %eax
f010a1b1:	e8 78 a0 ff ff       	call   f010422e <pf_add_env_page>
f010a1b6:	83 c4 10             	add    $0x10,%esp
f010a1b9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a1bc:	75 17                	jne    f010a1d5 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a1be:	83 ec 04             	sub    $0x4,%esp
f010a1c1:	68 28 4e 12 f0       	push   $0xf0124e28
f010a1c6:	68 01 01 00 00       	push   $0x101
f010a1cb:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a1d0:	e8 64 61 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010a1d5:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010a1dc:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010a1e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a1e6:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010a1e9:	72 b5                	jb     f010a1a0 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010a1eb:	a1 ec cb 5e f0       	mov    0xf05ecbec,%eax
f010a1f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010a1f3:	83 ec 04             	sub    $0x4,%esp
f010a1f6:	68 00 10 00 00       	push   $0x1000
f010a1fb:	6a 00                	push   $0x0
f010a1fd:	ff 75 e0             	pushl  -0x20(%ebp)
f010a200:	e8 d8 47 01 00       	call   f011e9dd <memset>
f010a205:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010a208:	8b 45 88             	mov    -0x78(%ebp),%eax
f010a20b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a20e:	eb 13                	jmp    f010a223 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010a210:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a213:	8a 10                	mov    (%eax),%dl
f010a215:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a218:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010a21a:	ff 45 dc             	incl   -0x24(%ebp)
f010a21d:	ff 45 e4             	incl   -0x1c(%ebp)
f010a220:	ff 45 e0             	incl   -0x20(%ebp)
f010a223:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a226:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010a229:	72 e5                	jb     f010a210 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010a22b:	8b 15 ec cb 5e f0    	mov    0xf05ecbec,%edx
f010a231:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a237:	83 ec 04             	sub    $0x4,%esp
f010a23a:	52                   	push   %edx
f010a23b:	ff 75 88             	pushl  -0x78(%ebp)
f010a23e:	50                   	push   %eax
f010a23f:	e8 ea 9f ff ff       	call   f010422e <pf_add_env_page>
f010a244:	83 c4 10             	add    $0x10,%esp
f010a247:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a24a:	75 17                	jne    f010a263 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a24c:	83 ec 04             	sub    $0x4,%esp
f010a24f:	68 28 4e 12 f0       	push   $0xf0124e28
f010a254:	68 10 01 00 00       	push   $0x110
f010a259:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a25e:	e8 d6 60 ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010a263:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010a26a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a26d:	8b 50 04             	mov    0x4(%eax),%edx
f010a270:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a273:	01 c2                	add    %eax,%edx
f010a275:	8b 45 80             	mov    -0x80(%ebp),%eax
f010a278:	01 d0                	add    %edx,%eax
f010a27a:	48                   	dec    %eax
f010a27b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010a281:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010a287:	ba 00 00 00 00       	mov    $0x0,%edx
f010a28c:	f7 75 80             	divl   -0x80(%ebp)
f010a28f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010a295:	29 d0                	sub    %edx,%eax
f010a297:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010a29a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a29d:	8b 50 08             	mov    0x8(%eax),%edx
f010a2a0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a2a3:	01 d0                	add    %edx,%eax
f010a2a5:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010a2a8:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010a2ae:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010a2b5:	eb 41                	jmp    f010a2f8 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010a2b7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2bd:	83 ec 04             	sub    $0x4,%esp
f010a2c0:	6a 01                	push   $0x1
f010a2c2:	ff 75 d8             	pushl  -0x28(%ebp)
f010a2c5:	50                   	push   %eax
f010a2c6:	e8 35 9e ff ff       	call   f0104100 <pf_add_empty_env_page>
f010a2cb:	83 c4 10             	add    $0x10,%esp
f010a2ce:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a2d1:	75 17                	jne    f010a2ea <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a2d3:	83 ec 04             	sub    $0x4,%esp
f010a2d6:	68 28 4e 12 f0       	push   $0xf0124e28
f010a2db:	68 1d 01 00 00       	push   $0x11d
f010a2e0:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a2e5:	e8 4f 60 ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010a2ea:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010a2f1:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010a2f8:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010a2ff:	10 00 00 
f010a302:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010a308:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010a30e:	01 d0                	add    %edx,%eax
f010a310:	48                   	dec    %eax
f010a311:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010a317:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010a31d:	ba 00 00 00 00       	mov    $0x0,%edx
f010a322:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010a328:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010a32e:	29 d0                	sub    %edx,%eax
f010a330:	89 c2                	mov    %eax,%edx
f010a332:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a335:	39 c2                	cmp    %eax,%edx
f010a337:	0f 87 7a ff ff ff    	ja     f010a2b7 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a33d:	83 ec 08             	sub    $0x8,%esp
f010a340:	ff 75 c8             	pushl  -0x38(%ebp)
f010a343:	ff 75 f4             	pushl  -0xc(%ebp)
f010a346:	e8 ed 14 00 00       	call   f010b838 <PROGRAM_SEGMENT_NEXT>
f010a34b:	83 c4 10             	add    $0x10,%esp
f010a34e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a351:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a355:	0f 85 fc fc ff ff    	jne    f010a057 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a35b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a361:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a367:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a36a:	eb 77                	jmp    f010a3e3 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010a36c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a36f:	8b 00                	mov    (%eax),%eax
f010a371:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010a377:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a37d:	8b 40 64             	mov    0x64(%eax),%eax
f010a380:	83 ec 04             	sub    $0x4,%esp
f010a383:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010a389:	52                   	push   %edx
f010a38a:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010a390:	50                   	push   %eax
f010a391:	e8 ee df ff ff       	call   f0108384 <get_page_table>
f010a396:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010a399:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010a39f:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010a3a5:	c1 ea 0c             	shr    $0xc,%edx
f010a3a8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a3ae:	c1 e2 02             	shl    $0x2,%edx
f010a3b1:	01 d0                	add    %edx,%eax
f010a3b3:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010a3b9:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010a3bf:	c1 e9 0c             	shr    $0xc,%ecx
f010a3c2:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a3c8:	c1 e1 02             	shl    $0x2,%ecx
f010a3cb:	01 ca                	add    %ecx,%edx
f010a3cd:	8b 12                	mov    (%edx),%edx
f010a3cf:	83 e2 bf             	and    $0xffffffbf,%edx
f010a3d2:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a3d4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a3da:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a3e0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a3e3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a3e9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a3ed:	74 08                	je     f010a3f7 <env_create+0x593>
f010a3ef:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a3f2:	8b 52 10             	mov    0x10(%edx),%edx
f010a3f5:	eb 05                	jmp    f010a3fc <env_create+0x598>
f010a3f7:	ba 00 00 00 00       	mov    $0x0,%edx
f010a3fc:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010a402:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a408:	85 c0                	test   %eax,%eax
f010a40a:	0f 85 5c ff ff ff    	jne    f010a36c <env_create+0x508>
f010a410:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a414:	0f 85 52 ff ff ff    	jne    f010a36c <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010a41a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a41d:	8b 50 08             	mov    0x8(%eax),%edx
f010a420:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a426:	83 ec 08             	sub    $0x8,%esp
f010a429:	52                   	push   %edx
f010a42a:	50                   	push   %eax
f010a42b:	e8 c8 13 00 00       	call   f010b7f8 <set_environment_entry_point>
f010a430:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010a433:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a439:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010a440:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010a447:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010a44a:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a451:	e9 42 03 00 00       	jmp    f010a798 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010a456:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010a45d:	00 00 00 
			allocate_frame(&pp);
f010a460:	83 ec 0c             	sub    $0xc,%esp
f010a463:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010a469:	50                   	push   %eax
f010a46a:	e8 d8 dc ff ff       	call   f0108147 <allocate_frame>
f010a46f:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010a472:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010a478:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a47e:	8b 40 64             	mov    0x64(%eax),%eax
f010a481:	6a 06                	push   $0x6
f010a483:	ff 75 d0             	pushl  -0x30(%ebp)
f010a486:	52                   	push   %edx
f010a487:	50                   	push   %eax
f010a488:	e8 8b e3 ff ff       	call   f0108818 <loadtime_map_frame>
f010a48d:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010a490:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a493:	83 ec 04             	sub    $0x4,%esp
f010a496:	68 00 10 00 00       	push   $0x1000
f010a49b:	6a 00                	push   $0x0
f010a49d:	50                   	push   %eax
f010a49e:	e8 3a 45 01 00       	call   f011e9dd <memset>
f010a4a3:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010a4a6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a4ac:	83 ec 08             	sub    $0x8,%esp
f010a4af:	ff 75 d0             	pushl  -0x30(%ebp)
f010a4b2:	50                   	push   %eax
f010a4b3:	e8 05 eb ff ff       	call   f0108fbd <env_page_ws_list_create_element>
f010a4b8:	83 c4 10             	add    $0x10,%esp
f010a4bb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010a4be:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a4c2:	75 17                	jne    f010a4db <env_create+0x677>
f010a4c4:	83 ec 04             	sub    $0x4,%esp
f010a4c7:	68 70 4e 12 f0       	push   $0xf0124e70
f010a4cc:	68 5c 01 00 00       	push   $0x15c
f010a4d1:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a4d6:	e8 5e 5e ff ff       	call   f0100339 <_panic>
f010a4db:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a4e1:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010a4e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a4ea:	89 50 14             	mov    %edx,0x14(%eax)
f010a4ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a4f0:	8b 40 14             	mov    0x14(%eax),%eax
f010a4f3:	85 c0                	test   %eax,%eax
f010a4f5:	74 14                	je     f010a50b <env_create+0x6a7>
f010a4f7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a4fd:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010a503:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a506:	89 50 10             	mov    %edx,0x10(%eax)
f010a509:	eb 0f                	jmp    f010a51a <env_create+0x6b6>
f010a50b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a511:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a514:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a51a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a520:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a523:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a529:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a52c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a533:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a539:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a53f:	42                   	inc    %edx
f010a540:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010a546:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a54c:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a552:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a558:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a55e:	39 c2                	cmp    %eax,%edx
f010a560:	75 1a                	jne    f010a57c <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010a562:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a568:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a56e:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010a574:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a57a:	eb 10                	jmp    f010a58c <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010a57c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a582:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010a589:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a58c:	83 ec 0c             	sub    $0xc,%esp
f010a58f:	6a 02                	push   $0x2
f010a591:	e8 6b 3e 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f010a596:	83 c4 10             	add    $0x10,%esp
f010a599:	85 c0                	test   %eax,%eax
f010a59b:	0f 84 d3 01 00 00    	je     f010a774 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010a5a1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a5a5:	75 17                	jne    f010a5be <env_create+0x75a>
f010a5a7:	83 ec 04             	sub    $0x4,%esp
f010a5aa:	68 93 4e 12 f0       	push   $0xf0124e93
f010a5af:	68 69 01 00 00       	push   $0x169
f010a5b4:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a5b9:	e8 7b 5d ff ff       	call   f0100339 <_panic>
f010a5be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a5c1:	8b 40 10             	mov    0x10(%eax),%eax
f010a5c4:	85 c0                	test   %eax,%eax
f010a5c6:	74 11                	je     f010a5d9 <env_create+0x775>
f010a5c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a5cb:	8b 40 10             	mov    0x10(%eax),%eax
f010a5ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a5d1:	8b 52 14             	mov    0x14(%edx),%edx
f010a5d4:	89 50 14             	mov    %edx,0x14(%eax)
f010a5d7:	eb 12                	jmp    f010a5eb <env_create+0x787>
f010a5d9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a5df:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a5e2:	8b 52 14             	mov    0x14(%edx),%edx
f010a5e5:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a5eb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a5ee:	8b 40 14             	mov    0x14(%eax),%eax
f010a5f1:	85 c0                	test   %eax,%eax
f010a5f3:	74 11                	je     f010a606 <env_create+0x7a2>
f010a5f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a5f8:	8b 40 14             	mov    0x14(%eax),%eax
f010a5fb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a5fe:	8b 52 10             	mov    0x10(%edx),%edx
f010a601:	89 50 10             	mov    %edx,0x10(%eax)
f010a604:	eb 12                	jmp    f010a618 <env_create+0x7b4>
f010a606:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a60c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a60f:	8b 52 10             	mov    0x10(%edx),%edx
f010a612:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a618:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a61b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a622:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a625:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a62c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a632:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a638:	4a                   	dec    %edx
f010a639:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a63f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a645:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010a64b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a651:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a657:	39 c2                	cmp    %eax,%edx
f010a659:	0f 83 8d 00 00 00    	jae    f010a6ec <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010a65f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a663:	75 17                	jne    f010a67c <env_create+0x818>
f010a665:	83 ec 04             	sub    $0x4,%esp
f010a668:	68 e8 4d 12 f0       	push   $0xf0124de8
f010a66d:	68 6e 01 00 00       	push   $0x16e
f010a672:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a677:	e8 bd 5c ff ff       	call   f0100339 <_panic>
f010a67c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a682:	8b 90 54 05 00 00    	mov    0x554(%eax),%edx
f010a688:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a68b:	89 50 10             	mov    %edx,0x10(%eax)
f010a68e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a691:	8b 40 10             	mov    0x10(%eax),%eax
f010a694:	85 c0                	test   %eax,%eax
f010a696:	74 14                	je     f010a6ac <env_create+0x848>
f010a698:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a69e:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010a6a4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a6a7:	89 50 14             	mov    %edx,0x14(%eax)
f010a6aa:	eb 0f                	jmp    f010a6bb <env_create+0x857>
f010a6ac:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a6b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a6b5:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f010a6bb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a6c1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a6c4:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010a6ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a6cd:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a6d4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a6da:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010a6e0:	42                   	inc    %edx
f010a6e1:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a6e7:	e9 88 00 00 00       	jmp    f010a774 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010a6ec:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a6f0:	75 17                	jne    f010a709 <env_create+0x8a5>
f010a6f2:	83 ec 04             	sub    $0x4,%esp
f010a6f5:	68 e8 4d 12 f0       	push   $0xf0124de8
f010a6fa:	68 72 01 00 00       	push   $0x172
f010a6ff:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a704:	e8 30 5c ff ff       	call   f0100339 <_panic>
f010a709:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a70f:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a715:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a718:	89 50 10             	mov    %edx,0x10(%eax)
f010a71b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a71e:	8b 40 10             	mov    0x10(%eax),%eax
f010a721:	85 c0                	test   %eax,%eax
f010a723:	74 14                	je     f010a739 <env_create+0x8d5>
f010a725:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a72b:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a731:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a734:	89 50 14             	mov    %edx,0x14(%eax)
f010a737:	eb 0f                	jmp    f010a748 <env_create+0x8e4>
f010a739:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a73f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a742:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a748:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a74e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a751:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a757:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a75a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a761:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a767:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010a76d:	42                   	inc    %edx
f010a76e:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010a774:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a77a:	83 ec 04             	sub    $0x4,%esp
f010a77d:	6a 01                	push   $0x1
f010a77f:	ff 75 d0             	pushl  -0x30(%ebp)
f010a782:	50                   	push   %eax
f010a783:	e8 78 99 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010a788:	83 c4 10             	add    $0x10,%esp
f010a78b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a791:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010a798:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a79b:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010a7a1:	0f 83 af fc ff ff    	jae    f010a456 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a7a7:	83 ec 0c             	sub    $0xc,%esp
f010a7aa:	6a 02                	push   $0x2
f010a7ac:	e8 50 3c 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f010a7b1:	83 c4 10             	add    $0x10,%esp
f010a7b4:	85 c0                	test   %eax,%eax
f010a7b6:	74 72                	je     f010a82a <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010a7b8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010a7bf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7c5:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a7cb:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010a7ce:	eb 2b                	jmp    f010a7fb <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010a7d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010a7d3:	8b 10                	mov    (%eax),%edx
f010a7d5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7db:	8b 40 64             	mov    0x64(%eax),%eax
f010a7de:	6a 01                	push   $0x1
f010a7e0:	6a 00                	push   $0x0
f010a7e2:	52                   	push   %edx
f010a7e3:	50                   	push   %eax
f010a7e4:	e8 9e e5 ff ff       	call   f0108d87 <pt_set_page_permissions>
f010a7e9:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010a7ec:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7f2:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a7f8:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010a7fb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a801:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010a805:	74 08                	je     f010a80f <env_create+0x9ab>
f010a807:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010a80a:	8b 52 10             	mov    0x10(%edx),%edx
f010a80d:	eb 05                	jmp    f010a814 <env_create+0x9b0>
f010a80f:	ba 00 00 00 00       	mov    $0x0,%edx
f010a814:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a81a:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a820:	85 c0                	test   %eax,%eax
f010a822:	75 ac                	jne    f010a7d0 <env_create+0x96c>
f010a824:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010a828:	75 a6                	jne    f010a7d0 <env_create+0x96c>
f010a82a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010a82d:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010a830:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010a833:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010a836:	e8 7b c9 ff ff       	call   f01071b6 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010a83b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010a841:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a844:	5e                   	pop    %esi
f010a845:	5f                   	pop    %edi
f010a846:	5d                   	pop    %ebp
f010a847:	c3                   	ret    

f010a848 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010a848:	55                   	push   %ebp
f010a849:	89 e5                	mov    %esp,%ebp
f010a84b:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010a84e:	83 ec 0c             	sub    $0xc,%esp
f010a851:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010a856:	e8 8e 40 00 00       	call   f010e8e9 <release_spinlock>
f010a85b:	83 c4 10             	add    $0x10,%esp

	if (first)
f010a85e:	a1 60 b9 17 f0       	mov    0xf017b960,%eax
f010a863:	85 c0                	test   %eax,%eax
f010a865:	74 30                	je     f010a897 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010a867:	e8 76 00 00 00       	call   f010a8e2 <get_cpu_proc>
f010a86c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010a86f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a872:	8b 40 10             	mov    0x10(%eax),%eax
f010a875:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a878:	83 c2 20             	add    $0x20,%edx
f010a87b:	83 ec 04             	sub    $0x4,%esp
f010a87e:	50                   	push   %eax
f010a87f:	52                   	push   %edx
f010a880:	68 b1 4e 12 f0       	push   $0xf0124eb1
f010a885:	e8 01 67 ff ff       	call   f0100f8b <cprintf>
f010a88a:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010a88d:	c7 05 60 b9 17 f0 00 	movl   $0x0,0xf017b960
f010a894:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010a897:	90                   	nop
f010a898:	c9                   	leave  
f010a899:	c3                   	ret    

f010a89a <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010a89a:	55                   	push   %ebp
f010a89b:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010a89d:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010a89e:	5d                   	pop    %ebp
f010a89f:	c3                   	ret    

f010a8a0 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010a8a0:	55                   	push   %ebp
f010a8a1:	89 e5                	mov    %esp,%ebp
f010a8a3:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010a8a6:	e8 37 00 00 00       	call   f010a8e2 <get_cpu_proc>
f010a8ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010a8ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a8b2:	75 19                	jne    f010a8cd <env_exit+0x2d>
f010a8b4:	68 c7 4e 12 f0       	push   $0xf0124ec7
f010a8b9:	68 d7 4e 12 f0       	push   $0xf0124ed7
f010a8be:	68 ec 01 00 00       	push   $0x1ec
f010a8c3:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010a8c8:	e8 6c 5a ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010a8cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8d0:	8b 40 10             	mov    0x10(%eax),%eax
f010a8d3:	83 ec 0c             	sub    $0xc,%esp
f010a8d6:	50                   	push   %eax
f010a8d7:	e8 eb ae ff ff       	call   f01057c7 <sched_exit_env>
f010a8dc:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010a8df:	90                   	nop
f010a8e0:	c9                   	leave  
f010a8e1:	c3                   	ret    

f010a8e2 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010a8e2:	55                   	push   %ebp
f010a8e3:	89 e5                	mov    %esp,%ebp
f010a8e5:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010a8e8:	e8 77 c8 ff ff       	call   f0107164 <pushcli>
	c = mycpu();
f010a8ed:	e8 af c7 ff ff       	call   f01070a1 <mycpu>
f010a8f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010a8f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8f8:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a8fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010a901:	e8 b0 c8 ff ff       	call   f01071b6 <popcli>
	return p;
f010a906:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a909:	c9                   	leave  
f010a90a:	c3                   	ret    

f010a90b <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010a90b:	55                   	push   %ebp
f010a90c:	89 e5                	mov    %esp,%ebp
f010a90e:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010a911:	e8 4e c8 ff ff       	call   f0107164 <pushcli>
	c = mycpu();
f010a916:	e8 86 c7 ff ff       	call   f01070a1 <mycpu>
f010a91b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010a91e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a921:	8b 55 08             	mov    0x8(%ebp),%edx
f010a924:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010a92a:	e8 87 c8 ff ff       	call   f01071b6 <popcli>
}
f010a92f:	90                   	nop
f010a930:	c9                   	leave  
f010a931:	c3                   	ret    

f010a932 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010a932:	55                   	push   %ebp
f010a933:	89 e5                	mov    %esp,%ebp
f010a935:	53                   	push   %ebx
f010a936:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010a939:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a93d:	75 16                	jne    f010a955 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010a93f:	e8 9e ff ff ff       	call   f010a8e2 <get_cpu_proc>
f010a944:	89 c2                	mov    %eax,%edx
f010a946:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a949:	89 10                	mov    %edx,(%eax)
		return 0;
f010a94b:	b8 00 00 00 00       	mov    $0x0,%eax
f010a950:	e9 a2 00 00 00       	jmp    f010a9f7 <envid2env+0xc5>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010a955:	8b 1d b0 39 5c f0    	mov    0xf05c39b0,%ebx
f010a95b:	83 ec 0c             	sub    $0xc,%esp
f010a95e:	68 d0 02 00 00       	push   $0x2d0
f010a963:	e8 e5 23 01 00       	call   f011cd4d <nearest_pow2_ceil>
f010a968:	83 c4 10             	add    $0x10,%esp
f010a96b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a96e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a971:	21 c2                	and    %eax,%edx
f010a973:	89 d0                	mov    %edx,%eax
f010a975:	c1 e0 02             	shl    $0x2,%eax
f010a978:	01 d0                	add    %edx,%eax
f010a97a:	01 c0                	add    %eax,%eax
f010a97c:	01 d0                	add    %edx,%eax
f010a97e:	c1 e0 02             	shl    $0x2,%eax
f010a981:	01 d0                	add    %edx,%eax
f010a983:	01 c0                	add    %eax,%eax
f010a985:	01 d0                	add    %edx,%eax
f010a987:	c1 e0 04             	shl    $0x4,%eax
f010a98a:	01 d8                	add    %ebx,%eax
f010a98c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010a98f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a992:	8b 40 18             	mov    0x18(%eax),%eax
f010a995:	85 c0                	test   %eax,%eax
f010a997:	74 0b                	je     f010a9a4 <envid2env+0x72>
f010a999:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a99c:	8b 40 10             	mov    0x10(%eax),%eax
f010a99f:	3b 45 08             	cmp    0x8(%ebp),%eax
f010a9a2:	74 10                	je     f010a9b4 <envid2env+0x82>
		*env_store = 0;
f010a9a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a9ad:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a9b2:	eb 43                	jmp    f010a9f7 <envid2env+0xc5>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010a9b4:	e8 29 ff ff ff       	call   f010a8e2 <get_cpu_proc>
f010a9b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010a9bc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a9c0:	74 28                	je     f010a9ea <envid2env+0xb8>
f010a9c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9c5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010a9c8:	74 20                	je     f010a9ea <envid2env+0xb8>
f010a9ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9cd:	8b 50 14             	mov    0x14(%eax),%edx
f010a9d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a9d3:	8b 40 10             	mov    0x10(%eax),%eax
f010a9d6:	39 c2                	cmp    %eax,%edx
f010a9d8:	74 10                	je     f010a9ea <envid2env+0xb8>
		*env_store = 0;
f010a9da:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a9e3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a9e8:	eb 0d                	jmp    f010a9f7 <envid2env+0xc5>
	}

	*env_store = e;
f010a9ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a9f0:	89 10                	mov    %edx,(%eax)
	return 0;
f010a9f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a9f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a9fa:	c9                   	leave  
f010a9fb:	c3                   	ret    

f010a9fc <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010a9fc:	55                   	push   %ebp
f010a9fd:	89 e5                	mov    %esp,%ebp
f010a9ff:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010aa02:	83 ec 0c             	sub    $0xc,%esp
f010aa05:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010aa0a:	e8 53 3e 00 00       	call   f010e862 <acquire_spinlock>
f010aa0f:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010aa12:	e8 cb fe ff ff       	call   f010a8e2 <get_cpu_proc>
f010aa17:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010aa1a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010aa1e:	75 19                	jne    f010aa39 <yield+0x3d>
f010aa20:	68 ec 4e 12 f0       	push   $0xf0124eec
f010aa25:	68 d7 4e 12 f0       	push   $0xf0124ed7
f010aa2a:	68 4b 02 00 00       	push   $0x24b
f010aa2f:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010aa34:	e8 00 59 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010aa39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa3c:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010aa43:	e8 13 00 00 00       	call   f010aa5b <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010aa48:	83 ec 0c             	sub    $0xc,%esp
f010aa4b:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010aa50:	e8 94 3e 00 00       	call   f010e8e9 <release_spinlock>
f010aa55:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010aa58:	90                   	nop
f010aa59:	c9                   	leave  
f010aa5a:	c3                   	ret    

f010aa5b <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010aa5b:	55                   	push   %ebp
f010aa5c:	89 e5                	mov    %esp,%ebp
f010aa5e:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010aa61:	e8 7c fe ff ff       	call   f010a8e2 <get_cpu_proc>
f010aa66:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010aa69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010aa6d:	75 19                	jne    f010aa88 <sched+0x2d>
f010aa6f:	68 ec 4e 12 f0       	push   $0xf0124eec
f010aa74:	68 d7 4e 12 f0       	push   $0xf0124ed7
f010aa79:	68 5f 02 00 00       	push   $0x25f
f010aa7e:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010aa83:	e8 b1 58 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010aa88:	83 ec 0c             	sub    $0xc,%esp
f010aa8b:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010aa90:	e8 e6 3f 00 00       	call   f010ea7b <holding_spinlock>
f010aa95:	83 c4 10             	add    $0x10,%esp
f010aa98:	85 c0                	test   %eax,%eax
f010aa9a:	75 17                	jne    f010aab3 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010aa9c:	83 ec 04             	sub    $0x4,%esp
f010aa9f:	68 f8 4e 12 f0       	push   $0xf0124ef8
f010aaa4:	68 63 02 00 00       	push   $0x263
f010aaa9:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010aaae:	e8 86 58 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010aab3:	e8 e9 c5 ff ff       	call   f01070a1 <mycpu>
f010aab8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010aabe:	83 f8 01             	cmp    $0x1,%eax
f010aac1:	74 20                	je     f010aae3 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010aac3:	e8 d9 c5 ff ff       	call   f01070a1 <mycpu>
f010aac8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010aace:	50                   	push   %eax
f010aacf:	68 3a 4f 12 f0       	push   $0xf0124f3a
f010aad4:	68 66 02 00 00       	push   $0x266
f010aad9:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010aade:	e8 56 58 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010aae3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aae6:	8b 40 18             	mov    0x18(%eax),%eax
f010aae9:	83 f8 02             	cmp    $0x2,%eax
f010aaec:	75 17                	jne    f010ab05 <sched+0xaa>
		panic("sched a running process");
f010aaee:	83 ec 04             	sub    $0x4,%esp
f010aaf1:	68 51 4f 12 f0       	push   $0xf0124f51
f010aaf6:	68 69 02 00 00       	push   $0x269
f010aafb:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010ab00:	e8 34 58 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ab05:	9c                   	pushf  
f010ab06:	58                   	pop    %eax
f010ab07:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010ab0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010ab0d:	25 00 02 00 00       	and    $0x200,%eax
f010ab12:	85 c0                	test   %eax,%eax
f010ab14:	74 17                	je     f010ab2d <sched+0xd2>
		panic("sched is interruptible!");
f010ab16:	83 ec 04             	sub    $0x4,%esp
f010ab19:	68 69 4f 12 f0       	push   $0xf0124f69
f010ab1e:	68 6b 02 00 00       	push   $0x26b
f010ab23:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010ab28:	e8 0c 58 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010ab2d:	e8 6f c5 ff ff       	call   f01070a1 <mycpu>
f010ab32:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010ab38:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010ab3b:	e8 61 c5 ff ff       	call   f01070a1 <mycpu>
f010ab40:	8b 40 04             	mov    0x4(%eax),%eax
f010ab43:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ab46:	83 c2 04             	add    $0x4,%edx
f010ab49:	83 ec 08             	sub    $0x8,%esp
f010ab4c:	50                   	push   %eax
f010ab4d:	52                   	push   %edx
f010ab4e:	e8 bc 9f ff ff       	call   f0104b0f <context_switch>
f010ab53:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010ab56:	e8 46 c5 ff ff       	call   f01070a1 <mycpu>
f010ab5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ab5e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010ab64:	90                   	nop
f010ab65:	c9                   	leave  
f010ab66:	c3                   	ret    

f010ab67 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010ab67:	55                   	push   %ebp
f010ab68:	89 e5                	mov    %esp,%ebp
f010ab6a:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010ab6d:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f010ab72:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010ab75:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab78:	0f 22 d8             	mov    %eax,%cr3
}
f010ab7b:	90                   	nop
f010ab7c:	c9                   	leave  
f010ab7d:	c3                   	ret    

f010ab7e <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010ab7e:	55                   	push   %ebp
f010ab7f:	89 e5                	mov    %esp,%ebp
f010ab81:	53                   	push   %ebx
f010ab82:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010ab85:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ab89:	75 17                	jne    f010aba2 <switchuvm+0x24>
		panic("switchuvm: no process");
f010ab8b:	83 ec 04             	sub    $0x4,%esp
f010ab8e:	68 81 4f 12 f0       	push   $0xf0124f81
f010ab93:	68 80 02 00 00       	push   $0x280
f010ab98:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010ab9d:	e8 97 57 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010aba2:	8b 45 08             	mov    0x8(%ebp),%eax
f010aba5:	8b 40 70             	mov    0x70(%eax),%eax
f010aba8:	85 c0                	test   %eax,%eax
f010abaa:	75 17                	jne    f010abc3 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010abac:	83 ec 04             	sub    $0x4,%esp
f010abaf:	68 97 4f 12 f0       	push   $0xf0124f97
f010abb4:	68 82 02 00 00       	push   $0x282
f010abb9:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010abbe:	e8 76 57 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010abc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010abc6:	8b 40 64             	mov    0x64(%eax),%eax
f010abc9:	85 c0                	test   %eax,%eax
f010abcb:	75 17                	jne    f010abe4 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010abcd:	83 ec 04             	sub    $0x4,%esp
f010abd0:	68 ac 4f 12 f0       	push   $0xf0124fac
f010abd5:	68 84 02 00 00       	push   $0x284
f010abda:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010abdf:	e8 55 57 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010abe4:	e8 7b c5 ff ff       	call   f0107164 <pushcli>
	struct cpu* c = mycpu();
f010abe9:	e8 b3 c4 ff ff       	call   f01070a1 <mycpu>
f010abee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010abf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abf4:	8b 55 08             	mov    0x8(%ebp),%edx
f010abf7:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010abfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac00:	83 c0 0c             	add    $0xc,%eax
f010ac03:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac06:	83 c2 0c             	add    $0xc,%edx
f010ac09:	c1 ea 10             	shr    $0x10,%edx
f010ac0c:	88 d3                	mov    %dl,%bl
f010ac0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac11:	83 c2 0c             	add    $0xc,%edx
f010ac14:	c1 ea 18             	shr    $0x18,%edx
f010ac17:	88 d1                	mov    %dl,%cl
f010ac19:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac1c:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010ac23:	68 00 
f010ac25:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac28:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010ac2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac32:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010ac38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac3b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ac41:	83 e2 f0             	and    $0xfffffff0,%edx
f010ac44:	83 ca 09             	or     $0x9,%edx
f010ac47:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ac4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac50:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ac56:	83 ca 10             	or     $0x10,%edx
f010ac59:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ac5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac62:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ac68:	83 e2 9f             	and    $0xffffff9f,%edx
f010ac6b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac74:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ac7a:	83 ca 80             	or     $0xffffff80,%edx
f010ac7d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ac83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac86:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ac8c:	83 e2 f0             	and    $0xfffffff0,%edx
f010ac8f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ac95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac98:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ac9e:	83 e2 ef             	and    $0xffffffef,%edx
f010aca1:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010aca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acaa:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010acb0:	83 e2 df             	and    $0xffffffdf,%edx
f010acb3:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010acb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acbc:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010acc2:	83 ca 40             	or     $0x40,%edx
f010acc5:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010accb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acce:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010acd4:	83 e2 7f             	and    $0x7f,%edx
f010acd7:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010acdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ace0:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010ace6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ace9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010acef:	83 e2 ef             	and    $0xffffffef,%edx
f010acf2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010acf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acfb:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ad01:	8b 40 70             	mov    0x70(%eax),%eax
f010ad04:	05 00 80 00 00       	add    $0x8000,%eax
f010ad09:	89 c2                	mov    %eax,%edx
f010ad0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad0e:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010ad11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad14:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010ad1a:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010ad20:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010ad24:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010ad27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad2a:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ad30:	8b 40 68             	mov    0x68(%eax),%eax
f010ad33:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010ad36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad39:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010ad3c:	e8 75 c4 ff ff       	call   f01071b6 <popcli>
}
f010ad41:	90                   	nop
f010ad42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ad45:	c9                   	leave  
f010ad46:	c3                   	ret    

f010ad47 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010ad47:	55                   	push   %ebp
f010ad48:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010ad4a:	8b 15 b4 39 5c f0    	mov    0xf05c39b4,%edx
f010ad50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad53:	89 10                	mov    %edx,(%eax)
f010ad55:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad58:	8b 00                	mov    (%eax),%eax
f010ad5a:	85 c0                	test   %eax,%eax
f010ad5c:	75 07                	jne    f010ad65 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010ad5e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010ad63:	eb 11                	jmp    f010ad76 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010ad65:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad68:	8b 00                	mov    (%eax),%eax
f010ad6a:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010ad71:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ad76:	5d                   	pop    %ebp
f010ad77:	c3                   	ret    

f010ad78 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010ad78:	55                   	push   %ebp
f010ad79:	89 e5                	mov    %esp,%ebp
f010ad7b:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010ad7e:	83 ec 04             	sub    $0x4,%esp
f010ad81:	68 b0 05 00 00       	push   $0x5b0
f010ad86:	6a 00                	push   $0x0
f010ad88:	ff 75 08             	pushl  0x8(%ebp)
f010ad8b:	e8 4d 3c 01 00       	call   f011e9dd <memset>
f010ad90:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010ad93:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad96:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010ad9d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ada1:	75 17                	jne    f010adba <free_environment+0x42>
f010ada3:	83 ec 04             	sub    $0x4,%esp
f010ada6:	68 e8 4d 12 f0       	push   $0xf0124de8
f010adab:	68 bf 02 00 00       	push   $0x2bf
f010adb0:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010adb5:	e8 7f 55 ff ff       	call   f0100339 <_panic>
f010adba:	8b 15 b4 39 5c f0    	mov    0xf05c39b4,%edx
f010adc0:	8b 45 08             	mov    0x8(%ebp),%eax
f010adc3:	89 50 08             	mov    %edx,0x8(%eax)
f010adc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010adc9:	8b 40 08             	mov    0x8(%eax),%eax
f010adcc:	85 c0                	test   %eax,%eax
f010adce:	74 0d                	je     f010addd <free_environment+0x65>
f010add0:	a1 b4 39 5c f0       	mov    0xf05c39b4,%eax
f010add5:	8b 55 08             	mov    0x8(%ebp),%edx
f010add8:	89 50 0c             	mov    %edx,0xc(%eax)
f010addb:	eb 08                	jmp    f010ade5 <free_environment+0x6d>
f010addd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ade0:	a3 b8 39 5c f0       	mov    %eax,0xf05c39b8
f010ade5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ade8:	a3 b4 39 5c f0       	mov    %eax,0xf05c39b4
f010aded:	8b 45 08             	mov    0x8(%ebp),%eax
f010adf0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010adf7:	a1 c0 39 5c f0       	mov    0xf05c39c0,%eax
f010adfc:	40                   	inc    %eax
f010adfd:	a3 c0 39 5c f0       	mov    %eax,0xf05c39c0
}
f010ae02:	90                   	nop
f010ae03:	c9                   	leave  
f010ae04:	c3                   	ret    

f010ae05 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010ae05:	55                   	push   %ebp
f010ae06:	89 e5                	mov    %esp,%ebp
f010ae08:	53                   	push   %ebx
f010ae09:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010ae0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ae0f:	8b 40 0c             	mov    0xc(%eax),%eax
f010ae12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010ae15:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ae18:	8b 40 08             	mov    0x8(%eax),%eax
f010ae1b:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010ae1e:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010ae25:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ae28:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ae2b:	01 c2                	add    %eax,%edx
f010ae2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ae30:	01 d0                	add    %edx,%eax
f010ae32:	48                   	dec    %eax
f010ae33:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010ae36:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ae39:	ba 00 00 00 00       	mov    $0x0,%edx
f010ae3e:	f7 75 dc             	divl   -0x24(%ebp)
f010ae41:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ae44:	29 d0                	sub    %edx,%eax
f010ae46:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010ae49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ae4c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010ae4f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ae52:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ae57:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010ae5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010ae61:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010ae68:	8b 45 10             	mov    0x10(%ebp),%eax
f010ae6b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010ae71:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010ae78:	0f 85 f5 03 00 00    	jne    f010b273 <program_segment_alloc_map_copy_workingset+0x46e>
f010ae7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae81:	83 c0 20             	add    $0x20,%eax
f010ae84:	83 ec 08             	sub    $0x8,%esp
f010ae87:	68 c0 4f 12 f0       	push   $0xf0124fc0
f010ae8c:	50                   	push   %eax
f010ae8d:	e8 69 3a 01 00       	call   f011e8fb <strcmp>
f010ae92:	83 c4 10             	add    $0x10,%esp
f010ae95:	85 c0                	test   %eax,%eax
f010ae97:	0f 84 d6 03 00 00    	je     f010b273 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010ae9d:	8b 45 14             	mov    0x14(%ebp),%eax
f010aea0:	83 f8 06             	cmp    $0x6,%eax
f010aea3:	76 05                	jbe    f010aeaa <program_segment_alloc_map_copy_workingset+0xa5>
f010aea5:	b8 06 00 00 00       	mov    $0x6,%eax
f010aeaa:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010aead:	e9 c1 03 00 00       	jmp    f010b273 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010aeb2:	83 ec 0c             	sub    $0xc,%esp
f010aeb5:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010aeb8:	50                   	push   %eax
f010aeb9:	e8 89 d2 ff ff       	call   f0108147 <allocate_frame>
f010aebe:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010aec1:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010aec4:	8b 45 08             	mov    0x8(%ebp),%eax
f010aec7:	8b 40 64             	mov    0x64(%eax),%eax
f010aeca:	6a 06                	push   $0x6
f010aecc:	ff 75 f4             	pushl  -0xc(%ebp)
f010aecf:	52                   	push   %edx
f010aed0:	50                   	push   %eax
f010aed1:	e8 42 d9 ff ff       	call   f0108818 <loadtime_map_frame>
f010aed6:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010aed9:	83 ec 08             	sub    $0x8,%esp
f010aedc:	ff 75 f4             	pushl  -0xc(%ebp)
f010aedf:	ff 75 08             	pushl  0x8(%ebp)
f010aee2:	e8 d6 e0 ff ff       	call   f0108fbd <env_page_ws_list_create_element>
f010aee7:	83 c4 10             	add    $0x10,%esp
f010aeea:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010aeed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010aef0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010aef7:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010aefb:	75 17                	jne    f010af14 <program_segment_alloc_map_copy_workingset+0x10f>
f010aefd:	83 ec 04             	sub    $0x4,%esp
f010af00:	68 70 4e 12 f0       	push   $0xf0124e70
f010af05:	68 e9 02 00 00       	push   $0x2e9
f010af0a:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010af0f:	e8 25 54 ff ff       	call   f0100339 <_panic>
f010af14:	8b 45 08             	mov    0x8(%ebp),%eax
f010af17:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010af1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010af20:	89 50 14             	mov    %edx,0x14(%eax)
f010af23:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010af26:	8b 40 14             	mov    0x14(%eax),%eax
f010af29:	85 c0                	test   %eax,%eax
f010af2b:	74 11                	je     f010af3e <program_segment_alloc_map_copy_workingset+0x139>
f010af2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010af30:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010af36:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010af39:	89 50 10             	mov    %edx,0x10(%eax)
f010af3c:	eb 0c                	jmp    f010af4a <program_segment_alloc_map_copy_workingset+0x145>
f010af3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010af41:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010af44:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010af4a:	8b 45 08             	mov    0x8(%ebp),%eax
f010af4d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010af50:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010af56:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010af59:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010af60:	8b 45 08             	mov    0x8(%ebp),%eax
f010af63:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010af69:	8d 50 01             	lea    0x1(%eax),%edx
f010af6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010af6f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010af75:	83 ec 0c             	sub    $0xc,%esp
f010af78:	6a 02                	push   $0x2
f010af7a:	e8 82 34 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f010af7f:	83 c4 10             	add    $0x10,%esp
f010af82:	85 c0                	test   %eax,%eax
f010af84:	0f 84 b3 01 00 00    	je     f010b13d <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010af8a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010af8e:	75 17                	jne    f010afa7 <program_segment_alloc_map_copy_workingset+0x1a2>
f010af90:	83 ec 04             	sub    $0x4,%esp
f010af93:	68 93 4e 12 f0       	push   $0xf0124e93
f010af98:	68 f5 02 00 00       	push   $0x2f5
f010af9d:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010afa2:	e8 92 53 ff ff       	call   f0100339 <_panic>
f010afa7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010afaa:	8b 40 10             	mov    0x10(%eax),%eax
f010afad:	85 c0                	test   %eax,%eax
f010afaf:	74 11                	je     f010afc2 <program_segment_alloc_map_copy_workingset+0x1bd>
f010afb1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010afb4:	8b 40 10             	mov    0x10(%eax),%eax
f010afb7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010afba:	8b 52 14             	mov    0x14(%edx),%edx
f010afbd:	89 50 14             	mov    %edx,0x14(%eax)
f010afc0:	eb 0f                	jmp    f010afd1 <program_segment_alloc_map_copy_workingset+0x1cc>
f010afc2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010afc5:	8b 50 14             	mov    0x14(%eax),%edx
f010afc8:	8b 45 08             	mov    0x8(%ebp),%eax
f010afcb:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010afd1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010afd4:	8b 40 14             	mov    0x14(%eax),%eax
f010afd7:	85 c0                	test   %eax,%eax
f010afd9:	74 11                	je     f010afec <program_segment_alloc_map_copy_workingset+0x1e7>
f010afdb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010afde:	8b 40 14             	mov    0x14(%eax),%eax
f010afe1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010afe4:	8b 52 10             	mov    0x10(%edx),%edx
f010afe7:	89 50 10             	mov    %edx,0x10(%eax)
f010afea:	eb 0f                	jmp    f010affb <program_segment_alloc_map_copy_workingset+0x1f6>
f010afec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010afef:	8b 50 10             	mov    0x10(%eax),%edx
f010aff2:	8b 45 08             	mov    0x8(%ebp),%eax
f010aff5:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010affb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010affe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b005:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b008:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b00f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b012:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b018:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b01b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b01e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010b024:	8b 45 08             	mov    0x8(%ebp),%eax
f010b027:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b02d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b030:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010b036:	48                   	dec    %eax
f010b037:	39 c2                	cmp    %eax,%edx
f010b039:	0f 83 80 00 00 00    	jae    f010b0bf <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b03f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b043:	75 17                	jne    f010b05c <program_segment_alloc_map_copy_workingset+0x257>
f010b045:	83 ec 04             	sub    $0x4,%esp
f010b048:	68 e8 4d 12 f0       	push   $0xf0124de8
f010b04d:	68 f9 02 00 00       	push   $0x2f9
f010b052:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b057:	e8 dd 52 ff ff       	call   f0100339 <_panic>
f010b05c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b05f:	8b 90 54 05 00 00    	mov    0x554(%eax),%edx
f010b065:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b068:	89 50 10             	mov    %edx,0x10(%eax)
f010b06b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b06e:	8b 40 10             	mov    0x10(%eax),%eax
f010b071:	85 c0                	test   %eax,%eax
f010b073:	74 11                	je     f010b086 <program_segment_alloc_map_copy_workingset+0x281>
f010b075:	8b 45 08             	mov    0x8(%ebp),%eax
f010b078:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010b07e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b081:	89 50 14             	mov    %edx,0x14(%eax)
f010b084:	eb 0c                	jmp    f010b092 <program_segment_alloc_map_copy_workingset+0x28d>
f010b086:	8b 45 08             	mov    0x8(%ebp),%eax
f010b089:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b08c:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f010b092:	8b 45 08             	mov    0x8(%ebp),%eax
f010b095:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b098:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010b09e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b0a1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b0a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0ab:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b0b1:	8d 50 01             	lea    0x1(%eax),%edx
f010b0b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0b7:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b0bd:	eb 7e                	jmp    f010b13d <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b0bf:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b0c3:	75 17                	jne    f010b0dc <program_segment_alloc_map_copy_workingset+0x2d7>
f010b0c5:	83 ec 04             	sub    $0x4,%esp
f010b0c8:	68 e8 4d 12 f0       	push   $0xf0124de8
f010b0cd:	68 fe 02 00 00       	push   $0x2fe
f010b0d2:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b0d7:	e8 5d 52 ff ff       	call   f0100339 <_panic>
f010b0dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0df:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010b0e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b0e8:	89 50 10             	mov    %edx,0x10(%eax)
f010b0eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b0ee:	8b 40 10             	mov    0x10(%eax),%eax
f010b0f1:	85 c0                	test   %eax,%eax
f010b0f3:	74 11                	je     f010b106 <program_segment_alloc_map_copy_workingset+0x301>
f010b0f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0f8:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010b0fe:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b101:	89 50 14             	mov    %edx,0x14(%eax)
f010b104:	eb 0c                	jmp    f010b112 <program_segment_alloc_map_copy_workingset+0x30d>
f010b106:	8b 45 08             	mov    0x8(%ebp),%eax
f010b109:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b10c:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010b112:	8b 45 08             	mov    0x8(%ebp),%eax
f010b115:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b118:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b11e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b121:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b128:	8b 45 08             	mov    0x8(%ebp),%eax
f010b12b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b131:	8d 50 01             	lea    0x1(%eax),%edx
f010b134:	8b 45 08             	mov    0x8(%ebp),%eax
f010b137:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b13d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b140:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b146:	8b 45 08             	mov    0x8(%ebp),%eax
f010b149:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b14f:	39 c2                	cmp    %eax,%edx
f010b151:	75 14                	jne    f010b167 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b153:	8b 45 08             	mov    0x8(%ebp),%eax
f010b156:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010b15c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b15f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b165:	eb 0d                	jmp    f010b174 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010b167:	8b 45 08             	mov    0x8(%ebp),%eax
f010b16a:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010b171:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010b174:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b177:	c1 e8 16             	shr    $0x16,%eax
f010b17a:	89 c2                	mov    %eax,%edx
f010b17c:	8b 45 18             	mov    0x18(%ebp),%eax
f010b17f:	8b 00                	mov    (%eax),%eax
f010b181:	39 c2                	cmp    %eax,%edx
f010b183:	0f 84 d3 00 00 00    	je     f010b25c <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010b189:	8b 45 08             	mov    0x8(%ebp),%eax
f010b18c:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b192:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b195:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b198:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b19b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010b1a0:	89 c1                	mov    %eax,%ecx
f010b1a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b1a5:	89 d0                	mov    %edx,%eax
f010b1a7:	01 c0                	add    %eax,%eax
f010b1a9:	01 d0                	add    %edx,%eax
f010b1ab:	c1 e0 03             	shl    $0x3,%eax
f010b1ae:	01 d8                	add    %ebx,%eax
f010b1b0:	05 a0 00 00 00       	add    $0xa0,%eax
f010b1b5:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010b1b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1ba:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b1c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b1c3:	89 d0                	mov    %edx,%eax
f010b1c5:	01 c0                	add    %eax,%eax
f010b1c7:	01 d0                	add    %edx,%eax
f010b1c9:	c1 e0 03             	shl    $0x3,%eax
f010b1cc:	01 c8                	add    %ecx,%eax
f010b1ce:	05 a4 00 00 00       	add    $0xa4,%eax
f010b1d3:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010b1d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1d9:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b1df:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b1e2:	89 d0                	mov    %edx,%eax
f010b1e4:	01 c0                	add    %eax,%eax
f010b1e6:	01 d0                	add    %edx,%eax
f010b1e8:	c1 e0 03             	shl    $0x3,%eax
f010b1eb:	01 c8                	add    %ecx,%eax
f010b1ed:	05 a8 00 00 00       	add    $0xa8,%eax
f010b1f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010b1f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1fb:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b201:	8d 50 01             	lea    0x1(%eax),%edx
f010b204:	8b 45 08             	mov    0x8(%ebp),%eax
f010b207:	89 90 50 05 00 00    	mov    %edx,0x550(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010b20d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b210:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b216:	b9 32 00 00 00       	mov    $0x32,%ecx
f010b21b:	ba 00 00 00 00       	mov    $0x0,%edx
f010b220:	f7 f1                	div    %ecx
f010b222:	8b 45 08             	mov    0x8(%ebp),%eax
f010b225:	89 90 50 05 00 00    	mov    %edx,0x550(%eax)
			if (e->table_last_WS_index == 0)
f010b22b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b22e:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b234:	85 c0                	test   %eax,%eax
f010b236:	75 17                	jne    f010b24f <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b238:	83 ec 04             	sub    $0x4,%esp
f010b23b:	68 c4 4f 12 f0       	push   $0xf0124fc4
f010b240:	68 26 03 00 00       	push   $0x326
f010b245:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b24a:	e8 ea 50 ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b24f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b252:	c1 e8 16             	shr    $0x16,%eax
f010b255:	89 c2                	mov    %eax,%edx
f010b257:	8b 45 18             	mov    0x18(%ebp),%eax
f010b25a:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b25c:	8b 45 10             	mov    0x10(%ebp),%eax
f010b25f:	8b 00                	mov    (%eax),%eax
f010b261:	8d 50 01             	lea    0x1(%eax),%edx
f010b264:	8b 45 10             	mov    0x10(%ebp),%eax
f010b267:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b269:	ff 45 f0             	incl   -0x10(%ebp)
f010b26c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b276:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b279:	73 0c                	jae    f010b287 <program_segment_alloc_map_copy_workingset+0x482>
f010b27b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b27e:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b281:	0f 82 2b fc ff ff    	jb     f010aeb2 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b287:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b28a:	8b 00                	mov    (%eax),%eax
f010b28c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b28f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b292:	8b 40 0c             	mov    0xc(%eax),%eax
f010b295:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b298:	eb 10                	jmp    f010b2aa <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b29a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b29d:	8a 10                	mov    (%eax),%dl
f010b29f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b2a2:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b2a4:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b2a7:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b2aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b2b0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b2b3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b2b8:	89 c2                	mov    %eax,%edx
f010b2ba:	8b 45 10             	mov    0x10(%ebp),%eax
f010b2bd:	8b 00                	mov    (%eax),%eax
f010b2bf:	c1 e0 0c             	shl    $0xc,%eax
f010b2c2:	01 c2                	add    %eax,%edx
f010b2c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b2c7:	39 c2                	cmp    %eax,%edx
f010b2c9:	76 1d                	jbe    f010b2e8 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b2cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b2ce:	8b 50 04             	mov    0x4(%eax),%edx
f010b2d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2d4:	01 c2                	add    %eax,%edx
f010b2d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b2d9:	39 c2                	cmp    %eax,%edx
f010b2db:	77 bd                	ja     f010b29a <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b2dd:	eb 09                	jmp    f010b2e8 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010b2df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b2e2:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b2e5:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b2e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2eb:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010b2ee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b2f1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b2f6:	89 c2                	mov    %eax,%edx
f010b2f8:	8b 45 10             	mov    0x10(%ebp),%eax
f010b2fb:	8b 00                	mov    (%eax),%eax
f010b2fd:	c1 e0 0c             	shl    $0xc,%eax
f010b300:	01 c2                	add    %eax,%edx
f010b302:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b305:	39 c2                	cmp    %eax,%edx
f010b307:	77 d6                	ja     f010b2df <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b309:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b30e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b311:	c9                   	leave  
f010b312:	c3                   	ret    

f010b313 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b313:	55                   	push   %ebp
f010b314:	89 e5                	mov    %esp,%ebp
f010b316:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b319:	83 ec 0c             	sub    $0xc,%esp
f010b31c:	68 00 10 00 00       	push   $0x1000
f010b321:	e8 e6 d9 ff ff       	call   f0108d0c <kmalloc>
f010b326:	83 c4 10             	add    $0x10,%esp
f010b329:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b32c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b330:	75 17                	jne    f010b349 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b332:	83 ec 04             	sub    $0x4,%esp
f010b335:	68 67 50 12 f0       	push   $0xf0125067
f010b33a:	68 56 03 00 00       	push   $0x356
f010b33f:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b344:	e8 f0 4f ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010b349:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b34c:	c9                   	leave  
f010b34d:	c3                   	ret    

f010b34e <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b34e:	55                   	push   %ebp
f010b34f:	89 e5                	mov    %esp,%ebp
f010b351:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - create_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("create_user_kern_stack() is not implemented yet...!!");
f010b354:	83 ec 04             	sub    $0x4,%esp
f010b357:	68 84 50 12 f0       	push   $0xf0125084
f010b35c:	68 66 03 00 00       	push   $0x366
f010b361:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b366:	e8 ce 4f ff ff       	call   f0100339 <_panic>

f010b36b <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b36b:	55                   	push   %ebp
f010b36c:	89 e5                	mov    %esp,%ebp
f010b36e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010b371:	83 ec 04             	sub    $0x4,%esp
f010b374:	68 bc 50 12 f0       	push   $0xf01250bc
f010b379:	68 81 03 00 00       	push   $0x381
f010b37e:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b383:	e8 b1 4f ff ff       	call   f0100339 <_panic>

f010b388 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b388:	55                   	push   %ebp
f010b389:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b38b:	90                   	nop
f010b38c:	5d                   	pop    %ebp
f010b38d:	c3                   	ret    

f010b38e <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b38e:	55                   	push   %ebp
f010b38f:	89 e5                	mov    %esp,%ebp
f010b391:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b394:	8b 45 08             	mov    0x8(%ebp),%eax
f010b397:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b39a:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b39d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3a0:	8b 55 10             	mov    0x10(%ebp),%edx
f010b3a3:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b3a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b3ad:	eb 17                	jmp    f010b3c6 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010b3af:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3b2:	8b 40 64             	mov    0x64(%eax),%eax
f010b3b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b3b8:	c1 e2 02             	shl    $0x2,%edx
f010b3bb:	01 d0                	add    %edx,%eax
f010b3bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b3c3:	ff 45 f4             	incl   -0xc(%ebp)
f010b3c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3c9:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b3ce:	76 df                	jbe    f010b3af <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b3d0:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b3d7:	eb 22                	jmp    f010b3fb <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b3d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3dc:	8b 40 64             	mov    0x64(%eax),%eax
f010b3df:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b3e2:	c1 e2 02             	shl    $0x2,%edx
f010b3e5:	01 c2                	add    %eax,%edx
f010b3e7:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f010b3ec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b3ef:	c1 e1 02             	shl    $0x2,%ecx
f010b3f2:	01 c8                	add    %ecx,%eax
f010b3f4:	8b 00                	mov    (%eax),%eax
f010b3f6:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b3f8:	ff 45 f4             	incl   -0xc(%ebp)
f010b3fb:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b402:	7e d5                	jle    f010b3d9 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b404:	8b 45 08             	mov    0x8(%ebp),%eax
f010b407:	8b 40 64             	mov    0x64(%eax),%eax
f010b40a:	83 ec 0c             	sub    $0xc,%esp
f010b40d:	50                   	push   %eax
f010b40e:	e8 3b ff ff ff       	call   f010b34e <create_user_kern_stack>
f010b413:	83 c4 10             	add    $0x10,%esp
f010b416:	89 c2                	mov    %eax,%edx
f010b418:	8b 45 08             	mov    0x8(%ebp),%eax
f010b41b:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b41e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b421:	8b 40 70             	mov    0x70(%eax),%eax
f010b424:	05 00 80 00 00       	add    $0x8000,%eax
f010b429:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010b42c:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b430:	8b 45 08             	mov    0x8(%ebp),%eax
f010b433:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b436:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b438:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b43c:	ba 5e d4 10 f0       	mov    $0xf010d45e,%edx
f010b441:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b444:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b446:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010b44a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b44d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b450:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b453:	8b 45 08             	mov    0x8(%ebp),%eax
f010b456:	8b 40 04             	mov    0x4(%eax),%eax
f010b459:	83 ec 04             	sub    $0x4,%esp
f010b45c:	6a 20                	push   $0x20
f010b45e:	6a 00                	push   $0x0
f010b460:	50                   	push   %eax
f010b461:	e8 77 35 01 00       	call   f011e9dd <memset>
f010b466:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b469:	8b 45 08             	mov    0x8(%ebp),%eax
f010b46c:	8b 40 04             	mov    0x4(%eax),%eax
f010b46f:	ba 48 a8 10 f0       	mov    $0xf010a848,%edx
f010b474:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010b477:	8b 45 08             	mov    0x8(%ebp),%eax
f010b47a:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010b481:	00 00 00 
f010b484:	8b 45 08             	mov    0x8(%ebp),%eax
f010b487:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010b48e:	00 00 00 
f010b491:	8b 45 08             	mov    0x8(%ebp),%eax
f010b494:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010b49b:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b49e:	83 ec 0c             	sub    $0xc,%esp
f010b4a1:	6a 02                	push   $0x2
f010b4a3:	e8 59 2f 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f010b4a8:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b4ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b4b2:	eb 54                	jmp    f010b508 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b4b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4ba:	89 d0                	mov    %edx,%eax
f010b4bc:	01 c0                	add    %eax,%eax
f010b4be:	01 d0                	add    %edx,%eax
f010b4c0:	c1 e0 03             	shl    $0x3,%eax
f010b4c3:	01 c8                	add    %ecx,%eax
f010b4c5:	05 a0 00 00 00       	add    $0xa0,%eax
f010b4ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b4d0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4d6:	89 d0                	mov    %edx,%eax
f010b4d8:	01 c0                	add    %eax,%eax
f010b4da:	01 d0                	add    %edx,%eax
f010b4dc:	c1 e0 03             	shl    $0x3,%eax
f010b4df:	01 c8                	add    %ecx,%eax
f010b4e1:	05 a4 00 00 00       	add    $0xa4,%eax
f010b4e6:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b4e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4ef:	89 d0                	mov    %edx,%eax
f010b4f1:	01 c0                	add    %eax,%eax
f010b4f3:	01 d0                	add    %edx,%eax
f010b4f5:	c1 e0 03             	shl    $0x3,%eax
f010b4f8:	01 c8                	add    %ecx,%eax
f010b4fa:	05 a8 00 00 00       	add    $0xa8,%eax
f010b4ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b505:	ff 45 f4             	incl   -0xc(%ebp)
f010b508:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b50c:	7e a6                	jle    f010b4b4 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b50e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b511:	c7 80 50 05 00 00 00 	movl   $0x0,0x550(%eax)
f010b518:	00 00 00 

	e->pageFaultsCounter=0;
f010b51b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b51e:	c7 80 84 05 00 00 00 	movl   $0x0,0x584(%eax)
f010b525:	00 00 00 
	e->tableFaultsCounter=0;
f010b528:	8b 45 08             	mov    0x8(%ebp),%eax
f010b52b:	c7 80 88 05 00 00 00 	movl   $0x0,0x588(%eax)
f010b532:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b535:	8b 45 08             	mov    0x8(%ebp),%eax
f010b538:	c7 80 8c 05 00 00 00 	movl   $0x0,0x58c(%eax)
f010b53f:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b542:	8b 45 08             	mov    0x8(%ebp),%eax
f010b545:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010b54c:	00 00 00 

	e->nModifiedPages=0;
f010b54f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b552:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010b559:	00 00 00 
	e->nNotModifiedPages=0;
f010b55c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b55f:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010b566:	00 00 00 
	e->nClocks = 0;
f010b569:	8b 45 08             	mov    0x8(%ebp),%eax
f010b56c:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010b573:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b576:	8b 45 08             	mov    0x8(%ebp),%eax
f010b579:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010b580:	00 00 00 
	e->nPageOut = 0;
f010b583:	8b 45 08             	mov    0x8(%ebp),%eax
f010b586:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010b58d:	00 00 00 
	e->nNewPageAdded = 0;
f010b590:	8b 45 08             	mov    0x8(%ebp),%eax
f010b593:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010b59a:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b59d:	83 ec 04             	sub    $0x4,%esp
f010b5a0:	68 00 00 00 82       	push   $0x82000000
f010b5a5:	68 00 00 00 80       	push   $0x80000000
f010b5aa:	ff 75 08             	pushl  0x8(%ebp)
f010b5ad:	e8 d6 fd ff ff       	call   f010b388 <initialize_uheap_dynamic_allocator>
f010b5b2:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b5b5:	83 ec 0c             	sub    $0xc,%esp
f010b5b8:	ff 75 08             	pushl  0x8(%ebp)
f010b5bb:	e8 06 00 00 00       	call   f010b5c6 <complete_environment_initialization>
f010b5c0:	83 c4 10             	add    $0x10,%esp
}
f010b5c3:	90                   	nop
f010b5c4:	c9                   	leave  
f010b5c5:	c3                   	ret    

f010b5c6 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b5c6:	55                   	push   %ebp
f010b5c7:	89 e5                	mov    %esp,%ebp
f010b5c9:	53                   	push   %ebx
f010b5ca:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b5cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5d0:	8b 40 64             	mov    0x64(%eax),%eax
f010b5d3:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b5d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5dc:	8b 40 68             	mov    0x68(%eax),%eax
f010b5df:	83 c8 03             	or     $0x3,%eax
f010b5e2:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b5e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5e7:	8b 40 64             	mov    0x64(%eax),%eax
f010b5ea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b5f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5f3:	8b 40 68             	mov    0x68(%eax),%eax
f010b5f6:	83 c8 05             	or     $0x5,%eax
f010b5f9:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b5fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5fe:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b605:	8b 45 08             	mov    0x8(%ebp),%eax
f010b608:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b60f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b612:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b619:	8b 45 08             	mov    0x8(%ebp),%eax
f010b61c:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b623:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b626:	8b 45 08             	mov    0x8(%ebp),%eax
f010b629:	8b 58 10             	mov    0x10(%eax),%ebx
f010b62c:	83 ec 0c             	sub    $0xc,%esp
f010b62f:	68 d0 02 00 00       	push   $0x2d0
f010b634:	e8 49 17 01 00       	call   f011cd82 <log2_ceil>
f010b639:	83 c4 10             	add    $0x10,%esp
f010b63c:	ba 01 00 00 00       	mov    $0x1,%edx
f010b641:	88 c1                	mov    %al,%cl
f010b643:	d3 e2                	shl    %cl,%edx
f010b645:	89 d0                	mov    %edx,%eax
f010b647:	01 d8                	add    %ebx,%eax
f010b649:	89 c3                	mov    %eax,%ebx
f010b64b:	83 ec 0c             	sub    $0xc,%esp
f010b64e:	68 d0 02 00 00       	push   $0x2d0
f010b653:	e8 f5 16 01 00       	call   f011cd4d <nearest_pow2_ceil>
f010b658:	83 c4 10             	add    $0x10,%esp
f010b65b:	f7 d8                	neg    %eax
f010b65d:	21 d8                	and    %ebx,%eax
f010b65f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b662:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b666:	7f 1e                	jg     f010b686 <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010b668:	83 ec 0c             	sub    $0xc,%esp
f010b66b:	68 d0 02 00 00       	push   $0x2d0
f010b670:	e8 0d 17 01 00       	call   f011cd82 <log2_ceil>
f010b675:	83 c4 10             	add    $0x10,%esp
f010b678:	ba 01 00 00 00       	mov    $0x1,%edx
f010b67d:	88 c1                	mov    %al,%cl
f010b67f:	d3 e2                	shl    %cl,%edx
f010b681:	89 d0                	mov    %edx,%eax
f010b683:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b686:	8b 45 08             	mov    0x8(%ebp),%eax
f010b689:	8b 15 b0 39 5c f0    	mov    0xf05c39b0,%edx
f010b68f:	29 d0                	sub    %edx,%eax
f010b691:	c1 f8 04             	sar    $0x4,%eax
f010b694:	89 c2                	mov    %eax,%edx
f010b696:	89 d0                	mov    %edx,%eax
f010b698:	c1 e0 09             	shl    $0x9,%eax
f010b69b:	29 d0                	sub    %edx,%eax
f010b69d:	c1 e0 03             	shl    $0x3,%eax
f010b6a0:	01 d0                	add    %edx,%eax
f010b6a2:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b6a9:	01 c8                	add    %ecx,%eax
f010b6ab:	c1 e0 03             	shl    $0x3,%eax
f010b6ae:	01 d0                	add    %edx,%eax
f010b6b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b6b7:	01 d0                	add    %edx,%eax
f010b6b9:	89 c2                	mov    %eax,%edx
f010b6bb:	c1 e2 09             	shl    $0x9,%edx
f010b6be:	01 d0                	add    %edx,%eax
f010b6c0:	f7 d8                	neg    %eax
f010b6c2:	0b 45 f4             	or     -0xc(%ebp),%eax
f010b6c5:	89 c2                	mov    %eax,%edx
f010b6c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6ca:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010b6cd:	e8 10 f2 ff ff       	call   f010a8e2 <get_cpu_proc>
f010b6d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010b6d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010b6d9:	75 0c                	jne    f010b6e7 <complete_environment_initialization+0x121>
		e->env_parent_id = 0;//no parent;
f010b6db:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6de:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b6e5:	eb 0c                	jmp    f010b6f3 <complete_environment_initialization+0x12d>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010b6e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b6ea:	8b 50 10             	mov    0x10(%eax),%edx
f010b6ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6f0:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010b6f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6f6:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010b6fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b700:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010b707:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010b70a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b70d:	8b 00                	mov    (%eax),%eax
f010b70f:	83 ec 04             	sub    $0x4,%esp
f010b712:	6a 44                	push   $0x44
f010b714:	6a 00                	push   $0x0
f010b716:	50                   	push   %eax
f010b717:	e8 c1 32 01 00       	call   f011e9dd <memset>
f010b71c:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010b71f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b722:	8b 00                	mov    (%eax),%eax
f010b724:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010b72a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b72d:	8b 00                	mov    (%eax),%eax
f010b72f:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010b735:	8b 45 08             	mov    0x8(%ebp),%eax
f010b738:	8b 00                	mov    (%eax),%eax
f010b73a:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010b740:	8b 45 08             	mov    0x8(%ebp),%eax
f010b743:	8b 00                	mov    (%eax),%eax
f010b745:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010b74c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b74f:	8b 00                	mov    (%eax),%eax
f010b751:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010b757:	8b 45 08             	mov    0x8(%ebp),%eax
f010b75a:	8b 00                	mov    (%eax),%eax
f010b75c:	8b 55 08             	mov    0x8(%ebp),%edx
f010b75f:	8b 12                	mov    (%edx),%edx
f010b761:	8b 52 38             	mov    0x38(%edx),%edx
f010b764:	80 ce 02             	or     $0x2,%dh
f010b767:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010b76a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b76e:	75 17                	jne    f010b787 <complete_environment_initialization+0x1c1>
f010b770:	83 ec 04             	sub    $0x4,%esp
f010b773:	68 93 4e 12 f0       	push   $0xf0124e93
f010b778:	68 55 04 00 00       	push   $0x455
f010b77d:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b782:	e8 b2 4b ff ff       	call   f0100339 <_panic>
f010b787:	8b 45 08             	mov    0x8(%ebp),%eax
f010b78a:	8b 40 08             	mov    0x8(%eax),%eax
f010b78d:	85 c0                	test   %eax,%eax
f010b78f:	74 11                	je     f010b7a2 <complete_environment_initialization+0x1dc>
f010b791:	8b 45 08             	mov    0x8(%ebp),%eax
f010b794:	8b 40 08             	mov    0x8(%eax),%eax
f010b797:	8b 55 08             	mov    0x8(%ebp),%edx
f010b79a:	8b 52 0c             	mov    0xc(%edx),%edx
f010b79d:	89 50 0c             	mov    %edx,0xc(%eax)
f010b7a0:	eb 0b                	jmp    f010b7ad <complete_environment_initialization+0x1e7>
f010b7a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7a5:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7a8:	a3 b8 39 5c f0       	mov    %eax,0xf05c39b8
f010b7ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7b0:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7b3:	85 c0                	test   %eax,%eax
f010b7b5:	74 11                	je     f010b7c8 <complete_environment_initialization+0x202>
f010b7b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7ba:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7bd:	8b 55 08             	mov    0x8(%ebp),%edx
f010b7c0:	8b 52 08             	mov    0x8(%edx),%edx
f010b7c3:	89 50 08             	mov    %edx,0x8(%eax)
f010b7c6:	eb 0b                	jmp    f010b7d3 <complete_environment_initialization+0x20d>
f010b7c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7cb:	8b 40 08             	mov    0x8(%eax),%eax
f010b7ce:	a3 b4 39 5c f0       	mov    %eax,0xf05c39b4
f010b7d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7d6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010b7dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7e0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b7e7:	a1 c0 39 5c f0       	mov    0xf05c39c0,%eax
f010b7ec:	48                   	dec    %eax
f010b7ed:	a3 c0 39 5c f0       	mov    %eax,0xf05c39c0
	return ;
f010b7f2:	90                   	nop
}
f010b7f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b7f6:	c9                   	leave  
f010b7f7:	c3                   	ret    

f010b7f8 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010b7f8:	55                   	push   %ebp
f010b7f9:	89 e5                	mov    %esp,%ebp
f010b7fb:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b801:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b804:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b807:	8b 00                	mov    (%eax),%eax
f010b809:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b80e:	74 17                	je     f010b827 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010b810:	83 ec 04             	sub    $0x4,%esp
f010b813:	68 f1 50 12 f0       	push   $0xf01250f1
f010b818:	68 61 04 00 00       	push   $0x461
f010b81d:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b822:	e8 12 4b ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010b827:	8b 45 08             	mov    0x8(%ebp),%eax
f010b82a:	8b 00                	mov    (%eax),%eax
f010b82c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b82f:	8b 52 18             	mov    0x18(%edx),%edx
f010b832:	89 50 30             	mov    %edx,0x30(%eax)
}
f010b835:	90                   	nop
f010b836:	c9                   	leave  
f010b837:	c3                   	ret    

f010b838 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010b838:	55                   	push   %ebp
f010b839:	89 e5                	mov    %esp,%ebp
f010b83b:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010b83e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b841:	8b 40 10             	mov    0x10(%eax),%eax
f010b844:	8d 48 01             	lea    0x1(%eax),%ecx
f010b847:	8b 55 08             	mov    0x8(%ebp),%edx
f010b84a:	89 4a 10             	mov    %ecx,0x10(%edx)
f010b84d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b850:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b853:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b856:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b859:	8b 00                	mov    (%eax),%eax
f010b85b:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b860:	74 17                	je     f010b879 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010b862:	83 ec 04             	sub    $0x4,%esp
f010b865:	68 f1 50 12 f0       	push   $0xf01250f1
f010b86a:	68 6f 04 00 00       	push   $0x46f
f010b86f:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b874:	e8 c0 4a ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010b879:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b87c:	8b 50 1c             	mov    0x1c(%eax),%edx
f010b87f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b882:	01 d0                	add    %edx,%eax
f010b884:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010b887:	eb 0f                	jmp    f010b898 <PROGRAM_SEGMENT_NEXT+0x60>
f010b889:	8b 45 08             	mov    0x8(%ebp),%eax
f010b88c:	8b 40 10             	mov    0x10(%eax),%eax
f010b88f:	8d 50 01             	lea    0x1(%eax),%edx
f010b892:	8b 45 08             	mov    0x8(%ebp),%eax
f010b895:	89 50 10             	mov    %edx,0x10(%eax)
f010b898:	8b 45 08             	mov    0x8(%ebp),%eax
f010b89b:	8b 40 10             	mov    0x10(%eax),%eax
f010b89e:	c1 e0 05             	shl    $0x5,%eax
f010b8a1:	89 c2                	mov    %eax,%edx
f010b8a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b8a6:	01 d0                	add    %edx,%eax
f010b8a8:	8b 00                	mov    (%eax),%eax
f010b8aa:	83 f8 01             	cmp    $0x1,%eax
f010b8ad:	74 13                	je     f010b8c2 <PROGRAM_SEGMENT_NEXT+0x8a>
f010b8af:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8b2:	8b 50 10             	mov    0x10(%eax),%edx
f010b8b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8b8:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b8bb:	0f b7 c0             	movzwl %ax,%eax
f010b8be:	39 c2                	cmp    %eax,%edx
f010b8c0:	72 c7                	jb     f010b889 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010b8c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8c5:	8b 40 10             	mov    0x10(%eax),%eax
f010b8c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010b8cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8ce:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b8d1:	0f b7 c0             	movzwl %ax,%eax
f010b8d4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010b8d7:	7e 63                	jle    f010b93c <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010b8d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b8dc:	c1 e0 05             	shl    $0x5,%eax
f010b8df:	89 c2                	mov    %eax,%edx
f010b8e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b8e4:	01 d0                	add    %edx,%eax
f010b8e6:	8b 50 04             	mov    0x4(%eax),%edx
f010b8e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8ec:	01 c2                	add    %eax,%edx
f010b8ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8f1:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010b8f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b8f6:	c1 e0 05             	shl    $0x5,%eax
f010b8f9:	89 c2                	mov    %eax,%edx
f010b8fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b8fe:	01 d0                	add    %edx,%eax
f010b900:	8b 50 14             	mov    0x14(%eax),%edx
f010b903:	8b 45 08             	mov    0x8(%ebp),%eax
f010b906:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010b909:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b90c:	c1 e0 05             	shl    $0x5,%eax
f010b90f:	89 c2                	mov    %eax,%edx
f010b911:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b914:	01 d0                	add    %edx,%eax
f010b916:	8b 50 10             	mov    0x10(%eax),%edx
f010b919:	8b 45 08             	mov    0x8(%ebp),%eax
f010b91c:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010b91f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b922:	c1 e0 05             	shl    $0x5,%eax
f010b925:	89 c2                	mov    %eax,%edx
f010b927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b92a:	01 d0                	add    %edx,%eax
f010b92c:	8b 40 08             	mov    0x8(%eax),%eax
f010b92f:	89 c2                	mov    %eax,%edx
f010b931:	8b 45 08             	mov    0x8(%ebp),%eax
f010b934:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010b937:	8b 45 08             	mov    0x8(%ebp),%eax
f010b93a:	eb 05                	jmp    f010b941 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010b93c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b941:	c9                   	leave  
f010b942:	c3                   	ret    

f010b943 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010b943:	55                   	push   %ebp
f010b944:	89 e5                	mov    %esp,%ebp
f010b946:	57                   	push   %edi
f010b947:	56                   	push   %esi
f010b948:	53                   	push   %ebx
f010b949:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010b94c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b953:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b956:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b959:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b95c:	8b 00                	mov    (%eax),%eax
f010b95e:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b963:	74 17                	je     f010b97c <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010b965:	83 ec 04             	sub    $0x4,%esp
f010b968:	68 f1 50 12 f0       	push   $0xf01250f1
f010b96d:	68 8b 04 00 00       	push   $0x48b
f010b972:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010b977:	e8 bd 49 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010b97c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b97f:	8b 50 1c             	mov    0x1c(%eax),%edx
f010b982:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b985:	01 d0                	add    %edx,%eax
f010b987:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010b98a:	eb 07                	jmp    f010b993 <PROGRAM_SEGMENT_FIRST+0x50>
f010b98c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b98f:	40                   	inc    %eax
f010b990:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b993:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b996:	c1 e0 05             	shl    $0x5,%eax
f010b999:	89 c2                	mov    %eax,%edx
f010b99b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b99e:	01 d0                	add    %edx,%eax
f010b9a0:	8b 00                	mov    (%eax),%eax
f010b9a2:	83 f8 01             	cmp    $0x1,%eax
f010b9a5:	74 10                	je     f010b9b7 <PROGRAM_SEGMENT_FIRST+0x74>
f010b9a7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010b9aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9ad:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b9b0:	0f b7 c0             	movzwl %ax,%eax
f010b9b3:	39 c2                	cmp    %eax,%edx
f010b9b5:	72 d5                	jb     f010b98c <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010b9b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9ba:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010b9bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9c0:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b9c3:	0f b7 c0             	movzwl %ax,%eax
f010b9c6:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010b9c9:	7e 68                	jle    f010ba33 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010b9cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b9ce:	c1 e0 05             	shl    $0x5,%eax
f010b9d1:	89 c2                	mov    %eax,%edx
f010b9d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b9d6:	01 d0                	add    %edx,%eax
f010b9d8:	8b 50 04             	mov    0x4(%eax),%edx
f010b9db:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b9de:	01 d0                	add    %edx,%eax
f010b9e0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010b9e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b9e6:	c1 e0 05             	shl    $0x5,%eax
f010b9e9:	89 c2                	mov    %eax,%edx
f010b9eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b9ee:	01 d0                	add    %edx,%eax
f010b9f0:	8b 40 14             	mov    0x14(%eax),%eax
f010b9f3:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010b9f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b9f9:	c1 e0 05             	shl    $0x5,%eax
f010b9fc:	89 c2                	mov    %eax,%edx
f010b9fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba01:	01 d0                	add    %edx,%eax
f010ba03:	8b 40 10             	mov    0x10(%eax),%eax
f010ba06:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010ba09:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba0c:	c1 e0 05             	shl    $0x5,%eax
f010ba0f:	89 c2                	mov    %eax,%edx
f010ba11:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba14:	01 d0                	add    %edx,%eax
f010ba16:	8b 40 08             	mov    0x8(%eax),%eax
f010ba19:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010ba1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba1f:	89 c3                	mov    %eax,%ebx
f010ba21:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ba24:	ba 05 00 00 00       	mov    $0x5,%edx
f010ba29:	89 df                	mov    %ebx,%edi
f010ba2b:	89 c6                	mov    %eax,%esi
f010ba2d:	89 d1                	mov    %edx,%ecx
f010ba2f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010ba31:	eb 1c                	jmp    f010ba4f <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010ba33:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010ba3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba3d:	89 c3                	mov    %eax,%ebx
f010ba3f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ba42:	ba 05 00 00 00       	mov    $0x5,%edx
f010ba47:	89 df                	mov    %ebx,%edi
f010ba49:	89 c6                	mov    %eax,%esi
f010ba4b:	89 d1                	mov    %edx,%ecx
f010ba4d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010ba4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba52:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ba55:	5b                   	pop    %ebx
f010ba56:	5e                   	pop    %esi
f010ba57:	5f                   	pop    %edi
f010ba58:	5d                   	pop    %ebp
f010ba59:	c2 04 00             	ret    $0x4

f010ba5c <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010ba5c:	55                   	push   %ebp
f010ba5d:	89 e5                	mov    %esp,%ebp
f010ba5f:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010ba62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010ba69:	83 ec 0c             	sub    $0xc,%esp
f010ba6c:	68 60 c5 5e f0       	push   $0xf05ec560
f010ba71:	e8 ec 2d 00 00       	call   f010e862 <acquire_spinlock>
f010ba76:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010ba79:	a1 50 c5 5e f0       	mov    0xf05ec550,%eax
f010ba7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ba81:	e9 c3 00 00 00       	jmp    f010bb49 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010ba86:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba89:	8b 40 0c             	mov    0xc(%eax),%eax
f010ba8c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ba8f:	0f 85 ac 00 00 00    	jne    f010bb41 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010ba95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba98:	8b 50 10             	mov    0x10(%eax),%edx
f010ba9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba9e:	8b 40 0c             	mov    0xc(%eax),%eax
f010baa1:	8b 40 64             	mov    0x64(%eax),%eax
f010baa4:	83 ec 08             	sub    $0x8,%esp
f010baa7:	52                   	push   %edx
f010baa8:	50                   	push   %eax
f010baa9:	e8 e6 d3 ff ff       	call   f0108e94 <pt_clear_page_table_entry>
f010baae:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010bab1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bab5:	75 17                	jne    f010bace <cleanup_buffers+0x72>
f010bab7:	83 ec 04             	sub    $0x4,%esp
f010baba:	68 93 4e 12 f0       	push   $0xf0124e93
f010babf:	68 b4 04 00 00       	push   $0x4b4
f010bac4:	68 0b 4e 12 f0       	push   $0xf0124e0b
f010bac9:	e8 6b 48 ff ff       	call   f0100339 <_panic>
f010bace:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bad1:	8b 00                	mov    (%eax),%eax
f010bad3:	85 c0                	test   %eax,%eax
f010bad5:	74 10                	je     f010bae7 <cleanup_buffers+0x8b>
f010bad7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bada:	8b 00                	mov    (%eax),%eax
f010badc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010badf:	8b 52 04             	mov    0x4(%edx),%edx
f010bae2:	89 50 04             	mov    %edx,0x4(%eax)
f010bae5:	eb 0b                	jmp    f010baf2 <cleanup_buffers+0x96>
f010bae7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baea:	8b 40 04             	mov    0x4(%eax),%eax
f010baed:	a3 54 c5 5e f0       	mov    %eax,0xf05ec554
f010baf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baf5:	8b 40 04             	mov    0x4(%eax),%eax
f010baf8:	85 c0                	test   %eax,%eax
f010bafa:	74 0f                	je     f010bb0b <cleanup_buffers+0xaf>
f010bafc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baff:	8b 40 04             	mov    0x4(%eax),%eax
f010bb02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb05:	8b 12                	mov    (%edx),%edx
f010bb07:	89 10                	mov    %edx,(%eax)
f010bb09:	eb 0a                	jmp    f010bb15 <cleanup_buffers+0xb9>
f010bb0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb0e:	8b 00                	mov    (%eax),%eax
f010bb10:	a3 50 c5 5e f0       	mov    %eax,0xf05ec550
f010bb15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010bb1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb21:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010bb28:	a1 5c c5 5e f0       	mov    0xf05ec55c,%eax
f010bb2d:	48                   	dec    %eax
f010bb2e:	a3 5c c5 5e f0       	mov    %eax,0xf05ec55c

				free_frame(ptr_fi);
f010bb33:	83 ec 0c             	sub    $0xc,%esp
f010bb36:	ff 75 f4             	pushl  -0xc(%ebp)
f010bb39:	e8 5d c7 ff ff       	call   f010829b <free_frame>
f010bb3e:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bb41:	a1 58 c5 5e f0       	mov    0xf05ec558,%eax
f010bb46:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bb49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb4d:	74 07                	je     f010bb56 <cleanup_buffers+0xfa>
f010bb4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb52:	8b 00                	mov    (%eax),%eax
f010bb54:	eb 05                	jmp    f010bb5b <cleanup_buffers+0xff>
f010bb56:	b8 00 00 00 00       	mov    $0x0,%eax
f010bb5b:	a3 58 c5 5e f0       	mov    %eax,0xf05ec558
f010bb60:	a1 58 c5 5e f0       	mov    0xf05ec558,%eax
f010bb65:	85 c0                	test   %eax,%eax
f010bb67:	0f 85 19 ff ff ff    	jne    f010ba86 <cleanup_buffers+0x2a>
f010bb6d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb71:	0f 85 0f ff ff ff    	jne    f010ba86 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010bb77:	83 ec 0c             	sub    $0xc,%esp
f010bb7a:	68 60 c5 5e f0       	push   $0xf05ec560
f010bb7f:	e8 65 2d 00 00       	call   f010e8e9 <release_spinlock>
f010bb84:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010bb87:	90                   	nop
f010bb88:	c9                   	leave  
f010bb89:	c3                   	ret    

f010bb8a <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010bb8a:	55                   	push   %ebp
f010bb8b:	89 e5                	mov    %esp,%ebp
f010bb8d:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010bb90:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010bb94:	7e 06                	jle    f010bb9c <set_program_priority+0x12>
f010bb96:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bb9a:	7e 14                	jle    f010bbb0 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010bb9c:	83 ec 04             	sub    $0x4,%esp
f010bb9f:	68 08 51 12 f0       	push   $0xf0125108
f010bba4:	6a 10                	push   $0x10
f010bba6:	68 2c 51 12 f0       	push   $0xf012512c
f010bbab:	e8 89 47 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010bbb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bbb4:	74 78                	je     f010bc2e <set_program_priority+0xa4>
		return;
	switch(priority)
f010bbb6:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bbba:	77 56                	ja     f010bc12 <set_program_priority+0x88>
f010bbbc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbbf:	c1 e0 02             	shl    $0x2,%eax
f010bbc2:	05 68 51 12 f0       	add    $0xf0125168,%eax
f010bbc7:	8b 00                	mov    (%eax),%eax
f010bbc9:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bbcb:	83 ec 08             	sub    $0x8,%esp
f010bbce:	6a 01                	push   $0x1
f010bbd0:	ff 75 08             	pushl  0x8(%ebp)
f010bbd3:	e8 c2 df ff ff       	call   f0109b9a <half_WS_Size>
f010bbd8:	83 c4 10             	add    $0x10,%esp
			break;
f010bbdb:	eb 35                	jmp    f010bc12 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bbdd:	83 ec 08             	sub    $0x8,%esp
f010bbe0:	6a 00                	push   $0x0
f010bbe2:	ff 75 08             	pushl  0x8(%ebp)
f010bbe5:	e8 b0 df ff ff       	call   f0109b9a <half_WS_Size>
f010bbea:	83 c4 10             	add    $0x10,%esp
			break;
f010bbed:	eb 23                	jmp    f010bc12 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bbef:	83 ec 08             	sub    $0x8,%esp
f010bbf2:	6a 01                	push   $0x1
f010bbf4:	ff 75 08             	pushl  0x8(%ebp)
f010bbf7:	e8 81 df ff ff       	call   f0109b7d <double_WS_Size>
f010bbfc:	83 c4 10             	add    $0x10,%esp
			break;
f010bbff:	eb 11                	jmp    f010bc12 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010bc01:	83 ec 08             	sub    $0x8,%esp
f010bc04:	6a 00                	push   $0x0
f010bc06:	ff 75 08             	pushl  0x8(%ebp)
f010bc09:	e8 6f df ff ff       	call   f0109b7d <double_WS_Size>
f010bc0e:	83 c4 10             	add    $0x10,%esp
			break;
f010bc11:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bc12:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc15:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bc1b:	83 ec 08             	sub    $0x8,%esp
f010bc1e:	50                   	push   %eax
f010bc1f:	68 49 51 12 f0       	push   $0xf0125149
f010bc24:	e8 62 53 ff ff       	call   f0100f8b <cprintf>
f010bc29:	83 c4 10             	add    $0x10,%esp
f010bc2c:	eb 01                	jmp    f010bc2f <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bc2e:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bc2f:	c9                   	leave  
f010bc30:	c3                   	ret    

f010bc31 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bc31:	55                   	push   %ebp
f010bc32:	89 e5                	mov    %esp,%ebp
f010bc34:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bc37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bc3e:	eb 29                	jmp    f010bc69 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bc40:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc43:	89 d0                	mov    %edx,%eax
f010bc45:	01 c0                	add    %eax,%eax
f010bc47:	01 d0                	add    %edx,%eax
f010bc49:	c1 e0 02             	shl    $0x2,%eax
f010bc4c:	05 80 b9 17 f0       	add    $0xf017b980,%eax
f010bc51:	8b 00                	mov    (%eax),%eax
f010bc53:	83 ec 08             	sub    $0x8,%esp
f010bc56:	50                   	push   %eax
f010bc57:	ff 75 08             	pushl  0x8(%ebp)
f010bc5a:	e8 9c 2c 01 00       	call   f011e8fb <strcmp>
f010bc5f:	83 c4 10             	add    $0x10,%esp
f010bc62:	85 c0                	test   %eax,%eax
f010bc64:	74 0f                	je     f010bc75 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bc66:	ff 45 f4             	incl   -0xc(%ebp)
f010bc69:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010bc6e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bc71:	7c cd                	jl     f010bc40 <get_user_program_info+0xf>
f010bc73:	eb 01                	jmp    f010bc76 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bc75:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bc76:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010bc7b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bc7e:	75 1a                	jne    f010bc9a <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bc80:	83 ec 08             	sub    $0x8,%esp
f010bc83:	ff 75 08             	pushl  0x8(%ebp)
f010bc86:	68 cd 5e 12 f0       	push   $0xf0125ecd
f010bc8b:	e8 fb 52 ff ff       	call   f0100f8b <cprintf>
f010bc90:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bc93:	b8 00 00 00 00       	mov    $0x0,%eax
f010bc98:	eb 11                	jmp    f010bcab <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010bc9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc9d:	89 d0                	mov    %edx,%eax
f010bc9f:	01 c0                	add    %eax,%eax
f010bca1:	01 d0                	add    %edx,%eax
f010bca3:	c1 e0 02             	shl    $0x2,%eax
f010bca6:	05 80 b9 17 f0       	add    $0xf017b980,%eax
}
f010bcab:	c9                   	leave  
f010bcac:	c3                   	ret    

f010bcad <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010bcad:	55                   	push   %ebp
f010bcae:	89 e5                	mov    %esp,%ebp
f010bcb0:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bcb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bcba:	eb 2d                	jmp    f010bce9 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010bcbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcbf:	89 d0                	mov    %edx,%eax
f010bcc1:	01 c0                	add    %eax,%eax
f010bcc3:	01 d0                	add    %edx,%eax
f010bcc5:	c1 e0 02             	shl    $0x2,%eax
f010bcc8:	05 80 b9 17 f0       	add    $0xf017b980,%eax
f010bccd:	8b 00                	mov    (%eax),%eax
f010bccf:	8b 55 08             	mov    0x8(%ebp),%edx
f010bcd2:	83 c2 20             	add    $0x20,%edx
f010bcd5:	83 ec 08             	sub    $0x8,%esp
f010bcd8:	50                   	push   %eax
f010bcd9:	52                   	push   %edx
f010bcda:	e8 1c 2c 01 00       	call   f011e8fb <strcmp>
f010bcdf:	83 c4 10             	add    $0x10,%esp
f010bce2:	85 c0                	test   %eax,%eax
f010bce4:	74 0f                	je     f010bcf5 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bce6:	ff 45 f4             	incl   -0xc(%ebp)
f010bce9:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010bcee:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bcf1:	7c c9                	jl     f010bcbc <get_user_program_info_by_env+0xf>
f010bcf3:	eb 01                	jmp    f010bcf6 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010bcf5:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bcf6:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010bcfb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bcfe:	75 17                	jne    f010bd17 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010bd00:	83 ec 0c             	sub    $0xc,%esp
f010bd03:	68 e8 5e 12 f0       	push   $0xf0125ee8
f010bd08:	e8 7e 52 ff ff       	call   f0100f8b <cprintf>
f010bd0d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bd10:	b8 00 00 00 00       	mov    $0x0,%eax
f010bd15:	eb 11                	jmp    f010bd28 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010bd17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd1a:	89 d0                	mov    %edx,%eax
f010bd1c:	01 c0                	add    %eax,%eax
f010bd1e:	01 d0                	add    %edx,%eax
f010bd20:	c1 e0 02             	shl    $0x2,%eax
f010bd23:	05 80 b9 17 f0       	add    $0xf017b980,%eax
}
f010bd28:	c9                   	leave  
f010bd29:	c3                   	ret    

f010bd2a <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010bd2a:	55                   	push   %ebp
f010bd2b:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010bd2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd30:	83 f8 13             	cmp    $0x13,%eax
f010bd33:	77 0c                	ja     f010bd41 <trapname+0x17>
		return excnames[trapno];
f010bd35:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd38:	8b 04 85 c0 62 12 f0 	mov    -0xfed9d40(,%eax,4),%eax
f010bd3f:	eb 2c                	jmp    f010bd6d <trapname+0x43>
	if (trapno == T_SYSCALL)
f010bd41:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010bd45:	75 07                	jne    f010bd4e <trapname+0x24>
		return "System call";
f010bd47:	b8 00 5f 12 f0       	mov    $0xf0125f00,%eax
f010bd4c:	eb 1f                	jmp    f010bd6d <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010bd4e:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010bd52:	75 07                	jne    f010bd5b <trapname+0x31>
		return "Clock Interrupt";
f010bd54:	b8 0c 5f 12 f0       	mov    $0xf0125f0c,%eax
f010bd59:	eb 12                	jmp    f010bd6d <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010bd5b:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010bd5f:	75 07                	jne    f010bd68 <trapname+0x3e>
		return "Keyboard Interrupt";
f010bd61:	b8 1c 5f 12 f0       	mov    $0xf0125f1c,%eax
f010bd66:	eb 05                	jmp    f010bd6d <trapname+0x43>
	return "(unknown trap)";
f010bd68:	b8 2f 5f 12 f0       	mov    $0xf0125f2f,%eax
}
f010bd6d:	5d                   	pop    %ebp
f010bd6e:	c3                   	ret    

f010bd6f <ts_init>:


void ts_init(void)
{
f010bd6f:	55                   	push   %ebp
f010bd70:	89 e5                	mov    %esp,%ebp
f010bd72:	53                   	push   %ebx
f010bd73:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010bd76:	e8 e9 b3 ff ff       	call   f0107164 <pushcli>

	struct cpu* c = mycpu();
f010bd7b:	e8 21 b3 ff ff       	call   f01070a1 <mycpu>
f010bd80:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010bd83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd86:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010bd8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd90:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bd96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd99:	83 c0 0c             	add    $0xc,%eax
f010bd9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd9f:	83 c2 0c             	add    $0xc,%edx
f010bda2:	c1 ea 10             	shr    $0x10,%edx
f010bda5:	88 d3                	mov    %dl,%bl
f010bda7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdaa:	83 c2 0c             	add    $0xc,%edx
f010bdad:	c1 ea 18             	shr    $0x18,%edx
f010bdb0:	88 d1                	mov    %dl,%cl
f010bdb2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdb5:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bdbc:	68 00 
f010bdbe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdc1:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bdc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdcb:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bdd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdd4:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdda:	83 e2 f0             	and    $0xfffffff0,%edx
f010bddd:	83 ca 09             	or     $0x9,%edx
f010bde0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bde6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdef:	83 ca 10             	or     $0x10,%edx
f010bdf2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdfb:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be01:	83 e2 9f             	and    $0xffffff9f,%edx
f010be04:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be0d:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be13:	83 ca 80             	or     $0xffffff80,%edx
f010be16:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be1f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be25:	83 e2 f0             	and    $0xfffffff0,%edx
f010be28:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be31:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be37:	83 e2 ef             	and    $0xffffffef,%edx
f010be3a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be43:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be49:	83 e2 df             	and    $0xffffffdf,%edx
f010be4c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be55:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be5b:	83 ca 40             	or     $0x40,%edx
f010be5e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be67:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be6d:	83 e2 7f             	and    $0x7f,%edx
f010be70:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be79:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010be7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be82:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be88:	83 e2 ef             	and    $0xffffffef,%edx
f010be8b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010be91:	e8 20 b3 ff ff       	call   f01071b6 <popcli>
f010be96:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010be9c:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010bea0:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010bea3:	90                   	nop
f010bea4:	83 c4 14             	add    $0x14,%esp
f010bea7:	5b                   	pop    %ebx
f010bea8:	5d                   	pop    %ebp
f010bea9:	c3                   	ret    

f010beaa <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010beaa:	55                   	push   %ebp
f010beab:	89 e5                	mov    %esp,%ebp
f010bead:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010beb0:	b8 58 d3 10 f0       	mov    $0xf010d358,%eax
f010beb5:	66 a3 20 3a 5c f0    	mov    %ax,0xf05c3a20
f010bebb:	66 c7 05 22 3a 5c f0 	movw   $0x8,0xf05c3a22
f010bec2:	08 00 
f010bec4:	a0 24 3a 5c f0       	mov    0xf05c3a24,%al
f010bec9:	83 e0 e0             	and    $0xffffffe0,%eax
f010becc:	a2 24 3a 5c f0       	mov    %al,0xf05c3a24
f010bed1:	a0 24 3a 5c f0       	mov    0xf05c3a24,%al
f010bed6:	83 e0 1f             	and    $0x1f,%eax
f010bed9:	a2 24 3a 5c f0       	mov    %al,0xf05c3a24
f010bede:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010bee3:	83 e0 f0             	and    $0xfffffff0,%eax
f010bee6:	83 c8 0e             	or     $0xe,%eax
f010bee9:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010beee:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010bef3:	83 e0 ef             	and    $0xffffffef,%eax
f010bef6:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010befb:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010bf00:	83 e0 9f             	and    $0xffffff9f,%eax
f010bf03:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010bf08:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010bf0d:	83 c8 80             	or     $0xffffff80,%eax
f010bf10:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010bf15:	b8 58 d3 10 f0       	mov    $0xf010d358,%eax
f010bf1a:	c1 e8 10             	shr    $0x10,%eax
f010bf1d:	66 a3 26 3a 5c f0    	mov    %ax,0xf05c3a26
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010bf23:	b8 60 d3 10 f0       	mov    $0xf010d360,%eax
f010bf28:	66 a3 50 3a 5c f0    	mov    %ax,0xf05c3a50
f010bf2e:	66 c7 05 52 3a 5c f0 	movw   $0x8,0xf05c3a52
f010bf35:	08 00 
f010bf37:	a0 54 3a 5c f0       	mov    0xf05c3a54,%al
f010bf3c:	83 e0 e0             	and    $0xffffffe0,%eax
f010bf3f:	a2 54 3a 5c f0       	mov    %al,0xf05c3a54
f010bf44:	a0 54 3a 5c f0       	mov    0xf05c3a54,%al
f010bf49:	83 e0 1f             	and    $0x1f,%eax
f010bf4c:	a2 54 3a 5c f0       	mov    %al,0xf05c3a54
f010bf51:	a0 55 3a 5c f0       	mov    0xf05c3a55,%al
f010bf56:	83 e0 f0             	and    $0xfffffff0,%eax
f010bf59:	83 c8 0e             	or     $0xe,%eax
f010bf5c:	a2 55 3a 5c f0       	mov    %al,0xf05c3a55
f010bf61:	a0 55 3a 5c f0       	mov    0xf05c3a55,%al
f010bf66:	83 e0 ef             	and    $0xffffffef,%eax
f010bf69:	a2 55 3a 5c f0       	mov    %al,0xf05c3a55
f010bf6e:	a0 55 3a 5c f0       	mov    0xf05c3a55,%al
f010bf73:	83 e0 9f             	and    $0xffffff9f,%eax
f010bf76:	a2 55 3a 5c f0       	mov    %al,0xf05c3a55
f010bf7b:	a0 55 3a 5c f0       	mov    0xf05c3a55,%al
f010bf80:	83 c8 80             	or     $0xffffff80,%eax
f010bf83:	a2 55 3a 5c f0       	mov    %al,0xf05c3a55
f010bf88:	b8 60 d3 10 f0       	mov    $0xf010d360,%eax
f010bf8d:	c1 e8 10             	shr    $0x10,%eax
f010bf90:	66 a3 56 3a 5c f0    	mov    %ax,0xf05c3a56
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010bf96:	b8 68 d3 10 f0       	mov    $0xf010d368,%eax
f010bf9b:	66 a3 e0 3a 5c f0    	mov    %ax,0xf05c3ae0
f010bfa1:	66 c7 05 e2 3a 5c f0 	movw   $0x8,0xf05c3ae2
f010bfa8:	08 00 
f010bfaa:	a0 e4 3a 5c f0       	mov    0xf05c3ae4,%al
f010bfaf:	83 e0 e0             	and    $0xffffffe0,%eax
f010bfb2:	a2 e4 3a 5c f0       	mov    %al,0xf05c3ae4
f010bfb7:	a0 e4 3a 5c f0       	mov    0xf05c3ae4,%al
f010bfbc:	83 e0 1f             	and    $0x1f,%eax
f010bfbf:	a2 e4 3a 5c f0       	mov    %al,0xf05c3ae4
f010bfc4:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010bfc9:	83 e0 f0             	and    $0xfffffff0,%eax
f010bfcc:	83 c8 0e             	or     $0xe,%eax
f010bfcf:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010bfd4:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010bfd9:	83 e0 ef             	and    $0xffffffef,%eax
f010bfdc:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010bfe1:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010bfe6:	83 c8 60             	or     $0x60,%eax
f010bfe9:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010bfee:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010bff3:	83 c8 80             	or     $0xffffff80,%eax
f010bff6:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010bffb:	b8 68 d3 10 f0       	mov    $0xf010d368,%eax
f010c000:	c1 e8 10             	shr    $0x10,%eax
f010c003:	66 a3 e6 3a 5c f0    	mov    %ax,0xf05c3ae6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c009:	b8 72 d3 10 f0       	mov    $0xf010d372,%eax
f010c00e:	66 a3 e8 3a 5c f0    	mov    %ax,0xf05c3ae8
f010c014:	66 c7 05 ea 3a 5c f0 	movw   $0x8,0xf05c3aea
f010c01b:	08 00 
f010c01d:	a0 ec 3a 5c f0       	mov    0xf05c3aec,%al
f010c022:	83 e0 e0             	and    $0xffffffe0,%eax
f010c025:	a2 ec 3a 5c f0       	mov    %al,0xf05c3aec
f010c02a:	a0 ec 3a 5c f0       	mov    0xf05c3aec,%al
f010c02f:	83 e0 1f             	and    $0x1f,%eax
f010c032:	a2 ec 3a 5c f0       	mov    %al,0xf05c3aec
f010c037:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010c03c:	83 e0 f0             	and    $0xfffffff0,%eax
f010c03f:	83 c8 0e             	or     $0xe,%eax
f010c042:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010c047:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010c04c:	83 e0 ef             	and    $0xffffffef,%eax
f010c04f:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010c054:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010c059:	83 c8 60             	or     $0x60,%eax
f010c05c:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010c061:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010c066:	83 c8 80             	or     $0xffffff80,%eax
f010c069:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010c06e:	b8 72 d3 10 f0       	mov    $0xf010d372,%eax
f010c073:	c1 e8 10             	shr    $0x10,%eax
f010c076:	66 a3 ee 3a 5c f0    	mov    %ax,0xf05c3aee
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c07c:	b8 7c d3 10 f0       	mov    $0xf010d37c,%eax
f010c081:	66 a3 60 3b 5c f0    	mov    %ax,0xf05c3b60
f010c087:	66 c7 05 62 3b 5c f0 	movw   $0x8,0xf05c3b62
f010c08e:	08 00 
f010c090:	a0 64 3b 5c f0       	mov    0xf05c3b64,%al
f010c095:	83 e0 e0             	and    $0xffffffe0,%eax
f010c098:	a2 64 3b 5c f0       	mov    %al,0xf05c3b64
f010c09d:	a0 64 3b 5c f0       	mov    0xf05c3b64,%al
f010c0a2:	83 e0 1f             	and    $0x1f,%eax
f010c0a5:	a2 64 3b 5c f0       	mov    %al,0xf05c3b64
f010c0aa:	a0 65 3b 5c f0       	mov    0xf05c3b65,%al
f010c0af:	83 e0 f0             	and    $0xfffffff0,%eax
f010c0b2:	83 c8 0e             	or     $0xe,%eax
f010c0b5:	a2 65 3b 5c f0       	mov    %al,0xf05c3b65
f010c0ba:	a0 65 3b 5c f0       	mov    0xf05c3b65,%al
f010c0bf:	83 e0 ef             	and    $0xffffffef,%eax
f010c0c2:	a2 65 3b 5c f0       	mov    %al,0xf05c3b65
f010c0c7:	a0 65 3b 5c f0       	mov    0xf05c3b65,%al
f010c0cc:	83 c8 60             	or     $0x60,%eax
f010c0cf:	a2 65 3b 5c f0       	mov    %al,0xf05c3b65
f010c0d4:	a0 65 3b 5c f0       	mov    0xf05c3b65,%al
f010c0d9:	83 c8 80             	or     $0xffffff80,%eax
f010c0dc:	a2 65 3b 5c f0       	mov    %al,0xf05c3b65
f010c0e1:	b8 7c d3 10 f0       	mov    $0xf010d37c,%eax
f010c0e6:	c1 e8 10             	shr    $0x10,%eax
f010c0e9:	66 a3 66 3b 5c f0    	mov    %ax,0xf05c3b66

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c0ef:	b8 86 d3 10 f0       	mov    $0xf010d386,%eax
f010c0f4:	66 a3 e0 39 5c f0    	mov    %ax,0xf05c39e0
f010c0fa:	66 c7 05 e2 39 5c f0 	movw   $0x8,0xf05c39e2
f010c101:	08 00 
f010c103:	a0 e4 39 5c f0       	mov    0xf05c39e4,%al
f010c108:	83 e0 e0             	and    $0xffffffe0,%eax
f010c10b:	a2 e4 39 5c f0       	mov    %al,0xf05c39e4
f010c110:	a0 e4 39 5c f0       	mov    0xf05c39e4,%al
f010c115:	83 e0 1f             	and    $0x1f,%eax
f010c118:	a2 e4 39 5c f0       	mov    %al,0xf05c39e4
f010c11d:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c122:	83 e0 f0             	and    $0xfffffff0,%eax
f010c125:	83 c8 0e             	or     $0xe,%eax
f010c128:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c12d:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c132:	83 e0 ef             	and    $0xffffffef,%eax
f010c135:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c13a:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c13f:	83 c8 60             	or     $0x60,%eax
f010c142:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c147:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c14c:	83 c8 80             	or     $0xffffff80,%eax
f010c14f:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c154:	b8 86 d3 10 f0       	mov    $0xf010d386,%eax
f010c159:	c1 e8 10             	shr    $0x10,%eax
f010c15c:	66 a3 e6 39 5c f0    	mov    %ax,0xf05c39e6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c162:	b8 90 d3 10 f0       	mov    $0xf010d390,%eax
f010c167:	66 a3 e8 39 5c f0    	mov    %ax,0xf05c39e8
f010c16d:	66 c7 05 ea 39 5c f0 	movw   $0x8,0xf05c39ea
f010c174:	08 00 
f010c176:	a0 ec 39 5c f0       	mov    0xf05c39ec,%al
f010c17b:	83 e0 e0             	and    $0xffffffe0,%eax
f010c17e:	a2 ec 39 5c f0       	mov    %al,0xf05c39ec
f010c183:	a0 ec 39 5c f0       	mov    0xf05c39ec,%al
f010c188:	83 e0 1f             	and    $0x1f,%eax
f010c18b:	a2 ec 39 5c f0       	mov    %al,0xf05c39ec
f010c190:	a0 ed 39 5c f0       	mov    0xf05c39ed,%al
f010c195:	83 c8 0f             	or     $0xf,%eax
f010c198:	a2 ed 39 5c f0       	mov    %al,0xf05c39ed
f010c19d:	a0 ed 39 5c f0       	mov    0xf05c39ed,%al
f010c1a2:	83 e0 ef             	and    $0xffffffef,%eax
f010c1a5:	a2 ed 39 5c f0       	mov    %al,0xf05c39ed
f010c1aa:	a0 ed 39 5c f0       	mov    0xf05c39ed,%al
f010c1af:	83 c8 60             	or     $0x60,%eax
f010c1b2:	a2 ed 39 5c f0       	mov    %al,0xf05c39ed
f010c1b7:	a0 ed 39 5c f0       	mov    0xf05c39ed,%al
f010c1bc:	83 c8 80             	or     $0xffffff80,%eax
f010c1bf:	a2 ed 39 5c f0       	mov    %al,0xf05c39ed
f010c1c4:	b8 90 d3 10 f0       	mov    $0xf010d390,%eax
f010c1c9:	c1 e8 10             	shr    $0x10,%eax
f010c1cc:	66 a3 ee 39 5c f0    	mov    %ax,0xf05c39ee
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c1d2:	b8 9a d3 10 f0       	mov    $0xf010d39a,%eax
f010c1d7:	66 a3 f0 39 5c f0    	mov    %ax,0xf05c39f0
f010c1dd:	66 c7 05 f2 39 5c f0 	movw   $0x8,0xf05c39f2
f010c1e4:	08 00 
f010c1e6:	a0 f4 39 5c f0       	mov    0xf05c39f4,%al
f010c1eb:	83 e0 e0             	and    $0xffffffe0,%eax
f010c1ee:	a2 f4 39 5c f0       	mov    %al,0xf05c39f4
f010c1f3:	a0 f4 39 5c f0       	mov    0xf05c39f4,%al
f010c1f8:	83 e0 1f             	and    $0x1f,%eax
f010c1fb:	a2 f4 39 5c f0       	mov    %al,0xf05c39f4
f010c200:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c205:	83 e0 f0             	and    $0xfffffff0,%eax
f010c208:	83 c8 0e             	or     $0xe,%eax
f010c20b:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c210:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c215:	83 e0 ef             	and    $0xffffffef,%eax
f010c218:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c21d:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c222:	83 c8 60             	or     $0x60,%eax
f010c225:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c22a:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c22f:	83 c8 80             	or     $0xffffff80,%eax
f010c232:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c237:	b8 9a d3 10 f0       	mov    $0xf010d39a,%eax
f010c23c:	c1 e8 10             	shr    $0x10,%eax
f010c23f:	66 a3 f6 39 5c f0    	mov    %ax,0xf05c39f6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c245:	b8 a4 d3 10 f0       	mov    $0xf010d3a4,%eax
f010c24a:	66 a3 f8 39 5c f0    	mov    %ax,0xf05c39f8
f010c250:	66 c7 05 fa 39 5c f0 	movw   $0x8,0xf05c39fa
f010c257:	08 00 
f010c259:	a0 fc 39 5c f0       	mov    0xf05c39fc,%al
f010c25e:	83 e0 e0             	and    $0xffffffe0,%eax
f010c261:	a2 fc 39 5c f0       	mov    %al,0xf05c39fc
f010c266:	a0 fc 39 5c f0       	mov    0xf05c39fc,%al
f010c26b:	83 e0 1f             	and    $0x1f,%eax
f010c26e:	a2 fc 39 5c f0       	mov    %al,0xf05c39fc
f010c273:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c278:	83 c8 0f             	or     $0xf,%eax
f010c27b:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c280:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c285:	83 e0 ef             	and    $0xffffffef,%eax
f010c288:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c28d:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c292:	83 c8 60             	or     $0x60,%eax
f010c295:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c29a:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c29f:	83 c8 80             	or     $0xffffff80,%eax
f010c2a2:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c2a7:	b8 a4 d3 10 f0       	mov    $0xf010d3a4,%eax
f010c2ac:	c1 e8 10             	shr    $0x10,%eax
f010c2af:	66 a3 fe 39 5c f0    	mov    %ax,0xf05c39fe
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c2b5:	b8 ae d3 10 f0       	mov    $0xf010d3ae,%eax
f010c2ba:	66 a3 00 3a 5c f0    	mov    %ax,0xf05c3a00
f010c2c0:	66 c7 05 02 3a 5c f0 	movw   $0x8,0xf05c3a02
f010c2c7:	08 00 
f010c2c9:	a0 04 3a 5c f0       	mov    0xf05c3a04,%al
f010c2ce:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2d1:	a2 04 3a 5c f0       	mov    %al,0xf05c3a04
f010c2d6:	a0 04 3a 5c f0       	mov    0xf05c3a04,%al
f010c2db:	83 e0 1f             	and    $0x1f,%eax
f010c2de:	a2 04 3a 5c f0       	mov    %al,0xf05c3a04
f010c2e3:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c2e8:	83 c8 0f             	or     $0xf,%eax
f010c2eb:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c2f0:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c2f5:	83 e0 ef             	and    $0xffffffef,%eax
f010c2f8:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c2fd:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c302:	83 c8 60             	or     $0x60,%eax
f010c305:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c30a:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c30f:	83 c8 80             	or     $0xffffff80,%eax
f010c312:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c317:	b8 ae d3 10 f0       	mov    $0xf010d3ae,%eax
f010c31c:	c1 e8 10             	shr    $0x10,%eax
f010c31f:	66 a3 06 3a 5c f0    	mov    %ax,0xf05c3a06
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c325:	b8 b8 d3 10 f0       	mov    $0xf010d3b8,%eax
f010c32a:	66 a3 08 3a 5c f0    	mov    %ax,0xf05c3a08
f010c330:	66 c7 05 0a 3a 5c f0 	movw   $0x8,0xf05c3a0a
f010c337:	08 00 
f010c339:	a0 0c 3a 5c f0       	mov    0xf05c3a0c,%al
f010c33e:	83 e0 e0             	and    $0xffffffe0,%eax
f010c341:	a2 0c 3a 5c f0       	mov    %al,0xf05c3a0c
f010c346:	a0 0c 3a 5c f0       	mov    0xf05c3a0c,%al
f010c34b:	83 e0 1f             	and    $0x1f,%eax
f010c34e:	a2 0c 3a 5c f0       	mov    %al,0xf05c3a0c
f010c353:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c358:	83 e0 f0             	and    $0xfffffff0,%eax
f010c35b:	83 c8 0e             	or     $0xe,%eax
f010c35e:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c363:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c368:	83 e0 ef             	and    $0xffffffef,%eax
f010c36b:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c370:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c375:	83 c8 60             	or     $0x60,%eax
f010c378:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c37d:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c382:	83 c8 80             	or     $0xffffff80,%eax
f010c385:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c38a:	b8 b8 d3 10 f0       	mov    $0xf010d3b8,%eax
f010c38f:	c1 e8 10             	shr    $0x10,%eax
f010c392:	66 a3 0e 3a 5c f0    	mov    %ax,0xf05c3a0e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c398:	b8 c2 d3 10 f0       	mov    $0xf010d3c2,%eax
f010c39d:	66 a3 10 3a 5c f0    	mov    %ax,0xf05c3a10
f010c3a3:	66 c7 05 12 3a 5c f0 	movw   $0x8,0xf05c3a12
f010c3aa:	08 00 
f010c3ac:	a0 14 3a 5c f0       	mov    0xf05c3a14,%al
f010c3b1:	83 e0 e0             	and    $0xffffffe0,%eax
f010c3b4:	a2 14 3a 5c f0       	mov    %al,0xf05c3a14
f010c3b9:	a0 14 3a 5c f0       	mov    0xf05c3a14,%al
f010c3be:	83 e0 1f             	and    $0x1f,%eax
f010c3c1:	a2 14 3a 5c f0       	mov    %al,0xf05c3a14
f010c3c6:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c3cb:	83 e0 f0             	and    $0xfffffff0,%eax
f010c3ce:	83 c8 0e             	or     $0xe,%eax
f010c3d1:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c3d6:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c3db:	83 e0 ef             	and    $0xffffffef,%eax
f010c3de:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c3e3:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c3e8:	83 c8 60             	or     $0x60,%eax
f010c3eb:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c3f0:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c3f5:	83 c8 80             	or     $0xffffff80,%eax
f010c3f8:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c3fd:	b8 c2 d3 10 f0       	mov    $0xf010d3c2,%eax
f010c402:	c1 e8 10             	shr    $0x10,%eax
f010c405:	66 a3 16 3a 5c f0    	mov    %ax,0xf05c3a16
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c40b:	b8 cc d3 10 f0       	mov    $0xf010d3cc,%eax
f010c410:	66 a3 18 3a 5c f0    	mov    %ax,0xf05c3a18
f010c416:	66 c7 05 1a 3a 5c f0 	movw   $0x8,0xf05c3a1a
f010c41d:	08 00 
f010c41f:	a0 1c 3a 5c f0       	mov    0xf05c3a1c,%al
f010c424:	83 e0 e0             	and    $0xffffffe0,%eax
f010c427:	a2 1c 3a 5c f0       	mov    %al,0xf05c3a1c
f010c42c:	a0 1c 3a 5c f0       	mov    0xf05c3a1c,%al
f010c431:	83 e0 1f             	and    $0x1f,%eax
f010c434:	a2 1c 3a 5c f0       	mov    %al,0xf05c3a1c
f010c439:	a0 1d 3a 5c f0       	mov    0xf05c3a1d,%al
f010c43e:	83 e0 f0             	and    $0xfffffff0,%eax
f010c441:	83 c8 0e             	or     $0xe,%eax
f010c444:	a2 1d 3a 5c f0       	mov    %al,0xf05c3a1d
f010c449:	a0 1d 3a 5c f0       	mov    0xf05c3a1d,%al
f010c44e:	83 e0 ef             	and    $0xffffffef,%eax
f010c451:	a2 1d 3a 5c f0       	mov    %al,0xf05c3a1d
f010c456:	a0 1d 3a 5c f0       	mov    0xf05c3a1d,%al
f010c45b:	83 c8 60             	or     $0x60,%eax
f010c45e:	a2 1d 3a 5c f0       	mov    %al,0xf05c3a1d
f010c463:	a0 1d 3a 5c f0       	mov    0xf05c3a1d,%al
f010c468:	83 c8 80             	or     $0xffffff80,%eax
f010c46b:	a2 1d 3a 5c f0       	mov    %al,0xf05c3a1d
f010c470:	b8 cc d3 10 f0       	mov    $0xf010d3cc,%eax
f010c475:	c1 e8 10             	shr    $0x10,%eax
f010c478:	66 a3 1e 3a 5c f0    	mov    %ax,0xf05c3a1e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c47e:	b8 d2 d3 10 f0       	mov    $0xf010d3d2,%eax
f010c483:	66 a3 30 3a 5c f0    	mov    %ax,0xf05c3a30
f010c489:	66 c7 05 32 3a 5c f0 	movw   $0x8,0xf05c3a32
f010c490:	08 00 
f010c492:	a0 34 3a 5c f0       	mov    0xf05c3a34,%al
f010c497:	83 e0 e0             	and    $0xffffffe0,%eax
f010c49a:	a2 34 3a 5c f0       	mov    %al,0xf05c3a34
f010c49f:	a0 34 3a 5c f0       	mov    0xf05c3a34,%al
f010c4a4:	83 e0 1f             	and    $0x1f,%eax
f010c4a7:	a2 34 3a 5c f0       	mov    %al,0xf05c3a34
f010c4ac:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010c4b1:	83 e0 f0             	and    $0xfffffff0,%eax
f010c4b4:	83 c8 0e             	or     $0xe,%eax
f010c4b7:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010c4bc:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010c4c1:	83 e0 ef             	and    $0xffffffef,%eax
f010c4c4:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010c4c9:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010c4ce:	83 c8 60             	or     $0x60,%eax
f010c4d1:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010c4d6:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010c4db:	83 c8 80             	or     $0xffffff80,%eax
f010c4de:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010c4e3:	b8 d2 d3 10 f0       	mov    $0xf010d3d2,%eax
f010c4e8:	c1 e8 10             	shr    $0x10,%eax
f010c4eb:	66 a3 36 3a 5c f0    	mov    %ax,0xf05c3a36
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c4f1:	b8 d6 d3 10 f0       	mov    $0xf010d3d6,%eax
f010c4f6:	66 a3 38 3a 5c f0    	mov    %ax,0xf05c3a38
f010c4fc:	66 c7 05 3a 3a 5c f0 	movw   $0x8,0xf05c3a3a
f010c503:	08 00 
f010c505:	a0 3c 3a 5c f0       	mov    0xf05c3a3c,%al
f010c50a:	83 e0 e0             	and    $0xffffffe0,%eax
f010c50d:	a2 3c 3a 5c f0       	mov    %al,0xf05c3a3c
f010c512:	a0 3c 3a 5c f0       	mov    0xf05c3a3c,%al
f010c517:	83 e0 1f             	and    $0x1f,%eax
f010c51a:	a2 3c 3a 5c f0       	mov    %al,0xf05c3a3c
f010c51f:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010c524:	83 e0 f0             	and    $0xfffffff0,%eax
f010c527:	83 c8 0e             	or     $0xe,%eax
f010c52a:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010c52f:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010c534:	83 e0 ef             	and    $0xffffffef,%eax
f010c537:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010c53c:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010c541:	83 c8 60             	or     $0x60,%eax
f010c544:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010c549:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010c54e:	83 c8 80             	or     $0xffffff80,%eax
f010c551:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010c556:	b8 d6 d3 10 f0       	mov    $0xf010d3d6,%eax
f010c55b:	c1 e8 10             	shr    $0x10,%eax
f010c55e:	66 a3 3e 3a 5c f0    	mov    %ax,0xf05c3a3e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c564:	b8 da d3 10 f0       	mov    $0xf010d3da,%eax
f010c569:	66 a3 40 3a 5c f0    	mov    %ax,0xf05c3a40
f010c56f:	66 c7 05 42 3a 5c f0 	movw   $0x8,0xf05c3a42
f010c576:	08 00 
f010c578:	a0 44 3a 5c f0       	mov    0xf05c3a44,%al
f010c57d:	83 e0 e0             	and    $0xffffffe0,%eax
f010c580:	a2 44 3a 5c f0       	mov    %al,0xf05c3a44
f010c585:	a0 44 3a 5c f0       	mov    0xf05c3a44,%al
f010c58a:	83 e0 1f             	and    $0x1f,%eax
f010c58d:	a2 44 3a 5c f0       	mov    %al,0xf05c3a44
f010c592:	a0 45 3a 5c f0       	mov    0xf05c3a45,%al
f010c597:	83 e0 f0             	and    $0xfffffff0,%eax
f010c59a:	83 c8 0e             	or     $0xe,%eax
f010c59d:	a2 45 3a 5c f0       	mov    %al,0xf05c3a45
f010c5a2:	a0 45 3a 5c f0       	mov    0xf05c3a45,%al
f010c5a7:	83 e0 ef             	and    $0xffffffef,%eax
f010c5aa:	a2 45 3a 5c f0       	mov    %al,0xf05c3a45
f010c5af:	a0 45 3a 5c f0       	mov    0xf05c3a45,%al
f010c5b4:	83 c8 60             	or     $0x60,%eax
f010c5b7:	a2 45 3a 5c f0       	mov    %al,0xf05c3a45
f010c5bc:	a0 45 3a 5c f0       	mov    0xf05c3a45,%al
f010c5c1:	83 c8 80             	or     $0xffffff80,%eax
f010c5c4:	a2 45 3a 5c f0       	mov    %al,0xf05c3a45
f010c5c9:	b8 da d3 10 f0       	mov    $0xf010d3da,%eax
f010c5ce:	c1 e8 10             	shr    $0x10,%eax
f010c5d1:	66 a3 46 3a 5c f0    	mov    %ax,0xf05c3a46
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c5d7:	b8 de d3 10 f0       	mov    $0xf010d3de,%eax
f010c5dc:	66 a3 48 3a 5c f0    	mov    %ax,0xf05c3a48
f010c5e2:	66 c7 05 4a 3a 5c f0 	movw   $0x8,0xf05c3a4a
f010c5e9:	08 00 
f010c5eb:	a0 4c 3a 5c f0       	mov    0xf05c3a4c,%al
f010c5f0:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5f3:	a2 4c 3a 5c f0       	mov    %al,0xf05c3a4c
f010c5f8:	a0 4c 3a 5c f0       	mov    0xf05c3a4c,%al
f010c5fd:	83 e0 1f             	and    $0x1f,%eax
f010c600:	a2 4c 3a 5c f0       	mov    %al,0xf05c3a4c
f010c605:	a0 4d 3a 5c f0       	mov    0xf05c3a4d,%al
f010c60a:	83 e0 f0             	and    $0xfffffff0,%eax
f010c60d:	83 c8 0e             	or     $0xe,%eax
f010c610:	a2 4d 3a 5c f0       	mov    %al,0xf05c3a4d
f010c615:	a0 4d 3a 5c f0       	mov    0xf05c3a4d,%al
f010c61a:	83 e0 ef             	and    $0xffffffef,%eax
f010c61d:	a2 4d 3a 5c f0       	mov    %al,0xf05c3a4d
f010c622:	a0 4d 3a 5c f0       	mov    0xf05c3a4d,%al
f010c627:	83 c8 60             	or     $0x60,%eax
f010c62a:	a2 4d 3a 5c f0       	mov    %al,0xf05c3a4d
f010c62f:	a0 4d 3a 5c f0       	mov    0xf05c3a4d,%al
f010c634:	83 c8 80             	or     $0xffffff80,%eax
f010c637:	a2 4d 3a 5c f0       	mov    %al,0xf05c3a4d
f010c63c:	b8 de d3 10 f0       	mov    $0xf010d3de,%eax
f010c641:	c1 e8 10             	shr    $0x10,%eax
f010c644:	66 a3 4e 3a 5c f0    	mov    %ax,0xf05c3a4e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c64a:	b8 e2 d3 10 f0       	mov    $0xf010d3e2,%eax
f010c64f:	66 a3 60 3a 5c f0    	mov    %ax,0xf05c3a60
f010c655:	66 c7 05 62 3a 5c f0 	movw   $0x8,0xf05c3a62
f010c65c:	08 00 
f010c65e:	a0 64 3a 5c f0       	mov    0xf05c3a64,%al
f010c663:	83 e0 e0             	and    $0xffffffe0,%eax
f010c666:	a2 64 3a 5c f0       	mov    %al,0xf05c3a64
f010c66b:	a0 64 3a 5c f0       	mov    0xf05c3a64,%al
f010c670:	83 e0 1f             	and    $0x1f,%eax
f010c673:	a2 64 3a 5c f0       	mov    %al,0xf05c3a64
f010c678:	a0 65 3a 5c f0       	mov    0xf05c3a65,%al
f010c67d:	83 e0 f0             	and    $0xfffffff0,%eax
f010c680:	83 c8 0e             	or     $0xe,%eax
f010c683:	a2 65 3a 5c f0       	mov    %al,0xf05c3a65
f010c688:	a0 65 3a 5c f0       	mov    0xf05c3a65,%al
f010c68d:	83 e0 ef             	and    $0xffffffef,%eax
f010c690:	a2 65 3a 5c f0       	mov    %al,0xf05c3a65
f010c695:	a0 65 3a 5c f0       	mov    0xf05c3a65,%al
f010c69a:	83 c8 60             	or     $0x60,%eax
f010c69d:	a2 65 3a 5c f0       	mov    %al,0xf05c3a65
f010c6a2:	a0 65 3a 5c f0       	mov    0xf05c3a65,%al
f010c6a7:	83 c8 80             	or     $0xffffff80,%eax
f010c6aa:	a2 65 3a 5c f0       	mov    %al,0xf05c3a65
f010c6af:	b8 e2 d3 10 f0       	mov    $0xf010d3e2,%eax
f010c6b4:	c1 e8 10             	shr    $0x10,%eax
f010c6b7:	66 a3 66 3a 5c f0    	mov    %ax,0xf05c3a66
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010c6bd:	b8 e8 d3 10 f0       	mov    $0xf010d3e8,%eax
f010c6c2:	66 a3 68 3a 5c f0    	mov    %ax,0xf05c3a68
f010c6c8:	66 c7 05 6a 3a 5c f0 	movw   $0x8,0xf05c3a6a
f010c6cf:	08 00 
f010c6d1:	a0 6c 3a 5c f0       	mov    0xf05c3a6c,%al
f010c6d6:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6d9:	a2 6c 3a 5c f0       	mov    %al,0xf05c3a6c
f010c6de:	a0 6c 3a 5c f0       	mov    0xf05c3a6c,%al
f010c6e3:	83 e0 1f             	and    $0x1f,%eax
f010c6e6:	a2 6c 3a 5c f0       	mov    %al,0xf05c3a6c
f010c6eb:	a0 6d 3a 5c f0       	mov    0xf05c3a6d,%al
f010c6f0:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6f3:	83 c8 0e             	or     $0xe,%eax
f010c6f6:	a2 6d 3a 5c f0       	mov    %al,0xf05c3a6d
f010c6fb:	a0 6d 3a 5c f0       	mov    0xf05c3a6d,%al
f010c700:	83 e0 ef             	and    $0xffffffef,%eax
f010c703:	a2 6d 3a 5c f0       	mov    %al,0xf05c3a6d
f010c708:	a0 6d 3a 5c f0       	mov    0xf05c3a6d,%al
f010c70d:	83 c8 60             	or     $0x60,%eax
f010c710:	a2 6d 3a 5c f0       	mov    %al,0xf05c3a6d
f010c715:	a0 6d 3a 5c f0       	mov    0xf05c3a6d,%al
f010c71a:	83 c8 80             	or     $0xffffff80,%eax
f010c71d:	a2 6d 3a 5c f0       	mov    %al,0xf05c3a6d
f010c722:	b8 e8 d3 10 f0       	mov    $0xf010d3e8,%eax
f010c727:	c1 e8 10             	shr    $0x10,%eax
f010c72a:	66 a3 6e 3a 5c f0    	mov    %ax,0xf05c3a6e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010c730:	b8 ec d3 10 f0       	mov    $0xf010d3ec,%eax
f010c735:	66 a3 70 3a 5c f0    	mov    %ax,0xf05c3a70
f010c73b:	66 c7 05 72 3a 5c f0 	movw   $0x8,0xf05c3a72
f010c742:	08 00 
f010c744:	a0 74 3a 5c f0       	mov    0xf05c3a74,%al
f010c749:	83 e0 e0             	and    $0xffffffe0,%eax
f010c74c:	a2 74 3a 5c f0       	mov    %al,0xf05c3a74
f010c751:	a0 74 3a 5c f0       	mov    0xf05c3a74,%al
f010c756:	83 e0 1f             	and    $0x1f,%eax
f010c759:	a2 74 3a 5c f0       	mov    %al,0xf05c3a74
f010c75e:	a0 75 3a 5c f0       	mov    0xf05c3a75,%al
f010c763:	83 e0 f0             	and    $0xfffffff0,%eax
f010c766:	83 c8 0e             	or     $0xe,%eax
f010c769:	a2 75 3a 5c f0       	mov    %al,0xf05c3a75
f010c76e:	a0 75 3a 5c f0       	mov    0xf05c3a75,%al
f010c773:	83 e0 ef             	and    $0xffffffef,%eax
f010c776:	a2 75 3a 5c f0       	mov    %al,0xf05c3a75
f010c77b:	a0 75 3a 5c f0       	mov    0xf05c3a75,%al
f010c780:	83 c8 60             	or     $0x60,%eax
f010c783:	a2 75 3a 5c f0       	mov    %al,0xf05c3a75
f010c788:	a0 75 3a 5c f0       	mov    0xf05c3a75,%al
f010c78d:	83 c8 80             	or     $0xffffff80,%eax
f010c790:	a2 75 3a 5c f0       	mov    %al,0xf05c3a75
f010c795:	b8 ec d3 10 f0       	mov    $0xf010d3ec,%eax
f010c79a:	c1 e8 10             	shr    $0x10,%eax
f010c79d:	66 a3 76 3a 5c f0    	mov    %ax,0xf05c3a76
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010c7a3:	b8 f2 d3 10 f0       	mov    $0xf010d3f2,%eax
f010c7a8:	66 a3 78 3a 5c f0    	mov    %ax,0xf05c3a78
f010c7ae:	66 c7 05 7a 3a 5c f0 	movw   $0x8,0xf05c3a7a
f010c7b5:	08 00 
f010c7b7:	a0 7c 3a 5c f0       	mov    0xf05c3a7c,%al
f010c7bc:	83 e0 e0             	and    $0xffffffe0,%eax
f010c7bf:	a2 7c 3a 5c f0       	mov    %al,0xf05c3a7c
f010c7c4:	a0 7c 3a 5c f0       	mov    0xf05c3a7c,%al
f010c7c9:	83 e0 1f             	and    $0x1f,%eax
f010c7cc:	a2 7c 3a 5c f0       	mov    %al,0xf05c3a7c
f010c7d1:	a0 7d 3a 5c f0       	mov    0xf05c3a7d,%al
f010c7d6:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7d9:	83 c8 0e             	or     $0xe,%eax
f010c7dc:	a2 7d 3a 5c f0       	mov    %al,0xf05c3a7d
f010c7e1:	a0 7d 3a 5c f0       	mov    0xf05c3a7d,%al
f010c7e6:	83 e0 ef             	and    $0xffffffef,%eax
f010c7e9:	a2 7d 3a 5c f0       	mov    %al,0xf05c3a7d
f010c7ee:	a0 7d 3a 5c f0       	mov    0xf05c3a7d,%al
f010c7f3:	83 c8 60             	or     $0x60,%eax
f010c7f6:	a2 7d 3a 5c f0       	mov    %al,0xf05c3a7d
f010c7fb:	a0 7d 3a 5c f0       	mov    0xf05c3a7d,%al
f010c800:	83 c8 80             	or     $0xffffff80,%eax
f010c803:	a2 7d 3a 5c f0       	mov    %al,0xf05c3a7d
f010c808:	b8 f2 d3 10 f0       	mov    $0xf010d3f2,%eax
f010c80d:	c1 e8 10             	shr    $0x10,%eax
f010c810:	66 a3 7e 3a 5c f0    	mov    %ax,0xf05c3a7e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010c816:	b8 f8 d3 10 f0       	mov    $0xf010d3f8,%eax
f010c81b:	66 a3 f0 3a 5c f0    	mov    %ax,0xf05c3af0
f010c821:	66 c7 05 f2 3a 5c f0 	movw   $0x8,0xf05c3af2
f010c828:	08 00 
f010c82a:	a0 f4 3a 5c f0       	mov    0xf05c3af4,%al
f010c82f:	83 e0 e0             	and    $0xffffffe0,%eax
f010c832:	a2 f4 3a 5c f0       	mov    %al,0xf05c3af4
f010c837:	a0 f4 3a 5c f0       	mov    0xf05c3af4,%al
f010c83c:	83 e0 1f             	and    $0x1f,%eax
f010c83f:	a2 f4 3a 5c f0       	mov    %al,0xf05c3af4
f010c844:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010c849:	83 e0 f0             	and    $0xfffffff0,%eax
f010c84c:	83 c8 0e             	or     $0xe,%eax
f010c84f:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010c854:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010c859:	83 e0 ef             	and    $0xffffffef,%eax
f010c85c:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010c861:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010c866:	83 c8 60             	or     $0x60,%eax
f010c869:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010c86e:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010c873:	83 c8 80             	or     $0xffffff80,%eax
f010c876:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010c87b:	b8 f8 d3 10 f0       	mov    $0xf010d3f8,%eax
f010c880:	c1 e8 10             	shr    $0x10,%eax
f010c883:	66 a3 f6 3a 5c f0    	mov    %ax,0xf05c3af6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010c889:	b8 fe d3 10 f0       	mov    $0xf010d3fe,%eax
f010c88e:	66 a3 f8 3a 5c f0    	mov    %ax,0xf05c3af8
f010c894:	66 c7 05 fa 3a 5c f0 	movw   $0x8,0xf05c3afa
f010c89b:	08 00 
f010c89d:	a0 fc 3a 5c f0       	mov    0xf05c3afc,%al
f010c8a2:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8a5:	a2 fc 3a 5c f0       	mov    %al,0xf05c3afc
f010c8aa:	a0 fc 3a 5c f0       	mov    0xf05c3afc,%al
f010c8af:	83 e0 1f             	and    $0x1f,%eax
f010c8b2:	a2 fc 3a 5c f0       	mov    %al,0xf05c3afc
f010c8b7:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010c8bc:	83 e0 f0             	and    $0xfffffff0,%eax
f010c8bf:	83 c8 0e             	or     $0xe,%eax
f010c8c2:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010c8c7:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010c8cc:	83 e0 ef             	and    $0xffffffef,%eax
f010c8cf:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010c8d4:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010c8d9:	83 c8 60             	or     $0x60,%eax
f010c8dc:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010c8e1:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010c8e6:	83 c8 80             	or     $0xffffff80,%eax
f010c8e9:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010c8ee:	b8 fe d3 10 f0       	mov    $0xf010d3fe,%eax
f010c8f3:	c1 e8 10             	shr    $0x10,%eax
f010c8f6:	66 a3 fe 3a 5c f0    	mov    %ax,0xf05c3afe
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010c8fc:	b8 04 d4 10 f0       	mov    $0xf010d404,%eax
f010c901:	66 a3 00 3b 5c f0    	mov    %ax,0xf05c3b00
f010c907:	66 c7 05 02 3b 5c f0 	movw   $0x8,0xf05c3b02
f010c90e:	08 00 
f010c910:	a0 04 3b 5c f0       	mov    0xf05c3b04,%al
f010c915:	83 e0 e0             	and    $0xffffffe0,%eax
f010c918:	a2 04 3b 5c f0       	mov    %al,0xf05c3b04
f010c91d:	a0 04 3b 5c f0       	mov    0xf05c3b04,%al
f010c922:	83 e0 1f             	and    $0x1f,%eax
f010c925:	a2 04 3b 5c f0       	mov    %al,0xf05c3b04
f010c92a:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010c92f:	83 e0 f0             	and    $0xfffffff0,%eax
f010c932:	83 c8 0e             	or     $0xe,%eax
f010c935:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010c93a:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010c93f:	83 e0 ef             	and    $0xffffffef,%eax
f010c942:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010c947:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010c94c:	83 c8 60             	or     $0x60,%eax
f010c94f:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010c954:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010c959:	83 c8 80             	or     $0xffffff80,%eax
f010c95c:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010c961:	b8 04 d4 10 f0       	mov    $0xf010d404,%eax
f010c966:	c1 e8 10             	shr    $0x10,%eax
f010c969:	66 a3 06 3b 5c f0    	mov    %ax,0xf05c3b06
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010c96f:	b8 0a d4 10 f0       	mov    $0xf010d40a,%eax
f010c974:	66 a3 08 3b 5c f0    	mov    %ax,0xf05c3b08
f010c97a:	66 c7 05 0a 3b 5c f0 	movw   $0x8,0xf05c3b0a
f010c981:	08 00 
f010c983:	a0 0c 3b 5c f0       	mov    0xf05c3b0c,%al
f010c988:	83 e0 e0             	and    $0xffffffe0,%eax
f010c98b:	a2 0c 3b 5c f0       	mov    %al,0xf05c3b0c
f010c990:	a0 0c 3b 5c f0       	mov    0xf05c3b0c,%al
f010c995:	83 e0 1f             	and    $0x1f,%eax
f010c998:	a2 0c 3b 5c f0       	mov    %al,0xf05c3b0c
f010c99d:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010c9a2:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9a5:	83 c8 0e             	or     $0xe,%eax
f010c9a8:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010c9ad:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010c9b2:	83 e0 ef             	and    $0xffffffef,%eax
f010c9b5:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010c9ba:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010c9bf:	83 c8 60             	or     $0x60,%eax
f010c9c2:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010c9c7:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010c9cc:	83 c8 80             	or     $0xffffff80,%eax
f010c9cf:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010c9d4:	b8 0a d4 10 f0       	mov    $0xf010d40a,%eax
f010c9d9:	c1 e8 10             	shr    $0x10,%eax
f010c9dc:	66 a3 0e 3b 5c f0    	mov    %ax,0xf05c3b0e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010c9e2:	b8 10 d4 10 f0       	mov    $0xf010d410,%eax
f010c9e7:	66 a3 10 3b 5c f0    	mov    %ax,0xf05c3b10
f010c9ed:	66 c7 05 12 3b 5c f0 	movw   $0x8,0xf05c3b12
f010c9f4:	08 00 
f010c9f6:	a0 14 3b 5c f0       	mov    0xf05c3b14,%al
f010c9fb:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9fe:	a2 14 3b 5c f0       	mov    %al,0xf05c3b14
f010ca03:	a0 14 3b 5c f0       	mov    0xf05c3b14,%al
f010ca08:	83 e0 1f             	and    $0x1f,%eax
f010ca0b:	a2 14 3b 5c f0       	mov    %al,0xf05c3b14
f010ca10:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010ca15:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca18:	83 c8 0e             	or     $0xe,%eax
f010ca1b:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010ca20:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010ca25:	83 e0 ef             	and    $0xffffffef,%eax
f010ca28:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010ca2d:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010ca32:	83 c8 60             	or     $0x60,%eax
f010ca35:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010ca3a:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010ca3f:	83 c8 80             	or     $0xffffff80,%eax
f010ca42:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010ca47:	b8 10 d4 10 f0       	mov    $0xf010d410,%eax
f010ca4c:	c1 e8 10             	shr    $0x10,%eax
f010ca4f:	66 a3 16 3b 5c f0    	mov    %ax,0xf05c3b16
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010ca55:	b8 16 d4 10 f0       	mov    $0xf010d416,%eax
f010ca5a:	66 a3 18 3b 5c f0    	mov    %ax,0xf05c3b18
f010ca60:	66 c7 05 1a 3b 5c f0 	movw   $0x8,0xf05c3b1a
f010ca67:	08 00 
f010ca69:	a0 1c 3b 5c f0       	mov    0xf05c3b1c,%al
f010ca6e:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca71:	a2 1c 3b 5c f0       	mov    %al,0xf05c3b1c
f010ca76:	a0 1c 3b 5c f0       	mov    0xf05c3b1c,%al
f010ca7b:	83 e0 1f             	and    $0x1f,%eax
f010ca7e:	a2 1c 3b 5c f0       	mov    %al,0xf05c3b1c
f010ca83:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010ca88:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca8b:	83 c8 0e             	or     $0xe,%eax
f010ca8e:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010ca93:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010ca98:	83 e0 ef             	and    $0xffffffef,%eax
f010ca9b:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010caa0:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010caa5:	83 c8 60             	or     $0x60,%eax
f010caa8:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010caad:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010cab2:	83 c8 80             	or     $0xffffff80,%eax
f010cab5:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010caba:	b8 16 d4 10 f0       	mov    $0xf010d416,%eax
f010cabf:	c1 e8 10             	shr    $0x10,%eax
f010cac2:	66 a3 1e 3b 5c f0    	mov    %ax,0xf05c3b1e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010cac8:	b8 1c d4 10 f0       	mov    $0xf010d41c,%eax
f010cacd:	66 a3 20 3b 5c f0    	mov    %ax,0xf05c3b20
f010cad3:	66 c7 05 22 3b 5c f0 	movw   $0x8,0xf05c3b22
f010cada:	08 00 
f010cadc:	a0 24 3b 5c f0       	mov    0xf05c3b24,%al
f010cae1:	83 e0 e0             	and    $0xffffffe0,%eax
f010cae4:	a2 24 3b 5c f0       	mov    %al,0xf05c3b24
f010cae9:	a0 24 3b 5c f0       	mov    0xf05c3b24,%al
f010caee:	83 e0 1f             	and    $0x1f,%eax
f010caf1:	a2 24 3b 5c f0       	mov    %al,0xf05c3b24
f010caf6:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010cafb:	83 e0 f0             	and    $0xfffffff0,%eax
f010cafe:	83 c8 0e             	or     $0xe,%eax
f010cb01:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010cb06:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010cb0b:	83 e0 ef             	and    $0xffffffef,%eax
f010cb0e:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010cb13:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010cb18:	83 c8 60             	or     $0x60,%eax
f010cb1b:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010cb20:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010cb25:	83 c8 80             	or     $0xffffff80,%eax
f010cb28:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010cb2d:	b8 1c d4 10 f0       	mov    $0xf010d41c,%eax
f010cb32:	c1 e8 10             	shr    $0x10,%eax
f010cb35:	66 a3 26 3b 5c f0    	mov    %ax,0xf05c3b26
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010cb3b:	b8 22 d4 10 f0       	mov    $0xf010d422,%eax
f010cb40:	66 a3 28 3b 5c f0    	mov    %ax,0xf05c3b28
f010cb46:	66 c7 05 2a 3b 5c f0 	movw   $0x8,0xf05c3b2a
f010cb4d:	08 00 
f010cb4f:	a0 2c 3b 5c f0       	mov    0xf05c3b2c,%al
f010cb54:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb57:	a2 2c 3b 5c f0       	mov    %al,0xf05c3b2c
f010cb5c:	a0 2c 3b 5c f0       	mov    0xf05c3b2c,%al
f010cb61:	83 e0 1f             	and    $0x1f,%eax
f010cb64:	a2 2c 3b 5c f0       	mov    %al,0xf05c3b2c
f010cb69:	a0 2d 3b 5c f0       	mov    0xf05c3b2d,%al
f010cb6e:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb71:	83 c8 0e             	or     $0xe,%eax
f010cb74:	a2 2d 3b 5c f0       	mov    %al,0xf05c3b2d
f010cb79:	a0 2d 3b 5c f0       	mov    0xf05c3b2d,%al
f010cb7e:	83 e0 ef             	and    $0xffffffef,%eax
f010cb81:	a2 2d 3b 5c f0       	mov    %al,0xf05c3b2d
f010cb86:	a0 2d 3b 5c f0       	mov    0xf05c3b2d,%al
f010cb8b:	83 c8 60             	or     $0x60,%eax
f010cb8e:	a2 2d 3b 5c f0       	mov    %al,0xf05c3b2d
f010cb93:	a0 2d 3b 5c f0       	mov    0xf05c3b2d,%al
f010cb98:	83 c8 80             	or     $0xffffff80,%eax
f010cb9b:	a2 2d 3b 5c f0       	mov    %al,0xf05c3b2d
f010cba0:	b8 22 d4 10 f0       	mov    $0xf010d422,%eax
f010cba5:	c1 e8 10             	shr    $0x10,%eax
f010cba8:	66 a3 2e 3b 5c f0    	mov    %ax,0xf05c3b2e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010cbae:	b8 28 d4 10 f0       	mov    $0xf010d428,%eax
f010cbb3:	66 a3 30 3b 5c f0    	mov    %ax,0xf05c3b30
f010cbb9:	66 c7 05 32 3b 5c f0 	movw   $0x8,0xf05c3b32
f010cbc0:	08 00 
f010cbc2:	a0 34 3b 5c f0       	mov    0xf05c3b34,%al
f010cbc7:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbca:	a2 34 3b 5c f0       	mov    %al,0xf05c3b34
f010cbcf:	a0 34 3b 5c f0       	mov    0xf05c3b34,%al
f010cbd4:	83 e0 1f             	and    $0x1f,%eax
f010cbd7:	a2 34 3b 5c f0       	mov    %al,0xf05c3b34
f010cbdc:	a0 35 3b 5c f0       	mov    0xf05c3b35,%al
f010cbe1:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbe4:	83 c8 0e             	or     $0xe,%eax
f010cbe7:	a2 35 3b 5c f0       	mov    %al,0xf05c3b35
f010cbec:	a0 35 3b 5c f0       	mov    0xf05c3b35,%al
f010cbf1:	83 e0 ef             	and    $0xffffffef,%eax
f010cbf4:	a2 35 3b 5c f0       	mov    %al,0xf05c3b35
f010cbf9:	a0 35 3b 5c f0       	mov    0xf05c3b35,%al
f010cbfe:	83 c8 60             	or     $0x60,%eax
f010cc01:	a2 35 3b 5c f0       	mov    %al,0xf05c3b35
f010cc06:	a0 35 3b 5c f0       	mov    0xf05c3b35,%al
f010cc0b:	83 c8 80             	or     $0xffffff80,%eax
f010cc0e:	a2 35 3b 5c f0       	mov    %al,0xf05c3b35
f010cc13:	b8 28 d4 10 f0       	mov    $0xf010d428,%eax
f010cc18:	c1 e8 10             	shr    $0x10,%eax
f010cc1b:	66 a3 36 3b 5c f0    	mov    %ax,0xf05c3b36
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cc21:	b8 2e d4 10 f0       	mov    $0xf010d42e,%eax
f010cc26:	66 a3 38 3b 5c f0    	mov    %ax,0xf05c3b38
f010cc2c:	66 c7 05 3a 3b 5c f0 	movw   $0x8,0xf05c3b3a
f010cc33:	08 00 
f010cc35:	a0 3c 3b 5c f0       	mov    0xf05c3b3c,%al
f010cc3a:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc3d:	a2 3c 3b 5c f0       	mov    %al,0xf05c3b3c
f010cc42:	a0 3c 3b 5c f0       	mov    0xf05c3b3c,%al
f010cc47:	83 e0 1f             	and    $0x1f,%eax
f010cc4a:	a2 3c 3b 5c f0       	mov    %al,0xf05c3b3c
f010cc4f:	a0 3d 3b 5c f0       	mov    0xf05c3b3d,%al
f010cc54:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc57:	83 c8 0e             	or     $0xe,%eax
f010cc5a:	a2 3d 3b 5c f0       	mov    %al,0xf05c3b3d
f010cc5f:	a0 3d 3b 5c f0       	mov    0xf05c3b3d,%al
f010cc64:	83 e0 ef             	and    $0xffffffef,%eax
f010cc67:	a2 3d 3b 5c f0       	mov    %al,0xf05c3b3d
f010cc6c:	a0 3d 3b 5c f0       	mov    0xf05c3b3d,%al
f010cc71:	83 c8 60             	or     $0x60,%eax
f010cc74:	a2 3d 3b 5c f0       	mov    %al,0xf05c3b3d
f010cc79:	a0 3d 3b 5c f0       	mov    0xf05c3b3d,%al
f010cc7e:	83 c8 80             	or     $0xffffff80,%eax
f010cc81:	a2 3d 3b 5c f0       	mov    %al,0xf05c3b3d
f010cc86:	b8 2e d4 10 f0       	mov    $0xf010d42e,%eax
f010cc8b:	c1 e8 10             	shr    $0x10,%eax
f010cc8e:	66 a3 3e 3b 5c f0    	mov    %ax,0xf05c3b3e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010cc94:	b8 34 d4 10 f0       	mov    $0xf010d434,%eax
f010cc99:	66 a3 40 3b 5c f0    	mov    %ax,0xf05c3b40
f010cc9f:	66 c7 05 42 3b 5c f0 	movw   $0x8,0xf05c3b42
f010cca6:	08 00 
f010cca8:	a0 44 3b 5c f0       	mov    0xf05c3b44,%al
f010ccad:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccb0:	a2 44 3b 5c f0       	mov    %al,0xf05c3b44
f010ccb5:	a0 44 3b 5c f0       	mov    0xf05c3b44,%al
f010ccba:	83 e0 1f             	and    $0x1f,%eax
f010ccbd:	a2 44 3b 5c f0       	mov    %al,0xf05c3b44
f010ccc2:	a0 45 3b 5c f0       	mov    0xf05c3b45,%al
f010ccc7:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccca:	83 c8 0e             	or     $0xe,%eax
f010cccd:	a2 45 3b 5c f0       	mov    %al,0xf05c3b45
f010ccd2:	a0 45 3b 5c f0       	mov    0xf05c3b45,%al
f010ccd7:	83 e0 ef             	and    $0xffffffef,%eax
f010ccda:	a2 45 3b 5c f0       	mov    %al,0xf05c3b45
f010ccdf:	a0 45 3b 5c f0       	mov    0xf05c3b45,%al
f010cce4:	83 c8 60             	or     $0x60,%eax
f010cce7:	a2 45 3b 5c f0       	mov    %al,0xf05c3b45
f010ccec:	a0 45 3b 5c f0       	mov    0xf05c3b45,%al
f010ccf1:	83 c8 80             	or     $0xffffff80,%eax
f010ccf4:	a2 45 3b 5c f0       	mov    %al,0xf05c3b45
f010ccf9:	b8 34 d4 10 f0       	mov    $0xf010d434,%eax
f010ccfe:	c1 e8 10             	shr    $0x10,%eax
f010cd01:	66 a3 46 3b 5c f0    	mov    %ax,0xf05c3b46
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010cd07:	b8 3a d4 10 f0       	mov    $0xf010d43a,%eax
f010cd0c:	66 a3 48 3b 5c f0    	mov    %ax,0xf05c3b48
f010cd12:	66 c7 05 4a 3b 5c f0 	movw   $0x8,0xf05c3b4a
f010cd19:	08 00 
f010cd1b:	a0 4c 3b 5c f0       	mov    0xf05c3b4c,%al
f010cd20:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd23:	a2 4c 3b 5c f0       	mov    %al,0xf05c3b4c
f010cd28:	a0 4c 3b 5c f0       	mov    0xf05c3b4c,%al
f010cd2d:	83 e0 1f             	and    $0x1f,%eax
f010cd30:	a2 4c 3b 5c f0       	mov    %al,0xf05c3b4c
f010cd35:	a0 4d 3b 5c f0       	mov    0xf05c3b4d,%al
f010cd3a:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd3d:	83 c8 0e             	or     $0xe,%eax
f010cd40:	a2 4d 3b 5c f0       	mov    %al,0xf05c3b4d
f010cd45:	a0 4d 3b 5c f0       	mov    0xf05c3b4d,%al
f010cd4a:	83 e0 ef             	and    $0xffffffef,%eax
f010cd4d:	a2 4d 3b 5c f0       	mov    %al,0xf05c3b4d
f010cd52:	a0 4d 3b 5c f0       	mov    0xf05c3b4d,%al
f010cd57:	83 c8 60             	or     $0x60,%eax
f010cd5a:	a2 4d 3b 5c f0       	mov    %al,0xf05c3b4d
f010cd5f:	a0 4d 3b 5c f0       	mov    0xf05c3b4d,%al
f010cd64:	83 c8 80             	or     $0xffffff80,%eax
f010cd67:	a2 4d 3b 5c f0       	mov    %al,0xf05c3b4d
f010cd6c:	b8 3a d4 10 f0       	mov    $0xf010d43a,%eax
f010cd71:	c1 e8 10             	shr    $0x10,%eax
f010cd74:	66 a3 4e 3b 5c f0    	mov    %ax,0xf05c3b4e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010cd7a:	b8 40 d4 10 f0       	mov    $0xf010d440,%eax
f010cd7f:	66 a3 50 3b 5c f0    	mov    %ax,0xf05c3b50
f010cd85:	66 c7 05 52 3b 5c f0 	movw   $0x8,0xf05c3b52
f010cd8c:	08 00 
f010cd8e:	a0 54 3b 5c f0       	mov    0xf05c3b54,%al
f010cd93:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd96:	a2 54 3b 5c f0       	mov    %al,0xf05c3b54
f010cd9b:	a0 54 3b 5c f0       	mov    0xf05c3b54,%al
f010cda0:	83 e0 1f             	and    $0x1f,%eax
f010cda3:	a2 54 3b 5c f0       	mov    %al,0xf05c3b54
f010cda8:	a0 55 3b 5c f0       	mov    0xf05c3b55,%al
f010cdad:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdb0:	83 c8 0e             	or     $0xe,%eax
f010cdb3:	a2 55 3b 5c f0       	mov    %al,0xf05c3b55
f010cdb8:	a0 55 3b 5c f0       	mov    0xf05c3b55,%al
f010cdbd:	83 e0 ef             	and    $0xffffffef,%eax
f010cdc0:	a2 55 3b 5c f0       	mov    %al,0xf05c3b55
f010cdc5:	a0 55 3b 5c f0       	mov    0xf05c3b55,%al
f010cdca:	83 c8 60             	or     $0x60,%eax
f010cdcd:	a2 55 3b 5c f0       	mov    %al,0xf05c3b55
f010cdd2:	a0 55 3b 5c f0       	mov    0xf05c3b55,%al
f010cdd7:	83 c8 80             	or     $0xffffff80,%eax
f010cdda:	a2 55 3b 5c f0       	mov    %al,0xf05c3b55
f010cddf:	b8 40 d4 10 f0       	mov    $0xf010d440,%eax
f010cde4:	c1 e8 10             	shr    $0x10,%eax
f010cde7:	66 a3 56 3b 5c f0    	mov    %ax,0xf05c3b56
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010cded:	b8 46 d4 10 f0       	mov    $0xf010d446,%eax
f010cdf2:	66 a3 58 3b 5c f0    	mov    %ax,0xf05c3b58
f010cdf8:	66 c7 05 5a 3b 5c f0 	movw   $0x8,0xf05c3b5a
f010cdff:	08 00 
f010ce01:	a0 5c 3b 5c f0       	mov    0xf05c3b5c,%al
f010ce06:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce09:	a2 5c 3b 5c f0       	mov    %al,0xf05c3b5c
f010ce0e:	a0 5c 3b 5c f0       	mov    0xf05c3b5c,%al
f010ce13:	83 e0 1f             	and    $0x1f,%eax
f010ce16:	a2 5c 3b 5c f0       	mov    %al,0xf05c3b5c
f010ce1b:	a0 5d 3b 5c f0       	mov    0xf05c3b5d,%al
f010ce20:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce23:	83 c8 0e             	or     $0xe,%eax
f010ce26:	a2 5d 3b 5c f0       	mov    %al,0xf05c3b5d
f010ce2b:	a0 5d 3b 5c f0       	mov    0xf05c3b5d,%al
f010ce30:	83 e0 ef             	and    $0xffffffef,%eax
f010ce33:	a2 5d 3b 5c f0       	mov    %al,0xf05c3b5d
f010ce38:	a0 5d 3b 5c f0       	mov    0xf05c3b5d,%al
f010ce3d:	83 c8 60             	or     $0x60,%eax
f010ce40:	a2 5d 3b 5c f0       	mov    %al,0xf05c3b5d
f010ce45:	a0 5d 3b 5c f0       	mov    0xf05c3b5d,%al
f010ce4a:	83 c8 80             	or     $0xffffff80,%eax
f010ce4d:	a2 5d 3b 5c f0       	mov    %al,0xf05c3b5d
f010ce52:	b8 46 d4 10 f0       	mov    $0xf010d446,%eax
f010ce57:	c1 e8 10             	shr    $0x10,%eax
f010ce5a:	66 a3 5e 3b 5c f0    	mov    %ax,0xf05c3b5e
f010ce60:	c7 45 fc e0 39 5c f0 	movl   $0xf05c39e0,-0x4(%ebp)
f010ce67:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010ce6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ce71:	48                   	dec    %eax
f010ce72:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010ce76:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ce79:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010ce7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ce80:	c1 e8 10             	shr    $0x10,%eax
f010ce83:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010ce87:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010ce8a:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010ce8d:	90                   	nop
f010ce8e:	c9                   	leave  
f010ce8f:	c3                   	ret    

f010ce90 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010ce90:	55                   	push   %ebp
f010ce91:	89 e5                	mov    %esp,%ebp
f010ce93:	53                   	push   %ebx
f010ce94:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010ce97:	83 ec 08             	sub    $0x8,%esp
f010ce9a:	ff 75 08             	pushl  0x8(%ebp)
f010ce9d:	68 3e 5f 12 f0       	push   $0xf0125f3e
f010cea2:	e8 e4 40 ff ff       	call   f0100f8b <cprintf>
f010cea7:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010ceaa:	8b 45 08             	mov    0x8(%ebp),%eax
f010cead:	83 ec 0c             	sub    $0xc,%esp
f010ceb0:	50                   	push   %eax
f010ceb1:	e8 fd 00 00 00       	call   f010cfb3 <print_regs>
f010ceb6:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010ceb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010cebc:	8b 40 20             	mov    0x20(%eax),%eax
f010cebf:	0f b7 c0             	movzwl %ax,%eax
f010cec2:	83 ec 08             	sub    $0x8,%esp
f010cec5:	50                   	push   %eax
f010cec6:	68 50 5f 12 f0       	push   $0xf0125f50
f010cecb:	e8 bb 40 ff ff       	call   f0100f8b <cprintf>
f010ced0:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010ced3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ced6:	8b 40 24             	mov    0x24(%eax),%eax
f010ced9:	0f b7 c0             	movzwl %ax,%eax
f010cedc:	83 ec 08             	sub    $0x8,%esp
f010cedf:	50                   	push   %eax
f010cee0:	68 63 5f 12 f0       	push   $0xf0125f63
f010cee5:	e8 a1 40 ff ff       	call   f0100f8b <cprintf>
f010ceea:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010ceed:	8b 45 08             	mov    0x8(%ebp),%eax
f010cef0:	8b 58 28             	mov    0x28(%eax),%ebx
f010cef3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cef6:	8b 40 28             	mov    0x28(%eax),%eax
f010cef9:	83 ec 0c             	sub    $0xc,%esp
f010cefc:	50                   	push   %eax
f010cefd:	e8 28 ee ff ff       	call   f010bd2a <trapname>
f010cf02:	83 c4 10             	add    $0x10,%esp
f010cf05:	89 c2                	mov    %eax,%edx
f010cf07:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf0a:	8b 40 28             	mov    0x28(%eax),%eax
f010cf0d:	53                   	push   %ebx
f010cf0e:	52                   	push   %edx
f010cf0f:	50                   	push   %eax
f010cf10:	68 76 5f 12 f0       	push   $0xf0125f76
f010cf15:	e8 71 40 ff ff       	call   f0100f8b <cprintf>
f010cf1a:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010cf1d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf20:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cf23:	83 ec 08             	sub    $0x8,%esp
f010cf26:	50                   	push   %eax
f010cf27:	68 8d 5f 12 f0       	push   $0xf0125f8d
f010cf2c:	e8 5a 40 ff ff       	call   f0100f8b <cprintf>
f010cf31:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010cf34:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf37:	8b 40 30             	mov    0x30(%eax),%eax
f010cf3a:	83 ec 08             	sub    $0x8,%esp
f010cf3d:	50                   	push   %eax
f010cf3e:	68 9c 5f 12 f0       	push   $0xf0125f9c
f010cf43:	e8 43 40 ff ff       	call   f0100f8b <cprintf>
f010cf48:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010cf4b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf4e:	8b 40 34             	mov    0x34(%eax),%eax
f010cf51:	0f b7 c0             	movzwl %ax,%eax
f010cf54:	83 ec 08             	sub    $0x8,%esp
f010cf57:	50                   	push   %eax
f010cf58:	68 ab 5f 12 f0       	push   $0xf0125fab
f010cf5d:	e8 29 40 ff ff       	call   f0100f8b <cprintf>
f010cf62:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010cf65:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf68:	8b 40 38             	mov    0x38(%eax),%eax
f010cf6b:	83 ec 08             	sub    $0x8,%esp
f010cf6e:	50                   	push   %eax
f010cf6f:	68 be 5f 12 f0       	push   $0xf0125fbe
f010cf74:	e8 12 40 ff ff       	call   f0100f8b <cprintf>
f010cf79:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010cf7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf7f:	8b 40 3c             	mov    0x3c(%eax),%eax
f010cf82:	83 ec 08             	sub    $0x8,%esp
f010cf85:	50                   	push   %eax
f010cf86:	68 cd 5f 12 f0       	push   $0xf0125fcd
f010cf8b:	e8 fb 3f ff ff       	call   f0100f8b <cprintf>
f010cf90:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010cf93:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf96:	8b 40 40             	mov    0x40(%eax),%eax
f010cf99:	0f b7 c0             	movzwl %ax,%eax
f010cf9c:	83 ec 08             	sub    $0x8,%esp
f010cf9f:	50                   	push   %eax
f010cfa0:	68 dc 5f 12 f0       	push   $0xf0125fdc
f010cfa5:	e8 e1 3f ff ff       	call   f0100f8b <cprintf>
f010cfaa:	83 c4 10             	add    $0x10,%esp
}
f010cfad:	90                   	nop
f010cfae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cfb1:	c9                   	leave  
f010cfb2:	c3                   	ret    

f010cfb3 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010cfb3:	55                   	push   %ebp
f010cfb4:	89 e5                	mov    %esp,%ebp
f010cfb6:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010cfb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfbc:	8b 00                	mov    (%eax),%eax
f010cfbe:	83 ec 08             	sub    $0x8,%esp
f010cfc1:	50                   	push   %eax
f010cfc2:	68 ef 5f 12 f0       	push   $0xf0125fef
f010cfc7:	e8 bf 3f ff ff       	call   f0100f8b <cprintf>
f010cfcc:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010cfcf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfd2:	8b 40 04             	mov    0x4(%eax),%eax
f010cfd5:	83 ec 08             	sub    $0x8,%esp
f010cfd8:	50                   	push   %eax
f010cfd9:	68 fe 5f 12 f0       	push   $0xf0125ffe
f010cfde:	e8 a8 3f ff ff       	call   f0100f8b <cprintf>
f010cfe3:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010cfe6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfe9:	8b 40 08             	mov    0x8(%eax),%eax
f010cfec:	83 ec 08             	sub    $0x8,%esp
f010cfef:	50                   	push   %eax
f010cff0:	68 0d 60 12 f0       	push   $0xf012600d
f010cff5:	e8 91 3f ff ff       	call   f0100f8b <cprintf>
f010cffa:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010cffd:	8b 45 08             	mov    0x8(%ebp),%eax
f010d000:	8b 40 0c             	mov    0xc(%eax),%eax
f010d003:	83 ec 08             	sub    $0x8,%esp
f010d006:	50                   	push   %eax
f010d007:	68 1c 60 12 f0       	push   $0xf012601c
f010d00c:	e8 7a 3f ff ff       	call   f0100f8b <cprintf>
f010d011:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d014:	8b 45 08             	mov    0x8(%ebp),%eax
f010d017:	8b 40 10             	mov    0x10(%eax),%eax
f010d01a:	83 ec 08             	sub    $0x8,%esp
f010d01d:	50                   	push   %eax
f010d01e:	68 2b 60 12 f0       	push   $0xf012602b
f010d023:	e8 63 3f ff ff       	call   f0100f8b <cprintf>
f010d028:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d02b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d02e:	8b 40 14             	mov    0x14(%eax),%eax
f010d031:	83 ec 08             	sub    $0x8,%esp
f010d034:	50                   	push   %eax
f010d035:	68 3a 60 12 f0       	push   $0xf012603a
f010d03a:	e8 4c 3f ff ff       	call   f0100f8b <cprintf>
f010d03f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d042:	8b 45 08             	mov    0x8(%ebp),%eax
f010d045:	8b 40 18             	mov    0x18(%eax),%eax
f010d048:	83 ec 08             	sub    $0x8,%esp
f010d04b:	50                   	push   %eax
f010d04c:	68 49 60 12 f0       	push   $0xf0126049
f010d051:	e8 35 3f ff ff       	call   f0100f8b <cprintf>
f010d056:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d059:	8b 45 08             	mov    0x8(%ebp),%eax
f010d05c:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d05f:	83 ec 08             	sub    $0x8,%esp
f010d062:	50                   	push   %eax
f010d063:	68 58 60 12 f0       	push   $0xf0126058
f010d068:	e8 1e 3f ff ff       	call   f0100f8b <cprintf>
f010d06d:	83 c4 10             	add    $0x10,%esp
}
f010d070:	90                   	nop
f010d071:	c9                   	leave  
f010d072:	c3                   	ret    

f010d073 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d073:	55                   	push   %ebp
f010d074:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d076:	8b 45 08             	mov    0x8(%ebp),%eax
f010d079:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d07c:	89 14 85 e0 41 5c f0 	mov    %edx,-0xfa3be20(,%eax,4)
}
f010d083:	90                   	nop
f010d084:	5d                   	pop    %ebp
f010d085:	c3                   	ret    

f010d086 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d086:	55                   	push   %ebp
f010d087:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d089:	8b 45 08             	mov    0x8(%ebp),%eax
f010d08c:	c7 04 85 e0 41 5c f0 	movl   $0x0,-0xfa3be20(,%eax,4)
f010d093:	00 00 00 00 
}
f010d097:	90                   	nop
f010d098:	5d                   	pop    %ebp
f010d099:	c3                   	ret    

f010d09a <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d09a:	55                   	push   %ebp
f010d09b:	89 e5                	mov    %esp,%ebp
f010d09d:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d0a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0a3:	8b 40 28             	mov    0x28(%eax),%eax
f010d0a6:	83 e8 20             	sub    $0x20,%eax
f010d0a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d0ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0af:	8b 04 85 e0 41 5c f0 	mov    -0xfa3be20(,%eax,4),%eax
f010d0b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d0b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d0bd:	74 0e                	je     f010d0cd <irq_dispatch+0x33>
	{
		handler(tf);
f010d0bf:	83 ec 0c             	sub    $0xc,%esp
f010d0c2:	ff 75 08             	pushl  0x8(%ebp)
f010d0c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d0c8:	ff d0                	call   *%eax
f010d0ca:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d0cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0d0:	0f b6 c0             	movzbl %al,%eax
f010d0d3:	83 ec 0c             	sub    $0xc,%esp
f010d0d6:	50                   	push   %eax
f010d0d7:	e8 8c 9f ff ff       	call   f0107068 <pic_sendEOI>
f010d0dc:	83 c4 10             	add    $0x10,%esp
}
f010d0df:	90                   	nop
f010d0e0:	c9                   	leave  
f010d0e1:	c3                   	ret    

f010d0e2 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d0e2:	55                   	push   %ebp
f010d0e3:	89 e5                	mov    %esp,%ebp
f010d0e5:	57                   	push   %edi
f010d0e6:	56                   	push   %esi
f010d0e7:	53                   	push   %ebx
f010d0e8:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d0eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0ee:	8b 40 28             	mov    0x28(%eax),%eax
f010d0f1:	83 f8 0e             	cmp    $0xe,%eax
f010d0f4:	75 51                	jne    f010d147 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d0f6:	a0 20 42 5c f0       	mov    0xf05c4220,%al
f010d0fb:	84 c0                	test   %al,%al
f010d0fd:	74 1f                	je     f010d11e <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d0ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010d102:	8b 40 30             	mov    0x30(%eax),%eax
f010d105:	89 c2                	mov    %eax,%edx
f010d107:	a0 20 42 5c f0       	mov    0xf05c4220,%al
f010d10c:	0f b6 c0             	movzbl %al,%eax
f010d10f:	01 d0                	add    %edx,%eax
f010d111:	89 c2                	mov    %eax,%edx
f010d113:	8b 45 08             	mov    0x8(%ebp),%eax
f010d116:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d119:	e9 0c 01 00 00       	jmp    f010d22a <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d11e:	83 ec 0c             	sub    $0xc,%esp
f010d121:	6a 01                	push   $0x1
f010d123:	e8 d9 12 00 00       	call   f010e401 <isPageReplacmentAlgorithmLRU>
f010d128:	83 c4 10             	add    $0x10,%esp
f010d12b:	85 c0                	test   %eax,%eax
f010d12d:	74 05                	je     f010d134 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d12f:	e8 a3 9a ff ff       	call   f0106bd7 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d134:	83 ec 0c             	sub    $0xc,%esp
f010d137:	ff 75 08             	pushl  0x8(%ebp)
f010d13a:	e8 a7 13 00 00       	call   f010e4e6 <fault_handler>
f010d13f:	83 c4 10             	add    $0x10,%esp
f010d142:	e9 e3 00 00 00       	jmp    f010d22a <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d147:	8b 45 08             	mov    0x8(%ebp),%eax
f010d14a:	8b 40 28             	mov    0x28(%eax),%eax
f010d14d:	83 f8 30             	cmp    $0x30,%eax
f010d150:	75 6e                	jne    f010d1c0 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d152:	8b 45 08             	mov    0x8(%ebp),%eax
f010d155:	8b 40 38             	mov    0x38(%eax),%eax
f010d158:	25 00 02 00 00       	and    $0x200,%eax
f010d15d:	85 c0                	test   %eax,%eax
f010d15f:	74 06                	je     f010d167 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d161:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d162:	e8 19 7b ff ff       	call   f0104c80 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d167:	8b 45 08             	mov    0x8(%ebp),%eax
f010d16a:	8b 78 04             	mov    0x4(%eax),%edi
f010d16d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d170:	8b 30                	mov    (%eax),%esi
f010d172:	8b 45 08             	mov    0x8(%ebp),%eax
f010d175:	8b 58 10             	mov    0x10(%eax),%ebx
f010d178:	8b 45 08             	mov    0x8(%ebp),%eax
f010d17b:	8b 48 18             	mov    0x18(%eax),%ecx
f010d17e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d181:	8b 50 14             	mov    0x14(%eax),%edx
f010d184:	8b 45 08             	mov    0x8(%ebp),%eax
f010d187:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d18a:	83 ec 08             	sub    $0x8,%esp
f010d18d:	57                   	push   %edi
f010d18e:	56                   	push   %esi
f010d18f:	53                   	push   %ebx
f010d190:	51                   	push   %ecx
f010d191:	52                   	push   %edx
f010d192:	50                   	push   %eax
f010d193:	e8 90 09 00 00       	call   f010db28 <syscall>
f010d198:	83 c4 20             	add    $0x20,%esp
f010d19b:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d19e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1a1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d1a4:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d1a7:	9c                   	pushf  
f010d1a8:	58                   	pop    %eax
f010d1a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d1ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d1af:	25 00 02 00 00       	and    $0x200,%eax
f010d1b4:	85 c0                	test   %eax,%eax
f010d1b6:	74 72                	je     f010d22a <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d1b8:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d1b9:	e8 9a 7a ff ff       	call   f0104c58 <kclock_stop>
f010d1be:	eb 6a                	jmp    f010d22a <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d1c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1c3:	8b 40 28             	mov    0x28(%eax),%eax
f010d1c6:	83 f8 08             	cmp    $0x8,%eax
f010d1c9:	75 17                	jne    f010d1e2 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d1cb:	83 ec 04             	sub    $0x4,%esp
f010d1ce:	68 67 60 12 f0       	push   $0xf0126067
f010d1d3:	68 22 01 00 00       	push   $0x122
f010d1d8:	68 76 60 12 f0       	push   $0xf0126076
f010d1dd:	e8 57 31 ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d1e2:	83 ec 0c             	sub    $0xc,%esp
f010d1e5:	ff 75 08             	pushl  0x8(%ebp)
f010d1e8:	e8 a3 fc ff ff       	call   f010ce90 <print_trapframe>
f010d1ed:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d1f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1f3:	8b 40 34             	mov    0x34(%eax),%eax
f010d1f6:	66 83 f8 08          	cmp    $0x8,%ax
f010d1fa:	75 17                	jne    f010d213 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d1fc:	83 ec 04             	sub    $0x4,%esp
f010d1ff:	68 87 60 12 f0       	push   $0xf0126087
f010d204:	68 2a 01 00 00       	push   $0x12a
f010d209:	68 76 60 12 f0       	push   $0xf0126076
f010d20e:	e8 26 31 ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d213:	83 ec 04             	sub    $0x4,%esp
f010d216:	68 a0 60 12 f0       	push   $0xf01260a0
f010d21b:	68 2f 01 00 00       	push   $0x12f
f010d220:	68 76 60 12 f0       	push   $0xf0126076
f010d225:	e8 0f 31 ff ff       	call   f0100339 <_panic>
		}
	}
}
f010d22a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d22d:	5b                   	pop    %ebx
f010d22e:	5e                   	pop    %esi
f010d22f:	5f                   	pop    %edi
f010d230:	5d                   	pop    %ebp
f010d231:	c3                   	ret    

f010d232 <trap>:

void trap(struct Trapframe *tf)
{
f010d232:	55                   	push   %ebp
f010d233:	89 e5                	mov    %esp,%ebp
f010d235:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d238:	e8 1b 7a ff ff       	call   f0104c58 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d23d:	9c                   	pushf  
f010d23e:	58                   	pop    %eax
f010d23f:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d242:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d245:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d248:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d24b:	25 00 02 00 00       	and    $0x200,%eax
f010d250:	85 c0                	test   %eax,%eax
f010d252:	74 25                	je     f010d279 <trap+0x47>
	{
		print_trapframe(tf);
f010d254:	83 ec 0c             	sub    $0xc,%esp
f010d257:	ff 75 08             	pushl  0x8(%ebp)
f010d25a:	e8 31 fc ff ff       	call   f010ce90 <print_trapframe>
f010d25f:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d262:	83 ec 04             	sub    $0x4,%esp
f010d265:	68 c0 60 12 f0       	push   $0xf01260c0
f010d26a:	68 45 01 00 00       	push   $0x145
f010d26f:	68 76 60 12 f0       	push   $0xf0126076
f010d274:	e8 c0 30 ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010d279:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d280:	e8 5d d6 ff ff       	call   f010a8e2 <get_cpu_proc>
f010d285:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d288:	8b 45 08             	mov    0x8(%ebp),%eax
f010d28b:	8b 40 34             	mov    0x34(%eax),%eax
f010d28e:	0f b7 c0             	movzwl %ax,%eax
f010d291:	83 e0 03             	and    $0x3,%eax
f010d294:	83 f8 03             	cmp    $0x3,%eax
f010d297:	75 54                	jne    f010d2ed <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d299:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d29d:	74 0b                	je     f010d2aa <trap+0x78>
f010d29f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d2a2:	8b 40 18             	mov    0x18(%eax),%eax
f010d2a5:	83 f8 02             	cmp    $0x2,%eax
f010d2a8:	74 19                	je     f010d2c3 <trap+0x91>
f010d2aa:	68 04 61 12 f0       	push   $0xf0126104
f010d2af:	68 32 61 12 f0       	push   $0xf0126132
f010d2b4:	68 4d 01 00 00       	push   $0x14d
f010d2b9:	68 76 60 12 f0       	push   $0xf0126076
f010d2be:	e8 76 30 ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d2c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d2c6:	8b 00                	mov    (%eax),%eax
f010d2c8:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d2cb:	74 19                	je     f010d2e6 <trap+0xb4>
f010d2cd:	68 47 61 12 f0       	push   $0xf0126147
f010d2d2:	68 32 61 12 f0       	push   $0xf0126132
f010d2d7:	68 4f 01 00 00       	push   $0x14f
f010d2dc:	68 76 60 12 f0       	push   $0xf0126076
f010d2e1:	e8 53 30 ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010d2e6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d2ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2f0:	8b 40 28             	mov    0x28(%eax),%eax
f010d2f3:	83 f8 1f             	cmp    $0x1f,%eax
f010d2f6:	76 1b                	jbe    f010d313 <trap+0xe1>
f010d2f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2fb:	8b 40 28             	mov    0x28(%eax),%eax
f010d2fe:	83 f8 2f             	cmp    $0x2f,%eax
f010d301:	77 10                	ja     f010d313 <trap+0xe1>
	{
		irq_dispatch(tf);
f010d303:	83 ec 0c             	sub    $0xc,%esp
f010d306:	ff 75 08             	pushl  0x8(%ebp)
f010d309:	e8 8c fd ff ff       	call   f010d09a <irq_dispatch>
f010d30e:	83 c4 10             	add    $0x10,%esp
f010d311:	eb 0e                	jmp    f010d321 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d313:	83 ec 0c             	sub    $0xc,%esp
f010d316:	ff 75 08             	pushl  0x8(%ebp)
f010d319:	e8 c4 fd ff ff       	call   f010d0e2 <trap_dispatch>
f010d31e:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d321:	9c                   	pushf  
f010d322:	58                   	pop    %eax
f010d323:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d326:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d329:	25 00 02 00 00       	and    $0x200,%eax
f010d32e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d331:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d335:	74 19                	je     f010d350 <trap+0x11e>
f010d337:	68 5d 61 12 f0       	push   $0xf012615d
f010d33c:	68 32 61 12 f0       	push   $0xf0126132
f010d341:	68 66 01 00 00       	push   $0x166
f010d346:	68 76 60 12 f0       	push   $0xf0126076
f010d34b:	e8 e9 2f ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d350:	e8 2b 79 ff ff       	call   f0104c80 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d355:	90                   	nop
f010d356:	c9                   	leave  
f010d357:	c3                   	ret    

f010d358 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d358:	6a 08                	push   $0x8
f010d35a:	e9 ed 00 00 00       	jmp    f010d44c <_alltraps>
f010d35f:	90                   	nop

f010d360 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d360:	6a 0e                	push   $0xe
f010d362:	e9 e5 00 00 00       	jmp    f010d44c <_alltraps>
f010d367:	90                   	nop

f010d368 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d368:	6a 00                	push   $0x0
f010d36a:	6a 20                	push   $0x20
f010d36c:	e9 db 00 00 00       	jmp    f010d44c <_alltraps>
f010d371:	90                   	nop

f010d372 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d372:	6a 00                	push   $0x0
f010d374:	6a 21                	push   $0x21
f010d376:	e9 d1 00 00 00       	jmp    f010d44c <_alltraps>
f010d37b:	90                   	nop

f010d37c <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d37c:	6a 00                	push   $0x0
f010d37e:	6a 30                	push   $0x30
f010d380:	e9 c7 00 00 00       	jmp    f010d44c <_alltraps>
f010d385:	90                   	nop

f010d386 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d386:	6a 00                	push   $0x0
f010d388:	6a 00                	push   $0x0
f010d38a:	e9 bd 00 00 00       	jmp    f010d44c <_alltraps>
f010d38f:	90                   	nop

f010d390 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d390:	6a 00                	push   $0x0
f010d392:	6a 01                	push   $0x1
f010d394:	e9 b3 00 00 00       	jmp    f010d44c <_alltraps>
f010d399:	90                   	nop

f010d39a <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d39a:	6a 00                	push   $0x0
f010d39c:	6a 02                	push   $0x2
f010d39e:	e9 a9 00 00 00       	jmp    f010d44c <_alltraps>
f010d3a3:	90                   	nop

f010d3a4 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d3a4:	6a 00                	push   $0x0
f010d3a6:	6a 03                	push   $0x3
f010d3a8:	e9 9f 00 00 00       	jmp    f010d44c <_alltraps>
f010d3ad:	90                   	nop

f010d3ae <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d3ae:	6a 00                	push   $0x0
f010d3b0:	6a 04                	push   $0x4
f010d3b2:	e9 95 00 00 00       	jmp    f010d44c <_alltraps>
f010d3b7:	90                   	nop

f010d3b8 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d3b8:	6a 00                	push   $0x0
f010d3ba:	6a 05                	push   $0x5
f010d3bc:	e9 8b 00 00 00       	jmp    f010d44c <_alltraps>
f010d3c1:	90                   	nop

f010d3c2 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d3c2:	6a 00                	push   $0x0
f010d3c4:	6a 06                	push   $0x6
f010d3c6:	e9 81 00 00 00       	jmp    f010d44c <_alltraps>
f010d3cb:	90                   	nop

f010d3cc <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d3cc:	6a 00                	push   $0x0
f010d3ce:	6a 07                	push   $0x7
f010d3d0:	eb 7a                	jmp    f010d44c <_alltraps>

f010d3d2 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d3d2:	6a 0a                	push   $0xa
f010d3d4:	eb 76                	jmp    f010d44c <_alltraps>

f010d3d6 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d3d6:	6a 0b                	push   $0xb
f010d3d8:	eb 72                	jmp    f010d44c <_alltraps>

f010d3da <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d3da:	6a 0c                	push   $0xc
f010d3dc:	eb 6e                	jmp    f010d44c <_alltraps>

f010d3de <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d3de:	6a 0d                	push   $0xd
f010d3e0:	eb 6a                	jmp    f010d44c <_alltraps>

f010d3e2 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d3e2:	6a 00                	push   $0x0
f010d3e4:	6a 10                	push   $0x10
f010d3e6:	eb 64                	jmp    f010d44c <_alltraps>

f010d3e8 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d3e8:	6a 11                	push   $0x11
f010d3ea:	eb 60                	jmp    f010d44c <_alltraps>

f010d3ec <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d3ec:	6a 00                	push   $0x0
f010d3ee:	6a 12                	push   $0x12
f010d3f0:	eb 5a                	jmp    f010d44c <_alltraps>

f010d3f2 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d3f2:	6a 00                	push   $0x0
f010d3f4:	6a 13                	push   $0x13
f010d3f6:	eb 54                	jmp    f010d44c <_alltraps>

f010d3f8 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d3f8:	6a 00                	push   $0x0
f010d3fa:	6a 22                	push   $0x22
f010d3fc:	eb 4e                	jmp    f010d44c <_alltraps>

f010d3fe <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d3fe:	6a 00                	push   $0x0
f010d400:	6a 23                	push   $0x23
f010d402:	eb 48                	jmp    f010d44c <_alltraps>

f010d404 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d404:	6a 00                	push   $0x0
f010d406:	6a 24                	push   $0x24
f010d408:	eb 42                	jmp    f010d44c <_alltraps>

f010d40a <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d40a:	6a 00                	push   $0x0
f010d40c:	6a 25                	push   $0x25
f010d40e:	eb 3c                	jmp    f010d44c <_alltraps>

f010d410 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d410:	6a 00                	push   $0x0
f010d412:	6a 26                	push   $0x26
f010d414:	eb 36                	jmp    f010d44c <_alltraps>

f010d416 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d416:	6a 00                	push   $0x0
f010d418:	6a 27                	push   $0x27
f010d41a:	eb 30                	jmp    f010d44c <_alltraps>

f010d41c <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d41c:	6a 00                	push   $0x0
f010d41e:	6a 28                	push   $0x28
f010d420:	eb 2a                	jmp    f010d44c <_alltraps>

f010d422 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d422:	6a 00                	push   $0x0
f010d424:	6a 29                	push   $0x29
f010d426:	eb 24                	jmp    f010d44c <_alltraps>

f010d428 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d428:	6a 00                	push   $0x0
f010d42a:	6a 2a                	push   $0x2a
f010d42c:	eb 1e                	jmp    f010d44c <_alltraps>

f010d42e <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d42e:	6a 00                	push   $0x0
f010d430:	6a 2b                	push   $0x2b
f010d432:	eb 18                	jmp    f010d44c <_alltraps>

f010d434 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d434:	6a 00                	push   $0x0
f010d436:	6a 2c                	push   $0x2c
f010d438:	eb 12                	jmp    f010d44c <_alltraps>

f010d43a <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d43a:	6a 00                	push   $0x0
f010d43c:	6a 2d                	push   $0x2d
f010d43e:	eb 0c                	jmp    f010d44c <_alltraps>

f010d440 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d440:	6a 00                	push   $0x0
f010d442:	6a 2e                	push   $0x2e
f010d444:	eb 06                	jmp    f010d44c <_alltraps>

f010d446 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d446:	6a 00                	push   $0x0
f010d448:	6a 2f                	push   $0x2f
f010d44a:	eb 00                	jmp    f010d44c <_alltraps>

f010d44c <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d44c:	1e                   	push   %ds
push 	%es
f010d44d:	06                   	push   %es
pushal
f010d44e:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d44f:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d453:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d455:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d457:	54                   	push   %esp
call 	trap
f010d458:	e8 d5 fd ff ff       	call   f010d232 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d45d:	59                   	pop    %ecx

f010d45e <trapret>:
.globl trapret
trapret:
popal
f010d45e:	61                   	popa   
pop 	%es
f010d45f:	07                   	pop    %es
pop 	%ds
f010d460:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d461:	83 c4 08             	add    $0x8,%esp
iret
f010d464:	cf                   	iret   

f010d465 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d465:	55                   	push   %ebp
f010d466:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d468:	8b 45 08             	mov    0x8(%ebp),%eax
f010d46b:	8b 15 a0 c9 5e f0    	mov    0xf05ec9a0,%edx
f010d471:	29 d0                	sub    %edx,%eax
f010d473:	c1 f8 03             	sar    $0x3,%eax
f010d476:	89 c2                	mov    %eax,%edx
f010d478:	89 d0                	mov    %edx,%eax
f010d47a:	c1 e0 02             	shl    $0x2,%eax
f010d47d:	01 d0                	add    %edx,%eax
f010d47f:	c1 e0 02             	shl    $0x2,%eax
f010d482:	01 d0                	add    %edx,%eax
f010d484:	c1 e0 02             	shl    $0x2,%eax
f010d487:	01 d0                	add    %edx,%eax
f010d489:	89 c1                	mov    %eax,%ecx
f010d48b:	c1 e1 08             	shl    $0x8,%ecx
f010d48e:	01 c8                	add    %ecx,%eax
f010d490:	89 c1                	mov    %eax,%ecx
f010d492:	c1 e1 10             	shl    $0x10,%ecx
f010d495:	01 c8                	add    %ecx,%eax
f010d497:	01 c0                	add    %eax,%eax
f010d499:	01 d0                	add    %edx,%eax
}
f010d49b:	5d                   	pop    %ebp
f010d49c:	c3                   	ret    

f010d49d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d49d:	55                   	push   %ebp
f010d49e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d4a0:	ff 75 08             	pushl  0x8(%ebp)
f010d4a3:	e8 bd ff ff ff       	call   f010d465 <to_frame_number>
f010d4a8:	83 c4 04             	add    $0x4,%esp
f010d4ab:	c1 e0 0c             	shl    $0xc,%eax
}
f010d4ae:	c9                   	leave  
f010d4af:	c3                   	ret    

f010d4b0 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d4b0:	55                   	push   %ebp
f010d4b1:	89 e5                	mov    %esp,%ebp
f010d4b3:	83 ec 18             	sub    $0x18,%esp
f010d4b6:	8b 45 10             	mov    0x10(%ebp),%eax
f010d4b9:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d4bc:	e8 a3 9c ff ff       	call   f0107164 <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d4c1:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d4c5:	74 23                	je     f010d4ea <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d4c7:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d4cc:	8b 40 10             	mov    0x10(%eax),%eax
f010d4cf:	8b 15 64 b1 60 f0    	mov    0xf060b164,%edx
f010d4d5:	83 c2 20             	add    $0x20,%edx
f010d4d8:	83 ec 04             	sub    $0x4,%esp
f010d4db:	50                   	push   %eax
f010d4dc:	52                   	push   %edx
f010d4dd:	68 10 63 12 f0       	push   $0xf0126310
f010d4e2:	e8 a4 3a ff ff       	call   f0100f8b <cprintf>
f010d4e7:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d4ea:	83 ec 04             	sub    $0x4,%esp
f010d4ed:	ff 75 08             	pushl  0x8(%ebp)
f010d4f0:	ff 75 0c             	pushl  0xc(%ebp)
f010d4f3:	68 19 63 12 f0       	push   $0xf0126319
f010d4f8:	e8 8e 3a ff ff       	call   f0100f8b <cprintf>
f010d4fd:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d500:	e8 b1 9c ff ff       	call   f01071b6 <popcli>
}
f010d505:	90                   	nop
f010d506:	c9                   	leave  
f010d507:	c3                   	ret    

f010d508 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d508:	55                   	push   %ebp
f010d509:	89 e5                	mov    %esp,%ebp
f010d50b:	83 ec 18             	sub    $0x18,%esp
f010d50e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d511:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d514:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d518:	83 ec 08             	sub    $0x8,%esp
f010d51b:	50                   	push   %eax
f010d51c:	68 1e 63 12 f0       	push   $0xf012631e
f010d521:	e8 65 3a ff ff       	call   f0100f8b <cprintf>
f010d526:	83 c4 10             	add    $0x10,%esp
}
f010d529:	90                   	nop
f010d52a:	c9                   	leave  
f010d52b:	c3                   	ret    

f010d52c <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d52c:	55                   	push   %ebp
f010d52d:	89 e5                	mov    %esp,%ebp
f010d52f:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d532:	9c                   	pushf  
f010d533:	58                   	pop    %eax
f010d534:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d537:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d53a:	25 00 02 00 00       	and    $0x200,%eax
f010d53f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d542:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d546:	74 10                	je     f010d558 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d548:	e8 77 38 ff ff       	call   f0100dc4 <cons_getc2>
f010d54d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d550:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d554:	74 f2                	je     f010d548 <sys_cgetc+0x1c>
f010d556:	eb 0e                	jmp    f010d566 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d558:	e8 0c 38 ff ff       	call   f0100d69 <cons_getc>
f010d55d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d560:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d564:	74 f2                	je     f010d558 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d566:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d569:	c9                   	leave  
f010d56a:	c3                   	ret    

f010d56b <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d56b:	55                   	push   %ebp
f010d56c:	89 e5                	mov    %esp,%ebp
f010d56e:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d571:	e8 3a 39 ff ff       	call   f0100eb0 <cons_lock>
}
f010d576:	90                   	nop
f010d577:	c9                   	leave  
f010d578:	c3                   	ret    

f010d579 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d579:	55                   	push   %ebp
f010d57a:	89 e5                	mov    %esp,%ebp
f010d57c:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d57f:	e8 73 39 ff ff       	call   f0100ef7 <cons_unlock>
}
f010d584:	90                   	nop
f010d585:	c9                   	leave  
f010d586:	c3                   	ret    

f010d587 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d587:	55                   	push   %ebp
f010d588:	89 e5                	mov    %esp,%ebp
f010d58a:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d58d:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d592:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d595:	83 ec 0c             	sub    $0xc,%esp
f010d598:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010d59b:	50                   	push   %eax
f010d59c:	e8 a6 ab ff ff       	call   f0108147 <allocate_frame>
f010d5a1:	83 c4 10             	add    $0x10,%esp
f010d5a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d5a7:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d5ab:	75 08                	jne    f010d5b5 <__sys_allocate_page+0x2e>
		return r ;
f010d5ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d5b0:	e9 e9 00 00 00       	jmp    f010d69e <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d5b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5b8:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d5bd:	77 0c                	ja     f010d5cb <__sys_allocate_page+0x44>
f010d5bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5c2:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d5c7:	85 c0                	test   %eax,%eax
f010d5c9:	74 0a                	je     f010d5d5 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d5cb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d5d0:	e9 c9 00 00 00       	jmp    f010d69e <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d5d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d5d8:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d5dd:	83 f8 04             	cmp    $0x4,%eax
f010d5e0:	74 0a                	je     f010d5ec <__sys_allocate_page+0x65>
		return E_INVAL;
f010d5e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d5e7:	e9 b2 00 00 00       	jmp    f010d69e <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d5ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d5ef:	83 ec 0c             	sub    $0xc,%esp
f010d5f2:	50                   	push   %eax
f010d5f3:	e8 a5 fe ff ff       	call   f010d49d <to_physical_address>
f010d5f8:	83 c4 10             	add    $0x10,%esp
f010d5fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010d5fe:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d601:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d604:	8b 40 64             	mov    0x64(%eax),%eax
f010d607:	6a 02                	push   $0x2
f010d609:	68 00 00 80 ef       	push   $0xef800000
f010d60e:	52                   	push   %edx
f010d60f:	50                   	push   %eax
f010d610:	e8 ff af ff ff       	call   f0108614 <map_frame>
f010d615:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010d618:	83 ec 04             	sub    $0x4,%esp
f010d61b:	68 00 10 00 00       	push   $0x1000
f010d620:	6a 00                	push   $0x0
f010d622:	68 00 00 80 ef       	push   $0xef800000
f010d627:	e8 b1 13 01 00       	call   f011e9dd <memset>
f010d62c:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010d62f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d632:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d635:	8b 40 08             	mov    0x8(%eax),%eax
f010d638:	40                   	inc    %eax
f010d639:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010d63d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d640:	8b 40 64             	mov    0x64(%eax),%eax
f010d643:	83 ec 08             	sub    $0x8,%esp
f010d646:	68 00 00 80 ef       	push   $0xef800000
f010d64b:	50                   	push   %eax
f010d64c:	e8 23 b1 ff ff       	call   f0108774 <unmap_frame>
f010d651:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010d654:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d657:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d65a:	8b 40 08             	mov    0x8(%eax),%eax
f010d65d:	48                   	dec    %eax
f010d65e:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d662:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d665:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d668:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d66b:	8b 40 64             	mov    0x64(%eax),%eax
f010d66e:	ff 75 0c             	pushl  0xc(%ebp)
f010d671:	51                   	push   %ecx
f010d672:	52                   	push   %edx
f010d673:	50                   	push   %eax
f010d674:	e8 9b af ff ff       	call   f0108614 <map_frame>
f010d679:	83 c4 10             	add    $0x10,%esp
f010d67c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d67f:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d683:	75 14                	jne    f010d699 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010d685:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d688:	83 ec 0c             	sub    $0xc,%esp
f010d68b:	50                   	push   %eax
f010d68c:	e8 c3 ac ff ff       	call   f0108354 <decrement_references>
f010d691:	83 c4 10             	add    $0x10,%esp
		return r;
f010d694:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d697:	eb 05                	jmp    f010d69e <__sys_allocate_page+0x117>
	}
	return 0 ;
f010d699:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d69e:	c9                   	leave  
f010d69f:	c3                   	ret    

f010d6a0 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010d6a0:	55                   	push   %ebp
f010d6a1:	89 e5                	mov    %esp,%ebp
f010d6a3:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010d6a6:	83 ec 04             	sub    $0x4,%esp
f010d6a9:	68 21 63 12 f0       	push   $0xf0126321
f010d6ae:	68 dc 00 00 00       	push   $0xdc
f010d6b3:	68 3f 63 12 f0       	push   $0xf012633f
f010d6b8:	e8 7c 2c ff ff       	call   f0100339 <_panic>

f010d6bd <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010d6bd:	55                   	push   %ebp
f010d6be:	89 e5                	mov    %esp,%ebp
f010d6c0:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010d6c3:	83 ec 04             	sub    $0x4,%esp
f010d6c6:	68 54 63 12 f0       	push   $0xf0126354
f010d6cb:	68 ed 00 00 00       	push   $0xed
f010d6d0:	68 3f 63 12 f0       	push   $0xf012633f
f010d6d5:	e8 5f 2c ff ff       	call   f0100339 <_panic>

f010d6da <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010d6da:	55                   	push   %ebp
f010d6db:	89 e5                	mov    %esp,%ebp
f010d6dd:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010d6e0:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d6e5:	8b 40 64             	mov    0x64(%eax),%eax
f010d6e8:	83 ec 04             	sub    $0x4,%esp
f010d6eb:	ff 75 0c             	pushl  0xc(%ebp)
f010d6ee:	ff 75 08             	pushl  0x8(%ebp)
f010d6f1:	50                   	push   %eax
f010d6f2:	e8 42 c5 ff ff       	call   f0109c39 <calculate_required_frames>
f010d6f7:	83 c4 10             	add    $0x10,%esp
}
f010d6fa:	c9                   	leave  
f010d6fb:	c3                   	ret    

f010d6fc <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010d6fc:	55                   	push   %ebp
f010d6fd:	89 e5                	mov    %esp,%ebp
f010d6ff:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d702:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d705:	83 ec 0c             	sub    $0xc,%esp
f010d708:	50                   	push   %eax
f010d709:	e8 e8 b1 ff ff       	call   f01088f6 <calculate_available_frames>
f010d70e:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010d711:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010d714:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d717:	01 d0                	add    %edx,%eax
}
f010d719:	c9                   	leave  
f010d71a:	c3                   	ret    

f010d71b <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010d71b:	55                   	push   %ebp
f010d71c:	89 e5                	mov    %esp,%ebp
f010d71e:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d721:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d724:	83 ec 0c             	sub    $0xc,%esp
f010d727:	50                   	push   %eax
f010d728:	e8 c9 b1 ff ff       	call   f01088f6 <calculate_available_frames>
f010d72d:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010d730:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d733:	c9                   	leave  
f010d734:	c3                   	ret    

f010d735 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010d735:	55                   	push   %ebp
f010d736:	89 e5                	mov    %esp,%ebp
f010d738:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d73b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d73e:	83 ec 0c             	sub    $0xc,%esp
f010d741:	50                   	push   %eax
f010d742:	e8 af b1 ff ff       	call   f01088f6 <calculate_available_frames>
f010d747:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010d74a:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010d74d:	c9                   	leave  
f010d74e:	c3                   	ret    

f010d74f <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010d74f:	55                   	push   %ebp
f010d750:	89 e5                	mov    %esp,%ebp
f010d752:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010d755:	83 ec 0c             	sub    $0xc,%esp
f010d758:	ff 75 08             	pushl  0x8(%ebp)
f010d75b:	e8 26 fe 00 00       	call   f011d586 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010d760:	83 c4 10             	add    $0x10,%esp
}
f010d763:	c9                   	leave  
f010d764:	c3                   	ret    

f010d765 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010d765:	55                   	push   %ebp
f010d766:	89 e5                	mov    %esp,%ebp
f010d768:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010d76b:	e8 41 fd 00 00       	call   f011d4b1 <scarce_memory>
}
f010d770:	90                   	nop
f010d771:	c9                   	leave  
f010d772:	c3                   	ret    

f010d773 <sys_clearFFL>:

void sys_clearFFL()
{
f010d773:	55                   	push   %ebp
f010d774:	89 e5                	mov    %esp,%ebp
f010d776:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010d779:	83 ec 0c             	sub    $0xc,%esp
f010d77c:	68 60 c5 5e f0       	push   $0xf05ec560
f010d781:	e8 dc 10 00 00       	call   f010e862 <acquire_spinlock>
f010d786:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010d789:	a1 4c c5 5e f0       	mov    0xf05ec54c,%eax
f010d78e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010d791:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d798:	eb 12                	jmp    f010d7ac <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010d79a:	83 ec 0c             	sub    $0xc,%esp
f010d79d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d7a0:	50                   	push   %eax
f010d7a1:	e8 a1 a9 ff ff       	call   f0108147 <allocate_frame>
f010d7a6:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010d7a9:	ff 45 f4             	incl   -0xc(%ebp)
f010d7ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d7af:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010d7b2:	7c e6                	jl     f010d79a <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d7b4:	83 ec 0c             	sub    $0xc,%esp
f010d7b7:	68 60 c5 5e f0       	push   $0xf05ec560
f010d7bc:	e8 28 11 00 00       	call   f010e8e9 <release_spinlock>
f010d7c1:	83 c4 10             	add    $0x10,%esp
}
f010d7c4:	90                   	nop
f010d7c5:	c9                   	leave  
f010d7c6:	c3                   	ret    

f010d7c7 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010d7c7:	55                   	push   %ebp
f010d7c8:	89 e5                	mov    %esp,%ebp
f010d7ca:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010d7cd:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d7d2:	83 ec 0c             	sub    $0xc,%esp
f010d7d5:	50                   	push   %eax
f010d7d6:	e8 eb 6f ff ff       	call   f01047c6 <pf_calculate_allocated_pages>
f010d7db:	83 c4 10             	add    $0x10,%esp
}
f010d7de:	c9                   	leave  
f010d7df:	c3                   	ret    

f010d7e0 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010d7e0:	55                   	push   %ebp
f010d7e1:	89 e5                	mov    %esp,%ebp
f010d7e3:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010d7e6:	e8 d9 0c 00 00       	call   f010e4c4 <isBufferingEnabled>
f010d7eb:	84 c0                	test   %al,%al
f010d7ed:	74 19                	je     f010d808 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010d7ef:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d7f4:	83 ec 04             	sub    $0x4,%esp
f010d7f7:	ff 75 0c             	pushl  0xc(%ebp)
f010d7fa:	ff 75 08             	pushl  0x8(%ebp)
f010d7fd:	50                   	push   %eax
f010d7fe:	e8 94 c4 ff ff       	call   f0109c97 <__free_user_mem_with_buffering>
f010d803:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010d806:	eb 18                	jmp    f010d820 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010d808:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d80d:	83 ec 04             	sub    $0x4,%esp
f010d810:	ff 75 0c             	pushl  0xc(%ebp)
f010d813:	ff 75 08             	pushl  0x8(%ebp)
f010d816:	50                   	push   %eax
f010d817:	e8 5e c4 ff ff       	call   f0109c7a <free_user_mem>
f010d81c:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010d81f:	90                   	nop
}
f010d820:	c9                   	leave  
f010d821:	c3                   	ret    

f010d822 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010d822:	55                   	push   %ebp
f010d823:	89 e5                	mov    %esp,%ebp
f010d825:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010d828:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d82c:	75 07                	jne    f010d835 <check_Param+0x13>
	{
		env_exit();
f010d82e:	e8 6d d0 ff ff       	call   f010a8a0 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010d833:	eb 25                	jmp    f010d85a <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010d835:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010d83c:	77 07                	ja     f010d845 <check_Param+0x23>
f010d83e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d841:	85 c0                	test   %eax,%eax
f010d843:	78 07                	js     f010d84c <check_Param+0x2a>
	{
		env_exit();
f010d845:	e8 56 d0 ff ff       	call   f010a8a0 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010d84a:	eb 0e                	jmp    f010d85a <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010d84c:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010d853:	76 05                	jbe    f010d85a <check_Param+0x38>
	{
		env_exit();
f010d855:	e8 46 d0 ff ff       	call   f010a8a0 <env_exit>
	}
}
f010d85a:	90                   	nop
f010d85b:	c9                   	leave  
f010d85c:	c3                   	ret    

f010d85d <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010d85d:	55                   	push   %ebp
f010d85e:	89 e5                	mov    %esp,%ebp
f010d860:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010d863:	83 ec 0c             	sub    $0xc,%esp
f010d866:	ff 75 08             	pushl  0x8(%ebp)
f010d869:	e8 b4 ff ff ff       	call   f010d822 <check_Param>
f010d86e:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010d871:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d876:	83 ec 04             	sub    $0x4,%esp
f010d879:	ff 75 0c             	pushl  0xc(%ebp)
f010d87c:	ff 75 08             	pushl  0x8(%ebp)
f010d87f:	50                   	push   %eax
f010d880:	e8 d8 c3 ff ff       	call   f0109c5d <allocate_user_mem>
f010d885:	83 c4 10             	add    $0x10,%esp
	return;
f010d888:	90                   	nop
}
f010d889:	c9                   	leave  
f010d88a:	c3                   	ret    

f010d88b <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010d88b:	55                   	push   %ebp
f010d88c:	89 e5                	mov    %esp,%ebp
f010d88e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010d891:	83 ec 0c             	sub    $0xc,%esp
f010d894:	ff 75 08             	pushl  0x8(%ebp)
f010d897:	e8 86 ff ff ff       	call   f010d822 <check_Param>
f010d89c:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010d89f:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d8a4:	8b 40 64             	mov    0x64(%eax),%eax
f010d8a7:	ff 75 10             	pushl  0x10(%ebp)
f010d8aa:	ff 75 0c             	pushl  0xc(%ebp)
f010d8ad:	ff 75 08             	pushl  0x8(%ebp)
f010d8b0:	50                   	push   %eax
f010d8b1:	e8 4f c3 ff ff       	call   f0109c05 <allocate_chunk>
f010d8b6:	83 c4 10             	add    $0x10,%esp
	return;
f010d8b9:	90                   	nop
}
f010d8ba:	c9                   	leave  
f010d8bb:	c3                   	ret    

f010d8bc <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010d8bc:	55                   	push   %ebp
f010d8bd:	89 e5                	mov    %esp,%ebp
f010d8bf:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010d8c2:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d8c7:	ff 75 10             	pushl  0x10(%ebp)
f010d8ca:	ff 75 0c             	pushl  0xc(%ebp)
f010d8cd:	ff 75 08             	pushl  0x8(%ebp)
f010d8d0:	50                   	push   %eax
f010d8d1:	e8 de c3 ff ff       	call   f0109cb4 <move_user_mem>
f010d8d6:	83 c4 10             	add    $0x10,%esp
	return;
f010d8d9:	90                   	nop
}
f010d8da:	c9                   	leave  
f010d8db:	c3                   	ret    

f010d8dc <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010d8dc:	55                   	push   %ebp
f010d8dd:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010d8df:	a1 84 c9 5e f0       	mov    0xf05ec984,%eax
}
f010d8e4:	5d                   	pop    %ebp
f010d8e5:	c3                   	ret    

f010d8e6 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010d8e6:	55                   	push   %ebp
f010d8e7:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010d8e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8ec:	a3 84 c9 5e f0       	mov    %eax,0xf05ec984
}
f010d8f1:	90                   	nop
f010d8f2:	5d                   	pop    %ebp
f010d8f3:	c3                   	ret    

f010d8f4 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010d8f4:	55                   	push   %ebp
f010d8f5:	89 e5                	mov    %esp,%ebp
f010d8f7:	83 ec 18             	sub    $0x18,%esp
f010d8fa:	8b 45 10             	mov    0x10(%ebp),%eax
f010d8fd:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010d900:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010d904:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d909:	8b 40 10             	mov    0x10(%eax),%eax
f010d90c:	83 ec 0c             	sub    $0xc,%esp
f010d90f:	ff 75 14             	pushl  0x14(%ebp)
f010d912:	52                   	push   %edx
f010d913:	ff 75 0c             	pushl  0xc(%ebp)
f010d916:	ff 75 08             	pushl  0x8(%ebp)
f010d919:	50                   	push   %eax
f010d91a:	e8 79 b1 ff ff       	call   f0108a98 <createSharedObject>
f010d91f:	83 c4 20             	add    $0x20,%esp
}
f010d922:	c9                   	leave  
f010d923:	c3                   	ret    

f010d924 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010d924:	55                   	push   %ebp
f010d925:	89 e5                	mov    %esp,%ebp
f010d927:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010d92a:	83 ec 08             	sub    $0x8,%esp
f010d92d:	ff 75 0c             	pushl  0xc(%ebp)
f010d930:	ff 75 08             	pushl  0x8(%ebp)
f010d933:	e8 dd b0 ff ff       	call   f0108a15 <getSizeOfSharedObject>
f010d938:	83 c4 10             	add    $0x10,%esp
}
f010d93b:	c9                   	leave  
f010d93c:	c3                   	ret    

f010d93d <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010d93d:	55                   	push   %ebp
f010d93e:	89 e5                	mov    %esp,%ebp
f010d940:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010d943:	83 ec 04             	sub    $0x4,%esp
f010d946:	ff 75 10             	pushl  0x10(%ebp)
f010d949:	ff 75 0c             	pushl  0xc(%ebp)
f010d94c:	ff 75 08             	pushl  0x8(%ebp)
f010d94f:	e8 64 b1 ff ff       	call   f0108ab8 <getSharedObject>
f010d954:	83 c4 10             	add    $0x10,%esp
}
f010d957:	c9                   	leave  
f010d958:	c3                   	ret    

f010d959 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010d959:	55                   	push   %ebp
f010d95a:	89 e5                	mov    %esp,%ebp
f010d95c:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010d95f:	83 ec 08             	sub    $0x8,%esp
f010d962:	ff 75 0c             	pushl  0xc(%ebp)
f010d965:	ff 75 08             	pushl  0x8(%ebp)
f010d968:	e8 82 b1 ff ff       	call   f0108aef <freeSharedObject>
f010d96d:	83 c4 10             	add    $0x10,%esp
}
f010d970:	c9                   	leave  
f010d971:	c3                   	ret    

f010d972 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010d972:	55                   	push   %ebp
f010d973:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010d975:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d97a:	8b 40 10             	mov    0x10(%eax),%eax
}
f010d97d:	5d                   	pop    %ebp
f010d97e:	c3                   	ret    

f010d97f <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010d97f:	55                   	push   %ebp
f010d980:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010d982:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d987:	89 c2                	mov    %eax,%edx
f010d989:	a1 b0 39 5c f0       	mov    0xf05c39b0,%eax
f010d98e:	29 c2                	sub    %eax,%edx
f010d990:	89 d0                	mov    %edx,%eax
f010d992:	c1 f8 04             	sar    $0x4,%eax
f010d995:	89 c2                	mov    %eax,%edx
f010d997:	89 d0                	mov    %edx,%eax
f010d999:	c1 e0 09             	shl    $0x9,%eax
f010d99c:	29 d0                	sub    %edx,%eax
f010d99e:	c1 e0 03             	shl    $0x3,%eax
f010d9a1:	01 d0                	add    %edx,%eax
f010d9a3:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010d9aa:	01 c8                	add    %ecx,%eax
f010d9ac:	c1 e0 03             	shl    $0x3,%eax
f010d9af:	01 d0                	add    %edx,%eax
f010d9b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010d9b8:	01 d0                	add    %edx,%eax
f010d9ba:	89 c2                	mov    %eax,%edx
f010d9bc:	c1 e2 09             	shl    $0x9,%edx
f010d9bf:	01 d0                	add    %edx,%eax
f010d9c1:	f7 d8                	neg    %eax
}
f010d9c3:	5d                   	pop    %ebp
f010d9c4:	c3                   	ret    

f010d9c5 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010d9c5:	55                   	push   %ebp
f010d9c6:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010d9c8:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d9cd:	8b 40 14             	mov    0x14(%eax),%eax
}
f010d9d0:	5d                   	pop    %ebp
f010d9d1:	c3                   	ret    

f010d9d2 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010d9d2:	55                   	push   %ebp
f010d9d3:	89 e5                	mov    %esp,%ebp
f010d9d5:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010d9d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d9dc:	75 0a                	jne    f010d9e8 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010d9de:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010d9e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010d9e6:	eb 22                	jmp    f010da0a <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010d9e8:	83 ec 04             	sub    $0x4,%esp
f010d9eb:	6a 00                	push   $0x0
f010d9ed:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010d9f0:	50                   	push   %eax
f010d9f1:	ff 75 08             	pushl  0x8(%ebp)
f010d9f4:	e8 39 cf ff ff       	call   f010a932 <envid2env>
f010d9f9:	83 c4 10             	add    $0x10,%esp
f010d9fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d9ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010da03:	79 05                	jns    f010da0a <sys_destroy_env+0x38>
	{
		return r;
f010da05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da08:	eb 5e                	jmp    f010da68 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010da0a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010da0d:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010da12:	39 c2                	cmp    %eax,%edx
f010da14:	75 1b                	jne    f010da31 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010da16:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010da1b:	8b 40 10             	mov    0x10(%eax),%eax
f010da1e:	83 ec 08             	sub    $0x8,%esp
f010da21:	50                   	push   %eax
f010da22:	68 73 63 12 f0       	push   $0xf0126373
f010da27:	e8 5f 35 ff ff       	call   f0100f8b <cprintf>
f010da2c:	83 c4 10             	add    $0x10,%esp
f010da2f:	eb 20                	jmp    f010da51 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010da31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da34:	8b 50 10             	mov    0x10(%eax),%edx
f010da37:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010da3c:	8b 40 10             	mov    0x10(%eax),%eax
f010da3f:	83 ec 04             	sub    $0x4,%esp
f010da42:	52                   	push   %edx
f010da43:	50                   	push   %eax
f010da44:	68 8e 63 12 f0       	push   $0xf012638e
f010da49:	e8 3d 35 ff ff       	call   f0100f8b <cprintf>
f010da4e:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010da51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da54:	8b 40 10             	mov    0x10(%eax),%eax
f010da57:	83 ec 0c             	sub    $0xc,%esp
f010da5a:	50                   	push   %eax
f010da5b:	e8 f6 7f ff ff       	call   f0105a56 <sched_kill_env>
f010da60:	83 c4 10             	add    $0x10,%esp

	return 0;
f010da63:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010da68:	c9                   	leave  
f010da69:	c3                   	ret    

f010da6a <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010da6a:	55                   	push   %ebp
f010da6b:	89 e5                	mov    %esp,%ebp
f010da6d:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010da70:	e8 2b ce ff ff       	call   f010a8a0 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010da75:	90                   	nop
f010da76:	c9                   	leave  
f010da77:	c3                   	ret    

f010da78 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010da78:	55                   	push   %ebp
f010da79:	89 e5                	mov    %esp,%ebp
f010da7b:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010da7e:	ff 75 14             	pushl  0x14(%ebp)
f010da81:	ff 75 10             	pushl  0x10(%ebp)
f010da84:	ff 75 0c             	pushl  0xc(%ebp)
f010da87:	ff 75 08             	pushl  0x8(%ebp)
f010da8a:	e8 d5 c3 ff ff       	call   f0109e64 <env_create>
f010da8f:	83 c4 10             	add    $0x10,%esp
f010da92:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010da95:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010da99:	75 07                	jne    f010daa2 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010da9b:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010daa0:	eb 14                	jmp    f010dab6 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010daa2:	83 ec 0c             	sub    $0xc,%esp
f010daa5:	ff 75 f4             	pushl  -0xc(%ebp)
f010daa8:	e8 0d 7c ff ff       	call   f01056ba <sched_new_env>
f010daad:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010dab0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dab3:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dab6:	c9                   	leave  
f010dab7:	c3                   	ret    

f010dab8 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010dab8:	55                   	push   %ebp
f010dab9:	89 e5                	mov    %esp,%ebp
f010dabb:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010dabe:	8b 45 08             	mov    0x8(%ebp),%eax
f010dac1:	83 ec 0c             	sub    $0xc,%esp
f010dac4:	50                   	push   %eax
f010dac5:	e8 46 7c ff ff       	call   f0105710 <sched_run_env>
f010daca:	83 c4 10             	add    $0x10,%esp
}
f010dacd:	90                   	nop
f010dace:	c9                   	leave  
f010dacf:	c3                   	ret    

f010dad0 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010dad0:	55                   	push   %ebp
f010dad1:	89 e5                	mov    %esp,%ebp
f010dad3:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010dad6:	0f 31                	rdtsc  
f010dad8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010dadb:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010dade:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dae1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010dae4:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010dae7:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010daea:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010daed:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010daf0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010daf3:	89 01                	mov    %eax,(%ecx)
f010daf5:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010daf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010dafb:	c9                   	leave  
f010dafc:	c2 04 00             	ret    $0x4

f010daff <sys_rcr2>:

uint32 sys_rcr2()
{
f010daff:	55                   	push   %ebp
f010db00:	89 e5                	mov    %esp,%ebp
f010db02:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010db05:	0f 20 d0             	mov    %cr2,%eax
f010db08:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010db0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010db0e:	90                   	nop
}
f010db0f:	c9                   	leave  
f010db10:	c3                   	ret    

f010db11 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010db11:	55                   	push   %ebp
f010db12:	89 e5                	mov    %esp,%ebp
f010db14:	83 ec 04             	sub    $0x4,%esp
f010db17:	8b 45 08             	mov    0x8(%ebp),%eax
f010db1a:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010db1d:	8a 45 fc             	mov    -0x4(%ebp),%al
f010db20:	a2 20 42 5c f0       	mov    %al,0xf05c4220
}
f010db25:	90                   	nop
f010db26:	c9                   	leave  
f010db27:	c3                   	ret    

f010db28 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010db28:	55                   	push   %ebp
f010db29:	89 e5                	mov    %esp,%ebp
f010db2b:	56                   	push   %esi
f010db2c:	53                   	push   %ebx
f010db2d:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010db30:	e8 ad cd ff ff       	call   f010a8e2 <get_cpu_proc>
f010db35:	a3 64 b1 60 f0       	mov    %eax,0xf060b164
	assert(cur_env != NULL);
f010db3a:	a1 64 b1 60 f0       	mov    0xf060b164,%eax
f010db3f:	85 c0                	test   %eax,%eax
f010db41:	75 19                	jne    f010db5c <syscall+0x34>
f010db43:	68 a6 63 12 f0       	push   $0xf01263a6
f010db48:	68 b6 63 12 f0       	push   $0xf01263b6
f010db4d:	68 05 02 00 00       	push   $0x205
f010db52:	68 3f 63 12 f0       	push   $0xf012633f
f010db57:	e8 dd 27 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010db5c:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010db60:	0f 87 06 04 00 00    	ja     f010df6c <syscall+0x444>
f010db66:	8b 45 08             	mov    0x8(%ebp),%eax
f010db69:	c1 e0 02             	shl    $0x2,%eax
f010db6c:	05 cc 63 12 f0       	add    $0xf01263cc,%eax
f010db71:	8b 00                	mov    (%eax),%eax
f010db73:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010db75:	8b 45 0c             	mov    0xc(%ebp),%eax
f010db78:	83 ec 0c             	sub    $0xc,%esp
f010db7b:	50                   	push   %eax
f010db7c:	e8 d2 c0 ff ff       	call   f0109c53 <sys_sbrk>
f010db81:	83 c4 10             	add    $0x10,%esp
f010db84:	e9 e8 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010db89:	83 ec 08             	sub    $0x8,%esp
f010db8c:	ff 75 10             	pushl  0x10(%ebp)
f010db8f:	ff 75 0c             	pushl  0xc(%ebp)
f010db92:	e8 49 fc ff ff       	call   f010d7e0 <sys_free_user_mem>
f010db97:	83 c4 10             	add    $0x10,%esp
		return 0;
f010db9a:	b8 00 00 00 00       	mov    $0x0,%eax
f010db9f:	e9 cd 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010dba4:	83 ec 08             	sub    $0x8,%esp
f010dba7:	ff 75 10             	pushl  0x10(%ebp)
f010dbaa:	ff 75 0c             	pushl  0xc(%ebp)
f010dbad:	e8 ab fc ff ff       	call   f010d85d <sys_allocate_user_mem>
f010dbb2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dbb5:	b8 00 00 00 00       	mov    $0x0,%eax
f010dbba:	e9 b2 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010dbbf:	8b 45 14             	mov    0x14(%ebp),%eax
f010dbc2:	0f b6 d0             	movzbl %al,%edx
f010dbc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dbc8:	83 ec 04             	sub    $0x4,%esp
f010dbcb:	52                   	push   %edx
f010dbcc:	ff 75 10             	pushl  0x10(%ebp)
f010dbcf:	50                   	push   %eax
f010dbd0:	e8 db f8 ff ff       	call   f010d4b0 <sys_cputs>
f010dbd5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dbd8:	b8 00 00 00 00       	mov    $0x0,%eax
f010dbdd:	e9 8f 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010dbe2:	e8 45 f9 ff ff       	call   f010d52c <sys_cgetc>
f010dbe7:	e9 85 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010dbec:	e8 7a f9 ff ff       	call   f010d56b <sys_lock_cons>
		return 0;
f010dbf1:	b8 00 00 00 00       	mov    $0x0,%eax
f010dbf6:	e9 76 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010dbfb:	e8 79 f9 ff ff       	call   f010d579 <sys_unlock_cons>
		return 0;
f010dc00:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc05:	e9 67 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010dc0a:	83 ec 08             	sub    $0x8,%esp
f010dc0d:	ff 75 10             	pushl  0x10(%ebp)
f010dc10:	ff 75 0c             	pushl  0xc(%ebp)
f010dc13:	e8 c2 fa ff ff       	call   f010d6da <sys_calculate_required_frames>
f010dc18:	83 c4 10             	add    $0x10,%esp
f010dc1b:	e9 51 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010dc20:	e8 d7 fa ff ff       	call   f010d6fc <sys_calculate_free_frames>
f010dc25:	e9 47 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010dc2a:	e8 ec fa ff ff       	call   f010d71b <sys_calculate_modified_frames>
f010dc2f:	e9 3d 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010dc34:	e8 fc fa ff ff       	call   f010d735 <sys_calculate_notmod_frames>
f010dc39:	e9 33 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010dc3e:	e8 84 fb ff ff       	call   f010d7c7 <sys_pf_calculate_allocated_pages>
f010dc43:	e9 29 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010dc48:	83 ec 0c             	sub    $0xc,%esp
f010dc4b:	ff 75 0c             	pushl  0xc(%ebp)
f010dc4e:	e8 fc fa ff ff       	call   f010d74f <sys_calculate_pages_tobe_removed_ready_exit>
f010dc53:	83 c4 10             	add    $0x10,%esp
f010dc56:	e9 16 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010dc5b:	e8 05 fb ff ff       	call   f010d765 <sys_scarce_memory>
		return 0;
f010dc60:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc65:	e9 07 03 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010dc6a:	83 ec 04             	sub    $0x4,%esp
f010dc6d:	ff 75 14             	pushl  0x14(%ebp)
f010dc70:	ff 75 10             	pushl  0x10(%ebp)
f010dc73:	ff 75 0c             	pushl  0xc(%ebp)
f010dc76:	e8 10 fc ff ff       	call   f010d88b <sys_allocate_chunk>
f010dc7b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc7e:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc83:	e9 e9 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010dc88:	8b 55 10             	mov    0x10(%ebp),%edx
f010dc8b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc8e:	83 ec 08             	sub    $0x8,%esp
f010dc91:	52                   	push   %edx
f010dc92:	50                   	push   %eax
f010dc93:	e8 ef f8 ff ff       	call   f010d587 <__sys_allocate_page>
f010dc98:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc9b:	b8 00 00 00 00       	mov    $0x0,%eax
f010dca0:	e9 cc 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010dca5:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010dca8:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010dcab:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dcae:	8b 55 10             	mov    0x10(%ebp),%edx
f010dcb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcb4:	83 ec 0c             	sub    $0xc,%esp
f010dcb7:	56                   	push   %esi
f010dcb8:	53                   	push   %ebx
f010dcb9:	51                   	push   %ecx
f010dcba:	52                   	push   %edx
f010dcbb:	50                   	push   %eax
f010dcbc:	e8 df f9 ff ff       	call   f010d6a0 <__sys_map_frame>
f010dcc1:	83 c4 20             	add    $0x20,%esp
		return 0;
f010dcc4:	b8 00 00 00 00       	mov    $0x0,%eax
f010dcc9:	e9 a3 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010dcce:	8b 55 10             	mov    0x10(%ebp),%edx
f010dcd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcd4:	83 ec 08             	sub    $0x8,%esp
f010dcd7:	52                   	push   %edx
f010dcd8:	50                   	push   %eax
f010dcd9:	e8 df f9 ff ff       	call   f010d6bd <__sys_unmap_frame>
f010dcde:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dce1:	b8 00 00 00 00       	mov    $0x0,%eax
f010dce6:	e9 86 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010dceb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcee:	0f be c0             	movsbl %al,%eax
f010dcf1:	83 ec 0c             	sub    $0xc,%esp
f010dcf4:	50                   	push   %eax
f010dcf5:	e8 0e f8 ff ff       	call   f010d508 <sys_cputc>
f010dcfa:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dcfd:	b8 00 00 00 00       	mov    $0x0,%eax
f010dd02:	e9 6a 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010dd07:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd0a:	0f be c0             	movsbl %al,%eax
f010dd0d:	83 ec 0c             	sub    $0xc,%esp
f010dd10:	50                   	push   %eax
f010dd11:	e8 5d fa ff ff       	call   f010d773 <sys_clearFFL>
f010dd16:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dd19:	b8 00 00 00 00       	mov    $0x0,%eax
f010dd1e:	e9 4e 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010dd23:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010dd26:	8b 45 14             	mov    0x14(%ebp),%eax
f010dd29:	0f b6 d0             	movzbl %al,%edx
f010dd2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd2f:	51                   	push   %ecx
f010dd30:	52                   	push   %edx
f010dd31:	ff 75 10             	pushl  0x10(%ebp)
f010dd34:	50                   	push   %eax
f010dd35:	e8 ba fb ff ff       	call   f010d8f4 <sys_createSharedObject>
f010dd3a:	83 c4 10             	add    $0x10,%esp
f010dd3d:	e9 2f 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010dd42:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dd45:	8b 55 10             	mov    0x10(%ebp),%edx
f010dd48:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd4b:	83 ec 04             	sub    $0x4,%esp
f010dd4e:	51                   	push   %ecx
f010dd4f:	52                   	push   %edx
f010dd50:	50                   	push   %eax
f010dd51:	e8 e7 fb ff ff       	call   f010d93d <sys_getSharedObject>
f010dd56:	83 c4 10             	add    $0x10,%esp
f010dd59:	e9 13 02 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010dd5e:	8b 55 10             	mov    0x10(%ebp),%edx
f010dd61:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd64:	83 ec 08             	sub    $0x8,%esp
f010dd67:	52                   	push   %edx
f010dd68:	50                   	push   %eax
f010dd69:	e8 eb fb ff ff       	call   f010d959 <sys_freeSharedObject>
f010dd6e:	83 c4 10             	add    $0x10,%esp
f010dd71:	e9 fb 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010dd76:	8b 55 10             	mov    0x10(%ebp),%edx
f010dd79:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd7c:	83 ec 08             	sub    $0x8,%esp
f010dd7f:	52                   	push   %edx
f010dd80:	50                   	push   %eax
f010dd81:	e8 9e fb ff ff       	call   f010d924 <sys_getSizeOfSharedObject>
f010dd86:	83 c4 10             	add    $0x10,%esp
f010dd89:	e9 e3 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010dd8e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd91:	ff 75 18             	pushl  0x18(%ebp)
f010dd94:	ff 75 14             	pushl  0x14(%ebp)
f010dd97:	ff 75 10             	pushl  0x10(%ebp)
f010dd9a:	50                   	push   %eax
f010dd9b:	e8 d8 fc ff ff       	call   f010da78 <sys_create_env>
f010dda0:	83 c4 10             	add    $0x10,%esp
f010dda3:	e9 c9 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010dda8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ddab:	83 ec 0c             	sub    $0xc,%esp
f010ddae:	50                   	push   %eax
f010ddaf:	e8 04 fd ff ff       	call   f010dab8 <sys_run_env>
f010ddb4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ddb7:	b8 00 00 00 00       	mov    $0x0,%eax
f010ddbc:	e9 b0 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010ddc1:	e8 b9 fb ff ff       	call   f010d97f <sys_getenvindex>
f010ddc6:	e9 a6 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010ddcb:	e8 a2 fb ff ff       	call   f010d972 <sys_getenvid>
f010ddd0:	e9 9c 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010ddd5:	e8 eb fb ff ff       	call   f010d9c5 <sys_getparentenvid>
f010ddda:	e9 92 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010dddf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dde2:	83 ec 0c             	sub    $0xc,%esp
f010dde5:	50                   	push   %eax
f010dde6:	e8 e7 fb ff ff       	call   f010d9d2 <sys_destroy_env>
f010ddeb:	83 c4 10             	add    $0x10,%esp
f010ddee:	e9 7e 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010ddf3:	e8 72 fc ff ff       	call   f010da6a <sys_exit_env>
		return 0;
f010ddf8:	b8 00 00 00 00       	mov    $0x0,%eax
f010ddfd:	e9 6f 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010de02:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010de05:	83 ec 0c             	sub    $0xc,%esp
f010de08:	50                   	push   %eax
f010de09:	e8 c2 fc ff ff       	call   f010dad0 <sys_get_virtual_time>
f010de0e:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010de11:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de14:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010de17:	8b 45 10             	mov    0x10(%ebp),%eax
f010de1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010de1d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010de20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010de23:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010de25:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010de28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010de2b:	89 10                	mov    %edx,(%eax)
		return 0;
f010de2d:	b8 00 00 00 00       	mov    $0x0,%eax
f010de32:	e9 3a 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010de37:	83 ec 04             	sub    $0x4,%esp
f010de3a:	ff 75 14             	pushl  0x14(%ebp)
f010de3d:	ff 75 10             	pushl  0x10(%ebp)
f010de40:	ff 75 0c             	pushl  0xc(%ebp)
f010de43:	e8 74 fa ff ff       	call   f010d8bc <sys_move_user_mem>
f010de48:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de4b:	b8 00 00 00 00       	mov    $0x0,%eax
f010de50:	e9 1c 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010de55:	e8 a5 fc ff ff       	call   f010daff <sys_rcr2>
f010de5a:	e9 12 01 00 00       	jmp    f010df71 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010de5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de62:	0f b6 c0             	movzbl %al,%eax
f010de65:	83 ec 0c             	sub    $0xc,%esp
f010de68:	50                   	push   %eax
f010de69:	e8 a3 fc ff ff       	call   f010db11 <sys_bypassPageFault>
f010de6e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de71:	b8 00 00 00 00       	mov    $0x0,%eax
f010de76:	e9 f6 00 00 00       	jmp    f010df71 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010de7b:	e8 e5 ec 00 00       	call   f011cb65 <rsttst>
		return 0;
f010de80:	b8 00 00 00 00       	mov    $0x0,%eax
f010de85:	e9 e7 00 00 00       	jmp    f010df71 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010de8a:	e8 1e ed 00 00       	call   f011cbad <inctst>
		return 0;
f010de8f:	b8 00 00 00 00       	mov    $0x0,%eax
f010de94:	e9 d8 00 00 00       	jmp    f010df71 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010de99:	83 ec 0c             	sub    $0xc,%esp
f010de9c:	ff 75 0c             	pushl  0xc(%ebp)
f010de9f:	e8 4b ee 00 00       	call   f011ccef <chktst>
f010dea4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dea7:	b8 00 00 00 00       	mov    $0x0,%eax
f010deac:	e9 c0 00 00 00       	jmp    f010df71 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010deb1:	e8 2b ed 00 00       	call   f011cbe1 <gettst>
f010deb6:	e9 b6 00 00 00       	jmp    f010df71 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010debb:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010debe:	8b 45 18             	mov    0x18(%ebp),%eax
f010dec1:	0f be c0             	movsbl %al,%eax
f010dec4:	83 ec 0c             	sub    $0xc,%esp
f010dec7:	52                   	push   %edx
f010dec8:	50                   	push   %eax
f010dec9:	ff 75 14             	pushl  0x14(%ebp)
f010decc:	ff 75 10             	pushl  0x10(%ebp)
f010decf:	ff 75 0c             	pushl  0xc(%ebp)
f010ded2:	e8 14 ed 00 00       	call   f011cbeb <tst>
f010ded7:	83 c4 20             	add    $0x20,%esp
		return 0;
f010deda:	b8 00 00 00 00       	mov    $0x0,%eax
f010dedf:	e9 8d 00 00 00       	jmp    f010df71 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010dee4:	e8 f3 f9 ff ff       	call   f010d8dc <sys_get_heap_strategy>
f010dee9:	e9 83 00 00 00       	jmp    f010df71 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010deee:	83 ec 0c             	sub    $0xc,%esp
f010def1:	ff 75 0c             	pushl  0xc(%ebp)
f010def4:	e8 ed f9 ff ff       	call   f010d8e6 <sys_set_uheap_strategy>
f010def9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010defc:	b8 00 00 00 00       	mov    $0x0,%eax
f010df01:	eb 6e                	jmp    f010df71 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010df03:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010df06:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010df09:	8b 55 10             	mov    0x10(%ebp),%edx
f010df0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df0f:	53                   	push   %ebx
f010df10:	51                   	push   %ecx
f010df11:	52                   	push   %edx
f010df12:	50                   	push   %eax
f010df13:	e8 c1 1b 00 00       	call   f010fad9 <sys_check_LRU_lists>
f010df18:	83 c4 10             	add    $0x10,%esp
f010df1b:	eb 54                	jmp    f010df71 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010df1d:	8b 55 10             	mov    0x10(%ebp),%edx
f010df20:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df23:	83 ec 08             	sub    $0x8,%esp
f010df26:	52                   	push   %edx
f010df27:	50                   	push   %eax
f010df28:	e8 6e 1d 00 00       	call   f010fc9b <sys_check_LRU_lists_free>
f010df2d:	83 c4 10             	add    $0x10,%esp
f010df30:	eb 3f                	jmp    f010df71 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010df32:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010df35:	8b 55 10             	mov    0x10(%ebp),%edx
f010df38:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df3b:	51                   	push   %ecx
f010df3c:	ff 75 14             	pushl  0x14(%ebp)
f010df3f:	52                   	push   %edx
f010df40:	50                   	push   %eax
f010df41:	e8 e2 1e 00 00       	call   f010fe28 <sys_check_WS_list>
f010df46:	83 c4 10             	add    $0x10,%esp
f010df49:	eb 26                	jmp    f010df71 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010df4b:	8b 55 10             	mov    0x10(%ebp),%edx
f010df4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df51:	83 ec 08             	sub    $0x8,%esp
f010df54:	52                   	push   %edx
f010df55:	50                   	push   %eax
f010df56:	e8 95 ef 00 00       	call   f011cef0 <sys_utilities>
f010df5b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010df5e:	b8 00 00 00 00       	mov    $0x0,%eax
f010df63:	eb 0c                	jmp    f010df71 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010df65:	b8 03 00 00 00       	mov    $0x3,%eax
f010df6a:	eb 05                	jmp    f010df71 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010df6c:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010df71:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010df74:	5b                   	pop    %ebx
f010df75:	5e                   	pop    %esi
f010df76:	5d                   	pop    %ebp
f010df77:	c3                   	ret    

f010df78 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010df78:	55                   	push   %ebp
f010df79:	89 e5                	mov    %esp,%ebp
f010df7b:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010df7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df81:	8b 00                	mov    (%eax),%eax
f010df83:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010df86:	8b 45 10             	mov    0x10(%ebp),%eax
f010df89:	8b 00                	mov    (%eax),%eax
f010df8b:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010df8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010df95:	e9 ca 00 00 00       	jmp    f010e064 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010df9a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010df9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010dfa0:	01 d0                	add    %edx,%eax
f010dfa2:	89 c2                	mov    %eax,%edx
f010dfa4:	c1 ea 1f             	shr    $0x1f,%edx
f010dfa7:	01 d0                	add    %edx,%eax
f010dfa9:	d1 f8                	sar    %eax
f010dfab:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010dfae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010dfb1:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010dfb4:	eb 03                	jmp    f010dfb9 <stab_binsearch+0x41>
			m--;
f010dfb6:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010dfb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfbc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010dfbf:	7c 1e                	jl     f010dfdf <stab_binsearch+0x67>
f010dfc1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dfc4:	89 d0                	mov    %edx,%eax
f010dfc6:	01 c0                	add    %eax,%eax
f010dfc8:	01 d0                	add    %edx,%eax
f010dfca:	c1 e0 02             	shl    $0x2,%eax
f010dfcd:	89 c2                	mov    %eax,%edx
f010dfcf:	8b 45 08             	mov    0x8(%ebp),%eax
f010dfd2:	01 d0                	add    %edx,%eax
f010dfd4:	8a 40 04             	mov    0x4(%eax),%al
f010dfd7:	0f b6 c0             	movzbl %al,%eax
f010dfda:	3b 45 14             	cmp    0x14(%ebp),%eax
f010dfdd:	75 d7                	jne    f010dfb6 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010dfdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfe2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010dfe5:	7d 09                	jge    f010dff0 <stab_binsearch+0x78>
			l = true_m + 1;
f010dfe7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010dfea:	40                   	inc    %eax
f010dfeb:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010dfee:	eb 74                	jmp    f010e064 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010dff0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010dff7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dffa:	89 d0                	mov    %edx,%eax
f010dffc:	01 c0                	add    %eax,%eax
f010dffe:	01 d0                	add    %edx,%eax
f010e000:	c1 e0 02             	shl    $0x2,%eax
f010e003:	89 c2                	mov    %eax,%edx
f010e005:	8b 45 08             	mov    0x8(%ebp),%eax
f010e008:	01 d0                	add    %edx,%eax
f010e00a:	8b 40 08             	mov    0x8(%eax),%eax
f010e00d:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e010:	73 11                	jae    f010e023 <stab_binsearch+0xab>
			*region_left = m;
f010e012:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e015:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e018:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010e01a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e01d:	40                   	inc    %eax
f010e01e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e021:	eb 41                	jmp    f010e064 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010e023:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e026:	89 d0                	mov    %edx,%eax
f010e028:	01 c0                	add    %eax,%eax
f010e02a:	01 d0                	add    %edx,%eax
f010e02c:	c1 e0 02             	shl    $0x2,%eax
f010e02f:	89 c2                	mov    %eax,%edx
f010e031:	8b 45 08             	mov    0x8(%ebp),%eax
f010e034:	01 d0                	add    %edx,%eax
f010e036:	8b 40 08             	mov    0x8(%eax),%eax
f010e039:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e03c:	76 14                	jbe    f010e052 <stab_binsearch+0xda>
			*region_right = m - 1;
f010e03e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e041:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e044:	8b 45 10             	mov    0x10(%ebp),%eax
f010e047:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010e049:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e04c:	48                   	dec    %eax
f010e04d:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e050:	eb 12                	jmp    f010e064 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010e052:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e055:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e058:	89 10                	mov    %edx,(%eax)
			l = m;
f010e05a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e05d:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010e060:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010e064:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e067:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010e06a:	0f 8e 2a ff ff ff    	jle    f010df9a <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010e070:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e074:	75 0f                	jne    f010e085 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010e076:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e079:	8b 00                	mov    (%eax),%eax
f010e07b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e07e:	8b 45 10             	mov    0x10(%ebp),%eax
f010e081:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010e083:	eb 3d                	jmp    f010e0c2 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e085:	8b 45 10             	mov    0x10(%ebp),%eax
f010e088:	8b 00                	mov    (%eax),%eax
f010e08a:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e08d:	eb 03                	jmp    f010e092 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010e08f:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e092:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e095:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e097:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e09a:	7d 1e                	jge    f010e0ba <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e09c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e09f:	89 d0                	mov    %edx,%eax
f010e0a1:	01 c0                	add    %eax,%eax
f010e0a3:	01 d0                	add    %edx,%eax
f010e0a5:	c1 e0 02             	shl    $0x2,%eax
f010e0a8:	89 c2                	mov    %eax,%edx
f010e0aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0ad:	01 d0                	add    %edx,%eax
f010e0af:	8a 40 04             	mov    0x4(%eax),%al
f010e0b2:	0f b6 c0             	movzbl %al,%eax
f010e0b5:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e0b8:	75 d5                	jne    f010e08f <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e0ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e0c0:	89 10                	mov    %edx,(%eax)
	}
}
f010e0c2:	90                   	nop
f010e0c3:	c9                   	leave  
f010e0c4:	c3                   	ret    

f010e0c5 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e0c5:	55                   	push   %ebp
f010e0c6:	89 e5                	mov    %esp,%ebp
f010e0c8:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e0cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0ce:	c7 00 88 64 12 f0    	movl   $0xf0126488,(%eax)
	info->eip_line = 0;
f010e0d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0d7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e0de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0e1:	c7 40 08 88 64 12 f0 	movl   $0xf0126488,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e0e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0eb:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e0f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0f5:	8b 55 08             	mov    0x8(%ebp),%edx
f010e0f8:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e0fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0fe:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e105:	8b 45 08             	mov    0x8(%ebp),%eax
f010e108:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e10d:	76 1e                	jbe    f010e12d <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e10f:	c7 45 f4 08 02 13 f0 	movl   $0xf0130208,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e116:	c7 45 f0 c4 18 16 f0 	movl   $0xf01618c4,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e11d:	c7 45 ec c5 18 16 f0 	movl   $0xf01618c5,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e124:	c7 45 e8 75 2d 17 f0 	movl   $0xf0172d75,-0x18(%ebp)
f010e12b:	eb 2a                	jmp    f010e157 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e12d:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e134:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e137:	8b 00                	mov    (%eax),%eax
f010e139:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e13c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e13f:	8b 40 04             	mov    0x4(%eax),%eax
f010e142:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e145:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e148:	8b 40 08             	mov    0x8(%eax),%eax
f010e14b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e14e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e151:	8b 40 0c             	mov    0xc(%eax),%eax
f010e154:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e157:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e15a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e15d:	76 0a                	jbe    f010e169 <debuginfo_eip+0xa4>
f010e15f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e162:	48                   	dec    %eax
f010e163:	8a 00                	mov    (%eax),%al
f010e165:	84 c0                	test   %al,%al
f010e167:	74 0a                	je     f010e173 <debuginfo_eip+0xae>
		return -1;
f010e169:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e16e:	e9 01 02 00 00       	jmp    f010e374 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e173:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e17a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e17d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e180:	29 c2                	sub    %eax,%edx
f010e182:	89 d0                	mov    %edx,%eax
f010e184:	c1 f8 02             	sar    $0x2,%eax
f010e187:	89 c2                	mov    %eax,%edx
f010e189:	89 d0                	mov    %edx,%eax
f010e18b:	c1 e0 02             	shl    $0x2,%eax
f010e18e:	01 d0                	add    %edx,%eax
f010e190:	c1 e0 02             	shl    $0x2,%eax
f010e193:	01 d0                	add    %edx,%eax
f010e195:	c1 e0 02             	shl    $0x2,%eax
f010e198:	01 d0                	add    %edx,%eax
f010e19a:	89 c1                	mov    %eax,%ecx
f010e19c:	c1 e1 08             	shl    $0x8,%ecx
f010e19f:	01 c8                	add    %ecx,%eax
f010e1a1:	89 c1                	mov    %eax,%ecx
f010e1a3:	c1 e1 10             	shl    $0x10,%ecx
f010e1a6:	01 c8                	add    %ecx,%eax
f010e1a8:	01 c0                	add    %eax,%eax
f010e1aa:	01 d0                	add    %edx,%eax
f010e1ac:	48                   	dec    %eax
f010e1ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e1b0:	ff 75 08             	pushl  0x8(%ebp)
f010e1b3:	6a 64                	push   $0x64
f010e1b5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e1b8:	50                   	push   %eax
f010e1b9:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e1bc:	50                   	push   %eax
f010e1bd:	ff 75 f4             	pushl  -0xc(%ebp)
f010e1c0:	e8 b3 fd ff ff       	call   f010df78 <stab_binsearch>
f010e1c5:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e1c8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e1cb:	85 c0                	test   %eax,%eax
f010e1cd:	75 0a                	jne    f010e1d9 <debuginfo_eip+0x114>
		return -1;
f010e1cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e1d4:	e9 9b 01 00 00       	jmp    f010e374 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e1d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e1dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e1df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e1e2:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e1e5:	ff 75 08             	pushl  0x8(%ebp)
f010e1e8:	6a 24                	push   $0x24
f010e1ea:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e1ed:	50                   	push   %eax
f010e1ee:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e1f1:	50                   	push   %eax
f010e1f2:	ff 75 f4             	pushl  -0xc(%ebp)
f010e1f5:	e8 7e fd ff ff       	call   f010df78 <stab_binsearch>
f010e1fa:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e1fd:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e200:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e203:	39 c2                	cmp    %eax,%edx
f010e205:	0f 8f 86 00 00 00    	jg     f010e291 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e20b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e20e:	89 c2                	mov    %eax,%edx
f010e210:	89 d0                	mov    %edx,%eax
f010e212:	01 c0                	add    %eax,%eax
f010e214:	01 d0                	add    %edx,%eax
f010e216:	c1 e0 02             	shl    $0x2,%eax
f010e219:	89 c2                	mov    %eax,%edx
f010e21b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e21e:	01 d0                	add    %edx,%eax
f010e220:	8b 00                	mov    (%eax),%eax
f010e222:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e225:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e228:	29 d1                	sub    %edx,%ecx
f010e22a:	89 ca                	mov    %ecx,%edx
f010e22c:	39 d0                	cmp    %edx,%eax
f010e22e:	73 22                	jae    f010e252 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e230:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e233:	89 c2                	mov    %eax,%edx
f010e235:	89 d0                	mov    %edx,%eax
f010e237:	01 c0                	add    %eax,%eax
f010e239:	01 d0                	add    %edx,%eax
f010e23b:	c1 e0 02             	shl    $0x2,%eax
f010e23e:	89 c2                	mov    %eax,%edx
f010e240:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e243:	01 d0                	add    %edx,%eax
f010e245:	8b 10                	mov    (%eax),%edx
f010e247:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e24a:	01 c2                	add    %eax,%edx
f010e24c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e24f:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e252:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e255:	89 c2                	mov    %eax,%edx
f010e257:	89 d0                	mov    %edx,%eax
f010e259:	01 c0                	add    %eax,%eax
f010e25b:	01 d0                	add    %edx,%eax
f010e25d:	c1 e0 02             	shl    $0x2,%eax
f010e260:	89 c2                	mov    %eax,%edx
f010e262:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e265:	01 d0                	add    %edx,%eax
f010e267:	8b 50 08             	mov    0x8(%eax),%edx
f010e26a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e26d:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e270:	8b 55 08             	mov    0x8(%ebp),%edx
f010e273:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e276:	8b 40 10             	mov    0x10(%eax),%eax
f010e279:	29 c2                	sub    %eax,%edx
f010e27b:	89 d0                	mov    %edx,%eax
f010e27d:	c1 f8 02             	sar    $0x2,%eax
f010e280:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e283:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e286:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e289:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e28c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e28f:	eb 15                	jmp    f010e2a6 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e291:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e294:	8b 55 08             	mov    0x8(%ebp),%edx
f010e297:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e29a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e29d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e2a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e2a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e2a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2a9:	8b 40 08             	mov    0x8(%eax),%eax
f010e2ac:	83 ec 08             	sub    $0x8,%esp
f010e2af:	6a 3a                	push   $0x3a
f010e2b1:	50                   	push   %eax
f010e2b2:	e8 fa 06 01 00       	call   f011e9b1 <strfind>
f010e2b7:	83 c4 10             	add    $0x10,%esp
f010e2ba:	89 c2                	mov    %eax,%edx
f010e2bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2bf:	8b 40 08             	mov    0x8(%eax),%eax
f010e2c2:	29 c2                	sub    %eax,%edx
f010e2c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2c7:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e2ca:	eb 03                	jmp    f010e2cf <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e2cc:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e2cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e2d2:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e2d5:	7c 4e                	jl     f010e325 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e2d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e2da:	89 d0                	mov    %edx,%eax
f010e2dc:	01 c0                	add    %eax,%eax
f010e2de:	01 d0                	add    %edx,%eax
f010e2e0:	c1 e0 02             	shl    $0x2,%eax
f010e2e3:	89 c2                	mov    %eax,%edx
f010e2e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2e8:	01 d0                	add    %edx,%eax
f010e2ea:	8a 40 04             	mov    0x4(%eax),%al
f010e2ed:	3c 84                	cmp    $0x84,%al
f010e2ef:	74 34                	je     f010e325 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e2f1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e2f4:	89 d0                	mov    %edx,%eax
f010e2f6:	01 c0                	add    %eax,%eax
f010e2f8:	01 d0                	add    %edx,%eax
f010e2fa:	c1 e0 02             	shl    $0x2,%eax
f010e2fd:	89 c2                	mov    %eax,%edx
f010e2ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e302:	01 d0                	add    %edx,%eax
f010e304:	8a 40 04             	mov    0x4(%eax),%al
f010e307:	3c 64                	cmp    $0x64,%al
f010e309:	75 c1                	jne    f010e2cc <debuginfo_eip+0x207>
f010e30b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e30e:	89 d0                	mov    %edx,%eax
f010e310:	01 c0                	add    %eax,%eax
f010e312:	01 d0                	add    %edx,%eax
f010e314:	c1 e0 02             	shl    $0x2,%eax
f010e317:	89 c2                	mov    %eax,%edx
f010e319:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e31c:	01 d0                	add    %edx,%eax
f010e31e:	8b 40 08             	mov    0x8(%eax),%eax
f010e321:	85 c0                	test   %eax,%eax
f010e323:	74 a7                	je     f010e2cc <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e325:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e328:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e32b:	7c 42                	jl     f010e36f <debuginfo_eip+0x2aa>
f010e32d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e330:	89 d0                	mov    %edx,%eax
f010e332:	01 c0                	add    %eax,%eax
f010e334:	01 d0                	add    %edx,%eax
f010e336:	c1 e0 02             	shl    $0x2,%eax
f010e339:	89 c2                	mov    %eax,%edx
f010e33b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e33e:	01 d0                	add    %edx,%eax
f010e340:	8b 00                	mov    (%eax),%eax
f010e342:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e345:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e348:	29 d1                	sub    %edx,%ecx
f010e34a:	89 ca                	mov    %ecx,%edx
f010e34c:	39 d0                	cmp    %edx,%eax
f010e34e:	73 1f                	jae    f010e36f <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e350:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e353:	89 d0                	mov    %edx,%eax
f010e355:	01 c0                	add    %eax,%eax
f010e357:	01 d0                	add    %edx,%eax
f010e359:	c1 e0 02             	shl    $0x2,%eax
f010e35c:	89 c2                	mov    %eax,%edx
f010e35e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e361:	01 d0                	add    %edx,%eax
f010e363:	8b 10                	mov    (%eax),%edx
f010e365:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e368:	01 c2                	add    %eax,%edx
f010e36a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e36d:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e36f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e374:	c9                   	leave  
f010e375:	c3                   	ret    

f010e376 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e376:	55                   	push   %ebp
f010e377:	89 e5                	mov    %esp,%ebp
f010e379:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e37c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e380:	74 1c                	je     f010e39e <setPageReplacmentAlgorithmLRU+0x28>
f010e382:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e386:	74 16                	je     f010e39e <setPageReplacmentAlgorithmLRU+0x28>
f010e388:	68 94 64 12 f0       	push   $0xf0126494
f010e38d:	68 de 64 12 f0       	push   $0xf01264de
f010e392:	6a 19                	push   $0x19
f010e394:	68 f3 64 12 f0       	push   $0xf01264f3
f010e399:	e8 9b 1f ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e39e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3a1:	a3 f0 cb 5e f0       	mov    %eax,0xf05ecbf0
}
f010e3a6:	90                   	nop
f010e3a7:	c9                   	leave  
f010e3a8:	c3                   	ret    

f010e3a9 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e3a9:	55                   	push   %ebp
f010e3aa:	89 e5                	mov    %esp,%ebp
f010e3ac:	c7 05 f0 cb 5e f0 03 	movl   $0x3,0xf05ecbf0
f010e3b3:	00 00 00 
f010e3b6:	90                   	nop
f010e3b7:	5d                   	pop    %ebp
f010e3b8:	c3                   	ret    

f010e3b9 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e3b9:	55                   	push   %ebp
f010e3ba:	89 e5                	mov    %esp,%ebp
f010e3bc:	c7 05 f0 cb 5e f0 04 	movl   $0x4,0xf05ecbf0
f010e3c3:	00 00 00 
f010e3c6:	90                   	nop
f010e3c7:	5d                   	pop    %ebp
f010e3c8:	c3                   	ret    

f010e3c9 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e3c9:	55                   	push   %ebp
f010e3ca:	89 e5                	mov    %esp,%ebp
f010e3cc:	c7 05 f0 cb 5e f0 05 	movl   $0x5,0xf05ecbf0
f010e3d3:	00 00 00 
f010e3d6:	90                   	nop
f010e3d7:	5d                   	pop    %ebp
f010e3d8:	c3                   	ret    

f010e3d9 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e3d9:	55                   	push   %ebp
f010e3da:	89 e5                	mov    %esp,%ebp
f010e3dc:	c7 05 f0 cb 5e f0 07 	movl   $0x7,0xf05ecbf0
f010e3e3:	00 00 00 
f010e3e6:	90                   	nop
f010e3e7:	5d                   	pop    %ebp
f010e3e8:	c3                   	ret    

f010e3e9 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e3e9:	55                   	push   %ebp
f010e3ea:	89 e5                	mov    %esp,%ebp
f010e3ec:	c7 05 f0 cb 5e f0 06 	movl   $0x6,0xf05ecbf0
f010e3f3:	00 00 00 
f010e3f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f9:	a3 34 c5 5e f0       	mov    %eax,0xf05ec534
f010e3fe:	90                   	nop
f010e3ff:	5d                   	pop    %ebp
f010e400:	c3                   	ret    

f010e401 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e401:	55                   	push   %ebp
f010e402:	89 e5                	mov    %esp,%ebp
f010e404:	8b 15 f0 cb 5e f0    	mov    0xf05ecbf0,%edx
f010e40a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e40d:	39 c2                	cmp    %eax,%edx
f010e40f:	0f 94 c0             	sete   %al
f010e412:	0f b6 c0             	movzbl %al,%eax
f010e415:	5d                   	pop    %ebp
f010e416:	c3                   	ret    

f010e417 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e417:	55                   	push   %ebp
f010e418:	89 e5                	mov    %esp,%ebp
f010e41a:	a1 f0 cb 5e f0       	mov    0xf05ecbf0,%eax
f010e41f:	83 f8 03             	cmp    $0x3,%eax
f010e422:	75 07                	jne    f010e42b <isPageReplacmentAlgorithmCLOCK+0x14>
f010e424:	b8 01 00 00 00       	mov    $0x1,%eax
f010e429:	eb 05                	jmp    f010e430 <isPageReplacmentAlgorithmCLOCK+0x19>
f010e42b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e430:	5d                   	pop    %ebp
f010e431:	c3                   	ret    

f010e432 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e432:	55                   	push   %ebp
f010e433:	89 e5                	mov    %esp,%ebp
f010e435:	a1 f0 cb 5e f0       	mov    0xf05ecbf0,%eax
f010e43a:	83 f8 04             	cmp    $0x4,%eax
f010e43d:	75 07                	jne    f010e446 <isPageReplacmentAlgorithmFIFO+0x14>
f010e43f:	b8 01 00 00 00       	mov    $0x1,%eax
f010e444:	eb 05                	jmp    f010e44b <isPageReplacmentAlgorithmFIFO+0x19>
f010e446:	b8 00 00 00 00       	mov    $0x0,%eax
f010e44b:	5d                   	pop    %ebp
f010e44c:	c3                   	ret    

f010e44d <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e44d:	55                   	push   %ebp
f010e44e:	89 e5                	mov    %esp,%ebp
f010e450:	a1 f0 cb 5e f0       	mov    0xf05ecbf0,%eax
f010e455:	83 f8 05             	cmp    $0x5,%eax
f010e458:	75 07                	jne    f010e461 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e45a:	b8 01 00 00 00       	mov    $0x1,%eax
f010e45f:	eb 05                	jmp    f010e466 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e461:	b8 00 00 00 00       	mov    $0x0,%eax
f010e466:	5d                   	pop    %ebp
f010e467:	c3                   	ret    

f010e468 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e468:	55                   	push   %ebp
f010e469:	89 e5                	mov    %esp,%ebp
f010e46b:	a1 f0 cb 5e f0       	mov    0xf05ecbf0,%eax
f010e470:	83 f8 07             	cmp    $0x7,%eax
f010e473:	75 07                	jne    f010e47c <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e475:	b8 01 00 00 00       	mov    $0x1,%eax
f010e47a:	eb 05                	jmp    f010e481 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e47c:	b8 00 00 00 00       	mov    $0x0,%eax
f010e481:	5d                   	pop    %ebp
f010e482:	c3                   	ret    

f010e483 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e483:	55                   	push   %ebp
f010e484:	89 e5                	mov    %esp,%ebp
f010e486:	a1 f0 cb 5e f0       	mov    0xf05ecbf0,%eax
f010e48b:	83 f8 06             	cmp    $0x6,%eax
f010e48e:	75 07                	jne    f010e497 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e490:	b8 01 00 00 00       	mov    $0x1,%eax
f010e495:	eb 05                	jmp    f010e49c <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e497:	b8 00 00 00 00       	mov    $0x0,%eax
f010e49c:	5d                   	pop    %ebp
f010e49d:	c3                   	ret    

f010e49e <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e49e:	55                   	push   %ebp
f010e49f:	89 e5                	mov    %esp,%ebp
f010e4a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4a4:	a3 98 c9 5e f0       	mov    %eax,0xf05ec998
f010e4a9:	90                   	nop
f010e4aa:	5d                   	pop    %ebp
f010e4ab:	c3                   	ret    

f010e4ac <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e4ac:	55                   	push   %ebp
f010e4ad:	89 e5                	mov    %esp,%ebp
f010e4af:	a1 98 c9 5e f0       	mov    0xf05ec998,%eax
f010e4b4:	5d                   	pop    %ebp
f010e4b5:	c3                   	ret    

f010e4b6 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e4b6:	55                   	push   %ebp
f010e4b7:	89 e5                	mov    %esp,%ebp
f010e4b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4bc:	a3 74 cc 5e f0       	mov    %eax,0xf05ecc74
f010e4c1:	90                   	nop
f010e4c2:	5d                   	pop    %ebp
f010e4c3:	c3                   	ret    

f010e4c4 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e4c4:	55                   	push   %ebp
f010e4c5:	89 e5                	mov    %esp,%ebp
f010e4c7:	a1 74 cc 5e f0       	mov    0xf05ecc74,%eax
f010e4cc:	5d                   	pop    %ebp
f010e4cd:	c3                   	ret    

f010e4ce <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e4ce:	55                   	push   %ebp
f010e4cf:	89 e5                	mov    %esp,%ebp
f010e4d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4d4:	a3 10 cd 5e f0       	mov    %eax,0xf05ecd10
f010e4d9:	90                   	nop
f010e4da:	5d                   	pop    %ebp
f010e4db:	c3                   	ret    

f010e4dc <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e4dc:	55                   	push   %ebp
f010e4dd:	89 e5                	mov    %esp,%ebp
f010e4df:	a1 10 cd 5e f0       	mov    0xf05ecd10,%eax
f010e4e4:	5d                   	pop    %ebp
f010e4e5:	c3                   	ret    

f010e4e6 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e4e6:	55                   	push   %ebp
f010e4e7:	89 e5                	mov    %esp,%ebp
f010e4e9:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e4ec:	0f 20 d0             	mov    %cr2,%eax
f010e4ef:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e4f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e4f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e4f8:	e8 e5 c3 ff ff       	call   f010a8e2 <get_cpu_proc>
f010e4fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e500:	a1 2c 42 5c f0       	mov    0xf05c422c,%eax
f010e505:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e508:	75 50                	jne    f010e55a <fault_handler+0x74>
f010e50a:	a1 38 42 5c f0       	mov    0xf05c4238,%eax
f010e50f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e512:	75 46                	jne    f010e55a <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e514:	a0 34 42 5c f0       	mov    0xf05c4234,%al
f010e519:	40                   	inc    %eax
f010e51a:	a2 34 42 5c f0       	mov    %al,0xf05c4234
		if (num_repeated_fault == 3)
f010e51f:	a0 34 42 5c f0       	mov    0xf05c4234,%al
f010e524:	3c 03                	cmp    $0x3,%al
f010e526:	75 4d                	jne    f010e575 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e528:	83 ec 0c             	sub    $0xc,%esp
f010e52b:	ff 75 08             	pushl  0x8(%ebp)
f010e52e:	e8 5d e9 ff ff       	call   f010ce90 <print_trapframe>
f010e533:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e536:	8b 15 28 42 5c f0    	mov    0xf05c4228,%edx
f010e53c:	a1 30 42 5c f0       	mov    0xf05c4230,%eax
f010e541:	83 ec 08             	sub    $0x8,%esp
f010e544:	ff 75 ec             	pushl  -0x14(%ebp)
f010e547:	52                   	push   %edx
f010e548:	50                   	push   %eax
f010e549:	68 10 65 12 f0       	push   $0xf0126510
f010e54e:	6a 57                	push   $0x57
f010e550:	68 f3 64 12 f0       	push   $0xf01264f3
f010e555:	e8 df 1d ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e55a:	a1 2c 42 5c f0       	mov    0xf05c422c,%eax
f010e55f:	a3 30 42 5c f0       	mov    %eax,0xf05c4230
		before_last_eip = last_eip;
f010e564:	a1 24 42 5c f0       	mov    0xf05c4224,%eax
f010e569:	a3 28 42 5c f0       	mov    %eax,0xf05c4228
		num_repeated_fault = 0;
f010e56e:	c6 05 34 42 5c f0 00 	movb   $0x0,0xf05c4234
	}
	last_eip = (uint32)tf->tf_eip;
f010e575:	8b 45 08             	mov    0x8(%ebp),%eax
f010e578:	8b 40 30             	mov    0x30(%eax),%eax
f010e57b:	a3 24 42 5c f0       	mov    %eax,0xf05c4224
	last_fault_va = fault_va ;
f010e580:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e583:	a3 2c 42 5c f0       	mov    %eax,0xf05c422c
	last_faulted_env = cur_env;
f010e588:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e58b:	a3 38 42 5c f0       	mov    %eax,0xf05c4238
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e590:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e597:	8b 45 08             	mov    0x8(%ebp),%eax
f010e59a:	8b 40 34             	mov    0x34(%eax),%eax
f010e59d:	0f b7 c0             	movzwl %ax,%eax
f010e5a0:	83 e0 03             	and    $0x3,%eax
f010e5a3:	83 f8 03             	cmp    $0x3,%eax
f010e5a6:	75 07                	jne    f010e5af <fault_handler+0xc9>
		userTrap = 1;
f010e5a8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e5af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e5b3:	0f 85 c2 00 00 00    	jne    f010e67b <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010e5b9:	e8 e3 8a ff ff       	call   f01070a1 <mycpu>
f010e5be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e5c1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e5c5:	74 2f                	je     f010e5f6 <fault_handler+0x110>
f010e5c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e5ca:	8b 40 70             	mov    0x70(%eax),%eax
f010e5cd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e5d0:	77 24                	ja     f010e5f6 <fault_handler+0x110>
f010e5d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e5d5:	8b 40 70             	mov    0x70(%eax),%eax
f010e5d8:	05 00 10 00 00       	add    $0x1000,%eax
f010e5dd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e5e0:	76 14                	jbe    f010e5f6 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e5e2:	83 ec 04             	sub    $0x4,%esp
f010e5e5:	68 80 65 12 f0       	push   $0xf0126580
f010e5ea:	6a 6e                	push   $0x6e
f010e5ec:	68 f3 64 12 f0       	push   $0xf01264f3
f010e5f1:	e8 43 1d ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e5f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e5f9:	8b 40 08             	mov    0x8(%eax),%eax
f010e5fc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e5ff:	77 5d                	ja     f010e65e <fault_handler+0x178>
f010e601:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e604:	8b 40 08             	mov    0x8(%eax),%eax
f010e607:	05 00 10 00 00       	add    $0x1000,%eax
f010e60c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e60f:	76 4d                	jbe    f010e65e <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e611:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e614:	ba 80 c6 5e f0       	mov    $0xf05ec680,%edx
f010e619:	29 d0                	sub    %edx,%eax
f010e61b:	c1 f8 03             	sar    $0x3,%eax
f010e61e:	89 c2                	mov    %eax,%edx
f010e620:	89 d0                	mov    %edx,%eax
f010e622:	c1 e0 02             	shl    $0x2,%eax
f010e625:	01 d0                	add    %edx,%eax
f010e627:	01 c0                	add    %eax,%eax
f010e629:	01 d0                	add    %edx,%eax
f010e62b:	c1 e0 03             	shl    $0x3,%eax
f010e62e:	01 d0                	add    %edx,%eax
f010e630:	89 c1                	mov    %eax,%ecx
f010e632:	c1 e1 0b             	shl    $0xb,%ecx
f010e635:	01 c8                	add    %ecx,%eax
f010e637:	c1 e0 05             	shl    $0x5,%eax
f010e63a:	01 d0                	add    %edx,%eax
f010e63c:	c1 e0 02             	shl    $0x2,%eax
f010e63f:	01 d0                	add    %edx,%eax
f010e641:	01 c0                	add    %eax,%eax
f010e643:	01 d0                	add    %edx,%eax
f010e645:	c1 e0 03             	shl    $0x3,%eax
f010e648:	01 d0                	add    %edx,%eax
f010e64a:	f7 d8                	neg    %eax
f010e64c:	50                   	push   %eax
f010e64d:	68 a8 65 12 f0       	push   $0xf01265a8
f010e652:	6a 70                	push   $0x70
f010e654:	68 f3 64 12 f0       	push   $0xf01264f3
f010e659:	e8 db 1c ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010e65e:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010e665:	76 3a                	jbe    f010e6a1 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010e667:	83 ec 04             	sub    $0x4,%esp
f010e66a:	68 dc 65 12 f0       	push   $0xf01265dc
f010e66f:	6a 73                	push   $0x73
f010e671:	68 f3 64 12 f0       	push   $0xf01264f3
f010e676:	e8 be 1c ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e67b:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e682:	76 1d                	jbe    f010e6a1 <fault_handler+0x1bb>
f010e684:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e68b:	77 14                	ja     f010e6a1 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010e68d:	83 ec 04             	sub    $0x4,%esp
f010e690:	68 00 66 12 f0       	push   $0xf0126600
f010e695:	6a 7b                	push   $0x7b
f010e697:	68 f3 64 12 f0       	push   $0xf01264f3
f010e69c:	e8 98 1c ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e6a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e6a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010e6a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e6ab:	75 25                	jne    f010e6d2 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010e6ad:	83 ec 0c             	sub    $0xc,%esp
f010e6b0:	ff 75 08             	pushl  0x8(%ebp)
f010e6b3:	e8 d8 e7 ff ff       	call   f010ce90 <print_trapframe>
f010e6b8:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010e6bb:	83 ec 04             	sub    $0x4,%esp
f010e6be:	68 21 66 12 f0       	push   $0xf0126621
f010e6c3:	68 84 00 00 00       	push   $0x84
f010e6c8:	68 f3 64 12 f0       	push   $0xf01264f3
f010e6cd:	e8 67 1c ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010e6d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6d5:	8b 40 64             	mov    0x64(%eax),%eax
f010e6d8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e6db:	c1 ea 16             	shr    $0x16,%edx
f010e6de:	c1 e2 02             	shl    $0x2,%edx
f010e6e1:	01 d0                	add    %edx,%eax
f010e6e3:	8b 00                	mov    (%eax),%eax
f010e6e5:	83 e0 01             	and    $0x1,%eax
f010e6e8:	85 c0                	test   %eax,%eax
f010e6ea:	75 28                	jne    f010e714 <fault_handler+0x22e>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010e6ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6ef:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010e6f5:	8d 50 01             	lea    0x1(%eax),%edx
f010e6f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6fb:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)

		table_fault_handler(faulted_env, fault_va);
f010e701:	83 ec 08             	sub    $0x8,%esp
f010e704:	ff 75 ec             	pushl  -0x14(%ebp)
f010e707:	ff 75 e0             	pushl  -0x20(%ebp)
f010e70a:	e8 8f 00 00 00       	call   f010e79e <table_fault_handler>
f010e70f:	83 c4 10             	add    $0x10,%esp
f010e712:	eb 7b                	jmp    f010e78f <fault_handler+0x2a9>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010e714:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e717:	8b 40 64             	mov    0x64(%eax),%eax
f010e71a:	83 ec 08             	sub    $0x8,%esp
f010e71d:	ff 75 ec             	pushl  -0x14(%ebp)
f010e720:	50                   	push   %eax
f010e721:	e8 25 a7 ff ff       	call   f0108e4b <pt_get_page_permissions>
f010e726:	83 c4 10             	add    $0x10,%esp
f010e729:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010e72c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e72f:	83 e0 01             	and    $0x1,%eax
f010e732:	85 c0                	test   %eax,%eax
f010e734:	74 17                	je     f010e74d <fault_handler+0x267>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010e736:	ff 75 ec             	pushl  -0x14(%ebp)
f010e739:	68 38 66 12 f0       	push   $0xf0126638
f010e73e:	68 a1 00 00 00       	push   $0xa1
f010e743:	68 f3 64 12 f0       	push   $0xf01264f3
f010e748:	e8 ec 1b ff ff       	call   f0100339 <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010e74d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e750:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010e756:	8d 50 01             	lea    0x1(%eax),%edx
f010e759:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e75c:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010e762:	e8 5d fd ff ff       	call   f010e4c4 <isBufferingEnabled>
f010e767:	84 c0                	test   %al,%al
f010e769:	74 13                	je     f010e77e <fault_handler+0x298>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010e76b:	83 ec 08             	sub    $0x8,%esp
f010e76e:	ff 75 ec             	pushl  -0x14(%ebp)
f010e771:	ff 75 e0             	pushl  -0x20(%ebp)
f010e774:	e8 9b 00 00 00       	call   f010e814 <__page_fault_handler_with_buffering>
f010e779:	83 c4 10             	add    $0x10,%esp
f010e77c:	eb 11                	jmp    f010e78f <fault_handler+0x2a9>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010e77e:	83 ec 08             	sub    $0x8,%esp
f010e781:	ff 75 ec             	pushl  -0x14(%ebp)
f010e784:	ff 75 e0             	pushl  -0x20(%ebp)
f010e787:	e8 33 00 00 00       	call   f010e7bf <page_fault_handler>
f010e78c:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010e78f:	0f 20 d8             	mov    %cr3,%eax
f010e792:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010e795:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e798:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010e79b:	90                   	nop
f010e79c:	c9                   	leave  
f010e79d:	c3                   	ret    

f010e79e <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010e79e:	55                   	push   %ebp
f010e79f:	89 e5                	mov    %esp,%ebp
f010e7a1:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010e7a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7a7:	8b 40 64             	mov    0x64(%eax),%eax
f010e7aa:	83 ec 08             	sub    $0x8,%esp
f010e7ad:	ff 75 0c             	pushl  0xc(%ebp)
f010e7b0:	50                   	push   %eax
f010e7b1:	e8 24 9d ff ff       	call   f01084da <create_page_table>
f010e7b6:	83 c4 10             	add    $0x10,%esp
f010e7b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010e7bc:	90                   	nop
f010e7bd:	c9                   	leave  
f010e7be:	c3                   	ret    

f010e7bf <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010e7bf:	55                   	push   %ebp
f010e7c0:	89 e5                	mov    %esp,%ebp
f010e7c2:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010e7c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010e7cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7cf:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010e7d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010e7d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7db:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010e7e1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e7e4:	76 17                	jbe    f010e7fd <page_fault_handler+0x3e>
	{
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
f010e7e6:	83 ec 04             	sub    $0x4,%esp
f010e7e9:	68 7c 66 12 f0       	push   $0xf012667c
f010e7ee:	68 e6 00 00 00       	push   $0xe6
f010e7f3:	68 f3 64 12 f0       	push   $0xf01264f3
f010e7f8:	e8 3c 1b ff ff       	call   f0100339 <_panic>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010e7fd:	83 ec 04             	sub    $0x4,%esp
f010e800:	68 b8 66 12 f0       	push   $0xf01266b8
f010e805:	68 f0 00 00 00       	push   $0xf0
f010e80a:	68 f3 64 12 f0       	push   $0xf01264f3
f010e80f:	e8 25 1b ff ff       	call   f0100339 <_panic>

f010e814 <__page_fault_handler_with_buffering>:
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010e814:	55                   	push   %ebp
f010e815:	89 e5                	mov    %esp,%ebp
f010e817:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010e81a:	83 ec 04             	sub    $0x4,%esp
f010e81d:	68 f8 66 12 f0       	push   $0xf01266f8
f010e822:	68 f8 00 00 00       	push   $0xf8
f010e827:	68 f3 64 12 f0       	push   $0xf01264f3
f010e82c:	e8 08 1b ff ff       	call   f0100339 <_panic>

f010e831 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010e831:	55                   	push   %ebp
f010e832:	89 e5                	mov    %esp,%ebp
f010e834:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010e837:	8b 45 08             	mov    0x8(%ebp),%eax
f010e83a:	83 c0 04             	add    $0x4,%eax
f010e83d:	83 ec 08             	sub    $0x8,%esp
f010e840:	ff 75 0c             	pushl  0xc(%ebp)
f010e843:	50                   	push   %eax
f010e844:	e8 f5 ff 00 00       	call   f011e83e <strcpy>
f010e849:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010e84c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e84f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010e855:	8b 45 08             	mov    0x8(%ebp),%eax
f010e858:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010e85f:	90                   	nop
f010e860:	c9                   	leave  
f010e861:	c3                   	ret    

f010e862 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010e862:	55                   	push   %ebp
f010e863:	89 e5                	mov    %esp,%ebp
f010e865:	53                   	push   %ebx
f010e866:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010e869:	8b 45 08             	mov    0x8(%ebp),%eax
f010e86c:	83 ec 0c             	sub    $0xc,%esp
f010e86f:	50                   	push   %eax
f010e870:	e8 06 02 00 00       	call   f010ea7b <holding_spinlock>
f010e875:	83 c4 10             	add    $0x10,%esp
f010e878:	85 c0                	test   %eax,%eax
f010e87a:	74 18                	je     f010e894 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010e87c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e87f:	83 c0 04             	add    $0x4,%eax
f010e882:	50                   	push   %eax
f010e883:	68 3c 67 12 f0       	push   $0xf012673c
f010e888:	6a 1f                	push   $0x1f
f010e88a:	68 79 67 12 f0       	push   $0xf0126779
f010e88f:	e8 a5 1a ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010e894:	e8 cb 88 ff ff       	call   f0107164 <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010e899:	90                   	nop
f010e89a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e89d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e8a0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010e8a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e8aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8ad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010e8b0:	f0 87 02             	lock xchg %eax,(%edx)
f010e8b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010e8b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e8b9:	85 c0                	test   %eax,%eax
f010e8bb:	75 dd                	jne    f010e89a <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010e8bd:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010e8c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010e8c5:	e8 d7 87 ff ff       	call   f01070a1 <mycpu>
f010e8ca:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010e8cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8d0:	83 c0 48             	add    $0x48,%eax
f010e8d3:	83 ec 08             	sub    $0x8,%esp
f010e8d6:	50                   	push   %eax
f010e8d7:	8d 45 08             	lea    0x8(%ebp),%eax
f010e8da:	50                   	push   %eax
f010e8db:	e8 74 00 00 00       	call   f010e954 <getcallerpcs>
f010e8e0:	83 c4 10             	add    $0x10,%esp

}
f010e8e3:	90                   	nop
f010e8e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e8e7:	c9                   	leave  
f010e8e8:	c3                   	ret    

f010e8e9 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010e8e9:	55                   	push   %ebp
f010e8ea:	89 e5                	mov    %esp,%ebp
f010e8ec:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010e8ef:	83 ec 0c             	sub    $0xc,%esp
f010e8f2:	ff 75 08             	pushl  0x8(%ebp)
f010e8f5:	e8 81 01 00 00       	call   f010ea7b <holding_spinlock>
f010e8fa:	83 c4 10             	add    $0x10,%esp
f010e8fd:	85 c0                	test   %eax,%eax
f010e8ff:	75 26                	jne    f010e927 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010e901:	83 ec 0c             	sub    $0xc,%esp
f010e904:	ff 75 08             	pushl  0x8(%ebp)
f010e907:	e8 08 01 00 00       	call   f010ea14 <printcallstack>
f010e90c:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010e90f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e912:	83 c0 04             	add    $0x4,%eax
f010e915:	50                   	push   %eax
f010e916:	68 90 67 12 f0       	push   $0xf0126790
f010e91b:	6a 3c                	push   $0x3c
f010e91d:	68 79 67 12 f0       	push   $0xf0126779
f010e922:	e8 12 1a ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010e927:	8b 45 08             	mov    0x8(%ebp),%eax
f010e92a:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010e931:	8b 45 08             	mov    0x8(%ebp),%eax
f010e934:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010e93b:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010e940:	8b 45 08             	mov    0x8(%ebp),%eax
f010e943:	8b 55 08             	mov    0x8(%ebp),%edx
f010e946:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010e94c:	e8 65 88 ff ff       	call   f01071b6 <popcli>
}
f010e951:	90                   	nop
f010e952:	c9                   	leave  
f010e953:	c3                   	ret    

f010e954 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010e954:	55                   	push   %ebp
f010e955:	89 e5                	mov    %esp,%ebp
f010e957:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010e95a:	e8 83 bf ff ff       	call   f010a8e2 <get_cpu_proc>
f010e95f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010e962:	e8 3a 87 ff ff       	call   f01070a1 <mycpu>
f010e967:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010e96a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e96d:	83 e8 08             	sub    $0x8,%eax
f010e970:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010e973:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010e97a:	eb 67                	jmp    f010e9e3 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010e97c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e980:	74 67                	je     f010e9e9 <getcallerpcs+0x95>
f010e982:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010e989:	76 5e                	jbe    f010e9e9 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010e98b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e98e:	8b 40 08             	mov    0x8(%eax),%eax
f010e991:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010e996:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e999:	77 10                	ja     f010e9ab <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010e99b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e99e:	8b 40 08             	mov    0x8(%eax),%eax
f010e9a1:	05 00 90 00 00       	add    $0x9000,%eax
f010e9a6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e9a9:	77 3e                	ja     f010e9e9 <getcallerpcs+0x95>
f010e9ab:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010e9af:	74 10                	je     f010e9c1 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010e9b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e9b4:	8b 40 70             	mov    0x70(%eax),%eax
f010e9b7:	05 00 80 00 00       	add    $0x8000,%eax
f010e9bc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e9bf:	76 28                	jbe    f010e9e9 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010e9c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e9c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010e9cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9ce:	01 c2                	add    %eax,%edx
f010e9d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9d3:	8b 40 04             	mov    0x4(%eax),%eax
f010e9d6:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010e9d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9db:	8b 00                	mov    (%eax),%eax
f010e9dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010e9e0:	ff 45 f0             	incl   -0x10(%ebp)
f010e9e3:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010e9e7:	7e 93                	jle    f010e97c <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010e9e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e9ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010e9ef:	eb 18                	jmp    f010ea09 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010e9f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e9f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010e9fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9fe:	01 d0                	add    %edx,%eax
f010ea00:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ea06:	ff 45 f0             	incl   -0x10(%ebp)
f010ea09:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ea0d:	7e e2                	jle    f010e9f1 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010ea0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010ea12:	c9                   	leave  
f010ea13:	c3                   	ret    

f010ea14 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010ea14:	55                   	push   %ebp
f010ea15:	89 e5                	mov    %esp,%ebp
f010ea17:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ea1a:	83 ec 0c             	sub    $0xc,%esp
f010ea1d:	68 ce 67 12 f0       	push   $0xf01267ce
f010ea22:	e8 64 25 ff ff       	call   f0100f8b <cprintf>
f010ea27:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ea2a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea2d:	83 c0 48             	add    $0x48,%eax
f010ea30:	83 ec 08             	sub    $0x8,%esp
f010ea33:	50                   	push   %eax
f010ea34:	8d 45 08             	lea    0x8(%ebp),%eax
f010ea37:	50                   	push   %eax
f010ea38:	e8 17 ff ff ff       	call   f010e954 <getcallerpcs>
f010ea3d:	83 c4 10             	add    $0x10,%esp
f010ea40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ea43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ea4a:	eb 24                	jmp    f010ea70 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ea4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ea52:	83 c2 10             	add    $0x10,%edx
f010ea55:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ea59:	83 ec 04             	sub    $0x4,%esp
f010ea5c:	50                   	push   %eax
f010ea5d:	ff 75 f4             	pushl  -0xc(%ebp)
f010ea60:	68 de 67 12 f0       	push   $0xf01267de
f010ea65:	e8 21 25 ff ff       	call   f0100f8b <cprintf>
f010ea6a:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ea6d:	ff 45 f4             	incl   -0xc(%ebp)
f010ea70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea73:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ea76:	7c d4                	jl     f010ea4c <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010ea78:	90                   	nop
f010ea79:	c9                   	leave  
f010ea7a:	c3                   	ret    

f010ea7b <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010ea7b:	55                   	push   %ebp
f010ea7c:	89 e5                	mov    %esp,%ebp
f010ea7e:	53                   	push   %ebx
f010ea7f:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010ea82:	e8 dd 86 ff ff       	call   f0107164 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ea87:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea8a:	8b 00                	mov    (%eax),%eax
f010ea8c:	85 c0                	test   %eax,%eax
f010ea8e:	74 16                	je     f010eaa6 <holding_spinlock+0x2b>
f010ea90:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea93:	8b 58 44             	mov    0x44(%eax),%ebx
f010ea96:	e8 06 86 ff ff       	call   f01070a1 <mycpu>
f010ea9b:	39 c3                	cmp    %eax,%ebx
f010ea9d:	75 07                	jne    f010eaa6 <holding_spinlock+0x2b>
f010ea9f:	b8 01 00 00 00       	mov    $0x1,%eax
f010eaa4:	eb 05                	jmp    f010eaab <holding_spinlock+0x30>
f010eaa6:	b8 00 00 00 00       	mov    $0x0,%eax
f010eaab:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010eaae:	e8 03 87 ff ff       	call   f01071b6 <popcli>
	return r;
f010eab3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eab6:	83 c4 14             	add    $0x14,%esp
f010eab9:	5b                   	pop    %ebx
f010eaba:	5d                   	pop    %ebp
f010eabb:	c3                   	ret    

f010eabc <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010eabc:	55                   	push   %ebp
f010eabd:	89 e5                	mov    %esp,%ebp
f010eabf:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010eac2:	8b 45 08             	mov    0x8(%ebp),%eax
f010eac5:	83 c0 74             	add    $0x74,%eax
f010eac8:	83 ec 08             	sub    $0x8,%esp
f010eacb:	68 ed 67 12 f0       	push   $0xf01267ed
f010ead0:	50                   	push   %eax
f010ead1:	e8 4c 01 00 00       	call   f010ec22 <init_channel>
f010ead6:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ead9:	8b 45 08             	mov    0x8(%ebp),%eax
f010eadc:	83 c0 04             	add    $0x4,%eax
f010eadf:	83 ec 08             	sub    $0x8,%esp
f010eae2:	68 00 68 12 f0       	push   $0xf0126800
f010eae7:	50                   	push   %eax
f010eae8:	e8 44 fd ff ff       	call   f010e831 <init_spinlock>
f010eaed:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010eaf0:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf3:	05 c4 00 00 00       	add    $0xc4,%eax
f010eaf8:	83 ec 08             	sub    $0x8,%esp
f010eafb:	ff 75 0c             	pushl  0xc(%ebp)
f010eafe:	50                   	push   %eax
f010eaff:	e8 3a fd 00 00       	call   f011e83e <strcpy>
f010eb04:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010eb07:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010eb10:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb13:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010eb1a:	00 00 00 
}
f010eb1d:	90                   	nop
f010eb1e:	c9                   	leave  
f010eb1f:	c3                   	ret    

f010eb20 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010eb20:	55                   	push   %ebp
f010eb21:	89 e5                	mov    %esp,%ebp
f010eb23:	53                   	push   %ebx
f010eb24:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010eb27:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb2a:	83 c0 04             	add    $0x4,%eax
f010eb2d:	83 ec 0c             	sub    $0xc,%esp
f010eb30:	50                   	push   %eax
f010eb31:	e8 2c fd ff ff       	call   f010e862 <acquire_spinlock>
f010eb36:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010eb39:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb3c:	8b 00                	mov    (%eax),%eax
f010eb3e:	85 c0                	test   %eax,%eax
f010eb40:	74 1c                	je     f010eb5e <holding_sleeplock+0x3e>
f010eb42:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb45:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010eb4b:	e8 92 bd ff ff       	call   f010a8e2 <get_cpu_proc>
f010eb50:	8b 40 10             	mov    0x10(%eax),%eax
f010eb53:	39 c3                	cmp    %eax,%ebx
f010eb55:	75 07                	jne    f010eb5e <holding_sleeplock+0x3e>
f010eb57:	b8 01 00 00 00       	mov    $0x1,%eax
f010eb5c:	eb 05                	jmp    f010eb63 <holding_sleeplock+0x43>
f010eb5e:	b8 00 00 00 00       	mov    $0x0,%eax
f010eb63:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010eb66:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb69:	83 c0 04             	add    $0x4,%eax
f010eb6c:	83 ec 0c             	sub    $0xc,%esp
f010eb6f:	50                   	push   %eax
f010eb70:	e8 74 fd ff ff       	call   f010e8e9 <release_spinlock>
f010eb75:	83 c4 10             	add    $0x10,%esp
	return r;
f010eb78:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eb7b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010eb7e:	c9                   	leave  
f010eb7f:	c3                   	ret    

f010eb80 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010eb80:	55                   	push   %ebp
f010eb81:	89 e5                	mov    %esp,%ebp
f010eb83:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010eb86:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb89:	83 c0 04             	add    $0x4,%eax
f010eb8c:	83 ec 0c             	sub    $0xc,%esp
f010eb8f:	50                   	push   %eax
f010eb90:	e8 cd fc ff ff       	call   f010e862 <acquire_spinlock>
f010eb95:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010eb98:	eb 19                	jmp    f010ebb3 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010eb9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb9d:	8d 50 04             	lea    0x4(%eax),%edx
f010eba0:	8b 45 08             	mov    0x8(%ebp),%eax
f010eba3:	83 c0 74             	add    $0x74,%eax
f010eba6:	83 ec 08             	sub    $0x8,%esp
f010eba9:	52                   	push   %edx
f010ebaa:	50                   	push   %eax
f010ebab:	e8 9f 00 00 00       	call   f010ec4f <sleep>
f010ebb0:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010ebb3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebb6:	8b 00                	mov    (%eax),%eax
f010ebb8:	85 c0                	test   %eax,%eax
f010ebba:	75 de                	jne    f010eb9a <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010ebbc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebbf:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010ebc5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebc8:	83 c0 04             	add    $0x4,%eax
f010ebcb:	83 ec 0c             	sub    $0xc,%esp
f010ebce:	50                   	push   %eax
f010ebcf:	e8 15 fd ff ff       	call   f010e8e9 <release_spinlock>
f010ebd4:	83 c4 10             	add    $0x10,%esp

}
f010ebd7:	90                   	nop
f010ebd8:	c9                   	leave  
f010ebd9:	c3                   	ret    

f010ebda <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010ebda:	55                   	push   %ebp
f010ebdb:	89 e5                	mov    %esp,%ebp
f010ebdd:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010ebe0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebe3:	83 c0 04             	add    $0x4,%eax
f010ebe6:	83 ec 0c             	sub    $0xc,%esp
f010ebe9:	50                   	push   %eax
f010ebea:	e8 73 fc ff ff       	call   f010e862 <acquire_spinlock>
f010ebef:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010ebf2:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebf5:	83 c0 74             	add    $0x74,%eax
f010ebf8:	83 ec 0c             	sub    $0xc,%esp
f010ebfb:	50                   	push   %eax
f010ebfc:	e8 3f 01 00 00       	call   f010ed40 <wakeup_all>
f010ec01:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f010ec04:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f010ec0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec10:	83 c0 04             	add    $0x4,%eax
f010ec13:	83 ec 0c             	sub    $0xc,%esp
f010ec16:	50                   	push   %eax
f010ec17:	e8 cd fc ff ff       	call   f010e8e9 <release_spinlock>
f010ec1c:	83 c4 10             	add    $0x10,%esp
}
f010ec1f:	90                   	nop
f010ec20:	c9                   	leave  
f010ec21:	c3                   	ret    

f010ec22 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010ec22:	55                   	push   %ebp
f010ec23:	89 e5                	mov    %esp,%ebp
f010ec25:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010ec28:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec2b:	83 c0 10             	add    $0x10,%eax
f010ec2e:	83 ec 08             	sub    $0x8,%esp
f010ec31:	ff 75 0c             	pushl  0xc(%ebp)
f010ec34:	50                   	push   %eax
f010ec35:	e8 04 fc 00 00       	call   f011e83e <strcpy>
f010ec3a:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010ec3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec40:	83 ec 0c             	sub    $0xc,%esp
f010ec43:	50                   	push   %eax
f010ec44:	e8 be 62 ff ff       	call   f0104f07 <init_queue>
f010ec49:	83 c4 10             	add    $0x10,%esp
}
f010ec4c:	90                   	nop
f010ec4d:	c9                   	leave  
f010ec4e:	c3                   	ret    

f010ec4f <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010ec4f:	55                   	push   %ebp
f010ec50:	89 e5                	mov    %esp,%ebp
f010ec52:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f010ec55:	83 ec 0c             	sub    $0xc,%esp
f010ec58:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010ec5d:	e8 00 fc ff ff       	call   f010e862 <acquire_spinlock>
f010ec62:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f010ec65:	e8 78 bc ff ff       	call   f010a8e2 <get_cpu_proc>
f010ec6a:	89 c2                	mov    %eax,%edx
f010ec6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec6f:	83 ec 08             	sub    $0x8,%esp
f010ec72:	52                   	push   %edx
f010ec73:	50                   	push   %eax
f010ec74:	e8 cf 62 ff ff       	call   f0104f48 <enqueue>
f010ec79:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f010ec7c:	e8 61 bc ff ff       	call   f010a8e2 <get_cpu_proc>
f010ec81:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f010ec88:	83 ec 0c             	sub    $0xc,%esp
f010ec8b:	ff 75 0c             	pushl  0xc(%ebp)
f010ec8e:	e8 56 fc ff ff       	call   f010e8e9 <release_spinlock>
f010ec93:	83 c4 10             	add    $0x10,%esp
	sched();
f010ec96:	e8 c0 bd ff ff       	call   f010aa5b <sched>
	release_spinlock(&(ProcessQueues.qlock));
f010ec9b:	83 ec 0c             	sub    $0xc,%esp
f010ec9e:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010eca3:	e8 41 fc ff ff       	call   f010e8e9 <release_spinlock>
f010eca8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010ecab:	83 ec 0c             	sub    $0xc,%esp
f010ecae:	ff 75 0c             	pushl  0xc(%ebp)
f010ecb1:	e8 ac fb ff ff       	call   f010e862 <acquire_spinlock>
f010ecb6:	83 c4 10             	add    $0x10,%esp
}
f010ecb9:	90                   	nop
f010ecba:	c9                   	leave  
f010ecbb:	c3                   	ret    

f010ecbc <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010ecbc:	55                   	push   %ebp
f010ecbd:	89 e5                	mov    %esp,%ebp
f010ecbf:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f010ecc2:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecc5:	83 ec 0c             	sub    $0xc,%esp
f010ecc8:	50                   	push   %eax
f010ecc9:	e8 62 62 ff ff       	call   f0104f30 <queue_size>
f010ecce:	83 c4 10             	add    $0x10,%esp
f010ecd1:	85 c0                	test   %eax,%eax
f010ecd3:	74 68                	je     f010ed3d <wakeup_one+0x81>
		bool locked_by_me = 0;
f010ecd5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f010ecdc:	83 ec 0c             	sub    $0xc,%esp
f010ecdf:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010ece4:	e8 92 fd ff ff       	call   f010ea7b <holding_spinlock>
f010ece9:	83 c4 10             	add    $0x10,%esp
f010ecec:	85 c0                	test   %eax,%eax
f010ecee:	75 17                	jne    f010ed07 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f010ecf0:	83 ec 0c             	sub    $0xc,%esp
f010ecf3:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010ecf8:	e8 65 fb ff ff       	call   f010e862 <acquire_spinlock>
f010ecfd:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f010ed00:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f010ed07:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed0a:	83 ec 0c             	sub    $0xc,%esp
f010ed0d:	50                   	push   %eax
f010ed0e:	e8 c6 62 ff ff       	call   f0104fd9 <dequeue>
f010ed13:	83 c4 10             	add    $0x10,%esp
f010ed16:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f010ed19:	83 ec 0c             	sub    $0xc,%esp
f010ed1c:	ff 75 f0             	pushl  -0x10(%ebp)
f010ed1f:	e8 f0 64 ff ff       	call   f0105214 <sched_insert_ready0>
f010ed24:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f010ed27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed2b:	74 10                	je     f010ed3d <wakeup_one+0x81>
f010ed2d:	83 ec 0c             	sub    $0xc,%esp
f010ed30:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010ed35:	e8 af fb ff ff       	call   f010e8e9 <release_spinlock>
f010ed3a:	83 c4 10             	add    $0x10,%esp
	}
}
f010ed3d:	90                   	nop
f010ed3e:	c9                   	leave  
f010ed3f:	c3                   	ret    

f010ed40 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010ed40:	55                   	push   %ebp
f010ed41:	89 e5                	mov    %esp,%ebp
f010ed43:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010ed46:	83 ec 0c             	sub    $0xc,%esp
f010ed49:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010ed4e:	e8 0f fb ff ff       	call   f010e862 <acquire_spinlock>
f010ed53:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f010ed56:	eb 0e                	jmp    f010ed66 <wakeup_all+0x26>
		wakeup_one(chan);
f010ed58:	83 ec 0c             	sub    $0xc,%esp
f010ed5b:	ff 75 08             	pushl  0x8(%ebp)
f010ed5e:	e8 59 ff ff ff       	call   f010ecbc <wakeup_one>
f010ed63:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f010ed66:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed69:	83 ec 0c             	sub    $0xc,%esp
f010ed6c:	50                   	push   %eax
f010ed6d:	e8 be 61 ff ff       	call   f0104f30 <queue_size>
f010ed72:	83 c4 10             	add    $0x10,%esp
f010ed75:	85 c0                	test   %eax,%eax
f010ed77:	75 df                	jne    f010ed58 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f010ed79:	83 ec 0c             	sub    $0xc,%esp
f010ed7c:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010ed81:	e8 63 fb ff ff       	call   f010e8e9 <release_spinlock>
f010ed86:	83 c4 10             	add    $0x10,%esp
}
f010ed89:	90                   	nop
f010ed8a:	c9                   	leave  
f010ed8b:	c3                   	ret    

f010ed8c <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010ed8c:	55                   	push   %ebp
f010ed8d:	89 e5                	mov    %esp,%ebp
f010ed8f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010ed92:	83 ec 04             	sub    $0x4,%esp
f010ed95:	68 14 68 12 f0       	push   $0xf0126814
f010ed9a:	6a 13                	push   $0x13
f010ed9c:	68 3b 68 12 f0       	push   $0xf012683b
f010eda1:	e8 93 15 ff ff       	call   f0100339 <_panic>

f010eda6 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010eda6:	55                   	push   %ebp
f010eda7:	89 e5                	mov    %esp,%ebp
f010eda9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010edac:	83 ec 04             	sub    $0x4,%esp
f010edaf:	68 54 68 12 f0       	push   $0xf0126854
f010edb4:	6a 1b                	push   $0x1b
f010edb6:	68 3b 68 12 f0       	push   $0xf012683b
f010edbb:	e8 79 15 ff ff       	call   f0100339 <_panic>

f010edc0 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010edc0:	55                   	push   %ebp
f010edc1:	89 e5                	mov    %esp,%ebp
f010edc3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010edc6:	83 ec 04             	sub    $0x4,%esp
f010edc9:	68 7c 68 12 f0       	push   $0xf012687c
f010edce:	6a 24                	push   $0x24
f010edd0:	68 3b 68 12 f0       	push   $0xf012683b
f010edd5:	e8 5f 15 ff ff       	call   f0100339 <_panic>

f010edda <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010edda:	55                   	push   %ebp
f010eddb:	89 e5                	mov    %esp,%ebp
f010eddd:	c7 05 34 ca 5e f0 01 	movl   $0x1,0xf05eca34
f010ede4:	00 00 00 
f010ede7:	90                   	nop
f010ede8:	5d                   	pop    %ebp
f010ede9:	c3                   	ret    

f010edea <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010edea:	55                   	push   %ebp
f010edeb:	89 e5                	mov    %esp,%ebp
f010eded:	c7 05 34 ca 5e f0 02 	movl   $0x2,0xf05eca34
f010edf4:	00 00 00 
f010edf7:	90                   	nop
f010edf8:	5d                   	pop    %ebp
f010edf9:	c3                   	ret    

f010edfa <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010edfa:	55                   	push   %ebp
f010edfb:	89 e5                	mov    %esp,%ebp
f010edfd:	c7 05 34 ca 5e f0 03 	movl   $0x3,0xf05eca34
f010ee04:	00 00 00 
f010ee07:	90                   	nop
f010ee08:	5d                   	pop    %ebp
f010ee09:	c3                   	ret    

f010ee0a <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010ee0a:	55                   	push   %ebp
f010ee0b:	89 e5                	mov    %esp,%ebp
f010ee0d:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f010ee12:	83 f8 01             	cmp    $0x1,%eax
f010ee15:	75 04                	jne    f010ee1b <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010ee17:	b0 01                	mov    $0x1,%al
f010ee19:	eb 02                	jmp    f010ee1d <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010ee1b:	b0 00                	mov    $0x0,%al
f010ee1d:	5d                   	pop    %ebp
f010ee1e:	c3                   	ret    

f010ee1f <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010ee1f:	55                   	push   %ebp
f010ee20:	89 e5                	mov    %esp,%ebp
f010ee22:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f010ee27:	83 f8 02             	cmp    $0x2,%eax
f010ee2a:	75 04                	jne    f010ee30 <isKHeapPlacementStrategyBESTFIT+0x11>
f010ee2c:	b0 01                	mov    $0x1,%al
f010ee2e:	eb 02                	jmp    f010ee32 <isKHeapPlacementStrategyBESTFIT+0x13>
f010ee30:	b0 00                	mov    $0x0,%al
f010ee32:	5d                   	pop    %ebp
f010ee33:	c3                   	ret    

f010ee34 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010ee34:	55                   	push   %ebp
f010ee35:	89 e5                	mov    %esp,%ebp
f010ee37:	a1 34 ca 5e f0       	mov    0xf05eca34,%eax
f010ee3c:	83 f8 03             	cmp    $0x3,%eax
f010ee3f:	75 04                	jne    f010ee45 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010ee41:	b0 01                	mov    $0x1,%al
f010ee43:	eb 02                	jmp    f010ee47 <isKHeapPlacementStrategyNEXTFIT+0x13>
f010ee45:	b0 00                	mov    $0x0,%al
f010ee47:	5d                   	pop    %ebp
f010ee48:	c3                   	ret    

f010ee49 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010ee49:	55                   	push   %ebp
f010ee4a:	89 e5                	mov    %esp,%ebp
f010ee4c:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ee4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ee56:	eb 26                	jmp    f010ee7e <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010ee58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee5b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ee62:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee65:	01 c2                	add    %eax,%edx
f010ee67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee6a:	40                   	inc    %eax
f010ee6b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ee72:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee75:	01 c8                	add    %ecx,%eax
f010ee77:	8b 00                	mov    (%eax),%eax
f010ee79:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ee7b:	ff 45 f4             	incl   -0xc(%ebp)
f010ee7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee81:	48                   	dec    %eax
f010ee82:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ee85:	7f d1                	jg     f010ee58 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010ee87:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010ee8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010ee91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010ee98:	eb 35                	jmp    f010eecf <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010ee9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ee9d:	89 d0                	mov    %edx,%eax
f010ee9f:	01 c0                	add    %eax,%eax
f010eea1:	01 d0                	add    %edx,%eax
f010eea3:	c1 e0 02             	shl    $0x2,%eax
f010eea6:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f010eeab:	8b 10                	mov    (%eax),%edx
f010eead:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eeb0:	8b 00                	mov    (%eax),%eax
f010eeb2:	83 ec 08             	sub    $0x8,%esp
f010eeb5:	52                   	push   %edx
f010eeb6:	50                   	push   %eax
f010eeb7:	e8 3f fa 00 00       	call   f011e8fb <strcmp>
f010eebc:	83 c4 10             	add    $0x10,%esp
f010eebf:	85 c0                	test   %eax,%eax
f010eec1:	75 09                	jne    f010eecc <tst_handler+0x83>
		{
			test_found = 1;
f010eec3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010eeca:	eb 0f                	jmp    f010eedb <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010eecc:	ff 45 ec             	incl   -0x14(%ebp)
f010eecf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010eed2:	a1 b4 bd 17 f0       	mov    0xf017bdb4,%eax
f010eed7:	39 c2                	cmp    %eax,%edx
f010eed9:	72 bf                	jb     f010ee9a <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010eedb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010eedf:	74 29                	je     f010ef0a <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010eee1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010eee4:	89 d0                	mov    %edx,%eax
f010eee6:	01 c0                	add    %eax,%eax
f010eee8:	01 d0                	add    %edx,%eax
f010eeea:	c1 e0 02             	shl    $0x2,%eax
f010eeed:	05 08 bd 17 f0       	add    $0xf017bd08,%eax
f010eef2:	8b 00                	mov    (%eax),%eax
f010eef4:	83 ec 08             	sub    $0x8,%esp
f010eef7:	ff 75 0c             	pushl  0xc(%ebp)
f010eefa:	ff 75 08             	pushl  0x8(%ebp)
f010eefd:	ff d0                	call   *%eax
f010eeff:	83 c4 10             	add    $0x10,%esp
f010ef02:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010ef05:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ef08:	eb 1b                	jmp    f010ef25 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010ef0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef0d:	8b 00                	mov    (%eax),%eax
f010ef0f:	83 ec 08             	sub    $0x8,%esp
f010ef12:	50                   	push   %eax
f010ef13:	68 bc 6b 12 f0       	push   $0xf0126bbc
f010ef18:	e8 6e 20 ff ff       	call   f0100f8b <cprintf>
f010ef1d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef20:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010ef25:	c9                   	leave  
f010ef26:	c3                   	ret    

f010ef27 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010ef27:	55                   	push   %ebp
f010ef28:	89 e5                	mov    %esp,%ebp
f010ef2a:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010ef2d:	e8 48 d0 00 00       	call   f011bf7a <test_three_creation_functions>
	return 0;
f010ef32:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef37:	c9                   	leave  
f010ef38:	c3                   	ret    

f010ef39 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010ef39:	55                   	push   %ebp
f010ef3a:	89 e5                	mov    %esp,%ebp
f010ef3c:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010ef3f:	e8 03 69 00 00       	call   f0115847 <test_priority_normal_and_higher>
	return 0;
f010ef44:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef49:	c9                   	leave  
f010ef4a:	c3                   	ret    

f010ef4b <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010ef4b:	55                   	push   %ebp
f010ef4c:	89 e5                	mov    %esp,%ebp
f010ef4e:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010ef51:	e8 0b 69 00 00       	call   f0115861 <test_priority_normal_and_lower>
	return 0;
f010ef56:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef5b:	c9                   	leave  
f010ef5c:	c3                   	ret    

f010ef5d <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010ef5d:	55                   	push   %ebp
f010ef5e:	89 e5                	mov    %esp,%ebp
f010ef60:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010ef63:	e8 c5 d1 00 00       	call   f011c12d <test_kfreeall>
	return 0;
f010ef68:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef6d:	c9                   	leave  
f010ef6e:	c3                   	ret    

f010ef6f <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010ef6f:	55                   	push   %ebp
f010ef70:	89 e5                	mov    %esp,%ebp
f010ef72:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010ef75:	e8 d0 d1 00 00       	call   f011c14a <test_kexpand>
	return 0;
f010ef7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef7f:	c9                   	leave  
f010ef80:	c3                   	ret    

f010ef81 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010ef81:	55                   	push   %ebp
f010ef82:	89 e5                	mov    %esp,%ebp
f010ef84:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010ef87:	e8 db d1 00 00       	call   f011c167 <test_kshrink>
	return 0;
f010ef8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef91:	c9                   	leave  
f010ef92:	c3                   	ret    

f010ef93 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010ef93:	55                   	push   %ebp
f010ef94:	89 e5                	mov    %esp,%ebp
f010ef96:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010ef99:	e8 e6 d1 00 00       	call   f011c184 <test_kfreelast>
	return 0;
f010ef9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010efa3:	c9                   	leave  
f010efa4:	c3                   	ret    

f010efa5 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010efa5:	55                   	push   %ebp
f010efa6:	89 e5                	mov    %esp,%ebp
f010efa8:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010efab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efae:	83 c0 04             	add    $0x4,%eax
f010efb1:	8b 00                	mov    (%eax),%eax
f010efb3:	83 ec 04             	sub    $0x4,%esp
f010efb6:	6a 0a                	push   $0xa
f010efb8:	6a 00                	push   $0x0
f010efba:	50                   	push   %eax
f010efbb:	e8 8f fb 00 00       	call   f011eb4f <strtol>
f010efc0:	83 c4 10             	add    $0x10,%esp
f010efc3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010efc6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010efcd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010efd4:	83 ec 0c             	sub    $0xc,%esp
f010efd7:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010efdc:	e8 81 f8 ff ff       	call   f010e862 <acquire_spinlock>
f010efe1:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010efe4:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f010efe9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010efec:	eb 3b                	jmp    f010f029 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010efee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eff1:	83 c0 20             	add    $0x20,%eax
f010eff4:	83 ec 08             	sub    $0x8,%esp
f010eff7:	68 cf 6b 12 f0       	push   $0xf0126bcf
f010effc:	50                   	push   %eax
f010effd:	e8 f9 f8 00 00       	call   f011e8fb <strcmp>
f010f002:	83 c4 10             	add    $0x10,%esp
f010f005:	85 c0                	test   %eax,%eax
f010f007:	75 12                	jne    f010f01b <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010f009:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f00d:	74 07                	je     f010f016 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010f00f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010f016:	ff 45 f4             	incl   -0xc(%ebp)
f010f019:	eb 06                	jmp    f010f021 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010f01b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f01f:	74 31                	je     f010f052 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f021:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f010f026:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f029:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f02d:	74 08                	je     f010f037 <tst_sc_MLFQ+0x92>
f010f02f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f032:	8b 40 08             	mov    0x8(%eax),%eax
f010f035:	eb 05                	jmp    f010f03c <tst_sc_MLFQ+0x97>
f010f037:	b8 00 00 00 00       	mov    $0x0,%eax
f010f03c:	a3 28 c5 5e f0       	mov    %eax,0xf05ec528
f010f041:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f010f046:	85 c0                	test   %eax,%eax
f010f048:	75 a4                	jne    f010efee <tst_sc_MLFQ+0x49>
f010f04a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f04e:	75 9e                	jne    f010efee <tst_sc_MLFQ+0x49>
f010f050:	eb 01                	jmp    f010f053 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010f052:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010f053:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f056:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f059:	75 12                	jne    f010f06d <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010f05b:	83 ec 0c             	sub    $0xc,%esp
f010f05e:	68 d8 6b 12 f0       	push   $0xf0126bd8
f010f063:	e8 23 1f ff ff       	call   f0100f8b <cprintf>
f010f068:	83 c4 10             	add    $0x10,%esp
f010f06b:	eb 17                	jmp    f010f084 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010f06d:	83 ec 04             	sub    $0x4,%esp
f010f070:	68 11 6c 12 f0       	push   $0xf0126c11
f010f075:	68 9b 00 00 00       	push   $0x9b
f010f07a:	68 27 6c 12 f0       	push   $0xf0126c27
f010f07f:	e8 b5 12 ff ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010f084:	83 ec 0c             	sub    $0xc,%esp
f010f087:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f010f08c:	e8 58 f8 ff ff       	call   f010e8e9 <release_spinlock>
f010f091:	83 c4 10             	add    $0x10,%esp
	return 0;
f010f094:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f099:	c9                   	leave  
f010f09a:	c3                   	ret    

f010f09b <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010f09b:	55                   	push   %ebp
f010f09c:	89 e5                	mov    %esp,%ebp
f010f09e:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010f0a1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f0a5:	74 17                	je     f010f0be <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010f0a7:	83 ec 0c             	sub    $0xc,%esp
f010f0aa:	68 40 6c 12 f0       	push   $0xf0126c40
f010f0af:	e8 d7 1e ff ff       	call   f0100f8b <cprintf>
f010f0b4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0b7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0bc:	eb 45                	jmp    f010f103 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010f0be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0c1:	83 c0 04             	add    $0x4,%eax
f010f0c4:	8b 00                	mov    (%eax),%eax
f010f0c6:	83 ec 04             	sub    $0x4,%esp
f010f0c9:	6a 0a                	push   $0xa
f010f0cb:	6a 00                	push   $0x0
f010f0cd:	50                   	push   %eax
f010f0ce:	e8 7c fa 00 00       	call   f011eb4f <strtol>
f010f0d3:	83 c4 10             	add    $0x10,%esp
f010f0d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010f0d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f0dc:	83 f8 01             	cmp    $0x1,%eax
f010f0df:	74 10                	je     f010f0f1 <tst_bsd_nice+0x56>
f010f0e1:	83 f8 02             	cmp    $0x2,%eax
f010f0e4:	74 12                	je     f010f0f8 <tst_bsd_nice+0x5d>
f010f0e6:	85 c0                	test   %eax,%eax
f010f0e8:	75 14                	jne    f010f0fe <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010f0ea:	e8 98 d2 00 00       	call   f011c387 <test_bsd_nice_0>
		break;
f010f0ef:	eb 0d                	jmp    f010f0fe <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010f0f1:	e8 1b d5 00 00       	call   f011c611 <test_bsd_nice_1>
		break;
f010f0f6:	eb 06                	jmp    f010f0fe <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010f0f8:	e8 28 d7 00 00       	call   f011c825 <test_bsd_nice_2>
		break;
f010f0fd:	90                   	nop
	}
	return 0;
f010f0fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f103:	c9                   	leave  
f010f104:	c3                   	ret    

f010f105 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010f105:	55                   	push   %ebp
f010f106:	89 e5                	mov    %esp,%ebp
f010f108:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010f10b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f10f:	74 17                	je     f010f128 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010f111:	83 ec 0c             	sub    $0xc,%esp
f010f114:	68 80 6c 12 f0       	push   $0xf0126c80
f010f119:	e8 6d 1e ff ff       	call   f0100f8b <cprintf>
f010f11e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f121:	b8 00 00 00 00       	mov    $0x0,%eax
f010f126:	eb 0a                	jmp    f010f132 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010f128:	e8 3f 15 00 00       	call   f011066c <test_str2lower_function>
	return 0;
f010f12d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f132:	c9                   	leave  
f010f133:	c3                   	ret    

f010f134 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010f134:	55                   	push   %ebp
f010f135:	89 e5                	mov    %esp,%ebp
f010f137:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010f13a:	e8 63 11 00 00       	call   f01102a2 <TestAutoCompleteCommand>
f010f13f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010f142:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f147:	c9                   	leave  
f010f148:	c3                   	ret    

f010f149 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010f149:	55                   	push   %ebp
f010f14a:	89 e5                	mov    %esp,%ebp
f010f14c:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f14f:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f153:	74 1a                	je     f010f16f <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010f155:	83 ec 0c             	sub    $0xc,%esp
f010f158:	68 b4 6c 12 f0       	push   $0xf0126cb4
f010f15d:	e8 29 1e ff ff       	call   f0100f8b <cprintf>
f010f162:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f165:	b8 00 00 00 00       	mov    $0x0,%eax
f010f16a:	e9 2f 01 00 00       	jmp    f010f29e <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010f16f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f172:	83 c0 04             	add    $0x4,%eax
f010f175:	8b 00                	mov    (%eax),%eax
f010f177:	83 ec 08             	sub    $0x8,%esp
f010f17a:	68 f1 6c 12 f0       	push   $0xf0126cf1
f010f17f:	50                   	push   %eax
f010f180:	e8 76 f7 00 00       	call   f011e8fb <strcmp>
f010f185:	83 c4 10             	add    $0x10,%esp
f010f188:	85 c0                	test   %eax,%eax
f010f18a:	75 0a                	jne    f010f196 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010f18c:	e8 40 08 00 00       	call   f010f9d1 <test_initialize_dynamic_allocator>
f010f191:	e9 03 01 00 00       	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010f196:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f199:	83 c0 04             	add    $0x4,%eax
f010f19c:	8b 00                	mov    (%eax),%eax
f010f19e:	83 ec 08             	sub    $0x8,%esp
f010f1a1:	68 f6 6c 12 f0       	push   $0xf0126cf6
f010f1a6:	50                   	push   %eax
f010f1a7:	e8 4f f7 00 00       	call   f011e8fb <strcmp>
f010f1ac:	83 c4 10             	add    $0x10,%esp
f010f1af:	85 c0                	test   %eax,%eax
f010f1b1:	75 0a                	jne    f010f1bd <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010f1b3:	e8 4d 08 00 00       	call   f010fa05 <test_alloc_block_FF>
f010f1b8:	e9 dc 00 00 00       	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010f1bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1c0:	83 c0 04             	add    $0x4,%eax
f010f1c3:	8b 00                	mov    (%eax),%eax
f010f1c5:	83 ec 08             	sub    $0x8,%esp
f010f1c8:	68 fe 6c 12 f0       	push   $0xf0126cfe
f010f1cd:	50                   	push   %eax
f010f1ce:	e8 28 f7 00 00       	call   f011e8fb <strcmp>
f010f1d3:	83 c4 10             	add    $0x10,%esp
f010f1d6:	85 c0                	test   %eax,%eax
f010f1d8:	75 0a                	jne    f010f1e4 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010f1da:	e8 43 08 00 00       	call   f010fa22 <test_alloc_block_BF>
f010f1df:	e9 b5 00 00 00       	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010f1e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1e7:	83 c0 04             	add    $0x4,%eax
f010f1ea:	8b 00                	mov    (%eax),%eax
f010f1ec:	83 ec 08             	sub    $0x8,%esp
f010f1ef:	68 06 6d 12 f0       	push   $0xf0126d06
f010f1f4:	50                   	push   %eax
f010f1f5:	e8 01 f7 00 00       	call   f011e8fb <strcmp>
f010f1fa:	83 c4 10             	add    $0x10,%esp
f010f1fd:	85 c0                	test   %eax,%eax
f010f1ff:	75 0a                	jne    f010f20b <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010f201:	e8 3c 08 00 00       	call   f010fa42 <test_alloc_block_NF>
f010f206:	e9 8e 00 00 00       	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010f20b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f20e:	83 c0 04             	add    $0x4,%eax
f010f211:	8b 00                	mov    (%eax),%eax
f010f213:	83 ec 08             	sub    $0x8,%esp
f010f216:	68 0e 6d 12 f0       	push   $0xf0126d0e
f010f21b:	50                   	push   %eax
f010f21c:	e8 da f6 00 00       	call   f011e8fb <strcmp>
f010f221:	83 c4 10             	add    $0x10,%esp
f010f224:	85 c0                	test   %eax,%eax
f010f226:	75 07                	jne    f010f22f <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010f228:	e8 1b 08 00 00       	call   f010fa48 <test_free_block_FF>
f010f22d:	eb 6a                	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010f22f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f232:	83 c0 04             	add    $0x4,%eax
f010f235:	8b 00                	mov    (%eax),%eax
f010f237:	83 ec 08             	sub    $0x8,%esp
f010f23a:	68 15 6d 12 f0       	push   $0xf0126d15
f010f23f:	50                   	push   %eax
f010f240:	e8 b6 f6 00 00       	call   f011e8fb <strcmp>
f010f245:	83 c4 10             	add    $0x10,%esp
f010f248:	85 c0                	test   %eax,%eax
f010f24a:	75 07                	jne    f010f253 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f24c:	e8 14 08 00 00       	call   f010fa65 <test_free_block_BF>
f010f251:	eb 46                	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f253:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f256:	83 c0 04             	add    $0x4,%eax
f010f259:	8b 00                	mov    (%eax),%eax
f010f25b:	83 ec 08             	sub    $0x8,%esp
f010f25e:	68 1c 6d 12 f0       	push   $0xf0126d1c
f010f263:	50                   	push   %eax
f010f264:	e8 92 f6 00 00       	call   f011e8fb <strcmp>
f010f269:	83 c4 10             	add    $0x10,%esp
f010f26c:	85 c0                	test   %eax,%eax
f010f26e:	75 07                	jne    f010f277 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f270:	e8 0d 08 00 00       	call   f010fa82 <test_free_block_NF>
f010f275:	eb 22                	jmp    f010f299 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f277:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f27a:	83 c0 04             	add    $0x4,%eax
f010f27d:	8b 00                	mov    (%eax),%eax
f010f27f:	83 ec 08             	sub    $0x8,%esp
f010f282:	68 23 6d 12 f0       	push   $0xf0126d23
f010f287:	50                   	push   %eax
f010f288:	e8 6e f6 00 00       	call   f011e8fb <strcmp>
f010f28d:	83 c4 10             	add    $0x10,%esp
f010f290:	85 c0                	test   %eax,%eax
f010f292:	75 05                	jne    f010f299 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f294:	e8 06 08 00 00       	call   f010fa9f <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f299:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f29e:	c9                   	leave  
f010f29f:	c3                   	ret    

f010f2a0 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f2a0:	55                   	push   %ebp
f010f2a1:	89 e5                	mov    %esp,%ebp
f010f2a3:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f2a6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f2aa:	74 1a                	je     f010f2c6 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f2ac:	83 ec 0c             	sub    $0xc,%esp
f010f2af:	68 30 6d 12 f0       	push   $0xf0126d30
f010f2b4:	e8 d2 1c ff ff       	call   f0100f8b <cprintf>
f010f2b9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2bc:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2c1:	e9 e1 00 00 00       	jmp    f010f3a7 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f2c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2c9:	83 c0 04             	add    $0x4,%eax
f010f2cc:	8b 00                	mov    (%eax),%eax
f010f2ce:	83 ec 08             	sub    $0x8,%esp
f010f2d1:	68 69 6d 12 f0       	push   $0xf0126d69
f010f2d6:	50                   	push   %eax
f010f2d7:	e8 1f f6 00 00       	call   f011e8fb <strcmp>
f010f2dc:	83 c4 10             	add    $0x10,%esp
f010f2df:	85 c0                	test   %eax,%eax
f010f2e1:	75 0a                	jne    f010f2ed <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f2e3:	e8 97 1c 00 00       	call   f0110f7f <test_cut_paste_pages>
f010f2e8:	e9 b5 00 00 00       	jmp    f010f3a2 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f2ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f0:	83 c0 04             	add    $0x4,%eax
f010f2f3:	8b 00                	mov    (%eax),%eax
f010f2f5:	83 ec 08             	sub    $0x8,%esp
f010f2f8:	68 72 6d 12 f0       	push   $0xf0126d72
f010f2fd:	50                   	push   %eax
f010f2fe:	e8 f8 f5 00 00       	call   f011e8fb <strcmp>
f010f303:	83 c4 10             	add    $0x10,%esp
f010f306:	85 c0                	test   %eax,%eax
f010f308:	75 0a                	jne    f010f314 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f30a:	e8 bb 26 00 00       	call   f01119ca <test_copy_paste_chunk>
f010f30f:	e9 8e 00 00 00       	jmp    f010f3a2 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f314:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f317:	83 c0 04             	add    $0x4,%eax
f010f31a:	8b 00                	mov    (%eax),%eax
f010f31c:	83 ec 08             	sub    $0x8,%esp
f010f31f:	68 7c 6d 12 f0       	push   $0xf0126d7c
f010f324:	50                   	push   %eax
f010f325:	e8 d1 f5 00 00       	call   f011e8fb <strcmp>
f010f32a:	83 c4 10             	add    $0x10,%esp
f010f32d:	85 c0                	test   %eax,%eax
f010f32f:	75 07                	jne    f010f338 <tst_chunks+0x98>
	{
		test_share_chunk();
f010f331:	e8 92 37 00 00       	call   f0112ac8 <test_share_chunk>
f010f336:	eb 6a                	jmp    f010f3a2 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f338:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f33b:	83 c0 04             	add    $0x4,%eax
f010f33e:	8b 00                	mov    (%eax),%eax
f010f340:	83 ec 08             	sub    $0x8,%esp
f010f343:	68 82 6d 12 f0       	push   $0xf0126d82
f010f348:	50                   	push   %eax
f010f349:	e8 ad f5 00 00       	call   f011e8fb <strcmp>
f010f34e:	83 c4 10             	add    $0x10,%esp
f010f351:	85 c0                	test   %eax,%eax
f010f353:	75 07                	jne    f010f35c <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f355:	e8 96 41 00 00       	call   f01134f0 <test_allocate_chunk>
f010f35a:	eb 46                	jmp    f010f3a2 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f35c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f35f:	83 c0 04             	add    $0x4,%eax
f010f362:	8b 00                	mov    (%eax),%eax
f010f364:	83 ec 08             	sub    $0x8,%esp
f010f367:	68 8b 6d 12 f0       	push   $0xf0126d8b
f010f36c:	50                   	push   %eax
f010f36d:	e8 89 f5 00 00       	call   f011e8fb <strcmp>
f010f372:	83 c4 10             	add    $0x10,%esp
f010f375:	85 c0                	test   %eax,%eax
f010f377:	75 07                	jne    f010f380 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f379:	e8 79 4a 00 00       	call   f0113df7 <test_calculate_required_frames>
f010f37e:	eb 22                	jmp    f010f3a2 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f380:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f383:	83 c0 04             	add    $0x4,%eax
f010f386:	8b 00                	mov    (%eax),%eax
f010f388:	83 ec 08             	sub    $0x8,%esp
f010f38b:	68 9a 6d 12 f0       	push   $0xf0126d9a
f010f390:	50                   	push   %eax
f010f391:	e8 65 f5 00 00       	call   f011e8fb <strcmp>
f010f396:	83 c4 10             	add    $0x10,%esp
f010f399:	85 c0                	test   %eax,%eax
f010f39b:	75 05                	jne    f010f3a2 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f39d:	e8 c9 52 00 00       	call   f011466b <test_calculate_allocated_space>
	}
	return 0;
f010f3a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f3a7:	c9                   	leave  
f010f3a8:	c3                   	ret    

f010f3a9 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f3a9:	55                   	push   %ebp
f010f3aa:	89 e5                	mov    %esp,%ebp
f010f3ac:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f3af:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f3b3:	74 1a                	je     f010f3cf <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f3b5:	83 ec 0c             	sub    $0xc,%esp
f010f3b8:	68 ac 6d 12 f0       	push   $0xf0126dac
f010f3bd:	e8 c9 1b ff ff       	call   f0100f8b <cprintf>
f010f3c2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3c5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3ca:	e9 ba 00 00 00       	jmp    f010f489 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f3cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3d2:	83 c0 04             	add    $0x4,%eax
f010f3d5:	8b 00                	mov    (%eax),%eax
f010f3d7:	83 ec 08             	sub    $0x8,%esp
f010f3da:	68 e2 6d 12 f0       	push   $0xf0126de2
f010f3df:	50                   	push   %eax
f010f3e0:	e8 16 f5 00 00       	call   f011e8fb <strcmp>
f010f3e5:	83 c4 10             	add    $0x10,%esp
f010f3e8:	85 c0                	test   %eax,%eax
f010f3ea:	75 0a                	jne    f010f3f6 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f3ec:	e8 01 16 00 00       	call   f01109f2 <test_pt_set_page_permissions>
f010f3f1:	e9 8e 00 00 00       	jmp    f010f484 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f3f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3f9:	83 c0 04             	add    $0x4,%eax
f010f3fc:	8b 00                	mov    (%eax),%eax
f010f3fe:	83 ec 08             	sub    $0x8,%esp
f010f401:	68 ea 6d 12 f0       	push   $0xf0126dea
f010f406:	50                   	push   %eax
f010f407:	e8 ef f4 00 00       	call   f011e8fb <strcmp>
f010f40c:	83 c4 10             	add    $0x10,%esp
f010f40f:	85 c0                	test   %eax,%eax
f010f411:	75 07                	jne    f010f41a <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f413:	e8 49 18 00 00       	call   f0110c61 <test_pt_set_page_permissions_invalid_va>
f010f418:	eb 6a                	jmp    f010f484 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f41a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f41d:	83 c0 04             	add    $0x4,%eax
f010f420:	8b 00                	mov    (%eax),%eax
f010f422:	83 ec 08             	sub    $0x8,%esp
f010f425:	68 f2 6d 12 f0       	push   $0xf0126df2
f010f42a:	50                   	push   %eax
f010f42b:	e8 cb f4 00 00       	call   f011e8fb <strcmp>
f010f430:	83 c4 10             	add    $0x10,%esp
f010f433:	85 c0                	test   %eax,%eax
f010f435:	75 07                	jne    f010f43e <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f437:	e8 6e 18 00 00       	call   f0110caa <test_pt_get_page_permissions>
f010f43c:	eb 46                	jmp    f010f484 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f43e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f441:	83 c0 04             	add    $0x4,%eax
f010f444:	8b 00                	mov    (%eax),%eax
f010f446:	83 ec 08             	sub    $0x8,%esp
f010f449:	68 fa 6d 12 f0       	push   $0xf0126dfa
f010f44e:	50                   	push   %eax
f010f44f:	e8 a7 f4 00 00       	call   f011e8fb <strcmp>
f010f454:	83 c4 10             	add    $0x10,%esp
f010f457:	85 c0                	test   %eax,%eax
f010f459:	75 07                	jne    f010f462 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f45b:	e8 8e 19 00 00       	call   f0110dee <test_pt_clear_page_table_entry>
f010f460:	eb 22                	jmp    f010f484 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f462:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f465:	83 c0 04             	add    $0x4,%eax
f010f468:	8b 00                	mov    (%eax),%eax
f010f46a:	83 ec 08             	sub    $0x8,%esp
f010f46d:	68 01 6e 12 f0       	push   $0xf0126e01
f010f472:	50                   	push   %eax
f010f473:	e8 83 f4 00 00       	call   f011e8fb <strcmp>
f010f478:	83 c4 10             	add    $0x10,%esp
f010f47b:	85 c0                	test   %eax,%eax
f010f47d:	75 05                	jne    f010f484 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f47f:	e8 c3 1a 00 00       	call   f0110f47 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f484:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f489:	c9                   	leave  
f010f48a:	c3                   	ret    

f010f48b <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f48b:	55                   	push   %ebp
f010f48c:	89 e5                	mov    %esp,%ebp
f010f48e:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f491:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f494:	83 c0 08             	add    $0x8,%eax
f010f497:	8b 00                	mov    (%eax),%eax
f010f499:	83 ec 08             	sub    $0x8,%esp
f010f49c:	68 08 6e 12 f0       	push   $0xf0126e08
f010f4a1:	50                   	push   %eax
f010f4a2:	e8 54 f4 00 00       	call   f011e8fb <strcmp>
f010f4a7:	83 c4 10             	add    $0x10,%esp
f010f4aa:	85 c0                	test   %eax,%eax
f010f4ac:	75 20                	jne    f010f4ce <tst_kheap+0x43>
f010f4ae:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f4b2:	74 1a                	je     f010f4ce <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f4b4:	83 ec 0c             	sub    $0xc,%esp
f010f4b7:	68 10 6e 12 f0       	push   $0xf0126e10
f010f4bc:	e8 ca 1a ff ff       	call   f0100f8b <cprintf>
f010f4c1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4c4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4c9:	e9 42 04 00 00       	jmp    f010f910 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f4ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4d1:	83 c0 08             	add    $0x8,%eax
f010f4d4:	8b 00                	mov    (%eax),%eax
f010f4d6:	83 ec 08             	sub    $0x8,%esp
f010f4d9:	68 08 6e 12 f0       	push   $0xf0126e08
f010f4de:	50                   	push   %eax
f010f4df:	e8 17 f4 00 00       	call   f011e8fb <strcmp>
f010f4e4:	83 c4 10             	add    $0x10,%esp
f010f4e7:	85 c0                	test   %eax,%eax
f010f4e9:	74 43                	je     f010f52e <tst_kheap+0xa3>
f010f4eb:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f4ef:	74 3d                	je     f010f52e <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f4f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f4:	83 c0 08             	add    $0x8,%eax
f010f4f7:	8b 00                	mov    (%eax),%eax
f010f4f9:	83 ec 08             	sub    $0x8,%esp
f010f4fc:	68 60 6e 12 f0       	push   $0xf0126e60
f010f501:	50                   	push   %eax
f010f502:	e8 f4 f3 00 00       	call   f011e8fb <strcmp>
f010f507:	83 c4 10             	add    $0x10,%esp
f010f50a:	85 c0                	test   %eax,%eax
f010f50c:	74 20                	je     f010f52e <tst_kheap+0xa3>
f010f50e:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f512:	74 1a                	je     f010f52e <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f514:	83 ec 0c             	sub    $0xc,%esp
f010f517:	68 6c 6e 12 f0       	push   $0xf0126e6c
f010f51c:	e8 6a 1a ff ff       	call   f0100f8b <cprintf>
f010f521:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f524:	b8 00 00 00 00       	mov    $0x0,%eax
f010f529:	e9 e2 03 00 00       	jmp    f010f910 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f52e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f531:	83 c0 04             	add    $0x4,%eax
f010f534:	8b 00                	mov    (%eax),%eax
f010f536:	83 ec 08             	sub    $0x8,%esp
f010f539:	68 b1 6e 12 f0       	push   $0xf0126eb1
f010f53e:	50                   	push   %eax
f010f53f:	e8 b7 f3 00 00       	call   f011e8fb <strcmp>
f010f544:	83 c4 10             	add    $0x10,%esp
f010f547:	85 c0                	test   %eax,%eax
f010f549:	74 1d                	je     f010f568 <tst_kheap+0xdd>
f010f54b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f54e:	83 c0 04             	add    $0x4,%eax
f010f551:	8b 00                	mov    (%eax),%eax
f010f553:	83 ec 08             	sub    $0x8,%esp
f010f556:	68 b4 6e 12 f0       	push   $0xf0126eb4
f010f55b:	50                   	push   %eax
f010f55c:	e8 9a f3 00 00       	call   f011e8fb <strcmp>
f010f561:	83 c4 10             	add    $0x10,%esp
f010f564:	85 c0                	test   %eax,%eax
f010f566:	75 1a                	jne    f010f582 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f568:	e8 6d f8 ff ff       	call   f010edda <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f56d:	83 ec 0c             	sub    $0xc,%esp
f010f570:	68 b8 6e 12 f0       	push   $0xf0126eb8
f010f575:	e8 11 1a ff ff       	call   f0100f8b <cprintf>
f010f57a:	83 c4 10             	add    $0x10,%esp
f010f57d:	e9 a0 00 00 00       	jmp    f010f622 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f582:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f585:	83 c0 04             	add    $0x4,%eax
f010f588:	8b 00                	mov    (%eax),%eax
f010f58a:	83 ec 08             	sub    $0x8,%esp
f010f58d:	68 e5 6e 12 f0       	push   $0xf0126ee5
f010f592:	50                   	push   %eax
f010f593:	e8 63 f3 00 00       	call   f011e8fb <strcmp>
f010f598:	83 c4 10             	add    $0x10,%esp
f010f59b:	85 c0                	test   %eax,%eax
f010f59d:	74 1d                	je     f010f5bc <tst_kheap+0x131>
f010f59f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5a2:	83 c0 04             	add    $0x4,%eax
f010f5a5:	8b 00                	mov    (%eax),%eax
f010f5a7:	83 ec 08             	sub    $0x8,%esp
f010f5aa:	68 e8 6e 12 f0       	push   $0xf0126ee8
f010f5af:	50                   	push   %eax
f010f5b0:	e8 46 f3 00 00       	call   f011e8fb <strcmp>
f010f5b5:	83 c4 10             	add    $0x10,%esp
f010f5b8:	85 c0                	test   %eax,%eax
f010f5ba:	75 17                	jne    f010f5d3 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f5bc:	e8 29 f8 ff ff       	call   f010edea <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f5c1:	83 ec 0c             	sub    $0xc,%esp
f010f5c4:	68 ec 6e 12 f0       	push   $0xf0126eec
f010f5c9:	e8 bd 19 ff ff       	call   f0100f8b <cprintf>
f010f5ce:	83 c4 10             	add    $0x10,%esp
f010f5d1:	eb 4f                	jmp    f010f622 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f5d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d6:	83 c0 04             	add    $0x4,%eax
f010f5d9:	8b 00                	mov    (%eax),%eax
f010f5db:	83 ec 08             	sub    $0x8,%esp
f010f5de:	68 18 6f 12 f0       	push   $0xf0126f18
f010f5e3:	50                   	push   %eax
f010f5e4:	e8 12 f3 00 00       	call   f011e8fb <strcmp>
f010f5e9:	83 c4 10             	add    $0x10,%esp
f010f5ec:	85 c0                	test   %eax,%eax
f010f5ee:	74 1d                	je     f010f60d <tst_kheap+0x182>
f010f5f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5f3:	83 c0 04             	add    $0x4,%eax
f010f5f6:	8b 00                	mov    (%eax),%eax
f010f5f8:	83 ec 08             	sub    $0x8,%esp
f010f5fb:	68 1b 6f 12 f0       	push   $0xf0126f1b
f010f600:	50                   	push   %eax
f010f601:	e8 f5 f2 00 00       	call   f011e8fb <strcmp>
f010f606:	83 c4 10             	add    $0x10,%esp
f010f609:	85 c0                	test   %eax,%eax
f010f60b:	75 15                	jne    f010f622 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f60d:	e8 e8 f7 ff ff       	call   f010edfa <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f612:	83 ec 0c             	sub    $0xc,%esp
f010f615:	68 20 6f 12 f0       	push   $0xf0126f20
f010f61a:	e8 6c 19 ff ff       	call   f0100f8b <cprintf>
f010f61f:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f622:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f625:	83 c0 08             	add    $0x8,%eax
f010f628:	8b 00                	mov    (%eax),%eax
f010f62a:	83 ec 08             	sub    $0x8,%esp
f010f62d:	68 08 6e 12 f0       	push   $0xf0126e08
f010f632:	50                   	push   %eax
f010f633:	e8 c3 f2 00 00       	call   f011e8fb <strcmp>
f010f638:	83 c4 10             	add    $0x10,%esp
f010f63b:	85 c0                	test   %eax,%eax
f010f63d:	0f 85 13 01 00 00    	jne    f010f756 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f643:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f646:	83 c0 0c             	add    $0xc,%eax
f010f649:	8b 00                	mov    (%eax),%eax
f010f64b:	83 ec 04             	sub    $0x4,%esp
f010f64e:	6a 0a                	push   $0xa
f010f650:	6a 00                	push   $0x0
f010f652:	50                   	push   %eax
f010f653:	e8 f7 f4 00 00       	call   f011eb4f <strtol>
f010f658:	83 c4 10             	add    $0x10,%esp
f010f65b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f65e:	e8 a7 f7 ff ff       	call   f010ee0a <isKHeapPlacementStrategyFIRSTFIT>
f010f663:	84 c0                	test   %al,%al
f010f665:	74 54                	je     f010f6bb <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f667:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f66b:	75 1a                	jne    f010f687 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f66d:	83 ec 0c             	sub    $0xc,%esp
f010f670:	68 4c 6f 12 f0       	push   $0xf0126f4c
f010f675:	e8 11 19 ff ff       	call   f0100f8b <cprintf>
f010f67a:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f67d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f682:	e9 89 02 00 00       	jmp    f010f910 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f687:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f68b:	75 0a                	jne    f010f697 <tst_kheap+0x20c>
				test_kmalloc();
f010f68d:	e8 ec 61 00 00       	call   f011587e <test_kmalloc>
f010f692:	e9 b5 00 00 00       	jmp    f010f74c <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f697:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f69b:	75 0a                	jne    f010f6a7 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f69d:	e8 68 6d 00 00       	call   f011640a <test_kmalloc_firstfit1>
f010f6a2:	e9 a5 00 00 00       	jmp    f010f74c <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f6a7:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f6ab:	0f 85 9b 00 00 00    	jne    f010f74c <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010f6b1:	e8 38 78 00 00       	call   f0116eee <test_kmalloc_firstfit2>
f010f6b6:	e9 91 00 00 00       	jmp    f010f74c <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010f6bb:	e8 5f f7 ff ff       	call   f010ee1f <isKHeapPlacementStrategyBESTFIT>
f010f6c0:	84 c0                	test   %al,%al
f010f6c2:	74 47                	je     f010f70b <tst_kheap+0x280>
		{
			if (testNum == 0)
f010f6c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f6c8:	75 1a                	jne    f010f6e4 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010f6ca:	83 ec 0c             	sub    $0xc,%esp
f010f6cd:	68 9c 6f 12 f0       	push   $0xf0126f9c
f010f6d2:	e8 b4 18 ff ff       	call   f0100f8b <cprintf>
f010f6d7:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f6da:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6df:	e9 2c 02 00 00       	jmp    f010f910 <tst_kheap+0x485>
			}
			if (testNum == 1)
f010f6e4:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f6e8:	75 07                	jne    f010f6f1 <tst_kheap+0x266>
				test_kmalloc();
f010f6ea:	e8 8f 61 00 00       	call   f011587e <test_kmalloc>
f010f6ef:	eb 5b                	jmp    f010f74c <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f6f1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f6f5:	75 07                	jne    f010f6fe <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010f6f7:	e8 0a c8 00 00       	call   f011bf06 <test_kmalloc_bestfit1>
f010f6fc:	eb 4e                	jmp    f010f74c <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f6fe:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f702:	75 48                	jne    f010f74c <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010f704:	e8 1a c8 00 00       	call   f011bf23 <test_kmalloc_bestfit2>
f010f709:	eb 41                	jmp    f010f74c <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010f70b:	e8 24 f7 ff ff       	call   f010ee34 <isKHeapPlacementStrategyNEXTFIT>
f010f710:	84 c0                	test   %al,%al
f010f712:	74 38                	je     f010f74c <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010f714:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f718:	75 1a                	jne    f010f734 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010f71a:	83 ec 0c             	sub    $0xc,%esp
f010f71d:	68 ec 6f 12 f0       	push   $0xf0126fec
f010f722:	e8 64 18 ff ff       	call   f0100f8b <cprintf>
f010f727:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f72a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f72f:	e9 dc 01 00 00       	jmp    f010f910 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f010f734:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f738:	75 07                	jne    f010f741 <tst_kheap+0x2b6>
				test_kmalloc();
f010f73a:	e8 3f 61 00 00       	call   f011587e <test_kmalloc>
f010f73f:	eb 0b                	jmp    f010f74c <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010f741:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f745:	75 05                	jne    f010f74c <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010f747:	e8 9d c7 00 00       	call   f011bee9 <test_kmalloc_nextfit>
		}
		return 0;
f010f74c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f751:	e9 ba 01 00 00       	jmp    f010f910 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f010f756:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f759:	83 c0 08             	add    $0x8,%eax
f010f75c:	8b 00                	mov    (%eax),%eax
f010f75e:	83 ec 08             	sub    $0x8,%esp
f010f761:	68 3a 70 12 f0       	push   $0xf012703a
f010f766:	50                   	push   %eax
f010f767:	e8 8f f1 00 00       	call   f011e8fb <strcmp>
f010f76c:	83 c4 10             	add    $0x10,%esp
f010f76f:	85 c0                	test   %eax,%eax
f010f771:	75 2f                	jne    f010f7a2 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f773:	e8 92 f6 ff ff       	call   f010ee0a <isKHeapPlacementStrategyFIRSTFIT>
f010f778:	84 c0                	test   %al,%al
f010f77a:	74 0f                	je     f010f78b <tst_kheap+0x300>
		{
			test_fastfirstfit();
f010f77c:	e8 74 82 00 00       	call   f01179f5 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f010f781:	b8 00 00 00 00       	mov    $0x0,%eax
f010f786:	e9 85 01 00 00       	jmp    f010f910 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f010f78b:	83 ec 04             	sub    $0x4,%esp
f010f78e:	68 40 70 12 f0       	push   $0xf0127040
f010f793:	68 ac 01 00 00       	push   $0x1ac
f010f798:	68 27 6c 12 f0       	push   $0xf0126c27
f010f79d:	e8 97 0b ff ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010f7a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7a5:	83 c0 08             	add    $0x8,%eax
f010f7a8:	8b 00                	mov    (%eax),%eax
f010f7aa:	83 ec 08             	sub    $0x8,%esp
f010f7ad:	68 81 70 12 f0       	push   $0xf0127081
f010f7b2:	50                   	push   %eax
f010f7b3:	e8 43 f1 00 00       	call   f011e8fb <strcmp>
f010f7b8:	83 c4 10             	add    $0x10,%esp
f010f7bb:	85 c0                	test   %eax,%eax
f010f7bd:	75 28                	jne    f010f7e7 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010f7bf:	e8 5b f6 ff ff       	call   f010ee1f <isKHeapPlacementStrategyBESTFIT>
f010f7c4:	84 c0                	test   %al,%al
f010f7c6:	75 09                	jne    f010f7d1 <tst_kheap+0x346>
f010f7c8:	e8 3d f6 ff ff       	call   f010ee0a <isKHeapPlacementStrategyFIRSTFIT>
f010f7cd:	84 c0                	test   %al,%al
f010f7cf:	74 07                	je     f010f7d8 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f010f7d1:	e8 ee 8a 00 00       	call   f01182c4 <test_kfree_bestfirstfit>
f010f7d6:	eb 05                	jmp    f010f7dd <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010f7d8:	e8 80 c7 00 00       	call   f011bf5d <test_kfree>
		}
		return 0;
f010f7dd:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7e2:	e9 29 01 00 00       	jmp    f010f910 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010f7e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7ea:	83 c0 08             	add    $0x8,%eax
f010f7ed:	8b 00                	mov    (%eax),%eax
f010f7ef:	83 ec 08             	sub    $0x8,%esp
f010f7f2:	68 87 70 12 f0       	push   $0xf0127087
f010f7f7:	50                   	push   %eax
f010f7f8:	e8 fe f0 00 00       	call   f011e8fb <strcmp>
f010f7fd:	83 c4 10             	add    $0x10,%esp
f010f800:	85 c0                	test   %eax,%eax
f010f802:	75 0f                	jne    f010f813 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f010f804:	e8 17 a1 00 00       	call   f0119920 <test_kheap_phys_addr>
		return 0;
f010f809:	b8 00 00 00 00       	mov    $0x0,%eax
f010f80e:	e9 fd 00 00 00       	jmp    f010f910 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010f813:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f816:	83 c0 08             	add    $0x8,%eax
f010f819:	8b 00                	mov    (%eax),%eax
f010f81b:	83 ec 08             	sub    $0x8,%esp
f010f81e:	68 91 70 12 f0       	push   $0xf0127091
f010f823:	50                   	push   %eax
f010f824:	e8 d2 f0 00 00       	call   f011e8fb <strcmp>
f010f829:	83 c4 10             	add    $0x10,%esp
f010f82c:	85 c0                	test   %eax,%eax
f010f82e:	75 0f                	jne    f010f83f <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f010f830:	e8 ce ae 00 00       	call   f011a703 <test_kheap_virt_addr>
		return 0;
f010f835:	b8 00 00 00 00       	mov    $0x0,%eax
f010f83a:	e9 d1 00 00 00       	jmp    f010f910 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010f83f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f842:	83 c0 08             	add    $0x8,%eax
f010f845:	8b 00                	mov    (%eax),%eax
f010f847:	83 ec 08             	sub    $0x8,%esp
f010f84a:	68 60 6e 12 f0       	push   $0xf0126e60
f010f84f:	50                   	push   %eax
f010f850:	e8 a6 f0 00 00       	call   f011e8fb <strcmp>
f010f855:	83 c4 10             	add    $0x10,%esp
f010f858:	85 c0                	test   %eax,%eax
f010f85a:	0f 85 89 00 00 00    	jne    f010f8e9 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f860:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f863:	83 c0 0c             	add    $0xc,%eax
f010f866:	8b 00                	mov    (%eax),%eax
f010f868:	83 ec 04             	sub    $0x4,%esp
f010f86b:	6a 0a                	push   $0xa
f010f86d:	6a 00                	push   $0x0
f010f86f:	50                   	push   %eax
f010f870:	e8 da f2 00 00       	call   f011eb4f <strtol>
f010f875:	83 c4 10             	add    $0x10,%esp
f010f878:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f87b:	e8 8a f5 ff ff       	call   f010ee0a <isKHeapPlacementStrategyFIRSTFIT>
f010f880:	84 c0                	test   %al,%al
f010f882:	74 42                	je     f010f8c6 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f010f884:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f888:	75 17                	jne    f010f8a1 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f88a:	83 ec 0c             	sub    $0xc,%esp
f010f88d:	68 4c 6f 12 f0       	push   $0xf0126f4c
f010f892:	e8 f4 16 ff ff       	call   f0100f8b <cprintf>
f010f897:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f89a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f89f:	eb 6f                	jmp    f010f910 <tst_kheap+0x485>
			}
			if (testNum==1)
f010f8a1:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010f8a5:	75 07                	jne    f010f8ae <tst_kheap+0x423>
				test_krealloc_FF1();
f010f8a7:	e8 2f c9 00 00       	call   f011c1db <test_krealloc_FF1>
f010f8ac:	eb 18                	jmp    f010f8c6 <tst_kheap+0x43b>
			else if (testNum==2)
f010f8ae:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010f8b2:	75 07                	jne    f010f8bb <tst_kheap+0x430>
				test_krealloc_FF2();
f010f8b4:	e8 3f c9 00 00       	call   f011c1f8 <test_krealloc_FF2>
f010f8b9:	eb 0b                	jmp    f010f8c6 <tst_kheap+0x43b>
			else if (testNum==3)
f010f8bb:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010f8bf:	75 05                	jne    f010f8c6 <tst_kheap+0x43b>
				test_krealloc_FF3();
f010f8c1:	e8 4f c9 00 00       	call   f011c215 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010f8c6:	e8 69 f5 ff ff       	call   f010ee34 <isKHeapPlacementStrategyNEXTFIT>
f010f8cb:	84 c0                	test   %al,%al
f010f8cd:	74 05                	je     f010f8d4 <tst_kheap+0x449>
		{
			test_krealloc();
f010f8cf:	e8 cd c8 00 00       	call   f011c1a1 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010f8d4:	e8 46 f5 ff ff       	call   f010ee1f <isKHeapPlacementStrategyBESTFIT>
f010f8d9:	84 c0                	test   %al,%al
f010f8db:	74 05                	je     f010f8e2 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f010f8dd:	e8 dc c8 00 00       	call   f011c1be <test_krealloc_BF>
		}
		return 0;
f010f8e2:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8e7:	eb 27                	jmp    f010f910 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010f8e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8ec:	83 c0 08             	add    $0x8,%eax
f010f8ef:	8b 00                	mov    (%eax),%eax
f010f8f1:	83 ec 08             	sub    $0x8,%esp
f010f8f4:	68 9b 70 12 f0       	push   $0xf012709b
f010f8f9:	50                   	push   %eax
f010f8fa:	e8 fc ef 00 00       	call   f011e8fb <strcmp>
f010f8ff:	83 c4 10             	add    $0x10,%esp
f010f902:	85 c0                	test   %eax,%eax
f010f904:	75 05                	jne    f010f90b <tst_kheap+0x480>
	{
		test_ksbrk();
f010f906:	e8 1d bb 00 00       	call   f011b428 <test_ksbrk>
	}
	return 0;
f010f90b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f910:	c9                   	leave  
f010f911:	c3                   	ret    

f010f912 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f010f912:	55                   	push   %ebp
f010f913:	89 e5                	mov    %esp,%ebp
f010f915:	83 ec 28             	sub    $0x28,%esp
f010f918:	8b 45 14             	mov    0x14(%ebp),%eax
f010f91b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f010f91e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f921:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010f924:	74 1d                	je     f010f943 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f010f926:	83 ec 04             	sub    $0x4,%esp
f010f929:	ff 75 08             	pushl  0x8(%ebp)
f010f92c:	ff 75 0c             	pushl  0xc(%ebp)
f010f92f:	68 a0 70 12 f0       	push   $0xf01270a0
f010f934:	e8 52 16 ff ff       	call   f0100f8b <cprintf>
f010f939:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f93c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f941:	eb 55                	jmp    f010f998 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f010f943:	8b 45 08             	mov    0x8(%ebp),%eax
f010f946:	8b 40 fc             	mov    -0x4(%eax),%eax
f010f949:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f010f94c:	8b 45 10             	mov    0x10(%ebp),%eax
f010f94f:	8d 50 f8             	lea    -0x8(%eax),%edx
f010f952:	8b 45 08             	mov    0x8(%ebp),%eax
f010f955:	01 d0                	add    %edx,%eax
f010f957:	8b 00                	mov    (%eax),%eax
f010f959:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f010f95c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f010f960:	0b 45 10             	or     0x10(%ebp),%eax
f010f963:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f010f966:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f969:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f96c:	75 08                	jne    f010f976 <check_block+0x64>
f010f96e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f971:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f974:	74 1d                	je     f010f993 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f010f976:	ff 75 f0             	pushl  -0x10(%ebp)
f010f979:	ff 75 f4             	pushl  -0xc(%ebp)
f010f97c:	ff 75 ec             	pushl  -0x14(%ebp)
f010f97f:	68 d0 70 12 f0       	push   $0xf01270d0
f010f984:	e8 02 16 ff ff       	call   f0100f8b <cprintf>
f010f989:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f98c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f991:	eb 05                	jmp    f010f998 <check_block+0x86>
	}
	return 1;
f010f993:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010f998:	c9                   	leave  
f010f999:	c3                   	ret    

f010f99a <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f010f99a:	55                   	push   %ebp
f010f99b:	89 e5                	mov    %esp,%ebp
f010f99d:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f010f9a0:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f010f9a5:	3b 45 08             	cmp    0x8(%ebp),%eax
f010f9a8:	74 20                	je     f010f9ca <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f010f9aa:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f010f9af:	83 ec 04             	sub    $0x4,%esp
f010f9b2:	50                   	push   %eax
f010f9b3:	ff 75 08             	pushl  0x8(%ebp)
f010f9b6:	68 0c 71 12 f0       	push   $0xf012710c
f010f9bb:	e8 cb 15 ff ff       	call   f0100f8b <cprintf>
f010f9c0:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f9c3:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9c8:	eb 05                	jmp    f010f9cf <check_list_size+0x35>
	}
	return 1;
f010f9ca:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010f9cf:	c9                   	leave  
f010f9d0:	c3                   	ret    

f010f9d1 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f010f9d1:	55                   	push   %ebp
f010f9d2:	89 e5                	mov    %esp,%ebp
f010f9d4:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f010f9d7:	83 ec 04             	sub    $0x4,%esp
f010f9da:	68 40 71 12 f0       	push   $0xf0127140
f010f9df:	6a 3f                	push   $0x3f
f010f9e1:	68 a0 71 12 f0       	push   $0xf01271a0
f010f9e6:	e8 4e 09 ff ff       	call   f0100339 <_panic>

f010f9eb <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f010f9eb:	55                   	push   %ebp
f010f9ec:	89 e5                	mov    %esp,%ebp
f010f9ee:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010f9f1:	83 ec 04             	sub    $0x4,%esp
f010f9f4:	68 c4 71 12 f0       	push   $0xf01271c4
f010f9f9:	6a 61                	push   $0x61
f010f9fb:	68 a0 71 12 f0       	push   $0xf01271a0
f010fa00:	e8 34 09 ff ff       	call   f0100339 <_panic>

f010fa05 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f010fa05:	55                   	push   %ebp
f010fa06:	89 e5                	mov    %esp,%ebp
f010fa08:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fa0b:	83 ec 04             	sub    $0x4,%esp
f010fa0e:	68 14 72 12 f0       	push   $0xf0127214
f010fa13:	68 e7 00 00 00       	push   $0xe7
f010fa18:	68 a0 71 12 f0       	push   $0xf01271a0
f010fa1d:	e8 17 09 ff ff       	call   f0100339 <_panic>

f010fa22 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f010fa22:	55                   	push   %ebp
f010fa23:	89 e5                	mov    %esp,%ebp
f010fa25:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fa2b:	83 ec 04             	sub    $0x4,%esp
f010fa2e:	68 68 72 12 f0       	push   $0xf0127268
f010fa33:	68 88 01 00 00       	push   $0x188
f010fa38:	68 a0 71 12 f0       	push   $0xf01271a0
f010fa3d:	e8 f7 08 ff ff       	call   f0100339 <_panic>

f010fa42 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f010fa42:	55                   	push   %ebp
f010fa43:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f010fa45:	90                   	nop
f010fa46:	5d                   	pop    %ebp
f010fa47:	c3                   	ret    

f010fa48 <test_free_block_FF>:

void test_free_block_FF()
{
f010fa48:	55                   	push   %ebp
f010fa49:	89 e5                	mov    %esp,%ebp
f010fa4b:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fa4e:	83 ec 04             	sub    $0x4,%esp
f010fa51:	68 bc 72 12 f0       	push   $0xf01272bc
f010fa56:	68 4e 02 00 00       	push   $0x24e
f010fa5b:	68 a0 71 12 f0       	push   $0xf01271a0
f010fa60:	e8 d4 08 ff ff       	call   f0100339 <_panic>

f010fa65 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f010fa65:	55                   	push   %ebp
f010fa66:	89 e5                	mov    %esp,%ebp
f010fa68:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fa6b:	83 ec 04             	sub    $0x4,%esp
f010fa6e:	68 bc 72 12 f0       	push   $0xf01272bc
f010fa73:	68 9a 03 00 00       	push   $0x39a
f010fa78:	68 a0 71 12 f0       	push   $0xf01271a0
f010fa7d:	e8 b7 08 ff ff       	call   f0100339 <_panic>

f010fa82 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f010fa82:	55                   	push   %ebp
f010fa83:	89 e5                	mov    %esp,%ebp
f010fa85:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f010fa88:	83 ec 04             	sub    $0x4,%esp
f010fa8b:	68 09 73 12 f0       	push   $0xf0127309
f010fa90:	68 ba 04 00 00       	push   $0x4ba
f010fa95:	68 a0 71 12 f0       	push   $0xf01271a0
f010fa9a:	e8 9a 08 ff ff       	call   f0100339 <_panic>

f010fa9f <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f010fa9f:	55                   	push   %ebp
f010faa0:	89 e5                	mov    %esp,%ebp
f010faa2:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010faa5:	83 ec 04             	sub    $0x4,%esp
f010faa8:	68 bc 72 12 f0       	push   $0xf01272bc
f010faad:	68 c0 04 00 00       	push   $0x4c0
f010fab2:	68 a0 71 12 f0       	push   $0xf01271a0
f010fab7:	e8 7d 08 ff ff       	call   f0100339 <_panic>

f010fabc <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f010fabc:	55                   	push   %ebp
f010fabd:	89 e5                	mov    %esp,%ebp
f010fabf:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fac2:	83 ec 04             	sub    $0x4,%esp
f010fac5:	68 bc 72 12 f0       	push   $0xf01272bc
f010faca:	68 e7 05 00 00       	push   $0x5e7
f010facf:	68 a0 71 12 f0       	push   $0xf01271a0
f010fad4:	e8 60 08 ff ff       	call   f0100339 <_panic>

f010fad9 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f010fad9:	55                   	push   %ebp
f010fada:	89 e5                	mov    %esp,%ebp
f010fadc:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f010fadf:	e8 fe ad ff ff       	call   f010a8e2 <get_cpu_proc>
f010fae4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f010fae7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010faeb:	75 16                	jne    f010fb03 <sys_check_LRU_lists+0x2a>
f010faed:	68 1c 73 12 f0       	push   $0xf012731c
f010faf2:	68 2c 73 12 f0       	push   $0xf012732c
f010faf7:	6a 10                	push   $0x10
f010faf9:	68 41 73 12 f0       	push   $0xf0127341
f010fafe:	e8 36 08 ff ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f010fb03:	83 ec 0c             	sub    $0xc,%esp
f010fb06:	68 60 73 12 f0       	push   $0xf0127360
f010fb0b:	e8 7b 14 ff ff       	call   f0100f8b <cprintf>
f010fb10:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f010fb13:	83 ec 0c             	sub    $0xc,%esp
f010fb16:	ff 75 e0             	pushl  -0x20(%ebp)
f010fb19:	e8 16 9a ff ff       	call   f0109534 <env_page_ws_print>
f010fb1e:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f010fb21:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb24:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f010fb27:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f010fb2e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f010fb35:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010fb39:	0f 84 a5 00 00 00    	je     f010fbe4 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f010fb3f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fb46:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb49:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010fb4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fb52:	eb 4a                	jmp    f010fb9e <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f010fb54:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fb57:	8b 00                	mov    (%eax),%eax
f010fb59:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010fb5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fb5f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fb64:	89 c2                	mov    %eax,%edx
f010fb66:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb69:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fb70:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb73:	01 c8                	add    %ecx,%eax
f010fb75:	8b 00                	mov    (%eax),%eax
f010fb77:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010fb7a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fb7d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fb82:	39 c2                	cmp    %eax,%edx
f010fb84:	74 09                	je     f010fb8f <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f010fb86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f010fb8d:	eb 3e                	jmp    f010fbcd <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f010fb8f:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fb92:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb95:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010fb9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fb9e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fba2:	74 08                	je     f010fbac <sys_check_LRU_lists+0xd3>
f010fba4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fba7:	8b 40 10             	mov    0x10(%eax),%eax
f010fbaa:	eb 05                	jmp    f010fbb1 <sys_check_LRU_lists+0xd8>
f010fbac:	b8 00 00 00 00       	mov    $0x0,%eax
f010fbb1:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fbb4:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f010fbba:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbbd:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010fbc3:	85 c0                	test   %eax,%eax
f010fbc5:	75 8d                	jne    f010fb54 <sys_check_LRU_lists+0x7b>
f010fbc7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fbcb:	75 87                	jne    f010fb54 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f010fbcd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbd0:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010fbd6:	8b 45 10             	mov    0x10(%ebp),%eax
f010fbd9:	39 c2                	cmp    %eax,%edx
f010fbdb:	74 07                	je     f010fbe4 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f010fbdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f010fbe4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010fbe8:	0f 84 a5 00 00 00    	je     f010fc93 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f010fbee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010fbf5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbf8:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010fbfe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fc01:	eb 4a                	jmp    f010fc4d <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f010fc03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fc06:	8b 00                	mov    (%eax),%eax
f010fc08:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010fc0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fc0e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fc13:	89 c2                	mov    %eax,%edx
f010fc15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fc18:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fc1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc22:	01 c8                	add    %ecx,%eax
f010fc24:	8b 00                	mov    (%eax),%eax
f010fc26:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010fc29:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fc2c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fc31:	39 c2                	cmp    %eax,%edx
f010fc33:	74 09                	je     f010fc3e <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f010fc35:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f010fc3c:	eb 3e                	jmp    f010fc7c <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f010fc3e:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010fc41:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc44:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010fc4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fc4d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fc51:	74 08                	je     f010fc5b <sys_check_LRU_lists+0x182>
f010fc53:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fc56:	8b 40 10             	mov    0x10(%eax),%eax
f010fc59:	eb 05                	jmp    f010fc60 <sys_check_LRU_lists+0x187>
f010fc5b:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc60:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fc63:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010fc69:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc6c:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010fc72:	85 c0                	test   %eax,%eax
f010fc74:	75 8d                	jne    f010fc03 <sys_check_LRU_lists+0x12a>
f010fc76:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fc7a:	75 87                	jne    f010fc03 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f010fc7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc7f:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010fc85:	8b 45 14             	mov    0x14(%ebp),%eax
f010fc88:	39 c2                	cmp    %eax,%edx
f010fc8a:	74 07                	je     f010fc93 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f010fc8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f010fc93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc96:	23 45 f0             	and    -0x10(%ebp),%eax
}
f010fc99:	c9                   	leave  
f010fc9a:	c3                   	ret    

f010fc9b <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f010fc9b:	55                   	push   %ebp
f010fc9c:	89 e5                	mov    %esp,%ebp
f010fc9e:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f010fca1:	e8 3c ac ff ff       	call   f010a8e2 <get_cpu_proc>
f010fca6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f010fca9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010fcad:	75 16                	jne    f010fcc5 <sys_check_LRU_lists_free+0x2a>
f010fcaf:	68 1c 73 12 f0       	push   $0xf012731c
f010fcb4:	68 2c 73 12 f0       	push   $0xf012732c
f010fcb9:	6a 45                	push   $0x45
f010fcbb:	68 41 73 12 f0       	push   $0xf0127341
f010fcc0:	e8 74 06 ff ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f010fcc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fcc8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f010fccb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fcd2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fcd5:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010fcdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010fcde:	eb 65                	jmp    f010fd45 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f010fce0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010fce7:	eb 3a                	jmp    f010fd23 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f010fce9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fcec:	8b 00                	mov    (%eax),%eax
f010fcee:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010fcf1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fcf4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fcf9:	89 c2                	mov    %eax,%edx
f010fcfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fcfe:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fd05:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd08:	01 c8                	add    %ecx,%eax
f010fd0a:	8b 00                	mov    (%eax),%eax
f010fd0c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010fd0f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd12:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fd17:	39 c2                	cmp    %eax,%edx
f010fd19:	75 05                	jne    f010fd20 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f010fd1b:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f010fd1e:	eb 0b                	jmp    f010fd2b <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f010fd20:	ff 45 ec             	incl   -0x14(%ebp)
f010fd23:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fd26:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fd29:	7c be                	jl     f010fce9 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f010fd2b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fd2f:	7e 08                	jle    f010fd39 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f010fd31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fd34:	e9 ed 00 00 00       	jmp    f010fe26 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fd39:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd3c:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010fd42:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010fd45:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fd49:	74 08                	je     f010fd53 <sys_check_LRU_lists_free+0xb8>
f010fd4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd4e:	8b 40 10             	mov    0x10(%eax),%eax
f010fd51:	eb 05                	jmp    f010fd58 <sys_check_LRU_lists_free+0xbd>
f010fd53:	b8 00 00 00 00       	mov    $0x0,%eax
f010fd58:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010fd5b:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f010fd61:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd64:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010fd6a:	85 c0                	test   %eax,%eax
f010fd6c:	0f 85 6e ff ff ff    	jne    f010fce0 <sys_check_LRU_lists_free+0x45>
f010fd72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fd76:	0f 85 64 ff ff ff    	jne    f010fce0 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010fd7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd7f:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010fd85:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010fd88:	eb 62                	jmp    f010fdec <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f010fd8a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010fd91:	eb 3a                	jmp    f010fdcd <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f010fd93:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd96:	8b 00                	mov    (%eax),%eax
f010fd98:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010fd9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fd9e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fda3:	89 c2                	mov    %eax,%edx
f010fda5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fda8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fdaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdb2:	01 c8                	add    %ecx,%eax
f010fdb4:	8b 00                	mov    (%eax),%eax
f010fdb6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010fdb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fdbc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fdc1:	39 c2                	cmp    %eax,%edx
f010fdc3:	75 05                	jne    f010fdca <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f010fdc5:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f010fdc8:	eb 0b                	jmp    f010fdd5 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f010fdca:	ff 45 e8             	incl   -0x18(%ebp)
f010fdcd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fdd0:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fdd3:	7c be                	jl     f010fd93 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f010fdd5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fdd9:	7e 05                	jle    f010fde0 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f010fddb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fdde:	eb 46                	jmp    f010fe26 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010fde0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fde3:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010fde9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010fdec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdf0:	74 08                	je     f010fdfa <sys_check_LRU_lists_free+0x15f>
f010fdf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fdf5:	8b 40 10             	mov    0x10(%eax),%eax
f010fdf8:	eb 05                	jmp    f010fdff <sys_check_LRU_lists_free+0x164>
f010fdfa:	b8 00 00 00 00       	mov    $0x0,%eax
f010fdff:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010fe02:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010fe08:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fe0b:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010fe11:	85 c0                	test   %eax,%eax
f010fe13:	0f 85 71 ff ff ff    	jne    f010fd8a <sys_check_LRU_lists_free+0xef>
f010fe19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fe1d:	0f 85 67 ff ff ff    	jne    f010fd8a <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f010fe23:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010fe26:	c9                   	leave  
f010fe27:	c3                   	ret    

f010fe28 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f010fe28:	55                   	push   %ebp
f010fe29:	89 e5                	mov    %esp,%ebp
f010fe2b:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f010fe2e:	e8 af aa ff ff       	call   f010a8e2 <get_cpu_proc>
f010fe33:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f010fe36:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f010fe3a:	75 16                	jne    f010fe52 <sys_check_WS_list+0x2a>
f010fe3c:	68 1c 73 12 f0       	push   $0xf012731c
f010fe41:	68 2c 73 12 f0       	push   $0xf012732c
f010fe46:	6a 79                	push   $0x79
f010fe48:	68 41 73 12 f0       	push   $0xf0127341
f010fe4d:	e8 e7 04 ff ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f010fe52:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fe55:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f010fe58:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f010fe5f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010fe63:	74 06                	je     f010fe6b <sys_check_WS_list+0x43>
f010fe65:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f010fe69:	75 1f                	jne    f010fe8a <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f010fe6b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fe6e:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010fe74:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe77:	39 c2                	cmp    %eax,%edx
f010fe79:	74 0f                	je     f010fe8a <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f010fe7b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fe82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe85:	e9 15 03 00 00       	jmp    f011019f <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f010fe8a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010fe8e:	74 39                	je     f010fec9 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f010fe90:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fe93:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fe99:	8b 00                	mov    (%eax),%eax
f010fe9b:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010fe9e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fea1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fea6:	89 c2                	mov    %eax,%edx
f010fea8:	8b 45 10             	mov    0x10(%ebp),%eax
f010feab:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010feae:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010feb1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010feb6:	39 c2                	cmp    %eax,%edx
f010feb8:	74 0f                	je     f010fec9 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f010feba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fec4:	e9 d6 02 00 00       	jmp    f011019f <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f010fec9:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f010fecd:	0f 85 3c 01 00 00    	jne    f011000f <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f010fed3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f010feda:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010fede:	74 4c                	je     f010ff2c <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f010fee0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010fee7:	eb 3b                	jmp    f010ff24 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f010fee9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010feec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fef3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fef6:	01 d0                	add    %edx,%eax
f010fef8:	8b 00                	mov    (%eax),%eax
f010fefa:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010fefd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010ff00:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff05:	89 c2                	mov    %eax,%edx
f010ff07:	8b 45 10             	mov    0x10(%ebp),%eax
f010ff0a:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010ff0d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010ff10:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff15:	39 c2                	cmp    %eax,%edx
f010ff17:	75 08                	jne    f010ff21 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f010ff19:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ff1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f010ff1f:	eb 0b                	jmp    f010ff2c <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f010ff21:	ff 45 e8             	incl   -0x18(%ebp)
f010ff24:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ff27:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010ff2a:	7c bd                	jl     f010fee9 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f010ff2c:	83 ec 08             	sub    $0x8,%esp
f010ff2f:	ff 75 ec             	pushl  -0x14(%ebp)
f010ff32:	68 88 73 12 f0       	push   $0xf0127388
f010ff37:	e8 4f 10 ff ff       	call   f0100f8b <cprintf>
f010ff3c:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f010ff3f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff42:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010ff48:	85 c0                	test   %eax,%eax
f010ff4a:	74 0e                	je     f010ff5a <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f010ff4c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff4f:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010ff55:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ff58:	eb 0c                	jmp    f010ff66 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f010ff5a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff5d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010ff63:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f010ff66:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff69:	8b 00                	mov    (%eax),%eax
f010ff6b:	83 ec 08             	sub    $0x8,%esp
f010ff6e:	50                   	push   %eax
f010ff6f:	68 a7 73 12 f0       	push   $0xf01273a7
f010ff74:	e8 12 10 ff ff       	call   f0100f8b <cprintf>
f010ff79:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f010ff7c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f010ff83:	eb 79                	jmp    f010fffe <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f010ff85:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff88:	8b 00                	mov    (%eax),%eax
f010ff8a:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010ff8d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010ff90:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff95:	89 c2                	mov    %eax,%edx
f010ff97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff9a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ffa1:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa4:	01 c8                	add    %ecx,%eax
f010ffa6:	8b 00                	mov    (%eax),%eax
f010ffa8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f010ffab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010ffae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ffb3:	39 c2                	cmp    %eax,%edx
f010ffb5:	74 0c                	je     f010ffc3 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f010ffb7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f010ffbe:	e9 d9 01 00 00       	jmp    f011019c <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f010ffc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ffc6:	40                   	inc    %eax
f010ffc7:	89 c2                	mov    %eax,%edx
f010ffc9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ffcc:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f010ffd2:	89 d0                	mov    %edx,%eax
f010ffd4:	ba 00 00 00 00       	mov    $0x0,%edx
f010ffd9:	f7 f1                	div    %ecx
f010ffdb:	89 d0                	mov    %edx,%eax
f010ffdd:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f010ffe0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ffe3:	8b 40 10             	mov    0x10(%eax),%eax
f010ffe6:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f010ffe9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ffed:	75 0c                	jne    f010fffb <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f010ffef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fff2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010fff8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f010fffb:	ff 45 e4             	incl   -0x1c(%ebp)
f010fffe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110001:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110004:	0f 8c 7b ff ff ff    	jl     f010ff85 <sys_check_WS_list+0x15d>
f011000a:	e9 8d 01 00 00       	jmp    f011019c <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f011000f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110013:	74 0a                	je     f011001f <sys_check_WS_list+0x1f7>
f0110015:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0110019:	0f 85 be 00 00 00    	jne    f01100dd <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011001f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0110026:	e9 a1 00 00 00       	jmp    f01100cc <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f011002b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110032:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110035:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011003b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011003e:	eb 47                	jmp    f0110087 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110040:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110043:	8b 00                	mov    (%eax),%eax
f0110045:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0110048:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011004b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110050:	89 c2                	mov    %eax,%edx
f0110052:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110055:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011005c:	8b 45 08             	mov    0x8(%ebp),%eax
f011005f:	01 c8                	add    %ecx,%eax
f0110061:	8b 00                	mov    (%eax),%eax
f0110063:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0110066:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110069:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011006e:	39 c2                	cmp    %eax,%edx
f0110070:	75 09                	jne    f011007b <sys_check_WS_list+0x253>
				{
					found = 1;
f0110072:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0110079:	eb 3b                	jmp    f01100b6 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011007b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011007e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0110084:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110087:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011008b:	74 08                	je     f0110095 <sys_check_WS_list+0x26d>
f011008d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110090:	8b 40 10             	mov    0x10(%eax),%eax
f0110093:	eb 05                	jmp    f011009a <sys_check_WS_list+0x272>
f0110095:	b8 00 00 00 00       	mov    $0x0,%eax
f011009a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011009d:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01100a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01100a6:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01100ac:	85 c0                	test   %eax,%eax
f01100ae:	75 90                	jne    f0110040 <sys_check_WS_list+0x218>
f01100b0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01100b4:	75 8a                	jne    f0110040 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f01100b6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01100ba:	75 0d                	jne    f01100c9 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f01100bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01100c3:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01100c4:	e9 d3 00 00 00       	jmp    f011019c <sys_check_WS_list+0x374>
f01100c9:	ff 45 e0             	incl   -0x20(%ebp)
f01100cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01100cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01100d2:	0f 8c 53 ff ff ff    	jl     f011002b <sys_check_WS_list+0x203>
f01100d8:	e9 bf 00 00 00       	jmp    f011019c <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f01100dd:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f01100e1:	0f 85 b5 00 00 00    	jne    f011019c <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01100e7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01100ee:	e9 9d 00 00 00       	jmp    f0110190 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f01100f3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01100fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01100fd:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0110103:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110106:	eb 47                	jmp    f011014f <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110108:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011010b:	8b 00                	mov    (%eax),%eax
f011010d:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0110110:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110113:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110118:	89 c2                	mov    %eax,%edx
f011011a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011011d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110124:	8b 45 08             	mov    0x8(%ebp),%eax
f0110127:	01 c8                	add    %ecx,%eax
f0110129:	8b 00                	mov    (%eax),%eax
f011012b:	89 45 ac             	mov    %eax,-0x54(%ebp)
f011012e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0110131:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110136:	39 c2                	cmp    %eax,%edx
f0110138:	75 09                	jne    f0110143 <sys_check_WS_list+0x31b>
				{
					found = 1;
f011013a:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0110141:	eb 3b                	jmp    f011017e <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110143:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110146:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011014c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011014f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110153:	74 08                	je     f011015d <sys_check_WS_list+0x335>
f0110155:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110158:	8b 40 10             	mov    0x10(%eax),%eax
f011015b:	eb 05                	jmp    f0110162 <sys_check_WS_list+0x33a>
f011015d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110162:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110165:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f011016b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011016e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0110174:	85 c0                	test   %eax,%eax
f0110176:	75 90                	jne    f0110108 <sys_check_WS_list+0x2e0>
f0110178:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011017c:	75 8a                	jne    f0110108 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f011017e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0110182:	74 09                	je     f011018d <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0110184:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011018b:	eb 0f                	jmp    f011019c <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011018d:	ff 45 d8             	incl   -0x28(%ebp)
f0110190:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110193:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110196:	0f 8c 57 ff ff ff    	jl     f01100f3 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f011019c:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f011019f:	c9                   	leave  
f01101a0:	c3                   	ret    

f01101a1 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01101a1:	55                   	push   %ebp
f01101a2:	89 e5                	mov    %esp,%ebp
f01101a4:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01101a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f01101ae:	8b 15 00 cc 5e f0    	mov    0xf05ecc00,%edx
f01101b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101b7:	39 c2                	cmp    %eax,%edx
f01101b9:	74 0a                	je     f01101c5 <hasExpectedCommands+0x24>
		return 0;
f01101bb:	b8 00 00 00 00       	mov    $0x0,%eax
f01101c0:	e9 8b 00 00 00       	jmp    f0110250 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f01101c5:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f01101ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01101cd:	eb 55                	jmp    f0110224 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01101cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01101d6:	eb 2a                	jmp    f0110202 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f01101d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01101db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01101e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01101e5:	01 d0                	add    %edx,%eax
f01101e7:	8b 10                	mov    (%eax),%edx
f01101e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101ec:	8b 00                	mov    (%eax),%eax
f01101ee:	83 ec 08             	sub    $0x8,%esp
f01101f1:	52                   	push   %edx
f01101f2:	50                   	push   %eax
f01101f3:	e8 03 e7 00 00       	call   f011e8fb <strcmp>
f01101f8:	83 c4 10             	add    $0x10,%esp
f01101fb:	85 c0                	test   %eax,%eax
f01101fd:	74 0d                	je     f011020c <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01101ff:	ff 45 f0             	incl   -0x10(%ebp)
f0110202:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110205:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110208:	7c ce                	jl     f01101d8 <hasExpectedCommands+0x37>
f011020a:	eb 01                	jmp    f011020d <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f011020c:	90                   	nop
		if (i == commandsCount)
f011020d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110210:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110213:	75 07                	jne    f011021c <hasExpectedCommands+0x7b>
			return 0;
f0110215:	b8 00 00 00 00       	mov    $0x0,%eax
f011021a:	eb 34                	jmp    f0110250 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f011021c:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0110221:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110224:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110228:	74 08                	je     f0110232 <hasExpectedCommands+0x91>
f011022a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011022d:	8b 40 10             	mov    0x10(%eax),%eax
f0110230:	eb 05                	jmp    f0110237 <hasExpectedCommands+0x96>
f0110232:	b8 00 00 00 00       	mov    $0x0,%eax
f0110237:	a3 fc cb 5e f0       	mov    %eax,0xf05ecbfc
f011023c:	a1 fc cb 5e f0       	mov    0xf05ecbfc,%eax
f0110241:	85 c0                	test   %eax,%eax
f0110243:	75 8a                	jne    f01101cf <hasExpectedCommands+0x2e>
f0110245:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110249:	75 84                	jne    f01101cf <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f011024b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110250:	c9                   	leave  
f0110251:	c3                   	ret    

f0110252 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0110252:	55                   	push   %ebp
f0110253:	89 e5                	mov    %esp,%ebp
f0110255:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0110258:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011025f:	eb 2e                	jmp    f011028f <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0110261:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110264:	89 d0                	mov    %edx,%eax
f0110266:	01 c0                	add    %eax,%eax
f0110268:	01 d0                	add    %edx,%eax
f011026a:	c1 e0 03             	shl    $0x3,%eax
f011026d:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0110272:	8b 00                	mov    (%eax),%eax
f0110274:	83 ec 08             	sub    $0x8,%esp
f0110277:	ff 75 08             	pushl  0x8(%ebp)
f011027a:	50                   	push   %eax
f011027b:	e8 7b e6 00 00       	call   f011e8fb <strcmp>
f0110280:	83 c4 10             	add    $0x10,%esp
f0110283:	85 c0                	test   %eax,%eax
f0110285:	75 05                	jne    f011028c <getIndexOfCommand+0x3a>
			return i;
f0110287:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011028a:	eb 14                	jmp    f01102a0 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011028c:	ff 45 f4             	incl   -0xc(%ebp)
f011028f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110292:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f0110297:	39 c2                	cmp    %eax,%edx
f0110299:	72 c6                	jb     f0110261 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011029b:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01102a0:	c9                   	leave  
f01102a1:	c3                   	ret    

f01102a2 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01102a2:	55                   	push   %ebp
f01102a3:	89 e5                	mov    %esp,%ebp
f01102a5:	57                   	push   %edi
f01102a6:	56                   	push   %esi
f01102a7:	53                   	push   %ebx
f01102a8:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f01102ae:	83 ec 0c             	sub    $0xc,%esp
f01102b1:	68 e0 73 12 f0       	push   $0xf01273e0
f01102b6:	e8 d0 0c ff ff       	call   f0100f8b <cprintf>
f01102bb:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01102be:	83 ec 0c             	sub    $0xc,%esp
f01102c1:	68 04 74 12 f0       	push   $0xf0127404
f01102c6:	e8 c0 0c ff ff       	call   f0100f8b <cprintf>
f01102cb:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f01102ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f01102d5:	c7 45 8c 1f 74 12 f0 	movl   $0xf012741f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f01102dc:	83 ec 08             	sub    $0x8,%esp
f01102df:	8d 45 8c             	lea    -0x74(%ebp),%eax
f01102e2:	50                   	push   %eax
f01102e3:	6a 01                	push   $0x1
f01102e5:	e8 e6 1e ff ff       	call   f01021d0 <process_command>
f01102ea:	83 c4 10             	add    $0x10,%esp
f01102ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01102f0:	83 ec 0c             	sub    $0xc,%esp
f01102f3:	68 2c 74 12 f0       	push   $0xf012742c
f01102f8:	e8 8e 0c ff ff       	call   f0100f8b <cprintf>
f01102fd:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0110300:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0110303:	83 ec 0c             	sub    $0xc,%esp
f0110306:	50                   	push   %eax
f0110307:	e8 46 ff ff ff       	call   f0110252 <getIndexOfCommand>
f011030c:	83 c4 10             	add    $0x10,%esp
f011030f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0110312:	75 0f                	jne    f0110323 <TestAutoCompleteCommand+0x81>
f0110314:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f0110319:	85 c0                	test   %eax,%eax
f011031b:	75 06                	jne    f0110323 <TestAutoCompleteCommand+0x81>
		eval += 15;
f011031d:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110321:	eb 10                	jmp    f0110333 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110323:	83 ec 0c             	sub    $0xc,%esp
f0110326:	68 5c 74 12 f0       	push   $0xf012745c
f011032b:	e8 5b 0c ff ff       	call   f0100f8b <cprintf>
f0110330:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0110333:	83 ec 0c             	sub    $0xc,%esp
f0110336:	68 ac 74 12 f0       	push   $0xf01274ac
f011033b:	e8 4b 0c ff ff       	call   f0100f8b <cprintf>
f0110340:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0110343:	c7 45 88 d2 74 12 f0 	movl   $0xf01274d2,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f011034a:	83 ec 08             	sub    $0x8,%esp
f011034d:	8d 45 88             	lea    -0x78(%ebp),%eax
f0110350:	50                   	push   %eax
f0110351:	6a 01                	push   $0x1
f0110353:	e8 78 1e ff ff       	call   f01021d0 <process_command>
f0110358:	83 c4 10             	add    $0x10,%esp
f011035b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f011035e:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0110362:	75 30                	jne    f0110394 <TestAutoCompleteCommand+0xf2>
f0110364:	8d 45 90             	lea    -0x70(%ebp),%eax
f0110367:	bb b0 78 12 f0       	mov    $0xf01278b0,%ebx
f011036c:	ba 03 00 00 00       	mov    $0x3,%edx
f0110371:	89 c7                	mov    %eax,%edi
f0110373:	89 de                	mov    %ebx,%esi
f0110375:	89 d1                	mov    %edx,%ecx
f0110377:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0110379:	83 ec 08             	sub    $0x8,%esp
f011037c:	6a 03                	push   $0x3
f011037e:	8d 45 90             	lea    -0x70(%ebp),%eax
f0110381:	50                   	push   %eax
f0110382:	e8 1a fe ff ff       	call   f01101a1 <hasExpectedCommands>
f0110387:	83 c4 10             	add    $0x10,%esp
f011038a:	85 c0                	test   %eax,%eax
f011038c:	74 06                	je     f0110394 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f011038e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110392:	eb 10                	jmp    f01103a4 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110394:	83 ec 0c             	sub    $0xc,%esp
f0110397:	68 d8 74 12 f0       	push   $0xf01274d8
f011039c:	e8 ea 0b ff ff       	call   f0100f8b <cprintf>
f01103a1:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f01103a4:	83 ec 0c             	sub    $0xc,%esp
f01103a7:	68 28 75 12 f0       	push   $0xf0127528
f01103ac:	e8 da 0b ff ff       	call   f0100f8b <cprintf>
f01103b1:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f01103b4:	c7 45 84 4d 75 12 f0 	movl   $0xf012754d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f01103bb:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01103be:	83 ec 04             	sub    $0x4,%esp
f01103c1:	50                   	push   %eax
f01103c2:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01103c5:	50                   	push   %eax
f01103c6:	68 50 75 12 f0       	push   $0xf0127550
f01103cb:	e8 bb 0b ff ff       	call   f0100f8b <cprintf>
f01103d0:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f01103d3:	83 ec 08             	sub    $0x8,%esp
f01103d6:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01103d9:	50                   	push   %eax
f01103da:	6a 01                	push   $0x1
f01103dc:	e8 ef 1d ff ff       	call   f01021d0 <process_command>
f01103e1:	83 c4 10             	add    $0x10,%esp
f01103e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f01103e7:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01103eb:	75 1b                	jne    f0110408 <TestAutoCompleteCommand+0x166>
f01103ed:	83 ec 08             	sub    $0x8,%esp
f01103f0:	6a 01                	push   $0x1
f01103f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01103f5:	50                   	push   %eax
f01103f6:	e8 a6 fd ff ff       	call   f01101a1 <hasExpectedCommands>
f01103fb:	83 c4 10             	add    $0x10,%esp
f01103fe:	85 c0                	test   %eax,%eax
f0110400:	74 06                	je     f0110408 <TestAutoCompleteCommand+0x166>
		eval += 15;
f0110402:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110406:	eb 10                	jmp    f0110418 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0110408:	83 ec 0c             	sub    $0xc,%esp
f011040b:	68 70 75 12 f0       	push   $0xf0127570
f0110410:	e8 76 0b ff ff       	call   f0100f8b <cprintf>
f0110415:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0110418:	83 ec 0c             	sub    $0xc,%esp
f011041b:	68 c8 75 12 f0       	push   $0xf01275c8
f0110420:	e8 66 0b ff ff       	call   f0100f8b <cprintf>
f0110425:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0110428:	c7 45 80 ee 75 12 f0 	movl   $0xf01275ee,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f011042f:	83 ec 08             	sub    $0x8,%esp
f0110432:	8d 45 80             	lea    -0x80(%ebp),%eax
f0110435:	50                   	push   %eax
f0110436:	6a 01                	push   $0x1
f0110438:	e8 93 1d ff ff       	call   f01021d0 <process_command>
f011043d:	83 c4 10             	add    $0x10,%esp
f0110440:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0110443:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0110447:	75 0f                	jne    f0110458 <TestAutoCompleteCommand+0x1b6>
f0110449:	a1 00 cc 5e f0       	mov    0xf05ecc00,%eax
f011044e:	85 c0                	test   %eax,%eax
f0110450:	75 06                	jne    f0110458 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0110452:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110456:	eb 10                	jmp    f0110468 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110458:	83 ec 0c             	sub    $0xc,%esp
f011045b:	68 f4 75 12 f0       	push   $0xf01275f4
f0110460:	e8 26 0b ff ff       	call   f0100f8b <cprintf>
f0110465:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0110468:	83 ec 0c             	sub    $0xc,%esp
f011046b:	68 44 76 12 f0       	push   $0xf0127644
f0110470:	e8 16 0b ff ff       	call   f0100f8b <cprintf>
f0110475:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0110478:	c7 85 7c ff ff ff 69 	movl   $0xf0127669,-0x84(%ebp)
f011047f:	76 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0110482:	83 ec 08             	sub    $0x8,%esp
f0110485:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011048b:	50                   	push   %eax
f011048c:	6a 01                	push   $0x1
f011048e:	e8 3d 1d ff ff       	call   f01021d0 <process_command>
f0110493:	83 c4 10             	add    $0x10,%esp
f0110496:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0110499:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011049d:	75 30                	jne    f01104cf <TestAutoCompleteCommand+0x22d>
f011049f:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01104a2:	bb 40 79 12 f0       	mov    $0xf0127940,%ebx
f01104a7:	ba 0c 00 00 00       	mov    $0xc,%edx
f01104ac:	89 c7                	mov    %eax,%edi
f01104ae:	89 de                	mov    %ebx,%esi
f01104b0:	89 d1                	mov    %edx,%ecx
f01104b2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01104b4:	83 ec 08             	sub    $0x8,%esp
f01104b7:	6a 0c                	push   $0xc
f01104b9:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01104bc:	50                   	push   %eax
f01104bd:	e8 df fc ff ff       	call   f01101a1 <hasExpectedCommands>
f01104c2:	83 c4 10             	add    $0x10,%esp
f01104c5:	85 c0                	test   %eax,%eax
f01104c7:	74 06                	je     f01104cf <TestAutoCompleteCommand+0x22d>
		eval += 10;
f01104c9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01104cd:	eb 10                	jmp    f01104df <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f01104cf:	83 ec 0c             	sub    $0xc,%esp
f01104d2:	68 6c 76 12 f0       	push   $0xf012766c
f01104d7:	e8 af 0a ff ff       	call   f0100f8b <cprintf>
f01104dc:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f01104df:	83 ec 0c             	sub    $0xc,%esp
f01104e2:	68 c4 76 12 f0       	push   $0xf01276c4
f01104e7:	e8 9f 0a ff ff       	call   f0100f8b <cprintf>
f01104ec:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01104ef:	c7 85 78 ff ff ff e9 	movl   $0xf01276e9,-0x88(%ebp)
f01104f6:	76 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01104f9:	83 ec 08             	sub    $0x8,%esp
f01104fc:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0110502:	50                   	push   %eax
f0110503:	6a 01                	push   $0x1
f0110505:	e8 c6 1c ff ff       	call   f01021d0 <process_command>
f011050a:	83 c4 10             	add    $0x10,%esp
f011050d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0110510:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0110514:	75 30                	jne    f0110546 <TestAutoCompleteCommand+0x2a4>
f0110516:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0110519:	bb 88 79 12 f0       	mov    $0xf0127988,%ebx
f011051e:	ba 05 00 00 00       	mov    $0x5,%edx
f0110523:	89 c7                	mov    %eax,%edi
f0110525:	89 de                	mov    %ebx,%esi
f0110527:	89 d1                	mov    %edx,%ecx
f0110529:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011052b:	83 ec 08             	sub    $0x8,%esp
f011052e:	6a 05                	push   $0x5
f0110530:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0110533:	50                   	push   %eax
f0110534:	e8 68 fc ff ff       	call   f01101a1 <hasExpectedCommands>
f0110539:	83 c4 10             	add    $0x10,%esp
f011053c:	85 c0                	test   %eax,%eax
f011053e:	74 06                	je     f0110546 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0110540:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0110544:	eb 10                	jmp    f0110556 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0110546:	83 ec 0c             	sub    $0xc,%esp
f0110549:	68 ec 76 12 f0       	push   $0xf01276ec
f011054e:	e8 38 0a ff ff       	call   f0100f8b <cprintf>
f0110553:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0110556:	83 ec 0c             	sub    $0xc,%esp
f0110559:	68 44 77 12 f0       	push   $0xf0127744
f011055e:	e8 28 0a ff ff       	call   f0100f8b <cprintf>
f0110563:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0110566:	c7 85 70 ff ff ff 70 	movl   $0xf0127770,-0x90(%ebp)
f011056d:	77 12 f0 
f0110570:	c7 85 74 ff ff ff 75 	movl   $0xf0127775,-0x8c(%ebp)
f0110577:	77 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011057a:	83 ec 08             	sub    $0x8,%esp
f011057d:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0110583:	50                   	push   %eax
f0110584:	6a 02                	push   $0x2
f0110586:	e8 45 1c ff ff       	call   f01021d0 <process_command>
f011058b:	83 c4 10             	add    $0x10,%esp
f011058e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0110591:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0110597:	83 ec 0c             	sub    $0xc,%esp
f011059a:	50                   	push   %eax
f011059b:	e8 b2 fc ff ff       	call   f0110252 <getIndexOfCommand>
f01105a0:	83 c4 10             	add    $0x10,%esp
f01105a3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01105a6:	75 0f                	jne    f01105b7 <TestAutoCompleteCommand+0x315>
f01105a8:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f01105ad:	85 c0                	test   %eax,%eax
f01105af:	75 06                	jne    f01105b7 <TestAutoCompleteCommand+0x315>
		eval += 10;
f01105b1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01105b5:	eb 10                	jmp    f01105c7 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01105b7:	83 ec 0c             	sub    $0xc,%esp
f01105ba:	68 7c 77 12 f0       	push   $0xf012777c
f01105bf:	e8 c7 09 ff ff       	call   f0100f8b <cprintf>
f01105c4:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f01105c7:	83 ec 0c             	sub    $0xc,%esp
f01105ca:	68 cc 77 12 f0       	push   $0xf01277cc
f01105cf:	e8 b7 09 ff ff       	call   f0100f8b <cprintf>
f01105d4:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f01105d7:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01105dd:	bb b0 79 12 f0       	mov    $0xf01279b0,%ebx
f01105e2:	ba 03 00 00 00       	mov    $0x3,%edx
f01105e7:	89 c7                	mov    %eax,%edi
f01105e9:	89 de                	mov    %ebx,%esi
f01105eb:	89 d1                	mov    %edx,%ecx
f01105ed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01105ef:	83 ec 08             	sub    $0x8,%esp
f01105f2:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01105f8:	50                   	push   %eax
f01105f9:	6a 03                	push   $0x3
f01105fb:	e8 d0 1b ff ff       	call   f01021d0 <process_command>
f0110600:	83 c4 10             	add    $0x10,%esp
f0110603:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0110606:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011060c:	83 ec 0c             	sub    $0xc,%esp
f011060f:	50                   	push   %eax
f0110610:	e8 3d fc ff ff       	call   f0110252 <getIndexOfCommand>
f0110615:	83 c4 10             	add    $0x10,%esp
f0110618:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011061b:	75 0f                	jne    f011062c <TestAutoCompleteCommand+0x38a>
f011061d:	a1 f4 cb 5e f0       	mov    0xf05ecbf4,%eax
f0110622:	85 c0                	test   %eax,%eax
f0110624:	75 06                	jne    f011062c <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0110626:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011062a:	eb 10                	jmp    f011063c <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011062c:	83 ec 0c             	sub    $0xc,%esp
f011062f:	68 00 78 12 f0       	push   $0xf0127800
f0110634:	e8 52 09 ff ff       	call   f0100f8b <cprintf>
f0110639:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f011063c:	83 ec 08             	sub    $0x8,%esp
f011063f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110642:	68 50 78 12 f0       	push   $0xf0127850
f0110647:	e8 3f 09 ff ff       	call   f0100f8b <cprintf>
f011064c:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f011064f:	83 ec 0c             	sub    $0xc,%esp
f0110652:	68 80 78 12 f0       	push   $0xf0127880
f0110657:	e8 2f 09 ff ff       	call   f0100f8b <cprintf>
f011065c:	83 c4 10             	add    $0x10,%esp

	return 0;
f011065f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110664:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0110667:	5b                   	pop    %ebx
f0110668:	5e                   	pop    %esi
f0110669:	5f                   	pop    %edi
f011066a:	5d                   	pop    %ebp
f011066b:	c3                   	ret    

f011066c <test_str2lower_function>:

int test_str2lower_function()
{
f011066c:	55                   	push   %ebp
f011066d:	89 e5                	mov    %esp,%ebp
f011066f:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0110675:	83 ec 0c             	sub    $0xc,%esp
f0110678:	68 bc 79 12 f0       	push   $0xf01279bc
f011067d:	e8 09 09 ff ff       	call   f0100f8b <cprintf>
f0110682:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0110685:	83 ec 0c             	sub    $0xc,%esp
f0110688:	68 dd 79 12 f0       	push   $0xf01279dd
f011068d:	e8 f9 08 ff ff       	call   f0100f8b <cprintf>
f0110692:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0110695:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f011069c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f01106a3:	c7 45 ec f7 79 12 f0 	movl   $0xf01279f7,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f01106aa:	83 ec 08             	sub    $0x8,%esp
f01106ad:	ff 75 ec             	pushl  -0x14(%ebp)
f01106b0:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f01106b6:	50                   	push   %eax
f01106b7:	e8 1c e8 00 00       	call   f011eed8 <str2lower>
f01106bc:	83 c4 10             	add    $0x10,%esp
f01106bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f01106c2:	83 ec 0c             	sub    $0xc,%esp
f01106c5:	ff 75 e8             	pushl  -0x18(%ebp)
f01106c8:	e8 22 e1 00 00       	call   f011e7ef <strlen>
f01106cd:	83 c4 10             	add    $0x10,%esp
f01106d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f01106d3:	83 ec 08             	sub    $0x8,%esp
f01106d6:	68 02 7a 12 f0       	push   $0xf0127a02
f01106db:	ff 75 e8             	pushl  -0x18(%ebp)
f01106de:	e8 18 e2 00 00       	call   f011e8fb <strcmp>
f01106e3:	83 c4 10             	add    $0x10,%esp
f01106e6:	85 c0                	test   %eax,%eax
f01106e8:	75 13                	jne    f01106fd <test_str2lower_function+0x91>
f01106ea:	83 ec 0c             	sub    $0xc,%esp
f01106ed:	ff 75 ec             	pushl  -0x14(%ebp)
f01106f0:	e8 fa e0 00 00       	call   f011e7ef <strlen>
f01106f5:	83 c4 10             	add    $0x10,%esp
f01106f8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01106fb:	74 15                	je     f0110712 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f01106fd:	83 ec 08             	sub    $0x8,%esp
f0110700:	ff 75 e8             	pushl  -0x18(%ebp)
f0110703:	68 10 7a 12 f0       	push   $0xf0127a10
f0110708:	e8 7e 08 ff ff       	call   f0100f8b <cprintf>
f011070d:	83 c4 10             	add    $0x10,%esp
f0110710:	eb 04                	jmp    f0110716 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0110712:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0110716:	c7 45 e0 72 7a 12 f0 	movl   $0xf0127a72,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f011071d:	83 ec 08             	sub    $0x8,%esp
f0110720:	ff 75 e0             	pushl  -0x20(%ebp)
f0110723:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0110729:	50                   	push   %eax
f011072a:	e8 a9 e7 00 00       	call   f011eed8 <str2lower>
f011072f:	83 c4 10             	add    $0x10,%esp
f0110732:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110735:	83 ec 0c             	sub    $0xc,%esp
f0110738:	ff 75 e8             	pushl  -0x18(%ebp)
f011073b:	e8 af e0 00 00       	call   f011e7ef <strlen>
f0110740:	83 c4 10             	add    $0x10,%esp
f0110743:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0110746:	83 ec 08             	sub    $0x8,%esp
f0110749:	68 72 7a 12 f0       	push   $0xf0127a72
f011074e:	ff 75 e8             	pushl  -0x18(%ebp)
f0110751:	e8 a5 e1 00 00       	call   f011e8fb <strcmp>
f0110756:	83 c4 10             	add    $0x10,%esp
f0110759:	85 c0                	test   %eax,%eax
f011075b:	75 13                	jne    f0110770 <test_str2lower_function+0x104>
f011075d:	83 ec 0c             	sub    $0xc,%esp
f0110760:	ff 75 e0             	pushl  -0x20(%ebp)
f0110763:	e8 87 e0 00 00       	call   f011e7ef <strlen>
f0110768:	83 c4 10             	add    $0x10,%esp
f011076b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011076e:	74 15                	je     f0110785 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0110770:	83 ec 08             	sub    $0x8,%esp
f0110773:	ff 75 e8             	pushl  -0x18(%ebp)
f0110776:	68 74 7a 12 f0       	push   $0xf0127a74
f011077b:	e8 0b 08 ff ff       	call   f0100f8b <cprintf>
f0110780:	83 c4 10             	add    $0x10,%esp
f0110783:	eb 04                	jmp    f0110789 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0110785:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0110789:	c7 45 dc cc 7a 12 f0 	movl   $0xf0127acc,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0110790:	83 ec 08             	sub    $0x8,%esp
f0110793:	ff 75 dc             	pushl  -0x24(%ebp)
f0110796:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f011079c:	50                   	push   %eax
f011079d:	e8 36 e7 00 00       	call   f011eed8 <str2lower>
f01107a2:	83 c4 10             	add    $0x10,%esp
f01107a5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01107a8:	83 ec 0c             	sub    $0xc,%esp
f01107ab:	ff 75 e8             	pushl  -0x18(%ebp)
f01107ae:	e8 3c e0 00 00       	call   f011e7ef <strlen>
f01107b3:	83 c4 10             	add    $0x10,%esp
f01107b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f01107b9:	83 ec 08             	sub    $0x8,%esp
f01107bc:	68 cc 7a 12 f0       	push   $0xf0127acc
f01107c1:	ff 75 e8             	pushl  -0x18(%ebp)
f01107c4:	e8 32 e1 00 00       	call   f011e8fb <strcmp>
f01107c9:	83 c4 10             	add    $0x10,%esp
f01107cc:	85 c0                	test   %eax,%eax
f01107ce:	75 13                	jne    f01107e3 <test_str2lower_function+0x177>
f01107d0:	83 ec 0c             	sub    $0xc,%esp
f01107d3:	ff 75 dc             	pushl  -0x24(%ebp)
f01107d6:	e8 14 e0 00 00       	call   f011e7ef <strlen>
f01107db:	83 c4 10             	add    $0x10,%esp
f01107de:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01107e1:	74 15                	je     f01107f8 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f01107e3:	83 ec 08             	sub    $0x8,%esp
f01107e6:	ff 75 e8             	pushl  -0x18(%ebp)
f01107e9:	68 d8 7a 12 f0       	push   $0xf0127ad8
f01107ee:	e8 98 07 ff ff       	call   f0100f8b <cprintf>
f01107f3:	83 c4 10             	add    $0x10,%esp
f01107f6:	eb 04                	jmp    f01107fc <test_str2lower_function+0x190>
	else
		eval += 15;
f01107f8:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f01107fc:	c7 45 d8 3b 7b 12 f0 	movl   $0xf0127b3b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0110803:	83 ec 08             	sub    $0x8,%esp
f0110806:	ff 75 d8             	pushl  -0x28(%ebp)
f0110809:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f011080f:	50                   	push   %eax
f0110810:	e8 c3 e6 00 00       	call   f011eed8 <str2lower>
f0110815:	83 c4 10             	add    $0x10,%esp
f0110818:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011081b:	83 ec 0c             	sub    $0xc,%esp
f011081e:	ff 75 e8             	pushl  -0x18(%ebp)
f0110821:	e8 c9 df 00 00       	call   f011e7ef <strlen>
f0110826:	83 c4 10             	add    $0x10,%esp
f0110829:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f011082c:	83 ec 08             	sub    $0x8,%esp
f011082f:	68 3b 7b 12 f0       	push   $0xf0127b3b
f0110834:	ff 75 e8             	pushl  -0x18(%ebp)
f0110837:	e8 bf e0 00 00       	call   f011e8fb <strcmp>
f011083c:	83 c4 10             	add    $0x10,%esp
f011083f:	85 c0                	test   %eax,%eax
f0110841:	75 13                	jne    f0110856 <test_str2lower_function+0x1ea>
f0110843:	83 ec 0c             	sub    $0xc,%esp
f0110846:	ff 75 d8             	pushl  -0x28(%ebp)
f0110849:	e8 a1 df 00 00       	call   f011e7ef <strlen>
f011084e:	83 c4 10             	add    $0x10,%esp
f0110851:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110854:	74 15                	je     f011086b <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0110856:	83 ec 08             	sub    $0x8,%esp
f0110859:	ff 75 e8             	pushl  -0x18(%ebp)
f011085c:	68 48 7b 12 f0       	push   $0xf0127b48
f0110861:	e8 25 07 ff ff       	call   f0100f8b <cprintf>
f0110866:	83 c4 10             	add    $0x10,%esp
f0110869:	eb 04                	jmp    f011086f <test_str2lower_function+0x203>
	else
		eval += 15;
f011086b:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f011086f:	c7 45 d4 aa 7b 12 f0 	movl   $0xf0127baa,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0110876:	83 ec 08             	sub    $0x8,%esp
f0110879:	ff 75 d4             	pushl  -0x2c(%ebp)
f011087c:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0110882:	50                   	push   %eax
f0110883:	e8 50 e6 00 00       	call   f011eed8 <str2lower>
f0110888:	83 c4 10             	add    $0x10,%esp
f011088b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011088e:	83 ec 0c             	sub    $0xc,%esp
f0110891:	ff 75 e8             	pushl  -0x18(%ebp)
f0110894:	e8 56 df 00 00       	call   f011e7ef <strlen>
f0110899:	83 c4 10             	add    $0x10,%esp
f011089c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f011089f:	83 ec 08             	sub    $0x8,%esp
f01108a2:	68 c0 7b 12 f0       	push   $0xf0127bc0
f01108a7:	ff 75 e8             	pushl  -0x18(%ebp)
f01108aa:	e8 4c e0 00 00       	call   f011e8fb <strcmp>
f01108af:	83 c4 10             	add    $0x10,%esp
f01108b2:	85 c0                	test   %eax,%eax
f01108b4:	75 13                	jne    f01108c9 <test_str2lower_function+0x25d>
f01108b6:	83 ec 0c             	sub    $0xc,%esp
f01108b9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01108bc:	e8 2e df 00 00       	call   f011e7ef <strlen>
f01108c1:	83 c4 10             	add    $0x10,%esp
f01108c4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01108c7:	74 15                	je     f01108de <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f01108c9:	83 ec 08             	sub    $0x8,%esp
f01108cc:	ff 75 e8             	pushl  -0x18(%ebp)
f01108cf:	68 d8 7b 12 f0       	push   $0xf0127bd8
f01108d4:	e8 b2 06 ff ff       	call   f0100f8b <cprintf>
f01108d9:	83 c4 10             	add    $0x10,%esp
f01108dc:	eb 04                	jmp    f01108e2 <test_str2lower_function+0x276>
	else
		eval += 15;
f01108de:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f01108e2:	c7 45 d0 45 7c 12 f0 	movl   $0xf0127c45,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f01108e9:	83 ec 08             	sub    $0x8,%esp
f01108ec:	ff 75 d0             	pushl  -0x30(%ebp)
f01108ef:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f01108f5:	50                   	push   %eax
f01108f6:	e8 dd e5 00 00       	call   f011eed8 <str2lower>
f01108fb:	83 c4 10             	add    $0x10,%esp
f01108fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110901:	83 ec 0c             	sub    $0xc,%esp
f0110904:	ff 75 e8             	pushl  -0x18(%ebp)
f0110907:	e8 e3 de 00 00       	call   f011e7ef <strlen>
f011090c:	83 c4 10             	add    $0x10,%esp
f011090f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0110912:	83 ec 08             	sub    $0x8,%esp
f0110915:	68 51 7c 12 f0       	push   $0xf0127c51
f011091a:	ff 75 e8             	pushl  -0x18(%ebp)
f011091d:	e8 d9 df 00 00       	call   f011e8fb <strcmp>
f0110922:	83 c4 10             	add    $0x10,%esp
f0110925:	85 c0                	test   %eax,%eax
f0110927:	75 13                	jne    f011093c <test_str2lower_function+0x2d0>
f0110929:	83 ec 0c             	sub    $0xc,%esp
f011092c:	ff 75 d0             	pushl  -0x30(%ebp)
f011092f:	e8 bb de 00 00       	call   f011e7ef <strlen>
f0110934:	83 c4 10             	add    $0x10,%esp
f0110937:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011093a:	74 15                	je     f0110951 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f011093c:	83 ec 08             	sub    $0x8,%esp
f011093f:	ff 75 e8             	pushl  -0x18(%ebp)
f0110942:	68 60 7c 12 f0       	push   $0xf0127c60
f0110947:	e8 3f 06 ff ff       	call   f0100f8b <cprintf>
f011094c:	83 c4 10             	add    $0x10,%esp
f011094f:	eb 04                	jmp    f0110955 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0110951:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0110955:	c7 45 cc c3 7c 12 f0 	movl   $0xf0127cc3,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f011095c:	83 ec 08             	sub    $0x8,%esp
f011095f:	ff 75 cc             	pushl  -0x34(%ebp)
f0110962:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0110968:	50                   	push   %eax
f0110969:	e8 6a e5 00 00       	call   f011eed8 <str2lower>
f011096e:	83 c4 10             	add    $0x10,%esp
f0110971:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110974:	83 ec 0c             	sub    $0xc,%esp
f0110977:	ff 75 e8             	pushl  -0x18(%ebp)
f011097a:	e8 70 de 00 00       	call   f011e7ef <strlen>
f011097f:	83 c4 10             	add    $0x10,%esp
f0110982:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0110985:	83 ec 08             	sub    $0x8,%esp
f0110988:	68 de 7c 12 f0       	push   $0xf0127cde
f011098d:	ff 75 e8             	pushl  -0x18(%ebp)
f0110990:	e8 66 df 00 00       	call   f011e8fb <strcmp>
f0110995:	83 c4 10             	add    $0x10,%esp
f0110998:	85 c0                	test   %eax,%eax
f011099a:	75 13                	jne    f01109af <test_str2lower_function+0x343>
f011099c:	83 ec 0c             	sub    $0xc,%esp
f011099f:	ff 75 cc             	pushl  -0x34(%ebp)
f01109a2:	e8 48 de 00 00       	call   f011e7ef <strlen>
f01109a7:	83 c4 10             	add    $0x10,%esp
f01109aa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01109ad:	74 15                	je     f01109c4 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f01109af:	83 ec 08             	sub    $0x8,%esp
f01109b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01109b5:	68 fc 7c 12 f0       	push   $0xf0127cfc
f01109ba:	e8 cc 05 ff ff       	call   f0100f8b <cprintf>
f01109bf:	83 c4 10             	add    $0x10,%esp
f01109c2:	eb 04                	jmp    f01109c8 <test_str2lower_function+0x35c>
	else
		eval += 20;
f01109c4:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f01109c8:	83 ec 08             	sub    $0x8,%esp
f01109cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01109ce:	68 70 7d 12 f0       	push   $0xf0127d70
f01109d3:	e8 b3 05 ff ff       	call   f0100f8b <cprintf>
f01109d8:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01109db:	83 ec 0c             	sub    $0xc,%esp
f01109de:	68 80 78 12 f0       	push   $0xf0127880
f01109e3:	e8 a3 05 ff ff       	call   f0100f8b <cprintf>
f01109e8:	83 c4 10             	add    $0x10,%esp
	return 0;
f01109eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01109f0:	c9                   	leave  
f01109f1:	c3                   	ret    

f01109f2 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f01109f2:	55                   	push   %ebp
f01109f3:	89 e5                	mov    %esp,%ebp
f01109f5:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f01109f8:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01109ff:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0110a06:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110a0d:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110a12:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a15:	ff 75 f0             	pushl  -0x10(%ebp)
f0110a18:	ff 75 f4             	pushl  -0xc(%ebp)
f0110a1b:	50                   	push   %eax
f0110a1c:	e8 66 83 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110a21:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110a24:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110a29:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a2c:	ff 75 f0             	pushl  -0x10(%ebp)
f0110a2f:	ff 75 f4             	pushl  -0xc(%ebp)
f0110a32:	50                   	push   %eax
f0110a33:	e8 74 4b 00 00       	call   f01155ac <CP>
f0110a38:	83 c4 10             	add    $0x10,%esp
f0110a3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110a3e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110a42:	74 17                	je     f0110a5b <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0110a44:	83 ec 04             	sub    $0x4,%esp
f0110a47:	68 a0 7d 12 f0       	push   $0xf0127da0
f0110a4c:	68 23 01 00 00       	push   $0x123
f0110a51:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110a56:	e8 de f8 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0110a5b:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0110a62:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0110a69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110a70:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110a75:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a78:	ff 75 f0             	pushl  -0x10(%ebp)
f0110a7b:	ff 75 f4             	pushl  -0xc(%ebp)
f0110a7e:	50                   	push   %eax
f0110a7f:	e8 03 83 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110a84:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110a87:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110a8c:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a8f:	ff 75 f0             	pushl  -0x10(%ebp)
f0110a92:	ff 75 f4             	pushl  -0xc(%ebp)
f0110a95:	50                   	push   %eax
f0110a96:	e8 11 4b 00 00       	call   f01155ac <CP>
f0110a9b:	83 c4 10             	add    $0x10,%esp
f0110a9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110aa1:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110aa5:	74 17                	je     f0110abe <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0110aa7:	83 ec 04             	sub    $0x4,%esp
f0110aaa:	68 e0 7d 12 f0       	push   $0xf0127de0
f0110aaf:	68 2f 01 00 00       	push   $0x12f
f0110ab4:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110ab9:	e8 7b f8 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0110abe:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0110ac5:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0110acc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110ad3:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110ad8:	ff 75 ec             	pushl  -0x14(%ebp)
f0110adb:	ff 75 f0             	pushl  -0x10(%ebp)
f0110ade:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ae1:	50                   	push   %eax
f0110ae2:	e8 a0 82 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110ae7:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110aea:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110aef:	ff 75 ec             	pushl  -0x14(%ebp)
f0110af2:	ff 75 f0             	pushl  -0x10(%ebp)
f0110af5:	ff 75 f4             	pushl  -0xc(%ebp)
f0110af8:	50                   	push   %eax
f0110af9:	e8 ae 4a 00 00       	call   f01155ac <CP>
f0110afe:	83 c4 10             	add    $0x10,%esp
f0110b01:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110b04:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110b08:	74 17                	je     f0110b21 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0110b0a:	83 ec 04             	sub    $0x4,%esp
f0110b0d:	68 04 7e 12 f0       	push   $0xf0127e04
f0110b12:	68 3a 01 00 00       	push   $0x13a
f0110b17:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110b1c:	e8 18 f8 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0110b21:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0110b28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0110b2f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110b36:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110b3b:	ff 75 ec             	pushl  -0x14(%ebp)
f0110b3e:	ff 75 f0             	pushl  -0x10(%ebp)
f0110b41:	ff 75 f4             	pushl  -0xc(%ebp)
f0110b44:	50                   	push   %eax
f0110b45:	e8 3d 82 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110b4a:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110b4d:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110b52:	ff 75 ec             	pushl  -0x14(%ebp)
f0110b55:	ff 75 f0             	pushl  -0x10(%ebp)
f0110b58:	ff 75 f4             	pushl  -0xc(%ebp)
f0110b5b:	50                   	push   %eax
f0110b5c:	e8 4b 4a 00 00       	call   f01155ac <CP>
f0110b61:	83 c4 10             	add    $0x10,%esp
f0110b64:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110b67:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110b6b:	74 17                	je     f0110b84 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0110b6d:	83 ec 04             	sub    $0x4,%esp
f0110b70:	68 28 7e 12 f0       	push   $0xf0127e28
f0110b75:	68 46 01 00 00       	push   $0x146
f0110b7a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110b7f:	e8 b5 f7 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0110b84:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0110b8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0110b92:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110b99:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110b9e:	ff 75 ec             	pushl  -0x14(%ebp)
f0110ba1:	ff 75 f0             	pushl  -0x10(%ebp)
f0110ba4:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ba7:	50                   	push   %eax
f0110ba8:	e8 da 81 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110bad:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110bb0:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110bb5:	ff 75 ec             	pushl  -0x14(%ebp)
f0110bb8:	ff 75 f0             	pushl  -0x10(%ebp)
f0110bbb:	ff 75 f4             	pushl  -0xc(%ebp)
f0110bbe:	50                   	push   %eax
f0110bbf:	e8 e8 49 00 00       	call   f01155ac <CP>
f0110bc4:	83 c4 10             	add    $0x10,%esp
f0110bc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110bca:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110bce:	74 17                	je     f0110be7 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0110bd0:	83 ec 04             	sub    $0x4,%esp
f0110bd3:	68 4c 7e 12 f0       	push   $0xf0127e4c
f0110bd8:	68 52 01 00 00       	push   $0x152
f0110bdd:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110be2:	e8 52 f7 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0110be7:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0110bee:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0110bf5:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110bfc:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110c01:	ff 75 ec             	pushl  -0x14(%ebp)
f0110c04:	ff 75 f0             	pushl  -0x10(%ebp)
f0110c07:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c0a:	50                   	push   %eax
f0110c0b:	e8 77 81 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110c10:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110c13:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110c18:	ff 75 ec             	pushl  -0x14(%ebp)
f0110c1b:	ff 75 f0             	pushl  -0x10(%ebp)
f0110c1e:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c21:	50                   	push   %eax
f0110c22:	e8 85 49 00 00       	call   f01155ac <CP>
f0110c27:	83 c4 10             	add    $0x10,%esp
f0110c2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110c2d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110c31:	74 17                	je     f0110c4a <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0110c33:	83 ec 04             	sub    $0x4,%esp
f0110c36:	68 70 7e 12 f0       	push   $0xf0127e70
f0110c3b:	68 5e 01 00 00       	push   $0x15e
f0110c40:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110c45:	e8 ef f6 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0110c4a:	83 ec 0c             	sub    $0xc,%esp
f0110c4d:	68 9c 7e 12 f0       	push   $0xf0127e9c
f0110c52:	e8 34 03 ff ff       	call   f0100f8b <cprintf>
f0110c57:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110c5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110c5f:	c9                   	leave  
f0110c60:	c3                   	ret    

f0110c61 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0110c61:	55                   	push   %ebp
f0110c62:	89 e5                	mov    %esp,%ebp
f0110c64:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0110c67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0110c6e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0110c75:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110c7c:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110c81:	ff 75 ec             	pushl  -0x14(%ebp)
f0110c84:	ff 75 f0             	pushl  -0x10(%ebp)
f0110c87:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c8a:	50                   	push   %eax
f0110c8b:	e8 f7 80 ff ff       	call   f0108d87 <pt_set_page_permissions>
f0110c90:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0110c93:	83 ec 04             	sub    $0x4,%esp
f0110c96:	68 ec 7e 12 f0       	push   $0xf0127eec
f0110c9b:	68 6b 01 00 00       	push   $0x16b
f0110ca0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110ca5:	e8 8f f6 fe ff       	call   f0100339 <_panic>

f0110caa <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0110caa:	55                   	push   %ebp
f0110cab:	89 e5                	mov    %esp,%ebp
f0110cad:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0110cb0:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0110cb7:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110cbc:	83 ec 08             	sub    $0x8,%esp
f0110cbf:	ff 75 f4             	pushl  -0xc(%ebp)
f0110cc2:	50                   	push   %eax
f0110cc3:	e8 83 81 ff ff       	call   f0108e4b <pt_get_page_permissions>
f0110cc8:	83 c4 10             	add    $0x10,%esp
f0110ccb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0110cce:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0110cd2:	74 17                	je     f0110ceb <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0110cd4:	83 ec 04             	sub    $0x4,%esp
f0110cd7:	68 88 7f 12 f0       	push   $0xf0127f88
f0110cdc:	68 79 01 00 00       	push   $0x179
f0110ce1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110ce6:	e8 4e f6 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0110ceb:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0110cf2:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110cf7:	83 ec 08             	sub    $0x8,%esp
f0110cfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0110cfd:	50                   	push   %eax
f0110cfe:	e8 48 81 ff ff       	call   f0108e4b <pt_get_page_permissions>
f0110d03:	83 c4 10             	add    $0x10,%esp
f0110d06:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0110d09:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110d0d:	74 17                	je     f0110d26 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0110d0f:	83 ec 04             	sub    $0x4,%esp
f0110d12:	68 ac 7f 12 f0       	push   $0xf0127fac
f0110d17:	68 81 01 00 00       	push   $0x181
f0110d1c:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110d21:	e8 13 f6 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0110d26:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0110d2d:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110d32:	83 ec 08             	sub    $0x8,%esp
f0110d35:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d38:	50                   	push   %eax
f0110d39:	e8 0d 81 ff ff       	call   f0108e4b <pt_get_page_permissions>
f0110d3e:	83 c4 10             	add    $0x10,%esp
f0110d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0110d44:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110d48:	74 17                	je     f0110d61 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0110d4a:	83 ec 04             	sub    $0x4,%esp
f0110d4d:	68 d0 7f 12 f0       	push   $0xf0127fd0
f0110d52:	68 89 01 00 00       	push   $0x189
f0110d57:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110d5c:	e8 d8 f5 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0110d61:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0110d68:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110d6d:	83 ec 08             	sub    $0x8,%esp
f0110d70:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d73:	50                   	push   %eax
f0110d74:	e8 d2 80 ff ff       	call   f0108e4b <pt_get_page_permissions>
f0110d79:	83 c4 10             	add    $0x10,%esp
f0110d7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0110d7f:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110d83:	74 17                	je     f0110d9c <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0110d85:	83 ec 04             	sub    $0x4,%esp
f0110d88:	68 f4 7f 12 f0       	push   $0xf0127ff4
f0110d8d:	68 90 01 00 00       	push   $0x190
f0110d92:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110d97:	e8 9d f5 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0110d9c:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0110da3:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110da8:	83 ec 08             	sub    $0x8,%esp
f0110dab:	ff 75 f4             	pushl  -0xc(%ebp)
f0110dae:	50                   	push   %eax
f0110daf:	e8 97 80 ff ff       	call   f0108e4b <pt_get_page_permissions>
f0110db4:	83 c4 10             	add    $0x10,%esp
f0110db7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0110dba:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0110dbe:	74 17                	je     f0110dd7 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0110dc0:	83 ec 04             	sub    $0x4,%esp
f0110dc3:	68 18 80 12 f0       	push   $0xf0128018
f0110dc8:	68 97 01 00 00       	push   $0x197
f0110dcd:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110dd2:	e8 62 f5 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0110dd7:	83 ec 0c             	sub    $0xc,%esp
f0110dda:	68 3c 80 12 f0       	push   $0xf012803c
f0110ddf:	e8 a7 01 ff ff       	call   f0100f8b <cprintf>
f0110de4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110de7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110dec:	c9                   	leave  
f0110ded:	c3                   	ret    

f0110dee <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0110dee:	55                   	push   %ebp
f0110def:	89 e5                	mov    %esp,%ebp
f0110df1:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0110df4:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0110dfb:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110e00:	83 ec 08             	sub    $0x8,%esp
f0110e03:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e06:	50                   	push   %eax
f0110e07:	e8 88 80 ff ff       	call   f0108e94 <pt_clear_page_table_entry>
f0110e0c:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0110e0f:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110e14:	83 ec 08             	sub    $0x8,%esp
f0110e17:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e1a:	50                   	push   %eax
f0110e1b:	e8 e8 46 00 00       	call   f0115508 <CE>
f0110e20:	83 c4 10             	add    $0x10,%esp
f0110e23:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0110e26:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110e2a:	74 17                	je     f0110e43 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0110e2c:	83 ec 04             	sub    $0x4,%esp
f0110e2f:	68 84 80 12 f0       	push   $0xf0128084
f0110e34:	68 a7 01 00 00       	push   $0x1a7
f0110e39:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110e3e:	e8 f6 f4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0110e43:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0110e4a:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110e4f:	83 ec 08             	sub    $0x8,%esp
f0110e52:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e55:	50                   	push   %eax
f0110e56:	e8 39 80 ff ff       	call   f0108e94 <pt_clear_page_table_entry>
f0110e5b:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0110e5e:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110e63:	83 ec 08             	sub    $0x8,%esp
f0110e66:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e69:	50                   	push   %eax
f0110e6a:	e8 99 46 00 00       	call   f0115508 <CE>
f0110e6f:	83 c4 10             	add    $0x10,%esp
f0110e72:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0110e75:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110e79:	74 17                	je     f0110e92 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0110e7b:	83 ec 04             	sub    $0x4,%esp
f0110e7e:	68 b0 80 12 f0       	push   $0xf01280b0
f0110e83:	68 af 01 00 00       	push   $0x1af
f0110e88:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110e8d:	e8 a7 f4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0110e92:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0110e99:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110e9e:	83 ec 08             	sub    $0x8,%esp
f0110ea1:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ea4:	50                   	push   %eax
f0110ea5:	e8 ea 7f ff ff       	call   f0108e94 <pt_clear_page_table_entry>
f0110eaa:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0110ead:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110eb2:	83 ec 08             	sub    $0x8,%esp
f0110eb5:	ff 75 f4             	pushl  -0xc(%ebp)
f0110eb8:	50                   	push   %eax
f0110eb9:	e8 4a 46 00 00       	call   f0115508 <CE>
f0110ebe:	83 c4 10             	add    $0x10,%esp
f0110ec1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0110ec4:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110ec8:	74 17                	je     f0110ee1 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0110eca:	83 ec 04             	sub    $0x4,%esp
f0110ecd:	68 dc 80 12 f0       	push   $0xf01280dc
f0110ed2:	68 b7 01 00 00       	push   $0x1b7
f0110ed7:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110edc:	e8 58 f4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0110ee1:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0110ee8:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110eed:	83 ec 08             	sub    $0x8,%esp
f0110ef0:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ef3:	50                   	push   %eax
f0110ef4:	e8 9b 7f ff ff       	call   f0108e94 <pt_clear_page_table_entry>
f0110ef9:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0110efc:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110f01:	83 ec 08             	sub    $0x8,%esp
f0110f04:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f07:	50                   	push   %eax
f0110f08:	e8 fb 45 00 00       	call   f0115508 <CE>
f0110f0d:	83 c4 10             	add    $0x10,%esp
f0110f10:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0110f13:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110f17:	74 17                	je     f0110f30 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0110f19:	83 ec 04             	sub    $0x4,%esp
f0110f1c:	68 08 81 12 f0       	push   $0xf0128108
f0110f21:	68 bf 01 00 00       	push   $0x1bf
f0110f26:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110f2b:	e8 09 f4 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0110f30:	83 ec 0c             	sub    $0xc,%esp
f0110f33:	68 34 81 12 f0       	push   $0xf0128134
f0110f38:	e8 4e 00 ff ff       	call   f0100f8b <cprintf>
f0110f3d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110f40:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110f45:	c9                   	leave  
f0110f46:	c3                   	ret    

f0110f47 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0110f47:	55                   	push   %ebp
f0110f48:	89 e5                	mov    %esp,%ebp
f0110f4a:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0110f4d:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0110f54:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0110f59:	83 ec 08             	sub    $0x8,%esp
f0110f5c:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f5f:	50                   	push   %eax
f0110f60:	e8 2f 7f ff ff       	call   f0108e94 <pt_clear_page_table_entry>
f0110f65:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0110f68:	83 ec 04             	sub    $0x4,%esp
f0110f6b:	68 80 81 12 f0       	push   $0xf0128180
f0110f70:	68 ca 01 00 00       	push   $0x1ca
f0110f75:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110f7a:	e8 ba f3 fe ff       	call   f0100339 <_panic>

f0110f7f <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0110f7f:	55                   	push   %ebp
f0110f80:	89 e5                	mov    %esp,%ebp
f0110f82:	57                   	push   %edi
f0110f83:	56                   	push   %esi
f0110f84:	53                   	push   %ebx
f0110f85:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0110f8b:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0110f91:	bb c4 84 12 f0       	mov    $0xf01284c4,%ebx
f0110f96:	ba 0f 00 00 00       	mov    $0xf,%edx
f0110f9b:	89 c7                	mov    %eax,%edi
f0110f9d:	89 de                	mov    %ebx,%esi
f0110f9f:	89 d1                	mov    %edx,%ecx
f0110fa1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0110fa3:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0110fa9:	b9 23 00 00 00       	mov    $0x23,%ecx
f0110fae:	b0 00                	mov    $0x0,%al
f0110fb0:	89 d7                	mov    %edx,%edi
f0110fb2:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0110fb4:	6a 00                	push   $0x0
f0110fb6:	6a 0a                	push   $0xa
f0110fb8:	6a 14                	push   $0x14
f0110fba:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0110fc0:	50                   	push   %eax
f0110fc1:	e8 9e 8e ff ff       	call   f0109e64 <env_create>
f0110fc6:	83 c4 10             	add    $0x10,%esp
f0110fc9:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0110fcc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110fcf:	8b 40 64             	mov    0x64(%eax),%eax
f0110fd2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0110fd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110fd8:	8b 40 68             	mov    0x68(%eax),%eax
f0110fdb:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0110fde:	8b 45 90             	mov    -0x70(%ebp),%eax
f0110fe1:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0110fe4:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0110feb:	75 70 20 
f0110fee:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0110ff5:	00 00 00 
f0110ff8:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0110ffe:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111003:	b8 00 00 00 00       	mov    $0x0,%eax
f0111008:	89 d7                	mov    %edx,%edi
f011100a:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011100c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011100f:	8b 40 10             	mov    0x10(%eax),%eax
f0111012:	83 ec 08             	sub    $0x8,%esp
f0111015:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f011101b:	52                   	push   %edx
f011101c:	50                   	push   %eax
f011101d:	e8 73 dc 00 00       	call   f011ec95 <ltostr>
f0111022:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111025:	83 ec 04             	sub    $0x4,%esp
f0111028:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011102e:	50                   	push   %eax
f011102f:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0111035:	50                   	push   %eax
f0111036:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f011103c:	50                   	push   %eax
f011103d:	e8 2c dd 00 00       	call   f011ed6e <strcconcat>
f0111042:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0111045:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f011104c:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0111053:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f011105a:	83 ec 0c             	sub    $0xc,%esp
f011105d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111060:	e8 85 45 00 00       	call   f01155ea <ClearUserSpace>
f0111065:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0111068:	83 ec 04             	sub    $0x4,%esp
f011106b:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111071:	50                   	push   %eax
f0111072:	68 16 82 12 f0       	push   $0xf0128216
f0111077:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011107d:	50                   	push   %eax
f011107e:	e8 eb dc 00 00       	call   f011ed6e <strcconcat>
f0111083:	83 c4 10             	add    $0x10,%esp
f0111086:	83 ec 0c             	sub    $0xc,%esp
f0111089:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011108f:	50                   	push   %eax
f0111090:	e8 66 0e ff ff       	call   f0101efb <execute_command>
f0111095:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0111098:	83 ec 04             	sub    $0x4,%esp
f011109b:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01110a1:	50                   	push   %eax
f01110a2:	68 21 82 12 f0       	push   $0xf0128221
f01110a7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01110ad:	50                   	push   %eax
f01110ae:	e8 bb dc 00 00       	call   f011ed6e <strcconcat>
f01110b3:	83 c4 10             	add    $0x10,%esp
f01110b6:	83 ec 0c             	sub    $0xc,%esp
f01110b9:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01110bf:	50                   	push   %eax
f01110c0:	e8 36 0e ff ff       	call   f0101efb <execute_command>
f01110c5:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01110c8:	83 ec 04             	sub    $0x4,%esp
f01110cb:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01110d1:	50                   	push   %eax
f01110d2:	68 2c 82 12 f0       	push   $0xf012822c
f01110d7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01110dd:	50                   	push   %eax
f01110de:	e8 8b dc 00 00       	call   f011ed6e <strcconcat>
f01110e3:	83 c4 10             	add    $0x10,%esp
f01110e6:	83 ec 0c             	sub    $0xc,%esp
f01110e9:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01110ef:	50                   	push   %eax
f01110f0:	e8 06 0e ff ff       	call   f0101efb <execute_command>
f01110f5:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f01110f8:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f01110ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111102:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0111105:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f011110c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011110f:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0111112:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0111119:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011111c:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f011111f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111122:	83 ec 08             	sub    $0x8,%esp
f0111125:	50                   	push   %eax
f0111126:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111129:	e8 9d 44 00 00       	call   f01155cb <GP>
f011112e:	83 c4 10             	add    $0x10,%esp
f0111131:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0111134:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f011113b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0111142:	e8 b5 c5 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111147:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f011114a:	83 ec 0c             	sub    $0xc,%esp
f011114d:	68 38 82 12 f0       	push   $0xf0128238
f0111152:	e8 34 fe fe ff       	call   f0100f8b <cprintf>
f0111157:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f011115a:	6a 03                	push   $0x3
f011115c:	68 00 00 90 02       	push   $0x2900000
f0111161:	68 00 00 80 02       	push   $0x2800000
f0111166:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111169:	e8 49 8a ff ff       	call   f0109bb7 <cut_paste_pages>
f011116e:	83 c4 10             	add    $0x10,%esp
f0111171:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0111174:	e8 83 c5 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111179:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f011117c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0111183:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0111187:	75 08                	jne    f0111191 <test_cut_paste_pages+0x212>
f0111189:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011118c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011118f:	74 2b                	je     f01111bc <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111191:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111194:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111197:	83 ec 0c             	sub    $0xc,%esp
f011119a:	50                   	push   %eax
f011119b:	ff 75 b4             	pushl  -0x4c(%ebp)
f011119e:	68 68 82 12 f0       	push   $0xf0128268
f01111a3:	68 04 02 00 00       	push   $0x204
f01111a8:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01111ad:	e8 24 f3 fe ff       	call   f01004d6 <_warn>
f01111b2:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01111b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f01111bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01111c0:	74 04                	je     f01111c6 <test_cut_paste_pages+0x247>
f01111c2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01111c6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01111cd:	83 ec 08             	sub    $0x8,%esp
f01111d0:	6a 00                	push   $0x0
f01111d2:	6a 01                	push   $0x1
f01111d4:	6a 00                	push   $0x0
f01111d6:	68 ff 0f 00 00       	push   $0xfff
f01111db:	ff 75 bc             	pushl  -0x44(%ebp)
f01111de:	6a 01                	push   $0x1
f01111e0:	68 00 30 00 00       	push   $0x3000
f01111e5:	68 00 00 90 02       	push   $0x2900000
f01111ea:	68 00 00 80 02       	push   $0x2800000
f01111ef:	ff 75 d4             	pushl  -0x2c(%ebp)
f01111f2:	e8 27 44 00 00       	call   f011561e <CCP>
f01111f7:	83 c4 30             	add    $0x30,%esp
f01111fa:	83 f8 01             	cmp    $0x1,%eax
f01111fd:	74 21                	je     f0111220 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01111ff:	83 ec 04             	sub    $0x4,%esp
f0111202:	68 bc 82 12 f0       	push   $0xf01282bc
f0111207:	68 0c 02 00 00       	push   $0x20c
f011120c:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111211:	e8 c0 f2 fe ff       	call   f01004d6 <_warn>
f0111216:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111219:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0111220:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111224:	74 04                	je     f011122a <test_cut_paste_pages+0x2ab>
f0111226:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f011122a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0111231:	83 ec 04             	sub    $0x4,%esp
f0111234:	6a 00                	push   $0x0
f0111236:	68 00 00 90 02       	push   $0x2900000
f011123b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011123e:	e8 b7 41 00 00       	call   f01153fa <CB>
f0111243:	83 c4 10             	add    $0x10,%esp
f0111246:	85 c0                	test   %eax,%eax
f0111248:	0f 84 f6 00 00 00    	je     f0111344 <test_cut_paste_pages+0x3c5>
f011124e:	83 ec 04             	sub    $0x4,%esp
f0111251:	6a 00                	push   $0x0
f0111253:	68 00 10 90 02       	push   $0x2901000
f0111258:	ff 75 d4             	pushl  -0x2c(%ebp)
f011125b:	e8 9a 41 00 00       	call   f01153fa <CB>
f0111260:	83 c4 10             	add    $0x10,%esp
f0111263:	85 c0                	test   %eax,%eax
f0111265:	0f 84 d9 00 00 00    	je     f0111344 <test_cut_paste_pages+0x3c5>
f011126b:	83 ec 04             	sub    $0x4,%esp
f011126e:	6a 00                	push   $0x0
f0111270:	68 00 20 90 02       	push   $0x2902000
f0111275:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111278:	e8 7d 41 00 00       	call   f01153fa <CB>
f011127d:	83 c4 10             	add    $0x10,%esp
f0111280:	85 c0                	test   %eax,%eax
f0111282:	0f 84 bc 00 00 00    	je     f0111344 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0111288:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f011128f:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0111296:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f011129d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01112a0:	8a 00                	mov    (%eax),%al
f01112a2:	3c 61                	cmp    $0x61,%al
f01112a4:	75 12                	jne    f01112b8 <test_cut_paste_pages+0x339>
f01112a6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01112a9:	8a 00                	mov    (%eax),%al
f01112ab:	3c 62                	cmp    $0x62,%al
f01112ad:	75 09                	jne    f01112b8 <test_cut_paste_pages+0x339>
f01112af:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01112b2:	8a 00                	mov    (%eax),%al
f01112b4:	3c 63                	cmp    $0x63,%al
f01112b6:	74 21                	je     f01112d9 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01112b8:	83 ec 04             	sub    $0x4,%esp
f01112bb:	68 08 83 12 f0       	push   $0xf0128308
f01112c0:	68 19 02 00 00       	push   $0x219
f01112c5:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01112ca:	e8 07 f2 fe ff       	call   f01004d6 <_warn>
f01112cf:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01112d2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01112d9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01112dd:	74 04                	je     f01112e3 <test_cut_paste_pages+0x364>
f01112df:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01112e3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01112ea:	83 ec 04             	sub    $0x4,%esp
f01112ed:	6a 01                	push   $0x1
f01112ef:	68 00 10 90 02       	push   $0x2901000
f01112f4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01112f7:	e8 fe 40 00 00       	call   f01153fa <CB>
f01112fc:	83 c4 10             	add    $0x10,%esp
f01112ff:	85 c0                	test   %eax,%eax
f0111301:	74 41                	je     f0111344 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0111303:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111306:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0111309:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011130c:	8a 00                	mov    (%eax),%al
f011130e:	3c 79                	cmp    $0x79,%al
f0111310:	74 21                	je     f0111333 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111312:	83 ec 04             	sub    $0x4,%esp
f0111315:	68 08 83 12 f0       	push   $0xf0128308
f011131a:	68 24 02 00 00       	push   $0x224
f011131f:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111324:	e8 ad f1 fe ff       	call   f01004d6 <_warn>
f0111329:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011132c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0111333:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111337:	74 04                	je     f011133d <test_cut_paste_pages+0x3be>
f0111339:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011133d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0111344:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111347:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f011134a:	6a 02                	push   $0x2
f011134c:	68 00 f0 bf 02       	push   $0x2bff000
f0111351:	68 00 10 90 02       	push   $0x2901000
f0111356:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111359:	e8 59 88 ff ff       	call   f0109bb7 <cut_paste_pages>
f011135e:	83 c4 10             	add    $0x10,%esp
f0111361:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0111364:	e8 93 c3 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111369:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f011136c:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0111370:	75 0b                	jne    f011137d <test_cut_paste_pages+0x3fe>
f0111372:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111375:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111378:	83 f8 01             	cmp    $0x1,%eax
f011137b:	74 2b                	je     f01113a8 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f011137d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111380:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111383:	83 ec 0c             	sub    $0xc,%esp
f0111386:	50                   	push   %eax
f0111387:	ff 75 b4             	pushl  -0x4c(%ebp)
f011138a:	68 68 82 12 f0       	push   $0xf0128268
f011138f:	68 35 02 00 00       	push   $0x235
f0111394:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111399:	e8 38 f1 fe ff       	call   f01004d6 <_warn>
f011139e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01113a1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01113a8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01113ac:	74 04                	je     f01113b2 <test_cut_paste_pages+0x433>
f01113ae:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01113b2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01113b9:	83 ec 08             	sub    $0x8,%esp
f01113bc:	6a 00                	push   $0x0
f01113be:	6a 01                	push   $0x1
f01113c0:	6a 00                	push   $0x0
f01113c2:	68 ff 0f 00 00       	push   $0xfff
f01113c7:	ff 75 bc             	pushl  -0x44(%ebp)
f01113ca:	6a 01                	push   $0x1
f01113cc:	68 00 20 00 00       	push   $0x2000
f01113d1:	68 00 f0 bf 02       	push   $0x2bff000
f01113d6:	68 00 10 90 02       	push   $0x2901000
f01113db:	ff 75 d4             	pushl  -0x2c(%ebp)
f01113de:	e8 3b 42 00 00       	call   f011561e <CCP>
f01113e3:	83 c4 30             	add    $0x30,%esp
f01113e6:	83 f8 01             	cmp    $0x1,%eax
f01113e9:	74 21                	je     f011140c <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01113eb:	83 ec 04             	sub    $0x4,%esp
f01113ee:	68 bc 82 12 f0       	push   $0xf01282bc
f01113f3:	68 3d 02 00 00       	push   $0x23d
f01113f8:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01113fd:	e8 d4 f0 fe ff       	call   f01004d6 <_warn>
f0111402:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111405:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011140c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111410:	74 04                	je     f0111416 <test_cut_paste_pages+0x497>
f0111412:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0111416:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f011141d:	83 ec 04             	sub    $0x4,%esp
f0111420:	6a 00                	push   $0x0
f0111422:	68 ff f7 bf 02       	push   $0x2bff7ff
f0111427:	ff 75 d4             	pushl  -0x2c(%ebp)
f011142a:	e8 cb 3f 00 00       	call   f01153fa <CB>
f011142f:	83 c4 10             	add    $0x10,%esp
f0111432:	85 c0                	test   %eax,%eax
f0111434:	74 6b                	je     f01114a1 <test_cut_paste_pages+0x522>
f0111436:	83 ec 04             	sub    $0x4,%esp
f0111439:	6a 00                	push   $0x0
f011143b:	68 ff 0f c0 02       	push   $0x2c00fff
f0111440:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111443:	e8 b2 3f 00 00       	call   f01153fa <CB>
f0111448:	83 c4 10             	add    $0x10,%esp
f011144b:	85 c0                	test   %eax,%eax
f011144d:	74 52                	je     f01114a1 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f011144f:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0111456:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f011145d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111460:	8a 00                	mov    (%eax),%al
f0111462:	3c 79                	cmp    $0x79,%al
f0111464:	75 09                	jne    f011146f <test_cut_paste_pages+0x4f0>
f0111466:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111469:	8a 00                	mov    (%eax),%al
f011146b:	3c 63                	cmp    $0x63,%al
f011146d:	74 21                	je     f0111490 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011146f:	83 ec 04             	sub    $0x4,%esp
f0111472:	68 08 83 12 f0       	push   $0xf0128308
f0111477:	68 49 02 00 00       	push   $0x249
f011147c:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111481:	e8 50 f0 fe ff       	call   f01004d6 <_warn>
f0111486:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0111489:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0111490:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111494:	74 04                	je     f011149a <test_cut_paste_pages+0x51b>
f0111496:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011149a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01114a1:	83 ec 0c             	sub    $0xc,%esp
f01114a4:	68 41 83 12 f0       	push   $0xf0128341
f01114a9:	e8 dd fa fe ff       	call   f0100f8b <cprintf>
f01114ae:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f01114b1:	83 ec 0c             	sub    $0xc,%esp
f01114b4:	68 50 83 12 f0       	push   $0xf0128350
f01114b9:	e8 cd fa fe ff       	call   f0100f8b <cprintf>
f01114be:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01114c1:	83 ec 04             	sub    $0x4,%esp
f01114c4:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01114ca:	50                   	push   %eax
f01114cb:	68 79 83 12 f0       	push   $0xf0128379
f01114d0:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01114d6:	50                   	push   %eax
f01114d7:	e8 92 d8 00 00       	call   f011ed6e <strcconcat>
f01114dc:	83 c4 10             	add    $0x10,%esp
f01114df:	83 ec 0c             	sub    $0xc,%esp
f01114e2:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01114e8:	50                   	push   %eax
f01114e9:	e8 0d 0a ff ff       	call   f0101efb <execute_command>
f01114ee:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01114f1:	83 ec 04             	sub    $0x4,%esp
f01114f4:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01114fa:	50                   	push   %eax
f01114fb:	68 84 83 12 f0       	push   $0xf0128384
f0111500:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111506:	50                   	push   %eax
f0111507:	e8 62 d8 00 00       	call   f011ed6e <strcconcat>
f011150c:	83 c4 10             	add    $0x10,%esp
f011150f:	83 ec 0c             	sub    $0xc,%esp
f0111512:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0111518:	50                   	push   %eax
f0111519:	e8 dd 09 ff ff       	call   f0101efb <execute_command>
f011151e:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0111521:	83 ec 04             	sub    $0x4,%esp
f0111524:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011152a:	50                   	push   %eax
f011152b:	68 8f 83 12 f0       	push   $0xf012838f
f0111530:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111536:	50                   	push   %eax
f0111537:	e8 32 d8 00 00       	call   f011ed6e <strcconcat>
f011153c:	83 c4 10             	add    $0x10,%esp
f011153f:	83 ec 0c             	sub    $0xc,%esp
f0111542:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0111548:	50                   	push   %eax
f0111549:	e8 ad 09 ff ff       	call   f0101efb <execute_command>
f011154e:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0111551:	83 ec 04             	sub    $0x4,%esp
f0111554:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011155a:	50                   	push   %eax
f011155b:	68 9a 83 12 f0       	push   $0xf012839a
f0111560:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111566:	50                   	push   %eax
f0111567:	e8 02 d8 00 00       	call   f011ed6e <strcconcat>
f011156c:	83 c4 10             	add    $0x10,%esp
f011156f:	83 ec 0c             	sub    $0xc,%esp
f0111572:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0111578:	50                   	push   %eax
f0111579:	e8 7d 09 ff ff       	call   f0101efb <execute_command>
f011157e:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0111581:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0111588:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011158b:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f011158e:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0111595:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111598:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f011159b:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f01115a2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01115a5:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f01115a8:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f01115af:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01115b2:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f01115b5:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f01115bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01115bf:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01115c2:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01115c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01115cc:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01115cf:	83 ec 08             	sub    $0x8,%esp
f01115d2:	68 00 00 c0 01       	push   $0x1c00000
f01115d7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01115da:	e8 ec 3f 00 00       	call   f01155cb <GP>
f01115df:	83 c4 10             	add    $0x10,%esp
f01115e2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f01115e5:	83 ec 08             	sub    $0x8,%esp
f01115e8:	68 00 00 40 01       	push   $0x1400000
f01115ed:	ff 75 d4             	pushl  -0x2c(%ebp)
f01115f0:	e8 d6 3f 00 00       	call   f01155cb <GP>
f01115f5:	83 c4 10             	add    $0x10,%esp
f01115f8:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01115fb:	e8 fc c0 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111600:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0111603:	6a 01                	push   $0x1
f0111605:	68 00 00 40 01       	push   $0x1400000
f011160a:	68 00 00 c0 01       	push   $0x1c00000
f011160f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111612:	e8 a0 85 ff ff       	call   f0109bb7 <cut_paste_pages>
f0111617:	83 c4 10             	add    $0x10,%esp
f011161a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011161d:	e8 da c0 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111622:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0111625:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0111629:	75 08                	jne    f0111633 <test_cut_paste_pages+0x6b4>
f011162b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011162e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111631:	74 2b                	je     f011165e <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111633:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111636:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111639:	83 ec 0c             	sub    $0xc,%esp
f011163c:	50                   	push   %eax
f011163d:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111640:	68 a8 83 12 f0       	push   $0xf01283a8
f0111645:	68 6c 02 00 00       	push   $0x26c
f011164a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011164f:	e8 82 ee fe ff       	call   f01004d6 <_warn>
f0111654:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111657:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011165e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111662:	74 04                	je     f0111668 <test_cut_paste_pages+0x6e9>
f0111664:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0111668:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f011166f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0111676:	83 ec 08             	sub    $0x8,%esp
f0111679:	6a 00                	push   $0x0
f011167b:	68 ff 0f 00 00       	push   $0xfff
f0111680:	ff 75 a4             	pushl  -0x5c(%ebp)
f0111683:	68 ff 0f 00 00       	push   $0xfff
f0111688:	ff 75 a0             	pushl  -0x60(%ebp)
f011168b:	6a 01                	push   $0x1
f011168d:	68 00 10 00 00       	push   $0x1000
f0111692:	68 00 00 40 01       	push   $0x1400000
f0111697:	68 00 00 c0 01       	push   $0x1c00000
f011169c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011169f:	e8 7a 3f 00 00       	call   f011561e <CCP>
f01116a4:	83 c4 30             	add    $0x30,%esp
f01116a7:	83 f8 01             	cmp    $0x1,%eax
f01116aa:	74 28                	je     f01116d4 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01116ac:	83 ec 04             	sub    $0x4,%esp
f01116af:	68 bc 82 12 f0       	push   $0xf01282bc
f01116b4:	68 75 02 00 00       	push   $0x275
f01116b9:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01116be:	e8 13 ee fe ff       	call   f01004d6 <_warn>
f01116c3:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01116c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01116cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01116d4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01116d8:	74 04                	je     f01116de <test_cut_paste_pages+0x75f>
f01116da:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01116de:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01116e5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01116e9:	0f 84 92 00 00 00    	je     f0111781 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f01116ef:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01116f6:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01116fd:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0111704:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011170b:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0111712:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111719:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011171c:	8a 00                	mov    (%eax),%al
f011171e:	3c 61                	cmp    $0x61,%al
f0111720:	75 2d                	jne    f011174f <test_cut_paste_pages+0x7d0>
f0111722:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111725:	8a 00                	mov    (%eax),%al
f0111727:	3c 78                	cmp    $0x78,%al
f0111729:	75 24                	jne    f011174f <test_cut_paste_pages+0x7d0>
f011172b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011172e:	8a 00                	mov    (%eax),%al
f0111730:	3c 62                	cmp    $0x62,%al
f0111732:	75 1b                	jne    f011174f <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111734:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111737:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111739:	3c 79                	cmp    $0x79,%al
f011173b:	75 12                	jne    f011174f <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011173d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111740:	8a 00                	mov    (%eax),%al
f0111742:	3c 63                	cmp    $0x63,%al
f0111744:	75 09                	jne    f011174f <test_cut_paste_pages+0x7d0>
f0111746:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111749:	8a 00                	mov    (%eax),%al
f011174b:	3c 7a                	cmp    $0x7a,%al
f011174d:	74 21                	je     f0111770 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011174f:	83 ec 04             	sub    $0x4,%esp
f0111752:	68 08 83 12 f0       	push   $0xf0128308
f0111757:	68 87 02 00 00       	push   $0x287
f011175c:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111761:	e8 70 ed fe ff       	call   f01004d6 <_warn>
f0111766:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0111769:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0111770:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111774:	74 04                	je     f011177a <test_cut_paste_pages+0x7fb>
f0111776:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011177a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0111781:	e8 76 bf ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111786:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0111789:	6a 03                	push   $0x3
f011178b:	68 00 f0 bf 01       	push   $0x1bff000
f0111790:	68 00 00 40 01       	push   $0x1400000
f0111795:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111798:	e8 1a 84 ff ff       	call   f0109bb7 <cut_paste_pages>
f011179d:	83 c4 10             	add    $0x10,%esp
f01117a0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01117a3:	e8 54 bf ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01117a8:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01117ab:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01117af:	75 08                	jne    f01117b9 <test_cut_paste_pages+0x83a>
f01117b1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01117b4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01117b7:	74 2b                	je     f01117e4 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01117b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01117bc:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01117bf:	83 ec 0c             	sub    $0xc,%esp
f01117c2:	50                   	push   %eax
f01117c3:	ff 75 b4             	pushl  -0x4c(%ebp)
f01117c6:	68 a8 83 12 f0       	push   $0xf01283a8
f01117cb:	68 96 02 00 00       	push   $0x296
f01117d0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01117d5:	e8 fc ec fe ff       	call   f01004d6 <_warn>
f01117da:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01117dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01117e4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01117e8:	74 04                	je     f01117ee <test_cut_paste_pages+0x86f>
f01117ea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01117ee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f01117f5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01117fc:	83 ec 04             	sub    $0x4,%esp
f01117ff:	6a 00                	push   $0x0
f0111801:	68 00 00 40 01       	push   $0x1400000
f0111806:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111809:	e8 ec 3b 00 00       	call   f01153fa <CB>
f011180e:	83 c4 10             	add    $0x10,%esp
f0111811:	83 f8 01             	cmp    $0x1,%eax
f0111814:	0f 85 80 00 00 00    	jne    f011189a <test_cut_paste_pages+0x91b>
f011181a:	83 ec 04             	sub    $0x4,%esp
f011181d:	6a 00                	push   $0x0
f011181f:	68 00 10 40 01       	push   $0x1401000
f0111824:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111827:	e8 ce 3b 00 00       	call   f01153fa <CB>
f011182c:	83 c4 10             	add    $0x10,%esp
f011182f:	83 f8 01             	cmp    $0x1,%eax
f0111832:	75 66                	jne    f011189a <test_cut_paste_pages+0x91b>
f0111834:	83 ec 04             	sub    $0x4,%esp
f0111837:	6a 00                	push   $0x0
f0111839:	68 00 20 40 01       	push   $0x1402000
f011183e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111841:	e8 b4 3b 00 00       	call   f01153fa <CB>
f0111846:	83 c4 10             	add    $0x10,%esp
f0111849:	83 f8 01             	cmp    $0x1,%eax
f011184c:	75 4c                	jne    f011189a <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f011184e:	83 ec 04             	sub    $0x4,%esp
f0111851:	6a 00                	push   $0x0
f0111853:	68 00 f0 bf 01       	push   $0x1bff000
f0111858:	ff 75 d4             	pushl  -0x2c(%ebp)
f011185b:	e8 9a 3b 00 00       	call   f01153fa <CB>
f0111860:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0111863:	85 c0                	test   %eax,%eax
f0111865:	75 33                	jne    f011189a <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0111867:	83 ec 04             	sub    $0x4,%esp
f011186a:	6a 00                	push   $0x0
f011186c:	68 00 00 c0 01       	push   $0x1c00000
f0111871:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111874:	e8 81 3b 00 00       	call   f01153fa <CB>
f0111879:	83 c4 10             	add    $0x10,%esp
f011187c:	83 f8 01             	cmp    $0x1,%eax
f011187f:	75 19                	jne    f011189a <test_cut_paste_pages+0x91b>
f0111881:	83 ec 04             	sub    $0x4,%esp
f0111884:	6a 00                	push   $0x0
f0111886:	68 00 10 c0 01       	push   $0x1c01000
f011188b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011188e:	e8 67 3b 00 00       	call   f01153fa <CB>
f0111893:	83 c4 10             	add    $0x10,%esp
f0111896:	85 c0                	test   %eax,%eax
f0111898:	74 28                	je     f01118c2 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f011189a:	83 ec 04             	sub    $0x4,%esp
f011189d:	68 08 84 12 f0       	push   $0xf0128408
f01118a2:	68 9f 02 00 00       	push   $0x29f
f01118a7:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01118ac:	e8 25 ec fe ff       	call   f01004d6 <_warn>
f01118b1:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01118b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01118bb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01118c2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01118c6:	74 04                	je     f01118cc <test_cut_paste_pages+0x94d>
f01118c8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01118cc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01118d3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01118d7:	0f 84 99 00 00 00    	je     f0111976 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f01118dd:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01118e4:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01118eb:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01118f2:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01118f9:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0111900:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111907:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011190a:	8a 00                	mov    (%eax),%al
f011190c:	3c 61                	cmp    $0x61,%al
f011190e:	75 2d                	jne    f011193d <test_cut_paste_pages+0x9be>
f0111910:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111913:	8a 00                	mov    (%eax),%al
f0111915:	3c 78                	cmp    $0x78,%al
f0111917:	75 24                	jne    f011193d <test_cut_paste_pages+0x9be>
f0111919:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011191c:	8a 00                	mov    (%eax),%al
f011191e:	3c 62                	cmp    $0x62,%al
f0111920:	75 1b                	jne    f011193d <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111922:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111925:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111927:	3c 79                	cmp    $0x79,%al
f0111929:	75 12                	jne    f011193d <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011192b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011192e:	8a 00                	mov    (%eax),%al
f0111930:	3c 63                	cmp    $0x63,%al
f0111932:	75 09                	jne    f011193d <test_cut_paste_pages+0x9be>
f0111934:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111937:	8a 00                	mov    (%eax),%al
f0111939:	3c 7a                	cmp    $0x7a,%al
f011193b:	74 28                	je     f0111965 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f011193d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0111944:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011194b:	83 ec 04             	sub    $0x4,%esp
f011194e:	68 08 83 12 f0       	push   $0xf0128308
f0111953:	68 b3 02 00 00       	push   $0x2b3
f0111958:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011195d:	e8 74 eb fe ff       	call   f01004d6 <_warn>
f0111962:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0111965:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111969:	74 04                	je     f011196f <test_cut_paste_pages+0x9f0>
f011196b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011196f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0111976:	83 ec 0c             	sub    $0xc,%esp
f0111979:	68 41 84 12 f0       	push   $0xf0128441
f011197e:	e8 08 f6 fe ff       	call   f0100f8b <cprintf>
f0111983:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0111986:	83 ec 08             	sub    $0x8,%esp
f0111989:	ff 75 e4             	pushl  -0x1c(%ebp)
f011198c:	68 50 84 12 f0       	push   $0xf0128450
f0111991:	e8 f5 f5 fe ff       	call   f0100f8b <cprintf>
f0111996:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0111999:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011199d:	75 10                	jne    f01119af <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f011199f:	83 ec 0c             	sub    $0xc,%esp
f01119a2:	68 84 84 12 f0       	push   $0xf0128484
f01119a7:	e8 df f5 fe ff       	call   f0100f8b <cprintf>
f01119ac:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01119af:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f01119b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01119b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01119ba:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01119bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01119c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01119c5:	5b                   	pop    %ebx
f01119c6:	5e                   	pop    %esi
f01119c7:	5f                   	pop    %edi
f01119c8:	5d                   	pop    %ebp
f01119c9:	c3                   	ret    

f01119ca <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f01119ca:	55                   	push   %ebp
f01119cb:	89 e5                	mov    %esp,%ebp
f01119cd:	57                   	push   %edi
f01119ce:	56                   	push   %esi
f01119cf:	53                   	push   %ebx
f01119d0:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01119d6:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01119dc:	bb c4 84 12 f0       	mov    $0xf01284c4,%ebx
f01119e1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01119e6:	89 c7                	mov    %eax,%edi
f01119e8:	89 de                	mov    %ebx,%esi
f01119ea:	89 d1                	mov    %edx,%ecx
f01119ec:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01119ee:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f01119f4:	b9 23 00 00 00       	mov    $0x23,%ecx
f01119f9:	b0 00                	mov    $0x0,%al
f01119fb:	89 d7                	mov    %edx,%edi
f01119fd:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01119ff:	6a 00                	push   $0x0
f0111a01:	6a 0a                	push   $0xa
f0111a03:	6a 14                	push   $0x14
f0111a05:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0111a0b:	50                   	push   %eax
f0111a0c:	e8 53 84 ff ff       	call   f0109e64 <env_create>
f0111a11:	83 c4 10             	add    $0x10,%esp
f0111a14:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111a17:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111a1a:	8b 40 64             	mov    0x64(%eax),%eax
f0111a1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0111a20:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111a23:	8b 40 68             	mov    0x68(%eax),%eax
f0111a26:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0111a2c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0111a32:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0111a35:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0111a3c:	75 70 20 
f0111a3f:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0111a46:	00 00 00 
f0111a49:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111a4f:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111a54:	b8 00 00 00 00       	mov    $0x0,%eax
f0111a59:	89 d7                	mov    %edx,%edi
f0111a5b:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111a5d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111a60:	8b 40 10             	mov    0x10(%eax),%eax
f0111a63:	83 ec 08             	sub    $0x8,%esp
f0111a66:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0111a6c:	52                   	push   %edx
f0111a6d:	50                   	push   %eax
f0111a6e:	e8 22 d2 00 00       	call   f011ec95 <ltostr>
f0111a73:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111a76:	83 ec 04             	sub    $0x4,%esp
f0111a79:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111a7f:	50                   	push   %eax
f0111a80:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0111a86:	50                   	push   %eax
f0111a87:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0111a8d:	50                   	push   %eax
f0111a8e:	e8 db d2 00 00       	call   f011ed6e <strcconcat>
f0111a93:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0111a96:	83 ec 0c             	sub    $0xc,%esp
f0111a99:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111a9c:	e8 49 3b 00 00       	call   f01155ea <ClearUserSpace>
f0111aa1:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0111aa4:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0111aab:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0111ab2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111ab9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0111ac0:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0111ac7:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0111ace:	83 ec 0c             	sub    $0xc,%esp
f0111ad1:	68 f8 84 12 f0       	push   $0xf01284f8
f0111ad6:	e8 b0 f4 fe ff       	call   f0100f8b <cprintf>
f0111adb:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0111ade:	83 ec 04             	sub    $0x4,%esp
f0111ae1:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111ae7:	50                   	push   %eax
f0111ae8:	68 2e 85 12 f0       	push   $0xf012852e
f0111aed:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111af3:	50                   	push   %eax
f0111af4:	e8 75 d2 00 00       	call   f011ed6e <strcconcat>
f0111af9:	83 c4 10             	add    $0x10,%esp
f0111afc:	83 ec 0c             	sub    $0xc,%esp
f0111aff:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111b05:	50                   	push   %eax
f0111b06:	e8 f0 03 ff ff       	call   f0101efb <execute_command>
f0111b0b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0111b0e:	83 ec 04             	sub    $0x4,%esp
f0111b11:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111b17:	50                   	push   %eax
f0111b18:	68 33 85 12 f0       	push   $0xf0128533
f0111b1d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111b23:	50                   	push   %eax
f0111b24:	e8 45 d2 00 00       	call   f011ed6e <strcconcat>
f0111b29:	83 c4 10             	add    $0x10,%esp
f0111b2c:	83 ec 0c             	sub    $0xc,%esp
f0111b2f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111b35:	50                   	push   %eax
f0111b36:	e8 c0 03 ff ff       	call   f0101efb <execute_command>
f0111b3b:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0111b3e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111b44:	bb 39 88 12 f0       	mov    $0xf0128839,%ebx
f0111b49:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111b4e:	89 c7                	mov    %eax,%edi
f0111b50:	89 de                	mov    %ebx,%esi
f0111b52:	89 d1                	mov    %edx,%ecx
f0111b54:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111b56:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0111b5c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111b61:	b0 00                	mov    $0x0,%al
f0111b63:	89 d7                	mov    %edx,%edi
f0111b65:	f3 aa                	rep stos %al,%es:(%edi)
f0111b67:	83 ec 0c             	sub    $0xc,%esp
f0111b6a:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111b70:	50                   	push   %eax
f0111b71:	e8 85 03 ff ff       	call   f0101efb <execute_command>
f0111b76:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0111b79:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0111b7f:	bb 9d 88 12 f0       	mov    $0xf012889d,%ebx
f0111b84:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111b89:	89 c7                	mov    %eax,%edi
f0111b8b:	89 de                	mov    %ebx,%esi
f0111b8d:	89 d1                	mov    %edx,%ecx
f0111b8f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111b91:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0111b97:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111b9c:	b0 00                	mov    $0x0,%al
f0111b9e:	89 d7                	mov    %edx,%edi
f0111ba0:	f3 aa                	rep stos %al,%es:(%edi)
f0111ba2:	83 ec 0c             	sub    $0xc,%esp
f0111ba5:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0111bab:	50                   	push   %eax
f0111bac:	e8 4a 03 ff ff       	call   f0101efb <execute_command>
f0111bb1:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0111bb4:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0111bba:	bb 01 89 12 f0       	mov    $0xf0128901,%ebx
f0111bbf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111bc4:	89 c7                	mov    %eax,%edi
f0111bc6:	89 de                	mov    %ebx,%esi
f0111bc8:	89 d1                	mov    %edx,%ecx
f0111bca:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111bcc:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0111bd2:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111bd7:	b0 00                	mov    $0x0,%al
f0111bd9:	89 d7                	mov    %edx,%edi
f0111bdb:	f3 aa                	rep stos %al,%es:(%edi)
f0111bdd:	83 ec 0c             	sub    $0xc,%esp
f0111be0:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0111be6:	50                   	push   %eax
f0111be7:	e8 0f 03 ff ff       	call   f0101efb <execute_command>
f0111bec:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0111bef:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0111bf5:	bb 65 89 12 f0       	mov    $0xf0128965,%ebx
f0111bfa:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111bff:	89 c7                	mov    %eax,%edi
f0111c01:	89 de                	mov    %ebx,%esi
f0111c03:	89 d1                	mov    %edx,%ecx
f0111c05:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111c07:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0111c0d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111c12:	b0 00                	mov    $0x0,%al
f0111c14:	89 d7                	mov    %edx,%edi
f0111c16:	f3 aa                	rep stos %al,%es:(%edi)
f0111c18:	83 ec 0c             	sub    $0xc,%esp
f0111c1b:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0111c21:	50                   	push   %eax
f0111c22:	e8 d4 02 ff ff       	call   f0101efb <execute_command>
f0111c27:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0111c2a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0111c30:	bb c9 89 12 f0       	mov    $0xf01289c9,%ebx
f0111c35:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111c3a:	89 c7                	mov    %eax,%edi
f0111c3c:	89 de                	mov    %ebx,%esi
f0111c3e:	89 d1                	mov    %edx,%ecx
f0111c40:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111c42:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0111c48:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111c4d:	b0 00                	mov    $0x0,%al
f0111c4f:	89 d7                	mov    %edx,%edi
f0111c51:	f3 aa                	rep stos %al,%es:(%edi)
f0111c53:	83 ec 0c             	sub    $0xc,%esp
f0111c56:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0111c5c:	50                   	push   %eax
f0111c5d:	e8 99 02 ff ff       	call   f0101efb <execute_command>
f0111c62:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0111c65:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0111c6b:	bb 2d 8a 12 f0       	mov    $0xf0128a2d,%ebx
f0111c70:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111c75:	89 c7                	mov    %eax,%edi
f0111c77:	89 de                	mov    %ebx,%esi
f0111c79:	89 d1                	mov    %edx,%ecx
f0111c7b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111c7d:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0111c83:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111c88:	b0 00                	mov    $0x0,%al
f0111c8a:	89 d7                	mov    %edx,%edi
f0111c8c:	f3 aa                	rep stos %al,%es:(%edi)
f0111c8e:	83 ec 0c             	sub    $0xc,%esp
f0111c91:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0111c97:	50                   	push   %eax
f0111c98:	e8 5e 02 ff ff       	call   f0101efb <execute_command>
f0111c9d:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0111ca0:	83 ec 04             	sub    $0x4,%esp
f0111ca3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0111ca9:	50                   	push   %eax
f0111caa:	68 3b 85 12 f0       	push   $0xf012853b
f0111caf:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111cb5:	50                   	push   %eax
f0111cb6:	e8 b3 d0 00 00       	call   f011ed6e <strcconcat>
f0111cbb:	83 c4 10             	add    $0x10,%esp
f0111cbe:	83 ec 0c             	sub    $0xc,%esp
f0111cc1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0111cc7:	50                   	push   %eax
f0111cc8:	e8 2e 02 ff ff       	call   f0101efb <execute_command>
f0111ccd:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0111cd0:	83 ec 04             	sub    $0x4,%esp
f0111cd3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0111cd9:	50                   	push   %eax
f0111cda:	68 45 85 12 f0       	push   $0xf0128545
f0111cdf:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111ce5:	50                   	push   %eax
f0111ce6:	e8 83 d0 00 00       	call   f011ed6e <strcconcat>
f0111ceb:	83 c4 10             	add    $0x10,%esp
f0111cee:	83 ec 0c             	sub    $0xc,%esp
f0111cf1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0111cf7:	50                   	push   %eax
f0111cf8:	e8 fe 01 ff ff       	call   f0101efb <execute_command>
f0111cfd:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0111d00:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0111d06:	bb 91 8a 12 f0       	mov    $0xf0128a91,%ebx
f0111d0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d10:	89 c7                	mov    %eax,%edi
f0111d12:	89 de                	mov    %ebx,%esi
f0111d14:	89 d1                	mov    %edx,%ecx
f0111d16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d18:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0111d1e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111d23:	b0 00                	mov    $0x0,%al
f0111d25:	89 d7                	mov    %edx,%edi
f0111d27:	f3 aa                	rep stos %al,%es:(%edi)
f0111d29:	83 ec 0c             	sub    $0xc,%esp
f0111d2c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0111d32:	50                   	push   %eax
f0111d33:	e8 c3 01 ff ff       	call   f0101efb <execute_command>
f0111d38:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0111d3b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0111d41:	bb f5 8a 12 f0       	mov    $0xf0128af5,%ebx
f0111d46:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d4b:	89 c7                	mov    %eax,%edi
f0111d4d:	89 de                	mov    %ebx,%esi
f0111d4f:	89 d1                	mov    %edx,%ecx
f0111d51:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d53:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0111d59:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111d5e:	b0 00                	mov    $0x0,%al
f0111d60:	89 d7                	mov    %edx,%edi
f0111d62:	f3 aa                	rep stos %al,%es:(%edi)
f0111d64:	83 ec 0c             	sub    $0xc,%esp
f0111d67:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0111d6d:	50                   	push   %eax
f0111d6e:	e8 88 01 ff ff       	call   f0101efb <execute_command>
f0111d73:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0111d76:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0111d7c:	bb 59 8b 12 f0       	mov    $0xf0128b59,%ebx
f0111d81:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d86:	89 c7                	mov    %eax,%edi
f0111d88:	89 de                	mov    %ebx,%esi
f0111d8a:	89 d1                	mov    %edx,%ecx
f0111d8c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d8e:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0111d94:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111d99:	b0 00                	mov    $0x0,%al
f0111d9b:	89 d7                	mov    %edx,%edi
f0111d9d:	f3 aa                	rep stos %al,%es:(%edi)
f0111d9f:	83 ec 0c             	sub    $0xc,%esp
f0111da2:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0111da8:	50                   	push   %eax
f0111da9:	e8 4d 01 ff ff       	call   f0101efb <execute_command>
f0111dae:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0111db1:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0111db8:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0111dbf:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0111dc6:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0111dcd:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0111dd4:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0111ddb:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0111de2:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0111de9:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0111df0:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0111df7:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0111dfe:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0111e05:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0111e08:	8a 00                	mov    (%eax),%al
f0111e0a:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0111e10:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111e13:	8a 00                	mov    (%eax),%al
f0111e15:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0111e1b:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111e1e:	8a 00                	mov    (%eax),%al
f0111e20:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0111e26:	e8 d1 b8 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111e2b:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0111e2e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111e31:	89 d0                	mov    %edx,%eax
f0111e33:	01 c0                	add    %eax,%eax
f0111e35:	01 d0                	add    %edx,%eax
f0111e37:	01 c0                	add    %eax,%eax
f0111e39:	50                   	push   %eax
f0111e3a:	68 00 00 10 00       	push   $0x100000
f0111e3f:	6a 00                	push   $0x0
f0111e41:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e44:	e8 88 7d ff ff       	call   f0109bd1 <copy_paste_chunk>
f0111e49:	83 c4 10             	add    $0x10,%esp
f0111e4c:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0111e4f:	e8 a8 b8 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0111e54:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0111e57:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0111e5e:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0111e62:	75 08                	jne    f0111e6c <test_copy_paste_chunk+0x4a2>
f0111e64:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111e67:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0111e6a:	74 2b                	je     f0111e97 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0111e6c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111e6f:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0111e72:	83 ec 0c             	sub    $0xc,%esp
f0111e75:	50                   	push   %eax
f0111e76:	ff 75 88             	pushl  -0x78(%ebp)
f0111e79:	68 54 85 12 f0       	push   $0xf0128554
f0111e7e:	68 06 03 00 00       	push   $0x306
f0111e83:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111e88:	e8 49 e6 fe ff       	call   f01004d6 <_warn>
f0111e8d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0111e90:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0111e97:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111e9b:	74 04                	je     f0111ea1 <test_copy_paste_chunk+0x4d7>
f0111e9d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0111ea1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0111ea8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111eab:	8a 00                	mov    (%eax),%al
f0111ead:	3c 61                	cmp    $0x61,%al
f0111eaf:	75 75                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111eb1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111eb4:	8a 00                	mov    (%eax),%al
f0111eb6:	3c 78                	cmp    $0x78,%al
f0111eb8:	75 6c                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111eba:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111ebd:	8a 00                	mov    (%eax),%al
f0111ebf:	3c 62                	cmp    $0x62,%al
f0111ec1:	75 63                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111ec3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111ec6:	8a 00                	mov    (%eax),%al
f0111ec8:	3c 79                	cmp    $0x79,%al
f0111eca:	75 5a                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111ecc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111ecf:	8a 00                	mov    (%eax),%al
f0111ed1:	3c 63                	cmp    $0x63,%al
f0111ed3:	75 51                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111ed5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111ed8:	8a 00                	mov    (%eax),%al
f0111eda:	3c 7a                	cmp    $0x7a,%al
f0111edc:	75 48                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0111ede:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111ee1:	8a 00                	mov    (%eax),%al
f0111ee3:	3c 64                	cmp    $0x64,%al
f0111ee5:	75 3f                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111ee7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0111eea:	8a 10                	mov    (%eax),%dl
f0111eec:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0111ef2:	38 c2                	cmp    %al,%dl
f0111ef4:	75 30                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111ef6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111ef9:	8a 00                	mov    (%eax),%al
f0111efb:	3c 65                	cmp    $0x65,%al
f0111efd:	75 27                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111eff:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111f02:	8a 10                	mov    (%eax),%dl
f0111f04:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0111f0a:	38 c2                	cmp    %al,%dl
f0111f0c:	75 18                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111f0e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111f11:	8a 00                	mov    (%eax),%al
f0111f13:	3c 66                	cmp    $0x66,%al
f0111f15:	75 0f                	jne    f0111f26 <test_copy_paste_chunk+0x55c>
f0111f17:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111f1a:	8a 10                	mov    (%eax),%dl
f0111f1c:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0111f22:	38 c2                	cmp    %al,%dl
f0111f24:	74 21                	je     f0111f47 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0111f26:	83 ec 04             	sub    $0x4,%esp
f0111f29:	68 b8 85 12 f0       	push   $0xf01285b8
f0111f2e:	68 0f 03 00 00       	push   $0x30f
f0111f33:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0111f38:	e8 99 e5 fe ff       	call   f01004d6 <_warn>
f0111f3d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0111f40:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0111f47:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111f4b:	74 04                	je     f0111f51 <test_copy_paste_chunk+0x587>
f0111f4d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0111f51:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0111f58:	83 ec 0c             	sub    $0xc,%esp
f0111f5b:	68 f2 85 12 f0       	push   $0xf01285f2
f0111f60:	e8 26 f0 fe ff       	call   f0100f8b <cprintf>
f0111f65:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0111f68:	83 ec 0c             	sub    $0xc,%esp
f0111f6b:	68 04 86 12 f0       	push   $0xf0128604
f0111f70:	e8 16 f0 fe ff       	call   f0100f8b <cprintf>
f0111f75:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0111f78:	83 ec 04             	sub    $0x4,%esp
f0111f7b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111f81:	50                   	push   %eax
f0111f82:	68 3a 86 12 f0       	push   $0xf012863a
f0111f87:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111f8d:	50                   	push   %eax
f0111f8e:	e8 db cd 00 00       	call   f011ed6e <strcconcat>
f0111f93:	83 c4 10             	add    $0x10,%esp
f0111f96:	83 ec 0c             	sub    $0xc,%esp
f0111f99:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111f9f:	50                   	push   %eax
f0111fa0:	e8 56 ff fe ff       	call   f0101efb <execute_command>
f0111fa5:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0111fa8:	83 ec 04             	sub    $0x4,%esp
f0111fab:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111fb1:	50                   	push   %eax
f0111fb2:	68 44 86 12 f0       	push   $0xf0128644
f0111fb7:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111fbd:	50                   	push   %eax
f0111fbe:	e8 ab cd 00 00       	call   f011ed6e <strcconcat>
f0111fc3:	83 c4 10             	add    $0x10,%esp
f0111fc6:	83 ec 0c             	sub    $0xc,%esp
f0111fc9:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111fcf:	50                   	push   %eax
f0111fd0:	e8 26 ff fe ff       	call   f0101efb <execute_command>
f0111fd5:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0111fd8:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111fde:	bb bd 8b 12 f0       	mov    $0xf0128bbd,%ebx
f0111fe3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111fe8:	89 c7                	mov    %eax,%edi
f0111fea:	89 de                	mov    %ebx,%esi
f0111fec:	89 d1                	mov    %edx,%ecx
f0111fee:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111ff0:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0111ff6:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111ffb:	b0 00                	mov    $0x0,%al
f0111ffd:	89 d7                	mov    %edx,%edi
f0111fff:	f3 aa                	rep stos %al,%es:(%edi)
f0112001:	83 ec 0c             	sub    $0xc,%esp
f0112004:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011200a:	50                   	push   %eax
f011200b:	e8 eb fe fe ff       	call   f0101efb <execute_command>
f0112010:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0112013:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112019:	bb 21 8c 12 f0       	mov    $0xf0128c21,%ebx
f011201e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112023:	89 c7                	mov    %eax,%edi
f0112025:	89 de                	mov    %ebx,%esi
f0112027:	89 d1                	mov    %edx,%ecx
f0112029:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011202b:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112031:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112036:	b0 00                	mov    $0x0,%al
f0112038:	89 d7                	mov    %edx,%edi
f011203a:	f3 aa                	rep stos %al,%es:(%edi)
f011203c:	83 ec 0c             	sub    $0xc,%esp
f011203f:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112045:	50                   	push   %eax
f0112046:	e8 b0 fe fe ff       	call   f0101efb <execute_command>
f011204b:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f011204e:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112054:	bb 85 8c 12 f0       	mov    $0xf0128c85,%ebx
f0112059:	ba 0f 00 00 00       	mov    $0xf,%edx
f011205e:	89 c7                	mov    %eax,%edi
f0112060:	89 de                	mov    %ebx,%esi
f0112062:	89 d1                	mov    %edx,%ecx
f0112064:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112066:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f011206c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112071:	b0 00                	mov    $0x0,%al
f0112073:	89 d7                	mov    %edx,%edi
f0112075:	f3 aa                	rep stos %al,%es:(%edi)
f0112077:	83 ec 0c             	sub    $0xc,%esp
f011207a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112080:	50                   	push   %eax
f0112081:	e8 75 fe fe ff       	call   f0101efb <execute_command>
f0112086:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0112089:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011208f:	bb e9 8c 12 f0       	mov    $0xf0128ce9,%ebx
f0112094:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112099:	89 c7                	mov    %eax,%edi
f011209b:	89 de                	mov    %ebx,%esi
f011209d:	89 d1                	mov    %edx,%ecx
f011209f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01120a1:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01120a7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01120ac:	b0 00                	mov    $0x0,%al
f01120ae:	89 d7                	mov    %edx,%edi
f01120b0:	f3 aa                	rep stos %al,%es:(%edi)
f01120b2:	83 ec 0c             	sub    $0xc,%esp
f01120b5:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01120bb:	50                   	push   %eax
f01120bc:	e8 3a fe fe ff       	call   f0101efb <execute_command>
f01120c1:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01120c4:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01120ca:	bb 4d 8d 12 f0       	mov    $0xf0128d4d,%ebx
f01120cf:	ba 0f 00 00 00       	mov    $0xf,%edx
f01120d4:	89 c7                	mov    %eax,%edi
f01120d6:	89 de                	mov    %ebx,%esi
f01120d8:	89 d1                	mov    %edx,%ecx
f01120da:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01120dc:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01120e2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01120e7:	b0 00                	mov    $0x0,%al
f01120e9:	89 d7                	mov    %edx,%edi
f01120eb:	f3 aa                	rep stos %al,%es:(%edi)
f01120ed:	83 ec 0c             	sub    $0xc,%esp
f01120f0:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01120f6:	50                   	push   %eax
f01120f7:	e8 ff fd fe ff       	call   f0101efb <execute_command>
f01120fc:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f01120ff:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112105:	bb b1 8d 12 f0       	mov    $0xf0128db1,%ebx
f011210a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011210f:	89 c7                	mov    %eax,%edi
f0112111:	89 de                	mov    %ebx,%esi
f0112113:	89 d1                	mov    %edx,%ecx
f0112115:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112117:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011211d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112122:	b0 00                	mov    $0x0,%al
f0112124:	89 d7                	mov    %edx,%edi
f0112126:	f3 aa                	rep stos %al,%es:(%edi)
f0112128:	83 ec 0c             	sub    $0xc,%esp
f011212b:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112131:	50                   	push   %eax
f0112132:	e8 c4 fd fe ff       	call   f0101efb <execute_command>
f0112137:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f011213a:	83 ec 04             	sub    $0x4,%esp
f011213d:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112143:	50                   	push   %eax
f0112144:	68 4e 86 12 f0       	push   $0xf012864e
f0112149:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011214f:	50                   	push   %eax
f0112150:	e8 19 cc 00 00       	call   f011ed6e <strcconcat>
f0112155:	83 c4 10             	add    $0x10,%esp
f0112158:	83 ec 0c             	sub    $0xc,%esp
f011215b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112161:	50                   	push   %eax
f0112162:	e8 94 fd fe ff       	call   f0101efb <execute_command>
f0112167:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f011216a:	83 ec 04             	sub    $0x4,%esp
f011216d:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112173:	50                   	push   %eax
f0112174:	68 58 86 12 f0       	push   $0xf0128658
f0112179:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011217f:	50                   	push   %eax
f0112180:	e8 e9 cb 00 00       	call   f011ed6e <strcconcat>
f0112185:	83 c4 10             	add    $0x10,%esp
f0112188:	83 ec 0c             	sub    $0xc,%esp
f011218b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112191:	50                   	push   %eax
f0112192:	e8 64 fd fe ff       	call   f0101efb <execute_command>
f0112197:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f011219a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01121a0:	bb 15 8e 12 f0       	mov    $0xf0128e15,%ebx
f01121a5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01121aa:	89 c7                	mov    %eax,%edi
f01121ac:	89 de                	mov    %ebx,%esi
f01121ae:	89 d1                	mov    %edx,%ecx
f01121b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01121b2:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01121b8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01121bd:	b0 00                	mov    $0x0,%al
f01121bf:	89 d7                	mov    %edx,%edi
f01121c1:	f3 aa                	rep stos %al,%es:(%edi)
f01121c3:	83 ec 0c             	sub    $0xc,%esp
f01121c6:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01121cc:	50                   	push   %eax
f01121cd:	e8 29 fd fe ff       	call   f0101efb <execute_command>
f01121d2:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01121d5:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01121db:	bb 79 8e 12 f0       	mov    $0xf0128e79,%ebx
f01121e0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01121e5:	89 c7                	mov    %eax,%edi
f01121e7:	89 de                	mov    %ebx,%esi
f01121e9:	89 d1                	mov    %edx,%ecx
f01121eb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01121ed:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01121f3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01121f8:	b0 00                	mov    $0x0,%al
f01121fa:	89 d7                	mov    %edx,%edi
f01121fc:	f3 aa                	rep stos %al,%es:(%edi)
f01121fe:	83 ec 0c             	sub    $0xc,%esp
f0112201:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112207:	50                   	push   %eax
f0112208:	e8 ee fc fe ff       	call   f0101efb <execute_command>
f011220d:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0112210:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112216:	bb dd 8e 12 f0       	mov    $0xf0128edd,%ebx
f011221b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112220:	89 c7                	mov    %eax,%edi
f0112222:	89 de                	mov    %ebx,%esi
f0112224:	89 d1                	mov    %edx,%ecx
f0112226:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112228:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011222e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112233:	b0 00                	mov    $0x0,%al
f0112235:	89 d7                	mov    %edx,%edi
f0112237:	f3 aa                	rep stos %al,%es:(%edi)
f0112239:	83 ec 0c             	sub    $0xc,%esp
f011223c:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112242:	50                   	push   %eax
f0112243:	e8 b3 fc fe ff       	call   f0101efb <execute_command>
f0112248:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f011224b:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0112252:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0112259:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0112260:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0112267:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f011226e:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0112275:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f011227c:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0112283:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f011228a:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0112291:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0112298:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f011229f:	8b 45 90             	mov    -0x70(%ebp),%eax
f01122a2:	8a 00                	mov    (%eax),%al
f01122a4:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01122aa:	e8 4d b4 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01122af:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f01122b2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01122b5:	89 d0                	mov    %edx,%eax
f01122b7:	01 c0                	add    %eax,%eax
f01122b9:	01 d0                	add    %edx,%eax
f01122bb:	01 c0                	add    %eax,%eax
f01122bd:	50                   	push   %eax
f01122be:	68 00 00 40 00       	push   $0x400000
f01122c3:	68 00 00 20 00       	push   $0x200000
f01122c8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01122cb:	e8 01 79 ff ff       	call   f0109bd1 <copy_paste_chunk>
f01122d0:	83 c4 10             	add    $0x10,%esp
f01122d3:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01122d6:	e8 21 b4 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01122db:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01122de:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01122e5:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01122e9:	75 08                	jne    f01122f3 <test_copy_paste_chunk+0x929>
f01122eb:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01122ee:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01122f1:	74 2b                	je     f011231e <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01122f3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01122f6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01122f9:	83 ec 0c             	sub    $0xc,%esp
f01122fc:	50                   	push   %eax
f01122fd:	ff 75 80             	pushl  -0x80(%ebp)
f0112300:	68 64 86 12 f0       	push   $0xf0128664
f0112305:	68 3f 03 00 00       	push   $0x33f
f011230a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011230f:	e8 c2 e1 fe ff       	call   f01004d6 <_warn>
f0112314:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112317:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011231e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112322:	74 04                	je     f0112328 <test_copy_paste_chunk+0x95e>
f0112324:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112328:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f011232f:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0112336:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112339:	83 ec 08             	sub    $0x8,%esp
f011233c:	6a 01                	push   $0x1
f011233e:	6a 07                	push   $0x7
f0112340:	6a 07                	push   $0x7
f0112342:	6a 07                	push   $0x7
f0112344:	6a 07                	push   $0x7
f0112346:	6a 01                	push   $0x1
f0112348:	68 00 20 00 00       	push   $0x2000
f011234d:	68 00 00 40 00       	push   $0x400000
f0112352:	68 00 00 20 00       	push   $0x200000
f0112357:	ff 75 d4             	pushl  -0x2c(%ebp)
f011235a:	e8 bf 32 00 00       	call   f011561e <CCP>
f011235f:	83 c4 30             	add    $0x30,%esp
f0112362:	83 f8 01             	cmp    $0x1,%eax
f0112365:	74 2b                	je     f0112392 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0112367:	83 ec 04             	sub    $0x4,%esp
f011236a:	68 b8 86 12 f0       	push   $0xf01286b8
f011236f:	68 48 03 00 00       	push   $0x348
f0112374:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112379:	e8 58 e1 fe ff       	call   f01004d6 <_warn>
f011237e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112381:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0112388:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f011238f:	00 00 00 
		}
		if (correct) eval += 5 ;
f0112392:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112396:	74 04                	je     f011239c <test_copy_paste_chunk+0x9d2>
f0112398:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011239c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f01123a3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01123a6:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f01123a9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01123ac:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f01123af:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01123b2:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f01123b5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01123b8:	8a 00                	mov    (%eax),%al
f01123ba:	3c 61                	cmp    $0x61,%al
f01123bc:	75 69                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123be:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01123c1:	8a 00                	mov    (%eax),%al
f01123c3:	3c 61                	cmp    $0x61,%al
f01123c5:	75 60                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123c7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01123ca:	8a 00                	mov    (%eax),%al
f01123cc:	3c 79                	cmp    $0x79,%al
f01123ce:	75 57                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123d0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01123d3:	8a 00                	mov    (%eax),%al
f01123d5:	3c 62                	cmp    $0x62,%al
f01123d7:	75 4e                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123d9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01123dc:	8a 00                	mov    (%eax),%al
f01123de:	3c 63                	cmp    $0x63,%al
f01123e0:	75 45                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123e2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01123e5:	8a 00                	mov    (%eax),%al
f01123e7:	3c 7a                	cmp    $0x7a,%al
f01123e9:	75 3c                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01123eb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01123ee:	8a 00                	mov    (%eax),%al
f01123f0:	3c 77                	cmp    $0x77,%al
f01123f2:	75 33                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123f4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01123f7:	8a 00                	mov    (%eax),%al
f01123f9:	3c 64                	cmp    $0x64,%al
f01123fb:	75 2a                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f01123fd:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112400:	8a 00                	mov    (%eax),%al
f0112402:	3c 65                	cmp    $0x65,%al
f0112404:	75 21                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f0112406:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112409:	8a 00                	mov    (%eax),%al
f011240b:	3c 65                	cmp    $0x65,%al
f011240d:	75 18                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f011240f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112412:	8a 00                	mov    (%eax),%al
f0112414:	3c 66                	cmp    $0x66,%al
f0112416:	75 0f                	jne    f0112427 <test_copy_paste_chunk+0xa5d>
f0112418:	8b 45 90             	mov    -0x70(%ebp),%eax
f011241b:	8a 10                	mov    (%eax),%dl
f011241d:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0112423:	38 c2                	cmp    %al,%dl
f0112425:	74 21                	je     f0112448 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112427:	83 ec 04             	sub    $0x4,%esp
f011242a:	68 b8 85 12 f0       	push   $0xf01285b8
f011242f:	68 56 03 00 00       	push   $0x356
f0112434:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112439:	e8 98 e0 fe ff       	call   f01004d6 <_warn>
f011243e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112441:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112448:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011244c:	74 04                	je     f0112452 <test_copy_paste_chunk+0xa88>
f011244e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112452:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0112459:	8b 45 98             	mov    -0x68(%ebp),%eax
f011245c:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011245f:	e8 98 b2 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112464:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0112467:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011246a:	89 c2                	mov    %eax,%edx
f011246c:	01 d2                	add    %edx,%edx
f011246e:	01 d0                	add    %edx,%eax
f0112470:	50                   	push   %eax
f0112471:	68 00 08 20 00       	push   $0x200800
f0112476:	68 00 08 40 00       	push   $0x400800
f011247b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011247e:	e8 4e 77 ff ff       	call   f0109bd1 <copy_paste_chunk>
f0112483:	83 c4 10             	add    $0x10,%esp
f0112486:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112489:	e8 6e b2 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011248e:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0112491:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0112495:	75 08                	jne    f011249f <test_copy_paste_chunk+0xad5>
f0112497:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011249a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011249d:	74 2b                	je     f01124ca <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011249f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01124a2:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01124a5:	83 ec 0c             	sub    $0xc,%esp
f01124a8:	50                   	push   %eax
f01124a9:	ff 75 80             	pushl  -0x80(%ebp)
f01124ac:	68 64 86 12 f0       	push   $0xf0128664
f01124b1:	68 66 03 00 00       	push   $0x366
f01124b6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01124bb:	e8 16 e0 fe ff       	call   f01004d6 <_warn>
f01124c0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01124c3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01124ca:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01124ce:	74 04                	je     f01124d4 <test_copy_paste_chunk+0xb0a>
f01124d0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01124d4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01124db:	83 ec 08             	sub    $0x8,%esp
f01124de:	6a 01                	push   $0x1
f01124e0:	6a 07                	push   $0x7
f01124e2:	6a 07                	push   $0x7
f01124e4:	6a 07                	push   $0x7
f01124e6:	6a 07                	push   $0x7
f01124e8:	6a 01                	push   $0x1
f01124ea:	68 00 20 00 00       	push   $0x2000
f01124ef:	68 00 00 20 00       	push   $0x200000
f01124f4:	68 00 00 40 00       	push   $0x400000
f01124f9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124fc:	e8 1d 31 00 00       	call   f011561e <CCP>
f0112501:	83 c4 30             	add    $0x30,%esp
f0112504:	83 f8 01             	cmp    $0x1,%eax
f0112507:	74 21                	je     f011252a <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112509:	83 ec 04             	sub    $0x4,%esp
f011250c:	68 04 87 12 f0       	push   $0xf0128704
f0112511:	68 6e 03 00 00       	push   $0x36e
f0112516:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011251b:	e8 b6 df fe ff       	call   f01004d6 <_warn>
f0112520:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112523:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011252a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011252e:	74 04                	je     f0112534 <test_copy_paste_chunk+0xb6a>
f0112530:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112534:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011253b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011253e:	8a 00                	mov    (%eax),%al
f0112540:	3c 61                	cmp    $0x61,%al
f0112542:	75 69                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f0112544:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112547:	8a 00                	mov    (%eax),%al
f0112549:	3c 61                	cmp    $0x61,%al
f011254b:	75 60                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f011254d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112550:	8a 00                	mov    (%eax),%al
f0112552:	3c 79                	cmp    $0x79,%al
f0112554:	75 57                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f0112556:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112559:	8a 00                	mov    (%eax),%al
f011255b:	3c 62                	cmp    $0x62,%al
f011255d:	75 4e                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f011255f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112562:	8a 00                	mov    (%eax),%al
f0112564:	3c 7a                	cmp    $0x7a,%al
f0112566:	75 45                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f0112568:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011256b:	8a 00                	mov    (%eax),%al
f011256d:	3c 7a                	cmp    $0x7a,%al
f011256f:	75 3c                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0112571:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112574:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0112576:	3c 64                	cmp    $0x64,%al
f0112578:	75 33                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011257a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011257d:	8a 00                	mov    (%eax),%al
f011257f:	3c 64                	cmp    $0x64,%al
f0112581:	75 2a                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f0112583:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112586:	8a 00                	mov    (%eax),%al
f0112588:	3c 65                	cmp    $0x65,%al
f011258a:	75 21                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f011258c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011258f:	8a 00                	mov    (%eax),%al
f0112591:	3c 78                	cmp    $0x78,%al
f0112593:	75 18                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f0112595:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112598:	8a 00                	mov    (%eax),%al
f011259a:	3c 66                	cmp    $0x66,%al
f011259c:	75 0f                	jne    f01125ad <test_copy_paste_chunk+0xbe3>
f011259e:	8b 45 90             	mov    -0x70(%ebp),%eax
f01125a1:	8a 10                	mov    (%eax),%dl
f01125a3:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01125a9:	38 c2                	cmp    %al,%dl
f01125ab:	74 21                	je     f01125ce <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01125ad:	83 ec 04             	sub    $0x4,%esp
f01125b0:	68 b8 85 12 f0       	push   $0xf01285b8
f01125b5:	68 77 03 00 00       	push   $0x377
f01125ba:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01125bf:	e8 12 df fe ff       	call   f01004d6 <_warn>
f01125c4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01125c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01125ce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01125d2:	74 04                	je     f01125d8 <test_copy_paste_chunk+0xc0e>
f01125d4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01125d8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f01125df:	83 ec 0c             	sub    $0xc,%esp
f01125e2:	68 4f 87 12 f0       	push   $0xf012874f
f01125e7:	e8 9f e9 fe ff       	call   f0100f8b <cprintf>
f01125ec:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01125ef:	83 ec 0c             	sub    $0xc,%esp
f01125f2:	68 60 87 12 f0       	push   $0xf0128760
f01125f7:	e8 8f e9 fe ff       	call   f0100f8b <cprintf>
f01125fc:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01125ff:	83 ec 04             	sub    $0x4,%esp
f0112602:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112608:	50                   	push   %eax
f0112609:	68 94 87 12 f0       	push   $0xf0128794
f011260e:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112614:	50                   	push   %eax
f0112615:	e8 54 c7 00 00       	call   f011ed6e <strcconcat>
f011261a:	83 c4 10             	add    $0x10,%esp
f011261d:	83 ec 0c             	sub    $0xc,%esp
f0112620:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112626:	50                   	push   %eax
f0112627:	e8 cf f8 fe ff       	call   f0101efb <execute_command>
f011262c:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f011262f:	83 ec 04             	sub    $0x4,%esp
f0112632:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112638:	50                   	push   %eax
f0112639:	68 9e 87 12 f0       	push   $0xf012879e
f011263e:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112644:	50                   	push   %eax
f0112645:	e8 24 c7 00 00       	call   f011ed6e <strcconcat>
f011264a:	83 c4 10             	add    $0x10,%esp
f011264d:	83 ec 0c             	sub    $0xc,%esp
f0112650:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112656:	50                   	push   %eax
f0112657:	e8 9f f8 fe ff       	call   f0101efb <execute_command>
f011265c:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f011265f:	83 ec 04             	sub    $0x4,%esp
f0112662:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112668:	50                   	push   %eax
f0112669:	68 a8 87 12 f0       	push   $0xf01287a8
f011266e:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112674:	50                   	push   %eax
f0112675:	e8 f4 c6 00 00       	call   f011ed6e <strcconcat>
f011267a:	83 c4 10             	add    $0x10,%esp
f011267d:	83 ec 0c             	sub    $0xc,%esp
f0112680:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112686:	50                   	push   %eax
f0112687:	e8 6f f8 fe ff       	call   f0101efb <execute_command>
f011268c:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f011268f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112695:	bb 41 8f 12 f0       	mov    $0xf0128f41,%ebx
f011269a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011269f:	89 c7                	mov    %eax,%edi
f01126a1:	89 de                	mov    %ebx,%esi
f01126a3:	89 d1                	mov    %edx,%ecx
f01126a5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01126a7:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01126ad:	b9 55 00 00 00       	mov    $0x55,%ecx
f01126b2:	b0 00                	mov    $0x0,%al
f01126b4:	89 d7                	mov    %edx,%edi
f01126b6:	f3 aa                	rep stos %al,%es:(%edi)
f01126b8:	83 ec 0c             	sub    $0xc,%esp
f01126bb:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01126c1:	50                   	push   %eax
f01126c2:	e8 34 f8 fe ff       	call   f0101efb <execute_command>
f01126c7:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f01126ca:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01126d0:	bb a5 8f 12 f0       	mov    $0xf0128fa5,%ebx
f01126d5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01126da:	89 c7                	mov    %eax,%edi
f01126dc:	89 de                	mov    %ebx,%esi
f01126de:	89 d1                	mov    %edx,%ecx
f01126e0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01126e2:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01126e8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01126ed:	b0 00                	mov    $0x0,%al
f01126ef:	89 d7                	mov    %edx,%edi
f01126f1:	f3 aa                	rep stos %al,%es:(%edi)
f01126f3:	83 ec 0c             	sub    $0xc,%esp
f01126f6:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01126fc:	50                   	push   %eax
f01126fd:	e8 f9 f7 fe ff       	call   f0101efb <execute_command>
f0112702:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0112705:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011270b:	bb 09 90 12 f0       	mov    $0xf0129009,%ebx
f0112710:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112715:	89 c7                	mov    %eax,%edi
f0112717:	89 de                	mov    %ebx,%esi
f0112719:	89 d1                	mov    %edx,%ecx
f011271b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011271d:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112723:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112728:	b0 00                	mov    $0x0,%al
f011272a:	89 d7                	mov    %edx,%edi
f011272c:	f3 aa                	rep stos %al,%es:(%edi)
f011272e:	83 ec 0c             	sub    $0xc,%esp
f0112731:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112737:	50                   	push   %eax
f0112738:	e8 be f7 fe ff       	call   f0101efb <execute_command>
f011273d:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112740:	e8 b7 af ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112745:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0112748:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011274b:	89 d0                	mov    %edx,%eax
f011274d:	01 c0                	add    %eax,%eax
f011274f:	01 d0                	add    %edx,%eax
f0112751:	c1 e0 02             	shl    $0x2,%eax
f0112754:	50                   	push   %eax
f0112755:	68 00 00 90 00       	push   $0x900000
f011275a:	68 00 00 80 00       	push   $0x800000
f011275f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112762:	e8 6a 74 ff ff       	call   f0109bd1 <copy_paste_chunk>
f0112767:	83 c4 10             	add    $0x10,%esp
f011276a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112770:	e8 87 af ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112775:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0112778:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f011277f:	75 0b                	jne    f011278c <test_copy_paste_chunk+0xdc2>
f0112781:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112784:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112787:	83 f8 03             	cmp    $0x3,%eax
f011278a:	74 2e                	je     f01127ba <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011278c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011278f:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112792:	83 ec 0c             	sub    $0xc,%esp
f0112795:	50                   	push   %eax
f0112796:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f011279c:	68 64 86 12 f0       	push   $0xf0128664
f01127a1:	68 95 03 00 00       	push   $0x395
f01127a6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01127ab:	e8 26 dd fe ff       	call   f01004d6 <_warn>
f01127b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01127b3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01127ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127be:	74 04                	je     f01127c4 <test_copy_paste_chunk+0xdfa>
f01127c0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01127c4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f01127cb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01127d2:	83 ec 08             	sub    $0x8,%esp
f01127d5:	6a 01                	push   $0x1
f01127d7:	6a 07                	push   $0x7
f01127d9:	6a 07                	push   $0x7
f01127db:	6a 07                	push   $0x7
f01127dd:	6a 07                	push   $0x7
f01127df:	6a 01                	push   $0x1
f01127e1:	68 00 30 00 00       	push   $0x3000
f01127e6:	68 00 00 90 00       	push   $0x900000
f01127eb:	68 00 00 80 00       	push   $0x800000
f01127f0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127f3:	e8 26 2e 00 00       	call   f011561e <CCP>
f01127f8:	83 c4 30             	add    $0x30,%esp
f01127fb:	83 f8 01             	cmp    $0x1,%eax
f01127fe:	74 28                	je     f0112828 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112800:	83 ec 04             	sub    $0x4,%esp
f0112803:	68 04 87 12 f0       	push   $0xf0128704
f0112808:	68 9e 03 00 00       	push   $0x39e
f011280d:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112812:	e8 bf dc fe ff       	call   f01004d6 <_warn>
f0112817:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011281a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0112821:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0112828:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011282c:	74 04                	je     f0112832 <test_copy_paste_chunk+0xe68>
f011282e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112832:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0112839:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011283d:	0f 84 9e 00 00 00    	je     f01128e1 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0112843:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f011284a:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0112851:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0112858:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f011285f:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0112866:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f011286d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112870:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0112873:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112876:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0112879:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011287c:	8a 00                	mov    (%eax),%al
f011287e:	3c 61                	cmp    $0x61,%al
f0112880:	75 2d                	jne    f01128af <test_copy_paste_chunk+0xee5>
f0112882:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112885:	8a 00                	mov    (%eax),%al
f0112887:	3c 61                	cmp    $0x61,%al
f0112889:	75 24                	jne    f01128af <test_copy_paste_chunk+0xee5>
f011288b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011288e:	8a 00                	mov    (%eax),%al
f0112890:	3c 79                	cmp    $0x79,%al
f0112892:	75 1b                	jne    f01128af <test_copy_paste_chunk+0xee5>
f0112894:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112897:	8a 00                	mov    (%eax),%al
f0112899:	3c 62                	cmp    $0x62,%al
f011289b:	75 12                	jne    f01128af <test_copy_paste_chunk+0xee5>
f011289d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01128a0:	8a 00                	mov    (%eax),%al
f01128a2:	3c 63                	cmp    $0x63,%al
f01128a4:	75 09                	jne    f01128af <test_copy_paste_chunk+0xee5>
f01128a6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01128a9:	8a 00                	mov    (%eax),%al
f01128ab:	3c 7a                	cmp    $0x7a,%al
f01128ad:	74 21                	je     f01128d0 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01128af:	83 ec 04             	sub    $0x4,%esp
f01128b2:	68 b8 85 12 f0       	push   $0xf01285b8
f01128b7:	68 b0 03 00 00       	push   $0x3b0
f01128bc:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01128c1:	e8 10 dc fe ff       	call   f01004d6 <_warn>
f01128c6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01128c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f01128d0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01128d4:	74 04                	je     f01128da <test_copy_paste_chunk+0xf10>
f01128d6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f01128da:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01128e1:	e8 16 ae ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01128e6:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f01128e9:	6a 00                	push   $0x0
f01128eb:	6a 02                	push   $0x2
f01128ed:	68 00 10 90 00       	push   $0x901000
f01128f2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128f5:	e8 b1 2b 00 00       	call   f01154ab <SB>
f01128fa:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f01128fd:	6a 00                	push   $0x0
f01128ff:	6a 02                	push   $0x2
f0112901:	68 00 20 90 00       	push   $0x902000
f0112906:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112909:	e8 9d 2b 00 00       	call   f01154ab <SB>
f011290e:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0112911:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112914:	c1 e0 03             	shl    $0x3,%eax
f0112917:	50                   	push   %eax
f0112918:	68 00 f0 bf 00       	push   $0xbff000
f011291d:	68 00 10 90 00       	push   $0x901000
f0112922:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112925:	e8 a7 72 ff ff       	call   f0109bd1 <copy_paste_chunk>
f011292a:	83 c4 10             	add    $0x10,%esp
f011292d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112933:	e8 c4 ad ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112938:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011293b:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0112942:	75 0b                	jne    f011294f <test_copy_paste_chunk+0xf85>
f0112944:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112947:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011294a:	83 f8 03             	cmp    $0x3,%eax
f011294d:	74 2e                	je     f011297d <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011294f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112952:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112955:	83 ec 0c             	sub    $0xc,%esp
f0112958:	50                   	push   %eax
f0112959:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f011295f:	68 64 86 12 f0       	push   $0xf0128664
f0112964:	68 c0 03 00 00       	push   $0x3c0
f0112969:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011296e:	e8 63 db fe ff       	call   f01004d6 <_warn>
f0112973:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112976:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011297d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112981:	74 04                	je     f0112987 <test_copy_paste_chunk+0xfbd>
f0112983:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112987:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f011298e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0112995:	83 ec 08             	sub    $0x8,%esp
f0112998:	6a 01                	push   $0x1
f011299a:	6a 07                	push   $0x7
f011299c:	6a 03                	push   $0x3
f011299e:	6a 07                	push   $0x7
f01129a0:	6a 03                	push   $0x3
f01129a2:	6a 01                	push   $0x1
f01129a4:	68 00 20 00 00       	push   $0x2000
f01129a9:	68 00 f0 bf 00       	push   $0xbff000
f01129ae:	68 00 10 90 00       	push   $0x901000
f01129b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129b6:	e8 63 2c 00 00       	call   f011561e <CCP>
f01129bb:	83 c4 30             	add    $0x30,%esp
f01129be:	83 f8 01             	cmp    $0x1,%eax
f01129c1:	74 28                	je     f01129eb <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01129c3:	83 ec 04             	sub    $0x4,%esp
f01129c6:	68 04 87 12 f0       	push   $0xf0128704
f01129cb:	68 c9 03 00 00       	push   $0x3c9
f01129d0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01129d5:	e8 fc da fe ff       	call   f01004d6 <_warn>
f01129da:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01129dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01129e4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f01129eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01129ef:	74 04                	je     f01129f5 <test_copy_paste_chunk+0x102b>
f01129f1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01129f5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01129fc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112a00:	74 72                	je     f0112a74 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0112a02:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0112a09:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0112a10:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0112a17:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0112a1e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112a21:	8a 00                	mov    (%eax),%al
f0112a23:	3c 62                	cmp    $0x62,%al
f0112a25:	75 1b                	jne    f0112a42 <test_copy_paste_chunk+0x1078>
f0112a27:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112a2a:	8a 00                	mov    (%eax),%al
f0112a2c:	3c 62                	cmp    $0x62,%al
f0112a2e:	75 12                	jne    f0112a42 <test_copy_paste_chunk+0x1078>
f0112a30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112a33:	8a 00                	mov    (%eax),%al
f0112a35:	3c 7a                	cmp    $0x7a,%al
f0112a37:	75 09                	jne    f0112a42 <test_copy_paste_chunk+0x1078>
f0112a39:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112a3c:	8a 00                	mov    (%eax),%al
f0112a3e:	3c 7a                	cmp    $0x7a,%al
f0112a40:	74 21                	je     f0112a63 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112a42:	83 ec 04             	sub    $0x4,%esp
f0112a45:	68 b8 85 12 f0       	push   $0xf01285b8
f0112a4a:	68 d5 03 00 00       	push   $0x3d5
f0112a4f:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112a54:	e8 7d da fe ff       	call   f01004d6 <_warn>
f0112a59:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112a5c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112a63:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a67:	74 04                	je     f0112a6d <test_copy_paste_chunk+0x10a3>
f0112a69:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112a6d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0112a74:	83 ec 0c             	sub    $0xc,%esp
f0112a77:	68 b2 87 12 f0       	push   $0xf01287b2
f0112a7c:	e8 0a e5 fe ff       	call   f0100f8b <cprintf>
f0112a81:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0112a84:	83 ec 08             	sub    $0x8,%esp
f0112a87:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112a8a:	68 c4 87 12 f0       	push   $0xf01287c4
f0112a8f:	e8 f7 e4 fe ff       	call   f0100f8b <cprintf>
f0112a94:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112a97:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112a9b:	75 10                	jne    f0112aad <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0112a9d:	83 ec 0c             	sub    $0xc,%esp
f0112aa0:	68 f8 87 12 f0       	push   $0xf01287f8
f0112aa5:	e8 e1 e4 fe ff       	call   f0100f8b <cprintf>
f0112aaa:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112aad:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f0112ab2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112ab5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112ab8:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112abb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112ac0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112ac3:	5b                   	pop    %ebx
f0112ac4:	5e                   	pop    %esi
f0112ac5:	5f                   	pop    %edi
f0112ac6:	5d                   	pop    %ebp
f0112ac7:	c3                   	ret    

f0112ac8 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0112ac8:	55                   	push   %ebp
f0112ac9:	89 e5                	mov    %esp,%ebp
f0112acb:	57                   	push   %edi
f0112acc:	56                   	push   %esi
f0112acd:	53                   	push   %ebx
f0112ace:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112ad4:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0112ada:	bb c4 84 12 f0       	mov    $0xf01284c4,%ebx
f0112adf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ae4:	89 c7                	mov    %eax,%edi
f0112ae6:	89 de                	mov    %ebx,%esi
f0112ae8:	89 d1                	mov    %edx,%ecx
f0112aea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112aec:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0112af2:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112af7:	b0 00                	mov    $0x0,%al
f0112af9:	89 d7                	mov    %edx,%edi
f0112afb:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112afd:	6a 00                	push   $0x0
f0112aff:	6a 0a                	push   $0xa
f0112b01:	6a 14                	push   $0x14
f0112b03:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0112b09:	50                   	push   %eax
f0112b0a:	e8 55 73 ff ff       	call   f0109e64 <env_create>
f0112b0f:	83 c4 10             	add    $0x10,%esp
f0112b12:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112b15:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112b18:	8b 40 64             	mov    0x64(%eax),%eax
f0112b1b:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0112b1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112b21:	8b 40 68             	mov    0x68(%eax),%eax
f0112b24:	89 45 80             	mov    %eax,-0x80(%ebp)
f0112b27:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112b2a:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0112b2d:	83 ec 0c             	sub    $0xc,%esp
f0112b30:	ff 75 cc             	pushl  -0x34(%ebp)
f0112b33:	e8 b2 2a 00 00       	call   f01155ea <ClearUserSpace>
f0112b38:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0112b3b:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112b42:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0112b49:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0112b50:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0112b54:	83 ec 0c             	sub    $0xc,%esp
f0112b57:	68 70 90 12 f0       	push   $0xf0129070
f0112b5c:	e8 2a e4 fe ff       	call   f0100f8b <cprintf>
f0112b61:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0112b64:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0112b6b:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0112b72:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112b75:	8a 00                	mov    (%eax),%al
f0112b77:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0112b7d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112b80:	8a 00                	mov    (%eax),%al
f0112b82:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112b88:	e8 6f ab ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112b8d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0112b90:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112b93:	89 d0                	mov    %edx,%eax
f0112b95:	01 c0                	add    %eax,%eax
f0112b97:	01 d0                	add    %edx,%eax
f0112b99:	01 c0                	add    %eax,%eax
f0112b9b:	83 ec 0c             	sub    $0xc,%esp
f0112b9e:	6a 02                	push   $0x2
f0112ba0:	50                   	push   %eax
f0112ba1:	68 00 40 10 f0       	push   $0xf0104000
f0112ba6:	68 00 00 10 f0       	push   $0xf0100000
f0112bab:	ff 75 cc             	pushl  -0x34(%ebp)
f0112bae:	e8 38 70 ff ff       	call   f0109beb <share_chunk>
f0112bb3:	83 c4 20             	add    $0x20,%esp
f0112bb6:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112bb9:	e8 3e ab ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112bbe:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0112bc1:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0112bc5:	75 08                	jne    f0112bcf <test_share_chunk+0x107>
f0112bc7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112bca:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0112bcd:	74 28                	je     f0112bf7 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0112bcf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112bd2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112bd5:	83 ec 0c             	sub    $0xc,%esp
f0112bd8:	50                   	push   %eax
f0112bd9:	ff 75 b0             	pushl  -0x50(%ebp)
f0112bdc:	68 9c 90 12 f0       	push   $0xf012909c
f0112be1:	68 11 04 00 00       	push   $0x411
f0112be6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112beb:	e8 e6 d8 fe ff       	call   f01004d6 <_warn>
f0112bf0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112bf3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112bf7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112bfb:	74 04                	je     f0112c01 <test_share_chunk+0x139>
f0112bfd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112c01:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0112c05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112c08:	c1 e0 03             	shl    $0x3,%eax
f0112c0b:	83 ec 08             	sub    $0x8,%esp
f0112c0e:	68 fd 00 00 00       	push   $0xfd
f0112c13:	6a 07                	push   $0x7
f0112c15:	6a 03                	push   $0x3
f0112c17:	6a 07                	push   $0x7
f0112c19:	6a 03                	push   $0x3
f0112c1b:	6a 01                	push   $0x1
f0112c1d:	50                   	push   %eax
f0112c1e:	68 00 40 10 f0       	push   $0xf0104000
f0112c23:	68 00 00 10 f0       	push   $0xf0100000
f0112c28:	ff 75 cc             	pushl  -0x34(%ebp)
f0112c2b:	e8 ee 29 00 00       	call   f011561e <CCP>
f0112c30:	83 c4 30             	add    $0x30,%esp
f0112c33:	85 c0                	test   %eax,%eax
f0112c35:	75 1e                	jne    f0112c55 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0112c37:	83 ec 04             	sub    $0x4,%esp
f0112c3a:	68 f8 90 12 f0       	push   $0xf01290f8
f0112c3f:	68 19 04 00 00       	push   $0x419
f0112c44:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112c49:	e8 88 d8 fe ff       	call   f01004d6 <_warn>
f0112c4e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112c51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112c55:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112c59:	74 04                	je     f0112c5f <test_share_chunk+0x197>
f0112c5b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0112c5f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112c62:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0112c65:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c68:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0112c6b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112c6e:	8a 00                	mov    (%eax),%al
f0112c70:	3c 41                	cmp    $0x41,%al
f0112c72:	75 09                	jne    f0112c7d <test_share_chunk+0x1b5>
f0112c74:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c77:	8a 00                	mov    (%eax),%al
f0112c79:	3c 42                	cmp    $0x42,%al
f0112c7b:	74 1e                	je     f0112c9b <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0112c7d:	83 ec 04             	sub    $0x4,%esp
f0112c80:	68 40 91 12 f0       	push   $0xf0129140
f0112c85:	68 23 04 00 00       	push   $0x423
f0112c8a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112c8f:	e8 42 d8 fe ff       	call   f01004d6 <_warn>
f0112c94:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112c97:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0112c9b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112c9f:	74 04                	je     f0112ca5 <test_share_chunk+0x1dd>
f0112ca1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112ca5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0112ca9:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0112caf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112cb2:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0112cb4:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0112cba:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112cbd:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0112cbf:	83 ec 0c             	sub    $0xc,%esp
f0112cc2:	68 75 91 12 f0       	push   $0xf0129175
f0112cc7:	e8 bf e2 fe ff       	call   f0100f8b <cprintf>
f0112ccc:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0112ccf:	83 ec 0c             	sub    $0xc,%esp
f0112cd2:	68 84 91 12 f0       	push   $0xf0129184
f0112cd7:	e8 af e2 fe ff       	call   f0100f8b <cprintf>
f0112cdc:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112cdf:	e8 18 aa ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112ce4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0112ce7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112cea:	c1 e0 05             	shl    $0x5,%eax
f0112ced:	83 ec 0c             	sub    $0xc,%esp
f0112cf0:	68 02 0e 00 00       	push   $0xe02
f0112cf5:	50                   	push   %eax
f0112cf6:	68 00 00 00 40       	push   $0x40000000
f0112cfb:	68 00 00 00 f0       	push   $0xf0000000
f0112d00:	ff 75 cc             	pushl  -0x34(%ebp)
f0112d03:	e8 e3 6e ff ff       	call   f0109beb <share_chunk>
f0112d08:	83 c4 20             	add    $0x20,%esp
f0112d0b:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112d0e:	e8 e9 a9 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112d13:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0112d16:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0112d1a:	75 1f                	jne    f0112d3b <test_share_chunk+0x273>
f0112d1c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112d1f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112d22:	89 c1                	mov    %eax,%ecx
f0112d24:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d27:	c1 e0 05             	shl    $0x5,%eax
f0112d2a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0112d2d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0112d34:	99                   	cltd   
f0112d35:	f7 fb                	idiv   %ebx
f0112d37:	39 c1                	cmp    %eax,%ecx
f0112d39:	74 28                	je     f0112d63 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112d3b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112d3e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112d41:	83 ec 0c             	sub    $0xc,%esp
f0112d44:	50                   	push   %eax
f0112d45:	ff 75 a8             	pushl  -0x58(%ebp)
f0112d48:	68 c0 91 12 f0       	push   $0xf01291c0
f0112d4d:	68 3b 04 00 00       	push   $0x43b
f0112d52:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112d57:	e8 7a d7 fe ff       	call   f01004d6 <_warn>
f0112d5c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112d5f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112d63:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112d67:	74 04                	je     f0112d6d <test_share_chunk+0x2a5>
f0112d69:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112d6d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0112d71:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0112d78:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d7b:	c1 e0 05             	shl    $0x5,%eax
f0112d7e:	83 ec 08             	sub    $0x8,%esp
f0112d81:	6a 02                	push   $0x2
f0112d83:	6a 07                	push   $0x7
f0112d85:	6a 03                	push   $0x3
f0112d87:	68 07 0e 00 00       	push   $0xe07
f0112d8c:	68 03 0e 00 00       	push   $0xe03
f0112d91:	6a ff                	push   $0xffffffff
f0112d93:	50                   	push   %eax
f0112d94:	68 00 00 00 40       	push   $0x40000000
f0112d99:	68 00 00 00 f0       	push   $0xf0000000
f0112d9e:	ff 75 cc             	pushl  -0x34(%ebp)
f0112da1:	e8 78 28 00 00       	call   f011561e <CCP>
f0112da6:	83 c4 30             	add    $0x30,%esp
f0112da9:	85 c0                	test   %eax,%eax
f0112dab:	75 25                	jne    f0112dd2 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0112dad:	83 ec 04             	sub    $0x4,%esp
f0112db0:	68 f8 90 12 f0       	push   $0xf01290f8
f0112db5:	68 44 04 00 00       	push   $0x444
f0112dba:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112dbf:	e8 12 d7 fe ff       	call   f01004d6 <_warn>
f0112dc4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112dc7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0112dcb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0112dd2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112dd5:	89 d0                	mov    %edx,%eax
f0112dd7:	01 c0                	add    %eax,%eax
f0112dd9:	01 d0                	add    %edx,%eax
f0112ddb:	c1 e0 02             	shl    $0x2,%eax
f0112dde:	83 ec 08             	sub    $0x8,%esp
f0112de1:	6a 02                	push   $0x2
f0112de3:	6a 07                	push   $0x7
f0112de5:	6a 03                	push   $0x3
f0112de7:	68 07 0e 00 00       	push   $0xe07
f0112dec:	68 03 0e 00 00       	push   $0xe03
f0112df1:	6a 02                	push   $0x2
f0112df3:	50                   	push   %eax
f0112df4:	68 00 00 00 40       	push   $0x40000000
f0112df9:	68 00 00 00 f0       	push   $0xf0000000
f0112dfe:	ff 75 cc             	pushl  -0x34(%ebp)
f0112e01:	e8 18 28 00 00       	call   f011561e <CCP>
f0112e06:	83 c4 30             	add    $0x30,%esp
f0112e09:	85 c0                	test   %eax,%eax
f0112e0b:	75 1e                	jne    f0112e2b <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0112e0d:	83 ec 04             	sub    $0x4,%esp
f0112e10:	68 f8 90 12 f0       	push   $0xf01290f8
f0112e15:	68 4b 04 00 00       	push   $0x44b
f0112e1a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112e1f:	e8 b2 d6 fe ff       	call   f01004d6 <_warn>
f0112e24:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112e27:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112e2b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112e2f:	74 04                	je     f0112e35 <test_share_chunk+0x36d>
f0112e31:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112e35:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0112e39:	b8 50 f6 60 f0       	mov    $0xf060f650,%eax
f0112e3e:	05 00 00 00 10       	add    $0x10000000,%eax
f0112e43:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0112e46:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112e49:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0112e4e:	83 ec 08             	sub    $0x8,%esp
f0112e51:	6a 02                	push   $0x2
f0112e53:	6a 07                	push   $0x7
f0112e55:	6a 03                	push   $0x3
f0112e57:	68 07 0e 00 00       	push   $0xe07
f0112e5c:	68 03 0e 00 00       	push   $0xe03
f0112e61:	6a 02                	push   $0x2
f0112e63:	50                   	push   %eax
f0112e64:	68 00 00 0a 40       	push   $0x400a0000
f0112e69:	68 00 00 0a f0       	push   $0xf00a0000
f0112e6e:	ff 75 cc             	pushl  -0x34(%ebp)
f0112e71:	e8 a8 27 00 00       	call   f011561e <CCP>
f0112e76:	83 c4 30             	add    $0x30,%esp
f0112e79:	85 c0                	test   %eax,%eax
f0112e7b:	75 1e                	jne    f0112e9b <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0112e7d:	83 ec 04             	sub    $0x4,%esp
f0112e80:	68 f8 90 12 f0       	push   $0xf01290f8
f0112e85:	68 55 04 00 00       	push   $0x455
f0112e8a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112e8f:	e8 42 d6 fe ff       	call   f01004d6 <_warn>
f0112e94:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112e97:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112e9b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112e9f:	74 04                	je     f0112ea5 <test_share_chunk+0x3dd>
f0112ea1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112ea5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0112ea9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112ead:	0f 84 a4 00 00 00    	je     f0112f57 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0112eb3:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0112eba:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112ebd:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0112ec0:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0112ec7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112eca:	8a 00                	mov    (%eax),%al
f0112ecc:	3c 41                	cmp    $0x41,%al
f0112ece:	75 09                	jne    f0112ed9 <test_share_chunk+0x411>
f0112ed0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ed3:	8a 00                	mov    (%eax),%al
f0112ed5:	3c 41                	cmp    $0x41,%al
f0112ed7:	74 1e                	je     f0112ef7 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0112ed9:	83 ec 04             	sub    $0x4,%esp
f0112edc:	68 40 91 12 f0       	push   $0xf0129140
f0112ee1:	68 62 04 00 00       	push   $0x462
f0112ee6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112eeb:	e8 e6 d5 fe ff       	call   f01004d6 <_warn>
f0112ef0:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112ef3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0112ef7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112efb:	74 04                	je     f0112f01 <test_share_chunk+0x439>
f0112efd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112f01:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0112f05:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0112f0c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112f0f:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0112f12:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0112f19:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112f1c:	8a 00                	mov    (%eax),%al
f0112f1e:	3c 43                	cmp    $0x43,%al
f0112f20:	75 09                	jne    f0112f2b <test_share_chunk+0x463>
f0112f22:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f25:	8a 00                	mov    (%eax),%al
f0112f27:	3c 43                	cmp    $0x43,%al
f0112f29:	74 1e                	je     f0112f49 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0112f2b:	83 ec 04             	sub    $0x4,%esp
f0112f2e:	68 40 91 12 f0       	push   $0xf0129140
f0112f33:	68 6d 04 00 00       	push   $0x46d
f0112f38:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112f3d:	e8 94 d5 fe ff       	call   f01004d6 <_warn>
f0112f42:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112f45:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0112f49:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112f4d:	74 04                	je     f0112f53 <test_share_chunk+0x48b>
f0112f4f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112f53:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0112f57:	83 ec 0c             	sub    $0xc,%esp
f0112f5a:	68 4f 87 12 f0       	push   $0xf012874f
f0112f5f:	e8 27 e0 fe ff       	call   f0100f8b <cprintf>
f0112f64:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0112f67:	83 ec 0c             	sub    $0xc,%esp
f0112f6a:	68 10 92 12 f0       	push   $0xf0129210
f0112f6f:	e8 17 e0 fe ff       	call   f0100f8b <cprintf>
f0112f74:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112f77:	e8 80 a7 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112f7c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0112f7f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112f82:	89 d0                	mov    %edx,%eax
f0112f84:	c1 e0 03             	shl    $0x3,%eax
f0112f87:	01 d0                	add    %edx,%eax
f0112f89:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0112f90:	01 d0                	add    %edx,%eax
f0112f92:	c1 e0 03             	shl    $0x3,%eax
f0112f95:	83 ec 0c             	sub    $0xc,%esp
f0112f98:	6a 06                	push   $0x6
f0112f9a:	50                   	push   %eax
f0112f9b:	6a 00                	push   $0x0
f0112f9d:	68 00 00 00 40       	push   $0x40000000
f0112fa2:	ff 75 cc             	pushl  -0x34(%ebp)
f0112fa5:	e8 41 6c ff ff       	call   f0109beb <share_chunk>
f0112faa:	83 c4 20             	add    $0x20,%esp
f0112fad:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112fb0:	e8 47 a7 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0112fb5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0112fb8:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0112fbc:	75 0b                	jne    f0112fc9 <test_share_chunk+0x501>
f0112fbe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112fc1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112fc4:	83 f8 01             	cmp    $0x1,%eax
f0112fc7:	74 28                	je     f0112ff1 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112fc9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112fcc:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112fcf:	83 ec 0c             	sub    $0xc,%esp
f0112fd2:	50                   	push   %eax
f0112fd3:	ff 75 a0             	pushl  -0x60(%ebp)
f0112fd6:	68 c0 91 12 f0       	push   $0xf01291c0
f0112fdb:	68 83 04 00 00       	push   $0x483
f0112fe0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0112fe5:	e8 ec d4 fe ff       	call   f01004d6 <_warn>
f0112fea:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112fed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112ff1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112ff5:	74 04                	je     f0112ffb <test_share_chunk+0x533>
f0112ff7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112ffb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0112fff:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113006:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113009:	05 00 80 02 00       	add    $0x28000,%eax
f011300e:	c1 e0 02             	shl    $0x2,%eax
f0113011:	83 ec 08             	sub    $0x8,%esp
f0113014:	6a 02                	push   $0x2
f0113016:	6a 07                	push   $0x7
f0113018:	6a 03                	push   $0x3
f011301a:	6a 07                	push   $0x7
f011301c:	6a 07                	push   $0x7
f011301e:	6a ff                	push   $0xffffffff
f0113020:	50                   	push   %eax
f0113021:	6a 00                	push   $0x0
f0113023:	68 00 00 00 40       	push   $0x40000000
f0113028:	ff 75 cc             	pushl  -0x34(%ebp)
f011302b:	e8 ee 25 00 00       	call   f011561e <CCP>
f0113030:	83 c4 30             	add    $0x30,%esp
f0113033:	85 c0                	test   %eax,%eax
f0113035:	75 25                	jne    f011305c <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113037:	83 ec 04             	sub    $0x4,%esp
f011303a:	68 f8 90 12 f0       	push   $0xf01290f8
f011303f:	68 8c 04 00 00       	push   $0x48c
f0113044:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113049:	e8 88 d4 fe ff       	call   f01004d6 <_warn>
f011304e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113051:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113055:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011305c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011305f:	89 d0                	mov    %edx,%eax
f0113061:	01 c0                	add    %eax,%eax
f0113063:	01 d0                	add    %edx,%eax
f0113065:	c1 e0 02             	shl    $0x2,%eax
f0113068:	83 ec 08             	sub    $0x8,%esp
f011306b:	6a 02                	push   $0x2
f011306d:	6a 07                	push   $0x7
f011306f:	6a 03                	push   $0x3
f0113071:	6a 07                	push   $0x7
f0113073:	6a 07                	push   $0x7
f0113075:	6a 03                	push   $0x3
f0113077:	50                   	push   %eax
f0113078:	6a 00                	push   $0x0
f011307a:	68 00 00 00 40       	push   $0x40000000
f011307f:	ff 75 cc             	pushl  -0x34(%ebp)
f0113082:	e8 97 25 00 00       	call   f011561e <CCP>
f0113087:	83 c4 30             	add    $0x30,%esp
f011308a:	85 c0                	test   %eax,%eax
f011308c:	75 1e                	jne    f01130ac <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011308e:	83 ec 04             	sub    $0x4,%esp
f0113091:	68 f8 90 12 f0       	push   $0xf01290f8
f0113096:	68 93 04 00 00       	push   $0x493
f011309b:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01130a0:	e8 31 d4 fe ff       	call   f01004d6 <_warn>
f01130a5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01130a8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01130ac:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01130b0:	74 04                	je     f01130b6 <test_share_chunk+0x5ee>
f01130b2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01130b6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01130ba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01130bd:	89 d0                	mov    %edx,%eax
f01130bf:	01 c0                	add    %eax,%eax
f01130c1:	01 d0                	add    %edx,%eax
f01130c3:	c1 e0 02             	shl    $0x2,%eax
f01130c6:	f7 d8                	neg    %eax
f01130c8:	05 00 00 0a 00       	add    $0xa0000,%eax
f01130cd:	83 ec 08             	sub    $0x8,%esp
f01130d0:	6a 02                	push   $0x2
f01130d2:	6a 07                	push   $0x7
f01130d4:	6a 03                	push   $0x3
f01130d6:	6a 07                	push   $0x7
f01130d8:	6a 07                	push   $0x7
f01130da:	6a 02                	push   $0x2
f01130dc:	50                   	push   %eax
f01130dd:	68 00 30 00 00       	push   $0x3000
f01130e2:	68 00 30 00 40       	push   $0x40003000
f01130e7:	ff 75 cc             	pushl  -0x34(%ebp)
f01130ea:	e8 2f 25 00 00       	call   f011561e <CCP>
f01130ef:	83 c4 30             	add    $0x30,%esp
f01130f2:	85 c0                	test   %eax,%eax
f01130f4:	75 1e                	jne    f0113114 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01130f6:	83 ec 04             	sub    $0x4,%esp
f01130f9:	68 f8 90 12 f0       	push   $0xf01290f8
f01130fe:	68 9b 04 00 00       	push   $0x49b
f0113103:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113108:	e8 c9 d3 fe ff       	call   f01004d6 <_warn>
f011310d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113110:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113114:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113118:	74 04                	je     f011311e <test_share_chunk+0x656>
f011311a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011311e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113122:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113125:	c1 e0 02             	shl    $0x2,%eax
f0113128:	83 ec 08             	sub    $0x8,%esp
f011312b:	6a 02                	push   $0x2
f011312d:	6a 07                	push   $0x7
f011312f:	6a 03                	push   $0x3
f0113131:	6a 07                	push   $0x7
f0113133:	6a 07                	push   $0x7
f0113135:	6a 03                	push   $0x3
f0113137:	50                   	push   %eax
f0113138:	68 00 00 0a 00       	push   $0xa0000
f011313d:	68 00 00 0a 40       	push   $0x400a0000
f0113142:	ff 75 cc             	pushl  -0x34(%ebp)
f0113145:	e8 d4 24 00 00       	call   f011561e <CCP>
f011314a:	83 c4 30             	add    $0x30,%esp
f011314d:	85 c0                	test   %eax,%eax
f011314f:	75 1e                	jne    f011316f <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113151:	83 ec 04             	sub    $0x4,%esp
f0113154:	68 f8 90 12 f0       	push   $0xf01290f8
f0113159:	68 a3 04 00 00       	push   $0x4a3
f011315e:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113163:	e8 6e d3 fe ff       	call   f01004d6 <_warn>
f0113168:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011316b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011316f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113173:	74 04                	je     f0113179 <test_share_chunk+0x6b1>
f0113175:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113179:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011317d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0113181:	0f 84 92 00 00 00    	je     f0113219 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0113187:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f011318e:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0113195:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f011319c:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01131a3:	8b 45 98             	mov    -0x68(%ebp),%eax
f01131a6:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01131a9:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f01131b0:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01131b7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01131ba:	8a 00                	mov    (%eax),%al
f01131bc:	3c 41                	cmp    $0x41,%al
f01131be:	75 2d                	jne    f01131ed <test_share_chunk+0x725>
f01131c0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01131c3:	8a 00                	mov    (%eax),%al
f01131c5:	3c 41                	cmp    $0x41,%al
f01131c7:	75 24                	jne    f01131ed <test_share_chunk+0x725>
f01131c9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01131cc:	8a 00                	mov    (%eax),%al
f01131ce:	3c 41                	cmp    $0x41,%al
f01131d0:	75 1b                	jne    f01131ed <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01131d2:	8b 45 98             	mov    -0x68(%ebp),%eax
f01131d5:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01131d7:	3c 44                	cmp    $0x44,%al
f01131d9:	75 12                	jne    f01131ed <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01131db:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01131de:	8a 00                	mov    (%eax),%al
f01131e0:	3c 44                	cmp    $0x44,%al
f01131e2:	75 09                	jne    f01131ed <test_share_chunk+0x725>
f01131e4:	8b 45 90             	mov    -0x70(%ebp),%eax
f01131e7:	8a 00                	mov    (%eax),%al
f01131e9:	3c 44                	cmp    $0x44,%al
f01131eb:	74 1e                	je     f011320b <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01131ed:	83 ec 04             	sub    $0x4,%esp
f01131f0:	68 40 91 12 f0       	push   $0xf0129140
f01131f5:	68 b5 04 00 00       	push   $0x4b5
f01131fa:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01131ff:	e8 d2 d2 fe ff       	call   f01004d6 <_warn>
f0113204:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113207:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011320b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011320f:	74 04                	je     f0113215 <test_share_chunk+0x74d>
f0113211:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113215:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113219:	83 ec 0c             	sub    $0xc,%esp
f011321c:	68 b2 87 12 f0       	push   $0xf01287b2
f0113221:	e8 65 dd fe ff       	call   f0100f8b <cprintf>
f0113226:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0113229:	83 ec 0c             	sub    $0xc,%esp
f011322c:	68 4c 92 12 f0       	push   $0xf012924c
f0113231:	e8 55 dd fe ff       	call   f0100f8b <cprintf>
f0113236:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113239:	e8 be a4 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011323e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0113241:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113244:	89 d0                	mov    %edx,%eax
f0113246:	01 c0                	add    %eax,%eax
f0113248:	01 d0                	add    %edx,%eax
f011324a:	01 c0                	add    %eax,%eax
f011324c:	01 d0                	add    %edx,%eax
f011324e:	83 ec 0c             	sub    $0xc,%esp
f0113251:	6a 04                	push   $0x4
f0113253:	50                   	push   %eax
f0113254:	68 00 fc 3f 00       	push   $0x3ffc00
f0113259:	68 00 fc 09 00       	push   $0x9fc00
f011325e:	ff 75 cc             	pushl  -0x34(%ebp)
f0113261:	e8 85 69 ff ff       	call   f0109beb <share_chunk>
f0113266:	83 c4 20             	add    $0x20,%esp
f0113269:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011326c:	e8 8b a4 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113271:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0113274:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0113278:	75 0b                	jne    f0113285 <test_share_chunk+0x7bd>
f011327a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011327d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113280:	83 f8 01             	cmp    $0x1,%eax
f0113283:	74 28                	je     f01132ad <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113285:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113288:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011328b:	83 ec 0c             	sub    $0xc,%esp
f011328e:	50                   	push   %eax
f011328f:	ff 75 8c             	pushl  -0x74(%ebp)
f0113292:	68 c0 91 12 f0       	push   $0xf01291c0
f0113297:	68 cb 04 00 00       	push   $0x4cb
f011329c:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01132a1:	e8 30 d2 fe ff       	call   f01004d6 <_warn>
f01132a6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01132a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01132ad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01132b1:	74 04                	je     f01132b7 <test_share_chunk+0x7ef>
f01132b3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01132b7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01132bb:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01132c2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01132c5:	89 d0                	mov    %edx,%eax
f01132c7:	01 c0                	add    %eax,%eax
f01132c9:	01 d0                	add    %edx,%eax
f01132cb:	c1 e0 02             	shl    $0x2,%eax
f01132ce:	83 ec 08             	sub    $0x8,%esp
f01132d1:	6a 02                	push   $0x2
f01132d3:	6a 07                	push   $0x7
f01132d5:	6a 07                	push   $0x7
f01132d7:	6a 07                	push   $0x7
f01132d9:	6a 05                	push   $0x5
f01132db:	6a ff                	push   $0xffffffff
f01132dd:	50                   	push   %eax
f01132de:	68 00 f0 3f 00       	push   $0x3ff000
f01132e3:	68 00 f0 09 00       	push   $0x9f000
f01132e8:	ff 75 cc             	pushl  -0x34(%ebp)
f01132eb:	e8 2e 23 00 00       	call   f011561e <CCP>
f01132f0:	83 c4 30             	add    $0x30,%esp
f01132f3:	85 c0                	test   %eax,%eax
f01132f5:	75 25                	jne    f011331c <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01132f7:	83 ec 04             	sub    $0x4,%esp
f01132fa:	68 f8 90 12 f0       	push   $0xf01290f8
f01132ff:	68 d4 04 00 00       	push   $0x4d4
f0113304:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113309:	e8 c8 d1 fe ff       	call   f01004d6 <_warn>
f011330e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113311:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113315:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f011331c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113320:	74 04                	je     f0113326 <test_share_chunk+0x85e>
f0113322:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113326:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011332a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011332d:	c1 e0 02             	shl    $0x2,%eax
f0113330:	83 ec 08             	sub    $0x8,%esp
f0113333:	6a 02                	push   $0x2
f0113335:	6a 07                	push   $0x7
f0113337:	6a 07                	push   $0x7
f0113339:	6a 07                	push   $0x7
f011333b:	6a 05                	push   $0x5
f011333d:	6a 03                	push   $0x3
f011333f:	50                   	push   %eax
f0113340:	68 00 f0 3f 00       	push   $0x3ff000
f0113345:	68 00 f0 09 00       	push   $0x9f000
f011334a:	ff 75 cc             	pushl  -0x34(%ebp)
f011334d:	e8 cc 22 00 00       	call   f011561e <CCP>
f0113352:	83 c4 30             	add    $0x30,%esp
f0113355:	85 c0                	test   %eax,%eax
f0113357:	75 1e                	jne    f0113377 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113359:	83 ec 04             	sub    $0x4,%esp
f011335c:	68 f8 90 12 f0       	push   $0xf01290f8
f0113361:	68 dd 04 00 00       	push   $0x4dd
f0113366:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011336b:	e8 66 d1 fe ff       	call   f01004d6 <_warn>
f0113370:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113373:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113377:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011337b:	74 04                	je     f0113381 <test_share_chunk+0x8b9>
f011337d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113381:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0113385:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113388:	c1 e0 03             	shl    $0x3,%eax
f011338b:	83 ec 08             	sub    $0x8,%esp
f011338e:	6a 02                	push   $0x2
f0113390:	6a 07                	push   $0x7
f0113392:	6a 07                	push   $0x7
f0113394:	6a 07                	push   $0x7
f0113396:	6a 05                	push   $0x5
f0113398:	6a 04                	push   $0x4
f011339a:	50                   	push   %eax
f011339b:	68 00 00 40 00       	push   $0x400000
f01133a0:	68 00 00 0a 00       	push   $0xa0000
f01133a5:	ff 75 cc             	pushl  -0x34(%ebp)
f01133a8:	e8 71 22 00 00       	call   f011561e <CCP>
f01133ad:	83 c4 30             	add    $0x30,%esp
f01133b0:	85 c0                	test   %eax,%eax
f01133b2:	75 1e                	jne    f01133d2 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01133b4:	83 ec 04             	sub    $0x4,%esp
f01133b7:	68 f8 90 12 f0       	push   $0xf01290f8
f01133bc:	68 e5 04 00 00       	push   $0x4e5
f01133c1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01133c6:	e8 0b d1 fe ff       	call   f01004d6 <_warn>
f01133cb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01133ce:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01133d2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01133d6:	74 04                	je     f01133dc <test_share_chunk+0x914>
f01133d8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01133dc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01133e0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01133e4:	0f 84 b2 00 00 00    	je     f011349c <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01133ea:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01133f1:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01133f8:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01133ff:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0113406:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f011340d:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0113414:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f011341b:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0113422:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113425:	8a 00                	mov    (%eax),%al
f0113427:	3c 44                	cmp    $0x44,%al
f0113429:	75 45                	jne    f0113470 <test_share_chunk+0x9a8>
f011342b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011342e:	8a 00                	mov    (%eax),%al
f0113430:	3c 44                	cmp    $0x44,%al
f0113432:	75 3c                	jne    f0113470 <test_share_chunk+0x9a8>
f0113434:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113437:	8a 00                	mov    (%eax),%al
f0113439:	3c 44                	cmp    $0x44,%al
f011343b:	75 33                	jne    f0113470 <test_share_chunk+0x9a8>
f011343d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113440:	8a 00                	mov    (%eax),%al
f0113442:	3c 44                	cmp    $0x44,%al
f0113444:	75 2a                	jne    f0113470 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0113446:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113449:	8a 10                	mov    (%eax),%dl
f011344b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011344e:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0113450:	38 c2                	cmp    %al,%dl
f0113452:	75 1c                	jne    f0113470 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0113454:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113457:	8a 10                	mov    (%eax),%dl
f0113459:	8b 45 88             	mov    -0x78(%ebp),%eax
f011345c:	8a 00                	mov    (%eax),%al
f011345e:	38 c2                	cmp    %al,%dl
f0113460:	75 0e                	jne    f0113470 <test_share_chunk+0x9a8>
f0113462:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113465:	8a 10                	mov    (%eax),%dl
f0113467:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011346a:	8a 00                	mov    (%eax),%al
f011346c:	38 c2                	cmp    %al,%dl
f011346e:	74 1e                	je     f011348e <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113470:	83 ec 04             	sub    $0x4,%esp
f0113473:	68 40 91 12 f0       	push   $0xf0129140
f0113478:	68 fa 04 00 00       	push   $0x4fa
f011347d:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113482:	e8 4f d0 fe ff       	call   f01004d6 <_warn>
f0113487:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011348a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011348e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113492:	74 04                	je     f0113498 <test_share_chunk+0x9d0>
f0113494:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113498:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f011349c:	83 ec 0c             	sub    $0xc,%esp
f011349f:	68 84 92 12 f0       	push   $0xf0129284
f01134a4:	e8 e2 da fe ff       	call   f0100f8b <cprintf>
f01134a9:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f01134ac:	83 ec 08             	sub    $0x8,%esp
f01134af:	ff 75 e4             	pushl  -0x1c(%ebp)
f01134b2:	68 94 92 12 f0       	push   $0xf0129294
f01134b7:	e8 cf da fe ff       	call   f0100f8b <cprintf>
f01134bc:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01134bf:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01134c3:	75 10                	jne    f01134d5 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01134c5:	83 ec 0c             	sub    $0xc,%esp
f01134c8:	68 c4 92 12 f0       	push   $0xf01292c4
f01134cd:	e8 b9 da fe ff       	call   f0100f8b <cprintf>
f01134d2:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01134d5:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f01134da:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01134dd:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01134e0:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01134e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01134e8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01134eb:	5b                   	pop    %ebx
f01134ec:	5e                   	pop    %esi
f01134ed:	5f                   	pop    %edi
f01134ee:	5d                   	pop    %ebp
f01134ef:	c3                   	ret    

f01134f0 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01134f0:	55                   	push   %ebp
f01134f1:	89 e5                	mov    %esp,%ebp
f01134f3:	57                   	push   %edi
f01134f4:	56                   	push   %esi
f01134f5:	53                   	push   %ebx
f01134f6:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01134fc:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0113502:	bb c4 84 12 f0       	mov    $0xf01284c4,%ebx
f0113507:	ba 0f 00 00 00       	mov    $0xf,%edx
f011350c:	89 c7                	mov    %eax,%edi
f011350e:	89 de                	mov    %ebx,%esi
f0113510:	89 d1                	mov    %edx,%ecx
f0113512:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113514:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f011351a:	b9 23 00 00 00       	mov    $0x23,%ecx
f011351f:	b0 00                	mov    $0x0,%al
f0113521:	89 d7                	mov    %edx,%edi
f0113523:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113525:	6a 00                	push   $0x0
f0113527:	6a 0a                	push   $0xa
f0113529:	6a 14                	push   $0x14
f011352b:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0113531:	50                   	push   %eax
f0113532:	e8 2d 69 ff ff       	call   f0109e64 <env_create>
f0113537:	83 c4 10             	add    $0x10,%esp
f011353a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011353d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113540:	8b 40 64             	mov    0x64(%eax),%eax
f0113543:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113546:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113549:	8b 40 68             	mov    0x68(%eax),%eax
f011354c:	89 45 90             	mov    %eax,-0x70(%ebp)
f011354f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113552:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113555:	83 ec 0c             	sub    $0xc,%esp
f0113558:	ff 75 cc             	pushl  -0x34(%ebp)
f011355b:	e8 8a 20 00 00       	call   f01155ea <ClearUserSpace>
f0113560:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113563:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011356a:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0113571:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0113578:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f011357c:	83 ec 0c             	sub    $0xc,%esp
f011357f:	68 00 93 12 f0       	push   $0xf0129300
f0113584:	e8 02 da fe ff       	call   f0100f8b <cprintf>
f0113589:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f011358c:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0113593:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f011359a:	eb 03                	jmp    f011359f <test_allocate_chunk+0xaf>
f011359c:	ff 4d e4             	decl   -0x1c(%ebp)
f011359f:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01135a6:	76 09                	jbe    f01135b1 <test_allocate_chunk+0xc1>
f01135a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01135ab:	8a 00                	mov    (%eax),%al
f01135ad:	84 c0                	test   %al,%al
f01135af:	74 eb                	je     f011359c <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f01135b1:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01135b8:	75 06                	jne    f01135c0 <test_allocate_chunk+0xd0>
f01135ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01135bd:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01135c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01135c3:	8a 00                	mov    (%eax),%al
f01135c5:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01135cb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01135ce:	8a 00                	mov    (%eax),%al
f01135d0:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f01135d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01135d9:	8a 00                	mov    (%eax),%al
f01135db:	0f be c0             	movsbl %al,%eax
f01135de:	83 ec 08             	sub    $0x8,%esp
f01135e1:	50                   	push   %eax
f01135e2:	68 2a 93 12 f0       	push   $0xf012932a
f01135e7:	e8 9f d9 fe ff       	call   f0100f8b <cprintf>
f01135ec:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01135ef:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01135f2:	8a 00                	mov    (%eax),%al
f01135f4:	0f be c0             	movsbl %al,%eax
f01135f7:	83 ec 08             	sub    $0x8,%esp
f01135fa:	50                   	push   %eax
f01135fb:	68 36 93 12 f0       	push   $0xf0129336
f0113600:	e8 86 d9 fe ff       	call   f0100f8b <cprintf>
f0113605:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0113608:	83 ec 08             	sub    $0x8,%esp
f011360b:	68 00 f0 bf ef       	push   $0xefbff000
f0113610:	ff 75 cc             	pushl  -0x34(%ebp)
f0113613:	e8 b3 1f 00 00       	call   f01155cb <GP>
f0113618:	83 c4 10             	add    $0x10,%esp
f011361b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011361e:	e8 d9 a0 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113623:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0113626:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113629:	c1 e0 02             	shl    $0x2,%eax
f011362c:	6a 02                	push   $0x2
f011362e:	50                   	push   %eax
f011362f:	68 00 f0 bf ef       	push   $0xefbff000
f0113634:	ff 75 cc             	pushl  -0x34(%ebp)
f0113637:	e8 c9 65 ff ff       	call   f0109c05 <allocate_chunk>
f011363c:	83 c4 10             	add    $0x10,%esp
f011363f:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113642:	e8 b5 a0 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113647:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011364a:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f011364e:	75 08                	jne    f0113658 <test_allocate_chunk+0x168>
f0113650:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113653:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113656:	74 2a                	je     f0113682 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0113658:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011365b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011365e:	83 ec 08             	sub    $0x8,%esp
f0113661:	6a 00                	push   $0x0
f0113663:	50                   	push   %eax
f0113664:	ff 75 b0             	pushl  -0x50(%ebp)
f0113667:	68 44 93 12 f0       	push   $0xf0129344
f011366c:	68 3a 05 00 00       	push   $0x53a
f0113671:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113676:	e8 5b ce fe ff       	call   f01004d6 <_warn>
f011367b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011367e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113682:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113686:	74 04                	je     f011368c <test_allocate_chunk+0x19c>
f0113688:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011368c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113690:	e8 67 a0 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113695:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0113698:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011369b:	01 c0                	add    %eax,%eax
f011369d:	89 c1                	mov    %eax,%ecx
f011369f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01136a2:	89 d0                	mov    %edx,%eax
f01136a4:	c1 e0 02             	shl    $0x2,%eax
f01136a7:	01 d0                	add    %edx,%eax
f01136a9:	f7 d8                	neg    %eax
f01136ab:	2d 00 00 40 10       	sub    $0x10400000,%eax
f01136b0:	6a 02                	push   $0x2
f01136b2:	51                   	push   %ecx
f01136b3:	50                   	push   %eax
f01136b4:	ff 75 cc             	pushl  -0x34(%ebp)
f01136b7:	e8 49 65 ff ff       	call   f0109c05 <allocate_chunk>
f01136bc:	83 c4 10             	add    $0x10,%esp
f01136bf:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01136c2:	e8 35 a0 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01136c7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01136ca:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01136ce:	75 08                	jne    f01136d8 <test_allocate_chunk+0x1e8>
f01136d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01136d3:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01136d6:	74 2a                	je     f0113702 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01136d8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01136db:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01136de:	83 ec 08             	sub    $0x8,%esp
f01136e1:	6a 00                	push   $0x0
f01136e3:	50                   	push   %eax
f01136e4:	ff 75 b0             	pushl  -0x50(%ebp)
f01136e7:	68 44 93 12 f0       	push   $0xf0129344
f01136ec:	68 48 05 00 00       	push   $0x548
f01136f1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01136f6:	e8 db cd fe ff       	call   f01004d6 <_warn>
f01136fb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01136fe:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0113702:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113706:	74 04                	je     f011370c <test_allocate_chunk+0x21c>
f0113708:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011370c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0113710:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113713:	c1 e0 02             	shl    $0x2,%eax
f0113716:	83 ec 08             	sub    $0x8,%esp
f0113719:	6a 03                	push   $0x3
f011371b:	6a 00                	push   $0x0
f011371d:	6a 00                	push   $0x0
f011371f:	68 ff 0f 00 00       	push   $0xfff
f0113724:	ff 75 b8             	pushl  -0x48(%ebp)
f0113727:	6a 01                	push   $0x1
f0113729:	50                   	push   %eax
f011372a:	68 00 f0 bf ef       	push   $0xefbff000
f011372f:	6a 00                	push   $0x0
f0113731:	ff 75 cc             	pushl  -0x34(%ebp)
f0113734:	e8 e5 1e 00 00       	call   f011561e <CCP>
f0113739:	83 c4 30             	add    $0x30,%esp
f011373c:	85 c0                	test   %eax,%eax
f011373e:	75 1e                	jne    f011375e <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113740:	83 ec 04             	sub    $0x4,%esp
f0113743:	68 ac 93 12 f0       	push   $0xf01293ac
f0113748:	68 50 05 00 00       	push   $0x550
f011374d:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113752:	e8 7f cd fe ff       	call   f01004d6 <_warn>
f0113757:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011375a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011375e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113762:	74 04                	je     f0113768 <test_allocate_chunk+0x278>
f0113764:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113768:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f011376c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011376f:	8a 10                	mov    (%eax),%dl
f0113771:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0113777:	38 c2                	cmp    %al,%dl
f0113779:	75 0f                	jne    f011378a <test_allocate_chunk+0x29a>
f011377b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011377e:	8a 10                	mov    (%eax),%dl
f0113780:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0113786:	38 c2                	cmp    %al,%dl
f0113788:	74 1e                	je     f01137a8 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011378a:	83 ec 04             	sub    $0x4,%esp
f011378d:	68 f8 93 12 f0       	push   $0xf01293f8
f0113792:	68 58 05 00 00       	push   $0x558
f0113797:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011379c:	e8 35 cd fe ff       	call   f01004d6 <_warn>
f01137a1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01137a4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01137a8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01137ac:	74 04                	je     f01137b2 <test_allocate_chunk+0x2c2>
f01137ae:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01137b2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01137b6:	83 ec 0c             	sub    $0xc,%esp
f01137b9:	68 75 91 12 f0       	push   $0xf0129175
f01137be:	e8 c8 d7 fe ff       	call   f0100f8b <cprintf>
f01137c3:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f01137c6:	83 ec 0c             	sub    $0xc,%esp
f01137c9:	68 30 94 12 f0       	push   $0xf0129430
f01137ce:	e8 b8 d7 fe ff       	call   f0100f8b <cprintf>
f01137d3:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01137d6:	e8 21 9f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01137db:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01137de:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01137e1:	c1 e0 05             	shl    $0x5,%eax
f01137e4:	68 02 0e 00 00       	push   $0xe02
f01137e9:	50                   	push   %eax
f01137ea:	6a 00                	push   $0x0
f01137ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01137ef:	e8 11 64 ff ff       	call   f0109c05 <allocate_chunk>
f01137f4:	83 c4 10             	add    $0x10,%esp
f01137f7:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01137fa:	e8 fd 9e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01137ff:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0113802:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113806:	75 36                	jne    f011383e <test_allocate_chunk+0x34e>
f0113808:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011380b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011380e:	89 c1                	mov    %eax,%ecx
f0113810:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113813:	c1 e0 05             	shl    $0x5,%eax
f0113816:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113819:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113820:	99                   	cltd   
f0113821:	f7 fe                	idiv   %esi
f0113823:	89 c3                	mov    %eax,%ebx
f0113825:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113828:	c1 e0 05             	shl    $0x5,%eax
f011382b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011382e:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113835:	99                   	cltd   
f0113836:	f7 fe                	idiv   %esi
f0113838:	01 d8                	add    %ebx,%eax
f011383a:	39 c1                	cmp    %eax,%ecx
f011383c:	74 54                	je     f0113892 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f011383e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113841:	c1 e0 05             	shl    $0x5,%eax
f0113844:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113847:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011384e:	99                   	cltd   
f011384f:	f7 ff                	idiv   %edi
f0113851:	89 c1                	mov    %eax,%ecx
f0113853:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113856:	c1 e0 05             	shl    $0x5,%eax
f0113859:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011385c:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113863:	99                   	cltd   
f0113864:	f7 fe                	idiv   %esi
f0113866:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113869:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011386c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011386f:	83 ec 08             	sub    $0x8,%esp
f0113872:	52                   	push   %edx
f0113873:	50                   	push   %eax
f0113874:	ff 75 a8             	pushl  -0x58(%ebp)
f0113877:	68 70 94 12 f0       	push   $0xf0129470
f011387c:	68 6d 05 00 00       	push   $0x56d
f0113881:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113886:	e8 4b cc fe ff       	call   f01004d6 <_warn>
f011388b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011388e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113892:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113896:	74 04                	je     f011389c <test_allocate_chunk+0x3ac>
f0113898:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011389c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01138a0:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01138a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01138aa:	c1 e0 05             	shl    $0x5,%eax
f01138ad:	83 ec 08             	sub    $0x8,%esp
f01138b0:	6a 03                	push   $0x3
f01138b2:	6a 00                	push   $0x0
f01138b4:	6a 00                	push   $0x0
f01138b6:	68 07 0e 00 00       	push   $0xe07
f01138bb:	68 03 0e 00 00       	push   $0xe03
f01138c0:	6a 01                	push   $0x1
f01138c2:	50                   	push   %eax
f01138c3:	6a 00                	push   $0x0
f01138c5:	6a 00                	push   $0x0
f01138c7:	ff 75 cc             	pushl  -0x34(%ebp)
f01138ca:	e8 4f 1d 00 00       	call   f011561e <CCP>
f01138cf:	83 c4 30             	add    $0x30,%esp
f01138d2:	85 c0                	test   %eax,%eax
f01138d4:	75 25                	jne    f01138fb <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01138d6:	83 ec 04             	sub    $0x4,%esp
f01138d9:	68 ac 93 12 f0       	push   $0xf01293ac
f01138de:	68 76 05 00 00       	push   $0x576
f01138e3:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01138e8:	e8 e9 cb fe ff       	call   f01004d6 <_warn>
f01138ed:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01138f0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01138f4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f01138fb:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01138ff:	74 04                	je     f0113905 <test_allocate_chunk+0x415>
f0113901:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113905:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0113909:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011390d:	74 5a                	je     f0113969 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f011390f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113912:	01 c0                	add    %eax,%eax
f0113914:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0113917:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011391a:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f011391d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113920:	01 c0                	add    %eax,%eax
f0113922:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0113925:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113928:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011392b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011392e:	8a 00                	mov    (%eax),%al
f0113930:	3c 4b                	cmp    $0x4b,%al
f0113932:	75 09                	jne    f011393d <test_allocate_chunk+0x44d>
f0113934:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113937:	8a 00                	mov    (%eax),%al
f0113939:	3c 4d                	cmp    $0x4d,%al
f011393b:	74 1e                	je     f011395b <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011393d:	83 ec 04             	sub    $0x4,%esp
f0113940:	68 f8 93 12 f0       	push   $0xf01293f8
f0113945:	68 84 05 00 00       	push   $0x584
f011394a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011394f:	e8 82 cb fe ff       	call   f01004d6 <_warn>
f0113954:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113957:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f011395b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011395f:	74 04                	je     f0113965 <test_allocate_chunk+0x475>
f0113961:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0113965:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113969:	83 ec 0c             	sub    $0xc,%esp
f011396c:	68 4f 87 12 f0       	push   $0xf012874f
f0113971:	e8 15 d6 fe ff       	call   f0100f8b <cprintf>
f0113976:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0113979:	83 ec 0c             	sub    $0xc,%esp
f011397c:	68 d0 94 12 f0       	push   $0xf01294d0
f0113981:	e8 05 d6 fe ff       	call   f0100f8b <cprintf>
f0113986:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113989:	e8 6e 9d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011398e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0113991:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113994:	c1 e0 06             	shl    $0x6,%eax
f0113997:	89 c2                	mov    %eax,%edx
f0113999:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011399c:	c1 e0 05             	shl    $0x5,%eax
f011399f:	6a 00                	push   $0x0
f01139a1:	52                   	push   %edx
f01139a2:	50                   	push   %eax
f01139a3:	ff 75 cc             	pushl  -0x34(%ebp)
f01139a6:	e8 5a 62 ff ff       	call   f0109c05 <allocate_chunk>
f01139ab:	83 c4 10             	add    $0x10,%esp
f01139ae:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01139b1:	e8 46 9d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01139b6:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f01139b9:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f01139bd:	75 36                	jne    f01139f5 <test_allocate_chunk+0x505>
f01139bf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139c2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01139c5:	89 c1                	mov    %eax,%ecx
f01139c7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01139ca:	c1 e0 06             	shl    $0x6,%eax
f01139cd:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01139d0:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01139d7:	99                   	cltd   
f01139d8:	f7 ff                	idiv   %edi
f01139da:	89 c3                	mov    %eax,%ebx
f01139dc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01139df:	c1 e0 06             	shl    $0x6,%eax
f01139e2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01139e5:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01139ec:	99                   	cltd   
f01139ed:	f7 fe                	idiv   %esi
f01139ef:	01 d8                	add    %ebx,%eax
f01139f1:	39 c1                	cmp    %eax,%ecx
f01139f3:	74 54                	je     f0113a49 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f01139f5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01139f8:	c1 e0 06             	shl    $0x6,%eax
f01139fb:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01139fe:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113a05:	99                   	cltd   
f0113a06:	f7 fb                	idiv   %ebx
f0113a08:	89 c1                	mov    %eax,%ecx
f0113a0a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113a0d:	c1 e0 06             	shl    $0x6,%eax
f0113a10:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113a13:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113a1a:	99                   	cltd   
f0113a1b:	f7 ff                	idiv   %edi
f0113a1d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113a20:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a23:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113a26:	83 ec 08             	sub    $0x8,%esp
f0113a29:	52                   	push   %edx
f0113a2a:	50                   	push   %eax
f0113a2b:	ff 75 a4             	pushl  -0x5c(%ebp)
f0113a2e:	68 70 94 12 f0       	push   $0xf0129470
f0113a33:	68 9a 05 00 00       	push   $0x59a
f0113a38:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113a3d:	e8 94 ca fe ff       	call   f01004d6 <_warn>
f0113a42:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113a45:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113a49:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113a4d:	74 04                	je     f0113a53 <test_allocate_chunk+0x563>
f0113a4f:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113a53:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113a57:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113a5e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113a61:	c1 e0 06             	shl    $0x6,%eax
f0113a64:	89 c2                	mov    %eax,%edx
f0113a66:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113a69:	c1 e0 05             	shl    $0x5,%eax
f0113a6c:	83 ec 08             	sub    $0x8,%esp
f0113a6f:	6a 03                	push   $0x3
f0113a71:	6a 00                	push   $0x0
f0113a73:	6a 00                	push   $0x0
f0113a75:	68 07 0e 00 00       	push   $0xe07
f0113a7a:	6a 01                	push   $0x1
f0113a7c:	6a 01                	push   $0x1
f0113a7e:	52                   	push   %edx
f0113a7f:	50                   	push   %eax
f0113a80:	6a 00                	push   $0x0
f0113a82:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a85:	e8 94 1b 00 00       	call   f011561e <CCP>
f0113a8a:	83 c4 30             	add    $0x30,%esp
f0113a8d:	85 c0                	test   %eax,%eax
f0113a8f:	75 25                	jne    f0113ab6 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113a91:	83 ec 04             	sub    $0x4,%esp
f0113a94:	68 ac 93 12 f0       	push   $0xf01293ac
f0113a99:	68 a3 05 00 00       	push   $0x5a3
f0113a9e:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113aa3:	e8 2e ca fe ff       	call   f01004d6 <_warn>
f0113aa8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113aab:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113aaf:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0113ab6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113aba:	74 04                	je     f0113ac0 <test_allocate_chunk+0x5d0>
f0113abc:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113ac0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0113ac4:	83 ec 0c             	sub    $0xc,%esp
f0113ac7:	68 b2 87 12 f0       	push   $0xf01287b2
f0113acc:	e8 ba d4 fe ff       	call   f0100f8b <cprintf>
f0113ad1:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0113ad4:	83 ec 0c             	sub    $0xc,%esp
f0113ad7:	68 10 95 12 f0       	push   $0xf0129510
f0113adc:	e8 aa d4 fe ff       	call   f0100f8b <cprintf>
f0113ae1:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ae4:	e8 13 9c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113ae9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0113aec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113aef:	c1 e0 06             	shl    $0x6,%eax
f0113af2:	68 06 0e 00 00       	push   $0xe06
f0113af7:	50                   	push   %eax
f0113af8:	68 00 00 00 80       	push   $0x80000000
f0113afd:	ff 75 cc             	pushl  -0x34(%ebp)
f0113b00:	e8 00 61 ff ff       	call   f0109c05 <allocate_chunk>
f0113b05:	83 c4 10             	add    $0x10,%esp
f0113b08:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b0b:	e8 ec 9b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113b10:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0113b13:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0113b17:	75 36                	jne    f0113b4f <test_allocate_chunk+0x65f>
f0113b19:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b1c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b1f:	89 c1                	mov    %eax,%ecx
f0113b21:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b24:	c1 e0 06             	shl    $0x6,%eax
f0113b27:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b2a:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113b31:	99                   	cltd   
f0113b32:	f7 fb                	idiv   %ebx
f0113b34:	89 c3                	mov    %eax,%ebx
f0113b36:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b39:	c1 e0 06             	shl    $0x6,%eax
f0113b3c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b3f:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113b46:	99                   	cltd   
f0113b47:	f7 fe                	idiv   %esi
f0113b49:	01 d8                	add    %ebx,%eax
f0113b4b:	39 c1                	cmp    %eax,%ecx
f0113b4d:	74 54                	je     f0113ba3 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0113b4f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b52:	c1 e0 06             	shl    $0x6,%eax
f0113b55:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b58:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113b5f:	99                   	cltd   
f0113b60:	f7 ff                	idiv   %edi
f0113b62:	89 c1                	mov    %eax,%ecx
f0113b64:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b67:	c1 e0 06             	shl    $0x6,%eax
f0113b6a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b6d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113b74:	99                   	cltd   
f0113b75:	f7 fb                	idiv   %ebx
f0113b77:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113b7a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b7d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b80:	83 ec 08             	sub    $0x8,%esp
f0113b83:	52                   	push   %edx
f0113b84:	50                   	push   %eax
f0113b85:	ff 75 9c             	pushl  -0x64(%ebp)
f0113b88:	68 70 94 12 f0       	push   $0xf0129470
f0113b8d:	68 b9 05 00 00       	push   $0x5b9
f0113b92:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113b97:	e8 3a c9 fe ff       	call   f01004d6 <_warn>
f0113b9c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b9f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113ba3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113ba7:	74 04                	je     f0113bad <test_allocate_chunk+0x6bd>
f0113ba9:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113bad:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113bb1:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113bb8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113bbb:	c1 e0 06             	shl    $0x6,%eax
f0113bbe:	83 ec 08             	sub    $0x8,%esp
f0113bc1:	6a 03                	push   $0x3
f0113bc3:	6a 00                	push   $0x0
f0113bc5:	6a 00                	push   $0x0
f0113bc7:	68 07 0e 00 00       	push   $0xe07
f0113bcc:	68 07 0e 00 00       	push   $0xe07
f0113bd1:	6a 01                	push   $0x1
f0113bd3:	50                   	push   %eax
f0113bd4:	68 00 00 00 80       	push   $0x80000000
f0113bd9:	6a 00                	push   $0x0
f0113bdb:	ff 75 cc             	pushl  -0x34(%ebp)
f0113bde:	e8 3b 1a 00 00       	call   f011561e <CCP>
f0113be3:	83 c4 30             	add    $0x30,%esp
f0113be6:	85 c0                	test   %eax,%eax
f0113be8:	75 25                	jne    f0113c0f <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113bea:	83 ec 04             	sub    $0x4,%esp
f0113bed:	68 ac 93 12 f0       	push   $0xf01293ac
f0113bf2:	68 c2 05 00 00       	push   $0x5c2
f0113bf7:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113bfc:	e8 d5 c8 fe ff       	call   f01004d6 <_warn>
f0113c01:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c04:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113c08:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0113c0f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113c13:	74 04                	je     f0113c19 <test_allocate_chunk+0x729>
f0113c15:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113c19:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0113c1d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0113c21:	74 6f                	je     f0113c92 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0113c23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113c26:	01 c0                	add    %eax,%eax
f0113c28:	05 00 00 00 80       	add    $0x80000000,%eax
f0113c2d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0113c30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113c33:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0113c36:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113c39:	89 d0                	mov    %edx,%eax
f0113c3b:	c1 e0 02             	shl    $0x2,%eax
f0113c3e:	01 d0                	add    %edx,%eax
f0113c40:	01 c0                	add    %eax,%eax
f0113c42:	01 d0                	add    %edx,%eax
f0113c44:	01 c0                	add    %eax,%eax
f0113c46:	05 00 00 00 80       	add    $0x80000000,%eax
f0113c4b:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0113c4e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c51:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0113c54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113c57:	8a 00                	mov    (%eax),%al
f0113c59:	3c 4b                	cmp    $0x4b,%al
f0113c5b:	75 09                	jne    f0113c66 <test_allocate_chunk+0x776>
f0113c5d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c60:	8a 00                	mov    (%eax),%al
f0113c62:	3c 4d                	cmp    $0x4d,%al
f0113c64:	74 1e                	je     f0113c84 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113c66:	83 ec 04             	sub    $0x4,%esp
f0113c69:	68 f8 93 12 f0       	push   $0xf01293f8
f0113c6e:	68 d0 05 00 00       	push   $0x5d0
f0113c73:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113c78:	e8 59 c8 fe ff       	call   f01004d6 <_warn>
f0113c7d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113c80:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0113c84:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113c88:	74 04                	je     f0113c8e <test_allocate_chunk+0x79e>
f0113c8a:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0113c8e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0113c92:	83 ec 0c             	sub    $0xc,%esp
f0113c95:	68 84 92 12 f0       	push   $0xf0129284
f0113c9a:	e8 ec d2 fe ff       	call   f0100f8b <cprintf>
f0113c9f:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0113ca2:	83 ec 0c             	sub    $0xc,%esp
f0113ca5:	68 4c 95 12 f0       	push   $0xf012954c
f0113caa:	e8 dc d2 fe ff       	call   f0100f8b <cprintf>
f0113caf:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113cb2:	e8 45 9a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113cb7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0113cba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113cbd:	89 d0                	mov    %edx,%eax
f0113cbf:	01 c0                	add    %eax,%eax
f0113cc1:	01 d0                	add    %edx,%eax
f0113cc3:	01 c0                	add    %eax,%eax
f0113cc5:	01 d0                	add    %edx,%eax
f0113cc7:	68 04 0e 00 00       	push   $0xe04
f0113ccc:	50                   	push   %eax
f0113ccd:	68 00 fc 3f 40       	push   $0x403ffc00
f0113cd2:	ff 75 cc             	pushl  -0x34(%ebp)
f0113cd5:	e8 2b 5f ff ff       	call   f0109c05 <allocate_chunk>
f0113cda:	83 c4 10             	add    $0x10,%esp
f0113cdd:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ce0:	e8 17 9a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0113ce5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0113ce8:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0113cec:	75 0b                	jne    f0113cf9 <test_allocate_chunk+0x809>
f0113cee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113cf1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113cf4:	83 f8 05             	cmp    $0x5,%eax
f0113cf7:	74 2a                	je     f0113d23 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0113cf9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113cfc:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113cff:	83 ec 08             	sub    $0x8,%esp
f0113d02:	6a 05                	push   $0x5
f0113d04:	50                   	push   %eax
f0113d05:	ff 75 98             	pushl  -0x68(%ebp)
f0113d08:	68 70 94 12 f0       	push   $0xf0129470
f0113d0d:	68 e7 05 00 00       	push   $0x5e7
f0113d12:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113d17:	e8 ba c7 fe ff       	call   f01004d6 <_warn>
f0113d1c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113d1f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0113d23:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113d27:	74 04                	je     f0113d2d <test_allocate_chunk+0x83d>
f0113d29:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113d2d:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113d31:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113d38:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d3b:	89 d0                	mov    %edx,%eax
f0113d3d:	01 c0                	add    %eax,%eax
f0113d3f:	01 d0                	add    %edx,%eax
f0113d41:	c1 e0 02             	shl    $0x2,%eax
f0113d44:	83 ec 08             	sub    $0x8,%esp
f0113d47:	6a 03                	push   $0x3
f0113d49:	6a 00                	push   $0x0
f0113d4b:	6a 00                	push   $0x0
f0113d4d:	68 07 0e 00 00       	push   $0xe07
f0113d52:	68 05 0e 00 00       	push   $0xe05
f0113d57:	6a 01                	push   $0x1
f0113d59:	50                   	push   %eax
f0113d5a:	68 00 f0 3f 40       	push   $0x403ff000
f0113d5f:	6a 00                	push   $0x0
f0113d61:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d64:	e8 b5 18 00 00       	call   f011561e <CCP>
f0113d69:	83 c4 30             	add    $0x30,%esp
f0113d6c:	85 c0                	test   %eax,%eax
f0113d6e:	75 25                	jne    f0113d95 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113d70:	83 ec 04             	sub    $0x4,%esp
f0113d73:	68 ac 93 12 f0       	push   $0xf01293ac
f0113d78:	68 f0 05 00 00       	push   $0x5f0
f0113d7d:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113d82:	e8 4f c7 fe ff       	call   f01004d6 <_warn>
f0113d87:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d8a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113d8e:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0113d95:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113d99:	74 04                	je     f0113d9f <test_allocate_chunk+0x8af>
f0113d9b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113d9f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0113da3:	83 ec 0c             	sub    $0xc,%esp
f0113da6:	68 83 95 12 f0       	push   $0xf0129583
f0113dab:	e8 db d1 fe ff       	call   f0100f8b <cprintf>
f0113db0:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0113db3:	83 ec 08             	sub    $0x8,%esp
f0113db6:	ff 75 e0             	pushl  -0x20(%ebp)
f0113db9:	68 94 95 12 f0       	push   $0xf0129594
f0113dbe:	e8 c8 d1 fe ff       	call   f0100f8b <cprintf>
f0113dc3:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113dc6:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0113dca:	75 10                	jne    f0113ddc <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0113dcc:	83 ec 0c             	sub    $0xc,%esp
f0113dcf:	68 c8 95 12 f0       	push   $0xf01295c8
f0113dd4:	e8 b2 d1 fe ff       	call   f0100f8b <cprintf>
f0113dd9:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113ddc:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f0113de1:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0113de4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0113de7:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113dea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113def:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113df2:	5b                   	pop    %ebx
f0113df3:	5e                   	pop    %esi
f0113df4:	5f                   	pop    %edi
f0113df5:	5d                   	pop    %ebp
f0113df6:	c3                   	ret    

f0113df7 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0113df7:	55                   	push   %ebp
f0113df8:	89 e5                	mov    %esp,%ebp
f0113dfa:	57                   	push   %edi
f0113dfb:	56                   	push   %esi
f0113dfc:	53                   	push   %ebx
f0113dfd:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113e03:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0113e06:	bb c4 84 12 f0       	mov    $0xf01284c4,%ebx
f0113e0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113e10:	89 c7                	mov    %eax,%edi
f0113e12:	89 de                	mov    %ebx,%esi
f0113e14:	89 d1                	mov    %edx,%ecx
f0113e16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113e18:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0113e1b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113e20:	b0 00                	mov    $0x0,%al
f0113e22:	89 d7                	mov    %edx,%edi
f0113e24:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113e26:	6a 00                	push   $0x0
f0113e28:	6a 0a                	push   $0xa
f0113e2a:	6a 14                	push   $0x14
f0113e2c:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0113e2f:	50                   	push   %eax
f0113e30:	e8 2f 60 ff ff       	call   f0109e64 <env_create>
f0113e35:	83 c4 10             	add    $0x10,%esp
f0113e38:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113e3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113e3e:	8b 40 64             	mov    0x64(%eax),%eax
f0113e41:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0113e44:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113e47:	8b 40 68             	mov    0x68(%eax),%eax
f0113e4a:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0113e4d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e50:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0113e53:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0113e5a:	75 70 20 
f0113e5d:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0113e64:	00 00 00 
f0113e67:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0113e6a:	b9 03 00 00 00       	mov    $0x3,%ecx
f0113e6f:	b8 00 00 00 00       	mov    $0x0,%eax
f0113e74:	89 d7                	mov    %edx,%edi
f0113e76:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0113e78:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113e7b:	8b 40 10             	mov    0x10(%eax),%eax
f0113e7e:	83 ec 08             	sub    $0x8,%esp
f0113e81:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0113e87:	52                   	push   %edx
f0113e88:	50                   	push   %eax
f0113e89:	e8 07 ae 00 00       	call   f011ec95 <ltostr>
f0113e8e:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0113e91:	83 ec 04             	sub    $0x4,%esp
f0113e94:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0113e9a:	50                   	push   %eax
f0113e9b:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0113ea1:	50                   	push   %eax
f0113ea2:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0113ea8:	50                   	push   %eax
f0113ea9:	e8 c0 ae 00 00       	call   f011ed6e <strcconcat>
f0113eae:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113eb1:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0113eb8:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0113ebf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0113ec6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0113ecd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0113ed1:	83 ec 0c             	sub    $0xc,%esp
f0113ed4:	ff 75 d8             	pushl  -0x28(%ebp)
f0113ed7:	e8 0e 17 00 00       	call   f01155ea <ClearUserSpace>
f0113edc:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0113edf:	83 ec 0c             	sub    $0xc,%esp
f0113ee2:	68 08 96 12 f0       	push   $0xf0129608
f0113ee7:	e8 9f d0 fe ff       	call   f0100f8b <cprintf>
f0113eec:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0113eef:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113ef2:	c1 e0 03             	shl    $0x3,%eax
f0113ef5:	83 ec 04             	sub    $0x4,%esp
f0113ef8:	50                   	push   %eax
f0113ef9:	6a 00                	push   $0x0
f0113efb:	ff 75 d8             	pushl  -0x28(%ebp)
f0113efe:	e8 36 5d ff ff       	call   f0109c39 <calculate_required_frames>
f0113f03:	83 c4 10             	add    $0x10,%esp
f0113f06:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0113f09:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0113f0d:	74 23                	je     f0113f32 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0113f0f:	83 ec 0c             	sub    $0xc,%esp
f0113f12:	6a 03                	push   $0x3
f0113f14:	ff 75 c8             	pushl  -0x38(%ebp)
f0113f17:	68 3c 96 12 f0       	push   $0xf012963c
f0113f1c:	68 29 06 00 00       	push   $0x629
f0113f21:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113f26:	e8 ab c5 fe ff       	call   f01004d6 <_warn>
f0113f2b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f2e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113f32:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f36:	74 04                	je     f0113f3c <test_calculate_required_frames+0x145>
f0113f38:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f3c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0113f40:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0113f43:	c1 e0 02             	shl    $0x2,%eax
f0113f46:	83 ec 04             	sub    $0x4,%esp
f0113f49:	50                   	push   %eax
f0113f4a:	6a 00                	push   $0x0
f0113f4c:	ff 75 d8             	pushl  -0x28(%ebp)
f0113f4f:	e8 e5 5c ff ff       	call   f0109c39 <calculate_required_frames>
f0113f54:	83 c4 10             	add    $0x10,%esp
f0113f57:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0113f5a:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0113f61:	74 26                	je     f0113f89 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0113f63:	83 ec 0c             	sub    $0xc,%esp
f0113f66:	68 01 04 00 00       	push   $0x401
f0113f6b:	ff 75 c8             	pushl  -0x38(%ebp)
f0113f6e:	68 3c 96 12 f0       	push   $0xf012963c
f0113f73:	68 33 06 00 00       	push   $0x633
f0113f78:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0113f7d:	e8 54 c5 fe ff       	call   f01004d6 <_warn>
f0113f82:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f85:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113f89:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f8d:	74 04                	je     f0113f93 <test_calculate_required_frames+0x19c>
f0113f8f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f93:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0113f97:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0113f9a:	c1 e0 0a             	shl    $0xa,%eax
f0113f9d:	83 ec 04             	sub    $0x4,%esp
f0113fa0:	50                   	push   %eax
f0113fa1:	6a 00                	push   $0x0
f0113fa3:	ff 75 d8             	pushl  -0x28(%ebp)
f0113fa6:	e8 8e 5c ff ff       	call   f0109c39 <calculate_required_frames>
f0113fab:	83 c4 10             	add    $0x10,%esp
f0113fae:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0113fb1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0113fb4:	c1 e0 0a             	shl    $0xa,%eax
f0113fb7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0113fba:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113fc1:	99                   	cltd   
f0113fc2:	f7 fb                	idiv   %ebx
f0113fc4:	89 c1                	mov    %eax,%ecx
f0113fc6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0113fc9:	c1 e0 0a             	shl    $0xa,%eax
f0113fcc:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0113fcf:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113fd6:	99                   	cltd   
f0113fd7:	f7 fe                	idiv   %esi
f0113fd9:	01 c8                	add    %ecx,%eax
f0113fdb:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0113fde:	74 4c                	je     f011402c <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0113fe0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0113fe3:	c1 e0 0a             	shl    $0xa,%eax
f0113fe6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0113fe9:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113ff0:	99                   	cltd   
f0113ff1:	f7 fb                	idiv   %ebx
f0113ff3:	89 c1                	mov    %eax,%ecx
f0113ff5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0113ff8:	c1 e0 0a             	shl    $0xa,%eax
f0113ffb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0113ffe:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114005:	99                   	cltd   
f0114006:	f7 fe                	idiv   %esi
f0114008:	01 c8                	add    %ecx,%eax
f011400a:	83 ec 0c             	sub    $0xc,%esp
f011400d:	50                   	push   %eax
f011400e:	ff 75 c8             	pushl  -0x38(%ebp)
f0114011:	68 3c 96 12 f0       	push   $0xf012963c
f0114016:	68 3d 06 00 00       	push   $0x63d
f011401b:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114020:	e8 b1 c4 fe ff       	call   f01004d6 <_warn>
f0114025:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114028:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011402c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114030:	74 04                	je     f0114036 <test_calculate_required_frames+0x23f>
f0114032:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114036:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f011403a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011403d:	89 d0                	mov    %edx,%eax
f011403f:	01 c0                	add    %eax,%eax
f0114041:	01 d0                	add    %edx,%eax
f0114043:	01 c0                	add    %eax,%eax
f0114045:	83 ec 04             	sub    $0x4,%esp
f0114048:	50                   	push   %eax
f0114049:	68 00 10 00 00       	push   $0x1000
f011404e:	ff 75 d8             	pushl  -0x28(%ebp)
f0114051:	e8 e3 5b ff ff       	call   f0109c39 <calculate_required_frames>
f0114056:	83 c4 10             	add    $0x10,%esp
f0114059:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011405c:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114060:	74 23                	je     f0114085 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114062:	83 ec 0c             	sub    $0xc,%esp
f0114065:	6a 03                	push   $0x3
f0114067:	ff 75 c8             	pushl  -0x38(%ebp)
f011406a:	68 3c 96 12 f0       	push   $0xf012963c
f011406f:	68 49 06 00 00       	push   $0x649
f0114074:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114079:	e8 58 c4 fe ff       	call   f01004d6 <_warn>
f011407e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114081:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114085:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114089:	74 04                	je     f011408f <test_calculate_required_frames+0x298>
f011408b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011408f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0114093:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114096:	89 c2                	mov    %eax,%edx
f0114098:	01 d2                	add    %edx,%edx
f011409a:	01 d0                	add    %edx,%eax
f011409c:	83 ec 04             	sub    $0x4,%esp
f011409f:	50                   	push   %eax
f01140a0:	68 00 18 00 00       	push   $0x1800
f01140a5:	ff 75 d8             	pushl  -0x28(%ebp)
f01140a8:	e8 8c 5b ff ff       	call   f0109c39 <calculate_required_frames>
f01140ad:	83 c4 10             	add    $0x10,%esp
f01140b0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01140b3:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01140b7:	74 23                	je     f01140dc <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01140b9:	83 ec 0c             	sub    $0xc,%esp
f01140bc:	6a 03                	push   $0x3
f01140be:	ff 75 c8             	pushl  -0x38(%ebp)
f01140c1:	68 3c 96 12 f0       	push   $0xf012963c
f01140c6:	68 53 06 00 00       	push   $0x653
f01140cb:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01140d0:	e8 01 c4 fe ff       	call   f01004d6 <_warn>
f01140d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01140d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01140dc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140e0:	74 04                	je     f01140e6 <test_calculate_required_frames+0x2ef>
f01140e2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01140e6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01140ea:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01140ed:	89 d0                	mov    %edx,%eax
f01140ef:	c1 e0 02             	shl    $0x2,%eax
f01140f2:	01 d0                	add    %edx,%eax
f01140f4:	01 c0                	add    %eax,%eax
f01140f6:	83 ec 04             	sub    $0x4,%esp
f01140f9:	50                   	push   %eax
f01140fa:	68 00 00 40 00       	push   $0x400000
f01140ff:	ff 75 d8             	pushl  -0x28(%ebp)
f0114102:	e8 32 5b ff ff       	call   f0109c39 <calculate_required_frames>
f0114107:	83 c4 10             	add    $0x10,%esp
f011410a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f011410d:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0114114:	74 26                	je     f011413c <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0114116:	83 ec 0c             	sub    $0xc,%esp
f0114119:	68 03 0a 00 00       	push   $0xa03
f011411e:	ff 75 c8             	pushl  -0x38(%ebp)
f0114121:	68 3c 96 12 f0       	push   $0xf012963c
f0114126:	68 5d 06 00 00       	push   $0x65d
f011412b:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114130:	e8 a1 c3 fe ff       	call   f01004d6 <_warn>
f0114135:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114138:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011413c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114140:	74 04                	je     f0114146 <test_calculate_required_frames+0x34f>
f0114142:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114146:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011414a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011414d:	01 c0                	add    %eax,%eax
f011414f:	83 ec 04             	sub    $0x4,%esp
f0114152:	50                   	push   %eax
f0114153:	68 00 00 70 00       	push   $0x700000
f0114158:	ff 75 d8             	pushl  -0x28(%ebp)
f011415b:	e8 d9 5a ff ff       	call   f0109c39 <calculate_required_frames>
f0114160:	83 c4 10             	add    $0x10,%esp
f0114163:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0114166:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f011416d:	74 26                	je     f0114195 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f011416f:	83 ec 0c             	sub    $0xc,%esp
f0114172:	68 02 02 00 00       	push   $0x202
f0114177:	ff 75 c8             	pushl  -0x38(%ebp)
f011417a:	68 3c 96 12 f0       	push   $0xf012963c
f011417f:	68 69 06 00 00       	push   $0x669
f0114184:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114189:	e8 48 c3 fe ff       	call   f01004d6 <_warn>
f011418e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114191:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114195:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114199:	74 04                	je     f011419f <test_calculate_required_frames+0x3a8>
f011419b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011419f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01141a3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01141a6:	83 ec 04             	sub    $0x4,%esp
f01141a9:	50                   	push   %eax
f01141aa:	68 ff ff 3f 00       	push   $0x3fffff
f01141af:	ff 75 d8             	pushl  -0x28(%ebp)
f01141b2:	e8 82 5a ff ff       	call   f0109c39 <calculate_required_frames>
f01141b7:	83 c4 10             	add    $0x10,%esp
f01141ba:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f01141bd:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01141c1:	74 23                	je     f01141e6 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01141c3:	83 ec 0c             	sub    $0xc,%esp
f01141c6:	6a 04                	push   $0x4
f01141c8:	ff 75 c8             	pushl  -0x38(%ebp)
f01141cb:	68 3c 96 12 f0       	push   $0xf012963c
f01141d0:	68 73 06 00 00       	push   $0x673
f01141d5:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01141da:	e8 f7 c2 fe ff       	call   f01004d6 <_warn>
f01141df:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01141e2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01141e6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01141ea:	74 04                	je     f01141f0 <test_calculate_required_frames+0x3f9>
f01141ec:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01141f0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01141f4:	83 ec 0c             	sub    $0xc,%esp
f01141f7:	68 75 91 12 f0       	push   $0xf0129175
f01141fc:	e8 8a cd fe ff       	call   f0100f8b <cprintf>
f0114201:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0114204:	83 ec 0c             	sub    $0xc,%esp
f0114207:	68 94 96 12 f0       	push   $0xf0129694
f011420c:	e8 7a cd fe ff       	call   f0100f8b <cprintf>
f0114211:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114214:	83 ec 04             	sub    $0x4,%esp
f0114217:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011421d:	50                   	push   %eax
f011421e:	68 2e 85 12 f0       	push   $0xf012852e
f0114223:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114229:	50                   	push   %eax
f011422a:	e8 3f ab 00 00       	call   f011ed6e <strcconcat>
f011422f:	83 c4 10             	add    $0x10,%esp
f0114232:	83 ec 0c             	sub    $0xc,%esp
f0114235:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011423b:	50                   	push   %eax
f011423c:	e8 ba dc fe ff       	call   f0101efb <execute_command>
f0114241:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114244:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114247:	c1 e0 03             	shl    $0x3,%eax
f011424a:	83 ec 04             	sub    $0x4,%esp
f011424d:	50                   	push   %eax
f011424e:	6a 00                	push   $0x0
f0114250:	ff 75 d8             	pushl  -0x28(%ebp)
f0114253:	e8 e1 59 ff ff       	call   f0109c39 <calculate_required_frames>
f0114258:	83 c4 10             	add    $0x10,%esp
f011425b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011425e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0114265:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114268:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011426b:	74 24                	je     f0114291 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011426d:	83 ec 0c             	sub    $0xc,%esp
f0114270:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114273:	ff 75 c8             	pushl  -0x38(%ebp)
f0114276:	68 3c 96 12 f0       	push   $0xf012963c
f011427b:	68 87 06 00 00       	push   $0x687
f0114280:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114285:	e8 4c c2 fe ff       	call   f01004d6 <_warn>
f011428a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011428d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114291:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114295:	74 04                	je     f011429b <test_calculate_required_frames+0x4a4>
f0114297:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011429b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f011429f:	83 ec 04             	sub    $0x4,%esp
f01142a2:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01142a8:	50                   	push   %eax
f01142a9:	68 3b 85 12 f0       	push   $0xf012853b
f01142ae:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01142b4:	50                   	push   %eax
f01142b5:	e8 b4 aa 00 00       	call   f011ed6e <strcconcat>
f01142ba:	83 c4 10             	add    $0x10,%esp
f01142bd:	83 ec 0c             	sub    $0xc,%esp
f01142c0:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01142c6:	50                   	push   %eax
f01142c7:	e8 2f dc fe ff       	call   f0101efb <execute_command>
f01142cc:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01142cf:	83 ec 04             	sub    $0x4,%esp
f01142d2:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01142d8:	50                   	push   %eax
f01142d9:	68 c8 96 12 f0       	push   $0xf01296c8
f01142de:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01142e4:	50                   	push   %eax
f01142e5:	e8 84 aa 00 00       	call   f011ed6e <strcconcat>
f01142ea:	83 c4 10             	add    $0x10,%esp
f01142ed:	83 ec 0c             	sub    $0xc,%esp
f01142f0:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01142f6:	50                   	push   %eax
f01142f7:	e8 ff db fe ff       	call   f0101efb <execute_command>
f01142fc:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01142ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114302:	c1 e0 03             	shl    $0x3,%eax
f0114305:	83 ec 04             	sub    $0x4,%esp
f0114308:	50                   	push   %eax
f0114309:	6a 00                	push   $0x0
f011430b:	ff 75 d8             	pushl  -0x28(%ebp)
f011430e:	e8 26 59 ff ff       	call   f0109c39 <calculate_required_frames>
f0114313:	83 c4 10             	add    $0x10,%esp
f0114316:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0114319:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0114320:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114323:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114326:	74 24                	je     f011434c <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114328:	83 ec 0c             	sub    $0xc,%esp
f011432b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011432e:	ff 75 c8             	pushl  -0x38(%ebp)
f0114331:	68 3c 96 12 f0       	push   $0xf012963c
f0114336:	68 95 06 00 00       	push   $0x695
f011433b:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114340:	e8 91 c1 fe ff       	call   f01004d6 <_warn>
f0114345:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114348:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011434c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114350:	74 04                	je     f0114356 <test_calculate_required_frames+0x55f>
f0114352:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114356:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011435a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011435d:	c1 e0 0a             	shl    $0xa,%eax
f0114360:	83 ec 04             	sub    $0x4,%esp
f0114363:	50                   	push   %eax
f0114364:	6a 00                	push   $0x0
f0114366:	ff 75 d8             	pushl  -0x28(%ebp)
f0114369:	e8 cb 58 ff ff       	call   f0109c39 <calculate_required_frames>
f011436e:	83 c4 10             	add    $0x10,%esp
f0114371:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0114374:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114377:	c1 e0 0a             	shl    $0xa,%eax
f011437a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011437d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114384:	99                   	cltd   
f0114385:	f7 fb                	idiv   %ebx
f0114387:	89 c1                	mov    %eax,%ecx
f0114389:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011438c:	c1 e0 0a             	shl    $0xa,%eax
f011438f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114392:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114399:	99                   	cltd   
f011439a:	f7 fe                	idiv   %esi
f011439c:	01 c8                	add    %ecx,%eax
f011439e:	83 e8 05             	sub    $0x5,%eax
f01143a1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f01143a4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01143a7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01143aa:	74 24                	je     f01143d0 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01143ac:	83 ec 0c             	sub    $0xc,%esp
f01143af:	ff 75 c4             	pushl  -0x3c(%ebp)
f01143b2:	ff 75 c8             	pushl  -0x38(%ebp)
f01143b5:	68 3c 96 12 f0       	push   $0xf012963c
f01143ba:	68 a0 06 00 00       	push   $0x6a0
f01143bf:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01143c4:	e8 0d c1 fe ff       	call   f01004d6 <_warn>
f01143c9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143cc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01143d0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143d4:	74 04                	je     f01143da <test_calculate_required_frames+0x5e3>
f01143d6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01143da:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01143de:	83 ec 04             	sub    $0x4,%esp
f01143e1:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01143e7:	50                   	push   %eax
f01143e8:	68 d4 96 12 f0       	push   $0xf01296d4
f01143ed:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01143f3:	50                   	push   %eax
f01143f4:	e8 75 a9 00 00       	call   f011ed6e <strcconcat>
f01143f9:	83 c4 10             	add    $0x10,%esp
f01143fc:	83 ec 0c             	sub    $0xc,%esp
f01143ff:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114405:	50                   	push   %eax
f0114406:	e8 f0 da fe ff       	call   f0101efb <execute_command>
f011440b:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011440e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114411:	89 c2                	mov    %eax,%edx
f0114413:	01 d2                	add    %edx,%edx
f0114415:	01 d0                	add    %edx,%eax
f0114417:	83 ec 04             	sub    $0x4,%esp
f011441a:	50                   	push   %eax
f011441b:	68 00 18 00 00       	push   $0x1800
f0114420:	ff 75 d8             	pushl  -0x28(%ebp)
f0114423:	e8 11 58 ff ff       	call   f0109c39 <calculate_required_frames>
f0114428:	83 c4 10             	add    $0x10,%esp
f011442b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011442e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0114435:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114438:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011443b:	74 24                	je     f0114461 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011443d:	83 ec 0c             	sub    $0xc,%esp
f0114440:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114443:	ff 75 c8             	pushl  -0x38(%ebp)
f0114446:	68 3c 96 12 f0       	push   $0xf012963c
f011444b:	68 af 06 00 00       	push   $0x6af
f0114450:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114455:	e8 7c c0 fe ff       	call   f01004d6 <_warn>
f011445a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011445d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114461:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114465:	74 04                	je     f011446b <test_calculate_required_frames+0x674>
f0114467:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011446b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011446f:	83 ec 04             	sub    $0x4,%esp
f0114472:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114478:	50                   	push   %eax
f0114479:	68 94 87 12 f0       	push   $0xf0128794
f011447e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114484:	50                   	push   %eax
f0114485:	e8 e4 a8 00 00       	call   f011ed6e <strcconcat>
f011448a:	83 c4 10             	add    $0x10,%esp
f011448d:	83 ec 0c             	sub    $0xc,%esp
f0114490:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114496:	50                   	push   %eax
f0114497:	e8 5f da fe ff       	call   f0101efb <execute_command>
f011449c:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f011449f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01144a2:	89 d0                	mov    %edx,%eax
f01144a4:	c1 e0 02             	shl    $0x2,%eax
f01144a7:	01 d0                	add    %edx,%eax
f01144a9:	01 c0                	add    %eax,%eax
f01144ab:	83 ec 04             	sub    $0x4,%esp
f01144ae:	50                   	push   %eax
f01144af:	68 00 00 40 00       	push   $0x400000
f01144b4:	ff 75 d8             	pushl  -0x28(%ebp)
f01144b7:	e8 7d 57 ff ff       	call   f0109c39 <calculate_required_frames>
f01144bc:	83 c4 10             	add    $0x10,%esp
f01144bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01144c2:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01144c9:	74 26                	je     f01144f1 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01144cb:	83 ec 0c             	sub    $0xc,%esp
f01144ce:	68 03 0a 00 00       	push   $0xa03
f01144d3:	ff 75 c8             	pushl  -0x38(%ebp)
f01144d6:	68 3c 96 12 f0       	push   $0xf012963c
f01144db:	68 bb 06 00 00       	push   $0x6bb
f01144e0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01144e5:	e8 ec bf fe ff       	call   f01004d6 <_warn>
f01144ea:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01144f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144f5:	74 04                	je     f01144fb <test_calculate_required_frames+0x704>
f01144f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01144ff:	83 ec 04             	sub    $0x4,%esp
f0114502:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114508:	50                   	push   %eax
f0114509:	68 9e 87 12 f0       	push   $0xf012879e
f011450e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114514:	50                   	push   %eax
f0114515:	e8 54 a8 00 00       	call   f011ed6e <strcconcat>
f011451a:	83 c4 10             	add    $0x10,%esp
f011451d:	83 ec 0c             	sub    $0xc,%esp
f0114520:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114526:	50                   	push   %eax
f0114527:	e8 cf d9 fe ff       	call   f0101efb <execute_command>
f011452c:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011452f:	83 ec 04             	sub    $0x4,%esp
f0114532:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114538:	50                   	push   %eax
f0114539:	68 dc 96 12 f0       	push   $0xf01296dc
f011453e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114544:	50                   	push   %eax
f0114545:	e8 24 a8 00 00       	call   f011ed6e <strcconcat>
f011454a:	83 c4 10             	add    $0x10,%esp
f011454d:	83 ec 0c             	sub    $0xc,%esp
f0114550:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114556:	50                   	push   %eax
f0114557:	e8 9f d9 fe ff       	call   f0101efb <execute_command>
f011455c:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011455f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114562:	01 c0                	add    %eax,%eax
f0114564:	83 ec 04             	sub    $0x4,%esp
f0114567:	50                   	push   %eax
f0114568:	68 00 00 70 00       	push   $0x700000
f011456d:	ff 75 d8             	pushl  -0x28(%ebp)
f0114570:	e8 c4 56 ff ff       	call   f0109c39 <calculate_required_frames>
f0114575:	83 c4 10             	add    $0x10,%esp
f0114578:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011457b:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0114582:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114585:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114588:	74 24                	je     f01145ae <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011458a:	83 ec 0c             	sub    $0xc,%esp
f011458d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114590:	ff 75 c8             	pushl  -0x38(%ebp)
f0114593:	68 3c 96 12 f0       	push   $0xf012963c
f0114598:	68 cb 06 00 00       	push   $0x6cb
f011459d:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01145a2:	e8 2f bf fe ff       	call   f01004d6 <_warn>
f01145a7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01145aa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01145ae:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145b2:	74 04                	je     f01145b8 <test_calculate_required_frames+0x7c1>
f01145b4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01145b8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01145bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01145bf:	83 ec 04             	sub    $0x4,%esp
f01145c2:	50                   	push   %eax
f01145c3:	68 ff ff 3f 00       	push   $0x3fffff
f01145c8:	ff 75 d8             	pushl  -0x28(%ebp)
f01145cb:	e8 69 56 ff ff       	call   f0109c39 <calculate_required_frames>
f01145d0:	83 c4 10             	add    $0x10,%esp
f01145d3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f01145d6:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f01145dd:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01145e0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01145e3:	74 24                	je     f0114609 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01145e5:	83 ec 0c             	sub    $0xc,%esp
f01145e8:	ff 75 c4             	pushl  -0x3c(%ebp)
f01145eb:	ff 75 c8             	pushl  -0x38(%ebp)
f01145ee:	68 3c 96 12 f0       	push   $0xf012963c
f01145f3:	68 d6 06 00 00       	push   $0x6d6
f01145f8:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01145fd:	e8 d4 be fe ff       	call   f01004d6 <_warn>
f0114602:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114605:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114609:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011460d:	74 04                	je     f0114613 <test_calculate_required_frames+0x81c>
f011460f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114613:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0114617:	83 ec 0c             	sub    $0xc,%esp
f011461a:	68 4f 87 12 f0       	push   $0xf012874f
f011461f:	e8 67 c9 fe ff       	call   f0100f8b <cprintf>
f0114624:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0114627:	83 ec 08             	sub    $0x8,%esp
f011462a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011462d:	68 e8 96 12 f0       	push   $0xf01296e8
f0114632:	e8 54 c9 fe ff       	call   f0100f8b <cprintf>
f0114637:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011463a:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011463e:	75 10                	jne    f0114650 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0114640:	83 ec 0c             	sub    $0xc,%esp
f0114643:	68 28 97 12 f0       	push   $0xf0129728
f0114648:	e8 3e c9 fe ff       	call   f0100f8b <cprintf>
f011464d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114650:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f0114655:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0114658:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011465b:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011465e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114663:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114666:	5b                   	pop    %ebx
f0114667:	5e                   	pop    %esi
f0114668:	5f                   	pop    %edi
f0114669:	5d                   	pop    %ebp
f011466a:	c3                   	ret    

f011466b <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f011466b:	55                   	push   %ebp
f011466c:	89 e5                	mov    %esp,%ebp
f011466e:	57                   	push   %edi
f011466f:	56                   	push   %esi
f0114670:	53                   	push   %ebx
f0114671:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114677:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011467a:	bb c4 84 12 f0       	mov    $0xf01284c4,%ebx
f011467f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114684:	89 c7                	mov    %eax,%edi
f0114686:	89 de                	mov    %ebx,%esi
f0114688:	89 d1                	mov    %edx,%ecx
f011468a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011468c:	8d 55 9d             	lea    -0x63(%ebp),%edx
f011468f:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114694:	b0 00                	mov    $0x0,%al
f0114696:	89 d7                	mov    %edx,%edi
f0114698:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011469a:	6a 00                	push   $0x0
f011469c:	6a 0a                	push   $0xa
f011469e:	6a 14                	push   $0x14
f01146a0:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01146a3:	50                   	push   %eax
f01146a4:	e8 bb 57 ff ff       	call   f0109e64 <env_create>
f01146a9:	83 c4 10             	add    $0x10,%esp
f01146ac:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01146af:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01146b2:	8b 40 64             	mov    0x64(%eax),%eax
f01146b5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f01146b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01146bb:	8b 40 68             	mov    0x68(%eax),%eax
f01146be:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01146c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146c4:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01146c7:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01146ce:	75 70 20 
f01146d1:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01146d8:	00 00 00 
f01146db:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01146de:	b9 03 00 00 00       	mov    $0x3,%ecx
f01146e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01146e8:	89 d7                	mov    %edx,%edi
f01146ea:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01146ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01146ef:	8b 40 10             	mov    0x10(%eax),%eax
f01146f2:	83 ec 08             	sub    $0x8,%esp
f01146f5:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01146fb:	52                   	push   %edx
f01146fc:	50                   	push   %eax
f01146fd:	e8 93 a5 00 00       	call   f011ec95 <ltostr>
f0114702:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114705:	83 ec 04             	sub    $0x4,%esp
f0114708:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011470e:	50                   	push   %eax
f011470f:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0114715:	50                   	push   %eax
f0114716:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f011471c:	50                   	push   %eax
f011471d:	e8 4c a6 00 00       	call   f011ed6e <strcconcat>
f0114722:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114725:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011472c:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114733:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f011473a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f011473e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114745:	00 00 00 
	uint32 num_tables = 0;
f0114748:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011474f:	00 00 00 
	ClearUserSpace(proc_directory);
f0114752:	83 ec 0c             	sub    $0xc,%esp
f0114755:	ff 75 d8             	pushl  -0x28(%ebp)
f0114758:	e8 8d 0e 00 00       	call   f01155ea <ClearUserSpace>
f011475d:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114760:	83 ec 0c             	sub    $0xc,%esp
f0114763:	68 08 96 12 f0       	push   $0xf0129608
f0114768:	e8 1e c8 fe ff       	call   f0100f8b <cprintf>
f011476d:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0114770:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114773:	c1 e0 03             	shl    $0x3,%eax
f0114776:	89 c2                	mov    %eax,%edx
f0114778:	83 ec 0c             	sub    $0xc,%esp
f011477b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114781:	50                   	push   %eax
f0114782:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114788:	50                   	push   %eax
f0114789:	52                   	push   %edx
f011478a:	6a 00                	push   $0x0
f011478c:	ff 75 d8             	pushl  -0x28(%ebp)
f011478f:	e8 8b 54 ff ff       	call   f0109c1f <calculate_allocated_space>
f0114794:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114797:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011479d:	85 c0                	test   %eax,%eax
f011479f:	74 27                	je     f01147c8 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01147a1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01147a7:	83 ec 0c             	sub    $0xc,%esp
f01147aa:	6a 00                	push   $0x0
f01147ac:	50                   	push   %eax
f01147ad:	68 74 97 12 f0       	push   $0xf0129774
f01147b2:	68 0b 07 00 00       	push   $0x70b
f01147b7:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01147bc:	e8 15 bd fe ff       	call   f01004d6 <_warn>
f01147c1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01147c4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01147c8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01147ce:	85 c0                	test   %eax,%eax
f01147d0:	74 27                	je     f01147f9 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01147d2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01147d8:	83 ec 0c             	sub    $0xc,%esp
f01147db:	6a 00                	push   $0x0
f01147dd:	50                   	push   %eax
f01147de:	68 d4 97 12 f0       	push   $0xf01297d4
f01147e3:	68 10 07 00 00       	push   $0x710
f01147e8:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01147ed:	e8 e4 bc fe ff       	call   f01004d6 <_warn>
f01147f2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01147f5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147f9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147fd:	74 04                	je     f0114803 <test_calculate_allocated_space+0x198>
f01147ff:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114803:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0114807:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011480e:	00 00 00 
		num_pages = 0;
f0114811:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114818:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f011481b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011481e:	c1 e0 02             	shl    $0x2,%eax
f0114821:	89 c2                	mov    %eax,%edx
f0114823:	83 ec 0c             	sub    $0xc,%esp
f0114826:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011482c:	50                   	push   %eax
f011482d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114833:	50                   	push   %eax
f0114834:	52                   	push   %edx
f0114835:	6a 00                	push   $0x0
f0114837:	ff 75 d8             	pushl  -0x28(%ebp)
f011483a:	e8 e0 53 ff ff       	call   f0109c1f <calculate_allocated_space>
f011483f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114842:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114848:	85 c0                	test   %eax,%eax
f011484a:	74 27                	je     f0114873 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011484c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114852:	83 ec 0c             	sub    $0xc,%esp
f0114855:	6a 00                	push   $0x0
f0114857:	50                   	push   %eax
f0114858:	68 74 97 12 f0       	push   $0xf0129774
f011485d:	68 1c 07 00 00       	push   $0x71c
f0114862:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114867:	e8 6a bc fe ff       	call   f01004d6 <_warn>
f011486c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011486f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114873:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114879:	85 c0                	test   %eax,%eax
f011487b:	74 27                	je     f01148a4 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011487d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114883:	83 ec 0c             	sub    $0xc,%esp
f0114886:	6a 00                	push   $0x0
f0114888:	50                   	push   %eax
f0114889:	68 d4 97 12 f0       	push   $0xf01297d4
f011488e:	68 21 07 00 00       	push   $0x721
f0114893:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114898:	e8 39 bc fe ff       	call   f01004d6 <_warn>
f011489d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01148a0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01148a4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148a8:	74 04                	je     f01148ae <test_calculate_allocated_space+0x243>
f01148aa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148ae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01148b2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01148b9:	00 00 00 
		num_pages = 0;
f01148bc:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01148c3:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01148c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01148c9:	c1 e0 0a             	shl    $0xa,%eax
f01148cc:	89 c2                	mov    %eax,%edx
f01148ce:	83 ec 0c             	sub    $0xc,%esp
f01148d1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01148d7:	50                   	push   %eax
f01148d8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01148de:	50                   	push   %eax
f01148df:	52                   	push   %edx
f01148e0:	6a 00                	push   $0x0
f01148e2:	ff 75 d8             	pushl  -0x28(%ebp)
f01148e5:	e8 35 53 ff ff       	call   f0109c1f <calculate_allocated_space>
f01148ea:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01148ed:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01148f3:	85 c0                	test   %eax,%eax
f01148f5:	74 27                	je     f011491e <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01148f7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01148fd:	83 ec 0c             	sub    $0xc,%esp
f0114900:	6a 00                	push   $0x0
f0114902:	50                   	push   %eax
f0114903:	68 74 97 12 f0       	push   $0xf0129774
f0114908:	68 2d 07 00 00       	push   $0x72d
f011490d:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114912:	e8 bf bb fe ff       	call   f01004d6 <_warn>
f0114917:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011491a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011491e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114924:	85 c0                	test   %eax,%eax
f0114926:	74 27                	je     f011494f <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114928:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011492e:	83 ec 0c             	sub    $0xc,%esp
f0114931:	6a 00                	push   $0x0
f0114933:	50                   	push   %eax
f0114934:	68 d4 97 12 f0       	push   $0xf01297d4
f0114939:	68 32 07 00 00       	push   $0x732
f011493e:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114943:	e8 8e bb fe ff       	call   f01004d6 <_warn>
f0114948:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011494b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011494f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114953:	74 04                	je     f0114959 <test_calculate_allocated_space+0x2ee>
f0114955:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114959:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f011495d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114964:	00 00 00 
		num_pages = 0;
f0114967:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011496e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0114971:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114974:	89 d0                	mov    %edx,%eax
f0114976:	01 c0                	add    %eax,%eax
f0114978:	01 d0                	add    %edx,%eax
f011497a:	01 c0                	add    %eax,%eax
f011497c:	05 00 10 00 00       	add    $0x1000,%eax
f0114981:	89 c2                	mov    %eax,%edx
f0114983:	83 ec 0c             	sub    $0xc,%esp
f0114986:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011498c:	50                   	push   %eax
f011498d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114993:	50                   	push   %eax
f0114994:	52                   	push   %edx
f0114995:	68 00 10 00 00       	push   $0x1000
f011499a:	ff 75 d8             	pushl  -0x28(%ebp)
f011499d:	e8 7d 52 ff ff       	call   f0109c1f <calculate_allocated_space>
f01149a2:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01149a5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01149ab:	85 c0                	test   %eax,%eax
f01149ad:	74 27                	je     f01149d6 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01149af:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01149b5:	83 ec 0c             	sub    $0xc,%esp
f01149b8:	6a 00                	push   $0x0
f01149ba:	50                   	push   %eax
f01149bb:	68 74 97 12 f0       	push   $0xf0129774
f01149c0:	68 3f 07 00 00       	push   $0x73f
f01149c5:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01149ca:	e8 07 bb fe ff       	call   f01004d6 <_warn>
f01149cf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01149d2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01149d6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01149dc:	85 c0                	test   %eax,%eax
f01149de:	74 27                	je     f0114a07 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01149e0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01149e6:	83 ec 0c             	sub    $0xc,%esp
f01149e9:	6a 00                	push   $0x0
f01149eb:	50                   	push   %eax
f01149ec:	68 d4 97 12 f0       	push   $0xf01297d4
f01149f1:	68 44 07 00 00       	push   $0x744
f01149f6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01149fb:	e8 d6 ba fe ff       	call   f01004d6 <_warn>
f0114a00:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a03:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a07:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a0b:	74 04                	je     f0114a11 <test_calculate_allocated_space+0x3a6>
f0114a0d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a11:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0114a15:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114a1c:	00 00 00 
		num_pages = 0;
f0114a1f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114a26:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0114a29:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114a2c:	89 c2                	mov    %eax,%edx
f0114a2e:	01 d2                	add    %edx,%edx
f0114a30:	01 d0                	add    %edx,%eax
f0114a32:	05 00 18 00 00       	add    $0x1800,%eax
f0114a37:	89 c2                	mov    %eax,%edx
f0114a39:	83 ec 0c             	sub    $0xc,%esp
f0114a3c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114a42:	50                   	push   %eax
f0114a43:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114a49:	50                   	push   %eax
f0114a4a:	52                   	push   %edx
f0114a4b:	68 00 18 00 00       	push   $0x1800
f0114a50:	ff 75 d8             	pushl  -0x28(%ebp)
f0114a53:	e8 c7 51 ff ff       	call   f0109c1f <calculate_allocated_space>
f0114a58:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114a5b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114a61:	85 c0                	test   %eax,%eax
f0114a63:	74 27                	je     f0114a8c <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114a65:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114a6b:	83 ec 0c             	sub    $0xc,%esp
f0114a6e:	6a 00                	push   $0x0
f0114a70:	50                   	push   %eax
f0114a71:	68 74 97 12 f0       	push   $0xf0129774
f0114a76:	68 50 07 00 00       	push   $0x750
f0114a7b:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114a80:	e8 51 ba fe ff       	call   f01004d6 <_warn>
f0114a85:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a88:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114a8c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114a92:	85 c0                	test   %eax,%eax
f0114a94:	74 27                	je     f0114abd <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114a96:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114a9c:	83 ec 0c             	sub    $0xc,%esp
f0114a9f:	6a 00                	push   $0x0
f0114aa1:	50                   	push   %eax
f0114aa2:	68 d4 97 12 f0       	push   $0xf01297d4
f0114aa7:	68 55 07 00 00       	push   $0x755
f0114aac:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114ab1:	e8 20 ba fe ff       	call   f01004d6 <_warn>
f0114ab6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ab9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114abd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ac1:	74 04                	je     f0114ac7 <test_calculate_allocated_space+0x45c>
f0114ac3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114ac7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0114acb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114ad2:	00 00 00 
		num_pages = 0;
f0114ad5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114adc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0114adf:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114ae2:	89 d0                	mov    %edx,%eax
f0114ae4:	c1 e0 02             	shl    $0x2,%eax
f0114ae7:	01 d0                	add    %edx,%eax
f0114ae9:	01 c0                	add    %eax,%eax
f0114aeb:	05 00 00 40 00       	add    $0x400000,%eax
f0114af0:	89 c2                	mov    %eax,%edx
f0114af2:	83 ec 0c             	sub    $0xc,%esp
f0114af5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114afb:	50                   	push   %eax
f0114afc:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114b02:	50                   	push   %eax
f0114b03:	52                   	push   %edx
f0114b04:	68 00 00 40 00       	push   $0x400000
f0114b09:	ff 75 d8             	pushl  -0x28(%ebp)
f0114b0c:	e8 0e 51 ff ff       	call   f0109c1f <calculate_allocated_space>
f0114b11:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114b14:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114b1a:	85 c0                	test   %eax,%eax
f0114b1c:	74 27                	je     f0114b45 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114b1e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114b24:	83 ec 0c             	sub    $0xc,%esp
f0114b27:	6a 00                	push   $0x0
f0114b29:	50                   	push   %eax
f0114b2a:	68 74 97 12 f0       	push   $0xf0129774
f0114b2f:	68 61 07 00 00       	push   $0x761
f0114b34:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114b39:	e8 98 b9 fe ff       	call   f01004d6 <_warn>
f0114b3e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b41:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114b45:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114b4b:	85 c0                	test   %eax,%eax
f0114b4d:	74 27                	je     f0114b76 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114b4f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114b55:	83 ec 0c             	sub    $0xc,%esp
f0114b58:	6a 00                	push   $0x0
f0114b5a:	50                   	push   %eax
f0114b5b:	68 d4 97 12 f0       	push   $0xf01297d4
f0114b60:	68 66 07 00 00       	push   $0x766
f0114b65:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114b6a:	e8 67 b9 fe ff       	call   f01004d6 <_warn>
f0114b6f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b72:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b76:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b7a:	74 04                	je     f0114b80 <test_calculate_allocated_space+0x515>
f0114b7c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b80:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0114b84:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114b8b:	00 00 00 
		num_pages = 0;
f0114b8e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114b95:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0114b98:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114b9b:	05 00 00 38 00       	add    $0x380000,%eax
f0114ba0:	01 c0                	add    %eax,%eax
f0114ba2:	89 c2                	mov    %eax,%edx
f0114ba4:	83 ec 0c             	sub    $0xc,%esp
f0114ba7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114bad:	50                   	push   %eax
f0114bae:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114bb4:	50                   	push   %eax
f0114bb5:	52                   	push   %edx
f0114bb6:	68 00 00 70 00       	push   $0x700000
f0114bbb:	ff 75 d8             	pushl  -0x28(%ebp)
f0114bbe:	e8 5c 50 ff ff       	call   f0109c1f <calculate_allocated_space>
f0114bc3:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114bc6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114bcc:	85 c0                	test   %eax,%eax
f0114bce:	74 27                	je     f0114bf7 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114bd0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114bd6:	83 ec 0c             	sub    $0xc,%esp
f0114bd9:	6a 00                	push   $0x0
f0114bdb:	50                   	push   %eax
f0114bdc:	68 74 97 12 f0       	push   $0xf0129774
f0114be1:	68 73 07 00 00       	push   $0x773
f0114be6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114beb:	e8 e6 b8 fe ff       	call   f01004d6 <_warn>
f0114bf0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bf3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114bf7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114bfd:	85 c0                	test   %eax,%eax
f0114bff:	74 27                	je     f0114c28 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114c01:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114c07:	83 ec 0c             	sub    $0xc,%esp
f0114c0a:	6a 00                	push   $0x0
f0114c0c:	50                   	push   %eax
f0114c0d:	68 d4 97 12 f0       	push   $0xf01297d4
f0114c12:	68 78 07 00 00       	push   $0x778
f0114c17:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114c1c:	e8 b5 b8 fe ff       	call   f01004d6 <_warn>
f0114c21:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c24:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114c28:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c2c:	74 04                	je     f0114c32 <test_calculate_allocated_space+0x5c7>
f0114c2e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114c32:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0114c36:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114c3d:	00 00 00 
		num_pages = 0;
f0114c40:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114c47:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0114c4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114c4d:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0114c52:	89 c2                	mov    %eax,%edx
f0114c54:	83 ec 0c             	sub    $0xc,%esp
f0114c57:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114c5d:	50                   	push   %eax
f0114c5e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114c64:	50                   	push   %eax
f0114c65:	52                   	push   %edx
f0114c66:	68 ff ff 3f 00       	push   $0x3fffff
f0114c6b:	ff 75 d8             	pushl  -0x28(%ebp)
f0114c6e:	e8 ac 4f ff ff       	call   f0109c1f <calculate_allocated_space>
f0114c73:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114c76:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114c7c:	85 c0                	test   %eax,%eax
f0114c7e:	74 27                	je     f0114ca7 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114c80:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114c86:	83 ec 0c             	sub    $0xc,%esp
f0114c89:	6a 00                	push   $0x0
f0114c8b:	50                   	push   %eax
f0114c8c:	68 74 97 12 f0       	push   $0xf0129774
f0114c91:	68 84 07 00 00       	push   $0x784
f0114c96:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114c9b:	e8 36 b8 fe ff       	call   f01004d6 <_warn>
f0114ca0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ca3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114ca7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114cad:	85 c0                	test   %eax,%eax
f0114caf:	74 27                	je     f0114cd8 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114cb1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114cb7:	83 ec 0c             	sub    $0xc,%esp
f0114cba:	6a 00                	push   $0x0
f0114cbc:	50                   	push   %eax
f0114cbd:	68 d4 97 12 f0       	push   $0xf01297d4
f0114cc2:	68 89 07 00 00       	push   $0x789
f0114cc7:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114ccc:	e8 05 b8 fe ff       	call   f01004d6 <_warn>
f0114cd1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114cd4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114cd8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114cdc:	74 04                	je     f0114ce2 <test_calculate_allocated_space+0x677>
f0114cde:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114ce2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114ce6:	83 ec 0c             	sub    $0xc,%esp
f0114ce9:	68 75 91 12 f0       	push   $0xf0129175
f0114cee:	e8 98 c2 fe ff       	call   f0100f8b <cprintf>
f0114cf3:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0114cf6:	83 ec 0c             	sub    $0xc,%esp
f0114cf9:	68 94 96 12 f0       	push   $0xf0129694
f0114cfe:	e8 88 c2 fe ff       	call   f0100f8b <cprintf>
f0114d03:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114d06:	83 ec 04             	sub    $0x4,%esp
f0114d09:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0114d0f:	50                   	push   %eax
f0114d10:	68 2e 85 12 f0       	push   $0xf012852e
f0114d15:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114d1b:	50                   	push   %eax
f0114d1c:	e8 4d a0 00 00       	call   f011ed6e <strcconcat>
f0114d21:	83 c4 10             	add    $0x10,%esp
f0114d24:	83 ec 0c             	sub    $0xc,%esp
f0114d27:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0114d2d:	50                   	push   %eax
f0114d2e:	e8 c8 d1 fe ff       	call   f0101efb <execute_command>
f0114d33:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0114d36:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114d3d:	00 00 00 
		num_pages = 0;
f0114d40:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114d47:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0114d4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d4d:	c1 e0 03             	shl    $0x3,%eax
f0114d50:	89 c2                	mov    %eax,%edx
f0114d52:	83 ec 0c             	sub    $0xc,%esp
f0114d55:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114d5b:	50                   	push   %eax
f0114d5c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114d62:	50                   	push   %eax
f0114d63:	52                   	push   %edx
f0114d64:	6a 00                	push   $0x0
f0114d66:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d69:	e8 b1 4e ff ff       	call   f0109c1f <calculate_allocated_space>
f0114d6e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0114d71:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0114d78:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0114d7f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114d85:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114d88:	74 28                	je     f0114db2 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0114d8a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114d90:	83 ec 0c             	sub    $0xc,%esp
f0114d93:	ff 75 c8             	pushl  -0x38(%ebp)
f0114d96:	50                   	push   %eax
f0114d97:	68 74 97 12 f0       	push   $0xf0129774
f0114d9c:	68 a0 07 00 00       	push   $0x7a0
f0114da1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114da6:	e8 2b b7 fe ff       	call   f01004d6 <_warn>
f0114dab:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114dae:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0114db2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114db8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114dbb:	74 28                	je     f0114de5 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0114dbd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114dc3:	83 ec 0c             	sub    $0xc,%esp
f0114dc6:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114dc9:	50                   	push   %eax
f0114dca:	68 d4 97 12 f0       	push   $0xf01297d4
f0114dcf:	68 a5 07 00 00       	push   $0x7a5
f0114dd4:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114dd9:	e8 f8 b6 fe ff       	call   f01004d6 <_warn>
f0114dde:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114de1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114de5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114de9:	74 04                	je     f0114def <test_calculate_allocated_space+0x784>
f0114deb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114def:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0114df3:	83 ec 04             	sub    $0x4,%esp
f0114df6:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0114dfc:	50                   	push   %eax
f0114dfd:	68 3b 85 12 f0       	push   $0xf012853b
f0114e02:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114e08:	50                   	push   %eax
f0114e09:	e8 60 9f 00 00       	call   f011ed6e <strcconcat>
f0114e0e:	83 c4 10             	add    $0x10,%esp
f0114e11:	83 ec 0c             	sub    $0xc,%esp
f0114e14:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0114e1a:	50                   	push   %eax
f0114e1b:	e8 db d0 fe ff       	call   f0101efb <execute_command>
f0114e20:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0114e23:	83 ec 04             	sub    $0x4,%esp
f0114e26:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0114e2c:	50                   	push   %eax
f0114e2d:	68 c8 96 12 f0       	push   $0xf01296c8
f0114e32:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114e38:	50                   	push   %eax
f0114e39:	e8 30 9f 00 00       	call   f011ed6e <strcconcat>
f0114e3e:	83 c4 10             	add    $0x10,%esp
f0114e41:	83 ec 0c             	sub    $0xc,%esp
f0114e44:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0114e4a:	50                   	push   %eax
f0114e4b:	e8 ab d0 fe ff       	call   f0101efb <execute_command>
f0114e50:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0114e53:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114e5a:	00 00 00 
		num_pages = 0;
f0114e5d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114e64:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0114e67:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114e6a:	c1 e0 03             	shl    $0x3,%eax
f0114e6d:	89 c2                	mov    %eax,%edx
f0114e6f:	83 ec 0c             	sub    $0xc,%esp
f0114e72:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114e78:	50                   	push   %eax
f0114e79:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114e7f:	50                   	push   %eax
f0114e80:	52                   	push   %edx
f0114e81:	6a 00                	push   $0x0
f0114e83:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e86:	e8 94 4d ff ff       	call   f0109c1f <calculate_allocated_space>
f0114e8b:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0114e8e:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0114e95:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0114e9c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114ea2:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114ea5:	74 28                	je     f0114ecf <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0114ea7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114ead:	83 ec 0c             	sub    $0xc,%esp
f0114eb0:	ff 75 c8             	pushl  -0x38(%ebp)
f0114eb3:	50                   	push   %eax
f0114eb4:	68 74 97 12 f0       	push   $0xf0129774
f0114eb9:	68 b6 07 00 00       	push   $0x7b6
f0114ebe:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114ec3:	e8 0e b6 fe ff       	call   f01004d6 <_warn>
f0114ec8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ecb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0114ecf:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114ed5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114ed8:	74 28                	je     f0114f02 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0114eda:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114ee0:	83 ec 0c             	sub    $0xc,%esp
f0114ee3:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114ee6:	50                   	push   %eax
f0114ee7:	68 d4 97 12 f0       	push   $0xf01297d4
f0114eec:	68 bb 07 00 00       	push   $0x7bb
f0114ef1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114ef6:	e8 db b5 fe ff       	call   f01004d6 <_warn>
f0114efb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114efe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114f02:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f06:	74 04                	je     f0114f0c <test_calculate_allocated_space+0x8a1>
f0114f08:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114f0c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0114f10:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114f17:	00 00 00 
		num_pages = 0;
f0114f1a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114f21:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0114f24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114f27:	c1 e0 0a             	shl    $0xa,%eax
f0114f2a:	89 c2                	mov    %eax,%edx
f0114f2c:	83 ec 0c             	sub    $0xc,%esp
f0114f2f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114f35:	50                   	push   %eax
f0114f36:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114f3c:	50                   	push   %eax
f0114f3d:	52                   	push   %edx
f0114f3e:	6a 00                	push   $0x0
f0114f40:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f43:	e8 d7 4c ff ff       	call   f0109c1f <calculate_allocated_space>
f0114f48:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0114f4b:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0114f52:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0114f59:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114f5f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114f62:	74 28                	je     f0114f8c <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0114f64:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114f6a:	83 ec 0c             	sub    $0xc,%esp
f0114f6d:	ff 75 c8             	pushl  -0x38(%ebp)
f0114f70:	50                   	push   %eax
f0114f71:	68 74 97 12 f0       	push   $0xf0129774
f0114f76:	68 c9 07 00 00       	push   $0x7c9
f0114f7b:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114f80:	e8 51 b5 fe ff       	call   f01004d6 <_warn>
f0114f85:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f88:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0114f8c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114f92:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114f95:	74 28                	je     f0114fbf <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0114f97:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114f9d:	83 ec 0c             	sub    $0xc,%esp
f0114fa0:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114fa3:	50                   	push   %eax
f0114fa4:	68 d4 97 12 f0       	push   $0xf01297d4
f0114fa9:	68 ce 07 00 00       	push   $0x7ce
f0114fae:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0114fb3:	e8 1e b5 fe ff       	call   f01004d6 <_warn>
f0114fb8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fbb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114fbf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114fc3:	74 04                	je     f0114fc9 <test_calculate_allocated_space+0x95e>
f0114fc5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114fc9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0114fcd:	83 ec 04             	sub    $0x4,%esp
f0114fd0:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0114fd6:	50                   	push   %eax
f0114fd7:	68 d4 96 12 f0       	push   $0xf01296d4
f0114fdc:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114fe2:	50                   	push   %eax
f0114fe3:	e8 86 9d 00 00       	call   f011ed6e <strcconcat>
f0114fe8:	83 c4 10             	add    $0x10,%esp
f0114feb:	83 ec 0c             	sub    $0xc,%esp
f0114fee:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0114ff4:	50                   	push   %eax
f0114ff5:	e8 01 cf fe ff       	call   f0101efb <execute_command>
f0114ffa:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0114ffd:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115004:	00 00 00 
		num_pages = 0;
f0115007:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011500e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115011:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115014:	89 c2                	mov    %eax,%edx
f0115016:	01 d2                	add    %edx,%edx
f0115018:	01 d0                	add    %edx,%eax
f011501a:	05 00 18 00 00       	add    $0x1800,%eax
f011501f:	89 c2                	mov    %eax,%edx
f0115021:	83 ec 0c             	sub    $0xc,%esp
f0115024:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011502a:	50                   	push   %eax
f011502b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115031:	50                   	push   %eax
f0115032:	52                   	push   %edx
f0115033:	68 00 18 00 00       	push   $0x1800
f0115038:	ff 75 d8             	pushl  -0x28(%ebp)
f011503b:	e8 df 4b ff ff       	call   f0109c1f <calculate_allocated_space>
f0115040:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115043:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011504a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115051:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115057:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011505a:	74 28                	je     f0115084 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011505c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115062:	83 ec 0c             	sub    $0xc,%esp
f0115065:	ff 75 c8             	pushl  -0x38(%ebp)
f0115068:	50                   	push   %eax
f0115069:	68 74 97 12 f0       	push   $0xf0129774
f011506e:	68 df 07 00 00       	push   $0x7df
f0115073:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115078:	e8 59 b4 fe ff       	call   f01004d6 <_warn>
f011507d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115080:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115084:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011508a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011508d:	74 28                	je     f01150b7 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011508f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115095:	83 ec 0c             	sub    $0xc,%esp
f0115098:	ff 75 c4             	pushl  -0x3c(%ebp)
f011509b:	50                   	push   %eax
f011509c:	68 d4 97 12 f0       	push   $0xf01297d4
f01150a1:	68 e4 07 00 00       	push   $0x7e4
f01150a6:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01150ab:	e8 26 b4 fe ff       	call   f01004d6 <_warn>
f01150b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150b3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01150b7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01150bb:	74 04                	je     f01150c1 <test_calculate_allocated_space+0xa56>
f01150bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01150c1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01150c5:	83 ec 04             	sub    $0x4,%esp
f01150c8:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01150ce:	50                   	push   %eax
f01150cf:	68 94 87 12 f0       	push   $0xf0128794
f01150d4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01150da:	50                   	push   %eax
f01150db:	e8 8e 9c 00 00       	call   f011ed6e <strcconcat>
f01150e0:	83 c4 10             	add    $0x10,%esp
f01150e3:	83 ec 0c             	sub    $0xc,%esp
f01150e6:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01150ec:	50                   	push   %eax
f01150ed:	e8 09 ce fe ff       	call   f0101efb <execute_command>
f01150f2:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f01150f5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01150fc:	00 00 00 
		num_pages = 0;
f01150ff:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115106:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115109:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011510c:	89 d0                	mov    %edx,%eax
f011510e:	c1 e0 02             	shl    $0x2,%eax
f0115111:	01 d0                	add    %edx,%eax
f0115113:	01 c0                	add    %eax,%eax
f0115115:	05 00 00 40 00       	add    $0x400000,%eax
f011511a:	89 c2                	mov    %eax,%edx
f011511c:	83 ec 0c             	sub    $0xc,%esp
f011511f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115125:	50                   	push   %eax
f0115126:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011512c:	50                   	push   %eax
f011512d:	52                   	push   %edx
f011512e:	68 00 00 40 00       	push   $0x400000
f0115133:	ff 75 d8             	pushl  -0x28(%ebp)
f0115136:	e8 e4 4a ff ff       	call   f0109c1f <calculate_allocated_space>
f011513b:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011513e:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115145:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011514c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115152:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115155:	74 28                	je     f011517f <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115157:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011515d:	83 ec 0c             	sub    $0xc,%esp
f0115160:	ff 75 c8             	pushl  -0x38(%ebp)
f0115163:	50                   	push   %eax
f0115164:	68 74 97 12 f0       	push   $0xf0129774
f0115169:	68 f4 07 00 00       	push   $0x7f4
f011516e:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115173:	e8 5e b3 fe ff       	call   f01004d6 <_warn>
f0115178:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011517b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011517f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115185:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115188:	74 28                	je     f01151b2 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011518a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115190:	83 ec 0c             	sub    $0xc,%esp
f0115193:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115196:	50                   	push   %eax
f0115197:	68 d4 97 12 f0       	push   $0xf01297d4
f011519c:	68 f9 07 00 00       	push   $0x7f9
f01151a1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01151a6:	e8 2b b3 fe ff       	call   f01004d6 <_warn>
f01151ab:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151ae:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01151b2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01151b6:	74 04                	je     f01151bc <test_calculate_allocated_space+0xb51>
f01151b8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01151bc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01151c0:	83 ec 04             	sub    $0x4,%esp
f01151c3:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01151c9:	50                   	push   %eax
f01151ca:	68 9e 87 12 f0       	push   $0xf012879e
f01151cf:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01151d5:	50                   	push   %eax
f01151d6:	e8 93 9b 00 00       	call   f011ed6e <strcconcat>
f01151db:	83 c4 10             	add    $0x10,%esp
f01151de:	83 ec 0c             	sub    $0xc,%esp
f01151e1:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01151e7:	50                   	push   %eax
f01151e8:	e8 0e cd fe ff       	call   f0101efb <execute_command>
f01151ed:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01151f0:	83 ec 04             	sub    $0x4,%esp
f01151f3:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01151f9:	50                   	push   %eax
f01151fa:	68 dc 96 12 f0       	push   $0xf01296dc
f01151ff:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115205:	50                   	push   %eax
f0115206:	e8 63 9b 00 00       	call   f011ed6e <strcconcat>
f011520b:	83 c4 10             	add    $0x10,%esp
f011520e:	83 ec 0c             	sub    $0xc,%esp
f0115211:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115217:	50                   	push   %eax
f0115218:	e8 de cc fe ff       	call   f0101efb <execute_command>
f011521d:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0115220:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115227:	00 00 00 
		num_pages = 0;
f011522a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115231:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115234:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115237:	05 00 00 38 00       	add    $0x380000,%eax
f011523c:	01 c0                	add    %eax,%eax
f011523e:	89 c2                	mov    %eax,%edx
f0115240:	83 ec 0c             	sub    $0xc,%esp
f0115243:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115249:	50                   	push   %eax
f011524a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115250:	50                   	push   %eax
f0115251:	52                   	push   %edx
f0115252:	68 00 00 70 00       	push   $0x700000
f0115257:	ff 75 d8             	pushl  -0x28(%ebp)
f011525a:	e8 c0 49 ff ff       	call   f0109c1f <calculate_allocated_space>
f011525f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115262:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0115269:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115270:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115276:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115279:	74 28                	je     f01152a3 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011527b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115281:	83 ec 0c             	sub    $0xc,%esp
f0115284:	ff 75 c8             	pushl  -0x38(%ebp)
f0115287:	50                   	push   %eax
f0115288:	68 74 97 12 f0       	push   $0xf0129774
f011528d:	68 0b 08 00 00       	push   $0x80b
f0115292:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115297:	e8 3a b2 fe ff       	call   f01004d6 <_warn>
f011529c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011529f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01152a3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01152a9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01152ac:	74 28                	je     f01152d6 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01152ae:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01152b4:	83 ec 0c             	sub    $0xc,%esp
f01152b7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01152ba:	50                   	push   %eax
f01152bb:	68 d4 97 12 f0       	push   $0xf01297d4
f01152c0:	68 10 08 00 00       	push   $0x810
f01152c5:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01152ca:	e8 07 b2 fe ff       	call   f01004d6 <_warn>
f01152cf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152d2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01152d6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152da:	74 04                	je     f01152e0 <test_calculate_allocated_space+0xc75>
f01152dc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01152e0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f01152e4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01152eb:	00 00 00 
		num_pages = 0;
f01152ee:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01152f5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01152f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01152fb:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115300:	89 c2                	mov    %eax,%edx
f0115302:	83 ec 0c             	sub    $0xc,%esp
f0115305:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011530b:	50                   	push   %eax
f011530c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115312:	50                   	push   %eax
f0115313:	52                   	push   %edx
f0115314:	68 ff ff 3f 00       	push   $0x3fffff
f0115319:	ff 75 d8             	pushl  -0x28(%ebp)
f011531c:	e8 fe 48 ff ff       	call   f0109c1f <calculate_allocated_space>
f0115321:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115324:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f011532b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115332:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115338:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011533b:	74 28                	je     f0115365 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011533d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115343:	83 ec 0c             	sub    $0xc,%esp
f0115346:	ff 75 c8             	pushl  -0x38(%ebp)
f0115349:	50                   	push   %eax
f011534a:	68 74 97 12 f0       	push   $0xf0129774
f011534f:	68 1e 08 00 00       	push   $0x81e
f0115354:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115359:	e8 78 b1 fe ff       	call   f01004d6 <_warn>
f011535e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115361:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115365:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011536b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011536e:	74 28                	je     f0115398 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115370:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115376:	83 ec 0c             	sub    $0xc,%esp
f0115379:	ff 75 c4             	pushl  -0x3c(%ebp)
f011537c:	50                   	push   %eax
f011537d:	68 d4 97 12 f0       	push   $0xf01297d4
f0115382:	68 23 08 00 00       	push   $0x823
f0115387:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011538c:	e8 45 b1 fe ff       	call   f01004d6 <_warn>
f0115391:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115394:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115398:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011539c:	74 04                	je     f01153a2 <test_calculate_allocated_space+0xd37>
f011539e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01153a2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01153a6:	83 ec 0c             	sub    $0xc,%esp
f01153a9:	68 4f 87 12 f0       	push   $0xf012874f
f01153ae:	e8 d8 bb fe ff       	call   f0100f8b <cprintf>
f01153b3:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f01153b6:	83 ec 08             	sub    $0x8,%esp
f01153b9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01153bc:	68 30 98 12 f0       	push   $0xf0129830
f01153c1:	e8 c5 bb fe ff       	call   f0100f8b <cprintf>
f01153c6:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01153c9:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01153cd:	75 10                	jne    f01153df <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f01153cf:	83 ec 0c             	sub    $0xc,%esp
f01153d2:	68 70 98 12 f0       	push   $0xf0129870
f01153d7:	e8 af bb fe ff       	call   f0100f8b <cprintf>
f01153dc:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01153df:	a1 84 cc 5e f0       	mov    0xf05ecc84,%eax
f01153e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01153e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01153ea:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01153ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01153f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01153f5:	5b                   	pop    %ebx
f01153f6:	5e                   	pop    %esi
f01153f7:	5f                   	pop    %edi
f01153f8:	5d                   	pop    %ebp
f01153f9:	c3                   	ret    

f01153fa <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01153fa:	55                   	push   %ebp
f01153fb:	89 e5                	mov    %esp,%ebp
f01153fd:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0115400:	8b 45 10             	mov    0x10(%ebp),%eax
f0115403:	ba 01 00 00 00       	mov    $0x1,%edx
f0115408:	88 c1                	mov    %al,%cl
f011540a:	d3 e2                	shl    %cl,%edx
f011540c:	89 d0                	mov    %edx,%eax
f011540e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0115411:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115414:	c1 e8 16             	shr    $0x16,%eax
f0115417:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011541e:	8b 45 08             	mov    0x8(%ebp),%eax
f0115421:	01 d0                	add    %edx,%eax
f0115423:	8b 00                	mov    (%eax),%eax
f0115425:	83 e0 01             	and    $0x1,%eax
f0115428:	85 c0                	test   %eax,%eax
f011542a:	75 07                	jne    f0115433 <CB+0x39>
f011542c:	b8 00 00 00 00       	mov    $0x0,%eax
f0115431:	eb 76                	jmp    f01154a9 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0115433:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115436:	c1 e8 16             	shr    $0x16,%eax
f0115439:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115440:	8b 45 08             	mov    0x8(%ebp),%eax
f0115443:	01 d0                	add    %edx,%eax
f0115445:	8b 00                	mov    (%eax),%eax
f0115447:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011544c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011544f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115452:	c1 e8 0c             	shr    $0xc,%eax
f0115455:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0115458:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f011545d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0115460:	72 17                	jb     f0115479 <CB+0x7f>
f0115462:	ff 75 f0             	pushl  -0x10(%ebp)
f0115465:	68 bc 98 12 f0       	push   $0xf01298bc
f011546a:	68 3e 08 00 00       	push   $0x83e
f011546f:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115474:	e8 c0 ae fe ff       	call   f0100339 <_panic>
f0115479:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011547c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0115481:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0115484:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115487:	c1 e8 0c             	shr    $0xc,%eax
f011548a:	25 ff 03 00 00       	and    $0x3ff,%eax
f011548f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115496:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0115499:	01 d0                	add    %edx,%eax
f011549b:	8b 00                	mov    (%eax),%eax
f011549d:	23 45 f4             	and    -0xc(%ebp),%eax
f01154a0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01154a3:	0f 94 c0             	sete   %al
f01154a6:	0f b6 c0             	movzbl %al,%eax
}
f01154a9:	c9                   	leave  
f01154aa:	c3                   	ret    

f01154ab <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f01154ab:	55                   	push   %ebp
f01154ac:	89 e5                	mov    %esp,%ebp
f01154ae:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01154b1:	68 eb 98 12 f0       	push   $0xf01298eb
f01154b6:	68 fa 98 12 f0       	push   $0xf01298fa
f01154bb:	68 43 08 00 00       	push   $0x843
f01154c0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01154c5:	e8 6f ae fe ff       	call   f0100339 <_panic>

f01154ca <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f01154ca:	55                   	push   %ebp
f01154cb:	89 e5                	mov    %esp,%ebp
f01154cd:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01154d0:	68 eb 98 12 f0       	push   $0xf01298eb
f01154d5:	68 fa 98 12 f0       	push   $0xf01298fa
f01154da:	68 4d 08 00 00       	push   $0x84d
f01154df:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01154e4:	e8 50 ae fe ff       	call   f0100339 <_panic>

f01154e9 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f01154e9:	55                   	push   %ebp
f01154ea:	89 e5                	mov    %esp,%ebp
f01154ec:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01154ef:	68 eb 98 12 f0       	push   $0xf01298eb
f01154f4:	68 fa 98 12 f0       	push   $0xf01298fa
f01154f9:	68 5c 08 00 00       	push   $0x85c
f01154fe:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115503:	e8 31 ae fe ff       	call   f0100339 <_panic>

f0115508 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0115508:	55                   	push   %ebp
f0115509:	89 e5                	mov    %esp,%ebp
f011550b:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011550e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115511:	c1 e8 16             	shr    $0x16,%eax
f0115514:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011551b:	8b 45 08             	mov    0x8(%ebp),%eax
f011551e:	01 d0                	add    %edx,%eax
f0115520:	8b 00                	mov    (%eax),%eax
f0115522:	83 e0 01             	and    $0x1,%eax
f0115525:	85 c0                	test   %eax,%eax
f0115527:	75 07                	jne    f0115530 <CE+0x28>
f0115529:	b8 00 00 00 00       	mov    $0x0,%eax
f011552e:	eb 7a                	jmp    f01155aa <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0115530:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115533:	c1 e8 16             	shr    $0x16,%eax
f0115536:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011553d:	8b 45 08             	mov    0x8(%ebp),%eax
f0115540:	01 d0                	add    %edx,%eax
f0115542:	8b 00                	mov    (%eax),%eax
f0115544:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115549:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011554c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011554f:	c1 e8 0c             	shr    $0xc,%eax
f0115552:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0115555:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f011555a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f011555d:	72 17                	jb     f0115576 <CE+0x6e>
f011555f:	ff 75 f4             	pushl  -0xc(%ebp)
f0115562:	68 bc 98 12 f0       	push   $0xf01298bc
f0115567:	68 65 08 00 00       	push   $0x865
f011556c:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115571:	e8 c3 ad fe ff       	call   f0100339 <_panic>
f0115576:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0115579:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011557e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0115581:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115584:	c1 e8 0c             	shr    $0xc,%eax
f0115587:	25 ff 03 00 00       	and    $0x3ff,%eax
f011558c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115593:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0115596:	01 d0                	add    %edx,%eax
f0115598:	8b 00                	mov    (%eax),%eax
f011559a:	85 c0                	test   %eax,%eax
f011559c:	74 07                	je     f01155a5 <CE+0x9d>
f011559e:	b8 00 00 00 00       	mov    $0x0,%eax
f01155a3:	eb 05                	jmp    f01155aa <CE+0xa2>
	return 1;
f01155a5:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01155aa:	c9                   	leave  
f01155ab:	c3                   	ret    

f01155ac <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f01155ac:	55                   	push   %ebp
f01155ad:	89 e5                	mov    %esp,%ebp
f01155af:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01155b2:	68 eb 98 12 f0       	push   $0xf01298eb
f01155b7:	68 fa 98 12 f0       	push   $0xf01298fa
f01155bc:	68 6c 08 00 00       	push   $0x86c
f01155c1:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01155c6:	e8 6e ad fe ff       	call   f0100339 <_panic>

f01155cb <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f01155cb:	55                   	push   %ebp
f01155cc:	89 e5                	mov    %esp,%ebp
f01155ce:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01155d1:	68 eb 98 12 f0       	push   $0xf01298eb
f01155d6:	68 fa 98 12 f0       	push   $0xf01298fa
f01155db:	68 7c 08 00 00       	push   $0x87c
f01155e0:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01155e5:	e8 4f ad fe ff       	call   f0100339 <_panic>

f01155ea <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f01155ea:	55                   	push   %ebp
f01155eb:	89 e5                	mov    %esp,%ebp
f01155ed:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01155f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01155f7:	eb 18                	jmp    f0115611 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f01155f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01155fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115603:	8b 45 08             	mov    0x8(%ebp),%eax
f0115606:	01 d0                	add    %edx,%eax
f0115608:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f011560e:	ff 45 fc             	incl   -0x4(%ebp)
f0115611:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0115614:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0115619:	76 de                	jbe    f01155f9 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f011561b:	90                   	nop
f011561c:	c9                   	leave  
f011561d:	c3                   	ret    

f011561e <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f011561e:	55                   	push   %ebp
f011561f:	89 e5                	mov    %esp,%ebp
f0115621:	83 ec 38             	sub    $0x38,%esp
f0115624:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0115627:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f011562a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011562d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115632:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0115635:	8b 45 10             	mov    0x10(%ebp),%eax
f0115638:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011563d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0115640:	e9 ea 01 00 00       	jmp    f011582f <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0115645:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0115649:	74 44                	je     f011568f <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f011564b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011564e:	83 ec 04             	sub    $0x4,%esp
f0115651:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0115654:	52                   	push   %edx
f0115655:	50                   	push   %eax
f0115656:	ff 75 08             	pushl  0x8(%ebp)
f0115659:	e8 a0 30 ff ff       	call   f01086fe <get_frame_info>
f011565e:	83 c4 10             	add    $0x10,%esp
f0115661:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0115664:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115667:	85 c0                	test   %eax,%eax
f0115669:	75 24                	jne    f011568f <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f011566b:	83 ec 04             	sub    $0x4,%esp
f011566e:	68 10 99 12 f0       	push   $0xf0129910
f0115673:	68 99 08 00 00       	push   $0x899
f0115678:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011567d:	e8 54 ae fe ff       	call   f01004d6 <_warn>
f0115682:	83 c4 10             	add    $0x10,%esp
				return 0;
f0115685:	b8 00 00 00 00       	mov    $0x0,%eax
f011568a:	e9 b6 01 00 00       	jmp    f0115845 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f011568f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115692:	83 ec 04             	sub    $0x4,%esp
f0115695:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0115698:	52                   	push   %edx
f0115699:	50                   	push   %eax
f011569a:	ff 75 08             	pushl  0x8(%ebp)
f011569d:	e8 5c 30 ff ff       	call   f01086fe <get_frame_info>
f01156a2:	83 c4 10             	add    $0x10,%esp
f01156a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f01156a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01156ab:	85 c0                	test   %eax,%eax
f01156ad:	75 24                	jne    f01156d3 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f01156af:	83 ec 04             	sub    $0x4,%esp
f01156b2:	68 3c 99 12 f0       	push   $0xf012993c
f01156b7:	68 a0 08 00 00       	push   $0x8a0
f01156bc:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01156c1:	e8 10 ae fe ff       	call   f01004d6 <_warn>
f01156c6:	83 c4 10             	add    $0x10,%esp
			return 0;
f01156c9:	b8 00 00 00 00       	mov    $0x0,%eax
f01156ce:	e9 72 01 00 00       	jmp    f0115845 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f01156d3:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f01156d7:	75 70                	jne    f0115749 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f01156d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01156dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01156df:	c1 ea 0c             	shr    $0xc,%edx
f01156e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01156e8:	c1 e2 02             	shl    $0x2,%edx
f01156eb:	01 d0                	add    %edx,%eax
f01156ed:	8b 00                	mov    (%eax),%eax
f01156ef:	c1 e8 0c             	shr    $0xc,%eax
f01156f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f01156f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01156f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01156fb:	c1 ea 0c             	shr    $0xc,%edx
f01156fe:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0115704:	c1 e2 02             	shl    $0x2,%edx
f0115707:	01 d0                	add    %edx,%eax
f0115709:	8b 00                	mov    (%eax),%eax
f011570b:	c1 e8 0c             	shr    $0xc,%eax
f011570e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0115711:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0115714:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0115717:	74 30                	je     f0115749 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0115719:	83 ec 04             	sub    $0x4,%esp
f011571c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011571f:	ff 75 e8             	pushl  -0x18(%ebp)
f0115722:	ff 75 f0             	pushl  -0x10(%ebp)
f0115725:	ff 75 f4             	pushl  -0xc(%ebp)
f0115728:	68 68 99 12 f0       	push   $0xf0129968
f011572d:	68 aa 08 00 00       	push   $0x8aa
f0115732:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0115737:	e8 9a ad fe ff       	call   f01004d6 <_warn>
f011573c:	83 c4 20             	add    $0x20,%esp
				return 0;
f011573f:	b8 00 00 00 00       	mov    $0x0,%eax
f0115744:	e9 fc 00 00 00       	jmp    f0115845 <CCP+0x227>
			}
		}
		if (ref != -1)
f0115749:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f011574d:	74 52                	je     f01157a1 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f011574f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0115753:	74 0e                	je     f0115763 <CCP+0x145>
f0115755:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0115758:	8b 40 08             	mov    0x8(%eax),%eax
f011575b:	0f b7 c0             	movzwl %ax,%eax
f011575e:	3b 45 18             	cmp    0x18(%ebp),%eax
f0115761:	74 3e                	je     f01157a1 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0115763:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0115767:	74 0b                	je     f0115774 <CCP+0x156>
f0115769:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011576c:	8b 40 08             	mov    0x8(%eax),%eax
f011576f:	0f b7 c0             	movzwl %ax,%eax
f0115772:	eb 05                	jmp    f0115779 <CCP+0x15b>
f0115774:	b8 00 00 00 00       	mov    $0x0,%eax
f0115779:	83 ec 0c             	sub    $0xc,%esp
f011577c:	50                   	push   %eax
f011577d:	ff 75 f0             	pushl  -0x10(%ebp)
f0115780:	68 c4 99 12 f0       	push   $0xf01299c4
f0115785:	68 b2 08 00 00       	push   $0x8b2
f011578a:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011578f:	e8 42 ad fe ff       	call   f01004d6 <_warn>
f0115794:	83 c4 20             	add    $0x20,%esp
				return 0;
f0115797:	b8 00 00 00 00       	mov    $0x0,%eax
f011579c:	e9 a4 00 00 00       	jmp    f0115845 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f01157a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01157a4:	ff 75 20             	pushl  0x20(%ebp)
f01157a7:	ff 75 1c             	pushl  0x1c(%ebp)
f01157aa:	50                   	push   %eax
f01157ab:	ff 75 08             	pushl  0x8(%ebp)
f01157ae:	e8 17 fd ff ff       	call   f01154ca <CPs>
f01157b3:	83 c4 10             	add    $0x10,%esp
f01157b6:	85 c0                	test   %eax,%eax
f01157b8:	7f 21                	jg     f01157db <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f01157ba:	83 ec 04             	sub    $0x4,%esp
f01157bd:	68 34 9a 12 f0       	push   $0xf0129a34
f01157c2:	68 b8 08 00 00       	push   $0x8b8
f01157c7:	68 c2 7d 12 f0       	push   $0xf0127dc2
f01157cc:	e8 05 ad fe ff       	call   f01004d6 <_warn>
f01157d1:	83 c4 10             	add    $0x10,%esp
			return 0;
f01157d4:	b8 00 00 00 00       	mov    $0x0,%eax
f01157d9:	eb 6a                	jmp    f0115845 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f01157db:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01157df:	74 3a                	je     f011581b <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f01157e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01157e4:	ff 75 28             	pushl  0x28(%ebp)
f01157e7:	ff 75 24             	pushl  0x24(%ebp)
f01157ea:	50                   	push   %eax
f01157eb:	ff 75 08             	pushl  0x8(%ebp)
f01157ee:	e8 d7 fc ff ff       	call   f01154ca <CPs>
f01157f3:	83 c4 10             	add    $0x10,%esp
f01157f6:	85 c0                	test   %eax,%eax
f01157f8:	7f 21                	jg     f011581b <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f01157fa:	83 ec 04             	sub    $0x4,%esp
f01157fd:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0115802:	68 bf 08 00 00       	push   $0x8bf
f0115807:	68 c2 7d 12 f0       	push   $0xf0127dc2
f011580c:	e8 c5 ac fe ff       	call   f01004d6 <_warn>
f0115811:	83 c4 10             	add    $0x10,%esp
				return 0;
f0115814:	b8 00 00 00 00       	mov    $0x0,%eax
f0115819:	eb 2a                	jmp    f0115845 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f011581b:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011581f:	74 07                	je     f0115828 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0115821:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0115828:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f011582f:	8b 55 10             	mov    0x10(%ebp),%edx
f0115832:	8b 45 14             	mov    0x14(%ebp),%eax
f0115835:	01 d0                	add    %edx,%eax
f0115837:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011583a:	0f 87 05 fe ff ff    	ja     f0115645 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0115840:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0115845:	c9                   	leave  
f0115846:	c3                   	ret    

f0115847 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0115847:	55                   	push   %ebp
f0115848:	89 e5                	mov    %esp,%ebp
f011584a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f011584d:	83 ec 04             	sub    $0x4,%esp
f0115850:	68 bc 9a 12 f0       	push   $0xf0129abc
f0115855:	6a 0e                	push   $0xe
f0115857:	68 cc 9a 12 f0       	push   $0xf0129acc
f011585c:	e8 d8 aa fe ff       	call   f0100339 <_panic>

f0115861 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0115861:	55                   	push   %ebp
f0115862:	89 e5                	mov    %esp,%ebp
f0115864:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0115867:	83 ec 04             	sub    $0x4,%esp
f011586a:	68 bc 9a 12 f0       	push   $0xf0129abc
f011586f:	68 d7 00 00 00       	push   $0xd7
f0115874:	68 cc 9a 12 f0       	push   $0xf0129acc
f0115879:	e8 bb aa fe ff       	call   f0100339 <_panic>

f011587e <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f011587e:	55                   	push   %ebp
f011587f:	89 e5                	mov    %esp,%ebp
f0115881:	57                   	push   %edi
f0115882:	53                   	push   %ebx
f0115883:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0115889:	83 ec 0c             	sub    $0xc,%esp
f011588c:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0115891:	e8 f5 b6 fe ff       	call   f0100f8b <cprintf>
f0115896:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0115899:	83 ec 0c             	sub    $0xc,%esp
f011589c:	68 18 9b 12 f0       	push   $0xf0129b18
f01158a1:	e8 e5 b6 fe ff       	call   f0100f8b <cprintf>
f01158a6:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01158a9:	83 ec 0c             	sub    $0xc,%esp
f01158ac:	68 e8 9a 12 f0       	push   $0xf0129ae8
f01158b1:	e8 d5 b6 fe ff       	call   f0100f8b <cprintf>
f01158b6:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01158b9:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f01158bd:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f01158c1:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f01158c7:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f01158cd:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f01158d4:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f01158db:	e8 1c 7e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01158e0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f01158e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01158ea:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f01158f1:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f01158f7:	b9 14 00 00 00       	mov    $0x14,%ecx
f01158fc:	b8 00 00 00 00       	mov    $0x0,%eax
f0115901:	89 d7                	mov    %edx,%edi
f0115903:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0115905:	83 ec 0c             	sub    $0xc,%esp
f0115908:	68 71 9b 12 f0       	push   $0xf0129b71
f011590d:	e8 79 b6 fe ff       	call   f0100f8b <cprintf>
f0115912:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0115915:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f011591c:	e8 db 7d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115921:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115924:	e8 3d ef fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115929:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f011592c:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0115933:	83 ec 0c             	sub    $0xc,%esp
f0115936:	ff 75 cc             	pushl  -0x34(%ebp)
f0115939:	e8 ce 33 ff ff       	call   f0108d0c <kmalloc>
f011593e:	83 c4 10             	add    $0x10,%esp
f0115941:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0115947:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011594d:	85 c0                	test   %eax,%eax
f011594f:	74 17                	je     f0115968 <test_kmalloc+0xea>
f0115951:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115958:	83 ec 0c             	sub    $0xc,%esp
f011595b:	68 90 9b 12 f0       	push   $0xf0129b90
f0115960:	e8 26 b6 fe ff       	call   f0100f8b <cprintf>
f0115965:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115968:	e8 f9 ee fe ff       	call   f0104866 <pf_calculate_free_frames>
f011596d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115970:	74 17                	je     f0115989 <test_kmalloc+0x10b>
f0115972:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115979:	83 ec 0c             	sub    $0xc,%esp
f011597c:	68 c4 9b 12 f0       	push   $0xf0129bc4
f0115981:	e8 05 b6 fe ff       	call   f0100f8b <cprintf>
f0115986:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115989:	e8 6e 7d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011598e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0115991:	74 17                	je     f01159aa <test_kmalloc+0x12c>
f0115993:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011599a:	83 ec 0c             	sub    $0xc,%esp
f011599d:	68 30 9c 12 f0       	push   $0xf0129c30
f01159a2:	e8 e4 b5 fe ff       	call   f0100f8b <cprintf>
f01159a7:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01159aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01159ae:	74 04                	je     f01159b4 <test_kmalloc+0x136>
f01159b0:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f01159b4:	83 ec 0c             	sub    $0xc,%esp
f01159b7:	68 74 9c 12 f0       	push   $0xf0129c74
f01159bc:	e8 ca b5 fe ff       	call   f0100f8b <cprintf>
f01159c1:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01159c4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01159cb:	e8 2c 7d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01159d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01159d3:	e8 8e ee fe ff       	call   f0104866 <pf_calculate_free_frames>
f01159d8:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01159db:	83 ec 0c             	sub    $0xc,%esp
f01159de:	68 00 fc 1f 00       	push   $0x1ffc00
f01159e3:	e8 24 33 ff ff       	call   f0108d0c <kmalloc>
f01159e8:	83 c4 10             	add    $0x10,%esp
f01159eb:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01159f1:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01159f7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01159fc:	74 17                	je     f0115a15 <test_kmalloc+0x197>
f01159fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115a05:	83 ec 0c             	sub    $0xc,%esp
f0115a08:	68 b8 9c 12 f0       	push   $0xf0129cb8
f0115a0d:	e8 79 b5 fe ff       	call   f0100f8b <cprintf>
f0115a12:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115a15:	e8 4c ee fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115a1a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115a1d:	74 17                	je     f0115a36 <test_kmalloc+0x1b8>
f0115a1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115a26:	83 ec 0c             	sub    $0xc,%esp
f0115a29:	68 0c 9d 12 f0       	push   $0xf0129d0c
f0115a2e:	e8 58 b5 fe ff       	call   f0100f8b <cprintf>
f0115a33:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115a36:	e8 c1 7c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115a3b:	89 c2                	mov    %eax,%edx
f0115a3d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115a40:	29 d0                	sub    %edx,%eax
f0115a42:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0115a47:	7f 17                	jg     f0115a60 <test_kmalloc+0x1e2>
f0115a49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115a50:	83 ec 0c             	sub    $0xc,%esp
f0115a53:	68 78 9d 12 f0       	push   $0xf0129d78
f0115a58:	e8 2e b5 fe ff       	call   f0100f8b <cprintf>
f0115a5d:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115a60:	e8 97 7c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115a65:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115a68:	e8 f9 ed fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115a6d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0115a70:	83 ec 0c             	sub    $0xc,%esp
f0115a73:	68 00 fc 1f 00       	push   $0x1ffc00
f0115a78:	e8 8f 32 ff ff       	call   f0108d0c <kmalloc>
f0115a7d:	83 c4 10             	add    $0x10,%esp
f0115a80:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115a86:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0115a8c:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0115a91:	74 17                	je     f0115aaa <test_kmalloc+0x22c>
f0115a93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115a9a:	83 ec 0c             	sub    $0xc,%esp
f0115a9d:	68 bc 9d 12 f0       	push   $0xf0129dbc
f0115aa2:	e8 e4 b4 fe ff       	call   f0100f8b <cprintf>
f0115aa7:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115aaa:	e8 b7 ed fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115aaf:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115ab2:	74 17                	je     f0115acb <test_kmalloc+0x24d>
f0115ab4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115abb:	83 ec 0c             	sub    $0xc,%esp
f0115abe:	68 10 9e 12 f0       	push   $0xf0129e10
f0115ac3:	e8 c3 b4 fe ff       	call   f0100f8b <cprintf>
f0115ac8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115acb:	e8 2c 7c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115ad0:	89 c2                	mov    %eax,%edx
f0115ad2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115ad5:	29 d0                	sub    %edx,%eax
f0115ad7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0115adc:	7f 17                	jg     f0115af5 <test_kmalloc+0x277>
f0115ade:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115ae5:	83 ec 0c             	sub    $0xc,%esp
f0115ae8:	68 7c 9e 12 f0       	push   $0xf0129e7c
f0115aed:	e8 99 b4 fe ff       	call   f0100f8b <cprintf>
f0115af2:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0115af5:	e8 02 7c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115afa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115afd:	e8 64 ed fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115b02:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0115b05:	83 ec 0c             	sub    $0xc,%esp
f0115b08:	68 ff 07 00 00       	push   $0x7ff
f0115b0d:	e8 fa 31 ff ff       	call   f0108d0c <kmalloc>
f0115b12:	83 c4 10             	add    $0x10,%esp
f0115b15:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0115b1b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115b21:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0115b26:	76 28                	jbe    f0115b50 <test_kmalloc+0x2d2>
f0115b28:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0115b2e:	83 ec 0c             	sub    $0xc,%esp
f0115b31:	6a 00                	push   $0x0
f0115b33:	e8 c6 30 ff ff       	call   f0108bfe <sbrk>
f0115b38:	83 c4 10             	add    $0x10,%esp
f0115b3b:	39 c3                	cmp    %eax,%ebx
f0115b3d:	73 11                	jae    f0115b50 <test_kmalloc+0x2d2>
f0115b3f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115b45:	89 c2                	mov    %eax,%edx
f0115b47:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0115b4c:	39 c2                	cmp    %eax,%edx
f0115b4e:	72 17                	jb     f0115b67 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0115b50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115b57:	83 ec 0c             	sub    $0xc,%esp
f0115b5a:	68 c0 9e 12 f0       	push   $0xf0129ec0
f0115b5f:	e8 27 b4 fe ff       	call   f0100f8b <cprintf>
f0115b64:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115b67:	e8 fa ec fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115b6c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115b6f:	74 17                	je     f0115b88 <test_kmalloc+0x30a>
f0115b71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115b78:	83 ec 0c             	sub    $0xc,%esp
f0115b7b:	68 4c 9f 12 f0       	push   $0xf0129f4c
f0115b80:	e8 06 b4 fe ff       	call   f0100f8b <cprintf>
f0115b85:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115b88:	e8 d9 ec fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115b8d:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0115b90:	83 ec 0c             	sub    $0xc,%esp
f0115b93:	68 ff 07 00 00       	push   $0x7ff
f0115b98:	e8 6f 31 ff ff       	call   f0108d0c <kmalloc>
f0115b9d:	83 c4 10             	add    $0x10,%esp
f0115ba0:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0115ba6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115bac:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0115bb1:	76 28                	jbe    f0115bdb <test_kmalloc+0x35d>
f0115bb3:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0115bb9:	83 ec 0c             	sub    $0xc,%esp
f0115bbc:	6a 00                	push   $0x0
f0115bbe:	e8 3b 30 ff ff       	call   f0108bfe <sbrk>
f0115bc3:	83 c4 10             	add    $0x10,%esp
f0115bc6:	39 c3                	cmp    %eax,%ebx
f0115bc8:	73 11                	jae    f0115bdb <test_kmalloc+0x35d>
f0115bca:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115bd0:	89 c2                	mov    %eax,%edx
f0115bd2:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0115bd7:	39 c2                	cmp    %eax,%edx
f0115bd9:	72 17                	jb     f0115bf2 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0115bdb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115be2:	83 ec 0c             	sub    $0xc,%esp
f0115be5:	68 b8 9f 12 f0       	push   $0xf0129fb8
f0115bea:	e8 9c b3 fe ff       	call   f0100f8b <cprintf>
f0115bef:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115bf2:	e8 6f ec fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115bf7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115bfa:	74 17                	je     f0115c13 <test_kmalloc+0x395>
f0115bfc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115c03:	83 ec 0c             	sub    $0xc,%esp
f0115c06:	68 44 a0 12 f0       	push   $0xf012a044
f0115c0b:	e8 7b b3 fe ff       	call   f0100f8b <cprintf>
f0115c10:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f0115c13:	e8 e4 7a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115c18:	89 c2                	mov    %eax,%edx
f0115c1a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115c1d:	29 d0                	sub    %edx,%eax
f0115c1f:	83 f8 01             	cmp    $0x1,%eax
f0115c22:	74 17                	je     f0115c3b <test_kmalloc+0x3bd>
f0115c24:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115c2b:	83 ec 0c             	sub    $0xc,%esp
f0115c2e:	68 b0 a0 12 f0       	push   $0xf012a0b0
f0115c33:	e8 53 b3 fe ff       	call   f0100f8b <cprintf>
f0115c38:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115c3b:	e8 bc 7a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115c40:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115c43:	e8 1e ec fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115c48:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0115c4b:	83 ec 0c             	sub    $0xc,%esp
f0115c4e:	68 00 1c 00 00       	push   $0x1c00
f0115c53:	e8 b4 30 ff ff       	call   f0108d0c <kmalloc>
f0115c58:	83 c4 10             	add    $0x10,%esp
f0115c5b:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115c61:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0115c67:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0115c6c:	74 17                	je     f0115c85 <test_kmalloc+0x407>
f0115c6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115c75:	83 ec 0c             	sub    $0xc,%esp
f0115c78:	68 d0 a0 12 f0       	push   $0xf012a0d0
f0115c7d:	e8 09 b3 fe ff       	call   f0100f8b <cprintf>
f0115c82:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115c85:	e8 dc eb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115c8a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115c8d:	74 17                	je     f0115ca6 <test_kmalloc+0x428>
f0115c8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115c96:	83 ec 0c             	sub    $0xc,%esp
f0115c99:	68 24 a1 12 f0       	push   $0xf012a124
f0115c9e:	e8 e8 b2 fe ff       	call   f0100f8b <cprintf>
f0115ca3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115ca6:	e8 51 7a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115cab:	89 c2                	mov    %eax,%edx
f0115cad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115cb0:	29 d0                	sub    %edx,%eax
f0115cb2:	83 f8 01             	cmp    $0x1,%eax
f0115cb5:	7f 17                	jg     f0115cce <test_kmalloc+0x450>
f0115cb7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115cbe:	83 ec 0c             	sub    $0xc,%esp
f0115cc1:	68 90 a1 12 f0       	push   $0xf012a190
f0115cc6:	e8 c0 b2 fe ff       	call   f0100f8b <cprintf>
f0115ccb:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115cce:	e8 29 7a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115cd3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115cd6:	e8 8b eb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115cdb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0115cde:	83 ec 0c             	sub    $0xc,%esp
f0115ce1:	68 00 fc 2f 00       	push   $0x2ffc00
f0115ce6:	e8 21 30 ff ff       	call   f0108d0c <kmalloc>
f0115ceb:	83 c4 10             	add    $0x10,%esp
f0115cee:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115cf4:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0115cfa:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0115cff:	74 17                	je     f0115d18 <test_kmalloc+0x49a>
f0115d01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d08:	83 ec 0c             	sub    $0xc,%esp
f0115d0b:	68 d4 a1 12 f0       	push   $0xf012a1d4
f0115d10:	e8 76 b2 fe ff       	call   f0100f8b <cprintf>
f0115d15:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115d18:	e8 49 eb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115d1d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115d20:	74 17                	je     f0115d39 <test_kmalloc+0x4bb>
f0115d22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d29:	83 ec 0c             	sub    $0xc,%esp
f0115d2c:	68 28 a2 12 f0       	push   $0xf012a228
f0115d31:	e8 55 b2 fe ff       	call   f0100f8b <cprintf>
f0115d36:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115d39:	e8 be 79 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115d3e:	89 c2                	mov    %eax,%edx
f0115d40:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115d43:	29 d0                	sub    %edx,%eax
f0115d45:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0115d4a:	7f 17                	jg     f0115d63 <test_kmalloc+0x4e5>
f0115d4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d53:	83 ec 0c             	sub    $0xc,%esp
f0115d56:	68 94 a2 12 f0       	push   $0xf012a294
f0115d5b:	e8 2b b2 fe ff       	call   f0100f8b <cprintf>
f0115d60:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115d63:	e8 94 79 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115d68:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115d6b:	e8 f6 ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115d70:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0115d73:	83 ec 0c             	sub    $0xc,%esp
f0115d76:	68 00 fc 5f 00       	push   $0x5ffc00
f0115d7b:	e8 8c 2f ff ff       	call   f0108d0c <kmalloc>
f0115d80:	83 c4 10             	add    $0x10,%esp
f0115d83:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115d89:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0115d8f:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0115d94:	74 17                	je     f0115dad <test_kmalloc+0x52f>
f0115d96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d9d:	83 ec 0c             	sub    $0xc,%esp
f0115da0:	68 d8 a2 12 f0       	push   $0xf012a2d8
f0115da5:	e8 e1 b1 fe ff       	call   f0100f8b <cprintf>
f0115daa:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115dad:	e8 b4 ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115db2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115db5:	74 17                	je     f0115dce <test_kmalloc+0x550>
f0115db7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115dbe:	83 ec 0c             	sub    $0xc,%esp
f0115dc1:	68 2c a3 12 f0       	push   $0xf012a32c
f0115dc6:	e8 c0 b1 fe ff       	call   f0100f8b <cprintf>
f0115dcb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115dce:	e8 29 79 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115dd3:	89 c2                	mov    %eax,%edx
f0115dd5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115dd8:	29 d0                	sub    %edx,%eax
f0115dda:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0115ddf:	7f 17                	jg     f0115df8 <test_kmalloc+0x57a>
f0115de1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115de8:	83 ec 0c             	sub    $0xc,%esp
f0115deb:	68 98 a3 12 f0       	push   $0xf012a398
f0115df0:	e8 96 b1 fe ff       	call   f0100f8b <cprintf>
f0115df5:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115df8:	e8 ff 78 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115dfd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115e00:	e8 61 ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115e05:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0115e08:	83 ec 0c             	sub    $0xc,%esp
f0115e0b:	68 00 38 00 00       	push   $0x3800
f0115e10:	e8 f7 2e ff ff       	call   f0108d0c <kmalloc>
f0115e15:	83 c4 10             	add    $0x10,%esp
f0115e18:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115e1e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0115e24:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0115e29:	74 17                	je     f0115e42 <test_kmalloc+0x5c4>
f0115e2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e32:	83 ec 0c             	sub    $0xc,%esp
f0115e35:	68 dc a3 12 f0       	push   $0xf012a3dc
f0115e3a:	e8 4c b1 fe ff       	call   f0100f8b <cprintf>
f0115e3f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115e42:	e8 1f ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115e47:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115e4a:	74 17                	je     f0115e63 <test_kmalloc+0x5e5>
f0115e4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e53:	83 ec 0c             	sub    $0xc,%esp
f0115e56:	68 30 a4 12 f0       	push   $0xf012a430
f0115e5b:	e8 2b b1 fe ff       	call   f0100f8b <cprintf>
f0115e60:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115e63:	e8 94 78 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115e68:	89 c2                	mov    %eax,%edx
f0115e6a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115e6d:	29 d0                	sub    %edx,%eax
f0115e6f:	83 f8 03             	cmp    $0x3,%eax
f0115e72:	7f 17                	jg     f0115e8b <test_kmalloc+0x60d>
f0115e74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e7b:	83 ec 0c             	sub    $0xc,%esp
f0115e7e:	68 9c a4 12 f0       	push   $0xf012a49c
f0115e83:	e8 03 b1 fe ff       	call   f0100f8b <cprintf>
f0115e88:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0115e8b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0115e8f:	74 04                	je     f0115e95 <test_kmalloc+0x617>
f0115e91:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0115e95:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0115e9c:	83 ec 0c             	sub    $0xc,%esp
f0115e9f:	68 e0 a4 12 f0       	push   $0xf012a4e0
f0115ea4:	e8 e2 b0 fe ff       	call   f0100f8b <cprintf>
f0115ea9:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0115eac:	e8 4b 78 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0115eb1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115eb4:	e8 ad e9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115eb9:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0115ebc:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0115ec3:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0115ec9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0115ecc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115ecf:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0115ed2:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0115ed4:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0115ed7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115eda:	01 c2                	add    %eax,%edx
f0115edc:	8a 45 ea             	mov    -0x16(%ebp),%al
f0115edf:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0115ee1:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0115ee7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0115eea:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0115ef1:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115ef4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0115ef7:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0115efa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115efd:	01 c0                	add    %eax,%eax
f0115eff:	89 c2                	mov    %eax,%edx
f0115f01:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115f04:	01 c2                	add    %eax,%edx
f0115f06:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0115f0a:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0115f0d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115f13:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0115f16:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0115f1d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115f20:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0115f23:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0115f25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115f28:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115f2f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115f32:	01 c2                	add    %eax,%edx
f0115f34:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115f37:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0115f39:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115f3f:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0115f42:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0115f49:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0115f4c:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0115f4f:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0115f51:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0115f54:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0115f57:	01 c2                	add    %eax,%edx
f0115f59:	8a 45 ea             	mov    -0x16(%ebp),%al
f0115f5c:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0115f5e:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0115f64:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0115f67:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0115f6e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115f71:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0115f74:	88 10                	mov    %dl,(%eax)
f0115f76:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0115f79:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0115f7c:	66 89 42 02          	mov    %ax,0x2(%edx)
f0115f80:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115f83:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0115f86:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0115f89:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115f8c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0115f93:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115f96:	01 c2                	add    %eax,%edx
f0115f98:	8a 45 ea             	mov    -0x16(%ebp),%al
f0115f9b:	88 02                	mov    %al,(%edx)
f0115f9d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115fa0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0115fa7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115faa:	01 c2                	add    %eax,%edx
f0115fac:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0115fb0:	66 89 42 02          	mov    %ax,0x2(%edx)
f0115fb4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115fb7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0115fbe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115fc1:	01 c2                	add    %eax,%edx
f0115fc3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115fc6:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0115fc9:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0115fd0:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0115fd6:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0115fd9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0115fdc:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0115fdf:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0115fe1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0115fe4:	89 c2                	mov    %eax,%edx
f0115fe6:	c1 ea 1f             	shr    $0x1f,%edx
f0115fe9:	01 d0                	add    %edx,%eax
f0115feb:	d1 f8                	sar    %eax
f0115fed:	89 c2                	mov    %eax,%edx
f0115fef:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0115ff2:	01 c2                	add    %eax,%edx
f0115ff4:	8a 45 ea             	mov    -0x16(%ebp),%al
f0115ff7:	88 c1                	mov    %al,%cl
f0115ff9:	c0 e9 07             	shr    $0x7,%cl
f0115ffc:	01 c8                	add    %ecx,%eax
f0115ffe:	d0 f8                	sar    %al
f0116000:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0116002:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116005:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116008:	01 c2                	add    %eax,%edx
f011600a:	8a 45 ea             	mov    -0x16(%ebp),%al
f011600d:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011600f:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116015:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0116018:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011601f:	8b 55 98             	mov    -0x68(%ebp),%edx
f0116022:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116025:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0116028:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011602b:	01 c0                	add    %eax,%eax
f011602d:	89 c2                	mov    %eax,%edx
f011602f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116032:	01 c2                	add    %eax,%edx
f0116034:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116038:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f011603b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011603e:	8a 00                	mov    (%eax),%al
f0116040:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116043:	75 0f                	jne    f0116054 <test_kmalloc+0x7d6>
f0116045:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116048:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011604b:	01 d0                	add    %edx,%eax
f011604d:	8a 00                	mov    (%eax),%al
f011604f:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116052:	74 17                	je     f011606b <test_kmalloc+0x7ed>
f0116054:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011605b:	83 ec 0c             	sub    $0xc,%esp
f011605e:	68 18 a5 12 f0       	push   $0xf012a518
f0116063:	e8 23 af fe ff       	call   f0100f8b <cprintf>
f0116068:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f011606b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011606e:	66 8b 00             	mov    (%eax),%ax
f0116071:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116075:	75 15                	jne    f011608c <test_kmalloc+0x80e>
f0116077:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011607a:	01 c0                	add    %eax,%eax
f011607c:	89 c2                	mov    %eax,%edx
f011607e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116081:	01 d0                	add    %edx,%eax
f0116083:	66 8b 00             	mov    (%eax),%ax
f0116086:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011608a:	74 17                	je     f01160a3 <test_kmalloc+0x825>
f011608c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116093:	83 ec 0c             	sub    $0xc,%esp
f0116096:	68 50 a5 12 f0       	push   $0xf012a550
f011609b:	e8 eb ae fe ff       	call   f0100f8b <cprintf>
f01160a0:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f01160a3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01160a6:	8b 00                	mov    (%eax),%eax
f01160a8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01160ab:	75 16                	jne    f01160c3 <test_kmalloc+0x845>
f01160ad:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01160b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01160b7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01160ba:	01 d0                	add    %edx,%eax
f01160bc:	8b 00                	mov    (%eax),%eax
f01160be:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01160c1:	74 17                	je     f01160da <test_kmalloc+0x85c>
f01160c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01160ca:	83 ec 0c             	sub    $0xc,%esp
f01160cd:	68 8c a5 12 f0       	push   $0xf012a58c
f01160d2:	e8 b4 ae fe ff       	call   f0100f8b <cprintf>
f01160d7:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f01160da:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01160dd:	8a 00                	mov    (%eax),%al
f01160df:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01160e2:	75 0f                	jne    f01160f3 <test_kmalloc+0x875>
f01160e4:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01160e7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01160ea:	01 d0                	add    %edx,%eax
f01160ec:	8a 00                	mov    (%eax),%al
f01160ee:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01160f1:	74 17                	je     f011610a <test_kmalloc+0x88c>
f01160f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01160fa:	83 ec 0c             	sub    $0xc,%esp
f01160fd:	68 c8 a5 12 f0       	push   $0xf012a5c8
f0116102:	e8 84 ae fe ff       	call   f0100f8b <cprintf>
f0116107:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f011610a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011610d:	8a 00                	mov    (%eax),%al
f011610f:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116112:	75 16                	jne    f011612a <test_kmalloc+0x8ac>
f0116114:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116117:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011611e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116121:	01 d0                	add    %edx,%eax
f0116123:	8a 00                	mov    (%eax),%al
f0116125:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116128:	74 17                	je     f0116141 <test_kmalloc+0x8c3>
f011612a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116131:	83 ec 0c             	sub    $0xc,%esp
f0116134:	68 04 a6 12 f0       	push   $0xf012a604
f0116139:	e8 4d ae fe ff       	call   f0100f8b <cprintf>
f011613e:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f0116141:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116144:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116148:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011614c:	75 19                	jne    f0116167 <test_kmalloc+0x8e9>
f011614e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116151:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116158:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011615b:	01 d0                	add    %edx,%eax
f011615d:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116161:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116165:	74 17                	je     f011617e <test_kmalloc+0x900>
f0116167:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011616e:	83 ec 0c             	sub    $0xc,%esp
f0116171:	68 40 a6 12 f0       	push   $0xf012a640
f0116176:	e8 10 ae fe ff       	call   f0100f8b <cprintf>
f011617b:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f011617e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116181:	8b 40 04             	mov    0x4(%eax),%eax
f0116184:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116187:	75 17                	jne    f01161a0 <test_kmalloc+0x922>
f0116189:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011618c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116193:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116196:	01 d0                	add    %edx,%eax
f0116198:	8b 40 04             	mov    0x4(%eax),%eax
f011619b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011619e:	74 17                	je     f01161b7 <test_kmalloc+0x939>
f01161a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01161a7:	83 ec 0c             	sub    $0xc,%esp
f01161aa:	68 7c a6 12 f0       	push   $0xf012a67c
f01161af:	e8 d7 ad fe ff       	call   f0100f8b <cprintf>
f01161b4:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01161b7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01161ba:	8a 00                	mov    (%eax),%al
f01161bc:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01161bf:	75 34                	jne    f01161f5 <test_kmalloc+0x977>
f01161c1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01161c4:	89 c2                	mov    %eax,%edx
f01161c6:	c1 ea 1f             	shr    $0x1f,%edx
f01161c9:	01 d0                	add    %edx,%eax
f01161cb:	d1 f8                	sar    %eax
f01161cd:	89 c2                	mov    %eax,%edx
f01161cf:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01161d2:	01 d0                	add    %edx,%eax
f01161d4:	8a 10                	mov    (%eax),%dl
f01161d6:	8a 45 ea             	mov    -0x16(%ebp),%al
f01161d9:	88 c1                	mov    %al,%cl
f01161db:	c0 e9 07             	shr    $0x7,%cl
f01161de:	01 c8                	add    %ecx,%eax
f01161e0:	d0 f8                	sar    %al
f01161e2:	38 c2                	cmp    %al,%dl
f01161e4:	75 0f                	jne    f01161f5 <test_kmalloc+0x977>
f01161e6:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01161e9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01161ec:	01 d0                	add    %edx,%eax
f01161ee:	8a 00                	mov    (%eax),%al
f01161f0:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01161f3:	74 17                	je     f011620c <test_kmalloc+0x98e>
f01161f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01161fc:	83 ec 0c             	sub    $0xc,%esp
f01161ff:	68 b8 a6 12 f0       	push   $0xf012a6b8
f0116204:	e8 82 ad fe ff       	call   f0100f8b <cprintf>
f0116209:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f011620c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011620f:	66 8b 00             	mov    (%eax),%ax
f0116212:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116216:	75 15                	jne    f011622d <test_kmalloc+0x9af>
f0116218:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011621b:	01 c0                	add    %eax,%eax
f011621d:	89 c2                	mov    %eax,%edx
f011621f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116222:	01 d0                	add    %edx,%eax
f0116224:	66 8b 00             	mov    (%eax),%ax
f0116227:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011622b:	74 17                	je     f0116244 <test_kmalloc+0x9c6>
f011622d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116234:	83 ec 0c             	sub    $0xc,%esp
f0116237:	68 f0 a6 12 f0       	push   $0xf012a6f0
f011623c:	e8 4a ad fe ff       	call   f0100f8b <cprintf>
f0116241:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116244:	e8 b3 74 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116249:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011624c:	74 17                	je     f0116265 <test_kmalloc+0x9e7>
f011624e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116255:	83 ec 0c             	sub    $0xc,%esp
f0116258:	68 2c a7 12 f0       	push   $0xf012a72c
f011625d:	e8 29 ad fe ff       	call   f0100f8b <cprintf>
f0116262:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116265:	e8 fc e5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011626a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011626d:	74 17                	je     f0116286 <test_kmalloc+0xa08>
f011626f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116276:	83 ec 0c             	sub    $0xc,%esp
f0116279:	68 70 a7 12 f0       	push   $0xf012a770
f011627e:	e8 08 ad fe ff       	call   f0100f8b <cprintf>
f0116283:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0116286:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011628a:	74 04                	je     f0116290 <test_kmalloc+0xa12>
f011628c:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0116290:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f0116297:	83 ec 0c             	sub    $0xc,%esp
f011629a:	68 dc a7 12 f0       	push   $0xf012a7dc
f011629f:	e8 e7 ac fe ff       	call   f0100f8b <cprintf>
f01162a4:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01162a7:	e8 50 74 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01162ac:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01162af:	e8 b2 e5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01162b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f01162b7:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f01162be:	8b 45 90             	mov    -0x70(%ebp),%eax
f01162c1:	40                   	inc    %eax
f01162c2:	83 ec 0c             	sub    $0xc,%esp
f01162c5:	50                   	push   %eax
f01162c6:	e8 41 2a ff ff       	call   f0108d0c <kmalloc>
f01162cb:	83 c4 10             	add    $0x10,%esp
f01162ce:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f01162d4:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f01162da:	85 c0                	test   %eax,%eax
f01162dc:	74 17                	je     f01162f5 <test_kmalloc+0xa77>
f01162de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01162e5:	83 ec 0c             	sub    $0xc,%esp
f01162e8:	68 00 a8 12 f0       	push   $0xf012a800
f01162ed:	e8 99 ac fe ff       	call   f0100f8b <cprintf>
f01162f2:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01162f5:	e8 6c e5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01162fa:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01162fd:	74 17                	je     f0116316 <test_kmalloc+0xa98>
f01162ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116306:	83 ec 0c             	sub    $0xc,%esp
f0116309:	68 38 a8 12 f0       	push   $0xf012a838
f011630e:	e8 78 ac fe ff       	call   f0100f8b <cprintf>
f0116313:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116316:	e8 e1 73 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011631b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011631e:	74 17                	je     f0116337 <test_kmalloc+0xab9>
f0116320:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116327:	83 ec 0c             	sub    $0xc,%esp
f011632a:	68 a4 a8 12 f0       	push   $0xf012a8a4
f011632f:	e8 57 ac fe ff       	call   f0100f8b <cprintf>
f0116334:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116337:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011633b:	74 04                	je     f0116341 <test_kmalloc+0xac3>
f011633d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116341:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0116348:	83 ec 0c             	sub    $0xc,%esp
f011634b:	68 e8 a8 12 f0       	push   $0xf012a8e8
f0116350:	e8 36 ac fe ff       	call   f0100f8b <cprintf>
f0116355:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0116358:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011635e:	05 00 40 00 00       	add    $0x4000,%eax
f0116363:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0116366:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f011636d:	eb 6a                	jmp    f01163d9 <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f011636f:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0116374:	83 ec 04             	sub    $0x4,%esp
f0116377:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f011637d:	52                   	push   %edx
f011637e:	ff 75 ec             	pushl  -0x14(%ebp)
f0116381:	50                   	push   %eax
f0116382:	e8 fd 1f ff ff       	call   f0108384 <get_page_table>
f0116387:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011638a:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0116390:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0116393:	c1 ea 0c             	shr    $0xc,%edx
f0116396:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011639c:	c1 e2 02             	shl    $0x2,%edx
f011639f:	01 d0                	add    %edx,%eax
f01163a1:	8b 00                	mov    (%eax),%eax
f01163a3:	25 ff 0f 00 00       	and    $0xfff,%eax
f01163a8:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f01163ab:	8b 45 88             	mov    -0x78(%ebp),%eax
f01163ae:	83 e0 04             	and    $0x4,%eax
f01163b1:	85 c0                	test   %eax,%eax
f01163b3:	74 1d                	je     f01163d2 <test_kmalloc+0xb54>
			{
				if (correct)
f01163b5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01163b9:	74 17                	je     f01163d2 <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f01163bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01163c2:	83 ec 0c             	sub    $0xc,%esp
f01163c5:	68 2c a9 12 f0       	push   $0xf012a92c
f01163ca:	e8 bc ab fe ff       	call   f0100f8b <cprintf>
f01163cf:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01163d2:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f01163d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01163dc:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01163df:	72 8e                	jb     f011636f <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f01163e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01163e5:	74 04                	je     f01163eb <test_kmalloc+0xb6d>
f01163e7:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f01163eb:	83 ec 08             	sub    $0x8,%esp
f01163ee:	ff 75 f4             	pushl  -0xc(%ebp)
f01163f1:	68 7c a9 12 f0       	push   $0xf012a97c
f01163f6:	e8 90 ab fe ff       	call   f0100f8b <cprintf>
f01163fb:	83 c4 10             	add    $0x10,%esp

	return 1;
f01163fe:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0116403:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0116406:	5b                   	pop    %ebx
f0116407:	5f                   	pop    %edi
f0116408:	5d                   	pop    %ebp
f0116409:	c3                   	ret    

f011640a <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f011640a:	55                   	push   %ebp
f011640b:	89 e5                	mov    %esp,%ebp
f011640d:	57                   	push   %edi
f011640e:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116411:	83 ec 0c             	sub    $0xc,%esp
f0116414:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0116419:	e8 6d ab fe ff       	call   f0100f8b <cprintf>
f011641e:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116421:	83 ec 0c             	sub    $0xc,%esp
f0116424:	68 18 9b 12 f0       	push   $0xf0129b18
f0116429:	e8 5d ab fe ff       	call   f0100f8b <cprintf>
f011642e:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116431:	83 ec 0c             	sub    $0xc,%esp
f0116434:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0116439:	e8 4d ab fe ff       	call   f0100f8b <cprintf>
f011643e:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0116441:	8d 55 98             	lea    -0x68(%ebp),%edx
f0116444:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116449:	b8 00 00 00 00       	mov    $0x0,%eax
f011644e:	89 d7                	mov    %edx,%edi
f0116450:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0116452:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116459:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0116460:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f0116467:	83 ec 0c             	sub    $0xc,%esp
f011646a:	68 a8 a9 12 f0       	push   $0xf012a9a8
f011646f:	e8 17 ab fe ff       	call   f0100f8b <cprintf>
f0116474:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116477:	e8 80 72 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011647c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011647f:	e8 e2 e3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116484:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0116487:	83 ec 0c             	sub    $0xc,%esp
f011648a:	68 00 fc 0f 00       	push   $0xffc00
f011648f:	e8 78 28 ff ff       	call   f0108d0c <kmalloc>
f0116494:	83 c4 10             	add    $0x10,%esp
f0116497:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f011649a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011649d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01164a2:	74 17                	je     f01164bb <test_kmalloc_firstfit1+0xb1>
f01164a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01164ab:	83 ec 0c             	sub    $0xc,%esp
f01164ae:	68 e8 a9 12 f0       	push   $0xf012a9e8
f01164b3:	e8 d3 aa fe ff       	call   f0100f8b <cprintf>
f01164b8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01164bb:	e8 a6 e3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01164c0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01164c3:	74 17                	je     f01164dc <test_kmalloc_firstfit1+0xd2>
f01164c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01164cc:	83 ec 0c             	sub    $0xc,%esp
f01164cf:	68 0c 9d 12 f0       	push   $0xf0129d0c
f01164d4:	e8 b2 aa fe ff       	call   f0100f8b <cprintf>
f01164d9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f01164dc:	e8 1b 72 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01164e1:	89 c2                	mov    %eax,%edx
f01164e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01164e6:	29 d0                	sub    %edx,%eax
f01164e8:	3d ff 00 00 00       	cmp    $0xff,%eax
f01164ed:	7f 17                	jg     f0116506 <test_kmalloc_firstfit1+0xfc>
f01164ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01164f6:	83 ec 0c             	sub    $0xc,%esp
f01164f9:	68 1b aa 12 f0       	push   $0xf012aa1b
f01164fe:	e8 88 aa fe ff       	call   f0100f8b <cprintf>
f0116503:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116506:	e8 f1 71 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011650b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011650e:	e8 53 e3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116513:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0116516:	83 ec 0c             	sub    $0xc,%esp
f0116519:	68 00 fc 0f 00       	push   $0xffc00
f011651e:	e8 e9 27 ff ff       	call   f0108d0c <kmalloc>
f0116523:	83 c4 10             	add    $0x10,%esp
f0116526:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0116529:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011652c:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0116531:	74 17                	je     f011654a <test_kmalloc_firstfit1+0x140>
f0116533:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011653a:	83 ec 0c             	sub    $0xc,%esp
f011653d:	68 34 aa 12 f0       	push   $0xf012aa34
f0116542:	e8 44 aa fe ff       	call   f0100f8b <cprintf>
f0116547:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011654a:	e8 17 e3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011654f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116552:	74 17                	je     f011656b <test_kmalloc_firstfit1+0x161>
f0116554:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011655b:	83 ec 0c             	sub    $0xc,%esp
f011655e:	68 10 9e 12 f0       	push   $0xf0129e10
f0116563:	e8 23 aa fe ff       	call   f0100f8b <cprintf>
f0116568:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f011656b:	e8 8c 71 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116570:	89 c2                	mov    %eax,%edx
f0116572:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116575:	29 d0                	sub    %edx,%eax
f0116577:	3d ff 00 00 00       	cmp    $0xff,%eax
f011657c:	7f 17                	jg     f0116595 <test_kmalloc_firstfit1+0x18b>
f011657e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116585:	83 ec 0c             	sub    $0xc,%esp
f0116588:	68 67 aa 12 f0       	push   $0xf012aa67
f011658d:	e8 f9 a9 fe ff       	call   f0100f8b <cprintf>
f0116592:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116595:	e8 62 71 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011659a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011659d:	e8 c4 e2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01165a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f01165a5:	83 ec 0c             	sub    $0xc,%esp
f01165a8:	68 00 fc 0f 00       	push   $0xffc00
f01165ad:	e8 5a 27 ff ff       	call   f0108d0c <kmalloc>
f01165b2:	83 c4 10             	add    $0x10,%esp
f01165b5:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01165b8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01165bb:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01165c0:	74 17                	je     f01165d9 <test_kmalloc_firstfit1+0x1cf>
f01165c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01165c9:	83 ec 0c             	sub    $0xc,%esp
f01165cc:	68 80 aa 12 f0       	push   $0xf012aa80
f01165d1:	e8 b5 a9 fe ff       	call   f0100f8b <cprintf>
f01165d6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01165d9:	e8 88 e2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01165de:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01165e1:	74 17                	je     f01165fa <test_kmalloc_firstfit1+0x1f0>
f01165e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01165ea:	83 ec 0c             	sub    $0xc,%esp
f01165ed:	68 4c 9f 12 f0       	push   $0xf0129f4c
f01165f2:	e8 94 a9 fe ff       	call   f0100f8b <cprintf>
f01165f7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01165fa:	e8 fd 70 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01165ff:	89 c2                	mov    %eax,%edx
f0116601:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116604:	29 d0                	sub    %edx,%eax
f0116606:	3d ff 00 00 00       	cmp    $0xff,%eax
f011660b:	7f 17                	jg     f0116624 <test_kmalloc_firstfit1+0x21a>
f011660d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116614:	83 ec 0c             	sub    $0xc,%esp
f0116617:	68 b3 aa 12 f0       	push   $0xf012aab3
f011661c:	e8 6a a9 fe ff       	call   f0100f8b <cprintf>
f0116621:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116624:	e8 d3 70 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116629:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011662c:	e8 35 e2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116631:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0116634:	83 ec 0c             	sub    $0xc,%esp
f0116637:	68 00 fc 0f 00       	push   $0xffc00
f011663c:	e8 cb 26 ff ff       	call   f0108d0c <kmalloc>
f0116641:	83 c4 10             	add    $0x10,%esp
f0116644:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0116647:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011664a:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011664f:	74 17                	je     f0116668 <test_kmalloc_firstfit1+0x25e>
f0116651:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116658:	83 ec 0c             	sub    $0xc,%esp
f011665b:	68 cc aa 12 f0       	push   $0xf012aacc
f0116660:	e8 26 a9 fe ff       	call   f0100f8b <cprintf>
f0116665:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116668:	e8 f9 e1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011666d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116670:	74 17                	je     f0116689 <test_kmalloc_firstfit1+0x27f>
f0116672:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116679:	83 ec 0c             	sub    $0xc,%esp
f011667c:	68 44 a0 12 f0       	push   $0xf012a044
f0116681:	e8 05 a9 fe ff       	call   f0100f8b <cprintf>
f0116686:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0116689:	e8 6e 70 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011668e:	89 c2                	mov    %eax,%edx
f0116690:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116693:	29 d0                	sub    %edx,%eax
f0116695:	3d ff 00 00 00       	cmp    $0xff,%eax
f011669a:	7f 17                	jg     f01166b3 <test_kmalloc_firstfit1+0x2a9>
f011669c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01166a3:	83 ec 0c             	sub    $0xc,%esp
f01166a6:	68 ff aa 12 f0       	push   $0xf012aaff
f01166ab:	e8 db a8 fe ff       	call   f0100f8b <cprintf>
f01166b0:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01166b3:	e8 44 70 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01166b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01166bb:	e8 a6 e1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01166c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f01166c3:	83 ec 0c             	sub    $0xc,%esp
f01166c6:	68 00 fc 1f 00       	push   $0x1ffc00
f01166cb:	e8 3c 26 ff ff       	call   f0108d0c <kmalloc>
f01166d0:	83 c4 10             	add    $0x10,%esp
f01166d3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f01166d6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01166d9:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01166de:	74 17                	je     f01166f7 <test_kmalloc_firstfit1+0x2ed>
f01166e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01166e7:	83 ec 0c             	sub    $0xc,%esp
f01166ea:	68 18 ab 12 f0       	push   $0xf012ab18
f01166ef:	e8 97 a8 fe ff       	call   f0100f8b <cprintf>
f01166f4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01166f7:	e8 6a e1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01166fc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01166ff:	74 17                	je     f0116718 <test_kmalloc_firstfit1+0x30e>
f0116701:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116708:	83 ec 0c             	sub    $0xc,%esp
f011670b:	68 24 a1 12 f0       	push   $0xf012a124
f0116710:	e8 76 a8 fe ff       	call   f0100f8b <cprintf>
f0116715:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0116718:	e8 df 6f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011671d:	89 c2                	mov    %eax,%edx
f011671f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116722:	29 d0                	sub    %edx,%eax
f0116724:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116729:	7f 17                	jg     f0116742 <test_kmalloc_firstfit1+0x338>
f011672b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116732:	83 ec 0c             	sub    $0xc,%esp
f0116735:	68 4b ab 12 f0       	push   $0xf012ab4b
f011673a:	e8 4c a8 fe ff       	call   f0100f8b <cprintf>
f011673f:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116742:	e8 b5 6f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116747:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011674a:	e8 17 e1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011674f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0116752:	83 ec 0c             	sub    $0xc,%esp
f0116755:	68 00 fc 1f 00       	push   $0x1ffc00
f011675a:	e8 ad 25 ff ff       	call   f0108d0c <kmalloc>
f011675f:	83 c4 10             	add    $0x10,%esp
f0116762:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0116765:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116768:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f011676d:	74 17                	je     f0116786 <test_kmalloc_firstfit1+0x37c>
f011676f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116776:	83 ec 0c             	sub    $0xc,%esp
f0116779:	68 64 ab 12 f0       	push   $0xf012ab64
f011677e:	e8 08 a8 fe ff       	call   f0100f8b <cprintf>
f0116783:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116786:	e8 db e0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011678b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011678e:	74 17                	je     f01167a7 <test_kmalloc_firstfit1+0x39d>
f0116790:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116797:	83 ec 0c             	sub    $0xc,%esp
f011679a:	68 28 a2 12 f0       	push   $0xf012a228
f011679f:	e8 e7 a7 fe ff       	call   f0100f8b <cprintf>
f01167a4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f01167a7:	e8 50 6f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01167ac:	89 c2                	mov    %eax,%edx
f01167ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01167b1:	29 d0                	sub    %edx,%eax
f01167b3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01167b8:	7f 17                	jg     f01167d1 <test_kmalloc_firstfit1+0x3c7>
f01167ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01167c1:	83 ec 0c             	sub    $0xc,%esp
f01167c4:	68 97 ab 12 f0       	push   $0xf012ab97
f01167c9:	e8 bd a7 fe ff       	call   f0100f8b <cprintf>
f01167ce:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01167d1:	e8 26 6f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01167d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01167d9:	e8 88 e0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01167de:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01167e1:	83 ec 0c             	sub    $0xc,%esp
f01167e4:	68 00 fc 2f 00       	push   $0x2ffc00
f01167e9:	e8 1e 25 ff ff       	call   f0108d0c <kmalloc>
f01167ee:	83 c4 10             	add    $0x10,%esp
f01167f1:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01167f4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01167f7:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01167fc:	74 17                	je     f0116815 <test_kmalloc_firstfit1+0x40b>
f01167fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116805:	83 ec 0c             	sub    $0xc,%esp
f0116808:	68 b0 ab 12 f0       	push   $0xf012abb0
f011680d:	e8 79 a7 fe ff       	call   f0100f8b <cprintf>
f0116812:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116815:	e8 4c e0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011681a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011681d:	74 17                	je     f0116836 <test_kmalloc_firstfit1+0x42c>
f011681f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116826:	83 ec 0c             	sub    $0xc,%esp
f0116829:	68 2c a3 12 f0       	push   $0xf012a32c
f011682e:	e8 58 a7 fe ff       	call   f0100f8b <cprintf>
f0116833:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0116836:	e8 c1 6e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011683b:	89 c2                	mov    %eax,%edx
f011683d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116840:	29 d0                	sub    %edx,%eax
f0116842:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116847:	7f 17                	jg     f0116860 <test_kmalloc_firstfit1+0x456>
f0116849:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116850:	83 ec 0c             	sub    $0xc,%esp
f0116853:	68 e3 ab 12 f0       	push   $0xf012abe3
f0116858:	e8 2e a7 fe ff       	call   f0100f8b <cprintf>
f011685d:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116860:	e8 97 6e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116865:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116868:	e8 f9 df fe ff       	call   f0104866 <pf_calculate_free_frames>
f011686d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0116870:	83 ec 0c             	sub    $0xc,%esp
f0116873:	68 00 fc 2f 00       	push   $0x2ffc00
f0116878:	e8 8f 24 ff ff       	call   f0108d0c <kmalloc>
f011687d:	83 c4 10             	add    $0x10,%esp
f0116880:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0116883:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116886:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f011688b:	74 17                	je     f01168a4 <test_kmalloc_firstfit1+0x49a>
f011688d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116894:	83 ec 0c             	sub    $0xc,%esp
f0116897:	68 fc ab 12 f0       	push   $0xf012abfc
f011689c:	e8 ea a6 fe ff       	call   f0100f8b <cprintf>
f01168a1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01168a4:	e8 bd df fe ff       	call   f0104866 <pf_calculate_free_frames>
f01168a9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01168ac:	74 17                	je     f01168c5 <test_kmalloc_firstfit1+0x4bb>
f01168ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168b5:	83 ec 0c             	sub    $0xc,%esp
f01168b8:	68 30 a4 12 f0       	push   $0xf012a430
f01168bd:	e8 c9 a6 fe ff       	call   f0100f8b <cprintf>
f01168c2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f01168c5:	e8 32 6e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01168ca:	89 c2                	mov    %eax,%edx
f01168cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01168cf:	29 d0                	sub    %edx,%eax
f01168d1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01168d6:	7f 17                	jg     f01168ef <test_kmalloc_firstfit1+0x4e5>
f01168d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168df:	83 ec 0c             	sub    $0xc,%esp
f01168e2:	68 2f ac 12 f0       	push   $0xf012ac2f
f01168e7:	e8 9f a6 fe ff       	call   f0100f8b <cprintf>
f01168ec:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01168ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01168f3:	74 04                	je     f01168f9 <test_kmalloc_firstfit1+0x4ef>
f01168f5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01168f9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0116900:	83 ec 0c             	sub    $0xc,%esp
f0116903:	68 48 ac 12 f0       	push   $0xf012ac48
f0116908:	e8 7e a6 fe ff       	call   f0100f8b <cprintf>
f011690d:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116910:	e8 e7 6d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116915:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116918:	e8 49 df fe ff       	call   f0104866 <pf_calculate_free_frames>
f011691d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0116920:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116923:	83 ec 0c             	sub    $0xc,%esp
f0116926:	50                   	push   %eax
f0116927:	e8 fa 23 ff ff       	call   f0108d26 <kfree>
f011692c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011692f:	e8 32 df fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116934:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116937:	74 17                	je     f0116950 <test_kmalloc_firstfit1+0x546>
f0116939:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116940:	83 ec 0c             	sub    $0xc,%esp
f0116943:	68 70 ac 12 f0       	push   $0xf012ac70
f0116948:	e8 3e a6 fe ff       	call   f0100f8b <cprintf>
f011694d:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0116950:	e8 a7 6d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116955:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116958:	3d ff 00 00 00       	cmp    $0xff,%eax
f011695d:	7f 17                	jg     f0116976 <test_kmalloc_firstfit1+0x56c>
f011695f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116966:	83 ec 0c             	sub    $0xc,%esp
f0116969:	68 db ac 12 f0       	push   $0xf012acdb
f011696e:	e8 18 a6 fe ff       	call   f0100f8b <cprintf>
f0116973:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116976:	e8 81 6d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011697b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011697e:	e8 e3 de fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116983:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0116986:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116989:	83 ec 0c             	sub    $0xc,%esp
f011698c:	50                   	push   %eax
f011698d:	e8 94 23 ff ff       	call   f0108d26 <kfree>
f0116992:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116995:	e8 cc de fe ff       	call   f0104866 <pf_calculate_free_frames>
f011699a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011699d:	74 17                	je     f01169b6 <test_kmalloc_firstfit1+0x5ac>
f011699f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169a6:	83 ec 0c             	sub    $0xc,%esp
f01169a9:	68 ec ac 12 f0       	push   $0xf012acec
f01169ae:	e8 d8 a5 fe ff       	call   f0100f8b <cprintf>
f01169b3:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f01169b6:	e8 41 6d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01169bb:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01169be:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01169c3:	7f 17                	jg     f01169dc <test_kmalloc_firstfit1+0x5d2>
f01169c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169cc:	83 ec 0c             	sub    $0xc,%esp
f01169cf:	68 58 ad 12 f0       	push   $0xf012ad58
f01169d4:	e8 b2 a5 fe ff       	call   f0100f8b <cprintf>
f01169d9:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01169dc:	e8 1b 6d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01169e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01169e4:	e8 7d de fe ff       	call   f0104866 <pf_calculate_free_frames>
f01169e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01169ec:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01169ef:	83 ec 0c             	sub    $0xc,%esp
f01169f2:	50                   	push   %eax
f01169f3:	e8 2e 23 ff ff       	call   f0108d26 <kfree>
f01169f8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01169fb:	e8 66 de fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116a00:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116a03:	74 17                	je     f0116a1c <test_kmalloc_firstfit1+0x612>
f0116a05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a0c:	83 ec 0c             	sub    $0xc,%esp
f0116a0f:	68 6c ad 12 f0       	push   $0xf012ad6c
f0116a14:	e8 72 a5 fe ff       	call   f0100f8b <cprintf>
f0116a19:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0116a1c:	e8 db 6c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116a21:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116a24:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116a29:	7f 17                	jg     f0116a42 <test_kmalloc_firstfit1+0x638>
f0116a2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a32:	83 ec 0c             	sub    $0xc,%esp
f0116a35:	68 d8 ad 12 f0       	push   $0xf012add8
f0116a3a:	e8 4c a5 fe ff       	call   f0100f8b <cprintf>
f0116a3f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116a42:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116a46:	74 04                	je     f0116a4c <test_kmalloc_firstfit1+0x642>
f0116a48:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116a4c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0116a53:	83 ec 0c             	sub    $0xc,%esp
f0116a56:	68 ec ad 12 f0       	push   $0xf012adec
f0116a5b:	e8 2b a5 fe ff       	call   f0100f8b <cprintf>
f0116a60:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116a63:	e8 94 6c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116a68:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116a6b:	e8 f6 dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116a70:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0116a73:	83 ec 0c             	sub    $0xc,%esp
f0116a76:	68 00 fc 07 00       	push   $0x7fc00
f0116a7b:	e8 8c 22 ff ff       	call   f0108d0c <kmalloc>
f0116a80:	83 c4 10             	add    $0x10,%esp
f0116a83:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0116a86:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116a89:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0116a8e:	74 17                	je     f0116aa7 <test_kmalloc_firstfit1+0x69d>
f0116a90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a97:	83 ec 0c             	sub    $0xc,%esp
f0116a9a:	68 18 ae 12 f0       	push   $0xf012ae18
f0116a9f:	e8 e7 a4 fe ff       	call   f0100f8b <cprintf>
f0116aa4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116aa7:	e8 ba dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116aac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116aaf:	74 17                	je     f0116ac8 <test_kmalloc_firstfit1+0x6be>
f0116ab1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ab8:	83 ec 0c             	sub    $0xc,%esp
f0116abb:	68 4c ae 12 f0       	push   $0xf012ae4c
f0116ac0:	e8 c6 a4 fe ff       	call   f0100f8b <cprintf>
f0116ac5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0116ac8:	e8 2f 6c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116acd:	89 c2                	mov    %eax,%edx
f0116acf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116ad2:	29 d0                	sub    %edx,%eax
f0116ad4:	83 f8 7f             	cmp    $0x7f,%eax
f0116ad7:	7f 17                	jg     f0116af0 <test_kmalloc_firstfit1+0x6e6>
f0116ad9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ae0:	83 ec 0c             	sub    $0xc,%esp
f0116ae3:	68 b8 ae 12 f0       	push   $0xf012aeb8
f0116ae8:	e8 9e a4 fe ff       	call   f0100f8b <cprintf>
f0116aed:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116af0:	e8 07 6c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116af5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116af8:	e8 69 dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116afd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0116b00:	83 ec 0c             	sub    $0xc,%esp
f0116b03:	68 00 fc 0f 00       	push   $0xffc00
f0116b08:	e8 ff 21 ff ff       	call   f0108d0c <kmalloc>
f0116b0d:	83 c4 10             	add    $0x10,%esp
f0116b10:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0116b13:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116b16:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116b1b:	74 17                	je     f0116b34 <test_kmalloc_firstfit1+0x72a>
f0116b1d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b24:	83 ec 0c             	sub    $0xc,%esp
f0116b27:	68 d0 ae 12 f0       	push   $0xf012aed0
f0116b2c:	e8 5a a4 fe ff       	call   f0100f8b <cprintf>
f0116b31:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116b34:	e8 2d dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116b39:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116b3c:	74 17                	je     f0116b55 <test_kmalloc_firstfit1+0x74b>
f0116b3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b45:	83 ec 0c             	sub    $0xc,%esp
f0116b48:	68 04 af 12 f0       	push   $0xf012af04
f0116b4d:	e8 39 a4 fe ff       	call   f0100f8b <cprintf>
f0116b52:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0116b55:	e8 a2 6b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116b5a:	89 c2                	mov    %eax,%edx
f0116b5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b5f:	29 d0                	sub    %edx,%eax
f0116b61:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116b66:	7f 17                	jg     f0116b7f <test_kmalloc_firstfit1+0x775>
f0116b68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b6f:	83 ec 0c             	sub    $0xc,%esp
f0116b72:	68 70 af 12 f0       	push   $0xf012af70
f0116b77:	e8 0f a4 fe ff       	call   f0100f8b <cprintf>
f0116b7c:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b7f:	e8 78 6b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116b84:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116b87:	e8 da dc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116b8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0116b8f:	83 ec 0c             	sub    $0xc,%esp
f0116b92:	68 00 fc 03 00       	push   $0x3fc00
f0116b97:	e8 70 21 ff ff       	call   f0108d0c <kmalloc>
f0116b9c:	83 c4 10             	add    $0x10,%esp
f0116b9f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0116ba2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ba5:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0116baa:	74 17                	je     f0116bc3 <test_kmalloc_firstfit1+0x7b9>
f0116bac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bb3:	83 ec 0c             	sub    $0xc,%esp
f0116bb6:	68 88 af 12 f0       	push   $0xf012af88
f0116bbb:	e8 cb a3 fe ff       	call   f0100f8b <cprintf>
f0116bc0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116bc3:	e8 9e dc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116bc8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116bcb:	74 17                	je     f0116be4 <test_kmalloc_firstfit1+0x7da>
f0116bcd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bd4:	83 ec 0c             	sub    $0xc,%esp
f0116bd7:	68 bc af 12 f0       	push   $0xf012afbc
f0116bdc:	e8 aa a3 fe ff       	call   f0100f8b <cprintf>
f0116be1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0116be4:	e8 13 6b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116be9:	89 c2                	mov    %eax,%edx
f0116beb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116bee:	29 d0                	sub    %edx,%eax
f0116bf0:	83 f8 3f             	cmp    $0x3f,%eax
f0116bf3:	7f 17                	jg     f0116c0c <test_kmalloc_firstfit1+0x802>
f0116bf5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bfc:	83 ec 0c             	sub    $0xc,%esp
f0116bff:	68 28 b0 12 f0       	push   $0xf012b028
f0116c04:	e8 82 a3 fe ff       	call   f0100f8b <cprintf>
f0116c09:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116c0c:	e8 eb 6a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116c11:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116c14:	e8 4d dc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116c19:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0116c1c:	83 ec 0c             	sub    $0xc,%esp
f0116c1f:	68 00 00 20 00       	push   $0x200000
f0116c24:	e8 e3 20 ff ff       	call   f0108d0c <kmalloc>
f0116c29:	83 c4 10             	add    $0x10,%esp
f0116c2c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0116c2f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116c32:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0116c37:	74 17                	je     f0116c50 <test_kmalloc_firstfit1+0x846>
f0116c39:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c40:	83 ec 0c             	sub    $0xc,%esp
f0116c43:	68 40 b0 12 f0       	push   $0xf012b040
f0116c48:	e8 3e a3 fe ff       	call   f0100f8b <cprintf>
f0116c4d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0116c50:	e8 a7 6a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116c55:	89 c2                	mov    %eax,%edx
f0116c57:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c5a:	29 d0                	sub    %edx,%eax
f0116c5c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116c61:	7f 17                	jg     f0116c7a <test_kmalloc_firstfit1+0x870>
f0116c63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c6a:	83 ec 0c             	sub    $0xc,%esp
f0116c6d:	68 74 b0 12 f0       	push   $0xf012b074
f0116c72:	e8 14 a3 fe ff       	call   f0100f8b <cprintf>
f0116c77:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116c7a:	e8 e7 db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116c7f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116c82:	74 17                	je     f0116c9b <test_kmalloc_firstfit1+0x891>
f0116c84:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c8b:	83 ec 0c             	sub    $0xc,%esp
f0116c8e:	68 8c b0 12 f0       	push   $0xf012b08c
f0116c93:	e8 f3 a2 fe ff       	call   f0100f8b <cprintf>
f0116c98:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0116c9b:	e8 5c 6a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116ca0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ca3:	e8 be db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116ca8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0116cab:	83 ec 0c             	sub    $0xc,%esp
f0116cae:	68 00 fc 3f 00       	push   $0x3ffc00
f0116cb3:	e8 54 20 ff ff       	call   f0108d0c <kmalloc>
f0116cb8:	83 c4 10             	add    $0x10,%esp
f0116cbb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0116cbe:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116cc1:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0116cc6:	74 17                	je     f0116cdf <test_kmalloc_firstfit1+0x8d5>
f0116cc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ccf:	83 ec 0c             	sub    $0xc,%esp
f0116cd2:	68 f8 b0 12 f0       	push   $0xf012b0f8
f0116cd7:	e8 af a2 fe ff       	call   f0100f8b <cprintf>
f0116cdc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116cdf:	e8 82 db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116ce4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116ce7:	74 17                	je     f0116d00 <test_kmalloc_firstfit1+0x8f6>
f0116ce9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116cf0:	83 ec 0c             	sub    $0xc,%esp
f0116cf3:	68 2c b1 12 f0       	push   $0xf012b12c
f0116cf8:	e8 8e a2 fe ff       	call   f0100f8b <cprintf>
f0116cfd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f0116d00:	e8 f7 69 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116d05:	89 c2                	mov    %eax,%edx
f0116d07:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116d0a:	29 d0                	sub    %edx,%eax
f0116d0c:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0116d11:	7f 17                	jg     f0116d2a <test_kmalloc_firstfit1+0x920>
f0116d13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d1a:	83 ec 0c             	sub    $0xc,%esp
f0116d1d:	68 98 b1 12 f0       	push   $0xf012b198
f0116d22:	e8 64 a2 fe ff       	call   f0100f8b <cprintf>
f0116d27:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0116d2a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116d2e:	74 04                	je     f0116d34 <test_kmalloc_firstfit1+0x92a>
f0116d30:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0116d34:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0116d3b:	83 ec 0c             	sub    $0xc,%esp
f0116d3e:	68 b0 b1 12 f0       	push   $0xf012b1b0
f0116d43:	e8 43 a2 fe ff       	call   f0100f8b <cprintf>
f0116d48:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116d4b:	e8 ac 69 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116d50:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116d53:	e8 0e db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116d58:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0116d5b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116d5e:	83 ec 0c             	sub    $0xc,%esp
f0116d61:	50                   	push   %eax
f0116d62:	e8 bf 1f ff ff       	call   f0108d26 <kfree>
f0116d67:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116d6a:	e8 f7 da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116d6f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116d72:	74 17                	je     f0116d8b <test_kmalloc_firstfit1+0x981>
f0116d74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d7b:	83 ec 0c             	sub    $0xc,%esp
f0116d7e:	68 70 a7 12 f0       	push   $0xf012a770
f0116d83:	e8 03 a2 fe ff       	call   f0100f8b <cprintf>
f0116d88:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0116d8b:	e8 6c 69 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116d90:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116d93:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116d98:	7f 17                	jg     f0116db1 <test_kmalloc_firstfit1+0x9a7>
f0116d9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116da1:	83 ec 0c             	sub    $0xc,%esp
f0116da4:	68 e4 b1 12 f0       	push   $0xf012b1e4
f0116da9:	e8 dd a1 fe ff       	call   f0100f8b <cprintf>
f0116dae:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0116db1:	e8 46 69 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116db6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116db9:	e8 a8 da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116dbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0116dc1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116dc4:	83 ec 0c             	sub    $0xc,%esp
f0116dc7:	50                   	push   %eax
f0116dc8:	e8 59 1f ff ff       	call   f0108d26 <kfree>
f0116dcd:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116dd0:	e8 91 da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116dd5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116dd8:	74 17                	je     f0116df1 <test_kmalloc_firstfit1+0x9e7>
f0116dda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116de1:	83 ec 0c             	sub    $0xc,%esp
f0116de4:	68 38 a8 12 f0       	push   $0xf012a838
f0116de9:	e8 9d a1 fe ff       	call   f0100f8b <cprintf>
f0116dee:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0116df1:	e8 06 69 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116df6:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116df9:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116dfe:	7f 17                	jg     f0116e17 <test_kmalloc_firstfit1+0xa0d>
f0116e00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e07:	83 ec 0c             	sub    $0xc,%esp
f0116e0a:	68 f5 b1 12 f0       	push   $0xf012b1f5
f0116e0f:	e8 77 a1 fe ff       	call   f0100f8b <cprintf>
f0116e14:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116e17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116e1b:	74 04                	je     f0116e21 <test_kmalloc_firstfit1+0xa17>
f0116e1d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116e21:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0116e28:	83 ec 0c             	sub    $0xc,%esp
f0116e2b:	68 08 b2 12 f0       	push   $0xf012b208
f0116e30:	e8 56 a1 fe ff       	call   f0100f8b <cprintf>
f0116e35:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e38:	e8 bf 68 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116e3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e40:	e8 21 da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116e45:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0116e48:	83 ec 0c             	sub    $0xc,%esp
f0116e4b:	68 00 00 10 00       	push   $0x100000
f0116e50:	e8 b7 1e ff ff       	call   f0108d0c <kmalloc>
f0116e55:	83 c4 10             	add    $0x10,%esp
f0116e58:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0116e5b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116e5e:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0116e63:	74 17                	je     f0116e7c <test_kmalloc_firstfit1+0xa72>
f0116e65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e6c:	83 ec 0c             	sub    $0xc,%esp
f0116e6f:	68 48 b2 12 f0       	push   $0xf012b248
f0116e74:	e8 12 a1 fe ff       	call   f0100f8b <cprintf>
f0116e79:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e7c:	e8 e5 d9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116e81:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116e84:	74 17                	je     f0116e9d <test_kmalloc_firstfit1+0xa93>
f0116e86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e8d:	83 ec 0c             	sub    $0xc,%esp
f0116e90:	68 7c b2 12 f0       	push   $0xf012b27c
f0116e95:	e8 f1 a0 fe ff       	call   f0100f8b <cprintf>
f0116e9a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0116e9d:	e8 5a 68 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116ea2:	89 c2                	mov    %eax,%edx
f0116ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116ea7:	29 d0                	sub    %edx,%eax
f0116ea9:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116eae:	7f 17                	jg     f0116ec7 <test_kmalloc_firstfit1+0xabd>
f0116eb0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eb7:	83 ec 0c             	sub    $0xc,%esp
f0116eba:	68 e8 b2 12 f0       	push   $0xf012b2e8
f0116ebf:	e8 c7 a0 fe ff       	call   f0100f8b <cprintf>
f0116ec4:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0116ec7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116ecb:	74 04                	je     f0116ed1 <test_kmalloc_firstfit1+0xac7>
f0116ecd:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0116ed1:	83 ec 08             	sub    $0x8,%esp
f0116ed4:	ff 75 f4             	pushl  -0xc(%ebp)
f0116ed7:	68 00 b3 12 f0       	push   $0xf012b300
f0116edc:	e8 aa a0 fe ff       	call   f0100f8b <cprintf>
f0116ee1:	83 c4 10             	add    $0x10,%esp

	return 1;
f0116ee4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116ee9:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0116eec:	c9                   	leave  
f0116eed:	c3                   	ret    

f0116eee <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0116eee:	55                   	push   %ebp
f0116eef:	89 e5                	mov    %esp,%ebp
f0116ef1:	57                   	push   %edi
f0116ef2:	53                   	push   %ebx
f0116ef3:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116ef6:	83 ec 0c             	sub    $0xc,%esp
f0116ef9:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0116efe:	e8 88 a0 fe ff       	call   f0100f8b <cprintf>
f0116f03:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116f06:	83 ec 0c             	sub    $0xc,%esp
f0116f09:	68 18 9b 12 f0       	push   $0xf0129b18
f0116f0e:	e8 78 a0 fe ff       	call   f0100f8b <cprintf>
f0116f13:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116f16:	83 ec 0c             	sub    $0xc,%esp
f0116f19:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0116f1e:	e8 68 a0 fe ff       	call   f0100f8b <cprintf>
f0116f23:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0116f26:	8d 55 98             	lea    -0x68(%ebp),%edx
f0116f29:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116f2e:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f33:	89 d7                	mov    %edx,%edi
f0116f35:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0116f37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116f3e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0116f45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0116f4c:	83 ec 0c             	sub    $0xc,%esp
f0116f4f:	68 38 b3 12 f0       	push   $0xf012b338
f0116f54:	e8 32 a0 fe ff       	call   f0100f8b <cprintf>
f0116f59:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0116f5c:	83 ec 0c             	sub    $0xc,%esp
f0116f5f:	68 01 e0 ff 07       	push   $0x7ffe001
f0116f64:	e8 a3 1d ff ff       	call   f0108d0c <kmalloc>
f0116f69:	83 c4 10             	add    $0x10,%esp
f0116f6c:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0116f6f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116f72:	85 c0                	test   %eax,%eax
f0116f74:	74 17                	je     f0116f8d <test_kmalloc_firstfit2+0x9f>
f0116f76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f7d:	83 ec 0c             	sub    $0xc,%esp
f0116f80:	68 6c b3 12 f0       	push   $0xf012b36c
f0116f85:	e8 01 a0 fe ff       	call   f0100f8b <cprintf>
f0116f8a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116f8d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116f91:	74 04                	je     f0116f97 <test_kmalloc_firstfit2+0xa9>
f0116f93:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116f97:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0116f9e:	83 ec 0c             	sub    $0xc,%esp
f0116fa1:	68 b4 b3 12 f0       	push   $0xf012b3b4
f0116fa6:	e8 e0 9f fe ff       	call   f0100f8b <cprintf>
f0116fab:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116fae:	e8 49 67 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0116fb3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116fb6:	e8 ab d8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116fbb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0116fbe:	83 ec 0c             	sub    $0xc,%esp
f0116fc1:	68 00 fc 1f 00       	push   $0x1ffc00
f0116fc6:	e8 41 1d ff ff       	call   f0108d0c <kmalloc>
f0116fcb:	83 c4 10             	add    $0x10,%esp
f0116fce:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0116fd1:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116fd4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0116fd9:	74 17                	je     f0116ff2 <test_kmalloc_firstfit2+0x104>
f0116fdb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fe2:	83 ec 0c             	sub    $0xc,%esp
f0116fe5:	68 34 aa 12 f0       	push   $0xf012aa34
f0116fea:	e8 9c 9f fe ff       	call   f0100f8b <cprintf>
f0116fef:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116ff2:	e8 6f d8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116ff7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116ffa:	74 17                	je     f0117013 <test_kmalloc_firstfit2+0x125>
f0116ffc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117003:	83 ec 0c             	sub    $0xc,%esp
f0117006:	68 10 9e 12 f0       	push   $0xf0129e10
f011700b:	e8 7b 9f fe ff       	call   f0100f8b <cprintf>
f0117010:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117013:	e8 e4 66 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117018:	89 c2                	mov    %eax,%edx
f011701a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011701d:	29 d0                	sub    %edx,%eax
f011701f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117024:	7f 17                	jg     f011703d <test_kmalloc_firstfit2+0x14f>
f0117026:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011702d:	83 ec 0c             	sub    $0xc,%esp
f0117030:	68 67 aa 12 f0       	push   $0xf012aa67
f0117035:	e8 51 9f fe ff       	call   f0100f8b <cprintf>
f011703a:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011703d:	e8 ba 66 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117042:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117045:	e8 1c d8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011704a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011704d:	83 ec 0c             	sub    $0xc,%esp
f0117050:	68 00 fc 1f 00       	push   $0x1ffc00
f0117055:	e8 b2 1c ff ff       	call   f0108d0c <kmalloc>
f011705a:	83 c4 10             	add    $0x10,%esp
f011705d:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117060:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117063:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117068:	74 17                	je     f0117081 <test_kmalloc_firstfit2+0x193>
f011706a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117071:	83 ec 0c             	sub    $0xc,%esp
f0117074:	68 80 aa 12 f0       	push   $0xf012aa80
f0117079:	e8 0d 9f fe ff       	call   f0100f8b <cprintf>
f011707e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117081:	e8 e0 d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117086:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117089:	74 17                	je     f01170a2 <test_kmalloc_firstfit2+0x1b4>
f011708b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117092:	83 ec 0c             	sub    $0xc,%esp
f0117095:	68 4c 9f 12 f0       	push   $0xf0129f4c
f011709a:	e8 ec 9e fe ff       	call   f0100f8b <cprintf>
f011709f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01170a2:	e8 55 66 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01170a7:	89 c2                	mov    %eax,%edx
f01170a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01170ac:	29 d0                	sub    %edx,%eax
f01170ae:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01170b3:	7f 17                	jg     f01170cc <test_kmalloc_firstfit2+0x1de>
f01170b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170bc:	83 ec 0c             	sub    $0xc,%esp
f01170bf:	68 b3 aa 12 f0       	push   $0xf012aab3
f01170c4:	e8 c2 9e fe ff       	call   f0100f8b <cprintf>
f01170c9:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01170cc:	e8 2b 66 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01170d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01170d4:	e8 8d d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01170d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f01170dc:	83 ec 0c             	sub    $0xc,%esp
f01170df:	68 00 1c 00 00       	push   $0x1c00
f01170e4:	e8 23 1c ff ff       	call   f0108d0c <kmalloc>
f01170e9:	83 c4 10             	add    $0x10,%esp
f01170ec:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01170ef:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01170f2:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01170f7:	74 17                	je     f0117110 <test_kmalloc_firstfit2+0x222>
f01170f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117100:	83 ec 0c             	sub    $0xc,%esp
f0117103:	68 cc aa 12 f0       	push   $0xf012aacc
f0117108:	e8 7e 9e fe ff       	call   f0100f8b <cprintf>
f011710d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117110:	e8 51 d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117115:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117118:	74 17                	je     f0117131 <test_kmalloc_firstfit2+0x243>
f011711a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117121:	83 ec 0c             	sub    $0xc,%esp
f0117124:	68 44 a0 12 f0       	push   $0xf012a044
f0117129:	e8 5d 9e fe ff       	call   f0100f8b <cprintf>
f011712e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117131:	e8 c6 65 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117136:	89 c2                	mov    %eax,%edx
f0117138:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011713b:	29 d0                	sub    %edx,%eax
f011713d:	83 f8 01             	cmp    $0x1,%eax
f0117140:	7f 17                	jg     f0117159 <test_kmalloc_firstfit2+0x26b>
f0117142:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117149:	83 ec 0c             	sub    $0xc,%esp
f011714c:	68 ff aa 12 f0       	push   $0xf012aaff
f0117151:	e8 35 9e fe ff       	call   f0100f8b <cprintf>
f0117156:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117159:	e8 9e 65 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011715e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117161:	e8 00 d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117166:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0117169:	8b 45 98             	mov    -0x68(%ebp),%eax
f011716c:	83 ec 0c             	sub    $0xc,%esp
f011716f:	50                   	push   %eax
f0117170:	e8 b1 1b ff ff       	call   f0108d26 <kfree>
f0117175:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117178:	e8 e9 d6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011717d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117180:	74 17                	je     f0117199 <test_kmalloc_firstfit2+0x2ab>
f0117182:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117189:	83 ec 0c             	sub    $0xc,%esp
f011718c:	68 24 a1 12 f0       	push   $0xf012a124
f0117191:	e8 f5 9d fe ff       	call   f0100f8b <cprintf>
f0117196:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0117199:	e8 5e 65 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011719e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01171a1:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01171a6:	7f 17                	jg     f01171bf <test_kmalloc_firstfit2+0x2d1>
f01171a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171af:	83 ec 0c             	sub    $0xc,%esp
f01171b2:	68 fa b3 12 f0       	push   $0xf012b3fa
f01171b7:	e8 cf 9d fe ff       	call   f0100f8b <cprintf>
f01171bc:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01171bf:	e8 38 65 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01171c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171c7:	e8 9a d6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01171cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01171cf:	83 ec 0c             	sub    $0xc,%esp
f01171d2:	68 00 fc 2f 00       	push   $0x2ffc00
f01171d7:	e8 30 1b ff ff       	call   f0108d0c <kmalloc>
f01171dc:	83 c4 10             	add    $0x10,%esp
f01171df:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f01171e2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01171e5:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01171ea:	74 17                	je     f0117203 <test_kmalloc_firstfit2+0x315>
f01171ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171f3:	83 ec 0c             	sub    $0xc,%esp
f01171f6:	68 64 ab 12 f0       	push   $0xf012ab64
f01171fb:	e8 8b 9d fe ff       	call   f0100f8b <cprintf>
f0117200:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117203:	e8 5e d6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117208:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011720b:	74 17                	je     f0117224 <test_kmalloc_firstfit2+0x336>
f011720d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117214:	83 ec 0c             	sub    $0xc,%esp
f0117217:	68 28 a2 12 f0       	push   $0xf012a228
f011721c:	e8 6a 9d fe ff       	call   f0100f8b <cprintf>
f0117221:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117224:	e8 d3 64 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117229:	89 c2                	mov    %eax,%edx
f011722b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011722e:	29 d0                	sub    %edx,%eax
f0117230:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117235:	7f 17                	jg     f011724e <test_kmalloc_firstfit2+0x360>
f0117237:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011723e:	83 ec 0c             	sub    $0xc,%esp
f0117241:	68 97 ab 12 f0       	push   $0xf012ab97
f0117246:	e8 40 9d fe ff       	call   f0100f8b <cprintf>
f011724b:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011724e:	e8 a9 64 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117253:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117256:	e8 0b d6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011725b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f011725e:	83 ec 0c             	sub    $0xc,%esp
f0117261:	68 00 18 20 00       	push   $0x201800
f0117266:	e8 a1 1a ff ff       	call   f0108d0c <kmalloc>
f011726b:	83 c4 10             	add    $0x10,%esp
f011726e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117271:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117274:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0117279:	74 17                	je     f0117292 <test_kmalloc_firstfit2+0x3a4>
f011727b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117282:	83 ec 0c             	sub    $0xc,%esp
f0117285:	68 b0 ab 12 f0       	push   $0xf012abb0
f011728a:	e8 fc 9c fe ff       	call   f0100f8b <cprintf>
f011728f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117292:	e8 cf d5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117297:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011729a:	74 17                	je     f01172b3 <test_kmalloc_firstfit2+0x3c5>
f011729c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172a3:	83 ec 0c             	sub    $0xc,%esp
f01172a6:	68 2c a3 12 f0       	push   $0xf012a32c
f01172ab:	e8 db 9c fe ff       	call   f0100f8b <cprintf>
f01172b0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01172b3:	e8 44 64 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01172b8:	89 c2                	mov    %eax,%edx
f01172ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01172bd:	29 d0                	sub    %edx,%eax
f01172bf:	3d 01 02 00 00       	cmp    $0x201,%eax
f01172c4:	7f 17                	jg     f01172dd <test_kmalloc_firstfit2+0x3ef>
f01172c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172cd:	83 ec 0c             	sub    $0xc,%esp
f01172d0:	68 e3 ab 12 f0       	push   $0xf012abe3
f01172d5:	e8 b1 9c fe ff       	call   f0100f8b <cprintf>
f01172da:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01172dd:	e8 1a 64 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01172e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172e5:	e8 7c d5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01172ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01172ed:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01172f0:	83 ec 0c             	sub    $0xc,%esp
f01172f3:	50                   	push   %eax
f01172f4:	e8 2d 1a ff ff       	call   f0108d26 <kfree>
f01172f9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172fc:	e8 65 d5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117301:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117304:	74 17                	je     f011731d <test_kmalloc_firstfit2+0x42f>
f0117306:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011730d:	83 ec 0c             	sub    $0xc,%esp
f0117310:	68 30 a4 12 f0       	push   $0xf012a430
f0117315:	e8 71 9c fe ff       	call   f0100f8b <cprintf>
f011731a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f011731d:	e8 da 63 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117322:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117325:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011732a:	7f 17                	jg     f0117343 <test_kmalloc_firstfit2+0x455>
f011732c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117333:	83 ec 0c             	sub    $0xc,%esp
f0117336:	68 0a b4 12 f0       	push   $0xf012b40a
f011733b:	e8 4b 9c fe ff       	call   f0100f8b <cprintf>
f0117340:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0117343:	e8 b4 63 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117348:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011734b:	e8 16 d5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117350:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117353:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117356:	83 ec 0c             	sub    $0xc,%esp
f0117359:	50                   	push   %eax
f011735a:	e8 c7 19 ff ff       	call   f0108d26 <kfree>
f011735f:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117362:	e8 95 63 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117367:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011736a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011736f:	7f 17                	jg     f0117388 <test_kmalloc_firstfit2+0x49a>
f0117371:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117378:	83 ec 0c             	sub    $0xc,%esp
f011737b:	68 db ac 12 f0       	push   $0xf012acdb
f0117380:	e8 06 9c fe ff       	call   f0100f8b <cprintf>
f0117385:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117388:	e8 d9 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011738d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117390:	74 17                	je     f01173a9 <test_kmalloc_firstfit2+0x4bb>
f0117392:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117399:	83 ec 0c             	sub    $0xc,%esp
f011739c:	68 70 ac 12 f0       	push   $0xf012ac70
f01173a1:	e8 e5 9b fe ff       	call   f0100f8b <cprintf>
f01173a6:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01173a9:	e8 4e 63 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01173ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01173b1:	e8 b0 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01173b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f01173b9:	83 ec 0c             	sub    $0xc,%esp
f01173bc:	68 00 fc 4f 00       	push   $0x4ffc00
f01173c1:	e8 46 19 ff ff       	call   f0108d0c <kmalloc>
f01173c6:	83 c4 10             	add    $0x10,%esp
f01173c9:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f01173cc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01173cf:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f01173d4:	74 17                	je     f01173ed <test_kmalloc_firstfit2+0x4ff>
f01173d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173dd:	83 ec 0c             	sub    $0xc,%esp
f01173e0:	68 1c b4 12 f0       	push   $0xf012b41c
f01173e5:	e8 a1 9b fe ff       	call   f0100f8b <cprintf>
f01173ea:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173ed:	e8 74 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01173f2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01173f5:	74 17                	je     f011740e <test_kmalloc_firstfit2+0x520>
f01173f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173fe:	83 ec 0c             	sub    $0xc,%esp
f0117401:	68 ec ac 12 f0       	push   $0xf012acec
f0117406:	e8 80 9b fe ff       	call   f0100f8b <cprintf>
f011740b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f011740e:	e8 e9 62 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117413:	89 c2                	mov    %eax,%edx
f0117415:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117418:	29 d0                	sub    %edx,%eax
f011741a:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f011741f:	7f 17                	jg     f0117438 <test_kmalloc_firstfit2+0x54a>
f0117421:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117428:	83 ec 0c             	sub    $0xc,%esp
f011742b:	68 50 b4 12 f0       	push   $0xf012b450
f0117430:	e8 56 9b fe ff       	call   f0100f8b <cprintf>
f0117435:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0117438:	e8 bf 62 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011743d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117440:	e8 21 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117445:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0117448:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011744b:	83 ec 0c             	sub    $0xc,%esp
f011744e:	50                   	push   %eax
f011744f:	e8 d2 18 ff ff       	call   f0108d26 <kfree>
f0117454:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117457:	e8 0a d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011745c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011745f:	74 17                	je     f0117478 <test_kmalloc_firstfit2+0x58a>
f0117461:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117468:	83 ec 0c             	sub    $0xc,%esp
f011746b:	68 6c ad 12 f0       	push   $0xf012ad6c
f0117470:	e8 16 9b fe ff       	call   f0100f8b <cprintf>
f0117475:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0117478:	e8 7f 62 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011747d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117480:	83 f8 01             	cmp    $0x1,%eax
f0117483:	7f 17                	jg     f011749c <test_kmalloc_firstfit2+0x5ae>
f0117485:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011748c:	83 ec 0c             	sub    $0xc,%esp
f011748f:	68 d8 ad 12 f0       	push   $0xf012add8
f0117494:	e8 f2 9a fe ff       	call   f0100f8b <cprintf>
f0117499:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f011749c:	e8 5b 62 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01174a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174a4:	e8 bd d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01174a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f01174ac:	83 ec 0c             	sub    $0xc,%esp
f01174af:	68 00 04 00 00       	push   $0x400
f01174b4:	e8 53 18 ff ff       	call   f0108d0c <kmalloc>
f01174b9:	83 c4 10             	add    $0x10,%esp
f01174bc:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01174bf:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01174c2:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01174c7:	76 22                	jbe    f01174eb <test_kmalloc_firstfit2+0x5fd>
f01174c9:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f01174cc:	83 ec 0c             	sub    $0xc,%esp
f01174cf:	6a 00                	push   $0x0
f01174d1:	e8 28 17 ff ff       	call   f0108bfe <sbrk>
f01174d6:	83 c4 10             	add    $0x10,%esp
f01174d9:	39 c3                	cmp    %eax,%ebx
f01174db:	73 0e                	jae    f01174eb <test_kmalloc_firstfit2+0x5fd>
f01174dd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01174e0:	89 c2                	mov    %eax,%edx
f01174e2:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f01174e7:	39 c2                	cmp    %eax,%edx
f01174e9:	72 17                	jb     f0117502 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01174eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174f2:	83 ec 0c             	sub    $0xc,%esp
f01174f5:	68 68 b4 12 f0       	push   $0xf012b468
f01174fa:	e8 8c 9a fe ff       	call   f0100f8b <cprintf>
f01174ff:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117502:	e8 5f d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117507:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011750a:	74 17                	je     f0117523 <test_kmalloc_firstfit2+0x635>
f011750c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117513:	83 ec 0c             	sub    $0xc,%esp
f0117516:	68 4c ae 12 f0       	push   $0xf012ae4c
f011751b:	e8 6b 9a fe ff       	call   f0100f8b <cprintf>
f0117520:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117523:	e8 3e d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117528:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011752b:	83 ec 0c             	sub    $0xc,%esp
f011752e:	68 00 08 00 00       	push   $0x800
f0117533:	e8 d4 17 ff ff       	call   f0108d0c <kmalloc>
f0117538:	83 c4 10             	add    $0x10,%esp
f011753b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011753e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117541:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117546:	76 22                	jbe    f011756a <test_kmalloc_firstfit2+0x67c>
f0117548:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011754b:	83 ec 0c             	sub    $0xc,%esp
f011754e:	6a 00                	push   $0x0
f0117550:	e8 a9 16 ff ff       	call   f0108bfe <sbrk>
f0117555:	83 c4 10             	add    $0x10,%esp
f0117558:	39 c3                	cmp    %eax,%ebx
f011755a:	73 0e                	jae    f011756a <test_kmalloc_firstfit2+0x67c>
f011755c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011755f:	89 c2                	mov    %eax,%edx
f0117561:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0117566:	39 c2                	cmp    %eax,%edx
f0117568:	72 17                	jb     f0117581 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011756a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117571:	83 ec 0c             	sub    $0xc,%esp
f0117574:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0117579:	e8 0d 9a fe ff       	call   f0100f8b <cprintf>
f011757e:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117581:	e8 e0 d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117586:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117589:	74 17                	je     f01175a2 <test_kmalloc_firstfit2+0x6b4>
f011758b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117592:	83 ec 0c             	sub    $0xc,%esp
f0117595:	68 04 af 12 f0       	push   $0xf012af04
f011759a:	e8 ec 99 fe ff       	call   f0100f8b <cprintf>
f011759f:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01175a2:	e8 bf d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01175a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f01175aa:	83 ec 0c             	sub    $0xc,%esp
f01175ad:	68 00 04 00 00       	push   $0x400
f01175b2:	e8 55 17 ff ff       	call   f0108d0c <kmalloc>
f01175b7:	83 c4 10             	add    $0x10,%esp
f01175ba:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f01175bd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175c0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01175c5:	76 22                	jbe    f01175e9 <test_kmalloc_firstfit2+0x6fb>
f01175c7:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f01175ca:	83 ec 0c             	sub    $0xc,%esp
f01175cd:	6a 00                	push   $0x0
f01175cf:	e8 2a 16 ff ff       	call   f0108bfe <sbrk>
f01175d4:	83 c4 10             	add    $0x10,%esp
f01175d7:	39 c3                	cmp    %eax,%ebx
f01175d9:	73 0e                	jae    f01175e9 <test_kmalloc_firstfit2+0x6fb>
f01175db:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175de:	89 c2                	mov    %eax,%edx
f01175e0:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f01175e5:	39 c2                	cmp    %eax,%edx
f01175e7:	72 17                	jb     f0117600 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01175e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175f0:	83 ec 0c             	sub    $0xc,%esp
f01175f3:	68 80 b5 12 f0       	push   $0xf012b580
f01175f8:	e8 8e 99 fe ff       	call   f0100f8b <cprintf>
f01175fd:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117600:	e8 61 d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117605:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117608:	74 17                	je     f0117621 <test_kmalloc_firstfit2+0x733>
f011760a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117611:	83 ec 0c             	sub    $0xc,%esp
f0117614:	68 bc af 12 f0       	push   $0xf012afbc
f0117619:	e8 6d 99 fe ff       	call   f0100f8b <cprintf>
f011761e:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0117621:	e8 d6 60 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117626:	89 c2                	mov    %eax,%edx
f0117628:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011762b:	29 d0                	sub    %edx,%eax
f011762d:	83 f8 01             	cmp    $0x1,%eax
f0117630:	74 17                	je     f0117649 <test_kmalloc_firstfit2+0x75b>
f0117632:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117639:	83 ec 0c             	sub    $0xc,%esp
f011763c:	68 0c b6 12 f0       	push   $0xf012b60c
f0117641:	e8 45 99 fe ff       	call   f0100f8b <cprintf>
f0117646:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0117649:	e8 ae 60 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011764e:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117651:	e8 10 d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117656:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0117659:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011765c:	83 ec 0c             	sub    $0xc,%esp
f011765f:	50                   	push   %eax
f0117660:	e8 c1 16 ff ff       	call   f0108d26 <kfree>
f0117665:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117668:	e8 f9 d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011766d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117670:	74 17                	je     f0117689 <test_kmalloc_firstfit2+0x79b>
f0117672:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117679:	83 ec 0c             	sub    $0xc,%esp
f011767c:	68 8c b0 12 f0       	push   $0xf012b08c
f0117681:	e8 05 99 fe ff       	call   f0100f8b <cprintf>
f0117686:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0117689:	e8 6e 60 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011768e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117691:	74 17                	je     f01176aa <test_kmalloc_firstfit2+0x7bc>
f0117693:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011769a:	83 ec 0c             	sub    $0xc,%esp
f011769d:	68 30 b6 12 f0       	push   $0xf012b630
f01176a2:	e8 e4 98 fe ff       	call   f0100f8b <cprintf>
f01176a7:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f01176aa:	e8 4d 60 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01176af:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176b2:	e8 af d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01176b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f01176ba:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01176bd:	83 ec 0c             	sub    $0xc,%esp
f01176c0:	50                   	push   %eax
f01176c1:	e8 60 16 ff ff       	call   f0108d26 <kfree>
f01176c6:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176c9:	e8 98 d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01176ce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01176d1:	74 17                	je     f01176ea <test_kmalloc_firstfit2+0x7fc>
f01176d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176da:	83 ec 0c             	sub    $0xc,%esp
f01176dd:	68 2c b1 12 f0       	push   $0xf012b12c
f01176e2:	e8 a4 98 fe ff       	call   f0100f8b <cprintf>
f01176e7:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01176ea:	e8 0d 60 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01176ef:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01176f2:	74 17                	je     f011770b <test_kmalloc_firstfit2+0x81d>
f01176f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176fb:	83 ec 0c             	sub    $0xc,%esp
f01176fe:	68 90 b6 12 f0       	push   $0xf012b690
f0117703:	e8 83 98 fe ff       	call   f0100f8b <cprintf>
f0117708:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f011770b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011770f:	74 04                	je     f0117715 <test_kmalloc_firstfit2+0x827>
f0117711:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0117715:	83 ec 0c             	sub    $0xc,%esp
f0117718:	68 f0 b6 12 f0       	push   $0xf012b6f0
f011771d:	e8 69 98 fe ff       	call   f0100f8b <cprintf>
f0117722:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117725:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011772c:	e8 cb 5f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117731:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117734:	e8 2d d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117739:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f011773c:	83 ec 0c             	sub    $0xc,%esp
f011773f:	68 00 08 00 00       	push   $0x800
f0117744:	e8 c3 15 ff ff       	call   f0108d0c <kmalloc>
f0117749:	83 c4 10             	add    $0x10,%esp
f011774c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f011774f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0117752:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117755:	39 c2                	cmp    %eax,%edx
f0117757:	74 17                	je     f0117770 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0117759:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117760:	83 ec 0c             	sub    $0xc,%esp
f0117763:	68 28 b7 12 f0       	push   $0xf012b728
f0117768:	e8 1e 98 fe ff       	call   f0100f8b <cprintf>
f011776d:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117770:	e8 f1 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117775:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117778:	74 17                	je     f0117791 <test_kmalloc_firstfit2+0x8a3>
f011777a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117781:	83 ec 0c             	sub    $0xc,%esp
f0117784:	68 70 a7 12 f0       	push   $0xf012a770
f0117789:	e8 fd 97 fe ff       	call   f0100f8b <cprintf>
f011778e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0117791:	e8 66 5f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117796:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117799:	74 17                	je     f01177b2 <test_kmalloc_firstfit2+0x8c4>
f011779b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177a2:	83 ec 0c             	sub    $0xc,%esp
f01177a5:	68 5c b7 12 f0       	push   $0xf012b75c
f01177aa:	e8 dc 97 fe ff       	call   f0100f8b <cprintf>
f01177af:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01177b2:	e8 45 5f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01177b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01177ba:	e8 a7 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01177bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f01177c2:	83 ec 0c             	sub    $0xc,%esp
f01177c5:	68 00 04 00 00       	push   $0x400
f01177ca:	e8 3d 15 ff ff       	call   f0108d0c <kmalloc>
f01177cf:	83 c4 10             	add    $0x10,%esp
f01177d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f01177d5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01177d8:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01177db:	81 c2 08 08 00 00    	add    $0x808,%edx
f01177e1:	39 d0                	cmp    %edx,%eax
f01177e3:	74 17                	je     f01177fc <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f01177e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177ec:	83 ec 0c             	sub    $0xc,%esp
f01177ef:	68 74 b7 12 f0       	push   $0xf012b774
f01177f4:	e8 92 97 fe ff       	call   f0100f8b <cprintf>
f01177f9:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01177fc:	e8 65 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117801:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117804:	74 17                	je     f011781d <test_kmalloc_firstfit2+0x92f>
f0117806:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011780d:	83 ec 0c             	sub    $0xc,%esp
f0117810:	68 38 a8 12 f0       	push   $0xf012a838
f0117815:	e8 71 97 fe ff       	call   f0100f8b <cprintf>
f011781a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f011781d:	e8 da 5e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117822:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117825:	74 17                	je     f011783e <test_kmalloc_firstfit2+0x950>
f0117827:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011782e:	83 ec 0c             	sub    $0xc,%esp
f0117831:	68 a8 b7 12 f0       	push   $0xf012b7a8
f0117836:	e8 50 97 fe ff       	call   f0100f8b <cprintf>
f011783b:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f011783e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117842:	74 04                	je     f0117848 <test_kmalloc_firstfit2+0x95a>
f0117844:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0117848:	83 ec 0c             	sub    $0xc,%esp
f011784b:	68 c0 b7 12 f0       	push   $0xf012b7c0
f0117850:	e8 36 97 fe ff       	call   f0100f8b <cprintf>
f0117855:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117858:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011785f:	e8 98 5e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117864:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117867:	e8 fa cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f011786c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f011786f:	83 ec 0c             	sub    $0xc,%esp
f0117872:	68 00 04 70 00       	push   $0x700400
f0117877:	e8 90 14 ff ff       	call   f0108d0c <kmalloc>
f011787c:	83 c4 10             	add    $0x10,%esp
f011787f:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117882:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117885:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011788a:	74 17                	je     f01178a3 <test_kmalloc_firstfit2+0x9b5>
f011788c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117893:	83 ec 0c             	sub    $0xc,%esp
f0117896:	68 48 b2 12 f0       	push   $0xf012b248
f011789b:	e8 eb 96 fe ff       	call   f0100f8b <cprintf>
f01178a0:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01178a3:	e8 be cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f01178a8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01178ab:	74 17                	je     f01178c4 <test_kmalloc_firstfit2+0x9d6>
f01178ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178b4:	83 ec 0c             	sub    $0xc,%esp
f01178b7:	68 7c b2 12 f0       	push   $0xf012b27c
f01178bc:	e8 ca 96 fe ff       	call   f0100f8b <cprintf>
f01178c1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01178c4:	e8 33 5e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01178c9:	89 c2                	mov    %eax,%edx
f01178cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01178ce:	29 d0                	sub    %edx,%eax
f01178d0:	3d 00 07 00 00       	cmp    $0x700,%eax
f01178d5:	7f 17                	jg     f01178ee <test_kmalloc_firstfit2+0xa00>
f01178d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178de:	83 ec 0c             	sub    $0xc,%esp
f01178e1:	68 e8 b2 12 f0       	push   $0xf012b2e8
f01178e6:	e8 a0 96 fe ff       	call   f0100f8b <cprintf>
f01178eb:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01178ee:	e8 09 5e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01178f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178f6:	e8 6b cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f01178fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f01178fe:	83 ec 0c             	sub    $0xc,%esp
f0117901:	68 00 0c 00 00       	push   $0xc00
f0117906:	e8 01 14 ff ff       	call   f0108d0c <kmalloc>
f011790b:	83 c4 10             	add    $0x10,%esp
f011790e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0117911:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117914:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0117919:	74 17                	je     f0117932 <test_kmalloc_firstfit2+0xa44>
f011791b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117922:	83 ec 0c             	sub    $0xc,%esp
f0117925:	68 f4 b7 12 f0       	push   $0xf012b7f4
f011792a:	e8 5c 96 fe ff       	call   f0100f8b <cprintf>
f011792f:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117932:	e8 2f cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117937:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011793a:	74 17                	je     f0117953 <test_kmalloc_firstfit2+0xa65>
f011793c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117943:	83 ec 0c             	sub    $0xc,%esp
f0117946:	68 28 b8 12 f0       	push   $0xf012b828
f011794b:	e8 3b 96 fe ff       	call   f0100f8b <cprintf>
f0117950:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0117953:	e8 a4 5d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117958:	89 c2                	mov    %eax,%edx
f011795a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011795d:	29 d0                	sub    %edx,%eax
f011795f:	85 c0                	test   %eax,%eax
f0117961:	7f 17                	jg     f011797a <test_kmalloc_firstfit2+0xa8c>
f0117963:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011796a:	83 ec 0c             	sub    $0xc,%esp
f011796d:	68 94 b8 12 f0       	push   $0xf012b894
f0117972:	e8 14 96 fe ff       	call   f0100f8b <cprintf>
f0117977:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011797a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011797e:	74 04                	je     f0117984 <test_kmalloc_firstfit2+0xa96>
f0117980:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0117984:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f011798b:	83 ec 0c             	sub    $0xc,%esp
f011798e:	68 ac b8 12 f0       	push   $0xf012b8ac
f0117993:	e8 f3 95 fe ff       	call   f0100f8b <cprintf>
f0117998:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011799b:	83 ec 0c             	sub    $0xc,%esp
f011799e:	68 00 e0 1f 07       	push   $0x71fe000
f01179a3:	e8 64 13 ff ff       	call   f0108d0c <kmalloc>
f01179a8:	83 c4 10             	add    $0x10,%esp
f01179ab:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f01179ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01179b1:	85 c0                	test   %eax,%eax
f01179b3:	74 17                	je     f01179cc <test_kmalloc_firstfit2+0xade>
f01179b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179bc:	83 ec 0c             	sub    $0xc,%esp
f01179bf:	68 00 b9 12 f0       	push   $0xf012b900
f01179c4:	e8 c2 95 fe ff       	call   f0100f8b <cprintf>
f01179c9:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f01179cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01179d0:	74 04                	je     f01179d6 <test_kmalloc_firstfit2+0xae8>
f01179d2:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f01179d6:	83 ec 08             	sub    $0x8,%esp
f01179d9:	ff 75 f4             	pushl  -0xc(%ebp)
f01179dc:	68 68 b9 12 f0       	push   $0xf012b968
f01179e1:	e8 a5 95 fe ff       	call   f0100f8b <cprintf>
f01179e6:	83 c4 10             	add    $0x10,%esp

	return 1;
f01179e9:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01179ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01179f1:	5b                   	pop    %ebx
f01179f2:	5f                   	pop    %edi
f01179f3:	5d                   	pop    %ebp
f01179f4:	c3                   	ret    

f01179f5 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f01179f5:	55                   	push   %ebp
f01179f6:	89 e5                	mov    %esp,%ebp
f01179f8:	53                   	push   %ebx
f01179f9:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01179fc:	83 ec 0c             	sub    $0xc,%esp
f01179ff:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0117a04:	e8 82 95 fe ff       	call   f0100f8b <cprintf>
f0117a09:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117a0c:	83 ec 0c             	sub    $0xc,%esp
f0117a0f:	68 18 9b 12 f0       	push   $0xf0129b18
f0117a14:	e8 72 95 fe ff       	call   f0100f8b <cprintf>
f0117a19:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117a1c:	83 ec 0c             	sub    $0xc,%esp
f0117a1f:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0117a24:	e8 62 95 fe ff       	call   f0100f8b <cprintf>
f0117a29:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0117a2c:	e8 cb 5c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117a31:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0117a34:	e8 2d ce fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117a39:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0117a3c:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0117a43:	83 ec 0c             	sub    $0xc,%esp
f0117a46:	68 9d b9 12 f0       	push   $0xf012b99d
f0117a4b:	e8 3b 95 fe ff       	call   f0100f8b <cprintf>
f0117a50:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0117a53:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0117a58:	ba 00 00 00 00       	mov    $0x0,%edx
f0117a5d:	f7 75 e4             	divl   -0x1c(%ebp)
f0117a60:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0117a63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117a6a:	eb 1d                	jmp    f0117a89 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0117a6c:	83 ec 0c             	sub    $0xc,%esp
f0117a6f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117a72:	e8 95 12 ff ff       	call   f0108d0c <kmalloc>
f0117a77:	83 c4 10             	add    $0x10,%esp
f0117a7a:	89 c2                	mov    %eax,%edx
f0117a7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117a7f:	89 14 85 40 42 5c f0 	mov    %edx,-0xfa3bdc0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0117a86:	ff 45 f4             	incl   -0xc(%ebp)
f0117a89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117a8c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117a8f:	7c db                	jl     f0117a6c <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0117a91:	83 ec 0c             	sub    $0xc,%esp
f0117a94:	68 a1 b9 12 f0       	push   $0xf012b9a1
f0117a99:	e8 ed 94 fe ff       	call   f0100f8b <cprintf>
f0117a9e:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0117aa1:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0117aa6:	ba 00 00 00 00       	mov    $0x0,%edx
f0117aab:	f7 75 e4             	divl   -0x1c(%ebp)
f0117aae:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0117ab1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117ab5:	74 1e                	je     f0117ad5 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0117ab7:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0117aba:	8d 43 01             	lea    0x1(%ebx),%eax
f0117abd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0117ac0:	83 ec 0c             	sub    $0xc,%esp
f0117ac3:	ff 75 e0             	pushl  -0x20(%ebp)
f0117ac6:	e8 41 12 ff ff       	call   f0108d0c <kmalloc>
f0117acb:	83 c4 10             	add    $0x10,%esp
f0117ace:	89 04 9d 40 42 5c f0 	mov    %eax,-0xfa3bdc0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0117ad5:	83 ec 04             	sub    $0x4,%esp
f0117ad8:	ff 75 f0             	pushl  -0x10(%ebp)
f0117adb:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117ade:	68 a8 b9 12 f0       	push   $0xf012b9a8
f0117ae3:	e8 a3 94 fe ff       	call   f0100f8b <cprintf>
f0117ae8:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0117aeb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117af2:	eb 36                	jmp    f0117b2a <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0117af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117af7:	8b 04 85 40 42 5c f0 	mov    -0xfa3bdc0(,%eax,4),%eax
f0117afe:	89 c2                	mov    %eax,%edx
f0117b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117b03:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0117b07:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0117b0c:	39 c2                	cmp    %eax,%edx
f0117b0e:	74 17                	je     f0117b27 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0117b10:	83 ec 04             	sub    $0x4,%esp
f0117b13:	68 f0 b9 12 f0       	push   $0xf012b9f0
f0117b18:	68 e3 02 00 00       	push   $0x2e3
f0117b1d:	68 33 ba 12 f0       	push   $0xf012ba33
f0117b22:	e8 12 88 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0117b27:	ff 45 f4             	incl   -0xc(%ebp)
f0117b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117b2d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117b30:	7c c2                	jl     f0117af4 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117b32:	e8 2f cd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117b37:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b3a:	74 17                	je     f0117b53 <test_fastfirstfit+0x15e>
f0117b3c:	83 ec 04             	sub    $0x4,%esp
f0117b3f:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117b44:	68 e6 02 00 00       	push   $0x2e6
f0117b49:	68 33 ba 12 f0       	push   $0xf012ba33
f0117b4e:	e8 e6 87 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0117b53:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117b56:	e8 a1 5b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117b5b:	29 c3                	sub    %eax,%ebx
f0117b5d:	89 d8                	mov    %ebx,%eax
f0117b5f:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0117b64:	77 17                	ja     f0117b7d <test_fastfirstfit+0x188>
f0117b66:	83 ec 04             	sub    $0x4,%esp
f0117b69:	68 b4 ba 12 f0       	push   $0xf012bab4
f0117b6e:	68 e7 02 00 00       	push   $0x2e7
f0117b73:	68 33 ba 12 f0       	push   $0xf012ba33
f0117b78:	e8 bc 87 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0117b7d:	e8 e4 cc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117b82:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0117b85:	e8 72 5b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117b8a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0117b8d:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0117b91:	7f 17                	jg     f0117baa <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0117b93:	83 ec 04             	sub    $0x4,%esp
f0117b96:	68 c8 ba 12 f0       	push   $0xf012bac8
f0117b9b:	68 ee 02 00 00       	push   $0x2ee
f0117ba0:	68 33 ba 12 f0       	push   $0xf012ba33
f0117ba5:	e8 8f 87 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0117baa:	a1 40 42 5c f0       	mov    0xf05c4240,%eax
f0117baf:	83 ec 0c             	sub    $0xc,%esp
f0117bb2:	50                   	push   %eax
f0117bb3:	e8 6e 11 ff ff       	call   f0108d26 <kfree>
f0117bb8:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0117bbb:	a1 48 42 5c f0       	mov    0xf05c4248,%eax
f0117bc0:	83 ec 0c             	sub    $0xc,%esp
f0117bc3:	50                   	push   %eax
f0117bc4:	e8 5d 11 ff ff       	call   f0108d26 <kfree>
f0117bc9:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0117bcc:	a1 4c 42 5c f0       	mov    0xf05c424c,%eax
f0117bd1:	83 ec 0c             	sub    $0xc,%esp
f0117bd4:	50                   	push   %eax
f0117bd5:	e8 4c 11 ff ff       	call   f0108d26 <kfree>
f0117bda:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0117bdd:	a1 54 42 5c f0       	mov    0xf05c4254,%eax
f0117be2:	83 ec 0c             	sub    $0xc,%esp
f0117be5:	50                   	push   %eax
f0117be6:	e8 3b 11 ff ff       	call   f0108d26 <kfree>
f0117beb:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0117bee:	a1 68 42 5c f0       	mov    0xf05c4268,%eax
f0117bf3:	83 ec 0c             	sub    $0xc,%esp
f0117bf6:	50                   	push   %eax
f0117bf7:	e8 2a 11 ff ff       	call   f0108d26 <kfree>
f0117bfc:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0117bff:	a1 70 42 5c f0       	mov    0xf05c4270,%eax
f0117c04:	83 ec 0c             	sub    $0xc,%esp
f0117c07:	50                   	push   %eax
f0117c08:	e8 19 11 ff ff       	call   f0108d26 <kfree>
f0117c0d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0117c10:	a1 6c 42 5c f0       	mov    0xf05c426c,%eax
f0117c15:	83 ec 0c             	sub    $0xc,%esp
f0117c18:	50                   	push   %eax
f0117c19:	e8 08 11 ff ff       	call   f0108d26 <kfree>
f0117c1e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0117c21:	a1 90 42 5c f0       	mov    0xf05c4290,%eax
f0117c26:	83 ec 0c             	sub    $0xc,%esp
f0117c29:	50                   	push   %eax
f0117c2a:	e8 f7 10 ff ff       	call   f0108d26 <kfree>
f0117c2f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0117c32:	a1 a4 42 5c f0       	mov    0xf05c42a4,%eax
f0117c37:	83 ec 0c             	sub    $0xc,%esp
f0117c3a:	50                   	push   %eax
f0117c3b:	e8 e6 10 ff ff       	call   f0108d26 <kfree>
f0117c40:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0117c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117c46:	83 e8 02             	sub    $0x2,%eax
f0117c49:	8b 04 85 40 42 5c f0 	mov    -0xfa3bdc0(,%eax,4),%eax
f0117c50:	83 ec 0c             	sub    $0xc,%esp
f0117c53:	50                   	push   %eax
f0117c54:	e8 cd 10 ff ff       	call   f0108d26 <kfree>
f0117c59:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0117c5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117c5f:	83 e8 03             	sub    $0x3,%eax
f0117c62:	8b 04 85 40 42 5c f0 	mov    -0xfa3bdc0(,%eax,4),%eax
f0117c69:	83 ec 0c             	sub    $0xc,%esp
f0117c6c:	50                   	push   %eax
f0117c6d:	e8 b4 10 ff ff       	call   f0108d26 <kfree>
f0117c72:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117c75:	e8 ec cb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117c7a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c7d:	74 17                	je     f0117c96 <test_fastfirstfit+0x2a1>
f0117c7f:	83 ec 04             	sub    $0x4,%esp
f0117c82:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117c87:	68 fb 02 00 00       	push   $0x2fb
f0117c8c:	68 33 ba 12 f0       	push   $0xf012ba33
f0117c91:	e8 a3 86 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0117c96:	e8 61 5a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117c9b:	89 c2                	mov    %eax,%edx
f0117c9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ca0:	89 d1                	mov    %edx,%ecx
f0117ca2:	29 c1                	sub    %eax,%ecx
f0117ca4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117ca7:	89 d0                	mov    %edx,%eax
f0117ca9:	c1 e0 02             	shl    $0x2,%eax
f0117cac:	01 d0                	add    %edx,%eax
f0117cae:	01 c0                	add    %eax,%eax
f0117cb0:	01 d0                	add    %edx,%eax
f0117cb2:	c1 e8 0c             	shr    $0xc,%eax
f0117cb5:	39 c1                	cmp    %eax,%ecx
f0117cb7:	74 17                	je     f0117cd0 <test_fastfirstfit+0x2db>
f0117cb9:	83 ec 04             	sub    $0x4,%esp
f0117cbc:	68 04 bb 12 f0       	push   $0xf012bb04
f0117cc1:	68 fc 02 00 00       	push   $0x2fc
f0117cc6:	68 33 ba 12 f0       	push   $0xf012ba33
f0117ccb:	e8 69 86 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0117cd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117cd3:	01 c0                	add    %eax,%eax
f0117cd5:	89 c2                	mov    %eax,%edx
f0117cd7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117cda:	d1 e8                	shr    %eax
f0117cdc:	01 d0                	add    %edx,%eax
f0117cde:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117ce1:	e8 80 cb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117ce6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0117ce9:	e8 0e 5a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117cee:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0117cf1:	83 ec 0c             	sub    $0xc,%esp
f0117cf4:	ff 75 dc             	pushl  -0x24(%ebp)
f0117cf7:	e8 10 10 ff ff       	call   f0108d0c <kmalloc>
f0117cfc:	83 c4 10             	add    $0x10,%esp
f0117cff:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0117d02:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117d05:	89 d0                	mov    %edx,%eax
f0117d07:	c1 e0 02             	shl    $0x2,%eax
f0117d0a:	01 d0                	add    %edx,%eax
f0117d0c:	01 c0                	add    %eax,%eax
f0117d0e:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0117d14:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0117d17:	39 c2                	cmp    %eax,%edx
f0117d19:	74 17                	je     f0117d32 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0117d1b:	83 ec 04             	sub    $0x4,%esp
f0117d1e:	68 44 bb 12 f0       	push   $0xf012bb44
f0117d23:	68 07 03 00 00       	push   $0x307
f0117d28:	68 33 ba 12 f0       	push   $0xf012ba33
f0117d2d:	e8 07 86 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117d32:	e8 2f cb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117d37:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d3a:	74 17                	je     f0117d53 <test_fastfirstfit+0x35e>
f0117d3c:	83 ec 04             	sub    $0x4,%esp
f0117d3f:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117d44:	68 08 03 00 00       	push   $0x308
f0117d49:	68 33 ba 12 f0       	push   $0xf012ba33
f0117d4e:	e8 e6 85 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0117d53:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117d56:	e8 a1 59 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117d5b:	29 c3                	sub    %eax,%ebx
f0117d5d:	89 da                	mov    %ebx,%edx
f0117d5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117d62:	c1 e8 0c             	shr    $0xc,%eax
f0117d65:	39 c2                	cmp    %eax,%edx
f0117d67:	73 17                	jae    f0117d80 <test_fastfirstfit+0x38b>
f0117d69:	83 ec 04             	sub    $0x4,%esp
f0117d6c:	68 b4 ba 12 f0       	push   $0xf012bab4
f0117d71:	68 09 03 00 00       	push   $0x309
f0117d76:	68 33 ba 12 f0       	push   $0xf012ba33
f0117d7b:	e8 b9 85 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0117d80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117d83:	01 c0                	add    %eax,%eax
f0117d85:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117d88:	e8 d9 ca fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117d8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0117d90:	e8 67 59 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117d95:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0117d98:	83 ec 0c             	sub    $0xc,%esp
f0117d9b:	ff 75 dc             	pushl  -0x24(%ebp)
f0117d9e:	e8 69 0f ff ff       	call   f0108d0c <kmalloc>
f0117da3:	83 c4 10             	add    $0x10,%esp
f0117da6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0117da9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117dac:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0117db1:	01 c0                	add    %eax,%eax
f0117db3:	89 c2                	mov    %eax,%edx
f0117db5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117db8:	39 c2                	cmp    %eax,%edx
f0117dba:	74 17                	je     f0117dd3 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0117dbc:	83 ec 04             	sub    $0x4,%esp
f0117dbf:	68 44 bb 12 f0       	push   $0xf012bb44
f0117dc4:	68 13 03 00 00       	push   $0x313
f0117dc9:	68 33 ba 12 f0       	push   $0xf012ba33
f0117dce:	e8 66 85 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117dd3:	e8 8e ca fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117dd8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ddb:	74 17                	je     f0117df4 <test_fastfirstfit+0x3ff>
f0117ddd:	83 ec 04             	sub    $0x4,%esp
f0117de0:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117de5:	68 14 03 00 00       	push   $0x314
f0117dea:	68 33 ba 12 f0       	push   $0xf012ba33
f0117def:	e8 45 85 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0117df4:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117df7:	e8 00 59 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117dfc:	29 c3                	sub    %eax,%ebx
f0117dfe:	89 da                	mov    %ebx,%edx
f0117e00:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117e03:	c1 e8 0c             	shr    $0xc,%eax
f0117e06:	39 c2                	cmp    %eax,%edx
f0117e08:	73 17                	jae    f0117e21 <test_fastfirstfit+0x42c>
f0117e0a:	83 ec 04             	sub    $0x4,%esp
f0117e0d:	68 b4 ba 12 f0       	push   $0xf012bab4
f0117e12:	68 15 03 00 00       	push   $0x315
f0117e17:	68 33 ba 12 f0       	push   $0xf012ba33
f0117e1c:	e8 18 85 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0117e21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117e24:	89 c2                	mov    %eax,%edx
f0117e26:	01 d2                	add    %edx,%edx
f0117e28:	01 d0                	add    %edx,%eax
f0117e2a:	d1 e8                	shr    %eax
f0117e2c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117e2f:	e8 32 ca fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117e34:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0117e37:	e8 c0 58 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117e3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0117e3f:	83 ec 0c             	sub    $0xc,%esp
f0117e42:	ff 75 dc             	pushl  -0x24(%ebp)
f0117e45:	e8 c2 0e ff ff       	call   f0108d0c <kmalloc>
f0117e4a:	83 c4 10             	add    $0x10,%esp
f0117e4d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0117e50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117e53:	83 e8 03             	sub    $0x3,%eax
f0117e56:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0117e5a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0117e60:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117e63:	39 c2                	cmp    %eax,%edx
f0117e65:	74 17                	je     f0117e7e <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0117e67:	83 ec 04             	sub    $0x4,%esp
f0117e6a:	68 44 bb 12 f0       	push   $0xf012bb44
f0117e6f:	68 1f 03 00 00       	push   $0x31f
f0117e74:	68 33 ba 12 f0       	push   $0xf012ba33
f0117e79:	e8 bb 84 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117e7e:	e8 e3 c9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117e83:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e86:	74 17                	je     f0117e9f <test_fastfirstfit+0x4aa>
f0117e88:	83 ec 04             	sub    $0x4,%esp
f0117e8b:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117e90:	68 20 03 00 00       	push   $0x320
f0117e95:	68 33 ba 12 f0       	push   $0xf012ba33
f0117e9a:	e8 9a 84 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0117e9f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117ea2:	e8 55 58 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117ea7:	29 c3                	sub    %eax,%ebx
f0117ea9:	89 da                	mov    %ebx,%edx
f0117eab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117eae:	c1 e8 0c             	shr    $0xc,%eax
f0117eb1:	39 c2                	cmp    %eax,%edx
f0117eb3:	73 17                	jae    f0117ecc <test_fastfirstfit+0x4d7>
f0117eb5:	83 ec 04             	sub    $0x4,%esp
f0117eb8:	68 b4 ba 12 f0       	push   $0xf012bab4
f0117ebd:	68 21 03 00 00       	push   $0x321
f0117ec2:	68 33 ba 12 f0       	push   $0xf012ba33
f0117ec7:	e8 6d 84 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0117ecc:	e8 95 c9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117ed1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0117ed4:	e8 23 58 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117ed9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0117edc:	83 ec 0c             	sub    $0xc,%esp
f0117edf:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117ee2:	e8 25 0e ff ff       	call   f0108d0c <kmalloc>
f0117ee7:	83 c4 10             	add    $0x10,%esp
f0117eea:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f0117eed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117ef0:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117ef5:	74 17                	je     f0117f0e <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0117ef7:	83 ec 04             	sub    $0x4,%esp
f0117efa:	68 44 bb 12 f0       	push   $0xf012bb44
f0117eff:	68 2a 03 00 00       	push   $0x32a
f0117f04:	68 33 ba 12 f0       	push   $0xf012ba33
f0117f09:	e8 2b 84 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117f0e:	e8 53 c9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117f13:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f16:	74 17                	je     f0117f2f <test_fastfirstfit+0x53a>
f0117f18:	83 ec 04             	sub    $0x4,%esp
f0117f1b:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117f20:	68 2b 03 00 00       	push   $0x32b
f0117f25:	68 33 ba 12 f0       	push   $0xf012ba33
f0117f2a:	e8 0a 84 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0117f2f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117f32:	e8 c5 57 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117f37:	29 c3                	sub    %eax,%ebx
f0117f39:	89 da                	mov    %ebx,%edx
f0117f3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117f3e:	c1 e8 0c             	shr    $0xc,%eax
f0117f41:	39 c2                	cmp    %eax,%edx
f0117f43:	73 17                	jae    f0117f5c <test_fastfirstfit+0x567>
f0117f45:	83 ec 04             	sub    $0x4,%esp
f0117f48:	68 b4 ba 12 f0       	push   $0xf012bab4
f0117f4d:	68 2c 03 00 00       	push   $0x32c
f0117f52:	68 33 ba 12 f0       	push   $0xf012ba33
f0117f57:	e8 dd 83 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0117f5c:	e8 05 c9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117f61:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0117f64:	e8 93 57 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117f69:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0117f6c:	83 ec 0c             	sub    $0xc,%esp
f0117f6f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117f72:	e8 95 0d ff ff       	call   f0108d0c <kmalloc>
f0117f77:	83 c4 10             	add    $0x10,%esp
f0117f7a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0117f7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117f80:	89 d0                	mov    %edx,%eax
f0117f82:	c1 e0 02             	shl    $0x2,%eax
f0117f85:	01 d0                	add    %edx,%eax
f0117f87:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0117f8d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117f90:	39 c2                	cmp    %eax,%edx
f0117f92:	74 17                	je     f0117fab <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0117f94:	83 ec 04             	sub    $0x4,%esp
f0117f97:	68 44 bb 12 f0       	push   $0xf012bb44
f0117f9c:	68 35 03 00 00       	push   $0x335
f0117fa1:	68 33 ba 12 f0       	push   $0xf012ba33
f0117fa6:	e8 8e 83 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117fab:	e8 b6 c8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117fb0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fb3:	74 17                	je     f0117fcc <test_fastfirstfit+0x5d7>
f0117fb5:	83 ec 04             	sub    $0x4,%esp
f0117fb8:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117fbd:	68 36 03 00 00       	push   $0x336
f0117fc2:	68 33 ba 12 f0       	push   $0xf012ba33
f0117fc7:	e8 6d 83 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0117fcc:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117fcf:	e8 28 57 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0117fd4:	29 c3                	sub    %eax,%ebx
f0117fd6:	89 da                	mov    %ebx,%edx
f0117fd8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117fdb:	c1 e8 0c             	shr    $0xc,%eax
f0117fde:	39 c2                	cmp    %eax,%edx
f0117fe0:	73 17                	jae    f0117ff9 <test_fastfirstfit+0x604>
f0117fe2:	83 ec 04             	sub    $0x4,%esp
f0117fe5:	68 b4 ba 12 f0       	push   $0xf012bab4
f0117fea:	68 37 03 00 00       	push   $0x337
f0117fef:	68 33 ba 12 f0       	push   $0xf012ba33
f0117ff4:	e8 40 83 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0117ff9:	e8 68 c8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118001:	e8 f6 56 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118006:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118009:	83 ec 0c             	sub    $0xc,%esp
f011800c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011800f:	e8 f8 0c ff ff       	call   f0108d0c <kmalloc>
f0118014:	83 c4 10             	add    $0x10,%esp
f0118017:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f011801a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011801d:	89 d0                	mov    %edx,%eax
f011801f:	c1 e0 02             	shl    $0x2,%eax
f0118022:	01 d0                	add    %edx,%eax
f0118024:	c1 e0 02             	shl    $0x2,%eax
f0118027:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011802d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118030:	39 c2                	cmp    %eax,%edx
f0118032:	74 17                	je     f011804b <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0118034:	83 ec 04             	sub    $0x4,%esp
f0118037:	68 44 bb 12 f0       	push   $0xf012bb44
f011803c:	68 40 03 00 00       	push   $0x340
f0118041:	68 33 ba 12 f0       	push   $0xf012ba33
f0118046:	e8 ee 82 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011804b:	e8 16 c8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118050:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118053:	74 17                	je     f011806c <test_fastfirstfit+0x677>
f0118055:	83 ec 04             	sub    $0x4,%esp
f0118058:	68 4c ba 12 f0       	push   $0xf012ba4c
f011805d:	68 41 03 00 00       	push   $0x341
f0118062:	68 33 ba 12 f0       	push   $0xf012ba33
f0118067:	e8 cd 82 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011806c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011806f:	e8 88 56 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118074:	29 c3                	sub    %eax,%ebx
f0118076:	89 da                	mov    %ebx,%edx
f0118078:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011807b:	c1 e8 0c             	shr    $0xc,%eax
f011807e:	39 c2                	cmp    %eax,%edx
f0118080:	73 17                	jae    f0118099 <test_fastfirstfit+0x6a4>
f0118082:	83 ec 04             	sub    $0x4,%esp
f0118085:	68 b4 ba 12 f0       	push   $0xf012bab4
f011808a:	68 42 03 00 00       	push   $0x342
f011808f:	68 33 ba 12 f0       	push   $0xf012ba33
f0118094:	e8 a0 82 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118099:	e8 c8 c7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011809e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01180a1:	e8 56 56 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01180a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01180a9:	83 ec 0c             	sub    $0xc,%esp
f01180ac:	ff 75 e4             	pushl  -0x1c(%ebp)
f01180af:	e8 58 0c ff ff       	call   f0108d0c <kmalloc>
f01180b4:	83 c4 10             	add    $0x10,%esp
f01180b7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f01180ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01180bd:	89 d0                	mov    %edx,%eax
f01180bf:	c1 e0 02             	shl    $0x2,%eax
f01180c2:	01 d0                	add    %edx,%eax
f01180c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01180cb:	01 d0                	add    %edx,%eax
f01180cd:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01180d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01180d6:	39 c2                	cmp    %eax,%edx
f01180d8:	74 17                	je     f01180f1 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f01180da:	83 ec 04             	sub    $0x4,%esp
f01180dd:	68 44 bb 12 f0       	push   $0xf012bb44
f01180e2:	68 4b 03 00 00       	push   $0x34b
f01180e7:	68 33 ba 12 f0       	push   $0xf012ba33
f01180ec:	e8 48 82 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01180f1:	e8 70 c7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01180f6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180f9:	74 17                	je     f0118112 <test_fastfirstfit+0x71d>
f01180fb:	83 ec 04             	sub    $0x4,%esp
f01180fe:	68 4c ba 12 f0       	push   $0xf012ba4c
f0118103:	68 4c 03 00 00       	push   $0x34c
f0118108:	68 33 ba 12 f0       	push   $0xf012ba33
f011810d:	e8 27 82 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118112:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118115:	e8 e2 55 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011811a:	29 c3                	sub    %eax,%ebx
f011811c:	89 da                	mov    %ebx,%edx
f011811e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118121:	c1 e8 0c             	shr    $0xc,%eax
f0118124:	39 c2                	cmp    %eax,%edx
f0118126:	73 17                	jae    f011813f <test_fastfirstfit+0x74a>
f0118128:	83 ec 04             	sub    $0x4,%esp
f011812b:	68 b4 ba 12 f0       	push   $0xf012bab4
f0118130:	68 4d 03 00 00       	push   $0x34d
f0118135:	68 33 ba 12 f0       	push   $0xf012ba33
f011813a:	e8 fa 81 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f011813f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118142:	d1 e8                	shr    %eax
f0118144:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118147:	e8 1a c7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011814c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011814f:	e8 a8 55 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118154:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118157:	83 ec 0c             	sub    $0xc,%esp
f011815a:	ff 75 dc             	pushl  -0x24(%ebp)
f011815d:	e8 aa 0b ff ff       	call   f0108d0c <kmalloc>
f0118162:	83 c4 10             	add    $0x10,%esp
f0118165:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0118168:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011816b:	89 d0                	mov    %edx,%eax
f011816d:	c1 e0 02             	shl    $0x2,%eax
f0118170:	01 d0                	add    %edx,%eax
f0118172:	01 c0                	add    %eax,%eax
f0118174:	89 c1                	mov    %eax,%ecx
f0118176:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118179:	89 d0                	mov    %edx,%eax
f011817b:	c1 e0 02             	shl    $0x2,%eax
f011817e:	01 d0                	add    %edx,%eax
f0118180:	d1 e8                	shr    %eax
f0118182:	01 c8                	add    %ecx,%eax
f0118184:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011818a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011818d:	39 c2                	cmp    %eax,%edx
f011818f:	74 17                	je     f01181a8 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0118191:	83 ec 04             	sub    $0x4,%esp
f0118194:	68 44 bb 12 f0       	push   $0xf012bb44
f0118199:	68 57 03 00 00       	push   $0x357
f011819e:	68 33 ba 12 f0       	push   $0xf012ba33
f01181a3:	e8 91 81 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01181a8:	e8 b9 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01181ad:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181b0:	74 17                	je     f01181c9 <test_fastfirstfit+0x7d4>
f01181b2:	83 ec 04             	sub    $0x4,%esp
f01181b5:	68 4c ba 12 f0       	push   $0xf012ba4c
f01181ba:	68 58 03 00 00       	push   $0x358
f01181bf:	68 33 ba 12 f0       	push   $0xf012ba33
f01181c4:	e8 70 81 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01181c9:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01181cc:	e8 2b 55 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01181d1:	29 c3                	sub    %eax,%ebx
f01181d3:	89 da                	mov    %ebx,%edx
f01181d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01181d8:	c1 e8 0c             	shr    $0xc,%eax
f01181db:	39 c2                	cmp    %eax,%edx
f01181dd:	73 17                	jae    f01181f6 <test_fastfirstfit+0x801>
f01181df:	83 ec 04             	sub    $0x4,%esp
f01181e2:	68 b4 ba 12 f0       	push   $0xf012bab4
f01181e7:	68 59 03 00 00       	push   $0x359
f01181ec:	68 33 ba 12 f0       	push   $0xf012ba33
f01181f1:	e8 43 81 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01181f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01181f9:	d1 e8                	shr    %eax
f01181fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01181fe:	e8 63 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118203:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118206:	e8 f1 54 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011820b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011820e:	83 ec 0c             	sub    $0xc,%esp
f0118211:	ff 75 dc             	pushl  -0x24(%ebp)
f0118214:	e8 f3 0a ff ff       	call   f0108d0c <kmalloc>
f0118219:	83 c4 10             	add    $0x10,%esp
f011821c:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f011821f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118222:	83 e8 03             	sub    $0x3,%eax
f0118225:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118229:	89 c2                	mov    %eax,%edx
f011822b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011822e:	89 c1                	mov    %eax,%ecx
f0118230:	01 c9                	add    %ecx,%ecx
f0118232:	01 c8                	add    %ecx,%eax
f0118234:	d1 e8                	shr    %eax
f0118236:	01 d0                	add    %edx,%eax
f0118238:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011823e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118241:	39 c2                	cmp    %eax,%edx
f0118243:	74 17                	je     f011825c <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0118245:	83 ec 04             	sub    $0x4,%esp
f0118248:	68 44 bb 12 f0       	push   $0xf012bb44
f011824d:	68 63 03 00 00       	push   $0x363
f0118252:	68 33 ba 12 f0       	push   $0xf012ba33
f0118257:	e8 dd 80 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011825c:	e8 05 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118261:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118264:	74 17                	je     f011827d <test_fastfirstfit+0x888>
f0118266:	83 ec 04             	sub    $0x4,%esp
f0118269:	68 4c ba 12 f0       	push   $0xf012ba4c
f011826e:	68 64 03 00 00       	push   $0x364
f0118273:	68 33 ba 12 f0       	push   $0xf012ba33
f0118278:	e8 bc 80 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011827d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118280:	e8 77 54 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118285:	29 c3                	sub    %eax,%ebx
f0118287:	89 da                	mov    %ebx,%edx
f0118289:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011828c:	c1 e8 0c             	shr    $0xc,%eax
f011828f:	39 c2                	cmp    %eax,%edx
f0118291:	73 17                	jae    f01182aa <test_fastfirstfit+0x8b5>
f0118293:	83 ec 04             	sub    $0x4,%esp
f0118296:	68 b4 ba 12 f0       	push   $0xf012bab4
f011829b:	68 65 03 00 00       	push   $0x365
f01182a0:	68 33 ba 12 f0       	push   $0xf012ba33
f01182a5:	e8 8f 80 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f01182aa:	83 ec 0c             	sub    $0xc,%esp
f01182ad:	68 64 bb 12 f0       	push   $0xf012bb64
f01182b2:	e8 d4 8c fe ff       	call   f0100f8b <cprintf>
f01182b7:	83 c4 10             	add    $0x10,%esp
	return 1;
f01182ba:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01182bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01182c2:	c9                   	leave  
f01182c3:	c3                   	ret    

f01182c4 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f01182c4:	55                   	push   %ebp
f01182c5:	89 e5                	mov    %esp,%ebp
f01182c7:	57                   	push   %edi
f01182c8:	53                   	push   %ebx
f01182c9:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01182cf:	83 ec 0c             	sub    $0xc,%esp
f01182d2:	68 e8 9a 12 f0       	push   $0xf0129ae8
f01182d7:	e8 af 8c fe ff       	call   f0100f8b <cprintf>
f01182dc:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01182df:	83 ec 0c             	sub    $0xc,%esp
f01182e2:	68 18 9b 12 f0       	push   $0xf0129b18
f01182e7:	e8 9f 8c fe ff       	call   f0100f8b <cprintf>
f01182ec:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01182ef:	83 ec 0c             	sub    $0xc,%esp
f01182f2:	68 e8 9a 12 f0       	push   $0xf0129ae8
f01182f7:	e8 8f 8c fe ff       	call   f0100f8b <cprintf>
f01182fc:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01182ff:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0118303:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0118307:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011830d:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0118313:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011831a:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0118321:	e8 d6 53 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118326:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0118329:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f011832f:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118334:	b8 00 00 00 00       	mov    $0x0,%eax
f0118339:	89 d7                	mov    %edx,%edi
f011833b:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011833d:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f0118343:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118348:	b8 00 00 00 00       	mov    $0x0,%eax
f011834d:	89 d7                	mov    %edx,%edi
f011834f:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0118351:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0118358:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011835f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0118366:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f011836c:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118371:	b8 00 00 00 00       	mov    $0x0,%eax
f0118376:	89 d7                	mov    %edx,%edi
f0118378:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f011837a:	83 ec 0c             	sub    $0xc,%esp
f011837d:	68 a8 bb 12 f0       	push   $0xf012bba8
f0118382:	e8 04 8c fe ff       	call   f0100f8b <cprintf>
f0118387:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011838a:	e8 6d 53 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011838f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118392:	e8 cf c4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118397:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011839a:	83 ec 0c             	sub    $0xc,%esp
f011839d:	68 00 fc 1f 00       	push   $0x1ffc00
f01183a2:	e8 65 09 ff ff       	call   f0108d0c <kmalloc>
f01183a7:	83 c4 10             	add    $0x10,%esp
f01183aa:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01183b0:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f01183b6:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01183bb:	74 17                	je     f01183d4 <test_kfree_bestfirstfit+0x110>
f01183bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01183c4:	83 ec 0c             	sub    $0xc,%esp
f01183c7:	68 e0 bb 12 f0       	push   $0xf012bbe0
f01183cc:	e8 ba 8b fe ff       	call   f0100f8b <cprintf>
f01183d1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183d4:	e8 8d c4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01183d9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01183dc:	74 17                	je     f01183f5 <test_kfree_bestfirstfit+0x131>
f01183de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01183e5:	83 ec 0c             	sub    $0xc,%esp
f01183e8:	68 34 bc 12 f0       	push   $0xf012bc34
f01183ed:	e8 99 8b fe ff       	call   f0100f8b <cprintf>
f01183f2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01183f5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01183f8:	e8 ff 52 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01183fd:	29 c3                	sub    %eax,%ebx
f01183ff:	89 d8                	mov    %ebx,%eax
f0118401:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118406:	77 17                	ja     f011841f <test_kfree_bestfirstfit+0x15b>
f0118408:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011840f:	83 ec 0c             	sub    $0xc,%esp
f0118412:	68 a4 bc 12 f0       	push   $0xf012bca4
f0118417:	e8 6f 8b fe ff       	call   f0100f8b <cprintf>
f011841c:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011841f:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0118426:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0118429:	e8 ce 52 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011842e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118431:	e8 30 c4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118436:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118439:	83 ec 0c             	sub    $0xc,%esp
f011843c:	68 00 fc 1f 00       	push   $0x1ffc00
f0118441:	e8 c6 08 ff ff       	call   f0108d0c <kmalloc>
f0118446:	83 c4 10             	add    $0x10,%esp
f0118449:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011844f:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0118455:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011845a:	74 17                	je     f0118473 <test_kfree_bestfirstfit+0x1af>
f011845c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118463:	83 ec 0c             	sub    $0xc,%esp
f0118466:	68 ec bc 12 f0       	push   $0xf012bcec
f011846b:	e8 1b 8b fe ff       	call   f0100f8b <cprintf>
f0118470:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118473:	e8 ee c3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118478:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011847b:	74 17                	je     f0118494 <test_kfree_bestfirstfit+0x1d0>
f011847d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118484:	83 ec 0c             	sub    $0xc,%esp
f0118487:	68 40 bd 12 f0       	push   $0xf012bd40
f011848c:	e8 fa 8a fe ff       	call   f0100f8b <cprintf>
f0118491:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118494:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118497:	e8 60 52 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011849c:	29 c3                	sub    %eax,%ebx
f011849e:	89 d8                	mov    %ebx,%eax
f01184a0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01184a5:	77 17                	ja     f01184be <test_kfree_bestfirstfit+0x1fa>
f01184a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01184ae:	83 ec 0c             	sub    $0xc,%esp
f01184b1:	68 b0 bd 12 f0       	push   $0xf012bdb0
f01184b6:	e8 d0 8a fe ff       	call   f0100f8b <cprintf>
f01184bb:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f01184be:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f01184c5:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f01184c8:	e8 2f 52 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01184cd:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01184d0:	e8 91 c3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01184d5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f01184d8:	83 ec 0c             	sub    $0xc,%esp
f01184db:	68 00 1c 00 00       	push   $0x1c00
f01184e0:	e8 27 08 ff ff       	call   f0108d0c <kmalloc>
f01184e5:	83 c4 10             	add    $0x10,%esp
f01184e8:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01184ee:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01184f4:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01184f9:	74 17                	je     f0118512 <test_kfree_bestfirstfit+0x24e>
f01184fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118502:	83 ec 0c             	sub    $0xc,%esp
f0118505:	68 f8 bd 12 f0       	push   $0xf012bdf8
f011850a:	e8 7c 8a fe ff       	call   f0100f8b <cprintf>
f011850f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118512:	e8 4f c3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118517:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011851a:	74 17                	je     f0118533 <test_kfree_bestfirstfit+0x26f>
f011851c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118523:	83 ec 0c             	sub    $0xc,%esp
f0118526:	68 4c be 12 f0       	push   $0xf012be4c
f011852b:	e8 5b 8a fe ff       	call   f0100f8b <cprintf>
f0118530:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118533:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118536:	e8 c1 51 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011853b:	29 c3                	sub    %eax,%ebx
f011853d:	89 d8                	mov    %ebx,%eax
f011853f:	83 f8 01             	cmp    $0x1,%eax
f0118542:	77 17                	ja     f011855b <test_kfree_bestfirstfit+0x297>
f0118544:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011854b:	83 ec 0c             	sub    $0xc,%esp
f011854e:	68 bc be 12 f0       	push   $0xf012bebc
f0118553:	e8 33 8a fe ff       	call   f0100f8b <cprintf>
f0118558:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011855b:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0118562:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0118565:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011856b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011856e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118575:	eb 0e                	jmp    f0118585 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0118577:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011857a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011857d:	01 d0                	add    %edx,%eax
f011857f:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0118582:	ff 45 f4             	incl   -0xc(%ebp)
f0118585:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011858b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011858e:	7f e7                	jg     f0118577 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0118590:	e8 67 51 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118595:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118598:	e8 c9 c2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011859d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f01185a0:	83 ec 0c             	sub    $0xc,%esp
f01185a3:	68 00 fc 2f 00       	push   $0x2ffc00
f01185a8:	e8 5f 07 ff ff       	call   f0108d0c <kmalloc>
f01185ad:	83 c4 10             	add    $0x10,%esp
f01185b0:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01185b6:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01185bc:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01185c1:	74 17                	je     f01185da <test_kfree_bestfirstfit+0x316>
f01185c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01185ca:	83 ec 0c             	sub    $0xc,%esp
f01185cd:	68 04 bf 12 f0       	push   $0xf012bf04
f01185d2:	e8 b4 89 fe ff       	call   f0100f8b <cprintf>
f01185d7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185da:	e8 87 c2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01185df:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01185e2:	74 17                	je     f01185fb <test_kfree_bestfirstfit+0x337>
f01185e4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01185eb:	83 ec 0c             	sub    $0xc,%esp
f01185ee:	68 58 bf 12 f0       	push   $0xf012bf58
f01185f3:	e8 93 89 fe ff       	call   f0100f8b <cprintf>
f01185f8:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01185fb:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01185fe:	e8 f9 50 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118603:	29 c3                	sub    %eax,%ebx
f0118605:	89 d8                	mov    %ebx,%eax
f0118607:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011860c:	77 17                	ja     f0118625 <test_kfree_bestfirstfit+0x361>
f011860e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118615:	83 ec 0c             	sub    $0xc,%esp
f0118618:	68 c8 bf 12 f0       	push   $0xf012bfc8
f011861d:	e8 69 89 fe ff       	call   f0100f8b <cprintf>
f0118622:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0118625:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f011862c:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011862f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0118635:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0118638:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011863f:	eb 0e                	jmp    f011864f <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0118641:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118644:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118647:	01 d0                	add    %edx,%eax
f0118649:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f011864c:	ff 45 f4             	incl   -0xc(%ebp)
f011864f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0118655:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118658:	7f e7                	jg     f0118641 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011865a:	e8 9d 50 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011865f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118662:	e8 ff c1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118667:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011866a:	83 ec 0c             	sub    $0xc,%esp
f011866d:	68 00 fc 5f 00       	push   $0x5ffc00
f0118672:	e8 95 06 ff ff       	call   f0108d0c <kmalloc>
f0118677:	83 c4 10             	add    $0x10,%esp
f011867a:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118680:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0118686:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011868b:	74 17                	je     f01186a4 <test_kfree_bestfirstfit+0x3e0>
f011868d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118694:	83 ec 0c             	sub    $0xc,%esp
f0118697:	68 10 c0 12 f0       	push   $0xf012c010
f011869c:	e8 ea 88 fe ff       	call   f0100f8b <cprintf>
f01186a1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01186a4:	e8 bd c1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01186a9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01186ac:	74 17                	je     f01186c5 <test_kfree_bestfirstfit+0x401>
f01186ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01186b5:	83 ec 0c             	sub    $0xc,%esp
f01186b8:	68 64 c0 12 f0       	push   $0xf012c064
f01186bd:	e8 c9 88 fe ff       	call   f0100f8b <cprintf>
f01186c2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01186c5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01186c8:	e8 2f 50 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01186cd:	29 c3                	sub    %eax,%ebx
f01186cf:	89 d8                	mov    %ebx,%eax
f01186d1:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01186d6:	77 17                	ja     f01186ef <test_kfree_bestfirstfit+0x42b>
f01186d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01186df:	83 ec 0c             	sub    $0xc,%esp
f01186e2:	68 d4 c0 12 f0       	push   $0xf012c0d4
f01186e7:	e8 9f 88 fe ff       	call   f0100f8b <cprintf>
f01186ec:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f01186ef:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f01186f6:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f01186f9:	e8 fe 4f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01186fe:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118701:	e8 60 c1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118706:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0118709:	83 ec 0c             	sub    $0xc,%esp
f011870c:	68 00 38 00 00       	push   $0x3800
f0118711:	e8 f6 05 ff ff       	call   f0108d0c <kmalloc>
f0118716:	83 c4 10             	add    $0x10,%esp
f0118719:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011871f:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118725:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011872a:	74 17                	je     f0118743 <test_kfree_bestfirstfit+0x47f>
f011872c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118733:	83 ec 0c             	sub    $0xc,%esp
f0118736:	68 1c c1 12 f0       	push   $0xf012c11c
f011873b:	e8 4b 88 fe ff       	call   f0100f8b <cprintf>
f0118740:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118743:	e8 1e c1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118748:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011874b:	74 17                	je     f0118764 <test_kfree_bestfirstfit+0x4a0>
f011874d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118754:	83 ec 0c             	sub    $0xc,%esp
f0118757:	68 70 c1 12 f0       	push   $0xf012c170
f011875c:	e8 2a 88 fe ff       	call   f0100f8b <cprintf>
f0118761:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118764:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118767:	e8 90 4f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011876c:	29 c3                	sub    %eax,%ebx
f011876e:	89 d8                	mov    %ebx,%eax
f0118770:	83 f8 03             	cmp    $0x3,%eax
f0118773:	77 17                	ja     f011878c <test_kfree_bestfirstfit+0x4c8>
f0118775:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011877c:	83 ec 0c             	sub    $0xc,%esp
f011877f:	68 e0 c1 12 f0       	push   $0xf012c1e0
f0118784:	e8 02 88 fe ff       	call   f0100f8b <cprintf>
f0118789:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f011878c:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0118793:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118799:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f011879c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01187a3:	eb 0e                	jmp    f01187b3 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f01187a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01187a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01187ab:	01 d0                	add    %edx,%eax
f01187ad:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f01187b0:	ff 45 f4             	incl   -0xc(%ebp)
f01187b3:	8b 45 80             	mov    -0x80(%ebp),%eax
f01187b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01187b9:	7f ea                	jg     f01187a5 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f01187bb:	e8 3c 4f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01187c0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f01187c3:	e8 9e c0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01187c8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f01187cb:	83 ec 0c             	sub    $0xc,%esp
f01187ce:	68 00 08 00 00       	push   $0x800
f01187d3:	e8 34 05 ff ff       	call   f0108d0c <kmalloc>
f01187d8:	83 c4 10             	add    $0x10,%esp
f01187db:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01187e1:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01187e7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01187ec:	76 28                	jbe    f0118816 <test_kfree_bestfirstfit+0x552>
f01187ee:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f01187f4:	83 ec 0c             	sub    $0xc,%esp
f01187f7:	6a 00                	push   $0x0
f01187f9:	e8 00 04 ff ff       	call   f0108bfe <sbrk>
f01187fe:	83 c4 10             	add    $0x10,%esp
f0118801:	39 c3                	cmp    %eax,%ebx
f0118803:	73 11                	jae    f0118816 <test_kfree_bestfirstfit+0x552>
f0118805:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011880b:	89 c2                	mov    %eax,%edx
f011880d:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0118812:	39 c2                	cmp    %eax,%edx
f0118814:	72 17                	jb     f011882d <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118816:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011881d:	83 ec 0c             	sub    $0xc,%esp
f0118820:	68 28 c2 12 f0       	push   $0xf012c228
f0118825:	e8 61 87 fe ff       	call   f0100f8b <cprintf>
f011882a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011882d:	e8 34 c0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118832:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118835:	74 17                	je     f011884e <test_kfree_bestfirstfit+0x58a>
f0118837:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011883e:	83 ec 0c             	sub    $0xc,%esp
f0118841:	68 b4 c2 12 f0       	push   $0xf012c2b4
f0118846:	e8 40 87 fe ff       	call   f0100f8b <cprintf>
f011884b:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011884e:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0118855:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0118858:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011885e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0118861:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118868:	eb 0e                	jmp    f0118878 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f011886a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011886d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118870:	01 d0                	add    %edx,%eax
f0118872:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0118875:	ff 45 f4             	incl   -0xc(%ebp)
f0118878:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011887e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118881:	7f e7                	jg     f011886a <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0118883:	e8 de bf fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118888:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011888b:	83 ec 0c             	sub    $0xc,%esp
f011888e:	68 00 08 00 00       	push   $0x800
f0118893:	e8 74 04 ff ff       	call   f0108d0c <kmalloc>
f0118898:	83 c4 10             	add    $0x10,%esp
f011889b:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01188a1:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f01188a7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01188ac:	76 28                	jbe    f01188d6 <test_kfree_bestfirstfit+0x612>
f01188ae:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f01188b4:	83 ec 0c             	sub    $0xc,%esp
f01188b7:	6a 00                	push   $0x0
f01188b9:	e8 40 03 ff ff       	call   f0108bfe <sbrk>
f01188be:	83 c4 10             	add    $0x10,%esp
f01188c1:	39 c3                	cmp    %eax,%ebx
f01188c3:	73 11                	jae    f01188d6 <test_kfree_bestfirstfit+0x612>
f01188c5:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f01188cb:	89 c2                	mov    %eax,%edx
f01188cd:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f01188d2:	39 c2                	cmp    %eax,%edx
f01188d4:	72 17                	jb     f01188ed <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01188d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01188dd:	83 ec 0c             	sub    $0xc,%esp
f01188e0:	68 24 c3 12 f0       	push   $0xf012c324
f01188e5:	e8 a1 86 fe ff       	call   f0100f8b <cprintf>
f01188ea:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01188ed:	e8 74 bf fe ff       	call   f0104866 <pf_calculate_free_frames>
f01188f2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01188f5:	74 17                	je     f011890e <test_kfree_bestfirstfit+0x64a>
f01188f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01188fe:	83 ec 0c             	sub    $0xc,%esp
f0118901:	68 b0 c3 12 f0       	push   $0xf012c3b0
f0118906:	e8 80 86 fe ff       	call   f0100f8b <cprintf>
f011890b:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011890e:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0118915:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0118918:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011891e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0118921:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118928:	eb 0e                	jmp    f0118938 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f011892a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011892d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118930:	01 d0                	add    %edx,%eax
f0118932:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0118935:	ff 45 f4             	incl   -0xc(%ebp)
f0118938:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011893e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118941:	7f e7                	jg     f011892a <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0118943:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118946:	e8 b1 4d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011894b:	29 c3                	sub    %eax,%ebx
f011894d:	89 d8                	mov    %ebx,%eax
f011894f:	83 f8 01             	cmp    $0x1,%eax
f0118952:	74 17                	je     f011896b <test_kfree_bestfirstfit+0x6a7>
f0118954:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011895b:	83 ec 0c             	sub    $0xc,%esp
f011895e:	68 20 c4 12 f0       	push   $0xf012c420
f0118963:	e8 23 86 fe ff       	call   f0100f8b <cprintf>
f0118968:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f011896b:	83 ec 0c             	sub    $0xc,%esp
f011896e:	68 44 c4 12 f0       	push   $0xf012c444
f0118973:	e8 13 86 fe ff       	call   f0100f8b <cprintf>
f0118978:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011897b:	e8 7c 4d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118980:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0118983:	e8 de be fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118988:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011898b:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0118991:	83 ec 0c             	sub    $0xc,%esp
f0118994:	50                   	push   %eax
f0118995:	e8 8c 03 ff ff       	call   f0108d26 <kfree>
f011899a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011899d:	e8 c4 be fe ff       	call   f0104866 <pf_calculate_free_frames>
f01189a2:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01189a5:	74 17                	je     f01189be <test_kfree_bestfirstfit+0x6fa>
f01189a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01189ae:	83 ec 0c             	sub    $0xc,%esp
f01189b1:	68 74 c4 12 f0       	push   $0xf012c474
f01189b6:	e8 d0 85 fe ff       	call   f0100f8b <cprintf>
f01189bb:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f01189be:	e8 39 4d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01189c3:	89 c2                	mov    %eax,%edx
f01189c5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01189c8:	29 c2                	sub    %eax,%edx
f01189ca:	89 d0                	mov    %edx,%eax
f01189cc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01189d1:	77 17                	ja     f01189ea <test_kfree_bestfirstfit+0x726>
f01189d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01189da:	83 ec 0c             	sub    $0xc,%esp
f01189dd:	68 e4 c4 12 f0       	push   $0xf012c4e4
f01189e2:	e8 a4 85 fe ff       	call   f0100f8b <cprintf>
f01189e7:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f01189ea:	e8 0d 4d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01189ef:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01189f2:	e8 6f be fe ff       	call   f0104866 <pf_calculate_free_frames>
f01189f7:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f01189fa:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118a00:	83 ec 0c             	sub    $0xc,%esp
f0118a03:	50                   	push   %eax
f0118a04:	e8 1d 03 ff ff       	call   f0108d26 <kfree>
f0118a09:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a0c:	e8 55 be fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118a11:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118a14:	74 17                	je     f0118a2d <test_kfree_bestfirstfit+0x769>
f0118a16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a1d:	83 ec 0c             	sub    $0xc,%esp
f0118a20:	68 20 c5 12 f0       	push   $0xf012c520
f0118a25:	e8 61 85 fe ff       	call   f0100f8b <cprintf>
f0118a2a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118a2d:	e8 ca 4c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118a32:	89 c2                	mov    %eax,%edx
f0118a34:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118a37:	39 c2                	cmp    %eax,%edx
f0118a39:	74 17                	je     f0118a52 <test_kfree_bestfirstfit+0x78e>
f0118a3b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a42:	83 ec 0c             	sub    $0xc,%esp
f0118a45:	68 90 c5 12 f0       	push   $0xf012c590
f0118a4a:	e8 3c 85 fe ff       	call   f0100f8b <cprintf>
f0118a4f:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0118a52:	e8 a5 4c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118a57:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118a5a:	e8 07 be fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118a5f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0118a62:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0118a68:	83 ec 0c             	sub    $0xc,%esp
f0118a6b:	50                   	push   %eax
f0118a6c:	e8 b5 02 ff ff       	call   f0108d26 <kfree>
f0118a71:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a74:	e8 ed bd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118a79:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118a7c:	74 17                	je     f0118a95 <test_kfree_bestfirstfit+0x7d1>
f0118a7e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a85:	83 ec 0c             	sub    $0xc,%esp
f0118a88:	68 f0 c5 12 f0       	push   $0xf012c5f0
f0118a8d:	e8 f9 84 fe ff       	call   f0100f8b <cprintf>
f0118a92:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118a95:	e8 62 4c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118a9a:	89 c2                	mov    %eax,%edx
f0118a9c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118a9f:	29 c2                	sub    %eax,%edx
f0118aa1:	89 d0                	mov    %edx,%eax
f0118aa3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118aa8:	77 17                	ja     f0118ac1 <test_kfree_bestfirstfit+0x7fd>
f0118aaa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ab1:	83 ec 0c             	sub    $0xc,%esp
f0118ab4:	68 60 c6 12 f0       	push   $0xf012c660
f0118ab9:	e8 cd 84 fe ff       	call   f0100f8b <cprintf>
f0118abe:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0118ac1:	e8 36 4c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118ac6:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118ac9:	e8 98 bd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118ace:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0118ad1:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0118ad7:	83 ec 0c             	sub    $0xc,%esp
f0118ada:	50                   	push   %eax
f0118adb:	e8 46 02 ff ff       	call   f0108d26 <kfree>
f0118ae0:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ae3:	e8 7e bd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118ae8:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118aeb:	74 17                	je     f0118b04 <test_kfree_bestfirstfit+0x840>
f0118aed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118af4:	83 ec 0c             	sub    $0xc,%esp
f0118af7:	68 9c c6 12 f0       	push   $0xf012c69c
f0118afc:	e8 8a 84 fe ff       	call   f0100f8b <cprintf>
f0118b01:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118b04:	e8 f3 4b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118b09:	89 c2                	mov    %eax,%edx
f0118b0b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118b0e:	29 c2                	sub    %eax,%edx
f0118b10:	89 d0                	mov    %edx,%eax
f0118b12:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0118b17:	77 17                	ja     f0118b30 <test_kfree_bestfirstfit+0x86c>
f0118b19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118b20:	83 ec 0c             	sub    $0xc,%esp
f0118b23:	68 0c c7 12 f0       	push   $0xf012c70c
f0118b28:	e8 5e 84 fe ff       	call   f0100f8b <cprintf>
f0118b2d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118b30:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118b34:	74 04                	je     f0118b3a <test_kfree_bestfirstfit+0x876>
f0118b36:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0118b3a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0118b41:	83 ec 0c             	sub    $0xc,%esp
f0118b44:	68 48 c7 12 f0       	push   $0xf012c748
f0118b49:	e8 3d 84 fe ff       	call   f0100f8b <cprintf>
f0118b4e:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0118b51:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118b57:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0118b5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118b61:	eb 1e                	jmp    f0118b81 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0118b63:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0118b69:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118b6c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118b6f:	01 c8                	add    %ecx,%eax
f0118b71:	8a 00                	mov    (%eax),%al
f0118b73:	0f be c0             	movsbl %al,%eax
f0118b76:	01 d0                	add    %edx,%eax
f0118b78:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0118b7e:	ff 45 f4             	incl   -0xc(%ebp)
f0118b81:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118b87:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118b8a:	7f d7                	jg     f0118b63 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0118b8c:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0118b92:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118b98:	89 c1                	mov    %eax,%ecx
f0118b9a:	01 c9                	add    %ecx,%ecx
f0118b9c:	01 c8                	add    %ecx,%eax
f0118b9e:	39 c2                	cmp    %eax,%edx
f0118ba0:	74 17                	je     f0118bb9 <test_kfree_bestfirstfit+0x8f5>
f0118ba2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ba9:	83 ec 0c             	sub    $0xc,%esp
f0118bac:	68 90 c7 12 f0       	push   $0xf012c790
f0118bb1:	e8 d5 83 fe ff       	call   f0100f8b <cprintf>
f0118bb6:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f0118bb9:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0118bbf:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f0118bc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118bc9:	eb 1e                	jmp    f0118be9 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f0118bcb:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f0118bd1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118bd4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118bd7:	01 c8                	add    %ecx,%eax
f0118bd9:	8a 00                	mov    (%eax),%al
f0118bdb:	0f be c0             	movsbl %al,%eax
f0118bde:	01 d0                	add    %edx,%eax
f0118be0:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f0118be6:	ff 45 f4             	incl   -0xc(%ebp)
f0118be9:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0118bef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118bf2:	7f d7                	jg     f0118bcb <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f0118bf4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118bfa:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f0118c00:	c1 e2 02             	shl    $0x2,%edx
f0118c03:	39 d0                	cmp    %edx,%eax
f0118c05:	74 17                	je     f0118c1e <test_kfree_bestfirstfit+0x95a>
f0118c07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c0e:	83 ec 0c             	sub    $0xc,%esp
f0118c11:	68 c8 c7 12 f0       	push   $0xf012c7c8
f0118c16:	e8 70 83 fe ff       	call   f0100f8b <cprintf>
f0118c1b:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f0118c1e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0118c24:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f0118c27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118c2e:	eb 1e                	jmp    f0118c4e <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f0118c30:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f0118c36:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118c39:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c3c:	01 c8                	add    %ecx,%eax
f0118c3e:	8a 00                	mov    (%eax),%al
f0118c40:	0f be c0             	movsbl %al,%eax
f0118c43:	01 d0                	add    %edx,%eax
f0118c45:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f0118c4b:	ff 45 f4             	incl   -0xc(%ebp)
f0118c4e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0118c54:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118c57:	7f d7                	jg     f0118c30 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f0118c59:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f0118c5f:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0118c65:	89 d0                	mov    %edx,%eax
f0118c67:	c1 e0 02             	shl    $0x2,%eax
f0118c6a:	01 d0                	add    %edx,%eax
f0118c6c:	39 c1                	cmp    %eax,%ecx
f0118c6e:	74 17                	je     f0118c87 <test_kfree_bestfirstfit+0x9c3>
f0118c70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c77:	83 ec 0c             	sub    $0xc,%esp
f0118c7a:	68 00 c8 12 f0       	push   $0xf012c800
f0118c7f:	e8 07 83 fe ff       	call   f0100f8b <cprintf>
f0118c84:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f0118c87:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118c8d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f0118c90:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118c97:	eb 1e                	jmp    f0118cb7 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f0118c99:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f0118c9f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118ca2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118ca5:	01 c8                	add    %ecx,%eax
f0118ca7:	8a 00                	mov    (%eax),%al
f0118ca9:	0f be c0             	movsbl %al,%eax
f0118cac:	01 d0                	add    %edx,%eax
f0118cae:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f0118cb4:	ff 45 f4             	incl   -0xc(%ebp)
f0118cb7:	8b 45 80             	mov    -0x80(%ebp),%eax
f0118cba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118cbd:	7f da                	jg     f0118c99 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f0118cbf:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f0118cc5:	8b 55 80             	mov    -0x80(%ebp),%edx
f0118cc8:	89 d0                	mov    %edx,%eax
f0118cca:	01 c0                	add    %eax,%eax
f0118ccc:	01 d0                	add    %edx,%eax
f0118cce:	01 c0                	add    %eax,%eax
f0118cd0:	01 d0                	add    %edx,%eax
f0118cd2:	39 c1                	cmp    %eax,%ecx
f0118cd4:	74 17                	je     f0118ced <test_kfree_bestfirstfit+0xa29>
f0118cd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118cdd:	83 ec 0c             	sub    $0xc,%esp
f0118ce0:	68 38 c8 12 f0       	push   $0xf012c838
f0118ce5:	e8 a1 82 fe ff       	call   f0100f8b <cprintf>
f0118cea:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118ced:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118cf1:	74 04                	je     f0118cf7 <test_kfree_bestfirstfit+0xa33>
f0118cf3:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0118cf7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f0118cfe:	83 ec 0c             	sub    $0xc,%esp
f0118d01:	68 70 c8 12 f0       	push   $0xf012c870
f0118d06:	e8 80 82 fe ff       	call   f0100f8b <cprintf>
f0118d0b:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f0118d0e:	e8 e9 49 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118d13:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d16:	e8 4b bb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118d1b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f0118d1e:	83 ec 0c             	sub    $0xc,%esp
f0118d21:	68 00 04 00 00       	push   $0x400
f0118d26:	e8 e1 ff fe ff       	call   f0108d0c <kmalloc>
f0118d2b:	83 c4 10             	add    $0x10,%esp
f0118d2e:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f0118d34:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f0118d3a:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118d40:	39 c2                	cmp    %eax,%edx
f0118d42:	74 17                	je     f0118d5b <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118d44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d4b:	83 ec 0c             	sub    $0xc,%esp
f0118d4e:	68 90 c8 12 f0       	push   $0xf012c890
f0118d53:	e8 33 82 fe ff       	call   f0100f8b <cprintf>
f0118d58:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d5b:	e8 06 bb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118d60:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118d63:	74 17                	je     f0118d7c <test_kfree_bestfirstfit+0xab8>
f0118d65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d6c:	83 ec 0c             	sub    $0xc,%esp
f0118d6f:	68 e4 c8 12 f0       	push   $0xf012c8e4
f0118d74:	e8 12 82 fe ff       	call   f0100f8b <cprintf>
f0118d79:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f0118d7c:	e8 7b 49 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118d81:	89 c2                	mov    %eax,%edx
f0118d83:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118d86:	39 c2                	cmp    %eax,%edx
f0118d88:	74 17                	je     f0118da1 <test_kfree_bestfirstfit+0xadd>
f0118d8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d91:	83 ec 0c             	sub    $0xc,%esp
f0118d94:	68 54 c9 12 f0       	push   $0xf012c954
f0118d99:	e8 ed 81 fe ff       	call   f0100f8b <cprintf>
f0118d9e:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f0118da1:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f0118da8:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0118dae:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f0118db1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118db8:	eb 0e                	jmp    f0118dc8 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f0118dba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118dbd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118dc0:	01 d0                	add    %edx,%eax
f0118dc2:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f0118dc5:	ff 45 f4             	incl   -0xc(%ebp)
f0118dc8:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118dcb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118dce:	7f ea                	jg     f0118dba <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f0118dd0:	e8 27 49 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118dd5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118dd8:	e8 89 ba fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118ddd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f0118de0:	83 ec 0c             	sub    $0xc,%esp
f0118de3:	68 00 00 30 00       	push   $0x300000
f0118de8:	e8 1f ff fe ff       	call   f0108d0c <kmalloc>
f0118ded:	83 c4 10             	add    $0x10,%esp
f0118df0:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118df6:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0118dfc:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118e01:	74 17                	je     f0118e1a <test_kfree_bestfirstfit+0xb56>
f0118e03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e0a:	83 ec 0c             	sub    $0xc,%esp
f0118e0d:	68 d0 c9 12 f0       	push   $0xf012c9d0
f0118e12:	e8 74 81 fe ff       	call   f0100f8b <cprintf>
f0118e17:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e1a:	e8 47 ba fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118e1f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118e22:	74 17                	je     f0118e3b <test_kfree_bestfirstfit+0xb77>
f0118e24:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e2b:	83 ec 0c             	sub    $0xc,%esp
f0118e2e:	68 24 ca 12 f0       	push   $0xf012ca24
f0118e33:	e8 53 81 fe ff       	call   f0100f8b <cprintf>
f0118e38:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118e3b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118e3e:	e8 b9 48 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118e43:	29 c3                	sub    %eax,%ebx
f0118e45:	89 d8                	mov    %ebx,%eax
f0118e47:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118e4c:	77 17                	ja     f0118e65 <test_kfree_bestfirstfit+0xba1>
f0118e4e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e55:	83 ec 0c             	sub    $0xc,%esp
f0118e58:	68 94 ca 12 f0       	push   $0xf012ca94
f0118e5d:	e8 29 81 fe ff       	call   f0100f8b <cprintf>
f0118e62:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f0118e65:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f0118e6c:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0118e72:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f0118e75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118e7c:	eb 0e                	jmp    f0118e8c <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f0118e7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118e81:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118e84:	01 d0                	add    %edx,%eax
f0118e86:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f0118e89:	ff 45 f4             	incl   -0xc(%ebp)
f0118e8c:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0118e8f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118e92:	7f ea                	jg     f0118e7e <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f0118e94:	e8 63 48 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118e99:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e9c:	e8 c5 b9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118ea1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f0118ea4:	83 ec 0c             	sub    $0xc,%esp
f0118ea7:	68 00 00 10 00       	push   $0x100000
f0118eac:	e8 5b fe fe ff       	call   f0108d0c <kmalloc>
f0118eb1:	83 c4 10             	add    $0x10,%esp
f0118eb4:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118eba:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0118ec0:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0118ec5:	74 17                	je     f0118ede <test_kfree_bestfirstfit+0xc1a>
f0118ec7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ece:	83 ec 0c             	sub    $0xc,%esp
f0118ed1:	68 dc ca 12 f0       	push   $0xf012cadc
f0118ed6:	e8 b0 80 fe ff       	call   f0100f8b <cprintf>
f0118edb:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ede:	e8 83 b9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118ee3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118ee6:	74 17                	je     f0118eff <test_kfree_bestfirstfit+0xc3b>
f0118ee8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118eef:	83 ec 0c             	sub    $0xc,%esp
f0118ef2:	68 30 cb 12 f0       	push   $0xf012cb30
f0118ef7:	e8 8f 80 fe ff       	call   f0100f8b <cprintf>
f0118efc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118eff:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118f02:	e8 f5 47 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118f07:	29 c3                	sub    %eax,%ebx
f0118f09:	89 d8                	mov    %ebx,%eax
f0118f0b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118f10:	77 17                	ja     f0118f29 <test_kfree_bestfirstfit+0xc65>
f0118f12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118f19:	83 ec 0c             	sub    $0xc,%esp
f0118f1c:	68 a0 cb 12 f0       	push   $0xf012cba0
f0118f21:	e8 65 80 fe ff       	call   f0100f8b <cprintf>
f0118f26:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f0118f29:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f0118f30:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0118f36:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f0118f39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f40:	eb 0e                	jmp    f0118f50 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f0118f42:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118f45:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f48:	01 d0                	add    %edx,%eax
f0118f4a:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f0118f4d:	ff 45 f4             	incl   -0xc(%ebp)
f0118f50:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0118f53:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118f56:	7f ea                	jg     f0118f42 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f0118f58:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118f5c:	74 04                	je     f0118f62 <test_kfree_bestfirstfit+0xc9e>
f0118f5e:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0118f62:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f0118f69:	83 ec 0c             	sub    $0xc,%esp
f0118f6c:	68 e8 cb 12 f0       	push   $0xf012cbe8
f0118f71:	e8 15 80 fe ff       	call   f0100f8b <cprintf>
f0118f76:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f0118f79:	e8 7e 47 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118f7e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118f81:	e8 e0 b8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118f86:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f0118f89:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0118f8f:	83 ec 0c             	sub    $0xc,%esp
f0118f92:	50                   	push   %eax
f0118f93:	e8 8e fd fe ff       	call   f0108d26 <kfree>
f0118f98:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f9b:	e8 c6 b8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118fa0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118fa3:	74 17                	je     f0118fbc <test_kfree_bestfirstfit+0xcf8>
f0118fa5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118fac:	83 ec 0c             	sub    $0xc,%esp
f0118faf:	68 14 cc 12 f0       	push   $0xf012cc14
f0118fb4:	e8 d2 7f fe ff       	call   f0100f8b <cprintf>
f0118fb9:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118fbc:	e8 3b 47 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118fc1:	89 c2                	mov    %eax,%edx
f0118fc3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118fc6:	29 c2                	sub    %eax,%edx
f0118fc8:	89 d0                	mov    %edx,%eax
f0118fca:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118fcf:	77 17                	ja     f0118fe8 <test_kfree_bestfirstfit+0xd24>
f0118fd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118fd8:	83 ec 0c             	sub    $0xc,%esp
f0118fdb:	68 84 cc 12 f0       	push   $0xf012cc84
f0118fe0:	e8 a6 7f fe ff       	call   f0100f8b <cprintf>
f0118fe5:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f0118fe8:	e8 0f 47 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0118fed:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118ff0:	e8 71 b8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118ff5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f0118ff8:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0118ffe:	83 ec 0c             	sub    $0xc,%esp
f0119001:	50                   	push   %eax
f0119002:	e8 1f fd fe ff       	call   f0108d26 <kfree>
f0119007:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011900a:	e8 57 b8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011900f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119012:	74 17                	je     f011902b <test_kfree_bestfirstfit+0xd67>
f0119014:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011901b:	83 ec 0c             	sub    $0xc,%esp
f011901e:	68 c0 cc 12 f0       	push   $0xf012ccc0
f0119023:	e8 63 7f fe ff       	call   f0100f8b <cprintf>
f0119028:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011902b:	e8 cc 46 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119030:	89 c2                	mov    %eax,%edx
f0119032:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119035:	29 c2                	sub    %eax,%edx
f0119037:	89 d0                	mov    %edx,%eax
f0119039:	83 f8 01             	cmp    $0x1,%eax
f011903c:	77 17                	ja     f0119055 <test_kfree_bestfirstfit+0xd91>
f011903e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119045:	83 ec 0c             	sub    $0xc,%esp
f0119048:	68 30 cd 12 f0       	push   $0xf012cd30
f011904d:	e8 39 7f fe ff       	call   f0100f8b <cprintf>
f0119052:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f0119055:	e8 a2 46 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011905a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011905d:	e8 04 b8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119062:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f0119065:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011906b:	83 ec 0c             	sub    $0xc,%esp
f011906e:	50                   	push   %eax
f011906f:	e8 b2 fc fe ff       	call   f0108d26 <kfree>
f0119074:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119077:	e8 ea b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011907c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011907f:	74 17                	je     f0119098 <test_kfree_bestfirstfit+0xdd4>
f0119081:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119088:	83 ec 0c             	sub    $0xc,%esp
f011908b:	68 6c cd 12 f0       	push   $0xf012cd6c
f0119090:	e8 f6 7e fe ff       	call   f0100f8b <cprintf>
f0119095:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119098:	e8 5f 46 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011909d:	89 c2                	mov    %eax,%edx
f011909f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01190a2:	29 c2                	sub    %eax,%edx
f01190a4:	89 d0                	mov    %edx,%eax
f01190a6:	83 f8 03             	cmp    $0x3,%eax
f01190a9:	77 17                	ja     f01190c2 <test_kfree_bestfirstfit+0xdfe>
f01190ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01190b2:	83 ec 0c             	sub    $0xc,%esp
f01190b5:	68 dc cd 12 f0       	push   $0xf012cddc
f01190ba:	e8 cc 7e fe ff       	call   f0100f8b <cprintf>
f01190bf:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f01190c2:	e8 35 46 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01190c7:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01190ca:	e8 97 b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01190cf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f01190d2:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01190d8:	83 ec 0c             	sub    $0xc,%esp
f01190db:	50                   	push   %eax
f01190dc:	e8 45 fc fe ff       	call   f0108d26 <kfree>
f01190e1:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01190e4:	e8 7d b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01190e9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01190ec:	74 17                	je     f0119105 <test_kfree_bestfirstfit+0xe41>
f01190ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01190f5:	83 ec 0c             	sub    $0xc,%esp
f01190f8:	68 18 ce 12 f0       	push   $0xf012ce18
f01190fd:	e8 89 7e fe ff       	call   f0100f8b <cprintf>
f0119102:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119105:	e8 f2 45 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011910a:	89 c2                	mov    %eax,%edx
f011910c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011910f:	29 c2                	sub    %eax,%edx
f0119111:	89 d0                	mov    %edx,%eax
f0119113:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119118:	77 17                	ja     f0119131 <test_kfree_bestfirstfit+0xe6d>
f011911a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119121:	83 ec 0c             	sub    $0xc,%esp
f0119124:	68 88 ce 12 f0       	push   $0xf012ce88
f0119129:	e8 5d 7e fe ff       	call   f0100f8b <cprintf>
f011912e:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f0119131:	e8 c6 45 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119136:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119139:	e8 28 b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011913e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f0119141:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119147:	83 ec 0c             	sub    $0xc,%esp
f011914a:	50                   	push   %eax
f011914b:	e8 d6 fb fe ff       	call   f0108d26 <kfree>
f0119150:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119153:	e8 0e b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119158:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011915b:	74 17                	je     f0119174 <test_kfree_bestfirstfit+0xeb0>
f011915d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119164:	83 ec 0c             	sub    $0xc,%esp
f0119167:	68 c4 ce 12 f0       	push   $0xf012cec4
f011916c:	e8 1a 7e fe ff       	call   f0100f8b <cprintf>
f0119171:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119174:	e8 83 45 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119179:	89 c2                	mov    %eax,%edx
f011917b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011917e:	29 c2                	sub    %eax,%edx
f0119180:	89 d0                	mov    %edx,%eax
f0119182:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119187:	77 17                	ja     f01191a0 <test_kfree_bestfirstfit+0xedc>
f0119189:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119190:	83 ec 0c             	sub    $0xc,%esp
f0119193:	68 34 cf 12 f0       	push   $0xf012cf34
f0119198:	e8 ee 7d fe ff       	call   f0100f8b <cprintf>
f011919d:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f01191a0:	e8 57 45 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01191a5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01191a8:	e8 b9 b6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01191ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f01191b0:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f01191b6:	83 ec 0c             	sub    $0xc,%esp
f01191b9:	50                   	push   %eax
f01191ba:	e8 67 fb fe ff       	call   f0108d26 <kfree>
f01191bf:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01191c2:	e8 9f b6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01191c7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01191ca:	74 17                	je     f01191e3 <test_kfree_bestfirstfit+0xf1f>
f01191cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191d3:	83 ec 0c             	sub    $0xc,%esp
f01191d6:	68 70 cf 12 f0       	push   $0xf012cf70
f01191db:	e8 ab 7d fe ff       	call   f0100f8b <cprintf>
f01191e0:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f01191e3:	e8 14 45 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01191e8:	89 c2                	mov    %eax,%edx
f01191ea:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01191ed:	39 c2                	cmp    %eax,%edx
f01191ef:	74 17                	je     f0119208 <test_kfree_bestfirstfit+0xf44>
f01191f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191f8:	83 ec 0c             	sub    $0xc,%esp
f01191fb:	68 e0 cf 12 f0       	push   $0xf012cfe0
f0119200:	e8 86 7d fe ff       	call   f0100f8b <cprintf>
f0119205:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f0119208:	e8 ef 44 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011920d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119210:	e8 51 b6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119215:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f0119218:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011921e:	83 ec 0c             	sub    $0xc,%esp
f0119221:	50                   	push   %eax
f0119222:	e8 ff fa fe ff       	call   f0108d26 <kfree>
f0119227:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011922a:	e8 37 b6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011922f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119232:	74 17                	je     f011924b <test_kfree_bestfirstfit+0xf87>
f0119234:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011923b:	83 ec 0c             	sub    $0xc,%esp
f011923e:	68 1c d0 12 f0       	push   $0xf012d01c
f0119243:	e8 43 7d fe ff       	call   f0100f8b <cprintf>
f0119248:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011924b:	e8 ac 44 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119250:	89 c2                	mov    %eax,%edx
f0119252:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119255:	39 c2                	cmp    %eax,%edx
f0119257:	74 17                	je     f0119270 <test_kfree_bestfirstfit+0xfac>
f0119259:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119260:	83 ec 0c             	sub    $0xc,%esp
f0119263:	68 8c d0 12 f0       	push   $0xf012d08c
f0119268:	e8 1e 7d fe ff       	call   f0100f8b <cprintf>
f011926d:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f0119270:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119274:	74 04                	je     f011927a <test_kfree_bestfirstfit+0xfb6>
f0119276:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011927a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f0119281:	83 ec 0c             	sub    $0xc,%esp
f0119284:	68 ec d0 12 f0       	push   $0xf012d0ec
f0119289:	e8 fd 7c fe ff       	call   f0100f8b <cprintf>
f011928e:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f0119291:	83 ec 0c             	sub    $0xc,%esp
f0119294:	6a 03                	push   $0x3
f0119296:	e8 76 48 ff ff       	call   f010db11 <sys_bypassPageFault>
f011929b:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011929e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01192a5:	e9 af 00 00 00       	jmp    f0119359 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f01192aa:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01192ae:	0f 84 a1 00 00 00    	je     f0119355 <test_kfree_bestfirstfit+0x1091>
f01192b4:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f01192b8:	0f 84 97 00 00 00    	je     f0119355 <test_kfree_bestfirstfit+0x1091>
f01192be:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f01192c2:	0f 84 8d 00 00 00    	je     f0119355 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f01192c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01192cb:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f01192d2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f01192d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01192d8:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f01192db:	e8 1f 48 ff ff       	call   f010daff <sys_rcr2>
f01192e0:	89 c2                	mov    %eax,%edx
f01192e2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01192e5:	39 c2                	cmp    %eax,%edx
f01192e7:	74 1d                	je     f0119306 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f01192e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01192ed:	74 17                	je     f0119306 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f01192ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192f6:	83 ec 0c             	sub    $0xc,%esp
f01192f9:	68 2c d1 12 f0       	push   $0xf012d12c
f01192fe:	e8 88 7c fe ff       	call   f0100f8b <cprintf>
f0119303:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f0119306:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119309:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f0119310:	89 c2                	mov    %eax,%edx
f0119312:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119315:	01 d0                	add    %edx,%eax
f0119317:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011931a:	e8 e0 47 ff ff       	call   f010daff <sys_rcr2>
f011931f:	89 c2                	mov    %eax,%edx
f0119321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119324:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011932b:	89 c1                	mov    %eax,%ecx
f011932d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119330:	01 c8                	add    %ecx,%eax
f0119332:	39 c2                	cmp    %eax,%edx
f0119334:	74 20                	je     f0119356 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f0119336:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011933a:	74 1a                	je     f0119356 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011933c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119343:	83 ec 0c             	sub    $0xc,%esp
f0119346:	68 78 d1 12 f0       	push   $0xf012d178
f011934b:	e8 3b 7c fe ff       	call   f0100f8b <cprintf>
f0119350:	83 c4 10             	add    $0x10,%esp
f0119353:	eb 01                	jmp    f0119356 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f0119355:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f0119356:	ff 45 f4             	incl   -0xc(%ebp)
f0119359:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011935d:	0f 8e 47 ff ff ff    	jle    f01192aa <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f0119363:	83 ec 0c             	sub    $0xc,%esp
f0119366:	6a 00                	push   $0x0
f0119368:	e8 a4 47 ff ff       	call   f010db11 <sys_bypassPageFault>
f011936d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f0119370:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119374:	74 04                	je     f011937a <test_kfree_bestfirstfit+0x10b6>
f0119376:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011937a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f0119381:	83 ec 0c             	sub    $0xc,%esp
f0119384:	68 c4 d1 12 f0       	push   $0xf012d1c4
f0119389:	e8 fd 7b fe ff       	call   f0100f8b <cprintf>
f011938e:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f0119391:	e8 66 43 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119396:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119399:	e8 c8 b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011939e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f01193a1:	83 ec 0c             	sub    $0xc,%esp
f01193a4:	68 00 04 00 00       	push   $0x400
f01193a9:	e8 5e f9 fe ff       	call   f0108d0c <kmalloc>
f01193ae:	83 c4 10             	add    $0x10,%esp
f01193b1:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f01193b7:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f01193bd:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01193c3:	39 c2                	cmp    %eax,%edx
f01193c5:	74 17                	je     f01193de <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01193c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193ce:	83 ec 0c             	sub    $0xc,%esp
f01193d1:	68 e8 d1 12 f0       	push   $0xf012d1e8
f01193d6:	e8 b0 7b fe ff       	call   f0100f8b <cprintf>
f01193db:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01193de:	e8 83 b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01193e3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01193e6:	74 17                	je     f01193ff <test_kfree_bestfirstfit+0x113b>
f01193e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193ef:	83 ec 0c             	sub    $0xc,%esp
f01193f2:	68 3c d2 12 f0       	push   $0xf012d23c
f01193f7:	e8 8f 7b fe ff       	call   f0100f8b <cprintf>
f01193fc:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01193ff:	e8 f8 42 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119404:	89 c2                	mov    %eax,%edx
f0119406:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119409:	39 c2                	cmp    %eax,%edx
f011940b:	74 17                	je     f0119424 <test_kfree_bestfirstfit+0x1160>
f011940d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119414:	83 ec 0c             	sub    $0xc,%esp
f0119417:	68 ac d2 12 f0       	push   $0xf012d2ac
f011941c:	e8 6a 7b fe ff       	call   f0100f8b <cprintf>
f0119421:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f0119424:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011942b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f0119431:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f0119434:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011943b:	eb 0e                	jmp    f011944b <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011943d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119440:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119443:	01 d0                	add    %edx,%eax
f0119445:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f0119448:	ff 45 f4             	incl   -0xc(%ebp)
f011944b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011944e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119451:	7f ea                	jg     f011943d <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f0119453:	e8 a4 42 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119458:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011945b:	e8 06 b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119460:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f0119463:	83 ec 0c             	sub    $0xc,%esp
f0119466:	68 00 08 00 00       	push   $0x800
f011946b:	e8 9c f8 fe ff       	call   f0108d0c <kmalloc>
f0119470:	83 c4 10             	add    $0x10,%esp
f0119473:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f0119479:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011947f:	05 08 04 00 00       	add    $0x408,%eax
f0119484:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f0119487:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011948d:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0119490:	74 35                	je     f01194c7 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f0119492:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f0119499:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011949f:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f01194a5:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f01194ab:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f01194b1:	81 c2 00 04 00 00    	add    $0x400,%edx
f01194b7:	50                   	push   %eax
f01194b8:	51                   	push   %ecx
f01194b9:	52                   	push   %edx
f01194ba:	68 28 d3 12 f0       	push   $0xf012d328
f01194bf:	e8 c7 7a fe ff       	call   f0100f8b <cprintf>
f01194c4:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194c7:	e8 9a b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01194cc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01194cf:	74 17                	je     f01194e8 <test_kfree_bestfirstfit+0x1224>
f01194d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194d8:	83 ec 0c             	sub    $0xc,%esp
f01194db:	68 9c d3 12 f0       	push   $0xf012d39c
f01194e0:	e8 a6 7a fe ff       	call   f0100f8b <cprintf>
f01194e5:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01194e8:	e8 0f 42 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01194ed:	89 c2                	mov    %eax,%edx
f01194ef:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01194f2:	39 c2                	cmp    %eax,%edx
f01194f4:	74 17                	je     f011950d <test_kfree_bestfirstfit+0x1249>
f01194f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194fd:	83 ec 0c             	sub    $0xc,%esp
f0119500:	68 0c d4 12 f0       	push   $0xf012d40c
f0119505:	e8 81 7a fe ff       	call   f0100f8b <cprintf>
f011950a:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011950d:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f0119514:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011951a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011951d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119524:	eb 0e                	jmp    f0119534 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f0119526:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119529:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011952c:	01 d0                	add    %edx,%eax
f011952e:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f0119531:	ff 45 f4             	incl   -0xc(%ebp)
f0119534:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0119537:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011953a:	7f ea                	jg     f0119526 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011953c:	e8 bb 41 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119541:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119544:	e8 1d b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119549:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011954c:	83 ec 0c             	sub    $0xc,%esp
f011954f:	68 00 06 00 00       	push   $0x600
f0119554:	e8 b3 f7 fe ff       	call   f0108d0c <kmalloc>
f0119559:	83 c4 10             	add    $0x10,%esp
f011955c:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f0119562:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119568:	05 10 0c 00 00       	add    $0xc10,%eax
f011956d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f0119570:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f0119576:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0119579:	74 17                	je     f0119592 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011957b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119582:	83 ec 0c             	sub    $0xc,%esp
f0119585:	68 88 d4 12 f0       	push   $0xf012d488
f011958a:	e8 fc 79 fe ff       	call   f0100f8b <cprintf>
f011958f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119592:	e8 cf b2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119597:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011959a:	74 17                	je     f01195b3 <test_kfree_bestfirstfit+0x12ef>
f011959c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195a3:	83 ec 0c             	sub    $0xc,%esp
f01195a6:	68 dc d4 12 f0       	push   $0xf012d4dc
f01195ab:	e8 db 79 fe ff       	call   f0100f8b <cprintf>
f01195b0:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01195b3:	e8 44 41 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01195b8:	89 c2                	mov    %eax,%edx
f01195ba:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01195bd:	39 c2                	cmp    %eax,%edx
f01195bf:	74 17                	je     f01195d8 <test_kfree_bestfirstfit+0x1314>
f01195c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195c8:	83 ec 0c             	sub    $0xc,%esp
f01195cb:	68 4c d5 12 f0       	push   $0xf012d54c
f01195d0:	e8 b6 79 fe ff       	call   f0100f8b <cprintf>
f01195d5:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f01195d8:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f01195df:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f01195e5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f01195e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01195ef:	eb 0e                	jmp    f01195ff <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f01195f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01195f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01195f7:	01 d0                	add    %edx,%eax
f01195f9:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f01195fc:	ff 45 f4             	incl   -0xc(%ebp)
f01195ff:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119602:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119605:	7f ea                	jg     f01195f1 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f0119607:	e8 f0 40 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011960c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011960f:	e8 52 b2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119614:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f0119617:	83 ec 0c             	sub    $0xc,%esp
f011961a:	68 00 00 e0 01       	push   $0x1e00000
f011961f:	e8 e8 f6 fe ff       	call   f0108d0c <kmalloc>
f0119624:	83 c4 10             	add    $0x10,%esp
f0119627:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011962d:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119633:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119638:	74 17                	je     f0119651 <test_kfree_bestfirstfit+0x138d>
f011963a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119641:	83 ec 0c             	sub    $0xc,%esp
f0119644:	68 c8 d5 12 f0       	push   $0xf012d5c8
f0119649:	e8 3d 79 fe ff       	call   f0100f8b <cprintf>
f011964e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119651:	e8 10 b2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119656:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119659:	74 17                	je     f0119672 <test_kfree_bestfirstfit+0x13ae>
f011965b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119662:	83 ec 0c             	sub    $0xc,%esp
f0119665:	68 1c d6 12 f0       	push   $0xf012d61c
f011966a:	e8 1c 79 fe ff       	call   f0100f8b <cprintf>
f011966f:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119672:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119675:	e8 82 40 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011967a:	29 c3                	sub    %eax,%ebx
f011967c:	89 d8                	mov    %ebx,%eax
f011967e:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f0119683:	77 17                	ja     f011969c <test_kfree_bestfirstfit+0x13d8>
f0119685:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011968c:	83 ec 0c             	sub    $0xc,%esp
f011968f:	68 8c d6 12 f0       	push   $0xf012d68c
f0119694:	e8 f2 78 fe ff       	call   f0100f8b <cprintf>
f0119699:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011969c:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f01196a3:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01196a9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f01196ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01196b3:	eb 0e                	jmp    f01196c3 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f01196b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01196b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01196bb:	01 d0                	add    %edx,%eax
f01196bd:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f01196c0:	ff 45 f4             	incl   -0xc(%ebp)
f01196c3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01196c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01196c9:	7f ea                	jg     f01196b5 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f01196cb:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01196d1:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f01196d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01196db:	eb 1e                	jmp    f01196fb <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f01196dd:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f01196e3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01196e6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01196e9:	01 c8                	add    %ecx,%eax
f01196eb:	8a 00                	mov    (%eax),%al
f01196ed:	0f be c0             	movsbl %al,%eax
f01196f0:	01 d0                	add    %edx,%eax
f01196f2:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f01196f8:	ff 45 f4             	incl   -0xc(%ebp)
f01196fb:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01196fe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119701:	7f da                	jg     f01196dd <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f0119703:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f0119709:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011970c:	89 d0                	mov    %edx,%eax
f011970e:	c1 e0 02             	shl    $0x2,%eax
f0119711:	01 d0                	add    %edx,%eax
f0119713:	01 c0                	add    %eax,%eax
f0119715:	39 c1                	cmp    %eax,%ecx
f0119717:	74 17                	je     f0119730 <test_kfree_bestfirstfit+0x146c>
f0119719:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119720:	83 ec 0c             	sub    $0xc,%esp
f0119723:	68 d4 d6 12 f0       	push   $0xf012d6d4
f0119728:	e8 5e 78 fe ff       	call   f0100f8b <cprintf>
f011972d:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f0119730:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f0119736:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f0119739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119740:	eb 1e                	jmp    f0119760 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f0119742:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0119748:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011974b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011974e:	01 c8                	add    %ecx,%eax
f0119750:	8a 00                	mov    (%eax),%al
f0119752:	0f be c0             	movsbl %al,%eax
f0119755:	01 d0                	add    %edx,%eax
f0119757:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011975d:	ff 45 f4             	incl   -0xc(%ebp)
f0119760:	8b 45 90             	mov    -0x70(%ebp),%eax
f0119763:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119766:	7f da                	jg     f0119742 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f0119768:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011976e:	8b 55 90             	mov    -0x70(%ebp),%edx
f0119771:	89 d0                	mov    %edx,%eax
f0119773:	c1 e0 02             	shl    $0x2,%eax
f0119776:	01 d0                	add    %edx,%eax
f0119778:	01 c0                	add    %eax,%eax
f011977a:	01 d0                	add    %edx,%eax
f011977c:	39 c1                	cmp    %eax,%ecx
f011977e:	74 17                	je     f0119797 <test_kfree_bestfirstfit+0x14d3>
f0119780:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119787:	83 ec 0c             	sub    $0xc,%esp
f011978a:	68 04 d7 12 f0       	push   $0xf012d704
f011978f:	e8 f7 77 fe ff       	call   f0100f8b <cprintf>
f0119794:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f0119797:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011979d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f01197a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01197a7:	eb 1e                	jmp    f01197c7 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f01197a9:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f01197af:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01197b2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01197b5:	01 c8                	add    %ecx,%eax
f01197b7:	8a 00                	mov    (%eax),%al
f01197b9:	0f be c0             	movsbl %al,%eax
f01197bc:	01 d0                	add    %edx,%eax
f01197be:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f01197c4:	ff 45 f4             	incl   -0xc(%ebp)
f01197c7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01197ca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01197cd:	7f da                	jg     f01197a9 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f01197cf:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f01197d5:	8b 55 94             	mov    -0x6c(%ebp),%edx
f01197d8:	89 d0                	mov    %edx,%eax
f01197da:	01 c0                	add    %eax,%eax
f01197dc:	01 d0                	add    %edx,%eax
f01197de:	c1 e0 02             	shl    $0x2,%eax
f01197e1:	39 c1                	cmp    %eax,%ecx
f01197e3:	74 17                	je     f01197fc <test_kfree_bestfirstfit+0x1538>
f01197e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197ec:	83 ec 0c             	sub    $0xc,%esp
f01197ef:	68 34 d7 12 f0       	push   $0xf012d734
f01197f4:	e8 92 77 fe ff       	call   f0100f8b <cprintf>
f01197f9:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f01197fc:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f0119802:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f0119805:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011980c:	eb 1e                	jmp    f011982c <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011980e:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f0119814:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119817:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011981a:	01 c8                	add    %ecx,%eax
f011981c:	8a 00                	mov    (%eax),%al
f011981e:	0f be c0             	movsbl %al,%eax
f0119821:	01 d0                	add    %edx,%eax
f0119823:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f0119829:	ff 45 f4             	incl   -0xc(%ebp)
f011982c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011982f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119832:	7f da                	jg     f011980e <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f0119834:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011983a:	8b 55 98             	mov    -0x68(%ebp),%edx
f011983d:	89 d0                	mov    %edx,%eax
f011983f:	01 c0                	add    %eax,%eax
f0119841:	01 d0                	add    %edx,%eax
f0119843:	c1 e0 02             	shl    $0x2,%eax
f0119846:	01 d0                	add    %edx,%eax
f0119848:	39 c1                	cmp    %eax,%ecx
f011984a:	74 17                	je     f0119863 <test_kfree_bestfirstfit+0x159f>
f011984c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119853:	83 ec 0c             	sub    $0xc,%esp
f0119856:	68 64 d7 12 f0       	push   $0xf012d764
f011985b:	e8 2b 77 fe ff       	call   f0100f8b <cprintf>
f0119860:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f0119863:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119867:	74 04                	je     f011986d <test_kfree_bestfirstfit+0x15a9>
f0119869:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011986d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f0119874:	83 ec 0c             	sub    $0xc,%esp
f0119877:	68 91 d7 12 f0       	push   $0xf012d791
f011987c:	e8 0a 77 fe ff       	call   f0100f8b <cprintf>
f0119881:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f0119884:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011988b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0119892:	eb 4e                	jmp    f01198e2 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f0119894:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119897:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011989c:	83 ec 04             	sub    $0x4,%esp
f011989f:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f01198a5:	51                   	push   %ecx
f01198a6:	52                   	push   %edx
f01198a7:	50                   	push   %eax
f01198a8:	e8 d7 ea fe ff       	call   f0108384 <get_page_table>
f01198ad:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f01198b0:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f01198b6:	85 c0                	test   %eax,%eax
f01198b8:	75 1d                	jne    f01198d7 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f01198ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01198be:	74 17                	je     f01198d7 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f01198c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198c7:	83 ec 0c             	sub    $0xc,%esp
f01198ca:	68 b0 d7 12 f0       	push   $0xf012d7b0
f01198cf:	e8 b7 76 fe ff       	call   f0100f8b <cprintf>
f01198d4:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f01198d7:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f01198de:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f01198e2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01198e6:	78 ac                	js     f0119894 <test_kfree_bestfirstfit+0x15d0>
f01198e8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01198ec:	7f 09                	jg     f01198f7 <test_kfree_bestfirstfit+0x1633>
f01198ee:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f01198f5:	76 9d                	jbe    f0119894 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f01198f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01198fb:	74 04                	je     f0119901 <test_kfree_bestfirstfit+0x163d>
f01198fd:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f0119901:	83 ec 08             	sub    $0x8,%esp
f0119904:	ff 75 f0             	pushl  -0x10(%ebp)
f0119907:	68 18 d8 12 f0       	push   $0xf012d818
f011990c:	e8 7a 76 fe ff       	call   f0100f8b <cprintf>
f0119911:	83 c4 10             	add    $0x10,%esp

	return 1;
f0119914:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119919:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011991c:	5b                   	pop    %ebx
f011991d:	5f                   	pop    %edi
f011991e:	5d                   	pop    %ebp
f011991f:	c3                   	ret    

f0119920 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f0119920:	55                   	push   %ebp
f0119921:	89 e5                	mov    %esp,%ebp
f0119923:	57                   	push   %edi
f0119924:	53                   	push   %ebx
f0119925:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011992b:	83 ec 0c             	sub    $0xc,%esp
f011992e:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0119933:	e8 53 76 fe ff       	call   f0100f8b <cprintf>
f0119938:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011993b:	83 ec 0c             	sub    $0xc,%esp
f011993e:	68 18 9b 12 f0       	push   $0xf0129b18
f0119943:	e8 43 76 fe ff       	call   f0100f8b <cprintf>
f0119948:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011994b:	83 ec 0c             	sub    $0xc,%esp
f011994e:	68 e8 9a 12 f0       	push   $0xf0129ae8
f0119953:	e8 33 76 fe ff       	call   f0100f8b <cprintf>
f0119958:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011995b:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011995f:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f0119963:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f0119969:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011996f:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119976:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011997d:	e8 7a 3d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119982:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f0119985:	83 ec 0c             	sub    $0xc,%esp
f0119988:	68 3c d8 12 f0       	push   $0xf012d83c
f011998d:	e8 f9 75 fe ff       	call   f0100f8b <cprintf>
f0119992:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0119995:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011999b:	b9 14 00 00 00       	mov    $0x14,%ecx
f01199a0:	b8 00 00 00 00       	mov    $0x0,%eax
f01199a5:	89 d7                	mov    %edx,%edi
f01199a7:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f01199a9:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f01199af:	b9 14 00 00 00       	mov    $0x14,%ecx
f01199b4:	b8 00 00 00 00       	mov    $0x0,%eax
f01199b9:	89 d7                	mov    %edx,%edi
f01199bb:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f01199bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f01199c4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f01199cb:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f01199d1:	b9 14 00 00 00       	mov    $0x14,%ecx
f01199d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01199db:	89 d7                	mov    %edx,%edi
f01199dd:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f01199df:	e8 18 3d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f01199e4:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01199e7:	e8 7a ae fe ff       	call   f0104866 <pf_calculate_free_frames>
f01199ec:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01199ef:	83 ec 0c             	sub    $0xc,%esp
f01199f2:	68 00 fc 1f 00       	push   $0x1ffc00
f01199f7:	e8 10 f3 fe ff       	call   f0108d0c <kmalloc>
f01199fc:	83 c4 10             	add    $0x10,%esp
f01199ff:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a05:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f0119a0b:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119a10:	74 17                	je     f0119a29 <test_kheap_phys_addr+0x109>
f0119a12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a19:	83 ec 0c             	sub    $0xc,%esp
f0119a1c:	68 e0 bb 12 f0       	push   $0xf012bbe0
f0119a21:	e8 65 75 fe ff       	call   f0100f8b <cprintf>
f0119a26:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a29:	e8 38 ae fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119a2e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119a31:	74 17                	je     f0119a4a <test_kheap_phys_addr+0x12a>
f0119a33:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a3a:	83 ec 0c             	sub    $0xc,%esp
f0119a3d:	68 34 bc 12 f0       	push   $0xf012bc34
f0119a42:	e8 44 75 fe ff       	call   f0100f8b <cprintf>
f0119a47:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119a4a:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119a4d:	e8 aa 3c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119a52:	29 c3                	sub    %eax,%ebx
f0119a54:	89 d8                	mov    %ebx,%eax
f0119a56:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119a5b:	77 17                	ja     f0119a74 <test_kheap_phys_addr+0x154>
f0119a5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a64:	83 ec 0c             	sub    $0xc,%esp
f0119a67:	68 a4 bc 12 f0       	push   $0xf012bca4
f0119a6c:	e8 1a 75 fe ff       	call   f0100f8b <cprintf>
f0119a71:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119a74:	e8 83 3c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119a79:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119a7c:	e8 e5 ad fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119a81:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119a84:	83 ec 0c             	sub    $0xc,%esp
f0119a87:	68 00 fc 1f 00       	push   $0x1ffc00
f0119a8c:	e8 7b f2 fe ff       	call   f0108d0c <kmalloc>
f0119a91:	83 c4 10             	add    $0x10,%esp
f0119a94:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a9a:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f0119aa0:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119aa5:	74 17                	je     f0119abe <test_kheap_phys_addr+0x19e>
f0119aa7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aae:	83 ec 0c             	sub    $0xc,%esp
f0119ab1:	68 ec bc 12 f0       	push   $0xf012bcec
f0119ab6:	e8 d0 74 fe ff       	call   f0100f8b <cprintf>
f0119abb:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119abe:	e8 a3 ad fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ac3:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119ac6:	74 17                	je     f0119adf <test_kheap_phys_addr+0x1bf>
f0119ac8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119acf:	83 ec 0c             	sub    $0xc,%esp
f0119ad2:	68 40 bd 12 f0       	push   $0xf012bd40
f0119ad7:	e8 af 74 fe ff       	call   f0100f8b <cprintf>
f0119adc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119adf:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119ae2:	e8 15 3c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119ae7:	29 c3                	sub    %eax,%ebx
f0119ae9:	89 d8                	mov    %ebx,%eax
f0119aeb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119af0:	77 17                	ja     f0119b09 <test_kheap_phys_addr+0x1e9>
f0119af2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119af9:	83 ec 0c             	sub    $0xc,%esp
f0119afc:	68 b0 bd 12 f0       	push   $0xf012bdb0
f0119b01:	e8 85 74 fe ff       	call   f0100f8b <cprintf>
f0119b06:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f0119b09:	e8 ee 3b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119b0e:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b11:	e8 50 ad fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119b16:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0119b19:	83 ec 0c             	sub    $0xc,%esp
f0119b1c:	68 00 04 00 00       	push   $0x400
f0119b21:	e8 e6 f1 fe ff       	call   f0108d0c <kmalloc>
f0119b26:	83 c4 10             	add    $0x10,%esp
f0119b29:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119b2f:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f0119b35:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119b3a:	76 28                	jbe    f0119b64 <test_kheap_phys_addr+0x244>
f0119b3c:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f0119b42:	83 ec 0c             	sub    $0xc,%esp
f0119b45:	6a 00                	push   $0x0
f0119b47:	e8 b2 f0 fe ff       	call   f0108bfe <sbrk>
f0119b4c:	83 c4 10             	add    $0x10,%esp
f0119b4f:	39 c3                	cmp    %eax,%ebx
f0119b51:	73 11                	jae    f0119b64 <test_kheap_phys_addr+0x244>
f0119b53:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f0119b59:	89 c2                	mov    %eax,%edx
f0119b5b:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0119b60:	39 c2                	cmp    %eax,%edx
f0119b62:	72 17                	jb     f0119b7b <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119b64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b6b:	83 ec 0c             	sub    $0xc,%esp
f0119b6e:	68 6c d8 12 f0       	push   $0xf012d86c
f0119b73:	e8 13 74 fe ff       	call   f0100f8b <cprintf>
f0119b78:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b7b:	e8 e6 ac fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119b80:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119b83:	74 17                	je     f0119b9c <test_kheap_phys_addr+0x27c>
f0119b85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b8c:	83 ec 0c             	sub    $0xc,%esp
f0119b8f:	68 4c be 12 f0       	push   $0xf012be4c
f0119b94:	e8 f2 73 fe ff       	call   f0100f8b <cprintf>
f0119b99:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f0119b9c:	e8 5b 3b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119ba1:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ba4:	e8 bd ac fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ba9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119bac:	83 ec 0c             	sub    $0xc,%esp
f0119baf:	68 00 08 00 00       	push   $0x800
f0119bb4:	e8 53 f1 fe ff       	call   f0108d0c <kmalloc>
f0119bb9:	83 c4 10             	add    $0x10,%esp
f0119bbc:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119bc2:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f0119bc8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119bcd:	76 28                	jbe    f0119bf7 <test_kheap_phys_addr+0x2d7>
f0119bcf:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f0119bd5:	83 ec 0c             	sub    $0xc,%esp
f0119bd8:	6a 00                	push   $0x0
f0119bda:	e8 1f f0 fe ff       	call   f0108bfe <sbrk>
f0119bdf:	83 c4 10             	add    $0x10,%esp
f0119be2:	39 c3                	cmp    %eax,%ebx
f0119be4:	73 11                	jae    f0119bf7 <test_kheap_phys_addr+0x2d7>
f0119be6:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f0119bec:	89 c2                	mov    %eax,%edx
f0119bee:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0119bf3:	39 c2                	cmp    %eax,%edx
f0119bf5:	72 17                	jb     f0119c0e <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119bf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bfe:	83 ec 0c             	sub    $0xc,%esp
f0119c01:	68 f8 d8 12 f0       	push   $0xf012d8f8
f0119c06:	e8 80 73 fe ff       	call   f0100f8b <cprintf>
f0119c0b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c0e:	e8 53 ac fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119c13:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119c16:	74 17                	je     f0119c2f <test_kheap_phys_addr+0x30f>
f0119c18:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c1f:	83 ec 0c             	sub    $0xc,%esp
f0119c22:	68 58 bf 12 f0       	push   $0xf012bf58
f0119c27:	e8 5f 73 fe ff       	call   f0100f8b <cprintf>
f0119c2c:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f0119c2f:	e8 c8 3a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119c34:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c37:	e8 2a ac fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119c3c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f0119c3f:	83 ec 0c             	sub    $0xc,%esp
f0119c42:	68 00 06 00 00       	push   $0x600
f0119c47:	e8 c0 f0 fe ff       	call   f0108d0c <kmalloc>
f0119c4c:	83 c4 10             	add    $0x10,%esp
f0119c4f:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0119c55:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f0119c5b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119c60:	76 28                	jbe    f0119c8a <test_kheap_phys_addr+0x36a>
f0119c62:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f0119c68:	83 ec 0c             	sub    $0xc,%esp
f0119c6b:	6a 00                	push   $0x0
f0119c6d:	e8 8c ef fe ff       	call   f0108bfe <sbrk>
f0119c72:	83 c4 10             	add    $0x10,%esp
f0119c75:	39 c3                	cmp    %eax,%ebx
f0119c77:	73 11                	jae    f0119c8a <test_kheap_phys_addr+0x36a>
f0119c79:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f0119c7f:	89 c2                	mov    %eax,%edx
f0119c81:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0119c86:	39 c2                	cmp    %eax,%edx
f0119c88:	72 17                	jb     f0119ca1 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119c8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c91:	83 ec 0c             	sub    $0xc,%esp
f0119c94:	68 84 d9 12 f0       	push   $0xf012d984
f0119c99:	e8 ed 72 fe ff       	call   f0100f8b <cprintf>
f0119c9e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ca1:	e8 c0 ab fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ca6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119ca9:	74 17                	je     f0119cc2 <test_kheap_phys_addr+0x3a2>
f0119cab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cb2:	83 ec 0c             	sub    $0xc,%esp
f0119cb5:	68 64 c0 12 f0       	push   $0xf012c064
f0119cba:	e8 cc 72 fe ff       	call   f0100f8b <cprintf>
f0119cbf:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f0119cc2:	e8 35 3a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119cc7:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119cca:	e8 97 ab fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ccf:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0119cd2:	83 ec 0c             	sub    $0xc,%esp
f0119cd5:	68 00 1c 00 00       	push   $0x1c00
f0119cda:	e8 2d f0 fe ff       	call   f0108d0c <kmalloc>
f0119cdf:	83 c4 10             	add    $0x10,%esp
f0119ce2:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119ce8:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f0119cee:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119cf3:	74 17                	je     f0119d0c <test_kheap_phys_addr+0x3ec>
f0119cf5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cfc:	83 ec 0c             	sub    $0xc,%esp
f0119cff:	68 1c c1 12 f0       	push   $0xf012c11c
f0119d04:	e8 82 72 fe ff       	call   f0100f8b <cprintf>
f0119d09:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d0c:	e8 55 ab fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119d11:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119d14:	74 17                	je     f0119d2d <test_kheap_phys_addr+0x40d>
f0119d16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d1d:	83 ec 0c             	sub    $0xc,%esp
f0119d20:	68 70 c1 12 f0       	push   $0xf012c170
f0119d25:	e8 61 72 fe ff       	call   f0100f8b <cprintf>
f0119d2a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119d2d:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119d30:	e8 c7 39 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119d35:	29 c3                	sub    %eax,%ebx
f0119d37:	89 d8                	mov    %ebx,%eax
f0119d39:	83 f8 01             	cmp    $0x1,%eax
f0119d3c:	77 17                	ja     f0119d55 <test_kheap_phys_addr+0x435>
f0119d3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d45:	83 ec 0c             	sub    $0xc,%esp
f0119d48:	68 e0 c1 12 f0       	push   $0xf012c1e0
f0119d4d:	e8 39 72 fe ff       	call   f0100f8b <cprintf>
f0119d52:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f0119d55:	e8 a2 39 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119d5a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119d5d:	e8 04 ab fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119d62:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0119d65:	83 ec 0c             	sub    $0xc,%esp
f0119d68:	68 00 fc 2f 00       	push   $0x2ffc00
f0119d6d:	e8 9a ef fe ff       	call   f0108d0c <kmalloc>
f0119d72:	83 c4 10             	add    $0x10,%esp
f0119d75:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119d7b:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f0119d81:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119d86:	74 17                	je     f0119d9f <test_kheap_phys_addr+0x47f>
f0119d88:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d8f:	83 ec 0c             	sub    $0xc,%esp
f0119d92:	68 10 da 12 f0       	push   $0xf012da10
f0119d97:	e8 ef 71 fe ff       	call   f0100f8b <cprintf>
f0119d9c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d9f:	e8 c2 aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119da4:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119da7:	74 17                	je     f0119dc0 <test_kheap_phys_addr+0x4a0>
f0119da9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119db0:	83 ec 0c             	sub    $0xc,%esp
f0119db3:	68 b4 c2 12 f0       	push   $0xf012c2b4
f0119db8:	e8 ce 71 fe ff       	call   f0100f8b <cprintf>
f0119dbd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119dc0:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119dc3:	e8 34 39 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119dc8:	29 c3                	sub    %eax,%ebx
f0119dca:	89 d8                	mov    %ebx,%eax
f0119dcc:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119dd1:	77 17                	ja     f0119dea <test_kheap_phys_addr+0x4ca>
f0119dd3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dda:	83 ec 0c             	sub    $0xc,%esp
f0119ddd:	68 64 da 12 f0       	push   $0xf012da64
f0119de2:	e8 a4 71 fe ff       	call   f0100f8b <cprintf>
f0119de7:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f0119dea:	e8 0d 39 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119def:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119df2:	e8 6f aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119df7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f0119dfa:	83 ec 0c             	sub    $0xc,%esp
f0119dfd:	68 00 fc 5f 00       	push   $0x5ffc00
f0119e02:	e8 05 ef fe ff       	call   f0108d0c <kmalloc>
f0119e07:	83 c4 10             	add    $0x10,%esp
f0119e0a:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119e10:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f0119e16:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119e1b:	74 17                	je     f0119e34 <test_kheap_phys_addr+0x514>
f0119e1d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e24:	83 ec 0c             	sub    $0xc,%esp
f0119e27:	68 ac da 12 f0       	push   $0xf012daac
f0119e2c:	e8 5a 71 fe ff       	call   f0100f8b <cprintf>
f0119e31:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e34:	e8 2d aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119e39:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119e3c:	74 17                	je     f0119e55 <test_kheap_phys_addr+0x535>
f0119e3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e45:	83 ec 0c             	sub    $0xc,%esp
f0119e48:	68 b0 c3 12 f0       	push   $0xf012c3b0
f0119e4d:	e8 39 71 fe ff       	call   f0100f8b <cprintf>
f0119e52:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e55:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119e58:	e8 9f 38 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119e5d:	29 c3                	sub    %eax,%ebx
f0119e5f:	89 d8                	mov    %ebx,%eax
f0119e61:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119e66:	77 17                	ja     f0119e7f <test_kheap_phys_addr+0x55f>
f0119e68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e6f:	83 ec 0c             	sub    $0xc,%esp
f0119e72:	68 00 db 12 f0       	push   $0xf012db00
f0119e77:	e8 0f 71 fe ff       	call   f0100f8b <cprintf>
f0119e7c:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f0119e7f:	e8 78 38 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119e84:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e87:	e8 da a9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119e8c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f0119e8f:	83 ec 0c             	sub    $0xc,%esp
f0119e92:	68 00 38 00 00       	push   $0x3800
f0119e97:	e8 70 ee fe ff       	call   f0108d0c <kmalloc>
f0119e9c:	83 c4 10             	add    $0x10,%esp
f0119e9f:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119ea5:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f0119eab:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119eb0:	74 17                	je     f0119ec9 <test_kheap_phys_addr+0x5a9>
f0119eb2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eb9:	83 ec 0c             	sub    $0xc,%esp
f0119ebc:	68 48 db 12 f0       	push   $0xf012db48
f0119ec1:	e8 c5 70 fe ff       	call   f0100f8b <cprintf>
f0119ec6:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ec9:	e8 98 a9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ece:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119ed1:	74 17                	je     f0119eea <test_kheap_phys_addr+0x5ca>
f0119ed3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eda:	83 ec 0c             	sub    $0xc,%esp
f0119edd:	68 9c db 12 f0       	push   $0xf012db9c
f0119ee2:	e8 a4 70 fe ff       	call   f0100f8b <cprintf>
f0119ee7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119eea:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119eed:	e8 0a 38 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f0119ef2:	29 c3                	sub    %eax,%ebx
f0119ef4:	89 d8                	mov    %ebx,%eax
f0119ef6:	83 f8 03             	cmp    $0x3,%eax
f0119ef9:	77 17                	ja     f0119f12 <test_kheap_phys_addr+0x5f2>
f0119efb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f02:	83 ec 0c             	sub    $0xc,%esp
f0119f05:	68 0c dc 12 f0       	push   $0xf012dc0c
f0119f0a:	e8 7c 70 fe ff       	call   f0100f8b <cprintf>
f0119f0f:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f0119f12:	83 ec 0c             	sub    $0xc,%esp
f0119f15:	68 54 dc 12 f0       	push   $0xf012dc54
f0119f1a:	e8 6c 70 fe ff       	call   f0100f8b <cprintf>
f0119f1f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f0119f22:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f0119f29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f0119f30:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f0119f37:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0119f3c:	05 00 10 00 00       	add    $0x1000,%eax
f0119f41:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f0119f44:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119f47:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0119f4a:	eb 2e                	jmp    f0119f7a <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f0119f4c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0119f4f:	8d 43 01             	lea    0x1(%ebx),%eax
f0119f52:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0119f55:	83 ec 0c             	sub    $0xc,%esp
f0119f58:	ff 75 e8             	pushl  -0x18(%ebp)
f0119f5b:	e8 e3 ed fe ff       	call   f0108d43 <kheap_physical_address>
f0119f60:	83 c4 10             	add    $0x10,%esp
f0119f63:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f0119f6a:	8b 55 9c             	mov    -0x64(%ebp),%edx
f0119f6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0119f70:	01 d0                	add    %edx,%eax
f0119f72:	05 00 10 00 00       	add    $0x1000,%eax
f0119f77:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0119f7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0119f7d:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f0119f80:	72 ca                	jb     f0119f4c <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f0119f82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f85:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f0119f88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f0119f8f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119f92:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0119f95:	e9 ce 00 00 00       	jmp    f011a068 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f0119f9a:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f0119f9f:	83 ec 04             	sub    $0x4,%esp
f0119fa2:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f0119fa8:	52                   	push   %edx
f0119fa9:	ff 75 e8             	pushl  -0x18(%ebp)
f0119fac:	50                   	push   %eax
f0119fad:	e8 d2 e3 fe ff       	call   f0108384 <get_page_table>
f0119fb2:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f0119fb5:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f0119fbb:	85 c0                	test   %eax,%eax
f0119fbd:	75 1e                	jne    f0119fdd <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f0119fbf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fc6:	83 ec 04             	sub    $0x4,%esp
f0119fc9:	68 a0 dc 12 f0       	push   $0xf012dca0
f0119fce:	68 e7 05 00 00       	push   $0x5e7
f0119fd3:	68 33 ba 12 f0       	push   $0xf012ba33
f0119fd8:	e8 5c 63 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f0119fdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0119fe0:	c1 e8 0c             	shr    $0xc,%eax
f0119fe3:	25 ff 03 00 00       	and    $0x3ff,%eax
f0119fe8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0119feb:	eb 62                	jmp    f011a04f <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f0119fed:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f0119ff3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119ff6:	c1 e2 02             	shl    $0x2,%edx
f0119ff9:	01 d0                	add    %edx,%eax
f0119ffb:	8b 00                	mov    (%eax),%eax
f0119ffd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a002:	89 c2                	mov    %eax,%edx
f011a004:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a007:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a00c:	01 c2                	add    %eax,%edx
f011a00e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a011:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011a018:	39 c2                	cmp    %eax,%edx
f011a01a:	74 1d                	je     f011a039 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a01c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a020:	74 17                	je     f011a039 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011a022:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a029:	83 ec 0c             	sub    $0xc,%esp
f011a02c:	68 00 dd 12 f0       	push   $0xf012dd00
f011a031:	e8 55 6f fe ff       	call   f0100f8b <cprintf>
f011a036:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011a039:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011a03c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a03f:	01 d0                	add    %edx,%eax
f011a041:	05 00 10 00 00       	add    $0x1000,%eax
f011a046:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a049:	ff 45 e4             	incl   -0x1c(%ebp)
f011a04c:	ff 45 f4             	incl   -0xc(%ebp)
f011a04f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a052:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011a055:	7d 11                	jge    f011a068 <test_kheap_phys_addr+0x748>
f011a057:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011a05e:	7f 08                	jg     f011a068 <test_kheap_phys_addr+0x748>
f011a060:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a063:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a066:	72 85                	jb     f0119fed <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011a068:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a06b:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a06e:	0f 82 26 ff ff ff    	jb     f0119f9a <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011a074:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a078:	74 04                	je     f011a07e <test_kheap_phys_addr+0x75e>
f011a07a:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a07e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011a085:	83 ec 0c             	sub    $0xc,%esp
f011a088:	68 24 dd 12 f0       	push   $0xf012dd24
f011a08d:	e8 f9 6e fe ff       	call   f0100f8b <cprintf>
f011a092:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011a095:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011a09c:	e9 b0 00 00 00       	jmp    f011a151 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011a0a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a0a4:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011a0ab:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011a0ae:	83 ec 0c             	sub    $0xc,%esp
f011a0b1:	ff 75 90             	pushl  -0x70(%ebp)
f011a0b4:	e8 8a ec fe ff       	call   f0108d43 <kheap_physical_address>
f011a0b9:	83 c4 10             	add    $0x10,%esp
f011a0bc:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a0bf:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011a0c4:	83 ec 04             	sub    $0x4,%esp
f011a0c7:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011a0cd:	52                   	push   %edx
f011a0ce:	ff 75 90             	pushl  -0x70(%ebp)
f011a0d1:	50                   	push   %eax
f011a0d2:	e8 ad e2 fe ff       	call   f0108384 <get_page_table>
f011a0d7:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a0da:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011a0e0:	85 c0                	test   %eax,%eax
f011a0e2:	75 1e                	jne    f011a102 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a0e4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0eb:	83 ec 04             	sub    $0x4,%esp
f011a0ee:	68 74 dd 12 f0       	push   $0xf012dd74
f011a0f3:	68 04 06 00 00       	push   $0x604
f011a0f8:	68 33 ba 12 f0       	push   $0xf012ba33
f011a0fd:	e8 37 62 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011a102:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011a108:	8b 55 90             	mov    -0x70(%ebp),%edx
f011a10b:	c1 ea 0c             	shr    $0xc,%edx
f011a10e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011a114:	c1 e2 02             	shl    $0x2,%edx
f011a117:	01 d0                	add    %edx,%eax
f011a119:	8b 00                	mov    (%eax),%eax
f011a11b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a120:	89 c2                	mov    %eax,%edx
f011a122:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a125:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a12a:	01 d0                	add    %edx,%eax
f011a12c:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011a12f:	74 1d                	je     f011a14e <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011a131:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a135:	74 17                	je     f011a14e <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011a137:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a13e:	83 ec 0c             	sub    $0xc,%esp
f011a141:	68 d4 dd 12 f0       	push   $0xf012ddd4
f011a146:	e8 40 6e fe ff       	call   f0100f8b <cprintf>
f011a14b:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011a14e:	ff 45 e0             	incl   -0x20(%ebp)
f011a151:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011a155:	0f 8e 46 ff ff ff    	jle    f011a0a1 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011a15b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a15f:	74 04                	je     f011a165 <test_kheap_phys_addr+0x845>
f011a161:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a165:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011a16c:	83 ec 0c             	sub    $0xc,%esp
f011a16f:	68 f8 dd 12 f0       	push   $0xf012ddf8
f011a174:	e8 12 6e fe ff       	call   f0100f8b <cprintf>
f011a179:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a17c:	e8 7b 35 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a181:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a184:	e8 dd a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a189:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011a18c:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a192:	83 ec 0c             	sub    $0xc,%esp
f011a195:	50                   	push   %eax
f011a196:	e8 8b eb fe ff       	call   f0108d26 <kfree>
f011a19b:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a19e:	e8 c3 a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a1a3:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a1a6:	74 17                	je     f011a1bf <test_kheap_phys_addr+0x89f>
f011a1a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1af:	83 ec 0c             	sub    $0xc,%esp
f011a1b2:	68 e4 c8 12 f0       	push   $0xf012c8e4
f011a1b7:	e8 cf 6d fe ff       	call   f0100f8b <cprintf>
f011a1bc:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a1bf:	e8 38 35 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a1c4:	89 c2                	mov    %eax,%edx
f011a1c6:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a1c9:	29 c2                	sub    %eax,%edx
f011a1cb:	89 d0                	mov    %edx,%eax
f011a1cd:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a1d2:	77 17                	ja     f011a1eb <test_kheap_phys_addr+0x8cb>
f011a1d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1db:	83 ec 0c             	sub    $0xc,%esp
f011a1de:	68 20 de 12 f0       	push   $0xf012de20
f011a1e3:	e8 a3 6d fe ff       	call   f0100f8b <cprintf>
f011a1e8:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a1eb:	e8 0c 35 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a1f0:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1f3:	e8 6e a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a1f8:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011a1fb:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a201:	83 ec 0c             	sub    $0xc,%esp
f011a204:	50                   	push   %eax
f011a205:	e8 1c eb fe ff       	call   f0108d26 <kfree>
f011a20a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a20d:	e8 54 a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a212:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a215:	74 17                	je     f011a22e <test_kheap_phys_addr+0x90e>
f011a217:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a21e:	83 ec 0c             	sub    $0xc,%esp
f011a221:	68 24 ca 12 f0       	push   $0xf012ca24
f011a226:	e8 60 6d fe ff       	call   f0100f8b <cprintf>
f011a22b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a22e:	e8 c9 34 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a233:	89 c2                	mov    %eax,%edx
f011a235:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a238:	29 c2                	sub    %eax,%edx
f011a23a:	89 d0                	mov    %edx,%eax
f011a23c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a241:	77 17                	ja     f011a25a <test_kheap_phys_addr+0x93a>
f011a243:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a24a:	83 ec 0c             	sub    $0xc,%esp
f011a24d:	68 5c de 12 f0       	push   $0xf012de5c
f011a252:	e8 34 6d fe ff       	call   f0100f8b <cprintf>
f011a257:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a25a:	e8 9d 34 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a25f:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a262:	e8 ff a5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a267:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011a26a:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011a270:	83 ec 0c             	sub    $0xc,%esp
f011a273:	50                   	push   %eax
f011a274:	e8 ad ea fe ff       	call   f0108d26 <kfree>
f011a279:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a27c:	e8 e5 a5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a281:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a284:	74 17                	je     f011a29d <test_kheap_phys_addr+0x97d>
f011a286:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a28d:	83 ec 0c             	sub    $0xc,%esp
f011a290:	68 30 cb 12 f0       	push   $0xf012cb30
f011a295:	e8 f1 6c fe ff       	call   f0100f8b <cprintf>
f011a29a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a29d:	e8 5a 34 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a2a2:	89 c2                	mov    %eax,%edx
f011a2a4:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a2a7:	29 c2                	sub    %eax,%edx
f011a2a9:	89 d0                	mov    %edx,%eax
f011a2ab:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a2b0:	77 17                	ja     f011a2c9 <test_kheap_phys_addr+0x9a9>
f011a2b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2b9:	83 ec 0c             	sub    $0xc,%esp
f011a2bc:	68 98 de 12 f0       	push   $0xf012de98
f011a2c1:	e8 c5 6c fe ff       	call   f0100f8b <cprintf>
f011a2c6:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011a2c9:	83 ec 0c             	sub    $0xc,%esp
f011a2cc:	68 d4 de 12 f0       	push   $0xf012ded4
f011a2d1:	e8 b5 6c fe ff       	call   f0100f8b <cprintf>
f011a2d6:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011a2d9:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011a2e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011a2e7:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011a2ee:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011a2f1:	8b 15 d8 bd 17 f0    	mov    0xf017bdd8,%edx
f011a2f7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011a2fd:	01 d0                	add    %edx,%eax
f011a2ff:	05 00 10 00 00       	add    $0x1000,%eax
f011a304:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011a30a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a310:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011a313:	eb 25                	jmp    f011a33a <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011a315:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011a318:	8d 43 01             	lea    0x1(%ebx),%eax
f011a31b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011a31e:	83 ec 0c             	sub    $0xc,%esp
f011a321:	ff 75 d8             	pushl  -0x28(%ebp)
f011a324:	e8 1a ea fe ff       	call   f0108d43 <kheap_physical_address>
f011a329:	83 c4 10             	add    $0x10,%esp
f011a32c:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011a333:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011a33a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a33d:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a340:	72 d3                	jb     f011a315 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011a342:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a345:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011a34b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011a352:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a358:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011a35b:	e9 f4 00 00 00       	jmp    f011a454 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a360:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011a365:	83 ec 04             	sub    $0x4,%esp
f011a368:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011a36e:	52                   	push   %edx
f011a36f:	ff 75 d8             	pushl  -0x28(%ebp)
f011a372:	50                   	push   %eax
f011a373:	e8 0c e0 fe ff       	call   f0108384 <get_page_table>
f011a378:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a37b:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a381:	85 c0                	test   %eax,%eax
f011a383:	75 24                	jne    f011a3a9 <test_kheap_phys_addr+0xa89>
				if (correct)
f011a385:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a389:	74 1e                	je     f011a3a9 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a38b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a392:	83 ec 04             	sub    $0x4,%esp
f011a395:	68 24 df 12 f0       	push   $0xf012df24
f011a39a:	68 42 06 00 00       	push   $0x642
f011a39f:	68 33 ba 12 f0       	push   $0xf012ba33
f011a3a4:	e8 90 5f fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a3a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a3ac:	c1 e8 0c             	shr    $0xc,%eax
f011a3af:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a3b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011a3b7:	eb 7b                	jmp    f011a434 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011a3b9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011a3c0:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a3c6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011a3c9:	c1 e2 02             	shl    $0x2,%edx
f011a3cc:	01 d0                	add    %edx,%eax
f011a3ce:	8b 00                	mov    (%eax),%eax
f011a3d0:	83 e0 01             	and    $0x1,%eax
f011a3d3:	85 c0                	test   %eax,%eax
f011a3d5:	74 24                	je     f011a3fb <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011a3d7:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a3dd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011a3e0:	c1 e2 02             	shl    $0x2,%edx
f011a3e3:	01 d0                	add    %edx,%eax
f011a3e5:	8b 00                	mov    (%eax),%eax
f011a3e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a3ec:	89 c2                	mov    %eax,%edx
f011a3ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a3f1:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a3f6:	01 d0                	add    %edx,%eax
f011a3f8:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011a3fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a3fe:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011a405:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011a408:	74 1d                	je     f011a427 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a40a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a40e:	74 17                	je     f011a427 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011a410:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a417:	83 ec 0c             	sub    $0xc,%esp
f011a41a:	68 84 df 12 f0       	push   $0xf012df84
f011a41f:	e8 67 6b fe ff       	call   f0100f8b <cprintf>
f011a424:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011a427:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a42e:	ff 45 d4             	incl   -0x2c(%ebp)
f011a431:	ff 45 f4             	incl   -0xc(%ebp)
f011a434:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a437:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011a43d:	7d 15                	jge    f011a454 <test_kheap_phys_addr+0xb34>
f011a43f:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011a446:	7f 0c                	jg     f011a454 <test_kheap_phys_addr+0xb34>
f011a448:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a44b:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a44e:	0f 82 65 ff ff ff    	jb     f011a3b9 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011a454:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a457:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a45a:	0f 82 00 ff ff ff    	jb     f011a360 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011a460:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a464:	74 04                	je     f011a46a <test_kheap_phys_addr+0xb4a>
f011a466:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011a46a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011a471:	83 ec 0c             	sub    $0xc,%esp
f011a474:	68 a8 df 12 f0       	push   $0xf012dfa8
f011a479:	e8 0d 6b fe ff       	call   f0100f8b <cprintf>
f011a47e:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011a481:	83 ec 0c             	sub    $0xc,%esp
f011a484:	6a 00                	push   $0x0
f011a486:	e8 73 e7 fe ff       	call   f0108bfe <sbrk>
f011a48b:	83 c4 10             	add    $0x10,%esp
f011a48e:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011a493:	77 17                	ja     f011a4ac <test_kheap_phys_addr+0xb8c>
f011a495:	83 ec 04             	sub    $0x4,%esp
f011a498:	68 00 e0 12 f0       	push   $0xf012e000
f011a49d:	68 5d 06 00 00       	push   $0x65d
f011a4a2:	68 33 ba 12 f0       	push   $0xf012ba33
f011a4a7:	e8 8d 5e fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011a4ac:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011a4b3:	e9 af 00 00 00       	jmp    f011a567 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011a4b8:	83 ec 0c             	sub    $0xc,%esp
f011a4bb:	ff 75 d0             	pushl  -0x30(%ebp)
f011a4be:	e8 80 e8 fe ff       	call   f0108d43 <kheap_physical_address>
f011a4c3:	83 c4 10             	add    $0x10,%esp
f011a4c6:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a4cc:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011a4d1:	83 ec 04             	sub    $0x4,%esp
f011a4d4:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011a4da:	52                   	push   %edx
f011a4db:	ff 75 d0             	pushl  -0x30(%ebp)
f011a4de:	50                   	push   %eax
f011a4df:	e8 a0 de fe ff       	call   f0108384 <get_page_table>
f011a4e4:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a4e7:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011a4ed:	85 c0                	test   %eax,%eax
f011a4ef:	75 24                	jne    f011a515 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011a4f1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a4f5:	74 1e                	je     f011a515 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a4f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4fe:	83 ec 04             	sub    $0x4,%esp
f011a501:	68 1c e0 12 f0       	push   $0xf012e01c
f011a506:	68 65 06 00 00       	push   $0x665
f011a50b:	68 33 ba 12 f0       	push   $0xf012ba33
f011a510:	e8 24 5e fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011a515:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011a51b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011a51e:	c1 ea 0c             	shr    $0xc,%edx
f011a521:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011a527:	c1 e2 02             	shl    $0x2,%edx
f011a52a:	01 d0                	add    %edx,%eax
f011a52c:	8b 00                	mov    (%eax),%eax
f011a52e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a533:	89 c2                	mov    %eax,%edx
f011a535:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a538:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a53d:	01 d0                	add    %edx,%eax
f011a53f:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011a545:	74 1d                	je     f011a564 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011a547:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a54b:	74 17                	je     f011a564 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011a54d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a554:	83 ec 0c             	sub    $0xc,%esp
f011a557:	68 7c e0 12 f0       	push   $0xf012e07c
f011a55c:	e8 2a 6a fe ff       	call   f0100f8b <cprintf>
f011a561:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011a564:	ff 45 d0             	incl   -0x30(%ebp)
f011a567:	83 ec 0c             	sub    $0xc,%esp
f011a56a:	6a 00                	push   $0x0
f011a56c:	e8 8d e6 fe ff       	call   f0108bfe <sbrk>
f011a571:	83 c4 10             	add    $0x10,%esp
f011a574:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a577:	0f 87 3b ff ff ff    	ja     f011a4b8 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011a57d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a581:	74 04                	je     f011a587 <test_kheap_phys_addr+0xc67>
f011a583:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a587:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011a58e:	83 ec 0c             	sub    $0xc,%esp
f011a591:	68 a0 e0 12 f0       	push   $0xf012e0a0
f011a596:	e8 f0 69 fe ff       	call   f0100f8b <cprintf>
f011a59b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011a59e:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011a5a5:	10 00 f9 
		i = 0;
f011a5a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011a5af:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a5b5:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011a5b8:	eb 0a                	jmp    f011a5c4 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011a5ba:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011a5bd:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011a5c4:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011a5cb:	76 ed                	jbe    f011a5ba <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011a5cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a5d0:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011a5d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011a5dd:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a5e3:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011a5e6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011a5ed:	e9 cb 00 00 00       	jmp    f011a6bd <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011a5f2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011a5f5:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011a5fa:	83 ec 04             	sub    $0x4,%esp
f011a5fd:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011a603:	51                   	push   %ecx
f011a604:	52                   	push   %edx
f011a605:	50                   	push   %eax
f011a606:	e8 79 dd fe ff       	call   f0108384 <get_page_table>
f011a60b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a60e:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011a614:	85 c0                	test   %eax,%eax
f011a616:	75 24                	jne    f011a63c <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011a618:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a61c:	74 1e                	je     f011a63c <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a61e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a625:	83 ec 04             	sub    $0x4,%esp
f011a628:	68 dc e0 12 f0       	push   $0xf012e0dc
f011a62d:	68 87 06 00 00       	push   $0x687
f011a632:	68 33 ba 12 f0       	push   $0xf012ba33
f011a637:	e8 fd 5c fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011a63c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011a643:	eb 59                	jmp    f011a69e <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011a645:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a648:	c1 e0 0c             	shl    $0xc,%eax
f011a64b:	89 c2                	mov    %eax,%edx
f011a64d:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a653:	01 d0                	add    %edx,%eax
f011a655:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011a65b:	83 ec 0c             	sub    $0xc,%esp
f011a65e:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011a664:	e8 da e6 fe ff       	call   f0108d43 <kheap_physical_address>
f011a669:	83 c4 10             	add    $0x10,%esp
f011a66c:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011a672:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011a679:	74 1d                	je     f011a698 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a67b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a67f:	74 17                	je     f011a698 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011a681:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a688:	83 ec 0c             	sub    $0xc,%esp
f011a68b:	68 3c e1 12 f0       	push   $0xf012e13c
f011a690:	e8 f6 68 fe ff       	call   f0100f8b <cprintf>
f011a695:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011a698:	ff 45 c8             	incl   -0x38(%ebp)
f011a69b:	ff 45 f4             	incl   -0xc(%ebp)
f011a69e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a6a1:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011a6a7:	7d 09                	jge    f011a6b2 <test_kheap_phys_addr+0xd92>
f011a6a9:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011a6b0:	7e 93                	jle    f011a645 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011a6b2:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011a6b9:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011a6bd:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011a6c1:	0f 88 2b ff ff ff    	js     f011a5f2 <test_kheap_phys_addr+0xcd2>
f011a6c7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011a6cb:	7f 0d                	jg     f011a6da <test_kheap_phys_addr+0xdba>
f011a6cd:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011a6d4:	0f 86 18 ff ff ff    	jbe    f011a5f2 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011a6da:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6de:	74 04                	je     f011a6e4 <test_kheap_phys_addr+0xdc4>
f011a6e0:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011a6e4:	83 ec 08             	sub    $0x8,%esp
f011a6e7:	ff 75 f0             	pushl  -0x10(%ebp)
f011a6ea:	68 60 e1 12 f0       	push   $0xf012e160
f011a6ef:	e8 97 68 fe ff       	call   f0100f8b <cprintf>
f011a6f4:	83 c4 10             	add    $0x10,%esp

	return 1;
f011a6f7:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011a6fc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a6ff:	5b                   	pop    %ebx
f011a700:	5f                   	pop    %edi
f011a701:	5d                   	pop    %ebp
f011a702:	c3                   	ret    

f011a703 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011a703:	55                   	push   %ebp
f011a704:	89 e5                	mov    %esp,%ebp
f011a706:	57                   	push   %edi
f011a707:	56                   	push   %esi
f011a708:	53                   	push   %ebx
f011a709:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011a70f:	89 e0                	mov    %esp,%eax
f011a711:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a713:	83 ec 0c             	sub    $0xc,%esp
f011a716:	68 e8 9a 12 f0       	push   $0xf0129ae8
f011a71b:	e8 6b 68 fe ff       	call   f0100f8b <cprintf>
f011a720:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a723:	83 ec 0c             	sub    $0xc,%esp
f011a726:	68 18 9b 12 f0       	push   $0xf0129b18
f011a72b:	e8 5b 68 fe ff       	call   f0100f8b <cprintf>
f011a730:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a733:	83 ec 0c             	sub    $0xc,%esp
f011a736:	68 e8 9a 12 f0       	push   $0xf0129ae8
f011a73b:	e8 4b 68 fe ff       	call   f0100f8b <cprintf>
f011a740:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a743:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011a747:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011a74b:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011a751:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011a757:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a75e:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a765:	e8 92 2f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a76a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011a76d:	83 ec 0c             	sub    $0xc,%esp
f011a770:	68 3c d8 12 f0       	push   $0xf012d83c
f011a775:	e8 11 68 fe ff       	call   f0100f8b <cprintf>
f011a77a:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a77d:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011a783:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a788:	b8 00 00 00 00       	mov    $0x0,%eax
f011a78d:	89 d7                	mov    %edx,%edi
f011a78f:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a791:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011a797:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a79c:	b8 00 00 00 00       	mov    $0x0,%eax
f011a7a1:	89 d7                	mov    %edx,%edi
f011a7a3:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011a7a5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011a7ac:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011a7b3:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011a7b9:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a7be:	b8 00 00 00 00       	mov    $0x0,%eax
f011a7c3:	89 d7                	mov    %edx,%edi
f011a7c5:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a7c7:	e8 30 2f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a7cc:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a7cf:	e8 92 a0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a7d4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a7d7:	83 ec 0c             	sub    $0xc,%esp
f011a7da:	68 00 fc 1f 00       	push   $0x1ffc00
f011a7df:	e8 28 e5 fe ff       	call   f0108d0c <kmalloc>
f011a7e4:	83 c4 10             	add    $0x10,%esp
f011a7e7:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a7ed:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011a7f3:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a7f8:	74 17                	je     f011a811 <test_kheap_virt_addr+0x10e>
f011a7fa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a801:	83 ec 0c             	sub    $0xc,%esp
f011a804:	68 e0 bb 12 f0       	push   $0xf012bbe0
f011a809:	e8 7d 67 fe ff       	call   f0100f8b <cprintf>
f011a80e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a811:	e8 50 a0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a816:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011a819:	74 17                	je     f011a832 <test_kheap_virt_addr+0x12f>
f011a81b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a822:	83 ec 0c             	sub    $0xc,%esp
f011a825:	68 34 bc 12 f0       	push   $0xf012bc34
f011a82a:	e8 5c 67 fe ff       	call   f0100f8b <cprintf>
f011a82f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a832:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011a835:	e8 c2 2e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a83a:	29 c3                	sub    %eax,%ebx
f011a83c:	89 d8                	mov    %ebx,%eax
f011a83e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a843:	77 17                	ja     f011a85c <test_kheap_virt_addr+0x159>
f011a845:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a84c:	83 ec 0c             	sub    $0xc,%esp
f011a84f:	68 a4 bc 12 f0       	push   $0xf012bca4
f011a854:	e8 32 67 fe ff       	call   f0100f8b <cprintf>
f011a859:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a85c:	e8 9b 2e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a861:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a864:	e8 fd 9f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a869:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a86c:	83 ec 0c             	sub    $0xc,%esp
f011a86f:	68 00 fc 1f 00       	push   $0x1ffc00
f011a874:	e8 93 e4 fe ff       	call   f0108d0c <kmalloc>
f011a879:	83 c4 10             	add    $0x10,%esp
f011a87c:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a882:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a888:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a88d:	74 17                	je     f011a8a6 <test_kheap_virt_addr+0x1a3>
f011a88f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a896:	83 ec 0c             	sub    $0xc,%esp
f011a899:	68 ec bc 12 f0       	push   $0xf012bcec
f011a89e:	e8 e8 66 fe ff       	call   f0100f8b <cprintf>
f011a8a3:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8a6:	e8 bb 9f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a8ab:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011a8ae:	74 17                	je     f011a8c7 <test_kheap_virt_addr+0x1c4>
f011a8b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a8b7:	83 ec 0c             	sub    $0xc,%esp
f011a8ba:	68 40 bd 12 f0       	push   $0xf012bd40
f011a8bf:	e8 c7 66 fe ff       	call   f0100f8b <cprintf>
f011a8c4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a8c7:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011a8ca:	e8 2d 2e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a8cf:	29 c3                	sub    %eax,%ebx
f011a8d1:	89 d8                	mov    %ebx,%eax
f011a8d3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a8d8:	77 17                	ja     f011a8f1 <test_kheap_virt_addr+0x1ee>
f011a8da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a8e1:	83 ec 0c             	sub    $0xc,%esp
f011a8e4:	68 b0 bd 12 f0       	push   $0xf012bdb0
f011a8e9:	e8 9d 66 fe ff       	call   f0100f8b <cprintf>
f011a8ee:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a8f1:	e8 06 2e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a8f6:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8f9:	e8 68 9f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a8fe:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011a901:	83 ec 0c             	sub    $0xc,%esp
f011a904:	68 00 04 00 00       	push   $0x400
f011a909:	e8 fe e3 fe ff       	call   f0108d0c <kmalloc>
f011a90e:	83 c4 10             	add    $0x10,%esp
f011a911:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a917:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a91d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a922:	76 28                	jbe    f011a94c <test_kheap_virt_addr+0x249>
f011a924:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011a92a:	83 ec 0c             	sub    $0xc,%esp
f011a92d:	6a 00                	push   $0x0
f011a92f:	e8 ca e2 fe ff       	call   f0108bfe <sbrk>
f011a934:	83 c4 10             	add    $0x10,%esp
f011a937:	39 c3                	cmp    %eax,%ebx
f011a939:	73 11                	jae    f011a94c <test_kheap_virt_addr+0x249>
f011a93b:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a941:	89 c2                	mov    %eax,%edx
f011a943:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011a948:	39 c2                	cmp    %eax,%edx
f011a94a:	72 17                	jb     f011a963 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a94c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a953:	83 ec 0c             	sub    $0xc,%esp
f011a956:	68 6c d8 12 f0       	push   $0xf012d86c
f011a95b:	e8 2b 66 fe ff       	call   f0100f8b <cprintf>
f011a960:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a963:	e8 fe 9e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a968:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011a96b:	74 17                	je     f011a984 <test_kheap_virt_addr+0x281>
f011a96d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a974:	83 ec 0c             	sub    $0xc,%esp
f011a977:	68 4c be 12 f0       	push   $0xf012be4c
f011a97c:	e8 0a 66 fe ff       	call   f0100f8b <cprintf>
f011a981:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a984:	e8 73 2d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011a989:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a98c:	e8 d5 9e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a991:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a994:	83 ec 0c             	sub    $0xc,%esp
f011a997:	68 00 08 00 00       	push   $0x800
f011a99c:	e8 6b e3 fe ff       	call   f0108d0c <kmalloc>
f011a9a1:	83 c4 10             	add    $0x10,%esp
f011a9a4:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a9aa:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a9b0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a9b5:	76 28                	jbe    f011a9df <test_kheap_virt_addr+0x2dc>
f011a9b7:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011a9bd:	83 ec 0c             	sub    $0xc,%esp
f011a9c0:	6a 00                	push   $0x0
f011a9c2:	e8 37 e2 fe ff       	call   f0108bfe <sbrk>
f011a9c7:	83 c4 10             	add    $0x10,%esp
f011a9ca:	39 c3                	cmp    %eax,%ebx
f011a9cc:	73 11                	jae    f011a9df <test_kheap_virt_addr+0x2dc>
f011a9ce:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a9d4:	89 c2                	mov    %eax,%edx
f011a9d6:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011a9db:	39 c2                	cmp    %eax,%edx
f011a9dd:	72 17                	jb     f011a9f6 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a9df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011a9e6:	83 ec 0c             	sub    $0xc,%esp
f011a9e9:	68 f8 d8 12 f0       	push   $0xf012d8f8
f011a9ee:	e8 98 65 fe ff       	call   f0100f8b <cprintf>
f011a9f3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9f6:	e8 6b 9e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a9fb:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011a9fe:	74 17                	je     f011aa17 <test_kheap_virt_addr+0x314>
f011aa00:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aa07:	83 ec 0c             	sub    $0xc,%esp
f011aa0a:	68 58 bf 12 f0       	push   $0xf012bf58
f011aa0f:	e8 77 65 fe ff       	call   f0100f8b <cprintf>
f011aa14:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011aa17:	e8 e0 2c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011aa1c:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa1f:	e8 42 9e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aa24:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011aa27:	83 ec 0c             	sub    $0xc,%esp
f011aa2a:	68 00 06 00 00       	push   $0x600
f011aa2f:	e8 d8 e2 fe ff       	call   f0108d0c <kmalloc>
f011aa34:	83 c4 10             	add    $0x10,%esp
f011aa37:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011aa3d:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011aa43:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011aa48:	76 28                	jbe    f011aa72 <test_kheap_virt_addr+0x36f>
f011aa4a:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011aa50:	83 ec 0c             	sub    $0xc,%esp
f011aa53:	6a 00                	push   $0x0
f011aa55:	e8 a4 e1 fe ff       	call   f0108bfe <sbrk>
f011aa5a:	83 c4 10             	add    $0x10,%esp
f011aa5d:	39 c3                	cmp    %eax,%ebx
f011aa5f:	73 11                	jae    f011aa72 <test_kheap_virt_addr+0x36f>
f011aa61:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011aa67:	89 c2                	mov    %eax,%edx
f011aa69:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011aa6e:	39 c2                	cmp    %eax,%edx
f011aa70:	72 17                	jb     f011aa89 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011aa72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aa79:	83 ec 0c             	sub    $0xc,%esp
f011aa7c:	68 84 d9 12 f0       	push   $0xf012d984
f011aa81:	e8 05 65 fe ff       	call   f0100f8b <cprintf>
f011aa86:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa89:	e8 d8 9d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aa8e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011aa91:	74 17                	je     f011aaaa <test_kheap_virt_addr+0x3a7>
f011aa93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aa9a:	83 ec 0c             	sub    $0xc,%esp
f011aa9d:	68 64 c0 12 f0       	push   $0xf012c064
f011aaa2:	e8 e4 64 fe ff       	call   f0100f8b <cprintf>
f011aaa7:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011aaaa:	e8 4d 2c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011aaaf:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aab2:	e8 af 9d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aab7:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011aaba:	83 ec 0c             	sub    $0xc,%esp
f011aabd:	68 00 1c 00 00       	push   $0x1c00
f011aac2:	e8 45 e2 fe ff       	call   f0108d0c <kmalloc>
f011aac7:	83 c4 10             	add    $0x10,%esp
f011aaca:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aad0:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011aad6:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011aadb:	74 17                	je     f011aaf4 <test_kheap_virt_addr+0x3f1>
f011aadd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aae4:	83 ec 0c             	sub    $0xc,%esp
f011aae7:	68 1c c1 12 f0       	push   $0xf012c11c
f011aaec:	e8 9a 64 fe ff       	call   f0100f8b <cprintf>
f011aaf1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aaf4:	e8 6d 9d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aaf9:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011aafc:	74 17                	je     f011ab15 <test_kheap_virt_addr+0x412>
f011aafe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab05:	83 ec 0c             	sub    $0xc,%esp
f011ab08:	68 70 c1 12 f0       	push   $0xf012c170
f011ab0d:	e8 79 64 fe ff       	call   f0100f8b <cprintf>
f011ab12:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ab15:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ab18:	e8 df 2b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011ab1d:	29 c3                	sub    %eax,%ebx
f011ab1f:	89 d8                	mov    %ebx,%eax
f011ab21:	83 f8 01             	cmp    $0x1,%eax
f011ab24:	77 17                	ja     f011ab3d <test_kheap_virt_addr+0x43a>
f011ab26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab2d:	83 ec 0c             	sub    $0xc,%esp
f011ab30:	68 e0 c1 12 f0       	push   $0xf012c1e0
f011ab35:	e8 51 64 fe ff       	call   f0100f8b <cprintf>
f011ab3a:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab3d:	e8 ba 2b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011ab42:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ab45:	e8 1c 9d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ab4a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ab4d:	83 ec 0c             	sub    $0xc,%esp
f011ab50:	68 00 fc 2f 00       	push   $0x2ffc00
f011ab55:	e8 b2 e1 fe ff       	call   f0108d0c <kmalloc>
f011ab5a:	83 c4 10             	add    $0x10,%esp
f011ab5d:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ab63:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011ab69:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011ab6e:	74 17                	je     f011ab87 <test_kheap_virt_addr+0x484>
f011ab70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab77:	83 ec 0c             	sub    $0xc,%esp
f011ab7a:	68 10 da 12 f0       	push   $0xf012da10
f011ab7f:	e8 07 64 fe ff       	call   f0100f8b <cprintf>
f011ab84:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab87:	e8 da 9c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ab8c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ab8f:	74 17                	je     f011aba8 <test_kheap_virt_addr+0x4a5>
f011ab91:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab98:	83 ec 0c             	sub    $0xc,%esp
f011ab9b:	68 b4 c2 12 f0       	push   $0xf012c2b4
f011aba0:	e8 e6 63 fe ff       	call   f0100f8b <cprintf>
f011aba5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aba8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011abab:	e8 4c 2b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011abb0:	29 c3                	sub    %eax,%ebx
f011abb2:	89 d8                	mov    %ebx,%eax
f011abb4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011abb9:	77 17                	ja     f011abd2 <test_kheap_virt_addr+0x4cf>
f011abbb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011abc2:	83 ec 0c             	sub    $0xc,%esp
f011abc5:	68 64 da 12 f0       	push   $0xf012da64
f011abca:	e8 bc 63 fe ff       	call   f0100f8b <cprintf>
f011abcf:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011abd2:	e8 25 2b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011abd7:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011abda:	e8 87 9c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011abdf:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011abe2:	83 ec 0c             	sub    $0xc,%esp
f011abe5:	68 00 fc 5f 00       	push   $0x5ffc00
f011abea:	e8 1d e1 fe ff       	call   f0108d0c <kmalloc>
f011abef:	83 c4 10             	add    $0x10,%esp
f011abf2:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011abf8:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011abfe:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011ac03:	74 17                	je     f011ac1c <test_kheap_virt_addr+0x519>
f011ac05:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac0c:	83 ec 0c             	sub    $0xc,%esp
f011ac0f:	68 ac da 12 f0       	push   $0xf012daac
f011ac14:	e8 72 63 fe ff       	call   f0100f8b <cprintf>
f011ac19:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac1c:	e8 45 9c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ac21:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ac24:	74 17                	je     f011ac3d <test_kheap_virt_addr+0x53a>
f011ac26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac2d:	83 ec 0c             	sub    $0xc,%esp
f011ac30:	68 b0 c3 12 f0       	push   $0xf012c3b0
f011ac35:	e8 51 63 fe ff       	call   f0100f8b <cprintf>
f011ac3a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ac3d:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ac40:	e8 b7 2a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011ac45:	29 c3                	sub    %eax,%ebx
f011ac47:	89 d8                	mov    %ebx,%eax
f011ac49:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ac4e:	77 17                	ja     f011ac67 <test_kheap_virt_addr+0x564>
f011ac50:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac57:	83 ec 0c             	sub    $0xc,%esp
f011ac5a:	68 00 db 12 f0       	push   $0xf012db00
f011ac5f:	e8 27 63 fe ff       	call   f0100f8b <cprintf>
f011ac64:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011ac67:	e8 90 2a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011ac6c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ac6f:	e8 f2 9b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ac74:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011ac77:	83 ec 0c             	sub    $0xc,%esp
f011ac7a:	68 00 38 00 00       	push   $0x3800
f011ac7f:	e8 88 e0 fe ff       	call   f0108d0c <kmalloc>
f011ac84:	83 c4 10             	add    $0x10,%esp
f011ac87:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac8d:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011ac93:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011ac98:	74 17                	je     f011acb1 <test_kheap_virt_addr+0x5ae>
f011ac9a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aca1:	83 ec 0c             	sub    $0xc,%esp
f011aca4:	68 48 db 12 f0       	push   $0xf012db48
f011aca9:	e8 dd 62 fe ff       	call   f0100f8b <cprintf>
f011acae:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011acb1:	e8 b0 9b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011acb6:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011acb9:	74 17                	je     f011acd2 <test_kheap_virt_addr+0x5cf>
f011acbb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011acc2:	83 ec 0c             	sub    $0xc,%esp
f011acc5:	68 9c db 12 f0       	push   $0xf012db9c
f011acca:	e8 bc 62 fe ff       	call   f0100f8b <cprintf>
f011accf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011acd2:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011acd5:	e8 22 2a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011acda:	29 c3                	sub    %eax,%ebx
f011acdc:	89 d8                	mov    %ebx,%eax
f011acde:	83 f8 03             	cmp    $0x3,%eax
f011ace1:	77 17                	ja     f011acfa <test_kheap_virt_addr+0x5f7>
f011ace3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011acea:	83 ec 0c             	sub    $0xc,%esp
f011aced:	68 0c dc 12 f0       	push   $0xf012dc0c
f011acf2:	e8 94 62 fe ff       	call   f0100f8b <cprintf>
f011acf7:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011acfa:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011ad01:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ad04:	c1 e8 0c             	shr    $0xc,%eax
f011ad07:	89 c2                	mov    %eax,%edx
f011ad09:	4a                   	dec    %edx
f011ad0a:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011ad0d:	c1 e0 02             	shl    $0x2,%eax
f011ad10:	8d 50 03             	lea    0x3(%eax),%edx
f011ad13:	b8 10 00 00 00       	mov    $0x10,%eax
f011ad18:	48                   	dec    %eax
f011ad19:	01 d0                	add    %edx,%eax
f011ad1b:	bf 10 00 00 00       	mov    $0x10,%edi
f011ad20:	ba 00 00 00 00       	mov    $0x0,%edx
f011ad25:	f7 f7                	div    %edi
f011ad27:	6b c0 10             	imul   $0x10,%eax,%eax
f011ad2a:	29 c4                	sub    %eax,%esp
f011ad2c:	89 e0                	mov    %esp,%eax
f011ad2e:	83 c0 03             	add    $0x3,%eax
f011ad31:	c1 e8 02             	shr    $0x2,%eax
f011ad34:	c1 e0 02             	shl    $0x2,%eax
f011ad37:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011ad3a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ad3d:	c1 e8 0c             	shr    $0xc,%eax
f011ad40:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011ad43:	83 ec 0c             	sub    $0xc,%esp
f011ad46:	68 94 e1 12 f0       	push   $0xf012e194
f011ad4b:	e8 3b 62 fe ff       	call   f0100f8b <cprintf>
f011ad50:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ad53:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ad5a:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011ad5f:	05 00 10 00 00       	add    $0x1000,%eax
f011ad64:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011ad67:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011ad6e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ad71:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ad74:	e9 2d 01 00 00       	jmp    f011aea6 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ad79:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011ad7e:	83 ec 04             	sub    $0x4,%esp
f011ad81:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011ad87:	52                   	push   %edx
f011ad88:	ff 75 dc             	pushl  -0x24(%ebp)
f011ad8b:	50                   	push   %eax
f011ad8c:	e8 f3 d5 fe ff       	call   f0108384 <get_page_table>
f011ad91:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ad94:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ad9a:	85 c0                	test   %eax,%eax
f011ad9c:	75 1e                	jne    f011adbc <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ad9e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ada5:	83 ec 04             	sub    $0x4,%esp
f011ada8:	68 a0 dc 12 f0       	push   $0xf012dca0
f011adad:	68 26 07 00 00       	push   $0x726
f011adb2:	68 33 ba 12 f0       	push   $0xf012ba33
f011adb7:	e8 7d 55 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011adbc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011adbf:	c1 e8 0c             	shr    $0xc,%eax
f011adc2:	25 ff 03 00 00       	and    $0x3ff,%eax
f011adc7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011adca:	e9 ba 00 00 00       	jmp    f011ae89 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011adcf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011add2:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011add5:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011addb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011adde:	c1 e2 02             	shl    $0x2,%edx
f011ade1:	01 d0                	add    %edx,%eax
f011ade3:	8b 00                	mov    (%eax),%eax
f011ade5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011adea:	89 c2                	mov    %eax,%edx
f011adec:	8b 45 90             	mov    -0x70(%ebp),%eax
f011adef:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011adf2:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011adf5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011adf8:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011adfb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011adfe:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ae01:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ae04:	83 ec 0c             	sub    $0xc,%esp
f011ae07:	50                   	push   %eax
f011ae08:	e8 53 df fe ff       	call   f0108d60 <kheap_virtual_address>
f011ae0d:	83 c4 10             	add    $0x10,%esp
f011ae10:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011ae13:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ae16:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ae19:	01 d0                	add    %edx,%eax
f011ae1b:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ae1e:	74 5c                	je     f011ae7c <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011ae20:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ae24:	74 56                	je     f011ae7c <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011ae26:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ae29:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ae2c:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ae2f:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011ae35:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011ae38:	c1 e1 02             	shl    $0x2,%ecx
f011ae3b:	01 ca                	add    %ecx,%edx
f011ae3d:	8b 12                	mov    (%edx),%edx
f011ae3f:	89 d1                	mov    %edx,%ecx
f011ae41:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011ae47:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011ae4a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ae4d:	01 da                	add    %ebx,%edx
f011ae4f:	83 ec 0c             	sub    $0xc,%esp
f011ae52:	50                   	push   %eax
f011ae53:	51                   	push   %ecx
f011ae54:	52                   	push   %edx
f011ae55:	ff 75 8c             	pushl  -0x74(%ebp)
f011ae58:	68 e0 e1 12 f0       	push   $0xf012e1e0
f011ae5d:	e8 29 61 fe ff       	call   f0100f8b <cprintf>
f011ae62:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011ae65:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ae6c:	83 ec 0c             	sub    $0xc,%esp
f011ae6f:	68 24 e2 12 f0       	push   $0xf012e224
f011ae74:	e8 12 61 fe ff       	call   f0100f8b <cprintf>
f011ae79:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011ae7c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ae83:	ff 45 d4             	incl   -0x2c(%ebp)
f011ae86:	ff 45 d8             	incl   -0x28(%ebp)
f011ae89:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ae8c:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ae8f:	7d 15                	jge    f011aea6 <test_kheap_virt_addr+0x7a3>
f011ae91:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011ae98:	7f 0c                	jg     f011aea6 <test_kheap_virt_addr+0x7a3>
f011ae9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ae9d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011aea0:	0f 82 29 ff ff ff    	jb     f011adcf <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011aea6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011aea9:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011aeac:	0f 82 c7 fe ff ff    	jb     f011ad79 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011aeb2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011aeb6:	74 04                	je     f011aebc <test_kheap_virt_addr+0x7b9>
f011aeb8:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011aebc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011aec3:	83 ec 0c             	sub    $0xc,%esp
f011aec6:	68 48 e2 12 f0       	push   $0xf012e248
f011aecb:	e8 bb 60 fe ff       	call   f0100f8b <cprintf>
f011aed0:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011aed3:	e8 24 28 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011aed8:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011aedb:	e8 86 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aee0:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011aee3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011aee9:	83 ec 0c             	sub    $0xc,%esp
f011aeec:	50                   	push   %eax
f011aeed:	e8 34 de fe ff       	call   f0108d26 <kfree>
f011aef2:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aef5:	e8 6c 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aefa:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011aefd:	74 17                	je     f011af16 <test_kheap_virt_addr+0x813>
f011aeff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af06:	83 ec 0c             	sub    $0xc,%esp
f011af09:	68 70 e2 12 f0       	push   $0xf012e270
f011af0e:	e8 78 60 fe ff       	call   f0100f8b <cprintf>
f011af13:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011af16:	e8 e1 27 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011af1b:	89 c2                	mov    %eax,%edx
f011af1d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011af20:	29 c2                	sub    %eax,%edx
f011af22:	89 d0                	mov    %edx,%eax
f011af24:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af29:	77 17                	ja     f011af42 <test_kheap_virt_addr+0x83f>
f011af2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af32:	83 ec 0c             	sub    $0xc,%esp
f011af35:	68 e0 e2 12 f0       	push   $0xf012e2e0
f011af3a:	e8 4c 60 fe ff       	call   f0100f8b <cprintf>
f011af3f:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011af42:	e8 b5 27 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011af47:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af4a:	e8 17 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011af4f:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011af52:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011af58:	83 ec 0c             	sub    $0xc,%esp
f011af5b:	50                   	push   %eax
f011af5c:	e8 c5 dd fe ff       	call   f0108d26 <kfree>
f011af61:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af64:	e8 fd 98 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011af69:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011af6c:	74 17                	je     f011af85 <test_kheap_virt_addr+0x882>
f011af6e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af75:	83 ec 0c             	sub    $0xc,%esp
f011af78:	68 1c e3 12 f0       	push   $0xf012e31c
f011af7d:	e8 09 60 fe ff       	call   f0100f8b <cprintf>
f011af82:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011af85:	e8 72 27 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011af8a:	89 c2                	mov    %eax,%edx
f011af8c:	8b 45 88             	mov    -0x78(%ebp),%eax
f011af8f:	29 c2                	sub    %eax,%edx
f011af91:	89 d0                	mov    %edx,%eax
f011af93:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af98:	77 17                	ja     f011afb1 <test_kheap_virt_addr+0x8ae>
f011af9a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011afa1:	83 ec 0c             	sub    $0xc,%esp
f011afa4:	68 8c e3 12 f0       	push   $0xf012e38c
f011afa9:	e8 dd 5f fe ff       	call   f0100f8b <cprintf>
f011afae:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011afb1:	e8 46 27 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011afb6:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afb9:	e8 a8 98 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011afbe:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011afc1:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011afc7:	83 ec 0c             	sub    $0xc,%esp
f011afca:	50                   	push   %eax
f011afcb:	e8 56 dd fe ff       	call   f0108d26 <kfree>
f011afd0:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afd3:	e8 8e 98 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011afd8:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011afdb:	74 17                	je     f011aff4 <test_kheap_virt_addr+0x8f1>
f011afdd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011afe4:	83 ec 0c             	sub    $0xc,%esp
f011afe7:	68 c8 e3 12 f0       	push   $0xf012e3c8
f011afec:	e8 9a 5f fe ff       	call   f0100f8b <cprintf>
f011aff1:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011aff4:	e8 03 27 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011aff9:	89 c2                	mov    %eax,%edx
f011affb:	8b 45 88             	mov    -0x78(%ebp),%eax
f011affe:	29 c2                	sub    %eax,%edx
f011b000:	89 d0                	mov    %edx,%eax
f011b002:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b007:	77 17                	ja     f011b020 <test_kheap_virt_addr+0x91d>
f011b009:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b010:	83 ec 0c             	sub    $0xc,%esp
f011b013:	68 38 e4 12 f0       	push   $0xf012e438
f011b018:	e8 6e 5f fe ff       	call   f0100f8b <cprintf>
f011b01d:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011b020:	83 ec 0c             	sub    $0xc,%esp
f011b023:	68 74 e4 12 f0       	push   $0xf012e474
f011b028:	e8 5e 5f fe ff       	call   f0100f8b <cprintf>
f011b02d:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b030:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b037:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011b03c:	05 00 10 00 00       	add    $0x1000,%eax
f011b041:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011b047:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011b04e:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011b055:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011b058:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b05e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b061:	eb 44                	jmp    f011b0a7 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b063:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b066:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b069:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b06c:	83 ec 0c             	sub    $0xc,%esp
f011b06f:	50                   	push   %eax
f011b070:	e8 eb dc fe ff       	call   f0108d60 <kheap_virtual_address>
f011b075:	83 c4 10             	add    $0x10,%esp
f011b078:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011b07e:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011b085:	74 1d                	je     f011b0a4 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011b087:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b08b:	74 17                	je     f011b0a4 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011b08d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b094:	83 ec 0c             	sub    $0xc,%esp
f011b097:	68 c4 e4 12 f0       	push   $0xf012e4c4
f011b09c:	e8 ea 5e fe ff       	call   f0100f8b <cprintf>
f011b0a1:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011b0a4:	ff 45 d0             	incl   -0x30(%ebp)
f011b0a7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b0ad:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011b0b3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b0b6:	39 c2                	cmp    %eax,%edx
f011b0b8:	77 a9                	ja     f011b063 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b0ba:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b0c0:	05 00 04 00 00       	add    $0x400,%eax
f011b0c5:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b0c8:	eb 64                	jmp    f011b12e <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b0ca:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b0cd:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b0d0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b0d3:	83 ec 0c             	sub    $0xc,%esp
f011b0d6:	50                   	push   %eax
f011b0d7:	e8 84 dc fe ff       	call   f0108d60 <kheap_virtual_address>
f011b0dc:	83 c4 10             	add    $0x10,%esp
f011b0df:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011b0e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b0e8:	c1 e0 0c             	shl    $0xc,%eax
f011b0eb:	89 c2                	mov    %eax,%edx
f011b0ed:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b0f3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b0f6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b0f9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b0fc:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b0ff:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b104:	01 c8                	add    %ecx,%eax
f011b106:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b10c:	74 1d                	je     f011b12b <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011b10e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b112:	74 17                	je     f011b12b <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011b114:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b11b:	83 ec 0c             	sub    $0xc,%esp
f011b11e:	68 e8 e4 12 f0       	push   $0xf012e4e8
f011b123:	e8 63 5e fe ff       	call   f0100f8b <cprintf>
f011b128:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b12b:	ff 45 d0             	incl   -0x30(%ebp)
f011b12e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b134:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011b13a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b13d:	39 c2                	cmp    %eax,%edx
f011b13f:	77 89                	ja     f011b0ca <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b141:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b147:	05 02 07 00 00       	add    $0x702,%eax
f011b14c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b14f:	eb 44                	jmp    f011b195 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b151:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b154:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b157:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b15a:	83 ec 0c             	sub    $0xc,%esp
f011b15d:	50                   	push   %eax
f011b15e:	e8 fd db fe ff       	call   f0108d60 <kheap_virtual_address>
f011b163:	83 c4 10             	add    $0x10,%esp
f011b166:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011b16c:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011b173:	74 1d                	je     f011b192 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011b175:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b179:	74 17                	je     f011b192 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011b17b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b182:	83 ec 0c             	sub    $0xc,%esp
f011b185:	68 0c e5 12 f0       	push   $0xf012e50c
f011b18a:	e8 fc 5d fe ff       	call   f0100f8b <cprintf>
f011b18f:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b192:	ff 45 d0             	incl   -0x30(%ebp)
f011b195:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b19b:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011b1a1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b1a4:	39 c2                	cmp    %eax,%edx
f011b1a6:	77 a9                	ja     f011b151 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011b1a8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b1ae:	05 02 0d 00 00       	add    $0xd02,%eax
f011b1b3:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b1b6:	eb 64                	jmp    f011b21c <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b1b8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b1bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b1be:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b1c1:	83 ec 0c             	sub    $0xc,%esp
f011b1c4:	50                   	push   %eax
f011b1c5:	e8 96 db fe ff       	call   f0108d60 <kheap_virtual_address>
f011b1ca:	83 c4 10             	add    $0x10,%esp
f011b1cd:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011b1d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b1d6:	c1 e0 0c             	shl    $0xc,%eax
f011b1d9:	89 c2                	mov    %eax,%edx
f011b1db:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b1e1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b1e4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b1e7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b1ea:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b1ed:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b1f2:	01 c8                	add    %ecx,%eax
f011b1f4:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011b1fa:	74 1d                	je     f011b219 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011b1fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b200:	74 17                	je     f011b219 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011b202:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b209:	83 ec 0c             	sub    $0xc,%esp
f011b20c:	68 30 e5 12 f0       	push   $0xf012e530
f011b211:	e8 75 5d fe ff       	call   f0100f8b <cprintf>
f011b216:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011b219:	ff 45 d0             	incl   -0x30(%ebp)
f011b21c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b222:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011b228:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b22b:	39 c2                	cmp    %eax,%edx
f011b22d:	77 89                	ja     f011b1b8 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011b22f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b233:	74 04                	je     f011b239 <test_kheap_virt_addr+0xb36>
f011b235:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011b239:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011b240:	83 ec 0c             	sub    $0xc,%esp
f011b243:	68 54 e5 12 f0       	push   $0xf012e554
f011b248:	e8 3e 5d fe ff       	call   f0100f8b <cprintf>
f011b24d:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011b250:	83 ec 0c             	sub    $0xc,%esp
f011b253:	6a 00                	push   $0x0
f011b255:	e8 a4 d9 fe ff       	call   f0108bfe <sbrk>
f011b25a:	83 c4 10             	add    $0x10,%esp
f011b25d:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b262:	77 17                	ja     f011b27b <test_kheap_virt_addr+0xb78>
f011b264:	83 ec 04             	sub    $0x4,%esp
f011b267:	68 9b e5 12 f0       	push   $0xf012e59b
f011b26c:	68 91 07 00 00       	push   $0x791
f011b271:	68 33 ba 12 f0       	push   $0xf012ba33
f011b276:	e8 be 50 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b27b:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011b282:	e9 d1 00 00 00       	jmp    f011b358 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b287:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011b28c:	83 ec 04             	sub    $0x4,%esp
f011b28f:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b295:	52                   	push   %edx
f011b296:	ff 75 cc             	pushl  -0x34(%ebp)
f011b299:	50                   	push   %eax
f011b29a:	e8 e5 d0 fe ff       	call   f0108384 <get_page_table>
f011b29f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b2a2:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b2a8:	85 c0                	test   %eax,%eax
f011b2aa:	75 1e                	jne    f011b2ca <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b2ac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b2b3:	83 ec 04             	sub    $0x4,%esp
f011b2b6:	68 24 df 12 f0       	push   $0xf012df24
f011b2bb:	68 97 07 00 00       	push   $0x797
f011b2c0:	68 33 ba 12 f0       	push   $0xf012ba33
f011b2c5:	e8 6f 50 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011b2ca:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b2d0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011b2d3:	c1 ea 0c             	shr    $0xc,%edx
f011b2d6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b2dc:	c1 e2 02             	shl    $0x2,%edx
f011b2df:	01 d0                	add    %edx,%eax
f011b2e1:	8b 00                	mov    (%eax),%eax
f011b2e3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b2e8:	89 c2                	mov    %eax,%edx
f011b2ea:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b2ed:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b2f2:	01 d0                	add    %edx,%eax
f011b2f4:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011b2fa:	83 ec 0c             	sub    $0xc,%esp
f011b2fd:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b303:	e8 58 da fe ff       	call   f0108d60 <kheap_virtual_address>
f011b308:	83 c4 10             	add    $0x10,%esp
f011b30b:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011b311:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011b317:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011b31a:	74 39                	je     f011b355 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011b31c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b320:	74 33                	je     f011b355 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011b322:	ff 75 cc             	pushl  -0x34(%ebp)
f011b325:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011b32b:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b331:	68 b4 e5 12 f0       	push   $0xf012e5b4
f011b336:	e8 50 5c fe ff       	call   f0100f8b <cprintf>
f011b33b:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011b33e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b345:	83 ec 0c             	sub    $0xc,%esp
f011b348:	68 e0 e5 12 f0       	push   $0xf012e5e0
f011b34d:	e8 39 5c fe ff       	call   f0100f8b <cprintf>
f011b352:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b355:	ff 45 cc             	incl   -0x34(%ebp)
f011b358:	83 ec 0c             	sub    $0xc,%esp
f011b35b:	6a 00                	push   $0x0
f011b35d:	e8 9c d8 fe ff       	call   f0108bfe <sbrk>
f011b362:	83 c4 10             	add    $0x10,%esp
f011b365:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011b368:	0f 87 19 ff ff ff    	ja     f011b287 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011b36e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b372:	74 04                	je     f011b378 <test_kheap_virt_addr+0xc75>
f011b374:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011b378:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011b37f:	83 ec 0c             	sub    $0xc,%esp
f011b382:	68 04 e6 12 f0       	push   $0xf012e604
f011b387:	e8 ff 5b fe ff       	call   f0100f8b <cprintf>
f011b38c:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011b38f:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011b396:	eb 5a                	jmp    f011b3f2 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011b398:	83 ec 0c             	sub    $0xc,%esp
f011b39b:	ff 75 c8             	pushl  -0x38(%ebp)
f011b39e:	e8 bd d9 fe ff       	call   f0108d60 <kheap_virtual_address>
f011b3a3:	83 c4 10             	add    $0x10,%esp
f011b3a6:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011b3ac:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011b3b3:	74 36                	je     f011b3eb <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011b3b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b3b9:	74 30                	je     f011b3eb <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011b3bb:	83 ec 04             	sub    $0x4,%esp
f011b3be:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011b3c4:	ff 75 c8             	pushl  -0x38(%ebp)
f011b3c7:	68 43 e6 12 f0       	push   $0xf012e643
f011b3cc:	e8 ba 5b fe ff       	call   f0100f8b <cprintf>
f011b3d1:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011b3d4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b3db:	83 ec 0c             	sub    $0xc,%esp
f011b3de:	68 60 e6 12 f0       	push   $0xf012e660
f011b3e3:	e8 a3 5b fe ff       	call   f0100f8b <cprintf>
f011b3e8:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011b3eb:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011b3f2:	b8 50 f6 60 00       	mov    $0x60f650,%eax
f011b3f7:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011b3fa:	72 9c                	jb     f011b398 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011b3fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b400:	74 04                	je     f011b406 <test_kheap_virt_addr+0xd03>
f011b402:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011b406:	83 ec 08             	sub    $0x8,%esp
f011b409:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b40c:	68 84 e6 12 f0       	push   $0xf012e684
f011b411:	e8 75 5b fe ff       	call   f0100f8b <cprintf>
f011b416:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b419:	b8 01 00 00 00       	mov    $0x1,%eax
f011b41e:	89 f4                	mov    %esi,%esp

}
f011b420:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011b423:	5b                   	pop    %ebx
f011b424:	5e                   	pop    %esi
f011b425:	5f                   	pop    %edi
f011b426:	5d                   	pop    %ebp
f011b427:	c3                   	ret    

f011b428 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011b428:	55                   	push   %ebp
f011b429:	89 e5                	mov    %esp,%ebp
f011b42b:	57                   	push   %edi
f011b42c:	56                   	push   %esi
f011b42d:	53                   	push   %ebx
f011b42e:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011b434:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011b43a:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b43f:	b8 00 00 00 00       	mov    $0x0,%eax
f011b444:	89 d7                	mov    %edx,%edi
f011b446:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011b448:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011b44f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011b456:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011b45d:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011b462:	0f b6 c0             	movzbl %al,%eax
f011b465:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b468:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011b46f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b472:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011b475:	39 c2                	cmp    %eax,%edx
f011b477:	73 02                	jae    f011b47b <test_ksbrk+0x53>
f011b479:	89 c2                	mov    %eax,%edx
f011b47b:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011b480:	0f b6 c0             	movzbl %al,%eax
f011b483:	c1 e0 04             	shl    $0x4,%eax
f011b486:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011b489:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011b490:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011b493:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b496:	39 c8                	cmp    %ecx,%eax
f011b498:	73 02                	jae    f011b49c <test_ksbrk+0x74>
f011b49a:	89 c8                	mov    %ecx,%eax
f011b49c:	01 d0                	add    %edx,%eax
f011b49e:	83 c0 10             	add    $0x10,%eax
f011b4a1:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011b4a6:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011b4a9:	83 ec 0c             	sub    $0xc,%esp
f011b4ac:	68 b8 e6 12 f0       	push   $0xf012e6b8
f011b4b1:	e8 d5 5a fe ff       	call   f0100f8b <cprintf>
f011b4b6:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011b4b9:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b4c0:	e8 37 22 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b4c5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b4c8:	e8 99 93 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b4cd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011b4d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b4d3:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b4d6:	29 c2                	sub    %eax,%edx
f011b4d8:	89 d0                	mov    %edx,%eax
f011b4da:	83 ec 0c             	sub    $0xc,%esp
f011b4dd:	50                   	push   %eax
f011b4de:	e8 29 d8 fe ff       	call   f0108d0c <kmalloc>
f011b4e3:	83 c4 10             	add    $0x10,%esp
f011b4e6:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011b4ec:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b4ef:	89 c2                	mov    %eax,%edx
f011b4f1:	c1 ea 1f             	shr    $0x1f,%edx
f011b4f4:	01 d0                	add    %edx,%eax
f011b4f6:	d1 f8                	sar    %eax
f011b4f8:	89 c2                	mov    %eax,%edx
f011b4fa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b4fd:	01 d0                	add    %edx,%eax
f011b4ff:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011b502:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011b508:	6a 01                	push   $0x1
f011b50a:	ff 75 b8             	pushl  -0x48(%ebp)
f011b50d:	ff 75 ac             	pushl  -0x54(%ebp)
f011b510:	50                   	push   %eax
f011b511:	e8 fc 43 ff ff       	call   f010f912 <check_block>
f011b516:	83 c4 10             	add    $0x10,%esp
f011b519:	85 c0                	test   %eax,%eax
f011b51b:	75 17                	jne    f011b534 <test_ksbrk+0x10c>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011b51d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b524:	83 ec 0c             	sub    $0xc,%esp
f011b527:	68 09 e7 12 f0       	push   $0xf012e709
f011b52c:	e8 5a 5a fe ff       	call   f0100f8b <cprintf>
f011b531:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b534:	e8 c3 21 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b539:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b53c:	74 17                	je     f011b555 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011b53e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b545:	83 ec 0c             	sub    $0xc,%esp
f011b548:	68 20 e7 12 f0       	push   $0xf012e720
f011b54d:	e8 39 5a fe ff       	call   f0100f8b <cprintf>
f011b552:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b555:	e8 0c 93 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b55a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b55d:	74 17                	je     f011b576 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b55f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b566:	83 ec 0c             	sub    $0xc,%esp
f011b569:	68 40 e7 12 f0       	push   $0xf012e740
f011b56e:	e8 18 5a fe ff       	call   f0100f8b <cprintf>
f011b573:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011b576:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011b57b:	0f b6 c0             	movzbl %al,%eax
f011b57e:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011b581:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011b588:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b58b:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011b58e:	39 c2                	cmp    %eax,%edx
f011b590:	73 02                	jae    f011b594 <test_ksbrk+0x16c>
f011b592:	89 c2                	mov    %eax,%edx
f011b594:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011b599:	0f b6 c0             	movzbl %al,%eax
f011b59c:	c1 e0 04             	shl    $0x4,%eax
f011b59f:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011b5a2:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011b5a9:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011b5ac:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b5af:	39 c8                	cmp    %ecx,%eax
f011b5b1:	73 02                	jae    f011b5b5 <test_ksbrk+0x18d>
f011b5b3:	89 c8                	mov    %ecx,%eax
f011b5b5:	01 d0                	add    %edx,%eax
f011b5b7:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011b5bc:	29 c2                	sub    %eax,%edx
f011b5be:	89 d0                	mov    %edx,%eax
f011b5c0:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b5c3:	e8 34 21 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b5c8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b5cb:	e8 96 92 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b5d0:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011b5d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b5d6:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b5d9:	29 c2                	sub    %eax,%edx
f011b5db:	89 d0                	mov    %edx,%eax
f011b5dd:	83 ec 0c             	sub    $0xc,%esp
f011b5e0:	50                   	push   %eax
f011b5e1:	e8 26 d7 fe ff       	call   f0108d0c <kmalloc>
f011b5e6:	83 c4 10             	add    $0x10,%esp
f011b5e9:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011b5ef:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b5f2:	89 c2                	mov    %eax,%edx
f011b5f4:	c1 ea 1f             	shr    $0x1f,%edx
f011b5f7:	01 d0                	add    %edx,%eax
f011b5f9:	d1 f8                	sar    %eax
f011b5fb:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011b601:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b604:	01 d0                	add    %edx,%eax
f011b606:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011b609:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011b60f:	6a 01                	push   $0x1
f011b611:	ff 75 b8             	pushl  -0x48(%ebp)
f011b614:	ff 75 ac             	pushl  -0x54(%ebp)
f011b617:	50                   	push   %eax
f011b618:	e8 f5 42 ff ff       	call   f010f912 <check_block>
f011b61d:	83 c4 10             	add    $0x10,%esp
f011b620:	85 c0                	test   %eax,%eax
f011b622:	75 17                	jne    f011b63b <test_ksbrk+0x213>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011b624:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b62b:	83 ec 0c             	sub    $0xc,%esp
f011b62e:	68 ae e7 12 f0       	push   $0xf012e7ae
f011b633:	e8 53 59 fe ff       	call   f0100f8b <cprintf>
f011b638:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b63b:	e8 bc 20 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b640:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b643:	74 17                	je     f011b65c <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011b645:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b64c:	83 ec 0c             	sub    $0xc,%esp
f011b64f:	68 c8 e7 12 f0       	push   $0xf012e7c8
f011b654:	e8 32 59 fe ff       	call   f0100f8b <cprintf>
f011b659:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b65c:	e8 05 92 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b661:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b664:	74 17                	je     f011b67d <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b666:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b66d:	83 ec 0c             	sub    $0xc,%esp
f011b670:	68 e8 e7 12 f0       	push   $0xf012e7e8
f011b675:	e8 11 59 fe ff       	call   f0100f8b <cprintf>
f011b67a:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011b67d:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011b684:	e8 73 20 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b689:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b68c:	e8 d5 91 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b691:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011b694:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b697:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b69a:	29 c2                	sub    %eax,%edx
f011b69c:	89 d0                	mov    %edx,%eax
f011b69e:	83 ec 0c             	sub    $0xc,%esp
f011b6a1:	50                   	push   %eax
f011b6a2:	e8 65 d6 fe ff       	call   f0108d0c <kmalloc>
f011b6a7:	83 c4 10             	add    $0x10,%esp
f011b6aa:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011b6b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b6b3:	89 c2                	mov    %eax,%edx
f011b6b5:	c1 ea 1f             	shr    $0x1f,%edx
f011b6b8:	01 d0                	add    %edx,%eax
f011b6ba:	d1 f8                	sar    %eax
f011b6bc:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011b6c1:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011b6c4:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011b6ca:	6a 01                	push   $0x1
f011b6cc:	ff 75 b8             	pushl  -0x48(%ebp)
f011b6cf:	ff 75 ac             	pushl  -0x54(%ebp)
f011b6d2:	50                   	push   %eax
f011b6d3:	e8 3a 42 ff ff       	call   f010f912 <check_block>
f011b6d8:	83 c4 10             	add    $0x10,%esp
f011b6db:	85 c0                	test   %eax,%eax
f011b6dd:	75 17                	jne    f011b6f6 <test_ksbrk+0x2ce>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011b6df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b6e6:	83 ec 0c             	sub    $0xc,%esp
f011b6e9:	68 56 e8 12 f0       	push   $0xf012e856
f011b6ee:	e8 98 58 fe ff       	call   f0100f8b <cprintf>
f011b6f3:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011b6f6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011b6f9:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011b6fc:	b8 00 10 00 00       	mov    $0x1000,%eax
f011b701:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011b704:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011b707:	6a 00                	push   $0x0
f011b709:	ff 75 98             	pushl  -0x68(%ebp)
f011b70c:	ff 75 ac             	pushl  -0x54(%ebp)
f011b70f:	ff 75 ac             	pushl  -0x54(%ebp)
f011b712:	e8 fb 41 ff ff       	call   f010f912 <check_block>
f011b717:	83 c4 10             	add    $0x10,%esp
f011b71a:	85 c0                	test   %eax,%eax
f011b71c:	75 17                	jne    f011b735 <test_ksbrk+0x30d>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011b71e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b725:	83 ec 0c             	sub    $0xc,%esp
f011b728:	68 6d e8 12 f0       	push   $0xf012e86d
f011b72d:	e8 59 58 fe ff       	call   f0100f8b <cprintf>
f011b732:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011b735:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011b73c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b73f:	8b 00                	mov    (%eax),%eax
f011b741:	83 f8 01             	cmp    $0x1,%eax
f011b744:	74 17                	je     f011b75d <test_ksbrk+0x335>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011b746:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b74d:	83 ec 0c             	sub    $0xc,%esp
f011b750:	68 84 e8 12 f0       	push   $0xf012e884
f011b755:	e8 31 58 fe ff       	call   f0100f8b <cprintf>
f011b75a:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011b75d:	83 ec 0c             	sub    $0xc,%esp
f011b760:	6a 00                	push   $0x0
f011b762:	e8 97 d4 fe ff       	call   f0108bfe <sbrk>
f011b767:	83 c4 10             	add    $0x10,%esp
f011b76a:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011b76d:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011b774:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b777:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b77a:	74 1d                	je     f011b799 <test_ksbrk+0x371>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011b77c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b783:	83 ec 04             	sub    $0x4,%esp
f011b786:	ff 75 90             	pushl  -0x70(%ebp)
f011b789:	ff 75 8c             	pushl  -0x74(%ebp)
f011b78c:	68 b0 e8 12 f0       	push   $0xf012e8b0
f011b791:	e8 f5 57 fe ff       	call   f0100f8b <cprintf>
f011b796:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011b799:	e8 5e 1f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b79e:	89 c2                	mov    %eax,%edx
f011b7a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011b7a3:	29 d0                	sub    %edx,%eax
f011b7a5:	83 f8 01             	cmp    $0x1,%eax
f011b7a8:	74 17                	je     f011b7c1 <test_ksbrk+0x399>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011b7aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7b1:	83 ec 0c             	sub    $0xc,%esp
f011b7b4:	68 e4 e8 12 f0       	push   $0xf012e8e4
f011b7b9:	e8 cd 57 fe ff       	call   f0100f8b <cprintf>
f011b7be:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b7c1:	e8 a0 90 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b7c6:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b7c9:	74 17                	je     f011b7e2 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b7cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7d2:	83 ec 0c             	sub    $0xc,%esp
f011b7d5:	68 04 e9 12 f0       	push   $0xf012e904
f011b7da:	e8 ac 57 fe ff       	call   f0100f8b <cprintf>
f011b7df:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011b7e2:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b7e9:	e8 0e 1f ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b7ee:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b7f1:	e8 70 90 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b7f6:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011b7f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b7fc:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b7ff:	29 c2                	sub    %eax,%edx
f011b801:	89 d0                	mov    %edx,%eax
f011b803:	83 ec 0c             	sub    $0xc,%esp
f011b806:	50                   	push   %eax
f011b807:	e8 00 d5 fe ff       	call   f0108d0c <kmalloc>
f011b80c:	83 c4 10             	add    $0x10,%esp
f011b80f:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011b815:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011b81c:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011b822:	6a 01                	push   $0x1
f011b824:	ff 75 b8             	pushl  -0x48(%ebp)
f011b827:	ff 75 ac             	pushl  -0x54(%ebp)
f011b82a:	50                   	push   %eax
f011b82b:	e8 e2 40 ff ff       	call   f010f912 <check_block>
f011b830:	83 c4 10             	add    $0x10,%esp
f011b833:	85 c0                	test   %eax,%eax
f011b835:	75 17                	jne    f011b84e <test_ksbrk+0x426>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011b837:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b83e:	83 ec 0c             	sub    $0xc,%esp
f011b841:	68 73 e9 12 f0       	push   $0xf012e973
f011b846:	e8 40 57 fe ff       	call   f0100f8b <cprintf>
f011b84b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b84e:	e8 a9 1e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b853:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b856:	74 17                	je     f011b86f <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011b858:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b85f:	83 ec 0c             	sub    $0xc,%esp
f011b862:	68 8c e9 12 f0       	push   $0xf012e98c
f011b867:	e8 1f 57 fe ff       	call   f0100f8b <cprintf>
f011b86c:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b86f:	e8 f2 8f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b874:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b877:	74 17                	je     f011b890 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b879:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b880:	83 ec 0c             	sub    $0xc,%esp
f011b883:	68 ac e9 12 f0       	push   $0xf012e9ac
f011b888:	e8 fe 56 fe ff       	call   f0100f8b <cprintf>
f011b88d:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011b890:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b894:	74 04                	je     f011b89a <test_ksbrk+0x472>
		eval += 25;
f011b896:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011b89a:	83 ec 0c             	sub    $0xc,%esp
f011b89d:	68 1c ea 12 f0       	push   $0xf012ea1c
f011b8a2:	e8 e4 56 fe ff       	call   f0100f8b <cprintf>
f011b8a7:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011b8aa:	83 ec 0c             	sub    $0xc,%esp
f011b8ad:	6a 00                	push   $0x0
f011b8af:	e8 4a d3 fe ff       	call   f0108bfe <sbrk>
f011b8b4:	83 c4 10             	add    $0x10,%esp
f011b8b7:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011b8ba:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b8c1:	e8 36 1e ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b8c6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b8c9:	e8 98 8f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b8ce:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011b8d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b8d4:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b8d7:	29 c2                	sub    %eax,%edx
f011b8d9:	89 d0                	mov    %edx,%eax
f011b8db:	83 ec 0c             	sub    $0xc,%esp
f011b8de:	50                   	push   %eax
f011b8df:	e8 28 d4 fe ff       	call   f0108d0c <kmalloc>
f011b8e4:	83 c4 10             	add    $0x10,%esp
f011b8e7:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011b8ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b8f0:	89 c2                	mov    %eax,%edx
f011b8f2:	c1 ea 1f             	shr    $0x1f,%edx
f011b8f5:	01 d0                	add    %edx,%eax
f011b8f7:	d1 f8                	sar    %eax
f011b8f9:	89 c2                	mov    %eax,%edx
f011b8fb:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b8fe:	01 d0                	add    %edx,%eax
f011b900:	83 e8 04             	sub    $0x4,%eax
f011b903:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011b906:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011b90c:	6a 01                	push   $0x1
f011b90e:	ff 75 b8             	pushl  -0x48(%ebp)
f011b911:	ff 75 ac             	pushl  -0x54(%ebp)
f011b914:	50                   	push   %eax
f011b915:	e8 f8 3f ff ff       	call   f010f912 <check_block>
f011b91a:	83 c4 10             	add    $0x10,%esp
f011b91d:	85 c0                	test   %eax,%eax
f011b91f:	75 17                	jne    f011b938 <test_ksbrk+0x510>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011b921:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b928:	83 ec 0c             	sub    $0xc,%esp
f011b92b:	68 7f ea 12 f0       	push   $0xf012ea7f
f011b930:	e8 56 56 fe ff       	call   f0100f8b <cprintf>
f011b935:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011b938:	e8 bf 1d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b93d:	89 c2                	mov    %eax,%edx
f011b93f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011b942:	29 d0                	sub    %edx,%eax
f011b944:	83 f8 01             	cmp    $0x1,%eax
f011b947:	74 17                	je     f011b960 <test_ksbrk+0x538>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011b949:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b950:	83 ec 0c             	sub    $0xc,%esp
f011b953:	68 98 ea 12 f0       	push   $0xf012ea98
f011b958:	e8 2e 56 fe ff       	call   f0100f8b <cprintf>
f011b95d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b960:	e8 01 8f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b965:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b968:	74 17                	je     f011b981 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b96a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b971:	83 ec 0c             	sub    $0xc,%esp
f011b974:	68 b8 ea 12 f0       	push   $0xf012eab8
f011b979:	e8 0d 56 fe ff       	call   f0100f8b <cprintf>
f011b97e:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011b981:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b988:	e8 6f 1d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b98d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b990:	e8 d1 8e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b995:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011b998:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b99b:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b99e:	29 c2                	sub    %eax,%edx
f011b9a0:	89 d0                	mov    %edx,%eax
f011b9a2:	83 ec 0c             	sub    $0xc,%esp
f011b9a5:	50                   	push   %eax
f011b9a6:	e8 61 d3 fe ff       	call   f0108d0c <kmalloc>
f011b9ab:	83 c4 10             	add    $0x10,%esp
f011b9ae:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011b9b4:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011b9bb:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011b9c1:	6a 01                	push   $0x1
f011b9c3:	ff 75 b8             	pushl  -0x48(%ebp)
f011b9c6:	ff 75 ac             	pushl  -0x54(%ebp)
f011b9c9:	50                   	push   %eax
f011b9ca:	e8 43 3f ff ff       	call   f010f912 <check_block>
f011b9cf:	83 c4 10             	add    $0x10,%esp
f011b9d2:	85 c0                	test   %eax,%eax
f011b9d4:	75 17                	jne    f011b9ed <test_ksbrk+0x5c5>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011b9d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9dd:	83 ec 0c             	sub    $0xc,%esp
f011b9e0:	68 26 eb 12 f0       	push   $0xf012eb26
f011b9e5:	e8 a1 55 fe ff       	call   f0100f8b <cprintf>
f011b9ea:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b9ed:	e8 0a 1d ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011b9f2:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b9f5:	74 17                	je     f011ba0e <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011b9f7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9fe:	83 ec 0c             	sub    $0xc,%esp
f011ba01:	68 40 eb 12 f0       	push   $0xf012eb40
f011ba06:	e8 80 55 fe ff       	call   f0100f8b <cprintf>
f011ba0b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ba0e:	e8 53 8e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ba13:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ba16:	74 17                	je     f011ba2f <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba1f:	83 ec 0c             	sub    $0xc,%esp
f011ba22:	68 60 eb 12 f0       	push   $0xf012eb60
f011ba27:	e8 5f 55 fe ff       	call   f0100f8b <cprintf>
f011ba2c:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011ba2f:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011ba36:	e8 c1 1c ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011ba3b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ba3e:	e8 23 8e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ba43:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ba46:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ba49:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ba4c:	29 c2                	sub    %eax,%edx
f011ba4e:	89 d0                	mov    %edx,%eax
f011ba50:	83 ec 0c             	sub    $0xc,%esp
f011ba53:	50                   	push   %eax
f011ba54:	e8 b3 d2 fe ff       	call   f0108d0c <kmalloc>
f011ba59:	83 c4 10             	add    $0x10,%esp
f011ba5c:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011ba62:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ba69:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ba6f:	6a 01                	push   $0x1
f011ba71:	ff 75 b8             	pushl  -0x48(%ebp)
f011ba74:	ff 75 ac             	pushl  -0x54(%ebp)
f011ba77:	50                   	push   %eax
f011ba78:	e8 95 3e ff ff       	call   f010f912 <check_block>
f011ba7d:	83 c4 10             	add    $0x10,%esp
f011ba80:	85 c0                	test   %eax,%eax
f011ba82:	75 17                	jne    f011ba9b <test_ksbrk+0x673>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011ba84:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba8b:	83 ec 0c             	sub    $0xc,%esp
f011ba8e:	68 ce eb 12 f0       	push   $0xf012ebce
f011ba93:	e8 f3 54 fe ff       	call   f0100f8b <cprintf>
f011ba98:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011ba9b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ba9e:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011baa1:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011baa8:	6a 00                	push   $0x0
f011baaa:	ff 75 98             	pushl  -0x68(%ebp)
f011baad:	ff 75 ac             	pushl  -0x54(%ebp)
f011bab0:	ff 75 ac             	pushl  -0x54(%ebp)
f011bab3:	e8 5a 3e ff ff       	call   f010f912 <check_block>
f011bab8:	83 c4 10             	add    $0x10,%esp
f011babb:	85 c0                	test   %eax,%eax
f011babd:	75 17                	jne    f011bad6 <test_ksbrk+0x6ae>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011babf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bac6:	83 ec 0c             	sub    $0xc,%esp
f011bac9:	68 e5 eb 12 f0       	push   $0xf012ebe5
f011bace:	e8 b8 54 fe ff       	call   f0100f8b <cprintf>
f011bad3:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011bad6:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bad9:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011bade:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011bae1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011bae4:	8b 00                	mov    (%eax),%eax
f011bae6:	83 f8 01             	cmp    $0x1,%eax
f011bae9:	74 17                	je     f011bb02 <test_ksbrk+0x6da>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011baeb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011baf2:	83 ec 0c             	sub    $0xc,%esp
f011baf5:	68 fc eb 12 f0       	push   $0xf012ebfc
f011bafa:	e8 8c 54 fe ff       	call   f0100f8b <cprintf>
f011baff:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011bb02:	83 ec 0c             	sub    $0xc,%esp
f011bb05:	6a 00                	push   $0x0
f011bb07:	e8 f2 d0 fe ff       	call   f0108bfe <sbrk>
f011bb0c:	83 c4 10             	add    $0x10,%esp
f011bb0f:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011bb12:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bb15:	05 00 20 00 00       	add    $0x2000,%eax
f011bb1a:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011bb1d:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bb20:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bb23:	74 1d                	je     f011bb42 <test_ksbrk+0x71a>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011bb25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb2c:	83 ec 04             	sub    $0x4,%esp
f011bb2f:	ff 75 90             	pushl  -0x70(%ebp)
f011bb32:	ff 75 8c             	pushl  -0x74(%ebp)
f011bb35:	68 28 ec 12 f0       	push   $0xf012ec28
f011bb3a:	e8 4c 54 fe ff       	call   f0100f8b <cprintf>
f011bb3f:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011bb42:	e8 b5 1b ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011bb47:	89 c2                	mov    %eax,%edx
f011bb49:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bb4c:	29 d0                	sub    %edx,%eax
f011bb4e:	83 f8 01             	cmp    $0x1,%eax
f011bb51:	74 17                	je     f011bb6a <test_ksbrk+0x742>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011bb53:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb5a:	83 ec 0c             	sub    $0xc,%esp
f011bb5d:	68 5c ec 12 f0       	push   $0xf012ec5c
f011bb62:	e8 24 54 fe ff       	call   f0100f8b <cprintf>
f011bb67:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bb6a:	e8 f7 8c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bb6f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bb72:	74 17                	je     f011bb8b <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb74:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb7b:	83 ec 0c             	sub    $0xc,%esp
f011bb7e:	68 7c ec 12 f0       	push   $0xf012ec7c
f011bb83:	e8 03 54 fe ff       	call   f0100f8b <cprintf>
f011bb88:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011bb8b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bb8f:	74 04                	je     f011bb95 <test_ksbrk+0x76d>
		eval += 25;
f011bb91:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011bb95:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011bb9c:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011bba2:	bb b8 ef 12 f0       	mov    $0xf012efb8,%ebx
f011bba7:	ba 05 00 00 00       	mov    $0x5,%edx
f011bbac:	89 c7                	mov    %eax,%edi
f011bbae:	89 de                	mov    %ebx,%esi
f011bbb0:	89 d1                	mov    %edx,%ecx
f011bbb2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011bbb4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011bbba:	bb cc ef 12 f0       	mov    $0xf012efcc,%ebx
f011bbbf:	ba 05 00 00 00       	mov    $0x5,%edx
f011bbc4:	89 c7                	mov    %eax,%edi
f011bbc6:	89 de                	mov    %ebx,%esi
f011bbc8:	89 d1                	mov    %edx,%ecx
f011bbca:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011bbcc:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011bbd2:	bb e0 ef 12 f0       	mov    $0xf012efe0,%ebx
f011bbd7:	ba 05 00 00 00       	mov    $0x5,%edx
f011bbdc:	89 c7                	mov    %eax,%edi
f011bbde:	89 de                	mov    %ebx,%esi
f011bbe0:	89 d1                	mov    %edx,%ecx
f011bbe2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011bbe4:	83 ec 04             	sub    $0x4,%esp
f011bbe7:	68 00 00 00 f8       	push   $0xf8000000
f011bbec:	68 00 10 00 00       	push   $0x1000
f011bbf1:	68 00 00 00 f6       	push   $0xf6000000
f011bbf6:	e8 11 cf fe ff       	call   f0108b0c <initialize_kheap_dynamic_allocator>
f011bbfb:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011bbfe:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011bc05:	eb 1b                	jmp    f011bc22 <test_ksbrk+0x7fa>
	{
		unmap_frame(ptr_page_directory, va);
f011bc07:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011bc0c:	83 ec 08             	sub    $0x8,%esp
f011bc0f:	ff 75 dc             	pushl  -0x24(%ebp)
f011bc12:	50                   	push   %eax
f011bc13:	e8 5c cb fe ff       	call   f0108774 <unmap_frame>
f011bc18:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011bc1b:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011bc22:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011bc29:	76 dc                	jbe    f011bc07 <test_ksbrk+0x7df>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011bc2b:	83 ec 0c             	sub    $0xc,%esp
f011bc2e:	68 ec ec 12 f0       	push   $0xf012ecec
f011bc33:	e8 53 53 fe ff       	call   f0100f8b <cprintf>
f011bc38:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011bc3b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011bc42:	e9 21 01 00 00       	jmp    f011bd68 <test_ksbrk+0x940>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011bc47:	e8 b0 1a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011bc4c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011bc4f:	e8 12 8c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bc54:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011bc57:	83 ec 0c             	sub    $0xc,%esp
f011bc5a:	6a 00                	push   $0x0
f011bc5c:	e8 9d cf fe ff       	call   f0108bfe <sbrk>
f011bc61:	83 c4 10             	add    $0x10,%esp
f011bc64:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011bc67:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bc6a:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011bc71:	83 ec 0c             	sub    $0xc,%esp
f011bc74:	50                   	push   %eax
f011bc75:	e8 84 cf fe ff       	call   f0108bfe <sbrk>
f011bc7a:	83 c4 10             	add    $0x10,%esp
f011bc7d:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011bc80:	83 ec 0c             	sub    $0xc,%esp
f011bc83:	6a 00                	push   $0x0
f011bc85:	e8 74 cf fe ff       	call   f0108bfe <sbrk>
f011bc8a:	83 c4 10             	add    $0x10,%esp
f011bc8d:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011bc90:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bc97:	e8 ca 8b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bc9c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bc9f:	74 1a                	je     f011bcbb <test_ksbrk+0x893>
			{
				correct = 0;
f011bca1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011bca8:	83 ec 08             	sub    $0x8,%esp
f011bcab:	ff 75 d8             	pushl  -0x28(%ebp)
f011bcae:	68 30 ed 12 f0       	push   $0xf012ed30
f011bcb3:	e8 d3 52 fe ff       	call   f0100f8b <cprintf>
f011bcb8:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011bcbb:	e8 3c 1a ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011bcc0:	89 c2                	mov    %eax,%edx
f011bcc2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bcc5:	29 d0                	sub    %edx,%eax
f011bcc7:	89 c2                	mov    %eax,%edx
f011bcc9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bccc:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011bcd3:	39 c2                	cmp    %eax,%edx
f011bcd5:	74 1a                	je     f011bcf1 <test_ksbrk+0x8c9>
			{
				correct = 0;
f011bcd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011bcde:	83 ec 08             	sub    $0x8,%esp
f011bce1:	ff 75 d8             	pushl  -0x28(%ebp)
f011bce4:	68 a0 ed 12 f0       	push   $0xf012eda0
f011bce9:	e8 9d 52 fe ff       	call   f0100f8b <cprintf>
f011bcee:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011bcf1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bcf4:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011bcfb:	8b 45 80             	mov    -0x80(%ebp),%eax
f011bcfe:	39 c2                	cmp    %eax,%edx
f011bd00:	74 25                	je     f011bd27 <test_ksbrk+0x8ff>
			{
				correct = 0;
f011bd02:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011bd09:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bd0c:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011bd13:	ff 75 80             	pushl  -0x80(%ebp)
f011bd16:	50                   	push   %eax
f011bd17:	ff 75 d8             	pushl  -0x28(%ebp)
f011bd1a:	68 c0 ed 12 f0       	push   $0xf012edc0
f011bd1f:	e8 67 52 fe ff       	call   f0100f8b <cprintf>
f011bd24:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011bd27:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bd2a:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011bd31:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011bd34:	74 25                	je     f011bd5b <test_ksbrk+0x933>
			{
				correct = 0;
f011bd36:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011bd3d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bd40:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011bd47:	ff 75 90             	pushl  -0x70(%ebp)
f011bd4a:	50                   	push   %eax
f011bd4b:	ff 75 d8             	pushl  -0x28(%ebp)
f011bd4e:	68 f8 ed 12 f0       	push   $0xf012edf8
f011bd53:	e8 33 52 fe ff       	call   f0100f8b <cprintf>
f011bd58:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011bd5b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bd5f:	74 04                	je     f011bd65 <test_ksbrk+0x93d>
				eval += 10;
f011bd61:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011bd65:	ff 45 d8             	incl   -0x28(%ebp)
f011bd68:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011bd6b:	8d 50 ff             	lea    -0x1(%eax),%edx
f011bd6e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bd71:	39 c2                	cmp    %eax,%edx
f011bd73:	0f 87 ce fe ff ff    	ja     f011bc47 <test_ksbrk+0x81f>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011bd79:	83 ec 0c             	sub    $0xc,%esp
f011bd7c:	68 2c ee 12 f0       	push   $0xf012ee2c
f011bd81:	e8 05 52 fe ff       	call   f0100f8b <cprintf>
f011bd86:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011bd89:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011bd8c:	48                   	dec    %eax
f011bd8d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011bd90:	e9 18 01 00 00       	jmp    f011bead <test_ksbrk+0xa85>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011bd95:	e8 62 19 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011bd9a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011bd9d:	e8 c4 8a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bda2:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011bda5:	83 ec 0c             	sub    $0xc,%esp
f011bda8:	6a 00                	push   $0x0
f011bdaa:	e8 4f ce fe ff       	call   f0108bfe <sbrk>
f011bdaf:	83 c4 10             	add    $0x10,%esp
f011bdb2:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011bdb5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011bdb8:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011bdbf:	83 ec 0c             	sub    $0xc,%esp
f011bdc2:	50                   	push   %eax
f011bdc3:	e8 36 ce fe ff       	call   f0108bfe <sbrk>
f011bdc8:	83 c4 10             	add    $0x10,%esp
f011bdcb:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011bdd1:	83 ec 0c             	sub    $0xc,%esp
f011bdd4:	6a 00                	push   $0x0
f011bdd6:	e8 23 ce fe ff       	call   f0108bfe <sbrk>
f011bddb:	83 c4 10             	add    $0x10,%esp
f011bdde:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011bde1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bde8:	e8 79 8a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bded:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bdf0:	74 1a                	je     f011be0c <test_ksbrk+0x9e4>
			{
				correct = 0;
f011bdf2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011bdf9:	83 ec 08             	sub    $0x8,%esp
f011bdfc:	ff 75 d4             	pushl  -0x2c(%ebp)
f011bdff:	68 7c ee 12 f0       	push   $0xf012ee7c
f011be04:	e8 82 51 fe ff       	call   f0100f8b <cprintf>
f011be09:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011be0c:	e8 eb 18 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011be11:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011be14:	74 1a                	je     f011be30 <test_ksbrk+0xa08>
			{
				correct = 0;
f011be16:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011be1d:	83 ec 08             	sub    $0x8,%esp
f011be20:	ff 75 d4             	pushl  -0x2c(%ebp)
f011be23:	68 ec ee 12 f0       	push   $0xf012eeec
f011be28:	e8 5e 51 fe ff       	call   f0100f8b <cprintf>
f011be2d:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011be30:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011be33:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011be3a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011be40:	39 c2                	cmp    %eax,%edx
f011be42:	74 28                	je     f011be6c <test_ksbrk+0xa44>
			{
				correct = 0;
f011be44:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011be4b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011be4e:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011be55:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011be5b:	50                   	push   %eax
f011be5c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011be5f:	68 0c ef 12 f0       	push   $0xf012ef0c
f011be64:	e8 22 51 fe ff       	call   f0100f8b <cprintf>
f011be69:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011be6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011be6f:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011be76:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011be79:	74 25                	je     f011bea0 <test_ksbrk+0xa78>
			{
				correct = 0;
f011be7b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011be82:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011be85:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011be8c:	ff 75 90             	pushl  -0x70(%ebp)
f011be8f:	50                   	push   %eax
f011be90:	ff 75 d4             	pushl  -0x2c(%ebp)
f011be93:	68 44 ef 12 f0       	push   $0xf012ef44
f011be98:	e8 ee 50 fe ff       	call   f0100f8b <cprintf>
f011be9d:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011bea0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bea4:	74 04                	je     f011beaa <test_ksbrk+0xa82>
				eval += 10;
f011bea6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011beaa:	ff 45 d4             	incl   -0x2c(%ebp)
f011bead:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011beb0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011beb3:	0f 82 dc fe ff ff    	jb     f011bd95 <test_ksbrk+0x96d>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011beb9:	83 ec 08             	sub    $0x8,%esp
f011bebc:	ff 75 e4             	pushl  -0x1c(%ebp)
f011bebf:	68 78 ef 12 f0       	push   $0xf012ef78
f011bec4:	e8 c2 50 fe ff       	call   f0100f8b <cprintf>
f011bec9:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011becc:	83 ec 0c             	sub    $0xc,%esp
f011becf:	68 a2 ef 12 f0       	push   $0xf012efa2
f011bed4:	e8 b2 50 fe ff       	call   f0100f8b <cprintf>
f011bed9:	83 c4 10             	add    $0x10,%esp
	return 0;
f011bedc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011bee1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011bee4:	5b                   	pop    %ebx
f011bee5:	5e                   	pop    %esi
f011bee6:	5f                   	pop    %edi
f011bee7:	5d                   	pop    %ebp
f011bee8:	c3                   	ret    

f011bee9 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011bee9:	55                   	push   %ebp
f011beea:	89 e5                	mov    %esp,%ebp
f011beec:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011beef:	83 ec 04             	sub    $0x4,%esp
f011bef2:	68 f4 ef 12 f0       	push   $0xf012eff4
f011bef7:	68 c1 08 00 00       	push   $0x8c1
f011befc:	68 33 ba 12 f0       	push   $0xf012ba33
f011bf01:	e8 33 44 fe ff       	call   f0100339 <_panic>

f011bf06 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011bf06:	55                   	push   %ebp
f011bf07:	89 e5                	mov    %esp,%ebp
f011bf09:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011bf0c:	83 ec 04             	sub    $0x4,%esp
f011bf0f:	68 f4 ef 12 f0       	push   $0xf012eff4
f011bf14:	68 c6 08 00 00       	push   $0x8c6
f011bf19:	68 33 ba 12 f0       	push   $0xf012ba33
f011bf1e:	e8 16 44 fe ff       	call   f0100339 <_panic>

f011bf23 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011bf23:	55                   	push   %ebp
f011bf24:	89 e5                	mov    %esp,%ebp
f011bf26:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011bf29:	83 ec 04             	sub    $0x4,%esp
f011bf2c:	68 f4 ef 12 f0       	push   $0xf012eff4
f011bf31:	68 cb 08 00 00       	push   $0x8cb
f011bf36:	68 33 ba 12 f0       	push   $0xf012ba33
f011bf3b:	e8 f9 43 fe ff       	call   f0100339 <_panic>

f011bf40 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011bf40:	55                   	push   %ebp
f011bf41:	89 e5                	mov    %esp,%ebp
f011bf43:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011bf46:	83 ec 04             	sub    $0x4,%esp
f011bf49:	68 f4 ef 12 f0       	push   $0xf012eff4
f011bf4e:	68 d0 08 00 00       	push   $0x8d0
f011bf53:	68 33 ba 12 f0       	push   $0xf012ba33
f011bf58:	e8 dc 43 fe ff       	call   f0100339 <_panic>

f011bf5d <test_kfree>:
}

int test_kfree()
{
f011bf5d:	55                   	push   %ebp
f011bf5e:	89 e5                	mov    %esp,%ebp
f011bf60:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011bf63:	83 ec 04             	sub    $0x4,%esp
f011bf66:	68 f4 ef 12 f0       	push   $0xf012eff4
f011bf6b:	68 d5 08 00 00       	push   $0x8d5
f011bf70:	68 33 ba 12 f0       	push   $0xf012ba33
f011bf75:	e8 bf 43 fe ff       	call   f0100339 <_panic>

f011bf7a <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011bf7a:	55                   	push   %ebp
f011bf7b:	89 e5                	mov    %esp,%ebp
f011bf7d:	57                   	push   %edi
f011bf7e:	56                   	push   %esi
f011bf7f:	53                   	push   %ebx
f011bf80:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011bf86:	a0 dc bd 17 f0       	mov    0xf017bddc,%al
f011bf8b:	84 c0                	test   %al,%al
f011bf8d:	74 56                	je     f011bfe5 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011bf8f:	c6 05 dc bd 17 f0 00 	movb   $0x0,0xf017bddc
		initFreeFrames = sys_calculate_free_frames() ;
f011bf96:	e8 61 17 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011bf9b:	a3 68 f3 60 f0       	mov    %eax,0xf060f368
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011bfa0:	e8 c1 88 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bfa5:	a3 64 f3 60 f0       	mov    %eax,0xf060f364
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011bfaa:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011bfb0:	bb 59 f1 12 f0       	mov    $0xf012f159,%ebx
f011bfb5:	ba 11 00 00 00       	mov    $0x11,%edx
f011bfba:	89 c7                	mov    %eax,%edi
f011bfbc:	89 de                	mov    %ebx,%esi
f011bfbe:	89 d1                	mov    %edx,%ecx
f011bfc0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011bfc2:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011bfc8:	b9 53 00 00 00       	mov    $0x53,%ecx
f011bfcd:	b0 00                	mov    $0x0,%al
f011bfcf:	89 d7                	mov    %edx,%edi
f011bfd1:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011bfd3:	83 ec 0c             	sub    $0xc,%esp
f011bfd6:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011bfdc:	50                   	push   %eax
f011bfdd:	e8 19 5f fe ff       	call   f0101efb <execute_command>
f011bfe2:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011bfe5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011bfec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011bff3:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f011bff8:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011bffb:	eb 2b                	jmp    f011c028 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011bffd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c000:	83 c0 20             	add    $0x20,%eax
f011c003:	83 ec 08             	sub    $0x8,%esp
f011c006:	68 04 f0 12 f0       	push   $0xf012f004
f011c00b:	50                   	push   %eax
f011c00c:	e8 ea 28 00 00       	call   f011e8fb <strcmp>
f011c011:	83 c4 10             	add    $0x10,%esp
f011c014:	85 c0                	test   %eax,%eax
f011c016:	75 08                	jne    f011c020 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011c018:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c01b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011c01e:	eb 2f                	jmp    f011c04f <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011c020:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f011c025:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011c028:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c02c:	74 08                	je     f011c036 <test_three_creation_functions+0xbc>
f011c02e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c031:	8b 40 08             	mov    0x8(%eax),%eax
f011c034:	eb 05                	jmp    f011c03b <test_three_creation_functions+0xc1>
f011c036:	b8 00 00 00 00       	mov    $0x0,%eax
f011c03b:	a3 28 c5 5e f0       	mov    %eax,0xf05ec528
f011c040:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f011c045:	85 c0                	test   %eax,%eax
f011c047:	75 b4                	jne    f011bffd <test_three_creation_functions+0x83>
f011c049:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c04d:	75 ae                	jne    f011bffd <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011c04f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c052:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f011c058:	85 c0                	test   %eax,%eax
f011c05a:	74 17                	je     f011c073 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011c05c:	83 ec 04             	sub    $0x4,%esp
f011c05f:	68 0c f0 12 f0       	push   $0xf012f00c
f011c064:	68 f6 08 00 00       	push   $0x8f6
f011c069:	68 33 ba 12 f0       	push   $0xf012ba33
f011c06e:	e8 c6 42 fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011c073:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c076:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011c07c:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011c07f:	e8 78 16 ff ff       	call   f010d6fc <sys_calculate_free_frames>
f011c084:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011c087:	e8 da 87 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011c08c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011c08f:	a1 64 f3 60 f0       	mov    0xf060f364,%eax
f011c094:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011c097:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011c09a:	74 17                	je     f011c0b3 <test_three_creation_functions+0x139>
f011c09c:	83 ec 04             	sub    $0x4,%esp
f011c09f:	68 4c ba 12 f0       	push   $0xf012ba4c
f011c0a4:	68 00 09 00 00       	push   $0x900
f011c0a9:	68 33 ba 12 f0       	push   $0xf012ba33
f011c0ae:	e8 86 42 fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011c0b3:	a1 68 f3 60 f0       	mov    0xf060f368,%eax
f011c0b8:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011c0bb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c0be:	83 c2 15             	add    $0x15,%edx
f011c0c1:	39 d0                	cmp    %edx,%eax
f011c0c3:	74 17                	je     f011c0dc <test_three_creation_functions+0x162>
f011c0c5:	83 ec 04             	sub    $0x4,%esp
f011c0c8:	68 5c f0 12 f0       	push   $0xf012f05c
f011c0cd:	68 02 09 00 00       	push   $0x902
f011c0d2:	68 33 ba 12 f0       	push   $0xf012ba33
f011c0d7:	e8 5d 42 fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011c0dc:	83 ec 0c             	sub    $0xc,%esp
f011c0df:	68 00 10 00 00       	push   $0x1000
f011c0e4:	e8 23 cc fe ff       	call   f0108d0c <kmalloc>
f011c0e9:	83 c4 10             	add    $0x10,%esp
f011c0ec:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011c0ef:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c0f2:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011c0f7:	74 17                	je     f011c110 <test_three_creation_functions+0x196>
f011c0f9:	83 ec 04             	sub    $0x4,%esp
f011c0fc:	68 9c f0 12 f0       	push   $0xf012f09c
f011c101:	68 06 09 00 00       	push   $0x906
f011c106:	68 33 ba 12 f0       	push   $0xf012ba33
f011c10b:	e8 29 42 fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011c110:	83 ec 0c             	sub    $0xc,%esp
f011c113:	68 0c f1 12 f0       	push   $0xf012f10c
f011c118:	e8 6e 4e fe ff       	call   f0100f8b <cprintf>
f011c11d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c120:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011c125:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c128:	5b                   	pop    %ebx
f011c129:	5e                   	pop    %esi
f011c12a:	5f                   	pop    %edi
f011c12b:	5d                   	pop    %ebp
f011c12c:	c3                   	ret    

f011c12d <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011c12d:	55                   	push   %ebp
f011c12e:	89 e5                	mov    %esp,%ebp
f011c130:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c133:	83 ec 04             	sub    $0x4,%esp
f011c136:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c13b:	68 14 09 00 00       	push   $0x914
f011c140:	68 33 ba 12 f0       	push   $0xf012ba33
f011c145:	e8 ef 41 fe ff       	call   f0100339 <_panic>

f011c14a <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011c14a:	55                   	push   %ebp
f011c14b:	89 e5                	mov    %esp,%ebp
f011c14d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c150:	83 ec 04             	sub    $0x4,%esp
f011c153:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c158:	68 1c 09 00 00       	push   $0x91c
f011c15d:	68 33 ba 12 f0       	push   $0xf012ba33
f011c162:	e8 d2 41 fe ff       	call   f0100339 <_panic>

f011c167 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011c167:	55                   	push   %ebp
f011c168:	89 e5                	mov    %esp,%ebp
f011c16a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c16d:	83 ec 04             	sub    $0x4,%esp
f011c170:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c175:	68 23 09 00 00       	push   $0x923
f011c17a:	68 33 ba 12 f0       	push   $0xf012ba33
f011c17f:	e8 b5 41 fe ff       	call   f0100339 <_panic>

f011c184 <test_kfreelast>:

}


int test_kfreelast()
{
f011c184:	55                   	push   %ebp
f011c185:	89 e5                	mov    %esp,%ebp
f011c187:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c18a:	83 ec 04             	sub    $0x4,%esp
f011c18d:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c192:	68 2a 09 00 00       	push   $0x92a
f011c197:	68 33 ba 12 f0       	push   $0xf012ba33
f011c19c:	e8 98 41 fe ff       	call   f0100339 <_panic>

f011c1a1 <test_krealloc>:

}

int test_krealloc() {
f011c1a1:	55                   	push   %ebp
f011c1a2:	89 e5                	mov    %esp,%ebp
f011c1a4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c1a7:	83 ec 04             	sub    $0x4,%esp
f011c1aa:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c1af:	68 2f 09 00 00       	push   $0x92f
f011c1b4:	68 33 ba 12 f0       	push   $0xf012ba33
f011c1b9:	e8 7b 41 fe ff       	call   f0100339 <_panic>

f011c1be <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011c1be:	55                   	push   %ebp
f011c1bf:	89 e5                	mov    %esp,%ebp
f011c1c1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c1c4:	83 ec 04             	sub    $0x4,%esp
f011c1c7:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c1cc:	68 34 09 00 00       	push   $0x934
f011c1d1:	68 33 ba 12 f0       	push   $0xf012ba33
f011c1d6:	e8 5e 41 fe ff       	call   f0100339 <_panic>

f011c1db <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011c1db:	55                   	push   %ebp
f011c1dc:	89 e5                	mov    %esp,%ebp
f011c1de:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c1e1:	83 ec 04             	sub    $0x4,%esp
f011c1e4:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c1e9:	68 3a 09 00 00       	push   $0x93a
f011c1ee:	68 33 ba 12 f0       	push   $0xf012ba33
f011c1f3:	e8 41 41 fe ff       	call   f0100339 <_panic>

f011c1f8 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011c1f8:	55                   	push   %ebp
f011c1f9:	89 e5                	mov    %esp,%ebp
f011c1fb:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c1fe:	83 ec 04             	sub    $0x4,%esp
f011c201:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c206:	68 3f 09 00 00       	push   $0x93f
f011c20b:	68 33 ba 12 f0       	push   $0xf012ba33
f011c210:	e8 24 41 fe ff       	call   f0100339 <_panic>

f011c215 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011c215:	55                   	push   %ebp
f011c216:	89 e5                	mov    %esp,%ebp
f011c218:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c21b:	83 ec 04             	sub    $0x4,%esp
f011c21e:	68 f4 ef 12 f0       	push   $0xf012eff4
f011c223:	68 45 09 00 00       	push   $0x945
f011c228:	68 33 ba 12 f0       	push   $0xf012ba33
f011c22d:	e8 07 41 fe ff       	call   f0100339 <_panic>

f011c232 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011c232:	55                   	push   %ebp
f011c233:	89 e5                	mov    %esp,%ebp
f011c235:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c238:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c23f:	e9 84 00 00 00       	jmp    f011c2c8 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011c244:	83 ec 08             	sub    $0x8,%esp
f011c247:	ff 75 f4             	pushl  -0xc(%ebp)
f011c24a:	68 c0 f1 12 f0       	push   $0xf012f1c0
f011c24f:	e8 37 4d fe ff       	call   f0100f8b <cprintf>
f011c254:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011c257:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c25e:	eb 4c                	jmp    f011c2ac <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011c260:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c263:	89 d0                	mov    %edx,%eax
f011c265:	c1 e0 02             	shl    $0x2,%eax
f011c268:	01 d0                	add    %edx,%eax
f011c26a:	c1 e0 03             	shl    $0x3,%eax
f011c26d:	89 c2                	mov    %eax,%edx
f011c26f:	8b 45 08             	mov    0x8(%ebp),%eax
f011c272:	01 c2                	add    %eax,%edx
f011c274:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c277:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011c27a:	85 c0                	test   %eax,%eax
f011c27c:	74 36                	je     f011c2b4 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011c27e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c281:	89 d0                	mov    %edx,%eax
f011c283:	c1 e0 02             	shl    $0x2,%eax
f011c286:	01 d0                	add    %edx,%eax
f011c288:	c1 e0 03             	shl    $0x3,%eax
f011c28b:	89 c2                	mov    %eax,%edx
f011c28d:	8b 45 08             	mov    0x8(%ebp),%eax
f011c290:	01 c2                	add    %eax,%edx
f011c292:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c295:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011c298:	83 ec 08             	sub    $0x8,%esp
f011c29b:	50                   	push   %eax
f011c29c:	68 c8 f1 12 f0       	push   $0xf012f1c8
f011c2a1:	e8 e5 4c fe ff       	call   f0100f8b <cprintf>
f011c2a6:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011c2a9:	ff 45 f0             	incl   -0x10(%ebp)
f011c2ac:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011c2b0:	7e ae                	jle    f011c260 <print_order+0x2e>
f011c2b2:	eb 01                	jmp    f011c2b5 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011c2b4:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011c2b5:	83 ec 0c             	sub    $0xc,%esp
f011c2b8:	68 cd f1 12 f0       	push   $0xf012f1cd
f011c2bd:	e8 c9 4c fe ff       	call   f0100f8b <cprintf>
f011c2c2:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c2c5:	ff 45 f4             	incl   -0xc(%ebp)
f011c2c8:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011c2cc:	0f 8e 72 ff ff ff    	jle    f011c244 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011c2d2:	90                   	nop
f011c2d3:	c9                   	leave  
f011c2d4:	c3                   	ret    

f011c2d5 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011c2d5:	55                   	push   %ebp
f011c2d6:	89 e5                	mov    %esp,%ebp
f011c2d8:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011c2db:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011c2e2:	83 ec 0c             	sub    $0xc,%esp
f011c2e5:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011c2ea:	e8 73 25 ff ff       	call   f010e862 <acquire_spinlock>
f011c2ef:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011c2f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011c2f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c300:	8b 55 0c             	mov    0xc(%ebp),%edx
f011c303:	8b 45 10             	mov    0x10(%ebp),%eax
f011c306:	01 d0                	add    %edx,%eax
f011c308:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011c30b:	a1 2c c5 5e f0       	mov    0xf05ec52c,%eax
f011c310:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011c313:	a1 24 c5 5e f0       	mov    0xf05ec524,%eax
f011c318:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011c31b:	ff 75 e8             	pushl  -0x18(%ebp)
f011c31e:	ff 75 0c             	pushl  0xc(%ebp)
f011c321:	ff 75 08             	pushl  0x8(%ebp)
f011c324:	68 d0 f1 12 f0       	push   $0xf012f1d0
f011c329:	e8 5d 4c fe ff       	call   f0100f8b <cprintf>
f011c32e:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c331:	eb 34                	jmp    f011c367 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011c333:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c336:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011c339:	7d 05                	jge    f011c340 <find_in_range+0x6b>
			{
				i++;
f011c33b:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011c33e:	eb 1e                	jmp    f011c35e <find_in_range+0x89>
			}
			if (i >= end)
f011c340:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c343:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011c346:	7d 29                	jge    f011c371 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011c348:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c34b:	8b 40 10             	mov    0x10(%eax),%eax
f011c34e:	3b 45 08             	cmp    0x8(%ebp),%eax
f011c351:	75 08                	jne    f011c35b <find_in_range+0x86>
			{
				ret = i;
f011c353:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c356:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011c359:	eb 17                	jmp    f011c372 <find_in_range+0x9d>
			}
			i++;
f011c35b:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c35e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c361:	8b 40 0c             	mov    0xc(%eax),%eax
f011c364:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011c367:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c36a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011c36d:	7c c4                	jl     f011c333 <find_in_range+0x5e>
f011c36f:	eb 01                	jmp    f011c372 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011c371:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011c372:	83 ec 0c             	sub    $0xc,%esp
f011c375:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011c37a:	e8 6a 25 ff ff       	call   f010e8e9 <release_spinlock>
f011c37f:	83 c4 10             	add    $0x10,%esp
	return ret;
f011c382:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011c385:	c9                   	leave  
f011c386:	c3                   	ret    

f011c387 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011c387:	55                   	push   %ebp
f011c388:	89 e5                	mov    %esp,%ebp
f011c38a:	57                   	push   %edi
f011c38b:	56                   	push   %esi
f011c38c:	53                   	push   %ebx
f011c38d:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011c390:	a0 dd bd 17 f0       	mov    0xf017bddd,%al
f011c395:	84 c0                	test   %al,%al
f011c397:	0f 84 9b 01 00 00    	je     f011c538 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011c39d:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011c3a4:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011c3a7:	bb 48 f3 12 f0       	mov    $0xf012f348,%ebx
f011c3ac:	ba 05 00 00 00       	mov    $0x5,%edx
f011c3b1:	89 c7                	mov    %eax,%edi
f011c3b3:	89 de                	mov    %ebx,%esi
f011c3b5:	89 d1                	mov    %edx,%ecx
f011c3b7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011c3b9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011c3c0:	e9 44 01 00 00       	jmp    f011c509 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011c3c5:	6a 00                	push   $0x0
f011c3c7:	6a 00                	push   $0x0
f011c3c9:	68 f4 01 00 00       	push   $0x1f4
f011c3ce:	68 01 f2 12 f0       	push   $0xf012f201
f011c3d3:	e8 8c da fe ff       	call   f0109e64 <env_create>
f011c3d8:	83 c4 10             	add    $0x10,%esp
f011c3db:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011c3de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c3e1:	b9 05 00 00 00       	mov    $0x5,%ecx
f011c3e6:	99                   	cltd   
f011c3e7:	f7 f9                	idiv   %ecx
f011c3e9:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011c3ec:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c3ef:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c3f3:	83 ec 08             	sub    $0x8,%esp
f011c3f6:	50                   	push   %eax
f011c3f7:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c3fa:	e8 25 a2 fe ff       	call   f0106624 <env_set_nice>
f011c3ff:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011c402:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011c406:	75 14                	jne    f011c41c <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011c408:	83 ec 04             	sub    $0x4,%esp
f011c40b:	68 09 f2 12 f0       	push   $0xf012f209
f011c410:	6a 53                	push   $0x53
f011c412:	68 22 f2 12 f0       	push   $0xf012f222
f011c417:	e8 1d 3f fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011c41c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c41f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c425:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011c42a:	74 14                	je     f011c440 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011c42c:	83 ec 04             	sub    $0x4,%esp
f011c42f:	68 40 f2 12 f0       	push   $0xf012f240
f011c434:	6a 55                	push   $0x55
f011c436:	68 22 f2 12 f0       	push   $0xf012f222
f011c43b:	e8 f9 3e fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011c440:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c443:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c447:	83 c0 0a             	add    $0xa,%eax
f011c44a:	83 f8 14             	cmp    $0x14,%eax
f011c44d:	0f 87 a5 00 00 00    	ja     f011c4f8 <test_bsd_nice_0+0x171>
f011c453:	8b 04 85 5c f3 12 f0 	mov    -0xfed0ca4(,%eax,4),%eax
f011c45a:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011c45c:	a1 3c c2 5e f0       	mov    0xf05ec23c,%eax
f011c461:	8d 50 01             	lea    0x1(%eax),%edx
f011c464:	89 15 3c c2 5e f0    	mov    %edx,0xf05ec23c
f011c46a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c46d:	8b 52 10             	mov    0x10(%edx),%edx
f011c470:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c477:	eb 7f                	jmp    f011c4f8 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011c479:	a1 40 c2 5e f0       	mov    0xf05ec240,%eax
f011c47e:	8d 50 01             	lea    0x1(%eax),%edx
f011c481:	89 15 40 c2 5e f0    	mov    %edx,0xf05ec240
f011c487:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c48a:	8b 52 10             	mov    0x10(%edx),%edx
f011c48d:	83 c0 0a             	add    $0xa,%eax
f011c490:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c497:	eb 5f                	jmp    f011c4f8 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011c499:	a1 44 c2 5e f0       	mov    0xf05ec244,%eax
f011c49e:	8d 50 01             	lea    0x1(%eax),%edx
f011c4a1:	89 15 44 c2 5e f0    	mov    %edx,0xf05ec244
f011c4a7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c4aa:	8b 52 10             	mov    0x10(%edx),%edx
f011c4ad:	83 c0 14             	add    $0x14,%eax
f011c4b0:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c4b7:	eb 3f                	jmp    f011c4f8 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011c4b9:	a1 48 c2 5e f0       	mov    0xf05ec248,%eax
f011c4be:	8d 50 01             	lea    0x1(%eax),%edx
f011c4c1:	89 15 48 c2 5e f0    	mov    %edx,0xf05ec248
f011c4c7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c4ca:	8b 52 10             	mov    0x10(%edx),%edx
f011c4cd:	83 c0 1e             	add    $0x1e,%eax
f011c4d0:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c4d7:	eb 1f                	jmp    f011c4f8 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011c4d9:	a1 4c c2 5e f0       	mov    0xf05ec24c,%eax
f011c4de:	8d 50 01             	lea    0x1(%eax),%edx
f011c4e1:	89 15 4c c2 5e f0    	mov    %edx,0xf05ec24c
f011c4e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c4ea:	8b 52 10             	mov    0x10(%edx),%edx
f011c4ed:	83 c0 28             	add    $0x28,%eax
f011c4f0:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c4f7:	90                   	nop
			}
			sched_new_env(env);
f011c4f8:	83 ec 0c             	sub    $0xc,%esp
f011c4fb:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c4fe:	e8 b7 91 fe ff       	call   f01056ba <sched_new_env>
f011c503:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011c506:	ff 45 e4             	incl   -0x1c(%ebp)
f011c509:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011c50d:	0f 8e b2 fe ff ff    	jle    f011c3c5 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011c513:	83 ec 0c             	sub    $0xc,%esp
f011c516:	68 70 f2 12 f0       	push   $0xf012f270
f011c51b:	e8 6b 4a fe ff       	call   f0100f8b <cprintf>
f011c520:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011c523:	83 ec 0c             	sub    $0xc,%esp
f011c526:	68 bf f2 12 f0       	push   $0xf012f2bf
f011c52b:	e8 cb 59 fe ff       	call   f0101efb <execute_command>
f011c530:	83 c4 10             	add    $0x10,%esp
f011c533:	e9 c0 00 00 00       	jmp    f011c5f8 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011c538:	83 ec 0c             	sub    $0xc,%esp
f011c53b:	68 c6 f2 12 f0       	push   $0xf012f2c6
f011c540:	e8 46 4a fe ff       	call   f0100f8b <cprintf>
f011c545:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011c548:	e8 a5 98 fe ff       	call   f0105df2 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011c54d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c554:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011c55b:	e9 87 00 00 00       	jmp    f011c5e7 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011c560:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011c567:	eb 52                	jmp    f011c5bb <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011c569:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c56c:	8b 14 85 3c c2 5e f0 	mov    -0xfa13dc4(,%eax,4),%edx
f011c573:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011c576:	89 c8                	mov    %ecx,%eax
f011c578:	c1 e0 02             	shl    $0x2,%eax
f011c57b:	01 c8                	add    %ecx,%eax
f011c57d:	01 c0                	add    %eax,%eax
f011c57f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011c582:	01 c8                	add    %ecx,%eax
f011c584:	8b 04 85 80 f3 60 f0 	mov    -0xf9f0c80(,%eax,4),%eax
f011c58b:	83 ec 04             	sub    $0x4,%esp
f011c58e:	52                   	push   %edx
f011c58f:	ff 75 e0             	pushl  -0x20(%ebp)
f011c592:	50                   	push   %eax
f011c593:	e8 3d fd ff ff       	call   f011c2d5 <find_in_range>
f011c598:	83 c4 10             	add    $0x10,%esp
f011c59b:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011c59e:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011c5a2:	75 14                	jne    f011c5b8 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011c5a4:	83 ec 04             	sub    $0x4,%esp
f011c5a7:	68 d8 f2 12 f0       	push   $0xf012f2d8
f011c5ac:	6a 7b                	push   $0x7b
f011c5ae:	68 22 f2 12 f0       	push   $0xf012f222
f011c5b3:	e8 81 3d fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011c5b8:	ff 45 d8             	incl   -0x28(%ebp)
f011c5bb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c5be:	89 d0                	mov    %edx,%eax
f011c5c0:	c1 e0 02             	shl    $0x2,%eax
f011c5c3:	01 d0                	add    %edx,%eax
f011c5c5:	01 c0                	add    %eax,%eax
f011c5c7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c5ca:	01 d0                	add    %edx,%eax
f011c5cc:	8b 04 85 80 f3 60 f0 	mov    -0xf9f0c80(,%eax,4),%eax
f011c5d3:	85 c0                	test   %eax,%eax
f011c5d5:	75 92                	jne    f011c569 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011c5d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c5da:	8b 04 85 3c c2 5e f0 	mov    -0xfa13dc4(,%eax,4),%eax
f011c5e1:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c5e4:	ff 45 dc             	incl   -0x24(%ebp)
f011c5e7:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011c5eb:	0f 8e 6f ff ff ff    	jle    f011c560 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011c5f1:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011c5f8:	83 ec 0c             	sub    $0xc,%esp
f011c5fb:	68 0c f3 12 f0       	push   $0xf012f30c
f011c600:	e8 86 49 fe ff       	call   f0100f8b <cprintf>
f011c605:	83 c4 10             	add    $0x10,%esp
}
f011c608:	90                   	nop
f011c609:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c60c:	5b                   	pop    %ebx
f011c60d:	5e                   	pop    %esi
f011c60e:	5f                   	pop    %edi
f011c60f:	5d                   	pop    %ebp
f011c610:	c3                   	ret    

f011c611 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011c611:	55                   	push   %ebp
f011c612:	89 e5                	mov    %esp,%ebp
f011c614:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011c617:	a0 dd bd 17 f0       	mov    0xf017bddd,%al
f011c61c:	84 c0                	test   %al,%al
f011c61e:	0f 84 50 01 00 00    	je     f011c774 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011c624:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011c62b:	6a 00                	push   $0x0
f011c62d:	6a 00                	push   $0x0
f011c62f:	68 f4 01 00 00       	push   $0x1f4
f011c634:	68 01 f2 12 f0       	push   $0xf012f201
f011c639:	e8 26 d8 fe ff       	call   f0109e64 <env_create>
f011c63e:	83 c4 10             	add    $0x10,%esp
f011c641:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011c644:	6a 00                	push   $0x0
f011c646:	6a 00                	push   $0x0
f011c648:	68 f4 01 00 00       	push   $0x1f4
f011c64d:	68 b0 f3 12 f0       	push   $0xf012f3b0
f011c652:	e8 0d d8 fe ff       	call   f0109e64 <env_create>
f011c657:	83 c4 10             	add    $0x10,%esp
f011c65a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011c65d:	6a 00                	push   $0x0
f011c65f:	6a 00                	push   $0x0
f011c661:	68 f4 01 00 00       	push   $0x1f4
f011c666:	68 bd f3 12 f0       	push   $0xf012f3bd
f011c66b:	e8 f4 d7 fe ff       	call   f0109e64 <env_create>
f011c670:	83 c4 10             	add    $0x10,%esp
f011c673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011c676:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c67a:	74 0c                	je     f011c688 <test_bsd_nice_1+0x77>
f011c67c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011c680:	74 06                	je     f011c688 <test_bsd_nice_1+0x77>
f011c682:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011c686:	75 17                	jne    f011c69f <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011c688:	83 ec 04             	sub    $0x4,%esp
f011c68b:	68 09 f2 12 f0       	push   $0xf012f209
f011c690:	68 8e 00 00 00       	push   $0x8e
f011c695:	68 22 f2 12 f0       	push   $0xf012f222
f011c69a:	e8 9a 3c fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011c69f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c6a2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c6a8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011c6ad:	75 20                	jne    f011c6cf <test_bsd_nice_1+0xbe>
f011c6af:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011c6b2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c6b8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011c6bd:	75 10                	jne    f011c6cf <test_bsd_nice_1+0xbe>
f011c6bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c6c2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c6c8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011c6cd:	74 35                	je     f011c704 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011c6cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c6d2:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f011c6d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011c6db:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f011c6e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c6e4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c6ea:	83 ec 08             	sub    $0x8,%esp
f011c6ed:	51                   	push   %ecx
f011c6ee:	52                   	push   %edx
f011c6ef:	50                   	push   %eax
f011c6f0:	68 cc f3 12 f0       	push   $0xf012f3cc
f011c6f5:	68 90 00 00 00       	push   $0x90
f011c6fa:	68 22 f2 12 f0       	push   $0xf012f222
f011c6ff:	e8 35 3c fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011c704:	83 ec 0c             	sub    $0xc,%esp
f011c707:	ff 75 ec             	pushl  -0x14(%ebp)
f011c70a:	e8 ab 8f fe ff       	call   f01056ba <sched_new_env>
f011c70f:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011c712:	83 ec 0c             	sub    $0xc,%esp
f011c715:	ff 75 e8             	pushl  -0x18(%ebp)
f011c718:	e8 9d 8f fe ff       	call   f01056ba <sched_new_env>
f011c71d:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011c720:	83 ec 0c             	sub    $0xc,%esp
f011c723:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c726:	e8 8f 8f fe ff       	call   f01056ba <sched_new_env>
f011c72b:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011c72e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c731:	8b 40 10             	mov    0x10(%eax),%eax
f011c734:	a3 80 f3 60 f0       	mov    %eax,0xf060f380
		prog_orders[1][0] = fibEnv->env_id;
f011c739:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c73c:	8b 40 10             	mov    0x10(%eax),%eax
f011c73f:	a3 a8 f3 60 f0       	mov    %eax,0xf060f3a8
		prog_orders[2][0] = fibposnEnv->env_id;
f011c744:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011c747:	8b 40 10             	mov    0x10(%eax),%eax
f011c74a:	a3 d0 f3 60 f0       	mov    %eax,0xf060f3d0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011c74f:	83 ec 0c             	sub    $0xc,%esp
f011c752:	68 70 f2 12 f0       	push   $0xf012f270
f011c757:	e8 2f 48 fe ff       	call   f0100f8b <cprintf>
f011c75c:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011c75f:	83 ec 0c             	sub    $0xc,%esp
f011c762:	68 bf f2 12 f0       	push   $0xf012f2bf
f011c767:	e8 8f 57 fe ff       	call   f0101efb <execute_command>
f011c76c:	83 c4 10             	add    $0x10,%esp
f011c76f:	e9 9e 00 00 00       	jmp    f011c812 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011c774:	83 ec 0c             	sub    $0xc,%esp
f011c777:	68 c6 f2 12 f0       	push   $0xf012f2c6
f011c77c:	e8 0a 48 fe ff       	call   f0100f8b <cprintf>
f011c781:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011c784:	e8 69 96 fe ff       	call   f0105df2 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011c789:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011c790:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011c797:	83 ec 0c             	sub    $0xc,%esp
f011c79a:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011c79f:	e8 be 20 ff ff       	call   f010e862 <acquire_spinlock>
f011c7a4:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011c7a7:	a1 2c c5 5e f0       	mov    0xf05ec52c,%eax
f011c7ac:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011c7af:	a1 24 c5 5e f0       	mov    0xf05ec524,%eax
f011c7b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c7b7:	eb 41                	jmp    f011c7fa <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011c7b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c7bc:	89 d0                	mov    %edx,%eax
f011c7be:	c1 e0 02             	shl    $0x2,%eax
f011c7c1:	01 d0                	add    %edx,%eax
f011c7c3:	c1 e0 03             	shl    $0x3,%eax
f011c7c6:	05 80 f3 60 f0       	add    $0xf060f380,%eax
f011c7cb:	8b 10                	mov    (%eax),%edx
f011c7cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c7d0:	8b 40 10             	mov    0x10(%eax),%eax
f011c7d3:	39 c2                	cmp    %eax,%edx
f011c7d5:	74 17                	je     f011c7ee <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011c7d7:	83 ec 04             	sub    $0x4,%esp
f011c7da:	68 d8 f2 12 f0       	push   $0xf012f2d8
f011c7df:	68 ab 00 00 00       	push   $0xab
f011c7e4:	68 22 f2 12 f0       	push   $0xf012f222
f011c7e9:	e8 4b 3b fe ff       	call   f0100339 <_panic>
				i++;
f011c7ee:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c7f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c7f4:	8b 40 0c             	mov    0xc(%eax),%eax
f011c7f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011c7fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c7fd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011c800:	7c b7                	jl     f011c7b9 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011c802:	83 ec 0c             	sub    $0xc,%esp
f011c805:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011c80a:	e8 da 20 ff ff       	call   f010e8e9 <release_spinlock>
f011c80f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011c812:	83 ec 0c             	sub    $0xc,%esp
f011c815:	68 38 f4 12 f0       	push   $0xf012f438
f011c81a:	e8 6c 47 fe ff       	call   f0100f8b <cprintf>
f011c81f:	83 c4 10             	add    $0x10,%esp
}
f011c822:	90                   	nop
f011c823:	c9                   	leave  
f011c824:	c3                   	ret    

f011c825 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011c825:	55                   	push   %ebp
f011c826:	89 e5                	mov    %esp,%ebp
f011c828:	57                   	push   %edi
f011c829:	56                   	push   %esi
f011c82a:	53                   	push   %ebx
f011c82b:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011c82e:	a0 dd bd 17 f0       	mov    0xf017bddd,%al
f011c833:	84 c0                	test   %al,%al
f011c835:	0f 84 ae 01 00 00    	je     f011c9e9 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011c83b:	83 ec 0c             	sub    $0xc,%esp
f011c83e:	6a 01                	push   $0x1
f011c840:	e8 fe 10 00 00       	call   f011d943 <chksch>
f011c845:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011c848:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011c84f:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011c852:	bb bc f4 12 f0       	mov    $0xf012f4bc,%ebx
f011c857:	ba 05 00 00 00       	mov    $0x5,%edx
f011c85c:	89 c7                	mov    %eax,%edi
f011c85e:	89 de                	mov    %ebx,%esi
f011c860:	89 d1                	mov    %edx,%ecx
f011c862:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011c864:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011c86b:	e9 4a 01 00 00       	jmp    f011c9ba <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011c870:	6a 00                	push   $0x0
f011c872:	6a 00                	push   $0x0
f011c874:	68 10 27 00 00       	push   $0x2710
f011c879:	68 74 f4 12 f0       	push   $0xf012f474
f011c87e:	e8 e1 d5 fe ff       	call   f0109e64 <env_create>
f011c883:	83 c4 10             	add    $0x10,%esp
f011c886:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011c889:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c88c:	b9 05 00 00 00       	mov    $0x5,%ecx
f011c891:	99                   	cltd   
f011c892:	f7 f9                	idiv   %ecx
f011c894:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011c897:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c89a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c89e:	83 ec 08             	sub    $0x8,%esp
f011c8a1:	50                   	push   %eax
f011c8a2:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c8a5:	e8 7a 9d fe ff       	call   f0106624 <env_set_nice>
f011c8aa:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011c8ad:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011c8b1:	75 17                	jne    f011c8ca <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011c8b3:	83 ec 04             	sub    $0x4,%esp
f011c8b6:	68 09 f2 12 f0       	push   $0xf012f209
f011c8bb:	68 c1 00 00 00       	push   $0xc1
f011c8c0:	68 22 f2 12 f0       	push   $0xf012f222
f011c8c5:	e8 6f 3a fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011c8ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c8cd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c8d3:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011c8d8:	74 17                	je     f011c8f1 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011c8da:	83 ec 04             	sub    $0x4,%esp
f011c8dd:	68 40 f2 12 f0       	push   $0xf012f240
f011c8e2:	68 c3 00 00 00       	push   $0xc3
f011c8e7:	68 22 f2 12 f0       	push   $0xf012f222
f011c8ec:	e8 48 3a fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011c8f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8f4:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c8f8:	83 c0 0f             	add    $0xf,%eax
f011c8fb:	83 f8 1e             	cmp    $0x1e,%eax
f011c8fe:	0f 87 a5 00 00 00    	ja     f011c9a9 <test_bsd_nice_2+0x184>
f011c904:	8b 04 85 d0 f4 12 f0 	mov    -0xfed0b30(,%eax,4),%eax
f011c90b:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011c90d:	a1 3c c2 5e f0       	mov    0xf05ec23c,%eax
f011c912:	8d 50 01             	lea    0x1(%eax),%edx
f011c915:	89 15 3c c2 5e f0    	mov    %edx,0xf05ec23c
f011c91b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c91e:	8b 52 10             	mov    0x10(%edx),%edx
f011c921:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c928:	eb 7f                	jmp    f011c9a9 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011c92a:	a1 40 c2 5e f0       	mov    0xf05ec240,%eax
f011c92f:	8d 50 01             	lea    0x1(%eax),%edx
f011c932:	89 15 40 c2 5e f0    	mov    %edx,0xf05ec240
f011c938:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c93b:	8b 52 10             	mov    0x10(%edx),%edx
f011c93e:	83 c0 0a             	add    $0xa,%eax
f011c941:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c948:	eb 5f                	jmp    f011c9a9 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011c94a:	a1 44 c2 5e f0       	mov    0xf05ec244,%eax
f011c94f:	8d 50 01             	lea    0x1(%eax),%edx
f011c952:	89 15 44 c2 5e f0    	mov    %edx,0xf05ec244
f011c958:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c95b:	8b 52 10             	mov    0x10(%edx),%edx
f011c95e:	83 c0 14             	add    $0x14,%eax
f011c961:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c968:	eb 3f                	jmp    f011c9a9 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011c96a:	a1 48 c2 5e f0       	mov    0xf05ec248,%eax
f011c96f:	8d 50 01             	lea    0x1(%eax),%edx
f011c972:	89 15 48 c2 5e f0    	mov    %edx,0xf05ec248
f011c978:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c97b:	8b 52 10             	mov    0x10(%edx),%edx
f011c97e:	83 c0 1e             	add    $0x1e,%eax
f011c981:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c988:	eb 1f                	jmp    f011c9a9 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011c98a:	a1 4c c2 5e f0       	mov    0xf05ec24c,%eax
f011c98f:	8d 50 01             	lea    0x1(%eax),%edx
f011c992:	89 15 4c c2 5e f0    	mov    %edx,0xf05ec24c
f011c998:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c99b:	8b 52 10             	mov    0x10(%edx),%edx
f011c99e:	83 c0 28             	add    $0x28,%eax
f011c9a1:	89 14 85 80 f3 60 f0 	mov    %edx,-0xf9f0c80(,%eax,4)
				break;
f011c9a8:	90                   	nop
			}
			sched_new_env(env);
f011c9a9:	83 ec 0c             	sub    $0xc,%esp
f011c9ac:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c9af:	e8 06 8d fe ff       	call   f01056ba <sched_new_env>
f011c9b4:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011c9b7:	ff 45 e4             	incl   -0x1c(%ebp)
f011c9ba:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011c9be:	0f 8e ac fe ff ff    	jle    f011c870 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011c9c4:	83 ec 0c             	sub    $0xc,%esp
f011c9c7:	68 70 f2 12 f0       	push   $0xf012f270
f011c9cc:	e8 ba 45 fe ff       	call   f0100f8b <cprintf>
f011c9d1:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011c9d4:	83 ec 0c             	sub    $0xc,%esp
f011c9d7:	68 bf f2 12 f0       	push   $0xf012f2bf
f011c9dc:	e8 1a 55 fe ff       	call   f0101efb <execute_command>
f011c9e1:	83 c4 10             	add    $0x10,%esp
f011c9e4:	e9 d0 00 00 00       	jmp    f011cab9 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011c9e9:	83 ec 0c             	sub    $0xc,%esp
f011c9ec:	6a 00                	push   $0x0
f011c9ee:	e8 50 0f 00 00       	call   f011d943 <chksch>
f011c9f3:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011c9f6:	83 ec 0c             	sub    $0xc,%esp
f011c9f9:	68 c6 f2 12 f0       	push   $0xf012f2c6
f011c9fe:	e8 88 45 fe ff       	call   f0100f8b <cprintf>
f011ca03:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011ca06:	e8 e7 93 fe ff       	call   f0105df2 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011ca0b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ca12:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011ca19:	e9 8a 00 00 00       	jmp    f011caa8 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011ca1e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011ca25:	eb 55                	jmp    f011ca7c <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011ca27:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ca2a:	8b 14 85 3c c2 5e f0 	mov    -0xfa13dc4(,%eax,4),%edx
f011ca31:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011ca34:	89 c8                	mov    %ecx,%eax
f011ca36:	c1 e0 02             	shl    $0x2,%eax
f011ca39:	01 c8                	add    %ecx,%eax
f011ca3b:	01 c0                	add    %eax,%eax
f011ca3d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011ca40:	01 c8                	add    %ecx,%eax
f011ca42:	8b 04 85 80 f3 60 f0 	mov    -0xf9f0c80(,%eax,4),%eax
f011ca49:	83 ec 04             	sub    $0x4,%esp
f011ca4c:	52                   	push   %edx
f011ca4d:	ff 75 e0             	pushl  -0x20(%ebp)
f011ca50:	50                   	push   %eax
f011ca51:	e8 7f f8 ff ff       	call   f011c2d5 <find_in_range>
f011ca56:	83 c4 10             	add    $0x10,%esp
f011ca59:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011ca5c:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011ca60:	75 17                	jne    f011ca79 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011ca62:	83 ec 04             	sub    $0x4,%esp
f011ca65:	68 d8 f2 12 f0       	push   $0xf012f2d8
f011ca6a:	68 ea 00 00 00       	push   $0xea
f011ca6f:	68 22 f2 12 f0       	push   $0xf012f222
f011ca74:	e8 c0 38 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011ca79:	ff 45 d8             	incl   -0x28(%ebp)
f011ca7c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ca7f:	89 d0                	mov    %edx,%eax
f011ca81:	c1 e0 02             	shl    $0x2,%eax
f011ca84:	01 d0                	add    %edx,%eax
f011ca86:	01 c0                	add    %eax,%eax
f011ca88:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ca8b:	01 d0                	add    %edx,%eax
f011ca8d:	8b 04 85 80 f3 60 f0 	mov    -0xf9f0c80(,%eax,4),%eax
f011ca94:	85 c0                	test   %eax,%eax
f011ca96:	75 8f                	jne    f011ca27 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011ca98:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ca9b:	8b 04 85 3c c2 5e f0 	mov    -0xfa13dc4(,%eax,4),%eax
f011caa2:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011caa5:	ff 45 dc             	incl   -0x24(%ebp)
f011caa8:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011caac:	0f 8e 6c ff ff ff    	jle    f011ca1e <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011cab2:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011cab9:	83 ec 0c             	sub    $0xc,%esp
f011cabc:	68 80 f4 12 f0       	push   $0xf012f480
f011cac1:	e8 c5 44 fe ff       	call   f0100f8b <cprintf>
f011cac6:	83 c4 10             	add    $0x10,%esp
}
f011cac9:	90                   	nop
f011caca:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cacd:	5b                   	pop    %ebx
f011cace:	5e                   	pop    %esi
f011cacf:	5f                   	pop    %edi
f011cad0:	5d                   	pop    %ebp
f011cad1:	c3                   	ret    

f011cad2 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011cad2:	55                   	push   %ebp
f011cad3:	89 e5                	mov    %esp,%ebp
f011cad5:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011cad8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011cadb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011cade:	8b 45 08             	mov    0x8(%ebp),%eax
f011cae1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011cae4:	89 10                	mov    %edx,(%eax)
}
f011cae6:	8b 45 08             	mov    0x8(%ebp),%eax
f011cae9:	c9                   	leave  
f011caea:	c2 04 00             	ret    $0x4

f011caed <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011caed:	55                   	push   %ebp
f011caee:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011caf0:	8b 45 08             	mov    0x8(%ebp),%eax
f011caf3:	85 c0                	test   %eax,%eax
f011caf5:	78 16                	js     f011cb0d <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011caf7:	8b 45 08             	mov    0x8(%ebp),%eax
f011cafa:	05 00 20 00 00       	add    $0x2000,%eax
f011caff:	85 c0                	test   %eax,%eax
f011cb01:	79 05                	jns    f011cb08 <fix_round+0x1b>
f011cb03:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011cb08:	c1 f8 0e             	sar    $0xe,%eax
f011cb0b:	eb 14                	jmp    f011cb21 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011cb0d:	8b 45 08             	mov    0x8(%ebp),%eax
f011cb10:	2d 00 20 00 00       	sub    $0x2000,%eax
f011cb15:	85 c0                	test   %eax,%eax
f011cb17:	79 05                	jns    f011cb1e <fix_round+0x31>
f011cb19:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011cb1e:	c1 f8 0e             	sar    $0xe,%eax
}
f011cb21:	5d                   	pop    %ebp
f011cb22:	c3                   	ret    

f011cb23 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011cb23:	55                   	push   %ebp
f011cb24:	89 e5                	mov    %esp,%ebp
f011cb26:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011cb29:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011cb2d:	79 16                	jns    f011cb45 <fix_scale+0x22>
f011cb2f:	68 4c f5 12 f0       	push   $0xf012f54c
f011cb34:	68 53 f5 12 f0       	push   $0xf012f553
f011cb39:	6a 5a                	push   $0x5a
f011cb3b:	68 68 f5 12 f0       	push   $0xf012f568
f011cb40:	e8 f4 37 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011cb45:	8b 45 0c             	mov    0xc(%ebp),%eax
f011cb48:	0f af 45 10          	imul   0x10(%ebp),%eax
f011cb4c:	89 c2                	mov    %eax,%edx
f011cb4e:	8b 45 08             	mov    0x8(%ebp),%eax
f011cb51:	83 ec 08             	sub    $0x8,%esp
f011cb54:	52                   	push   %edx
f011cb55:	50                   	push   %eax
f011cb56:	e8 77 ff ff ff       	call   f011cad2 <__mk_fix>
f011cb5b:	83 c4 0c             	add    $0xc,%esp
}
f011cb5e:	8b 45 08             	mov    0x8(%ebp),%eax
f011cb61:	c9                   	leave  
f011cb62:	c2 04 00             	ret    $0x4

f011cb65 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011cb65:	55                   	push   %ebp
f011cb66:	89 e5                	mov    %esp,%ebp
f011cb68:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011cb6b:	83 ec 08             	sub    $0x8,%esp
f011cb6e:	68 7c f5 12 f0       	push   $0xf012f57c
f011cb73:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cb78:	e8 b4 1c ff ff       	call   f010e831 <init_spinlock>
f011cb7d:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011cb80:	83 ec 0c             	sub    $0xc,%esp
f011cb83:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cb88:	e8 d5 1c ff ff       	call   f010e862 <acquire_spinlock>
f011cb8d:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011cb90:	c7 05 88 c3 5e f0 00 	movl   $0x0,0xf05ec388
f011cb97:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011cb9a:	83 ec 0c             	sub    $0xc,%esp
f011cb9d:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cba2:	e8 42 1d ff ff       	call   f010e8e9 <release_spinlock>
f011cba7:	83 c4 10             	add    $0x10,%esp
}
f011cbaa:	90                   	nop
f011cbab:	c9                   	leave  
f011cbac:	c3                   	ret    

f011cbad <inctst>:
void inctst()
{
f011cbad:	55                   	push   %ebp
f011cbae:	89 e5                	mov    %esp,%ebp
f011cbb0:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011cbb3:	83 ec 0c             	sub    $0xc,%esp
f011cbb6:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cbbb:	e8 a2 1c ff ff       	call   f010e862 <acquire_spinlock>
f011cbc0:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011cbc3:	a1 88 c3 5e f0       	mov    0xf05ec388,%eax
f011cbc8:	40                   	inc    %eax
f011cbc9:	a3 88 c3 5e f0       	mov    %eax,0xf05ec388
	}
	release_spinlock(&tstcntlock);
f011cbce:	83 ec 0c             	sub    $0xc,%esp
f011cbd1:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cbd6:	e8 0e 1d ff ff       	call   f010e8e9 <release_spinlock>
f011cbdb:	83 c4 10             	add    $0x10,%esp
}
f011cbde:	90                   	nop
f011cbdf:	c9                   	leave  
f011cbe0:	c3                   	ret    

f011cbe1 <gettst>:
uint32 gettst()
{
f011cbe1:	55                   	push   %ebp
f011cbe2:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011cbe4:	a1 88 c3 5e f0       	mov    0xf05ec388,%eax
}
f011cbe9:	5d                   	pop    %ebp
f011cbea:	c3                   	ret    

f011cbeb <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011cbeb:	55                   	push   %ebp
f011cbec:	89 e5                	mov    %esp,%ebp
f011cbee:	83 ec 28             	sub    $0x28,%esp
f011cbf1:	8b 45 14             	mov    0x14(%ebp),%eax
f011cbf4:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011cbf7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011cbfe:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011cc02:	83 f8 65             	cmp    $0x65,%eax
f011cc05:	74 5d                	je     f011cc64 <tst+0x79>
f011cc07:	83 f8 65             	cmp    $0x65,%eax
f011cc0a:	7f 0a                	jg     f011cc16 <tst+0x2b>
f011cc0c:	83 f8 62             	cmp    $0x62,%eax
f011cc0f:	74 73                	je     f011cc84 <tst+0x99>
f011cc11:	e9 91 00 00 00       	jmp    f011cca7 <tst+0xbc>
f011cc16:	83 f8 67             	cmp    $0x67,%eax
f011cc19:	74 29                	je     f011cc44 <tst+0x59>
f011cc1b:	83 f8 6c             	cmp    $0x6c,%eax
f011cc1e:	0f 85 83 00 00 00    	jne    f011cca7 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011cc24:	8b 45 08             	mov    0x8(%ebp),%eax
f011cc27:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cc2a:	73 09                	jae    f011cc35 <tst+0x4a>
			chk = 1;
f011cc2c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011cc33:	eb 68                	jmp    f011cc9d <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011cc35:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011cc39:	74 62                	je     f011cc9d <tst+0xb2>
			chk = 1;
f011cc3b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cc42:	eb 59                	jmp    f011cc9d <tst+0xb2>
	case 'g':
		if (n > v1)
f011cc44:	8b 45 08             	mov    0x8(%ebp),%eax
f011cc47:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cc4a:	76 09                	jbe    f011cc55 <tst+0x6a>
			chk = 1;
f011cc4c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011cc53:	eb 4b                	jmp    f011cca0 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011cc55:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011cc59:	74 45                	je     f011cca0 <tst+0xb5>
			chk = 1;
f011cc5b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cc62:	eb 3c                	jmp    f011cca0 <tst+0xb5>
	case 'e':
		if (n == v1)
f011cc64:	8b 45 08             	mov    0x8(%ebp),%eax
f011cc67:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cc6a:	75 09                	jne    f011cc75 <tst+0x8a>
			chk = 1;
f011cc6c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011cc73:	eb 2e                	jmp    f011cca3 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011cc75:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011cc79:	74 28                	je     f011cca3 <tst+0xb8>
			chk = 1;
f011cc7b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cc82:	eb 1f                	jmp    f011cca3 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011cc84:	8b 45 08             	mov    0x8(%ebp),%eax
f011cc87:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cc8a:	72 1a                	jb     f011cca6 <tst+0xbb>
f011cc8c:	8b 45 08             	mov    0x8(%ebp),%eax
f011cc8f:	3b 45 10             	cmp    0x10(%ebp),%eax
f011cc92:	77 12                	ja     f011cca6 <tst+0xbb>
			chk = 1;
f011cc94:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cc9b:	eb 09                	jmp    f011cca6 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011cc9d:	90                   	nop
f011cc9e:	eb 07                	jmp    f011cca7 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011cca0:	90                   	nop
f011cca1:	eb 04                	jmp    f011cca7 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011cca3:	90                   	nop
f011cca4:	eb 01                	jmp    f011cca7 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011cca6:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011cca7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ccab:	75 14                	jne    f011ccc1 <tst+0xd6>
f011ccad:	83 ec 04             	sub    $0x4,%esp
f011ccb0:	68 88 f5 12 f0       	push   $0xf012f588
f011ccb5:	6a 48                	push   $0x48
f011ccb7:	68 9b f5 12 f0       	push   $0xf012f59b
f011ccbc:	e8 78 36 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011ccc1:	83 ec 0c             	sub    $0xc,%esp
f011ccc4:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011ccc9:	e8 94 1b ff ff       	call   f010e862 <acquire_spinlock>
f011ccce:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011ccd1:	a1 88 c3 5e f0       	mov    0xf05ec388,%eax
f011ccd6:	40                   	inc    %eax
f011ccd7:	a3 88 c3 5e f0       	mov    %eax,0xf05ec388
	}
	release_spinlock(&tstcntlock);
f011ccdc:	83 ec 0c             	sub    $0xc,%esp
f011ccdf:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cce4:	e8 00 1c ff ff       	call   f010e8e9 <release_spinlock>
f011cce9:	83 c4 10             	add    $0x10,%esp

	return;
f011ccec:	90                   	nop
}
f011cced:	c9                   	leave  
f011ccee:	c3                   	ret    

f011ccef <chktst>:

void chktst(uint32 n)
{
f011ccef:	55                   	push   %ebp
f011ccf0:	89 e5                	mov    %esp,%ebp
f011ccf2:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011ccf5:	83 ec 0c             	sub    $0xc,%esp
f011ccf8:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011ccfd:	e8 60 1b ff ff       	call   f010e862 <acquire_spinlock>
f011cd02:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011cd05:	a1 88 c3 5e f0       	mov    0xf05ec388,%eax
f011cd0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011cd0d:	83 ec 0c             	sub    $0xc,%esp
f011cd10:	68 a0 cc 5e f0       	push   $0xf05ecca0
f011cd15:	e8 cf 1b ff ff       	call   f010e8e9 <release_spinlock>
f011cd1a:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011cd1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011cd20:	3b 45 08             	cmp    0x8(%ebp),%eax
f011cd23:	75 12                	jne    f011cd37 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011cd25:	83 ec 0c             	sub    $0xc,%esp
f011cd28:	68 b4 f5 12 f0       	push   $0xf012f5b4
f011cd2d:	e8 59 42 fe ff       	call   f0100f8b <cprintf>
f011cd32:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011cd35:	eb 14                	jmp    f011cd4b <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011cd37:	83 ec 04             	sub    $0x4,%esp
f011cd3a:	68 e0 f5 12 f0       	push   $0xf012f5e0
f011cd3f:	6a 5e                	push   $0x5e
f011cd41:	68 9b f5 12 f0       	push   $0xf012f59b
f011cd46:	e8 ee 35 fe ff       	call   f0100339 <_panic>
}
f011cd4b:	c9                   	leave  
f011cd4c:	c3                   	ret    

f011cd4d <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011cd4d:	55                   	push   %ebp
f011cd4e:	89 e5                	mov    %esp,%ebp
f011cd50:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011cd53:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011cd57:	77 07                	ja     f011cd60 <nearest_pow2_ceil+0x13>
f011cd59:	b8 01 00 00 00       	mov    $0x1,%eax
f011cd5e:	eb 20                	jmp    f011cd80 <nearest_pow2_ceil+0x33>
	int power = 2;
f011cd60:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011cd67:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011cd6a:	eb 08                	jmp    f011cd74 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011cd6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011cd6f:	01 c0                	add    %eax,%eax
f011cd71:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011cd74:	d1 6d 08             	shrl   0x8(%ebp)
f011cd77:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011cd7b:	75 ef                	jne    f011cd6c <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011cd7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011cd80:	c9                   	leave  
f011cd81:	c3                   	ret    

f011cd82 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011cd82:	55                   	push   %ebp
f011cd83:	89 e5                	mov    %esp,%ebp
f011cd85:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011cd88:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011cd8c:	77 07                	ja     f011cd95 <log2_ceil+0x13>
f011cd8e:	b8 01 00 00 00       	mov    $0x1,%eax
f011cd93:	eb 1b                	jmp    f011cdb0 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011cd95:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011cd9c:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011cd9f:	eb 03                	jmp    f011cda4 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011cda1:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011cda4:	d1 6d 08             	shrl   0x8(%ebp)
f011cda7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011cdab:	75 f4                	jne    f011cda1 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011cdad:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011cdb0:	c9                   	leave  
f011cdb1:	c3                   	ret    

f011cdb2 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011cdb2:	55                   	push   %ebp
f011cdb3:	89 e5                	mov    %esp,%ebp
f011cdb5:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011cdb8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011cdbf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011cdc6:	eb 12                	jmp    f011cdda <fixedPt2Str+0x28>
		mulFactor *= 10;
f011cdc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cdcb:	89 d0                	mov    %edx,%eax
f011cdcd:	c1 e0 02             	shl    $0x2,%eax
f011cdd0:	01 d0                	add    %edx,%eax
f011cdd2:	01 c0                	add    %eax,%eax
f011cdd4:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011cdd7:	ff 45 f0             	incl   -0x10(%ebp)
f011cdda:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cddd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cde0:	7c e6                	jl     f011cdc8 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011cde2:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011cde5:	83 ec 04             	sub    $0x4,%esp
f011cde8:	ff 75 f4             	pushl  -0xc(%ebp)
f011cdeb:	ff 75 08             	pushl  0x8(%ebp)
f011cdee:	50                   	push   %eax
f011cdef:	e8 2f fd ff ff       	call   f011cb23 <fix_scale>
f011cdf4:	83 c4 0c             	add    $0xc,%esp
f011cdf7:	83 ec 0c             	sub    $0xc,%esp
f011cdfa:	ff 75 dc             	pushl  -0x24(%ebp)
f011cdfd:	e8 eb fc ff ff       	call   f011caed <fix_round>
f011ce02:	83 c4 10             	add    $0x10,%esp
f011ce05:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011ce08:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ce0b:	99                   	cltd   
f011ce0c:	f7 7d f4             	idivl  -0xc(%ebp)
f011ce0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011ce12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ce15:	99                   	cltd   
f011ce16:	f7 7d f4             	idivl  -0xc(%ebp)
f011ce19:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011ce1c:	83 ec 08             	sub    $0x8,%esp
f011ce1f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ce22:	50                   	push   %eax
f011ce23:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ce26:	e8 6a 1e 00 00       	call   f011ec95 <ltostr>
f011ce2b:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011ce2e:	83 ec 08             	sub    $0x8,%esp
f011ce31:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011ce34:	50                   	push   %eax
f011ce35:	ff 75 e0             	pushl  -0x20(%ebp)
f011ce38:	e8 58 1e 00 00       	call   f011ec95 <ltostr>
f011ce3d:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011ce40:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ce43:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011ce48:	f7 e9                	imul   %ecx
f011ce4a:	c1 fa 02             	sar    $0x2,%edx
f011ce4d:	89 c8                	mov    %ecx,%eax
f011ce4f:	c1 f8 1f             	sar    $0x1f,%eax
f011ce52:	29 c2                	sub    %eax,%edx
f011ce54:	89 d0                	mov    %edx,%eax
f011ce56:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011ce59:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011ce60:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011ce67:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011ce6d:	eb 31                	jmp    f011cea0 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011ce6f:	83 ec 04             	sub    $0x4,%esp
f011ce72:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ce75:	50                   	push   %eax
f011ce76:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ce79:	50                   	push   %eax
f011ce7a:	68 fc f5 12 f0       	push   $0xf012f5fc
f011ce7f:	e8 ea 1e 00 00       	call   f011ed6e <strcconcat>
f011ce84:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011ce87:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011ce8a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011ce8f:	f7 e9                	imul   %ecx
f011ce91:	c1 fa 02             	sar    $0x2,%edx
f011ce94:	89 c8                	mov    %ecx,%eax
f011ce96:	c1 f8 1f             	sar    $0x1f,%eax
f011ce99:	29 c2                	sub    %eax,%edx
f011ce9b:	89 d0                	mov    %edx,%eax
f011ce9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011cea0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011cea3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011cea6:	7c c7                	jl     f011ce6f <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011cea8:	83 ec 04             	sub    $0x4,%esp
f011ceab:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011ceae:	50                   	push   %eax
f011ceaf:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011ceb2:	50                   	push   %eax
f011ceb3:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ceb6:	50                   	push   %eax
f011ceb7:	e8 b2 1e 00 00       	call   f011ed6e <strcconcat>
f011cebc:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011cebf:	83 ec 04             	sub    $0x4,%esp
f011cec2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011cec5:	50                   	push   %eax
f011cec6:	68 fe f5 12 f0       	push   $0xf012f5fe
f011cecb:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011cece:	50                   	push   %eax
f011cecf:	e8 9a 1e 00 00       	call   f011ed6e <strcconcat>
f011ced4:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011ced7:	83 ec 04             	sub    $0x4,%esp
f011ceda:	ff 75 10             	pushl  0x10(%ebp)
f011cedd:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011cee0:	50                   	push   %eax
f011cee1:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011cee4:	50                   	push   %eax
f011cee5:	e8 84 1e 00 00       	call   f011ed6e <strcconcat>
f011ceea:	83 c4 10             	add    $0x10,%esp

}
f011ceed:	90                   	nop
f011ceee:	c9                   	leave  
f011ceef:	c3                   	ret    

f011cef0 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011cef0:	55                   	push   %ebp
f011cef1:	89 e5                	mov    %esp,%ebp
f011cef3:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011cef9:	83 ec 0c             	sub    $0xc,%esp
f011cefc:	68 00 f6 12 f0       	push   $0xf012f600
f011cf01:	e8 e9 18 00 00       	call   f011e7ef <strlen>
f011cf06:	83 c4 10             	add    $0x10,%esp
f011cf09:	83 ec 04             	sub    $0x4,%esp
f011cf0c:	50                   	push   %eax
f011cf0d:	68 00 f6 12 f0       	push   $0xf012f600
f011cf12:	ff 75 08             	pushl  0x8(%ebp)
f011cf15:	e8 19 1a 00 00       	call   f011e933 <strncmp>
f011cf1a:	83 c4 10             	add    $0x10,%esp
f011cf1d:	85 c0                	test   %eax,%eax
f011cf1f:	0f 85 8a 00 00 00    	jne    f011cfaf <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011cf25:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011cf28:	50                   	push   %eax
f011cf29:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011cf2f:	50                   	push   %eax
f011cf30:	68 0e f6 12 f0       	push   $0xf012f60e
f011cf35:	ff 75 08             	pushl  0x8(%ebp)
f011cf38:	e8 c7 1e 00 00       	call   f011ee04 <strsplit>
f011cf3d:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011cf40:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf46:	83 ec 04             	sub    $0x4,%esp
f011cf49:	6a 0a                	push   $0xa
f011cf4b:	6a 00                	push   $0x0
f011cf4d:	50                   	push   %eax
f011cf4e:	e8 fc 1b 00 00       	call   f011eb4f <strtol>
f011cf53:	83 c4 10             	add    $0x10,%esp
f011cf56:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011cf59:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011cf60:	83 ec 04             	sub    $0x4,%esp
f011cf63:	6a 00                	push   $0x0
f011cf65:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011cf68:	50                   	push   %eax
f011cf69:	ff 75 e0             	pushl  -0x20(%ebp)
f011cf6c:	e8 c1 d9 fe ff       	call   f010a932 <envid2env>
f011cf71:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011cf74:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cf77:	8b 40 10             	mov    0x10(%eax),%eax
f011cf7a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011cf7d:	74 19                	je     f011cf98 <sys_utilities+0xa8>
f011cf7f:	68 10 f6 12 f0       	push   $0xf012f610
f011cf84:	68 53 f5 12 f0       	push   $0xf012f553
f011cf89:	68 a4 00 00 00       	push   $0xa4
f011cf8e:	68 9b f5 12 f0       	push   $0xf012f59b
f011cf93:	e8 a1 33 fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011cf98:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cf9b:	83 ec 08             	sub    $0x8,%esp
f011cf9e:	ff 75 0c             	pushl  0xc(%ebp)
f011cfa1:	50                   	push   %eax
f011cfa2:	e8 7d 96 fe ff       	call   f0106624 <env_set_nice>
f011cfa7:	83 c4 10             	add    $0x10,%esp
f011cfaa:	e9 12 04 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011cfaf:	83 ec 0c             	sub    $0xc,%esp
f011cfb2:	68 25 f6 12 f0       	push   $0xf012f625
f011cfb7:	e8 33 18 00 00       	call   f011e7ef <strlen>
f011cfbc:	83 c4 10             	add    $0x10,%esp
f011cfbf:	83 ec 04             	sub    $0x4,%esp
f011cfc2:	50                   	push   %eax
f011cfc3:	68 25 f6 12 f0       	push   $0xf012f625
f011cfc8:	ff 75 08             	pushl  0x8(%ebp)
f011cfcb:	e8 63 19 00 00       	call   f011e933 <strncmp>
f011cfd0:	83 c4 10             	add    $0x10,%esp
f011cfd3:	85 c0                	test   %eax,%eax
f011cfd5:	0f 85 a6 01 00 00    	jne    f011d181 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011cfdb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011cfde:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011cfe1:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011cfe4:	50                   	push   %eax
f011cfe5:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011cfeb:	50                   	push   %eax
f011cfec:	68 0e f6 12 f0       	push   $0xf012f60e
f011cff1:	ff 75 08             	pushl  0x8(%ebp)
f011cff4:	e8 0b 1e 00 00       	call   f011ee04 <strsplit>
f011cff9:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011cffc:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d002:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011d005:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011d00c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011d013:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011d01a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d01d:	8b 00                	mov    (%eax),%eax
f011d01f:	85 c0                	test   %eax,%eax
f011d021:	79 1c                	jns    f011d03f <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011d023:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011d02a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d02d:	8b 00                	mov    (%eax),%eax
f011d02f:	f7 d8                	neg    %eax
f011d031:	89 c2                	mov    %eax,%edx
f011d033:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d036:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011d038:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011d03f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011d046:	83 ec 0c             	sub    $0xc,%esp
f011d049:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d04e:	e8 0f 18 ff ff       	call   f010e862 <acquire_spinlock>
f011d053:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d056:	a1 2c c5 5e f0       	mov    0xf05ec52c,%eax
f011d05b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d05e:	a1 24 c5 5e f0       	mov    0xf05ec524,%eax
f011d063:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011d066:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d069:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d06c:	eb 6c                	jmp    f011d0da <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011d06e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d071:	83 c0 20             	add    $0x20,%eax
f011d074:	83 ec 08             	sub    $0x8,%esp
f011d077:	ff 75 d8             	pushl  -0x28(%ebp)
f011d07a:	50                   	push   %eax
f011d07b:	e8 7b 18 00 00       	call   f011e8fb <strcmp>
f011d080:	83 c4 10             	add    $0x10,%esp
f011d083:	85 c0                	test   %eax,%eax
f011d085:	75 46                	jne    f011d0cd <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011d087:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d08a:	8b 00                	mov    (%eax),%eax
f011d08c:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d08f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d092:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011d094:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d098:	74 14                	je     f011d0ae <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011d09a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d09d:	8b 40 10             	mov    0x10(%eax),%eax
f011d0a0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d0a3:	7d 1d                	jge    f011d0c2 <sys_utilities+0x1d2>
					{
						success = 0;
f011d0a5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011d0ac:	eb 32                	jmp    f011d0e0 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011d0ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d0b1:	8b 40 10             	mov    0x10(%eax),%eax
f011d0b4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d0b7:	7e 09                	jle    f011d0c2 <sys_utilities+0x1d2>
					{
						success = 0;
f011d0b9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011d0c0:	eb 1e                	jmp    f011d0e0 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011d0c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d0c5:	8b 40 10             	mov    0x10(%eax),%eax
f011d0c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011d0cb:	eb 01                	jmp    f011d0ce <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011d0cd:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011d0ce:	ff 4d e4             	decl   -0x1c(%ebp)
f011d0d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d0d4:	8b 40 0c             	mov    0xc(%eax),%eax
f011d0d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011d0da:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d0de:	7f 8e                	jg     f011d06e <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d0e0:	83 ec 0c             	sub    $0xc,%esp
f011d0e3:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d0e8:	e8 fc 17 ff ff       	call   f010e8e9 <release_spinlock>
f011d0ed:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011d0f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d0f3:	8b 00                	mov    (%eax),%eax
f011d0f5:	85 c0                	test   %eax,%eax
f011d0f7:	75 06                	jne    f011d0ff <sys_utilities+0x20f>
f011d0f9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011d0fd:	75 41                	jne    f011d140 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011d0ff:	83 ec 0c             	sub    $0xc,%esp
f011d102:	68 38 f6 12 f0       	push   $0xf012f638
f011d107:	e8 7f 3e fe ff       	call   f0100f8b <cprintf>
f011d10c:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011d10f:	83 ec 08             	sub    $0x8,%esp
f011d112:	ff 75 d8             	pushl  -0x28(%ebp)
f011d115:	68 68 f6 12 f0       	push   $0xf012f668
f011d11a:	e8 6c 3e fe ff       	call   f0100f8b <cprintf>
f011d11f:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011d122:	83 ec 0c             	sub    $0xc,%esp
f011d125:	68 38 f6 12 f0       	push   $0xf012f638
f011d12a:	e8 5c 3e fe ff       	call   f0100f8b <cprintf>
f011d12f:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011d132:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d135:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011d13b:	e9 81 02 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011d140:	83 ec 0c             	sub    $0xc,%esp
f011d143:	68 88 f6 12 f0       	push   $0xf012f688
f011d148:	e8 3e 3e fe ff       	call   f0100f8b <cprintf>
f011d14d:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011d150:	83 ec 08             	sub    $0x8,%esp
f011d153:	ff 75 d8             	pushl  -0x28(%ebp)
f011d156:	68 c0 f6 12 f0       	push   $0xf012f6c0
f011d15b:	e8 2b 3e fe ff       	call   f0100f8b <cprintf>
f011d160:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011d163:	83 ec 0c             	sub    $0xc,%esp
f011d166:	68 88 f6 12 f0       	push   $0xf012f688
f011d16b:	e8 1b 3e fe ff       	call   f0100f8b <cprintf>
f011d170:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011d173:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d176:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011d17c:	e9 40 02 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011d181:	83 ec 08             	sub    $0x8,%esp
f011d184:	68 e3 f6 12 f0       	push   $0xf012f6e3
f011d189:	ff 75 08             	pushl  0x8(%ebp)
f011d18c:	e8 6a 17 00 00       	call   f011e8fb <strcmp>
f011d191:	83 c4 10             	add    $0x10,%esp
f011d194:	85 c0                	test   %eax,%eax
f011d196:	75 77                	jne    f011d20f <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011d198:	a1 e0 bd 17 f0       	mov    0xf017bde0,%eax
f011d19d:	85 c0                	test   %eax,%eax
f011d19f:	74 34                	je     f011d1d5 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011d1a1:	c7 05 e0 bd 17 f0 00 	movl   $0x0,0xf017bde0
f011d1a8:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011d1ab:	83 ec 08             	sub    $0x8,%esp
f011d1ae:	68 ed f6 12 f0       	push   $0xf012f6ed
f011d1b3:	68 60 f4 60 f0       	push   $0xf060f460
f011d1b8:	e8 65 1a ff ff       	call   f010ec22 <init_channel>
f011d1bd:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011d1c0:	83 ec 08             	sub    $0x8,%esp
f011d1c3:	68 fa f6 12 f0       	push   $0xf012f6fa
f011d1c8:	68 e0 f5 60 f0       	push   $0xf060f5e0
f011d1cd:	e8 5f 16 ff ff       	call   f010e831 <init_spinlock>
f011d1d2:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011d1d5:	83 ec 0c             	sub    $0xc,%esp
f011d1d8:	68 e0 f5 60 f0       	push   $0xf060f5e0
f011d1dd:	e8 80 16 ff ff       	call   f010e862 <acquire_spinlock>
f011d1e2:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011d1e5:	83 ec 08             	sub    $0x8,%esp
f011d1e8:	68 e0 f5 60 f0       	push   $0xf060f5e0
f011d1ed:	68 60 f4 60 f0       	push   $0xf060f460
f011d1f2:	e8 58 1a ff ff       	call   f010ec4f <sleep>
f011d1f7:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011d1fa:	83 ec 0c             	sub    $0xc,%esp
f011d1fd:	68 e0 f5 60 f0       	push   $0xf060f5e0
f011d202:	e8 e2 16 ff ff       	call   f010e8e9 <release_spinlock>
f011d207:	83 c4 10             	add    $0x10,%esp
f011d20a:	e9 b2 01 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011d20f:	83 ec 08             	sub    $0x8,%esp
f011d212:	68 0c f7 12 f0       	push   $0xf012f70c
f011d217:	ff 75 08             	pushl  0x8(%ebp)
f011d21a:	e8 dc 16 00 00       	call   f011e8fb <strcmp>
f011d21f:	83 c4 10             	add    $0x10,%esp
f011d222:	85 c0                	test   %eax,%eax
f011d224:	75 15                	jne    f011d23b <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011d226:	83 ec 0c             	sub    $0xc,%esp
f011d229:	68 60 f4 60 f0       	push   $0xf060f460
f011d22e:	e8 89 1a ff ff       	call   f010ecbc <wakeup_one>
f011d233:	83 c4 10             	add    $0x10,%esp
f011d236:	e9 86 01 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011d23b:	83 ec 08             	sub    $0x8,%esp
f011d23e:	68 1a f7 12 f0       	push   $0xf012f71a
f011d243:	ff 75 08             	pushl  0x8(%ebp)
f011d246:	e8 b0 16 00 00       	call   f011e8fb <strcmp>
f011d24b:	83 c4 10             	add    $0x10,%esp
f011d24e:	85 c0                	test   %eax,%eax
f011d250:	75 15                	jne    f011d267 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011d252:	83 ec 0c             	sub    $0xc,%esp
f011d255:	68 60 f4 60 f0       	push   $0xf060f460
f011d25a:	e8 e1 1a ff ff       	call   f010ed40 <wakeup_all>
f011d25f:	83 c4 10             	add    $0x10,%esp
f011d262:	e9 5a 01 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011d267:	83 ec 08             	sub    $0x8,%esp
f011d26a:	68 28 f7 12 f0       	push   $0xf012f728
f011d26f:	ff 75 08             	pushl  0x8(%ebp)
f011d272:	e8 84 16 00 00       	call   f011e8fb <strcmp>
f011d277:	83 c4 10             	add    $0x10,%esp
f011d27a:	85 c0                	test   %eax,%eax
f011d27c:	75 17                	jne    f011d295 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011d27e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d281:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011d284:	a1 6c f4 60 f0       	mov    0xf060f46c,%eax
f011d289:	89 c2                	mov    %eax,%edx
f011d28b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d28e:	89 10                	mov    %edx,(%eax)
f011d290:	e9 2c 01 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011d295:	83 ec 08             	sub    $0x8,%esp
f011d298:	68 3d f7 12 f0       	push   $0xf012f73d
f011d29d:	ff 75 08             	pushl  0x8(%ebp)
f011d2a0:	e8 56 16 00 00       	call   f011e8fb <strcmp>
f011d2a5:	83 c4 10             	add    $0x10,%esp
f011d2a8:	85 c0                	test   %eax,%eax
f011d2aa:	75 1a                	jne    f011d2c6 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011d2ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d2af:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011d2b2:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011d2b7:	8b 40 0c             	mov    0xc(%eax),%eax
f011d2ba:	89 c2                	mov    %eax,%edx
f011d2bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d2bf:	89 10                	mov    %edx,(%eax)
f011d2c1:	e9 fb 00 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011d2c6:	83 ec 08             	sub    $0x8,%esp
f011d2c9:	68 53 f7 12 f0       	push   $0xf012f753
f011d2ce:	ff 75 08             	pushl  0x8(%ebp)
f011d2d1:	e8 25 16 00 00       	call   f011e8fb <strcmp>
f011d2d6:	83 c4 10             	add    $0x10,%esp
f011d2d9:	85 c0                	test   %eax,%eax
f011d2db:	75 3d                	jne    f011d31a <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011d2dd:	a1 e4 bd 17 f0       	mov    0xf017bde4,%eax
f011d2e2:	85 c0                	test   %eax,%eax
f011d2e4:	74 1f                	je     f011d305 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011d2e6:	c7 05 e4 bd 17 f0 00 	movl   $0x0,0xf017bde4
f011d2ed:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011d2f0:	83 ec 08             	sub    $0x8,%esp
f011d2f3:	68 68 f7 12 f0       	push   $0xf012f768
f011d2f8:	68 c0 f4 60 f0       	push   $0xf060f4c0
f011d2fd:	e8 ba 17 ff ff       	call   f010eabc <init_sleeplock>
f011d302:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011d305:	83 ec 0c             	sub    $0xc,%esp
f011d308:	68 c0 f4 60 f0       	push   $0xf060f4c0
f011d30d:	e8 6e 18 ff ff       	call   f010eb80 <acquire_sleeplock>
f011d312:	83 c4 10             	add    $0x10,%esp
f011d315:	e9 a7 00 00 00       	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011d31a:	83 ec 08             	sub    $0x8,%esp
f011d31d:	68 78 f7 12 f0       	push   $0xf012f778
f011d322:	ff 75 08             	pushl  0x8(%ebp)
f011d325:	e8 d1 15 00 00       	call   f011e8fb <strcmp>
f011d32a:	83 c4 10             	add    $0x10,%esp
f011d32d:	85 c0                	test   %eax,%eax
f011d32f:	75 12                	jne    f011d343 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011d331:	83 ec 0c             	sub    $0xc,%esp
f011d334:	68 c0 f4 60 f0       	push   $0xf060f4c0
f011d339:	e8 9c 18 ff ff       	call   f010ebda <release_sleeplock>
f011d33e:	83 c4 10             	add    $0x10,%esp
f011d341:	eb 7e                	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011d343:	83 ec 08             	sub    $0x8,%esp
f011d346:	68 8d f7 12 f0       	push   $0xf012f78d
f011d34b:	ff 75 08             	pushl  0x8(%ebp)
f011d34e:	e8 a8 15 00 00       	call   f011e8fb <strcmp>
f011d353:	83 c4 10             	add    $0x10,%esp
f011d356:	85 c0                	test   %eax,%eax
f011d358:	75 14                	jne    f011d36e <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011d35a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d35d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011d360:	a1 40 f5 60 f0       	mov    0xf060f540,%eax
f011d365:	89 c2                	mov    %eax,%edx
f011d367:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d36a:	89 10                	mov    %edx,(%eax)
f011d36c:	eb 53                	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011d36e:	83 ec 08             	sub    $0x8,%esp
f011d371:	68 a2 f7 12 f0       	push   $0xf012f7a2
f011d376:	ff 75 08             	pushl  0x8(%ebp)
f011d379:	e8 7d 15 00 00       	call   f011e8fb <strcmp>
f011d37e:	83 c4 10             	add    $0x10,%esp
f011d381:	85 c0                	test   %eax,%eax
f011d383:	75 13                	jne    f011d398 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011d385:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d388:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011d38b:	8b 15 c0 f4 60 f0    	mov    0xf060f4c0,%edx
f011d391:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d394:	89 10                	mov    %edx,(%eax)
f011d396:	eb 29                	jmp    f011d3c1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011d398:	83 ec 08             	sub    $0x8,%esp
f011d39b:	68 b3 f7 12 f0       	push   $0xf012f7b3
f011d3a0:	ff 75 08             	pushl  0x8(%ebp)
f011d3a3:	e8 53 15 00 00       	call   f011e8fb <strcmp>
f011d3a8:	83 c4 10             	add    $0x10,%esp
f011d3ab:	85 c0                	test   %eax,%eax
f011d3ad:	75 12                	jne    f011d3c1 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011d3af:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d3b2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011d3b5:	a1 c4 f5 60 f0       	mov    0xf060f5c4,%eax
f011d3ba:	89 c2                	mov    %eax,%edx
f011d3bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d3bf:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011d3c1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011d3c5:	79 5b                	jns    f011d422 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011d3c7:	83 ec 08             	sub    $0x8,%esp
f011d3ca:	68 c4 f7 12 f0       	push   $0xf012f7c4
f011d3cf:	ff 75 08             	pushl  0x8(%ebp)
f011d3d2:	e8 24 15 00 00       	call   f011e8fb <strcmp>
f011d3d7:	83 c4 10             	add    $0x10,%esp
f011d3da:	85 c0                	test   %eax,%eax
f011d3dc:	75 44                	jne    f011d422 <sys_utilities+0x532>
		{
			switch (value)
f011d3de:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d3e1:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011d3e4:	74 07                	je     f011d3ed <sys_utilities+0x4fd>
f011d3e6:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011d3e9:	74 19                	je     f011d404 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011d3eb:	eb 35                	jmp    f011d422 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011d3ed:	83 ec 0c             	sub    $0xc,%esp
f011d3f0:	68 d4 f7 12 f0       	push   $0xf012f7d4
f011d3f5:	e8 91 3b fe ff       	call   f0100f8b <cprintf>
f011d3fa:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011d3fd:	e8 b7 0f ff ff       	call   f010e3b9 <setPageReplacmentAlgorithmFIFO>
				break;
f011d402:	eb 1e                	jmp    f011d422 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011d404:	83 ec 0c             	sub    $0xc,%esp
f011d407:	68 44 f8 12 f0       	push   $0xf012f844
f011d40c:	e8 7a 3b fe ff       	call   f0100f8b <cprintf>
f011d411:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011d414:	83 ec 0c             	sub    $0xc,%esp
f011d417:	6a 02                	push   $0x2
f011d419:	e8 58 0f ff ff       	call   f010e376 <setPageReplacmentAlgorithmLRU>
f011d41e:	83 c4 10             	add    $0x10,%esp
				break;
f011d421:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011d422:	90                   	nop
f011d423:	c9                   	leave  
f011d424:	c3                   	ret    

f011d425 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011d425:	55                   	push   %ebp
f011d426:	89 e5                	mov    %esp,%ebp
f011d428:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011d42b:	8b 45 08             	mov    0x8(%ebp),%eax
f011d42e:	8b 00                	mov    (%eax),%eax
f011d430:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011d433:	8b 45 08             	mov    0x8(%ebp),%eax
f011d436:	8b 00                	mov    (%eax),%eax
f011d438:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011d43b:	eb 52                	jmp    f011d48f <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011d43d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d440:	8b 00                	mov    (%eax),%eax
f011d442:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011d445:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d448:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d44b:	75 12                	jne    f011d45f <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011d44d:	83 ec 0c             	sub    $0xc,%esp
f011d450:	68 b8 f8 12 f0       	push   $0xf012f8b8
f011d455:	e8 31 3b fe ff       	call   f0100f8b <cprintf>
f011d45a:	83 c4 10             	add    $0x10,%esp
			break;
f011d45d:	eb 3f                	jmp    f011d49e <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011d45f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d463:	74 38                	je     f011d49d <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011d465:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d468:	8b 00                	mov    (%eax),%eax
f011d46a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011d46d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d470:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d473:	75 12                	jne    f011d487 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011d475:	83 ec 0c             	sub    $0xc,%esp
f011d478:	68 d4 f8 12 f0       	push   $0xf012f8d4
f011d47d:	e8 09 3b fe ff       	call   f0100f8b <cprintf>
f011d482:	83 c4 10             	add    $0x10,%esp
			break;
f011d485:	eb 17                	jmp    f011d49e <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011d487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d48a:	8b 00                	mov    (%eax),%eax
f011d48c:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011d48f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d493:	74 09                	je     f011d49e <detect_loop_in_FrameInfo_list+0x79>
f011d495:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d499:	75 a2                	jne    f011d43d <detect_loop_in_FrameInfo_list+0x18>
f011d49b:	eb 01                	jmp    f011d49e <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011d49d:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011d49e:	83 ec 0c             	sub    $0xc,%esp
f011d4a1:	68 eb f8 12 f0       	push   $0xf012f8eb
f011d4a6:	e8 e0 3a fe ff       	call   f0100f8b <cprintf>
f011d4ab:	83 c4 10             	add    $0x10,%esp
}
f011d4ae:	90                   	nop
f011d4af:	c9                   	leave  
f011d4b0:	c3                   	ret    

f011d4b1 <scarce_memory>:

void scarce_memory()
{
f011d4b1:	55                   	push   %ebp
f011d4b2:	89 e5                	mov    %esp,%ebp
f011d4b4:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011d4b7:	a1 70 c6 5e f0       	mov    0xf05ec670,%eax
f011d4bc:	ba 64 00 00 00       	mov    $0x64,%edx
f011d4c1:	29 c2                	sub    %eax,%edx
f011d4c3:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f011d4c8:	0f af c2             	imul   %edx,%eax
f011d4cb:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d4d0:	f7 e2                	mul    %edx
f011d4d2:	89 d0                	mov    %edx,%eax
f011d4d4:	c1 e8 05             	shr    $0x5,%eax
f011d4d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011d4da:	a1 70 c6 5e f0       	mov    0xf05ec670,%eax
f011d4df:	ba 64 00 00 00       	mov    $0x64,%edx
f011d4e4:	29 c2                	sub    %eax,%edx
f011d4e6:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f011d4eb:	89 d1                	mov    %edx,%ecx
f011d4ed:	0f af c8             	imul   %eax,%ecx
f011d4f0:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d4f5:	f7 e1                	mul    %ecx
f011d4f7:	c1 ea 05             	shr    $0x5,%edx
f011d4fa:	89 d0                	mov    %edx,%eax
f011d4fc:	c1 e0 02             	shl    $0x2,%eax
f011d4ff:	01 d0                	add    %edx,%eax
f011d501:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d508:	01 d0                	add    %edx,%eax
f011d50a:	c1 e0 02             	shl    $0x2,%eax
f011d50d:	29 c1                	sub    %eax,%ecx
f011d50f:	89 ca                	mov    %ecx,%edx
f011d511:	85 d2                	test   %edx,%edx
f011d513:	74 03                	je     f011d518 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011d515:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011d518:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011d51f:	83 ec 0c             	sub    $0xc,%esp
f011d522:	68 60 c5 5e f0       	push   $0xf05ec560
f011d527:	e8 36 13 ff ff       	call   f010e862 <acquire_spinlock>
f011d52c:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011d52f:	a1 4c c5 5e f0       	mov    0xf05ec54c,%eax
f011d534:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011d537:	8b 15 38 c7 5e f0    	mov    0xf05ec738,%edx
f011d53d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d540:	29 c2                	sub    %eax,%edx
f011d542:	89 d0                	mov    %edx,%eax
f011d544:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011d547:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d54a:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011d54d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011d550:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011d557:	eb 12                	jmp    f011d56b <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011d559:	83 ec 0c             	sub    $0xc,%esp
f011d55c:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011d55f:	50                   	push   %eax
f011d560:	e8 e2 ab fe ff       	call   f0108147 <allocate_frame>
f011d565:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011d568:	ff 45 f0             	incl   -0x10(%ebp)
f011d56b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d56e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d571:	76 e6                	jbe    f011d559 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011d573:	83 ec 0c             	sub    $0xc,%esp
f011d576:	68 60 c5 5e f0       	push   $0xf05ec560
f011d57b:	e8 69 13 ff ff       	call   f010e8e9 <release_spinlock>
f011d580:	83 c4 10             	add    $0x10,%esp

}
f011d583:	90                   	nop
f011d584:	c9                   	leave  
f011d585:	c3                   	ret    

f011d586 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011d586:	55                   	push   %ebp
f011d587:	89 e5                	mov    %esp,%ebp
f011d589:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011d58c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011d593:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011d59a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011d5a1:	e8 3c d3 fe ff       	call   f010a8e2 <get_cpu_proc>
f011d5a6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011d5a9:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011d5ad:	75 19                	jne    f011d5c8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011d5af:	68 05 f9 12 f0       	push   $0xf012f905
f011d5b4:	68 53 f5 12 f0       	push   $0xf012f553
f011d5b9:	68 79 01 00 00       	push   $0x179
f011d5be:	68 9b f5 12 f0       	push   $0xf012f59b
f011d5c3:	e8 71 2d fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011d5c8:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d5cc:	0f 85 d6 01 00 00    	jne    f011d7a8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011d5d2:	83 ec 0c             	sub    $0xc,%esp
f011d5d5:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d5da:	e8 83 12 ff ff       	call   f010e862 <acquire_spinlock>
f011d5df:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011d5e2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011d5e9:	e9 d2 00 00 00       	jmp    f011d6c0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011d5ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011d5f5:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011d5fa:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d5fd:	c1 e2 04             	shl    $0x4,%edx
f011d600:	01 d0                	add    %edx,%eax
f011d602:	8b 00                	mov    (%eax),%eax
f011d604:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d607:	eb 7c                	jmp    f011d685 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011d609:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d60c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011d612:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011d615:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d618:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d61e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d621:	0f af c2             	imul   %edx,%eax
f011d624:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d629:	f7 e2                	mul    %edx
f011d62b:	89 d0                	mov    %edx,%eax
f011d62d:	c1 e8 05             	shr    $0x5,%eax
f011d630:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011d633:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d636:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d63c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d63f:	89 d1                	mov    %edx,%ecx
f011d641:	0f af c8             	imul   %eax,%ecx
f011d644:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d649:	f7 e1                	mul    %ecx
f011d64b:	c1 ea 05             	shr    $0x5,%edx
f011d64e:	89 d0                	mov    %edx,%eax
f011d650:	c1 e0 02             	shl    $0x2,%eax
f011d653:	01 d0                	add    %edx,%eax
f011d655:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d65c:	01 d0                	add    %edx,%eax
f011d65e:	c1 e0 02             	shl    $0x2,%eax
f011d661:	29 c1                	sub    %eax,%ecx
f011d663:	89 ca                	mov    %ecx,%edx
f011d665:	85 d2                	test   %edx,%edx
f011d667:	74 03                	je     f011d66c <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011d669:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011d66c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d66f:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011d672:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011d677:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d67a:	c1 e2 04             	shl    $0x4,%edx
f011d67d:	01 d0                	add    %edx,%eax
f011d67f:	8b 40 08             	mov    0x8(%eax),%eax
f011d682:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d685:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011d68a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d68d:	c1 e2 04             	shl    $0x4,%edx
f011d690:	01 d0                	add    %edx,%eax
f011d692:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d696:	74 08                	je     f011d6a0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011d698:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011d69b:	8b 52 08             	mov    0x8(%edx),%edx
f011d69e:	eb 05                	jmp    f011d6a5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011d6a0:	ba 00 00 00 00       	mov    $0x0,%edx
f011d6a5:	89 50 08             	mov    %edx,0x8(%eax)
f011d6a8:	8b 40 08             	mov    0x8(%eax),%eax
f011d6ab:	85 c0                	test   %eax,%eax
f011d6ad:	0f 85 56 ff ff ff    	jne    f011d609 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011d6b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d6b7:	0f 85 4c ff ff ff    	jne    f011d609 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011d6bd:	ff 45 e8             	incl   -0x18(%ebp)
f011d6c0:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011d6c5:	0f b6 c0             	movzbl %al,%eax
f011d6c8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d6cb:	0f 8f 1d ff ff ff    	jg     f011d5ee <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011d6d1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011d6d8:	a1 20 c5 5e f0       	mov    0xf05ec520,%eax
f011d6dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011d6e0:	eb 1a                	jmp    f011d6fc <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011d6e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d6e5:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011d6eb:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011d6ee:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d6f1:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011d6f4:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f011d6f9:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011d6fc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011d700:	74 08                	je     f011d70a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011d702:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d705:	8b 40 08             	mov    0x8(%eax),%eax
f011d708:	eb 05                	jmp    f011d70f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011d70a:	b8 00 00 00 00       	mov    $0x0,%eax
f011d70f:	a3 28 c5 5e f0       	mov    %eax,0xf05ec528
f011d714:	a1 28 c5 5e f0       	mov    0xf05ec528,%eax
f011d719:	85 c0                	test   %eax,%eax
f011d71b:	75 c5                	jne    f011d6e2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011d71d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011d721:	75 bf                	jne    f011d6e2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d723:	83 ec 0c             	sub    $0xc,%esp
f011d726:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d72b:	e8 b9 11 ff ff       	call   f010e8e9 <release_spinlock>
f011d730:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011d733:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011d737:	0f 84 d4 00 00 00    	je     f011d811 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011d73d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d740:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011d746:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011d749:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d74c:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d752:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d755:	0f af c2             	imul   %edx,%eax
f011d758:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d75d:	f7 e2                	mul    %edx
f011d75f:	89 d0                	mov    %edx,%eax
f011d761:	c1 e8 05             	shr    $0x5,%eax
f011d764:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011d767:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d76a:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d770:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d773:	89 d1                	mov    %edx,%ecx
f011d775:	0f af c8             	imul   %eax,%ecx
f011d778:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d77d:	f7 e1                	mul    %ecx
f011d77f:	c1 ea 05             	shr    $0x5,%edx
f011d782:	89 d0                	mov    %edx,%eax
f011d784:	c1 e0 02             	shl    $0x2,%eax
f011d787:	01 d0                	add    %edx,%eax
f011d789:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d790:	01 d0                	add    %edx,%eax
f011d792:	c1 e0 02             	shl    $0x2,%eax
f011d795:	29 c1                	sub    %eax,%ecx
f011d797:	89 ca                	mov    %ecx,%edx
f011d799:	85 d2                	test   %edx,%edx
f011d79b:	74 03                	je     f011d7a0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011d79d:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011d7a0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d7a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011d7a6:	eb 69                	jmp    f011d811 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011d7a8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d7ab:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011d7b1:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011d7b4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d7b7:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d7bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d7c0:	0f af c2             	imul   %edx,%eax
f011d7c3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d7c8:	f7 e2                	mul    %edx
f011d7ca:	89 d0                	mov    %edx,%eax
f011d7cc:	c1 e8 05             	shr    $0x5,%eax
f011d7cf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011d7d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d7d5:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d7db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d7de:	89 d1                	mov    %edx,%ecx
f011d7e0:	0f af c8             	imul   %eax,%ecx
f011d7e3:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d7e8:	f7 e1                	mul    %ecx
f011d7ea:	c1 ea 05             	shr    $0x5,%edx
f011d7ed:	89 d0                	mov    %edx,%eax
f011d7ef:	c1 e0 02             	shl    $0x2,%eax
f011d7f2:	01 d0                	add    %edx,%eax
f011d7f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d7fb:	01 d0                	add    %edx,%eax
f011d7fd:	c1 e0 02             	shl    $0x2,%eax
f011d800:	29 c1                	sub    %eax,%ecx
f011d802:	89 ca                	mov    %ecx,%edx
f011d804:	85 d2                	test   %edx,%edx
f011d806:	74 03                	je     f011d80b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011d808:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011d80b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d80e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011d811:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011d814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d817:	01 c2                	add    %eax,%edx
f011d819:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d81c:	01 d0                	add    %edx,%eax
}
f011d81e:	c9                   	leave  
f011d81f:	c3                   	ret    

f011d820 <schenv>:


void schenv()
{
f011d820:	55                   	push   %ebp
f011d821:	89 e5                	mov    %esp,%ebp
f011d823:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011d826:	c6 05 80 cc 5e f0 00 	movb   $0x0,0xf05ecc80
	__ne = NULL;
f011d82d:	c7 05 8c c9 5e f0 00 	movl   $0x0,0xf05ec98c
f011d834:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011d837:	83 ec 0c             	sub    $0xc,%esp
f011d83a:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d83f:	e8 1e 10 ff ff       	call   f010e862 <acquire_spinlock>
f011d844:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011d847:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d84e:	eb 3f                	jmp    f011d88f <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011d850:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011d855:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d858:	c1 e2 04             	shl    $0x4,%edx
f011d85b:	01 d0                	add    %edx,%eax
f011d85d:	83 ec 0c             	sub    $0xc,%esp
f011d860:	50                   	push   %eax
f011d861:	e8 ca 76 fe ff       	call   f0104f30 <queue_size>
f011d866:	83 c4 10             	add    $0x10,%esp
f011d869:	85 c0                	test   %eax,%eax
f011d86b:	74 1f                	je     f011d88c <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011d86d:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011d872:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d875:	c1 e2 04             	shl    $0x4,%edx
f011d878:	01 d0                	add    %edx,%eax
f011d87a:	8b 40 04             	mov    0x4(%eax),%eax
f011d87d:	a3 8c c9 5e f0       	mov    %eax,0xf05ec98c
				__nl = i;
f011d882:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d885:	a2 80 cc 5e f0       	mov    %al,0xf05ecc80
				break;
f011d88a:	eb 10                	jmp    f011d89c <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011d88c:	ff 45 f4             	incl   -0xc(%ebp)
f011d88f:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011d894:	0f b6 c0             	movzbl %al,%eax
f011d897:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d89a:	7f b4                	jg     f011d850 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d89c:	83 ec 0c             	sub    $0xc,%esp
f011d89f:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d8a4:	e8 40 10 ff ff       	call   f010e8e9 <release_spinlock>
f011d8a9:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011d8ac:	e8 31 d0 fe ff       	call   f010a8e2 <get_cpu_proc>
f011d8b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011d8b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d8b8:	0f 84 82 00 00 00    	je     f011d940 <schenv+0x120>
	{
		if (__ne != NULL)
f011d8be:	a1 8c c9 5e f0       	mov    0xf05ec98c,%eax
f011d8c3:	85 c0                	test   %eax,%eax
f011d8c5:	74 49                	je     f011d910 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011d8c7:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d8cc:	0f b6 c0             	movzbl %al,%eax
f011d8cf:	8d 50 01             	lea    0x1(%eax),%edx
f011d8d2:	a0 80 cc 5e f0       	mov    0xf05ecc80,%al
f011d8d7:	0f b6 c0             	movzbl %al,%eax
f011d8da:	39 c2                	cmp    %eax,%edx
f011d8dc:	7d 62                	jge    f011d940 <schenv+0x120>
			{
				__ne = cur_env;
f011d8de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d8e1:	a3 8c c9 5e f0       	mov    %eax,0xf05ec98c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011d8e6:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d8eb:	0f b6 c0             	movzbl %al,%eax
f011d8ee:	8a 15 e4 cb 5e f0    	mov    0xf05ecbe4,%dl
f011d8f4:	0f b6 d2             	movzbl %dl,%edx
f011d8f7:	4a                   	dec    %edx
f011d8f8:	39 d0                	cmp    %edx,%eax
f011d8fa:	7d 08                	jge    f011d904 <schenv+0xe4>
f011d8fc:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d901:	40                   	inc    %eax
f011d902:	eb 05                	jmp    f011d909 <schenv+0xe9>
f011d904:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d909:	a2 80 cc 5e f0       	mov    %al,0xf05ecc80
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011d90e:	eb 30                	jmp    f011d940 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011d910:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d913:	a3 8c c9 5e f0       	mov    %eax,0xf05ec98c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011d918:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d91d:	0f b6 c0             	movzbl %al,%eax
f011d920:	8a 15 e4 cb 5e f0    	mov    0xf05ecbe4,%dl
f011d926:	0f b6 d2             	movzbl %dl,%edx
f011d929:	4a                   	dec    %edx
f011d92a:	39 d0                	cmp    %edx,%eax
f011d92c:	7d 08                	jge    f011d936 <schenv+0x116>
f011d92e:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d933:	40                   	inc    %eax
f011d934:	eb 05                	jmp    f011d93b <schenv+0x11b>
f011d936:	a0 81 c4 5e f0       	mov    0xf05ec481,%al
f011d93b:	a2 80 cc 5e f0       	mov    %al,0xf05ecc80
		}
	}
}
f011d940:	90                   	nop
f011d941:	c9                   	leave  
f011d942:	c3                   	ret    

f011d943 <chksch>:

void chksch(uint8 onoff)
{
f011d943:	55                   	push   %ebp
f011d944:	89 e5                	mov    %esp,%ebp
f011d946:	83 ec 18             	sub    $0x18,%esp
f011d949:	8b 45 08             	mov    0x8(%ebp),%eax
f011d94c:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011d94f:	e8 5c 8d fe ff       	call   f01066b0 <isSchedMethodBSD>
f011d954:	85 c0                	test   %eax,%eax
f011d956:	74 48                	je     f011d9a0 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011d958:	e8 01 8d fe ff       	call   f010665e <get_load_average>
f011d95d:	a3 04 cc 5e f0       	mov    %eax,0xf05ecc04
f011d962:	a1 04 cc 5e f0       	mov    0xf05ecc04,%eax
f011d967:	a3 3c c7 5e f0       	mov    %eax,0xf05ec73c
		acquire_spinlock(&ProcessQueues.qlock);
f011d96c:	83 ec 0c             	sub    $0xc,%esp
f011d96f:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d974:	e8 e9 0e ff ff       	call   f010e862 <acquire_spinlock>
f011d979:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011d97c:	a1 2c c5 5e f0       	mov    0xf05ec52c,%eax
f011d981:	a3 e0 c5 5e f0       	mov    %eax,0xf05ec5e0
		}
		release_spinlock(&ProcessQueues.qlock);
f011d986:	83 ec 0c             	sub    $0xc,%esp
f011d989:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d98e:	e8 56 0f ff ff       	call   f010e8e9 <release_spinlock>
f011d993:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011d996:	c7 05 9c c9 5e f0 01 	movl   $0x1,0xf05ec99c
f011d99d:	00 00 00 
	}
	__chkstatus = onoff;
f011d9a0:	8a 45 f4             	mov    -0xc(%ebp),%al
f011d9a3:	a2 88 c9 5e f0       	mov    %al,0xf05ec988
}
f011d9a8:	90                   	nop
f011d9a9:	c9                   	leave  
f011d9aa:	c3                   	ret    

f011d9ab <chk1>:
void chk1()
{
f011d9ab:	55                   	push   %ebp
f011d9ac:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011d9ae:	90                   	nop
f011d9af:	5d                   	pop    %ebp
f011d9b0:	c3                   	ret    

f011d9b1 <chk2>:
void chk2(struct Env* __se)
{
f011d9b1:	55                   	push   %ebp
f011d9b2:	89 e5                	mov    %esp,%ebp
f011d9b4:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011d9b7:	a0 88 c9 5e f0       	mov    0xf05ec988,%al
f011d9bc:	84 c0                	test   %al,%al
f011d9be:	0f 84 59 03 00 00    	je     f011dd1d <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011d9c4:	e8 e7 8c fe ff       	call   f01066b0 <isSchedMethodBSD>
f011d9c9:	85 c0                	test   %eax,%eax
f011d9cb:	0f 84 4d 03 00 00    	je     f011dd1e <chk2+0x36d>
	{
		__nla = get_load_average();
f011d9d1:	e8 88 8c fe ff       	call   f010665e <get_load_average>
f011d9d6:	a3 74 c6 5e f0       	mov    %eax,0xf05ec674
		acquire_spinlock(&ProcessQueues.qlock);
f011d9db:	83 ec 0c             	sub    $0xc,%esp
f011d9de:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d9e3:	e8 7a 0e ff ff       	call   f010e862 <acquire_spinlock>
f011d9e8:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d9eb:	a1 2c c5 5e f0       	mov    0xf05ec52c,%eax
f011d9f0:	a3 90 c9 5e f0       	mov    %eax,0xf05ec990
		}
		release_spinlock(&ProcessQueues.qlock);
f011d9f5:	83 ec 0c             	sub    $0xc,%esp
f011d9f8:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011d9fd:	e8 e7 0e ff ff       	call   f010e8e9 <release_spinlock>
f011da02:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011da05:	a1 9c c9 5e f0       	mov    0xf05ec99c,%eax
f011da0a:	85 c0                	test   %eax,%eax
f011da0c:	74 72                	je     f011da80 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011da0e:	83 ec 0c             	sub    $0xc,%esp
f011da11:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011da16:	e8 47 0e ff ff       	call   f010e862 <acquire_spinlock>
f011da1b:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011da1e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011da22:	0f 95 c0             	setne  %al
f011da25:	0f b6 c0             	movzbl %al,%eax
f011da28:	a3 54 cb 5e f0       	mov    %eax,0xf05ecb54
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011da2d:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011da32:	0f b6 c0             	movzbl %al,%eax
f011da35:	48                   	dec    %eax
f011da36:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011da39:	eb 20                	jmp    f011da5b <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011da3b:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011da40:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011da43:	c1 e2 04             	shl    $0x4,%edx
f011da46:	01 d0                	add    %edx,%eax
f011da48:	8b 40 0c             	mov    0xc(%eax),%eax
f011da4b:	8b 15 54 cb 5e f0    	mov    0xf05ecb54,%edx
f011da51:	01 d0                	add    %edx,%eax
f011da53:	a3 54 cb 5e f0       	mov    %eax,0xf05ecb54
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011da58:	ff 4d f4             	decl   -0xc(%ebp)
f011da5b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011da5f:	79 da                	jns    f011da3b <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011da61:	c7 05 9c c9 5e f0 00 	movl   $0x0,0xf05ec99c
f011da68:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011da6b:	83 ec 0c             	sub    $0xc,%esp
f011da6e:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011da73:	e8 71 0e ff ff       	call   f010e8e9 <release_spinlock>
f011da78:	83 c4 10             	add    $0x10,%esp
f011da7b:	e9 91 02 00 00       	jmp    f011dd11 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011da80:	8b 15 e0 c5 5e f0    	mov    0xf05ec5e0,%edx
f011da86:	a1 90 c9 5e f0       	mov    0xf05ec990,%eax
f011da8b:	39 c2                	cmp    %eax,%edx
f011da8d:	74 63                	je     f011daf2 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011da8f:	83 ec 0c             	sub    $0xc,%esp
f011da92:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011da97:	e8 c6 0d ff ff       	call   f010e862 <acquire_spinlock>
f011da9c:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011da9f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011daa3:	0f 95 c0             	setne  %al
f011daa6:	0f b6 c0             	movzbl %al,%eax
f011daa9:	a3 54 cb 5e f0       	mov    %eax,0xf05ecb54
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011daae:	a0 e4 cb 5e f0       	mov    0xf05ecbe4,%al
f011dab3:	0f b6 c0             	movzbl %al,%eax
f011dab6:	48                   	dec    %eax
f011dab7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011daba:	eb 20                	jmp    f011dadc <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011dabc:	a1 30 c5 5e f0       	mov    0xf05ec530,%eax
f011dac1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011dac4:	c1 e2 04             	shl    $0x4,%edx
f011dac7:	01 d0                	add    %edx,%eax
f011dac9:	8b 40 0c             	mov    0xc(%eax),%eax
f011dacc:	8b 15 54 cb 5e f0    	mov    0xf05ecb54,%edx
f011dad2:	01 d0                	add    %edx,%eax
f011dad4:	a3 54 cb 5e f0       	mov    %eax,0xf05ecb54
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011dad9:	ff 4d f0             	decl   -0x10(%ebp)
f011dadc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011dae0:	79 da                	jns    f011dabc <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011dae2:	83 ec 0c             	sub    $0xc,%esp
f011dae5:	68 a0 c4 5e f0       	push   $0xf05ec4a0
f011daea:	e8 fa 0d ff ff       	call   f010e8e9 <release_spinlock>
f011daef:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011daf2:	e8 00 8b fe ff       	call   f01065f7 <timer_ticks>
f011daf7:	6a 00                	push   $0x0
f011daf9:	68 e8 03 00 00       	push   $0x3e8
f011dafe:	52                   	push   %edx
f011daff:	50                   	push   %eax
f011db00:	e8 c7 30 00 00       	call   f0120bcc <__moddi3>
f011db05:	83 c4 10             	add    $0x10,%esp
f011db08:	09 d0                	or     %edx,%eax
f011db0a:	85 c0                	test   %eax,%eax
f011db0c:	75 32                	jne    f011db40 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011db0e:	8b 15 3c c7 5e f0    	mov    0xf05ec73c,%edx
f011db14:	a1 74 c6 5e f0       	mov    0xf05ec674,%eax
f011db19:	39 c2                	cmp    %eax,%edx
f011db1b:	75 19                	jne    f011db36 <chk2+0x185>
f011db1d:	68 15 f9 12 f0       	push   $0xf012f915
f011db22:	68 53 f5 12 f0       	push   $0xf012f553
f011db27:	68 35 02 00 00       	push   $0x235
f011db2c:	68 9b f5 12 f0       	push   $0xf012f59b
f011db31:	e8 93 28 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011db36:	a1 74 c6 5e f0       	mov    0xf05ec674,%eax
f011db3b:	a3 3c c7 5e f0       	mov    %eax,0xf05ec73c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011db40:	e8 b2 8a fe ff       	call   f01065f7 <timer_ticks>
f011db45:	6a 00                	push   $0x0
f011db47:	6a 64                	push   $0x64
f011db49:	52                   	push   %edx
f011db4a:	50                   	push   %eax
f011db4b:	e8 7c 30 00 00       	call   f0120bcc <__moddi3>
f011db50:	83 c4 10             	add    $0x10,%esp
f011db53:	09 d0                	or     %edx,%eax
f011db55:	85 c0                	test   %eax,%eax
f011db57:	0f 85 b4 01 00 00    	jne    f011dd11 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011db5d:	8b 0d 04 cc 5e f0    	mov    0xf05ecc04,%ecx
f011db63:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011db68:	f7 e9                	imul   %ecx
f011db6a:	c1 fa 05             	sar    $0x5,%edx
f011db6d:	89 c8                	mov    %ecx,%eax
f011db6f:	c1 f8 1f             	sar    $0x1f,%eax
f011db72:	29 c2                	sub    %eax,%edx
f011db74:	89 d0                	mov    %edx,%eax
f011db76:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011db79:	8b 0d 04 cc 5e f0    	mov    0xf05ecc04,%ecx
f011db7f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011db84:	f7 e9                	imul   %ecx
f011db86:	c1 fa 05             	sar    $0x5,%edx
f011db89:	89 c8                	mov    %ecx,%eax
f011db8b:	c1 f8 1f             	sar    $0x1f,%eax
f011db8e:	29 c2                	sub    %eax,%edx
f011db90:	89 d0                	mov    %edx,%eax
f011db92:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011db95:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011db98:	89 d0                	mov    %edx,%eax
f011db9a:	c1 e0 02             	shl    $0x2,%eax
f011db9d:	01 d0                	add    %edx,%eax
f011db9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dba6:	01 d0                	add    %edx,%eax
f011dba8:	c1 e0 02             	shl    $0x2,%eax
f011dbab:	29 c1                	sub    %eax,%ecx
f011dbad:	89 c8                	mov    %ecx,%eax
f011dbaf:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011dbb2:	8b 0d 74 c6 5e f0    	mov    0xf05ec674,%ecx
f011dbb8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dbbd:	f7 e9                	imul   %ecx
f011dbbf:	c1 fa 05             	sar    $0x5,%edx
f011dbc2:	89 c8                	mov    %ecx,%eax
f011dbc4:	c1 f8 1f             	sar    $0x1f,%eax
f011dbc7:	29 c2                	sub    %eax,%edx
f011dbc9:	89 d0                	mov    %edx,%eax
f011dbcb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011dbce:	8b 0d 74 c6 5e f0    	mov    0xf05ec674,%ecx
f011dbd4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dbd9:	f7 e9                	imul   %ecx
f011dbdb:	c1 fa 05             	sar    $0x5,%edx
f011dbde:	89 c8                	mov    %ecx,%eax
f011dbe0:	c1 f8 1f             	sar    $0x1f,%eax
f011dbe3:	29 c2                	sub    %eax,%edx
f011dbe5:	89 d0                	mov    %edx,%eax
f011dbe7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011dbea:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011dbed:	89 d0                	mov    %edx,%eax
f011dbef:	c1 e0 02             	shl    $0x2,%eax
f011dbf2:	01 d0                	add    %edx,%eax
f011dbf4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dbfb:	01 d0                	add    %edx,%eax
f011dbfd:	c1 e0 02             	shl    $0x2,%eax
f011dc00:	29 c1                	sub    %eax,%ecx
f011dc02:	89 c8                	mov    %ecx,%eax
f011dc04:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011dc07:	8b 15 90 c9 5e f0    	mov    0xf05ec990,%edx
f011dc0d:	a1 e0 c5 5e f0       	mov    0xf05ec5e0,%eax
f011dc12:	39 c2                	cmp    %eax,%edx
f011dc14:	0f 85 ed 00 00 00    	jne    f011dd07 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011dc1a:	a1 54 cb 5e f0       	mov    0xf05ecb54,%eax
f011dc1f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dc22:	7e 5b                	jle    f011dc7f <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011dc24:	a1 54 cb 5e f0       	mov    0xf05ecb54,%eax
f011dc29:	83 ec 08             	sub    $0x8,%esp
f011dc2c:	ff 75 e0             	pushl  -0x20(%ebp)
f011dc2f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dc32:	ff 75 e8             	pushl  -0x18(%ebp)
f011dc35:	ff 75 ec             	pushl  -0x14(%ebp)
f011dc38:	50                   	push   %eax
f011dc39:	68 28 f9 12 f0       	push   $0xf012f928
f011dc3e:	e8 48 33 fe ff       	call   f0100f8b <cprintf>
f011dc43:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011dc46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dc49:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dc4c:	0f 8f b5 00 00 00    	jg     f011dd07 <chk2+0x356>
f011dc52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dc55:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dc58:	75 0c                	jne    f011dc66 <chk2+0x2b5>
f011dc5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dc5d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011dc60:	0f 8d a1 00 00 00    	jge    f011dd07 <chk2+0x356>
f011dc66:	68 70 f9 12 f0       	push   $0xf012f970
f011dc6b:	68 53 f5 12 f0       	push   $0xf012f553
f011dc70:	68 4a 02 00 00       	push   $0x24a
f011dc75:	68 9b f5 12 f0       	push   $0xf012f59b
f011dc7a:	e8 4a 27 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011dc7f:	a1 54 cb 5e f0       	mov    0xf05ecb54,%eax
f011dc84:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dc87:	7d 53                	jge    f011dcdc <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011dc89:	a1 54 cb 5e f0       	mov    0xf05ecb54,%eax
f011dc8e:	83 ec 08             	sub    $0x8,%esp
f011dc91:	ff 75 e0             	pushl  -0x20(%ebp)
f011dc94:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dc97:	ff 75 e8             	pushl  -0x18(%ebp)
f011dc9a:	ff 75 ec             	pushl  -0x14(%ebp)
f011dc9d:	50                   	push   %eax
f011dc9e:	68 b0 f9 12 f0       	push   $0xf012f9b0
f011dca3:	e8 e3 32 fe ff       	call   f0100f8b <cprintf>
f011dca8:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011dcab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dcae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dcb1:	7c 54                	jl     f011dd07 <chk2+0x356>
f011dcb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dcb6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dcb9:	75 08                	jne    f011dcc3 <chk2+0x312>
f011dcbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dcbe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011dcc1:	7e 44                	jle    f011dd07 <chk2+0x356>
f011dcc3:	68 f8 f9 12 f0       	push   $0xf012f9f8
f011dcc8:	68 53 f5 12 f0       	push   $0xf012f553
f011dccd:	68 50 02 00 00       	push   $0x250
f011dcd2:	68 9b f5 12 f0       	push   $0xf012f59b
f011dcd7:	e8 ed 26 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011dcdc:	a1 54 cb 5e f0       	mov    0xf05ecb54,%eax
f011dce1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dce4:	75 21                	jne    f011dd07 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011dce6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dce9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dcec:	74 19                	je     f011dd07 <chk2+0x356>
f011dcee:	68 38 fa 12 f0       	push   $0xf012fa38
f011dcf3:	68 53 f5 12 f0       	push   $0xf012f553
f011dcf8:	68 54 02 00 00       	push   $0x254
f011dcfd:	68 9b f5 12 f0       	push   $0xf012f59b
f011dd02:	e8 c2 26 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011dd07:	a1 74 c6 5e f0       	mov    0xf05ec674,%eax
f011dd0c:	a3 04 cc 5e f0       	mov    %eax,0xf05ecc04
			}
		}
		__pnexit = __nnexit;
f011dd11:	a1 90 c9 5e f0       	mov    0xf05ec990,%eax
f011dd16:	a3 e0 c5 5e f0       	mov    %eax,0xf05ec5e0
f011dd1b:	eb 01                	jmp    f011dd1e <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011dd1d:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011dd1e:	c9                   	leave  
f011dd1f:	c3                   	ret    

f011dd20 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011dd20:	55                   	push   %ebp
f011dd21:	89 e5                	mov    %esp,%ebp
f011dd23:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011dd26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011dd2d:	eb 40                	jmp    f011dd6f <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011dd2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd32:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011dd38:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011dd3d:	83 ec 08             	sub    $0x8,%esp
f011dd40:	52                   	push   %edx
f011dd41:	50                   	push   %eax
f011dd42:	e8 af 01 00 00       	call   f011def6 <check_va2pa>
f011dd47:	83 c4 10             	add    $0x10,%esp
f011dd4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011dd4d:	74 19                	je     f011dd68 <check_boot_pgdir+0x48>
f011dd4f:	68 4c fa 12 f0       	push   $0xf012fa4c
f011dd54:	68 53 f5 12 f0       	push   $0xf012f553
f011dd59:	68 9b 02 00 00       	push   $0x29b
f011dd5e:	68 9b f5 12 f0       	push   $0xf012f59b
f011dd63:	e8 d1 25 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011dd68:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011dd6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd72:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011dd78:	a1 58 cb 5e f0       	mov    0xf05ecb58,%eax
f011dd7d:	39 c2                	cmp    %eax,%edx
f011dd7f:	72 ae                	jb     f011dd2f <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011dd81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011dd88:	e9 81 00 00 00       	jmp    f011de0e <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011dd8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd90:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011dd95:	85 c0                	test   %eax,%eax
f011dd97:	74 6d                	je     f011de06 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011dd99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd9c:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011dda2:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011dda7:	83 ec 08             	sub    $0x8,%esp
f011ddaa:	52                   	push   %edx
f011ddab:	50                   	push   %eax
f011ddac:	e8 45 01 00 00       	call   f011def6 <check_va2pa>
f011ddb1:	83 c4 10             	add    $0x10,%esp
f011ddb4:	c7 45 f0 00 30 17 f0 	movl   $0xf0173000,-0x10(%ebp)
f011ddbb:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011ddc2:	77 17                	ja     f011dddb <check_boot_pgdir+0xbb>
f011ddc4:	ff 75 f0             	pushl  -0x10(%ebp)
f011ddc7:	68 84 fa 12 f0       	push   $0xf012fa84
f011ddcc:	68 a9 02 00 00       	push   $0x2a9
f011ddd1:	68 9b f5 12 f0       	push   $0xf012f59b
f011ddd6:	e8 5e 25 fe ff       	call   f0100339 <_panic>
f011dddb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ddde:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011dde4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dde7:	01 ca                	add    %ecx,%edx
f011dde9:	39 d0                	cmp    %edx,%eax
f011ddeb:	74 1a                	je     f011de07 <check_boot_pgdir+0xe7>
f011dded:	68 b8 fa 12 f0       	push   $0xf012fab8
f011ddf2:	68 53 f5 12 f0       	push   $0xf012f553
f011ddf7:	68 a9 02 00 00       	push   $0x2a9
f011ddfc:	68 9b f5 12 f0       	push   $0xf012f59b
f011de01:	e8 33 25 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011de06:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011de07:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011de0e:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011de15:	0f 86 72 ff ff ff    	jbe    f011dd8d <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011de1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011de22:	e9 af 00 00 00       	jmp    f011ded6 <check_boot_pgdir+0x1b6>
		switch (i) {
f011de27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de2a:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011de2f:	74 11                	je     f011de42 <check_boot_pgdir+0x122>
f011de31:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011de36:	72 36                	jb     f011de6e <check_boot_pgdir+0x14e>
f011de38:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011de3d:	83 f8 02             	cmp    $0x2,%eax
f011de40:	77 2c                	ja     f011de6e <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011de42:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011de47:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011de4a:	c1 e2 02             	shl    $0x2,%edx
f011de4d:	01 d0                	add    %edx,%eax
f011de4f:	8b 00                	mov    (%eax),%eax
f011de51:	85 c0                	test   %eax,%eax
f011de53:	75 7a                	jne    f011decf <check_boot_pgdir+0x1af>
f011de55:	68 3e fb 12 f0       	push   $0xf012fb3e
f011de5a:	68 53 f5 12 f0       	push   $0xf012f553
f011de5f:	68 b4 02 00 00       	push   $0x2b4
f011de64:	68 9b f5 12 f0       	push   $0xf012f59b
f011de69:	e8 cb 24 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011de6e:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011de75:	76 2c                	jbe    f011dea3 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011de77:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011de7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011de7f:	c1 e2 02             	shl    $0x2,%edx
f011de82:	01 d0                	add    %edx,%eax
f011de84:	8b 00                	mov    (%eax),%eax
f011de86:	85 c0                	test   %eax,%eax
f011de88:	75 48                	jne    f011ded2 <check_boot_pgdir+0x1b2>
f011de8a:	68 3e fb 12 f0       	push   $0xf012fb3e
f011de8f:	68 53 f5 12 f0       	push   $0xf012f553
f011de94:	68 b8 02 00 00       	push   $0x2b8
f011de99:	68 9b f5 12 f0       	push   $0xf012f59b
f011de9e:	e8 96 24 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011dea3:	a1 5c cb 5e f0       	mov    0xf05ecb5c,%eax
f011dea8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011deab:	c1 e2 02             	shl    $0x2,%edx
f011deae:	01 d0                	add    %edx,%eax
f011deb0:	8b 00                	mov    (%eax),%eax
f011deb2:	85 c0                	test   %eax,%eax
f011deb4:	74 1c                	je     f011ded2 <check_boot_pgdir+0x1b2>
f011deb6:	68 54 fb 12 f0       	push   $0xf012fb54
f011debb:	68 53 f5 12 f0       	push   $0xf012f553
f011dec0:	68 ba 02 00 00       	push   $0x2ba
f011dec5:	68 9b f5 12 f0       	push   $0xf012f59b
f011deca:	e8 6a 24 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011decf:	90                   	nop
f011ded0:	eb 01                	jmp    f011ded3 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011ded2:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011ded3:	ff 45 f4             	incl   -0xc(%ebp)
f011ded6:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011dedd:	0f 86 44 ff ff ff    	jbe    f011de27 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011dee3:	83 ec 0c             	sub    $0xc,%esp
f011dee6:	68 70 fb 12 f0       	push   $0xf012fb70
f011deeb:	e8 9b 30 fe ff       	call   f0100f8b <cprintf>
f011def0:	83 c4 10             	add    $0x10,%esp
}
f011def3:	90                   	nop
f011def4:	c9                   	leave  
f011def5:	c3                   	ret    

f011def6 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011def6:	55                   	push   %ebp
f011def7:	89 e5                	mov    %esp,%ebp
f011def9:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011defc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011deff:	c1 e8 16             	shr    $0x16,%eax
f011df02:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011df09:	8b 45 08             	mov    0x8(%ebp),%eax
f011df0c:	01 d0                	add    %edx,%eax
f011df0e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011df11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011df14:	8b 00                	mov    (%eax),%eax
f011df16:	83 e0 01             	and    $0x1,%eax
f011df19:	85 c0                	test   %eax,%eax
f011df1b:	75 0a                	jne    f011df27 <check_va2pa+0x31>
		return ~0;
f011df1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011df22:	e9 87 00 00 00       	jmp    f011dfae <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011df27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011df2a:	8b 00                	mov    (%eax),%eax
f011df2c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011df31:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011df34:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011df37:	c1 e8 0c             	shr    $0xc,%eax
f011df3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011df3d:	a1 38 c7 5e f0       	mov    0xf05ec738,%eax
f011df42:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011df45:	72 17                	jb     f011df5e <check_va2pa+0x68>
f011df47:	ff 75 f0             	pushl  -0x10(%ebp)
f011df4a:	68 94 fb 12 f0       	push   $0xf012fb94
f011df4f:	68 d0 02 00 00       	push   $0x2d0
f011df54:	68 9b f5 12 f0       	push   $0xf012f59b
f011df59:	e8 db 23 fe ff       	call   f0100339 <_panic>
f011df5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011df61:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011df66:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011df69:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df6c:	c1 e8 0c             	shr    $0xc,%eax
f011df6f:	25 ff 03 00 00       	and    $0x3ff,%eax
f011df74:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011df7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011df7e:	01 d0                	add    %edx,%eax
f011df80:	8b 00                	mov    (%eax),%eax
f011df82:	83 e0 01             	and    $0x1,%eax
f011df85:	85 c0                	test   %eax,%eax
f011df87:	75 07                	jne    f011df90 <check_va2pa+0x9a>
		return ~0;
f011df89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011df8e:	eb 1e                	jmp    f011dfae <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011df90:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df93:	c1 e8 0c             	shr    $0xc,%eax
f011df96:	25 ff 03 00 00       	and    $0x3ff,%eax
f011df9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dfa2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dfa5:	01 d0                	add    %edx,%eax
f011dfa7:	8b 00                	mov    (%eax),%eax
f011dfa9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011dfae:	c9                   	leave  
f011dfaf:	c3                   	ret    

f011dfb0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011dfb0:	55                   	push   %ebp
f011dfb1:	89 e5                	mov    %esp,%ebp
f011dfb3:	53                   	push   %ebx
f011dfb4:	83 ec 14             	sub    $0x14,%esp
f011dfb7:	8b 45 10             	mov    0x10(%ebp),%eax
f011dfba:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011dfbd:	8b 45 14             	mov    0x14(%ebp),%eax
f011dfc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011dfc3:	8b 45 18             	mov    0x18(%ebp),%eax
f011dfc6:	ba 00 00 00 00       	mov    $0x0,%edx
f011dfcb:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011dfce:	77 55                	ja     f011e025 <printnum+0x75>
f011dfd0:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011dfd3:	72 05                	jb     f011dfda <printnum+0x2a>
f011dfd5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011dfd8:	77 4b                	ja     f011e025 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011dfda:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011dfdd:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011dfe0:	8b 45 18             	mov    0x18(%ebp),%eax
f011dfe3:	ba 00 00 00 00       	mov    $0x0,%edx
f011dfe8:	52                   	push   %edx
f011dfe9:	50                   	push   %eax
f011dfea:	ff 75 f4             	pushl  -0xc(%ebp)
f011dfed:	ff 75 f0             	pushl  -0x10(%ebp)
f011dff0:	e8 6f 2d 00 00       	call   f0120d64 <__udivdi3>
f011dff5:	83 c4 10             	add    $0x10,%esp
f011dff8:	83 ec 04             	sub    $0x4,%esp
f011dffb:	ff 75 20             	pushl  0x20(%ebp)
f011dffe:	53                   	push   %ebx
f011dfff:	ff 75 18             	pushl  0x18(%ebp)
f011e002:	52                   	push   %edx
f011e003:	50                   	push   %eax
f011e004:	ff 75 0c             	pushl  0xc(%ebp)
f011e007:	ff 75 08             	pushl  0x8(%ebp)
f011e00a:	e8 a1 ff ff ff       	call   f011dfb0 <printnum>
f011e00f:	83 c4 20             	add    $0x20,%esp
f011e012:	eb 1a                	jmp    f011e02e <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011e014:	83 ec 08             	sub    $0x8,%esp
f011e017:	ff 75 0c             	pushl  0xc(%ebp)
f011e01a:	ff 75 20             	pushl  0x20(%ebp)
f011e01d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e020:	ff d0                	call   *%eax
f011e022:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011e025:	ff 4d 1c             	decl   0x1c(%ebp)
f011e028:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011e02c:	7f e6                	jg     f011e014 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011e02e:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011e031:	bb 00 00 00 00       	mov    $0x0,%ebx
f011e036:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e039:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e03c:	53                   	push   %ebx
f011e03d:	51                   	push   %ecx
f011e03e:	52                   	push   %edx
f011e03f:	50                   	push   %eax
f011e040:	e8 2f 2e 00 00       	call   f0120e74 <__umoddi3>
f011e045:	83 c4 10             	add    $0x10,%esp
f011e048:	05 f4 fd 12 f0       	add    $0xf012fdf4,%eax
f011e04d:	8a 00                	mov    (%eax),%al
f011e04f:	0f be c0             	movsbl %al,%eax
f011e052:	83 ec 08             	sub    $0x8,%esp
f011e055:	ff 75 0c             	pushl  0xc(%ebp)
f011e058:	50                   	push   %eax
f011e059:	8b 45 08             	mov    0x8(%ebp),%eax
f011e05c:	ff d0                	call   *%eax
f011e05e:	83 c4 10             	add    $0x10,%esp
}
f011e061:	90                   	nop
f011e062:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011e065:	c9                   	leave  
f011e066:	c3                   	ret    

f011e067 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011e067:	55                   	push   %ebp
f011e068:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011e06a:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011e06e:	7e 1c                	jle    f011e08c <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011e070:	8b 45 08             	mov    0x8(%ebp),%eax
f011e073:	8b 00                	mov    (%eax),%eax
f011e075:	8d 50 08             	lea    0x8(%eax),%edx
f011e078:	8b 45 08             	mov    0x8(%ebp),%eax
f011e07b:	89 10                	mov    %edx,(%eax)
f011e07d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e080:	8b 00                	mov    (%eax),%eax
f011e082:	83 e8 08             	sub    $0x8,%eax
f011e085:	8b 50 04             	mov    0x4(%eax),%edx
f011e088:	8b 00                	mov    (%eax),%eax
f011e08a:	eb 40                	jmp    f011e0cc <getuint+0x65>
	else if (lflag)
f011e08c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e090:	74 1e                	je     f011e0b0 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011e092:	8b 45 08             	mov    0x8(%ebp),%eax
f011e095:	8b 00                	mov    (%eax),%eax
f011e097:	8d 50 04             	lea    0x4(%eax),%edx
f011e09a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e09d:	89 10                	mov    %edx,(%eax)
f011e09f:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0a2:	8b 00                	mov    (%eax),%eax
f011e0a4:	83 e8 04             	sub    $0x4,%eax
f011e0a7:	8b 00                	mov    (%eax),%eax
f011e0a9:	ba 00 00 00 00       	mov    $0x0,%edx
f011e0ae:	eb 1c                	jmp    f011e0cc <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011e0b0:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0b3:	8b 00                	mov    (%eax),%eax
f011e0b5:	8d 50 04             	lea    0x4(%eax),%edx
f011e0b8:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0bb:	89 10                	mov    %edx,(%eax)
f011e0bd:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0c0:	8b 00                	mov    (%eax),%eax
f011e0c2:	83 e8 04             	sub    $0x4,%eax
f011e0c5:	8b 00                	mov    (%eax),%eax
f011e0c7:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011e0cc:	5d                   	pop    %ebp
f011e0cd:	c3                   	ret    

f011e0ce <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011e0ce:	55                   	push   %ebp
f011e0cf:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011e0d1:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011e0d5:	7e 1c                	jle    f011e0f3 <getint+0x25>
		return va_arg(*ap, long long);
f011e0d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0da:	8b 00                	mov    (%eax),%eax
f011e0dc:	8d 50 08             	lea    0x8(%eax),%edx
f011e0df:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0e2:	89 10                	mov    %edx,(%eax)
f011e0e4:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0e7:	8b 00                	mov    (%eax),%eax
f011e0e9:	83 e8 08             	sub    $0x8,%eax
f011e0ec:	8b 50 04             	mov    0x4(%eax),%edx
f011e0ef:	8b 00                	mov    (%eax),%eax
f011e0f1:	eb 38                	jmp    f011e12b <getint+0x5d>
	else if (lflag)
f011e0f3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e0f7:	74 1a                	je     f011e113 <getint+0x45>
		return va_arg(*ap, long);
f011e0f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0fc:	8b 00                	mov    (%eax),%eax
f011e0fe:	8d 50 04             	lea    0x4(%eax),%edx
f011e101:	8b 45 08             	mov    0x8(%ebp),%eax
f011e104:	89 10                	mov    %edx,(%eax)
f011e106:	8b 45 08             	mov    0x8(%ebp),%eax
f011e109:	8b 00                	mov    (%eax),%eax
f011e10b:	83 e8 04             	sub    $0x4,%eax
f011e10e:	8b 00                	mov    (%eax),%eax
f011e110:	99                   	cltd   
f011e111:	eb 18                	jmp    f011e12b <getint+0x5d>
	else
		return va_arg(*ap, int);
f011e113:	8b 45 08             	mov    0x8(%ebp),%eax
f011e116:	8b 00                	mov    (%eax),%eax
f011e118:	8d 50 04             	lea    0x4(%eax),%edx
f011e11b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e11e:	89 10                	mov    %edx,(%eax)
f011e120:	8b 45 08             	mov    0x8(%ebp),%eax
f011e123:	8b 00                	mov    (%eax),%eax
f011e125:	83 e8 04             	sub    $0x4,%eax
f011e128:	8b 00                	mov    (%eax),%eax
f011e12a:	99                   	cltd   
}
f011e12b:	5d                   	pop    %ebp
f011e12c:	c3                   	ret    

f011e12d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011e12d:	55                   	push   %ebp
f011e12e:	89 e5                	mov    %esp,%ebp
f011e130:	56                   	push   %esi
f011e131:	53                   	push   %ebx
f011e132:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011e135:	eb 17                	jmp    f011e14e <vprintfmt+0x21>
			if (ch == '\0')
f011e137:	85 db                	test   %ebx,%ebx
f011e139:	0f 84 c1 03 00 00    	je     f011e500 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011e13f:	83 ec 08             	sub    $0x8,%esp
f011e142:	ff 75 0c             	pushl  0xc(%ebp)
f011e145:	53                   	push   %ebx
f011e146:	8b 45 08             	mov    0x8(%ebp),%eax
f011e149:	ff d0                	call   *%eax
f011e14b:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011e14e:	8b 45 10             	mov    0x10(%ebp),%eax
f011e151:	8d 50 01             	lea    0x1(%eax),%edx
f011e154:	89 55 10             	mov    %edx,0x10(%ebp)
f011e157:	8a 00                	mov    (%eax),%al
f011e159:	0f b6 d8             	movzbl %al,%ebx
f011e15c:	83 fb 25             	cmp    $0x25,%ebx
f011e15f:	75 d6                	jne    f011e137 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011e161:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011e165:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011e16c:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011e173:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011e17a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011e181:	8b 45 10             	mov    0x10(%ebp),%eax
f011e184:	8d 50 01             	lea    0x1(%eax),%edx
f011e187:	89 55 10             	mov    %edx,0x10(%ebp)
f011e18a:	8a 00                	mov    (%eax),%al
f011e18c:	0f b6 d8             	movzbl %al,%ebx
f011e18f:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011e192:	83 f8 5b             	cmp    $0x5b,%eax
f011e195:	0f 87 3d 03 00 00    	ja     f011e4d8 <vprintfmt+0x3ab>
f011e19b:	8b 04 85 18 fe 12 f0 	mov    -0xfed01e8(,%eax,4),%eax
f011e1a2:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011e1a4:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011e1a8:	eb d7                	jmp    f011e181 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011e1aa:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011e1ae:	eb d1                	jmp    f011e181 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011e1b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011e1b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011e1ba:	89 d0                	mov    %edx,%eax
f011e1bc:	c1 e0 02             	shl    $0x2,%eax
f011e1bf:	01 d0                	add    %edx,%eax
f011e1c1:	01 c0                	add    %eax,%eax
f011e1c3:	01 d8                	add    %ebx,%eax
f011e1c5:	83 e8 30             	sub    $0x30,%eax
f011e1c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011e1cb:	8b 45 10             	mov    0x10(%ebp),%eax
f011e1ce:	8a 00                	mov    (%eax),%al
f011e1d0:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011e1d3:	83 fb 2f             	cmp    $0x2f,%ebx
f011e1d6:	7e 3e                	jle    f011e216 <vprintfmt+0xe9>
f011e1d8:	83 fb 39             	cmp    $0x39,%ebx
f011e1db:	7f 39                	jg     f011e216 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011e1dd:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011e1e0:	eb d5                	jmp    f011e1b7 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011e1e2:	8b 45 14             	mov    0x14(%ebp),%eax
f011e1e5:	83 c0 04             	add    $0x4,%eax
f011e1e8:	89 45 14             	mov    %eax,0x14(%ebp)
f011e1eb:	8b 45 14             	mov    0x14(%ebp),%eax
f011e1ee:	83 e8 04             	sub    $0x4,%eax
f011e1f1:	8b 00                	mov    (%eax),%eax
f011e1f3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011e1f6:	eb 1f                	jmp    f011e217 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011e1f8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e1fc:	79 83                	jns    f011e181 <vprintfmt+0x54>
				width = 0;
f011e1fe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011e205:	e9 77 ff ff ff       	jmp    f011e181 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011e20a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011e211:	e9 6b ff ff ff       	jmp    f011e181 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011e216:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011e217:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e21b:	0f 89 60 ff ff ff    	jns    f011e181 <vprintfmt+0x54>
				width = precision, precision = -1;
f011e221:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e224:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e227:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011e22e:	e9 4e ff ff ff       	jmp    f011e181 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011e233:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011e236:	e9 46 ff ff ff       	jmp    f011e181 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011e23b:	8b 45 14             	mov    0x14(%ebp),%eax
f011e23e:	83 c0 04             	add    $0x4,%eax
f011e241:	89 45 14             	mov    %eax,0x14(%ebp)
f011e244:	8b 45 14             	mov    0x14(%ebp),%eax
f011e247:	83 e8 04             	sub    $0x4,%eax
f011e24a:	8b 00                	mov    (%eax),%eax
f011e24c:	83 ec 08             	sub    $0x8,%esp
f011e24f:	ff 75 0c             	pushl  0xc(%ebp)
f011e252:	50                   	push   %eax
f011e253:	8b 45 08             	mov    0x8(%ebp),%eax
f011e256:	ff d0                	call   *%eax
f011e258:	83 c4 10             	add    $0x10,%esp
			break;
f011e25b:	e9 9b 02 00 00       	jmp    f011e4fb <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011e260:	8b 45 14             	mov    0x14(%ebp),%eax
f011e263:	83 c0 04             	add    $0x4,%eax
f011e266:	89 45 14             	mov    %eax,0x14(%ebp)
f011e269:	8b 45 14             	mov    0x14(%ebp),%eax
f011e26c:	83 e8 04             	sub    $0x4,%eax
f011e26f:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011e271:	85 db                	test   %ebx,%ebx
f011e273:	79 02                	jns    f011e277 <vprintfmt+0x14a>
				err = -err;
f011e275:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011e277:	83 fb 64             	cmp    $0x64,%ebx
f011e27a:	7f 0b                	jg     f011e287 <vprintfmt+0x15a>
f011e27c:	8b 34 9d 60 fc 12 f0 	mov    -0xfed03a0(,%ebx,4),%esi
f011e283:	85 f6                	test   %esi,%esi
f011e285:	75 19                	jne    f011e2a0 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011e287:	53                   	push   %ebx
f011e288:	68 05 fe 12 f0       	push   $0xf012fe05
f011e28d:	ff 75 0c             	pushl  0xc(%ebp)
f011e290:	ff 75 08             	pushl  0x8(%ebp)
f011e293:	e8 70 02 00 00       	call   f011e508 <printfmt>
f011e298:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011e29b:	e9 5b 02 00 00       	jmp    f011e4fb <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011e2a0:	56                   	push   %esi
f011e2a1:	68 0e fe 12 f0       	push   $0xf012fe0e
f011e2a6:	ff 75 0c             	pushl  0xc(%ebp)
f011e2a9:	ff 75 08             	pushl  0x8(%ebp)
f011e2ac:	e8 57 02 00 00       	call   f011e508 <printfmt>
f011e2b1:	83 c4 10             	add    $0x10,%esp
			break;
f011e2b4:	e9 42 02 00 00       	jmp    f011e4fb <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011e2b9:	8b 45 14             	mov    0x14(%ebp),%eax
f011e2bc:	83 c0 04             	add    $0x4,%eax
f011e2bf:	89 45 14             	mov    %eax,0x14(%ebp)
f011e2c2:	8b 45 14             	mov    0x14(%ebp),%eax
f011e2c5:	83 e8 04             	sub    $0x4,%eax
f011e2c8:	8b 30                	mov    (%eax),%esi
f011e2ca:	85 f6                	test   %esi,%esi
f011e2cc:	75 05                	jne    f011e2d3 <vprintfmt+0x1a6>
				p = "(null)";
f011e2ce:	be 11 fe 12 f0       	mov    $0xf012fe11,%esi
			if (width > 0 && padc != '-')
f011e2d3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e2d7:	7e 6d                	jle    f011e346 <vprintfmt+0x219>
f011e2d9:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011e2dd:	74 67                	je     f011e346 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011e2df:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e2e2:	83 ec 08             	sub    $0x8,%esp
f011e2e5:	50                   	push   %eax
f011e2e6:	56                   	push   %esi
f011e2e7:	e8 26 05 00 00       	call   f011e812 <strnlen>
f011e2ec:	83 c4 10             	add    $0x10,%esp
f011e2ef:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011e2f2:	eb 16                	jmp    f011e30a <vprintfmt+0x1dd>
					putch(padc, putdat);
f011e2f4:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011e2f8:	83 ec 08             	sub    $0x8,%esp
f011e2fb:	ff 75 0c             	pushl  0xc(%ebp)
f011e2fe:	50                   	push   %eax
f011e2ff:	8b 45 08             	mov    0x8(%ebp),%eax
f011e302:	ff d0                	call   *%eax
f011e304:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011e307:	ff 4d e4             	decl   -0x1c(%ebp)
f011e30a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e30e:	7f e4                	jg     f011e2f4 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011e310:	eb 34                	jmp    f011e346 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011e312:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e316:	74 1c                	je     f011e334 <vprintfmt+0x207>
f011e318:	83 fb 1f             	cmp    $0x1f,%ebx
f011e31b:	7e 05                	jle    f011e322 <vprintfmt+0x1f5>
f011e31d:	83 fb 7e             	cmp    $0x7e,%ebx
f011e320:	7e 12                	jle    f011e334 <vprintfmt+0x207>
					putch('?', putdat);
f011e322:	83 ec 08             	sub    $0x8,%esp
f011e325:	ff 75 0c             	pushl  0xc(%ebp)
f011e328:	6a 3f                	push   $0x3f
f011e32a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e32d:	ff d0                	call   *%eax
f011e32f:	83 c4 10             	add    $0x10,%esp
f011e332:	eb 0f                	jmp    f011e343 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011e334:	83 ec 08             	sub    $0x8,%esp
f011e337:	ff 75 0c             	pushl  0xc(%ebp)
f011e33a:	53                   	push   %ebx
f011e33b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e33e:	ff d0                	call   *%eax
f011e340:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011e343:	ff 4d e4             	decl   -0x1c(%ebp)
f011e346:	89 f0                	mov    %esi,%eax
f011e348:	8d 70 01             	lea    0x1(%eax),%esi
f011e34b:	8a 00                	mov    (%eax),%al
f011e34d:	0f be d8             	movsbl %al,%ebx
f011e350:	85 db                	test   %ebx,%ebx
f011e352:	74 24                	je     f011e378 <vprintfmt+0x24b>
f011e354:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011e358:	78 b8                	js     f011e312 <vprintfmt+0x1e5>
f011e35a:	ff 4d e0             	decl   -0x20(%ebp)
f011e35d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011e361:	79 af                	jns    f011e312 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011e363:	eb 13                	jmp    f011e378 <vprintfmt+0x24b>
				putch(' ', putdat);
f011e365:	83 ec 08             	sub    $0x8,%esp
f011e368:	ff 75 0c             	pushl  0xc(%ebp)
f011e36b:	6a 20                	push   $0x20
f011e36d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e370:	ff d0                	call   *%eax
f011e372:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011e375:	ff 4d e4             	decl   -0x1c(%ebp)
f011e378:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e37c:	7f e7                	jg     f011e365 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011e37e:	e9 78 01 00 00       	jmp    f011e4fb <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011e383:	83 ec 08             	sub    $0x8,%esp
f011e386:	ff 75 e8             	pushl  -0x18(%ebp)
f011e389:	8d 45 14             	lea    0x14(%ebp),%eax
f011e38c:	50                   	push   %eax
f011e38d:	e8 3c fd ff ff       	call   f011e0ce <getint>
f011e392:	83 c4 10             	add    $0x10,%esp
f011e395:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e398:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011e39b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e39e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e3a1:	85 d2                	test   %edx,%edx
f011e3a3:	79 23                	jns    f011e3c8 <vprintfmt+0x29b>
				putch('-', putdat);
f011e3a5:	83 ec 08             	sub    $0x8,%esp
f011e3a8:	ff 75 0c             	pushl  0xc(%ebp)
f011e3ab:	6a 2d                	push   $0x2d
f011e3ad:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3b0:	ff d0                	call   *%eax
f011e3b2:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011e3b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e3b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e3bb:	f7 d8                	neg    %eax
f011e3bd:	83 d2 00             	adc    $0x0,%edx
f011e3c0:	f7 da                	neg    %edx
f011e3c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e3c5:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011e3c8:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011e3cf:	e9 bc 00 00 00       	jmp    f011e490 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011e3d4:	83 ec 08             	sub    $0x8,%esp
f011e3d7:	ff 75 e8             	pushl  -0x18(%ebp)
f011e3da:	8d 45 14             	lea    0x14(%ebp),%eax
f011e3dd:	50                   	push   %eax
f011e3de:	e8 84 fc ff ff       	call   f011e067 <getuint>
f011e3e3:	83 c4 10             	add    $0x10,%esp
f011e3e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e3e9:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011e3ec:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011e3f3:	e9 98 00 00 00       	jmp    f011e490 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011e3f8:	83 ec 08             	sub    $0x8,%esp
f011e3fb:	ff 75 0c             	pushl  0xc(%ebp)
f011e3fe:	6a 58                	push   $0x58
f011e400:	8b 45 08             	mov    0x8(%ebp),%eax
f011e403:	ff d0                	call   *%eax
f011e405:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011e408:	83 ec 08             	sub    $0x8,%esp
f011e40b:	ff 75 0c             	pushl  0xc(%ebp)
f011e40e:	6a 58                	push   $0x58
f011e410:	8b 45 08             	mov    0x8(%ebp),%eax
f011e413:	ff d0                	call   *%eax
f011e415:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011e418:	83 ec 08             	sub    $0x8,%esp
f011e41b:	ff 75 0c             	pushl  0xc(%ebp)
f011e41e:	6a 58                	push   $0x58
f011e420:	8b 45 08             	mov    0x8(%ebp),%eax
f011e423:	ff d0                	call   *%eax
f011e425:	83 c4 10             	add    $0x10,%esp
			break;
f011e428:	e9 ce 00 00 00       	jmp    f011e4fb <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011e42d:	83 ec 08             	sub    $0x8,%esp
f011e430:	ff 75 0c             	pushl  0xc(%ebp)
f011e433:	6a 30                	push   $0x30
f011e435:	8b 45 08             	mov    0x8(%ebp),%eax
f011e438:	ff d0                	call   *%eax
f011e43a:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011e43d:	83 ec 08             	sub    $0x8,%esp
f011e440:	ff 75 0c             	pushl  0xc(%ebp)
f011e443:	6a 78                	push   $0x78
f011e445:	8b 45 08             	mov    0x8(%ebp),%eax
f011e448:	ff d0                	call   *%eax
f011e44a:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011e44d:	8b 45 14             	mov    0x14(%ebp),%eax
f011e450:	83 c0 04             	add    $0x4,%eax
f011e453:	89 45 14             	mov    %eax,0x14(%ebp)
f011e456:	8b 45 14             	mov    0x14(%ebp),%eax
f011e459:	83 e8 04             	sub    $0x4,%eax
f011e45c:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011e45e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e461:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011e468:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011e46f:	eb 1f                	jmp    f011e490 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011e471:	83 ec 08             	sub    $0x8,%esp
f011e474:	ff 75 e8             	pushl  -0x18(%ebp)
f011e477:	8d 45 14             	lea    0x14(%ebp),%eax
f011e47a:	50                   	push   %eax
f011e47b:	e8 e7 fb ff ff       	call   f011e067 <getuint>
f011e480:	83 c4 10             	add    $0x10,%esp
f011e483:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e486:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011e489:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011e490:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011e494:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e497:	83 ec 04             	sub    $0x4,%esp
f011e49a:	52                   	push   %edx
f011e49b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e49e:	50                   	push   %eax
f011e49f:	ff 75 f4             	pushl  -0xc(%ebp)
f011e4a2:	ff 75 f0             	pushl  -0x10(%ebp)
f011e4a5:	ff 75 0c             	pushl  0xc(%ebp)
f011e4a8:	ff 75 08             	pushl  0x8(%ebp)
f011e4ab:	e8 00 fb ff ff       	call   f011dfb0 <printnum>
f011e4b0:	83 c4 20             	add    $0x20,%esp
			break;
f011e4b3:	eb 46                	jmp    f011e4fb <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011e4b5:	83 ec 08             	sub    $0x8,%esp
f011e4b8:	ff 75 0c             	pushl  0xc(%ebp)
f011e4bb:	53                   	push   %ebx
f011e4bc:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4bf:	ff d0                	call   *%eax
f011e4c1:	83 c4 10             	add    $0x10,%esp
			break;
f011e4c4:	eb 35                	jmp    f011e4fb <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011e4c6:	c6 05 80 c4 5e f0 00 	movb   $0x0,0xf05ec480
			break;
f011e4cd:	eb 2c                	jmp    f011e4fb <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011e4cf:	c6 05 80 c4 5e f0 01 	movb   $0x1,0xf05ec480
			break;
f011e4d6:	eb 23                	jmp    f011e4fb <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011e4d8:	83 ec 08             	sub    $0x8,%esp
f011e4db:	ff 75 0c             	pushl  0xc(%ebp)
f011e4de:	6a 25                	push   $0x25
f011e4e0:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4e3:	ff d0                	call   *%eax
f011e4e5:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011e4e8:	ff 4d 10             	decl   0x10(%ebp)
f011e4eb:	eb 03                	jmp    f011e4f0 <vprintfmt+0x3c3>
f011e4ed:	ff 4d 10             	decl   0x10(%ebp)
f011e4f0:	8b 45 10             	mov    0x10(%ebp),%eax
f011e4f3:	48                   	dec    %eax
f011e4f4:	8a 00                	mov    (%eax),%al
f011e4f6:	3c 25                	cmp    $0x25,%al
f011e4f8:	75 f3                	jne    f011e4ed <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011e4fa:	90                   	nop
		}
	}
f011e4fb:	e9 35 fc ff ff       	jmp    f011e135 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011e500:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011e501:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011e504:	5b                   	pop    %ebx
f011e505:	5e                   	pop    %esi
f011e506:	5d                   	pop    %ebp
f011e507:	c3                   	ret    

f011e508 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011e508:	55                   	push   %ebp
f011e509:	89 e5                	mov    %esp,%ebp
f011e50b:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011e50e:	8d 45 10             	lea    0x10(%ebp),%eax
f011e511:	83 c0 04             	add    $0x4,%eax
f011e514:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011e517:	8b 45 10             	mov    0x10(%ebp),%eax
f011e51a:	ff 75 f4             	pushl  -0xc(%ebp)
f011e51d:	50                   	push   %eax
f011e51e:	ff 75 0c             	pushl  0xc(%ebp)
f011e521:	ff 75 08             	pushl  0x8(%ebp)
f011e524:	e8 04 fc ff ff       	call   f011e12d <vprintfmt>
f011e529:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011e52c:	90                   	nop
f011e52d:	c9                   	leave  
f011e52e:	c3                   	ret    

f011e52f <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011e52f:	55                   	push   %ebp
f011e530:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011e532:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e535:	8b 40 08             	mov    0x8(%eax),%eax
f011e538:	8d 50 01             	lea    0x1(%eax),%edx
f011e53b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e53e:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011e541:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e544:	8b 10                	mov    (%eax),%edx
f011e546:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e549:	8b 40 04             	mov    0x4(%eax),%eax
f011e54c:	39 c2                	cmp    %eax,%edx
f011e54e:	73 12                	jae    f011e562 <sprintputch+0x33>
		*b->buf++ = ch;
f011e550:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e553:	8b 00                	mov    (%eax),%eax
f011e555:	8d 48 01             	lea    0x1(%eax),%ecx
f011e558:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e55b:	89 0a                	mov    %ecx,(%edx)
f011e55d:	8b 55 08             	mov    0x8(%ebp),%edx
f011e560:	88 10                	mov    %dl,(%eax)
}
f011e562:	90                   	nop
f011e563:	5d                   	pop    %ebp
f011e564:	c3                   	ret    

f011e565 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011e565:	55                   	push   %ebp
f011e566:	89 e5                	mov    %esp,%ebp
f011e568:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011e56b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e56e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e571:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e574:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e577:	8b 45 08             	mov    0x8(%ebp),%eax
f011e57a:	01 d0                	add    %edx,%eax
f011e57c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e57f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011e586:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e58a:	74 06                	je     f011e592 <vsnprintf+0x2d>
f011e58c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e590:	7f 07                	jg     f011e599 <vsnprintf+0x34>
		return -E_INVAL;
f011e592:	b8 03 00 00 00       	mov    $0x3,%eax
f011e597:	eb 20                	jmp    f011e5b9 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011e599:	ff 75 14             	pushl  0x14(%ebp)
f011e59c:	ff 75 10             	pushl  0x10(%ebp)
f011e59f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011e5a2:	50                   	push   %eax
f011e5a3:	68 2f e5 11 f0       	push   $0xf011e52f
f011e5a8:	e8 80 fb ff ff       	call   f011e12d <vprintfmt>
f011e5ad:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011e5b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e5b3:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011e5b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011e5b9:	c9                   	leave  
f011e5ba:	c3                   	ret    

f011e5bb <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011e5bb:	55                   	push   %ebp
f011e5bc:	89 e5                	mov    %esp,%ebp
f011e5be:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011e5c1:	8d 45 10             	lea    0x10(%ebp),%eax
f011e5c4:	83 c0 04             	add    $0x4,%eax
f011e5c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011e5ca:	8b 45 10             	mov    0x10(%ebp),%eax
f011e5cd:	ff 75 f4             	pushl  -0xc(%ebp)
f011e5d0:	50                   	push   %eax
f011e5d1:	ff 75 0c             	pushl  0xc(%ebp)
f011e5d4:	ff 75 08             	pushl  0x8(%ebp)
f011e5d7:	e8 89 ff ff ff       	call   f011e565 <vsnprintf>
f011e5dc:	83 c4 10             	add    $0x10,%esp
f011e5df:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011e5e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011e5e5:	c9                   	leave  
f011e5e6:	c3                   	ret    

f011e5e7 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011e5e7:	55                   	push   %ebp
f011e5e8:	89 e5                	mov    %esp,%ebp
f011e5ea:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011e5ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e5f1:	74 13                	je     f011e606 <readline+0x1f>
		cprintf("%s", prompt);
f011e5f3:	83 ec 08             	sub    $0x8,%esp
f011e5f6:	ff 75 08             	pushl  0x8(%ebp)
f011e5f9:	68 88 ff 12 f0       	push   $0xf012ff88
f011e5fe:	e8 88 29 fe ff       	call   f0100f8b <cprintf>
f011e603:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011e606:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011e60d:	83 ec 0c             	sub    $0xc,%esp
f011e610:	6a 00                	push   $0x0
f011e612:	e8 81 28 fe ff       	call   f0100e98 <iscons>
f011e617:	83 c4 10             	add    $0x10,%esp
f011e61a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011e61d:	e8 5d 28 fe ff       	call   f0100e7f <getchar>
f011e622:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011e625:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e629:	79 22                	jns    f011e64d <readline+0x66>
			if (c != -E_EOF)
f011e62b:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011e62f:	0f 84 ad 00 00 00    	je     f011e6e2 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011e635:	83 ec 08             	sub    $0x8,%esp
f011e638:	ff 75 ec             	pushl  -0x14(%ebp)
f011e63b:	68 8b ff 12 f0       	push   $0xf012ff8b
f011e640:	e8 46 29 fe ff       	call   f0100f8b <cprintf>
f011e645:	83 c4 10             	add    $0x10,%esp
			break;
f011e648:	e9 95 00 00 00       	jmp    f011e6e2 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011e64d:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011e651:	7e 34                	jle    f011e687 <readline+0xa0>
f011e653:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011e65a:	7f 2b                	jg     f011e687 <readline+0xa0>
			if (echoing)
f011e65c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e660:	74 0e                	je     f011e670 <readline+0x89>
				cputchar(c);
f011e662:	83 ec 0c             	sub    $0xc,%esp
f011e665:	ff 75 ec             	pushl  -0x14(%ebp)
f011e668:	e8 fb 27 fe ff       	call   f0100e68 <cputchar>
f011e66d:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011e670:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e673:	8d 50 01             	lea    0x1(%eax),%edx
f011e676:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011e679:	89 c2                	mov    %eax,%edx
f011e67b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e67e:	01 d0                	add    %edx,%eax
f011e680:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011e683:	88 10                	mov    %dl,(%eax)
f011e685:	eb 56                	jmp    f011e6dd <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011e687:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011e68b:	75 1f                	jne    f011e6ac <readline+0xc5>
f011e68d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e691:	7e 19                	jle    f011e6ac <readline+0xc5>
			if (echoing)
f011e693:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e697:	74 0e                	je     f011e6a7 <readline+0xc0>
				cputchar(c);
f011e699:	83 ec 0c             	sub    $0xc,%esp
f011e69c:	ff 75 ec             	pushl  -0x14(%ebp)
f011e69f:	e8 c4 27 fe ff       	call   f0100e68 <cputchar>
f011e6a4:	83 c4 10             	add    $0x10,%esp

			i--;
f011e6a7:	ff 4d f4             	decl   -0xc(%ebp)
f011e6aa:	eb 31                	jmp    f011e6dd <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011e6ac:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011e6b0:	74 0a                	je     f011e6bc <readline+0xd5>
f011e6b2:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011e6b6:	0f 85 61 ff ff ff    	jne    f011e61d <readline+0x36>
			if (echoing)
f011e6bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e6c0:	74 0e                	je     f011e6d0 <readline+0xe9>
				cputchar(c);
f011e6c2:	83 ec 0c             	sub    $0xc,%esp
f011e6c5:	ff 75 ec             	pushl  -0x14(%ebp)
f011e6c8:	e8 9b 27 fe ff       	call   f0100e68 <cputchar>
f011e6cd:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011e6d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e6d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e6d6:	01 d0                	add    %edx,%eax
f011e6d8:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011e6db:	eb 06                	jmp    f011e6e3 <readline+0xfc>
		}
	}
f011e6dd:	e9 3b ff ff ff       	jmp    f011e61d <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011e6e2:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011e6e3:	90                   	nop
f011e6e4:	c9                   	leave  
f011e6e5:	c3                   	ret    

f011e6e6 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011e6e6:	55                   	push   %ebp
f011e6e7:	89 e5                	mov    %esp,%ebp
f011e6e9:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011e6ec:	e8 7a ee fe ff       	call   f010d56b <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011e6f1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e6f5:	74 13                	je     f011e70a <atomic_readline+0x24>
			cprintf("%s", prompt);
f011e6f7:	83 ec 08             	sub    $0x8,%esp
f011e6fa:	ff 75 08             	pushl  0x8(%ebp)
f011e6fd:	68 88 ff 12 f0       	push   $0xf012ff88
f011e702:	e8 84 28 fe ff       	call   f0100f8b <cprintf>
f011e707:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011e70a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011e711:	83 ec 0c             	sub    $0xc,%esp
f011e714:	6a 00                	push   $0x0
f011e716:	e8 7d 27 fe ff       	call   f0100e98 <iscons>
f011e71b:	83 c4 10             	add    $0x10,%esp
f011e71e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011e721:	e8 59 27 fe ff       	call   f0100e7f <getchar>
f011e726:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011e729:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e72d:	79 22                	jns    f011e751 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011e72f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011e733:	0f 84 ad 00 00 00    	je     f011e7e6 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011e739:	83 ec 08             	sub    $0x8,%esp
f011e73c:	ff 75 ec             	pushl  -0x14(%ebp)
f011e73f:	68 8b ff 12 f0       	push   $0xf012ff8b
f011e744:	e8 42 28 fe ff       	call   f0100f8b <cprintf>
f011e749:	83 c4 10             	add    $0x10,%esp
				break;
f011e74c:	e9 95 00 00 00       	jmp    f011e7e6 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011e751:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011e755:	7e 34                	jle    f011e78b <atomic_readline+0xa5>
f011e757:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011e75e:	7f 2b                	jg     f011e78b <atomic_readline+0xa5>
				if (echoing)
f011e760:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e764:	74 0e                	je     f011e774 <atomic_readline+0x8e>
					cputchar(c);
f011e766:	83 ec 0c             	sub    $0xc,%esp
f011e769:	ff 75 ec             	pushl  -0x14(%ebp)
f011e76c:	e8 f7 26 fe ff       	call   f0100e68 <cputchar>
f011e771:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011e774:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e777:	8d 50 01             	lea    0x1(%eax),%edx
f011e77a:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011e77d:	89 c2                	mov    %eax,%edx
f011e77f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e782:	01 d0                	add    %edx,%eax
f011e784:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011e787:	88 10                	mov    %dl,(%eax)
f011e789:	eb 56                	jmp    f011e7e1 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011e78b:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011e78f:	75 1f                	jne    f011e7b0 <atomic_readline+0xca>
f011e791:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e795:	7e 19                	jle    f011e7b0 <atomic_readline+0xca>
				if (echoing)
f011e797:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e79b:	74 0e                	je     f011e7ab <atomic_readline+0xc5>
					cputchar(c);
f011e79d:	83 ec 0c             	sub    $0xc,%esp
f011e7a0:	ff 75 ec             	pushl  -0x14(%ebp)
f011e7a3:	e8 c0 26 fe ff       	call   f0100e68 <cputchar>
f011e7a8:	83 c4 10             	add    $0x10,%esp
				i--;
f011e7ab:	ff 4d f4             	decl   -0xc(%ebp)
f011e7ae:	eb 31                	jmp    f011e7e1 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011e7b0:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011e7b4:	74 0a                	je     f011e7c0 <atomic_readline+0xda>
f011e7b6:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011e7ba:	0f 85 61 ff ff ff    	jne    f011e721 <atomic_readline+0x3b>
				if (echoing)
f011e7c0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e7c4:	74 0e                	je     f011e7d4 <atomic_readline+0xee>
					cputchar(c);
f011e7c6:	83 ec 0c             	sub    $0xc,%esp
f011e7c9:	ff 75 ec             	pushl  -0x14(%ebp)
f011e7cc:	e8 97 26 fe ff       	call   f0100e68 <cputchar>
f011e7d1:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011e7d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e7d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e7da:	01 d0                	add    %edx,%eax
f011e7dc:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011e7df:	eb 06                	jmp    f011e7e7 <atomic_readline+0x101>
			}
		}
f011e7e1:	e9 3b ff ff ff       	jmp    f011e721 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011e7e6:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011e7e7:	e8 8d ed fe ff       	call   f010d579 <sys_unlock_cons>
}
f011e7ec:	90                   	nop
f011e7ed:	c9                   	leave  
f011e7ee:	c3                   	ret    

f011e7ef <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011e7ef:	55                   	push   %ebp
f011e7f0:	89 e5                	mov    %esp,%ebp
f011e7f2:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011e7f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011e7fc:	eb 06                	jmp    f011e804 <strlen+0x15>
		n++;
f011e7fe:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011e801:	ff 45 08             	incl   0x8(%ebp)
f011e804:	8b 45 08             	mov    0x8(%ebp),%eax
f011e807:	8a 00                	mov    (%eax),%al
f011e809:	84 c0                	test   %al,%al
f011e80b:	75 f1                	jne    f011e7fe <strlen+0xf>
		n++;
	return n;
f011e80d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e810:	c9                   	leave  
f011e811:	c3                   	ret    

f011e812 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011e812:	55                   	push   %ebp
f011e813:	89 e5                	mov    %esp,%ebp
f011e815:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011e818:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011e81f:	eb 09                	jmp    f011e82a <strnlen+0x18>
		n++;
f011e821:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011e824:	ff 45 08             	incl   0x8(%ebp)
f011e827:	ff 4d 0c             	decl   0xc(%ebp)
f011e82a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e82e:	74 09                	je     f011e839 <strnlen+0x27>
f011e830:	8b 45 08             	mov    0x8(%ebp),%eax
f011e833:	8a 00                	mov    (%eax),%al
f011e835:	84 c0                	test   %al,%al
f011e837:	75 e8                	jne    f011e821 <strnlen+0xf>
		n++;
	return n;
f011e839:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e83c:	c9                   	leave  
f011e83d:	c3                   	ret    

f011e83e <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011e83e:	55                   	push   %ebp
f011e83f:	89 e5                	mov    %esp,%ebp
f011e841:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011e844:	8b 45 08             	mov    0x8(%ebp),%eax
f011e847:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011e84a:	90                   	nop
f011e84b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e84e:	8d 50 01             	lea    0x1(%eax),%edx
f011e851:	89 55 08             	mov    %edx,0x8(%ebp)
f011e854:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e857:	8d 4a 01             	lea    0x1(%edx),%ecx
f011e85a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011e85d:	8a 12                	mov    (%edx),%dl
f011e85f:	88 10                	mov    %dl,(%eax)
f011e861:	8a 00                	mov    (%eax),%al
f011e863:	84 c0                	test   %al,%al
f011e865:	75 e4                	jne    f011e84b <strcpy+0xd>
		/* do nothing */;
	return ret;
f011e867:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e86a:	c9                   	leave  
f011e86b:	c3                   	ret    

f011e86c <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011e86c:	55                   	push   %ebp
f011e86d:	89 e5                	mov    %esp,%ebp
f011e86f:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011e872:	8b 45 08             	mov    0x8(%ebp),%eax
f011e875:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011e878:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011e87f:	eb 1f                	jmp    f011e8a0 <strncpy+0x34>
		*dst++ = *src;
f011e881:	8b 45 08             	mov    0x8(%ebp),%eax
f011e884:	8d 50 01             	lea    0x1(%eax),%edx
f011e887:	89 55 08             	mov    %edx,0x8(%ebp)
f011e88a:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e88d:	8a 12                	mov    (%edx),%dl
f011e88f:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011e891:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e894:	8a 00                	mov    (%eax),%al
f011e896:	84 c0                	test   %al,%al
f011e898:	74 03                	je     f011e89d <strncpy+0x31>
			src++;
f011e89a:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011e89d:	ff 45 fc             	incl   -0x4(%ebp)
f011e8a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e8a3:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e8a6:	72 d9                	jb     f011e881 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011e8a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011e8ab:	c9                   	leave  
f011e8ac:	c3                   	ret    

f011e8ad <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011e8ad:	55                   	push   %ebp
f011e8ae:	89 e5                	mov    %esp,%ebp
f011e8b0:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011e8b3:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011e8b9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e8bd:	74 30                	je     f011e8ef <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011e8bf:	eb 16                	jmp    f011e8d7 <strlcpy+0x2a>
			*dst++ = *src++;
f011e8c1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8c4:	8d 50 01             	lea    0x1(%eax),%edx
f011e8c7:	89 55 08             	mov    %edx,0x8(%ebp)
f011e8ca:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e8cd:	8d 4a 01             	lea    0x1(%edx),%ecx
f011e8d0:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011e8d3:	8a 12                	mov    (%edx),%dl
f011e8d5:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011e8d7:	ff 4d 10             	decl   0x10(%ebp)
f011e8da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e8de:	74 09                	je     f011e8e9 <strlcpy+0x3c>
f011e8e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e8e3:	8a 00                	mov    (%eax),%al
f011e8e5:	84 c0                	test   %al,%al
f011e8e7:	75 d8                	jne    f011e8c1 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011e8e9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8ec:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011e8ef:	8b 55 08             	mov    0x8(%ebp),%edx
f011e8f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e8f5:	29 c2                	sub    %eax,%edx
f011e8f7:	89 d0                	mov    %edx,%eax
}
f011e8f9:	c9                   	leave  
f011e8fa:	c3                   	ret    

f011e8fb <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011e8fb:	55                   	push   %ebp
f011e8fc:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011e8fe:	eb 06                	jmp    f011e906 <strcmp+0xb>
		p++, q++;
f011e900:	ff 45 08             	incl   0x8(%ebp)
f011e903:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011e906:	8b 45 08             	mov    0x8(%ebp),%eax
f011e909:	8a 00                	mov    (%eax),%al
f011e90b:	84 c0                	test   %al,%al
f011e90d:	74 0e                	je     f011e91d <strcmp+0x22>
f011e90f:	8b 45 08             	mov    0x8(%ebp),%eax
f011e912:	8a 10                	mov    (%eax),%dl
f011e914:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e917:	8a 00                	mov    (%eax),%al
f011e919:	38 c2                	cmp    %al,%dl
f011e91b:	74 e3                	je     f011e900 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011e91d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e920:	8a 00                	mov    (%eax),%al
f011e922:	0f b6 d0             	movzbl %al,%edx
f011e925:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e928:	8a 00                	mov    (%eax),%al
f011e92a:	0f b6 c0             	movzbl %al,%eax
f011e92d:	29 c2                	sub    %eax,%edx
f011e92f:	89 d0                	mov    %edx,%eax
}
f011e931:	5d                   	pop    %ebp
f011e932:	c3                   	ret    

f011e933 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011e933:	55                   	push   %ebp
f011e934:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011e936:	eb 09                	jmp    f011e941 <strncmp+0xe>
		n--, p++, q++;
f011e938:	ff 4d 10             	decl   0x10(%ebp)
f011e93b:	ff 45 08             	incl   0x8(%ebp)
f011e93e:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011e941:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e945:	74 17                	je     f011e95e <strncmp+0x2b>
f011e947:	8b 45 08             	mov    0x8(%ebp),%eax
f011e94a:	8a 00                	mov    (%eax),%al
f011e94c:	84 c0                	test   %al,%al
f011e94e:	74 0e                	je     f011e95e <strncmp+0x2b>
f011e950:	8b 45 08             	mov    0x8(%ebp),%eax
f011e953:	8a 10                	mov    (%eax),%dl
f011e955:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e958:	8a 00                	mov    (%eax),%al
f011e95a:	38 c2                	cmp    %al,%dl
f011e95c:	74 da                	je     f011e938 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011e95e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e962:	75 07                	jne    f011e96b <strncmp+0x38>
		return 0;
f011e964:	b8 00 00 00 00       	mov    $0x0,%eax
f011e969:	eb 14                	jmp    f011e97f <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011e96b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e96e:	8a 00                	mov    (%eax),%al
f011e970:	0f b6 d0             	movzbl %al,%edx
f011e973:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e976:	8a 00                	mov    (%eax),%al
f011e978:	0f b6 c0             	movzbl %al,%eax
f011e97b:	29 c2                	sub    %eax,%edx
f011e97d:	89 d0                	mov    %edx,%eax
}
f011e97f:	5d                   	pop    %ebp
f011e980:	c3                   	ret    

f011e981 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011e981:	55                   	push   %ebp
f011e982:	89 e5                	mov    %esp,%ebp
f011e984:	83 ec 04             	sub    $0x4,%esp
f011e987:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e98a:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011e98d:	eb 12                	jmp    f011e9a1 <strchr+0x20>
		if (*s == c)
f011e98f:	8b 45 08             	mov    0x8(%ebp),%eax
f011e992:	8a 00                	mov    (%eax),%al
f011e994:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011e997:	75 05                	jne    f011e99e <strchr+0x1d>
			return (char *) s;
f011e999:	8b 45 08             	mov    0x8(%ebp),%eax
f011e99c:	eb 11                	jmp    f011e9af <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011e99e:	ff 45 08             	incl   0x8(%ebp)
f011e9a1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e9a4:	8a 00                	mov    (%eax),%al
f011e9a6:	84 c0                	test   %al,%al
f011e9a8:	75 e5                	jne    f011e98f <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011e9aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011e9af:	c9                   	leave  
f011e9b0:	c3                   	ret    

f011e9b1 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011e9b1:	55                   	push   %ebp
f011e9b2:	89 e5                	mov    %esp,%ebp
f011e9b4:	83 ec 04             	sub    $0x4,%esp
f011e9b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e9ba:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011e9bd:	eb 0d                	jmp    f011e9cc <strfind+0x1b>
		if (*s == c)
f011e9bf:	8b 45 08             	mov    0x8(%ebp),%eax
f011e9c2:	8a 00                	mov    (%eax),%al
f011e9c4:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011e9c7:	74 0e                	je     f011e9d7 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011e9c9:	ff 45 08             	incl   0x8(%ebp)
f011e9cc:	8b 45 08             	mov    0x8(%ebp),%eax
f011e9cf:	8a 00                	mov    (%eax),%al
f011e9d1:	84 c0                	test   %al,%al
f011e9d3:	75 ea                	jne    f011e9bf <strfind+0xe>
f011e9d5:	eb 01                	jmp    f011e9d8 <strfind+0x27>
		if (*s == c)
			break;
f011e9d7:	90                   	nop
	return (char *) s;
f011e9d8:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011e9db:	c9                   	leave  
f011e9dc:	c3                   	ret    

f011e9dd <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011e9dd:	55                   	push   %ebp
f011e9de:	89 e5                	mov    %esp,%ebp
f011e9e0:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011e9e3:	8b 45 08             	mov    0x8(%ebp),%eax
f011e9e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011e9e9:	8b 45 10             	mov    0x10(%ebp),%eax
f011e9ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011e9ef:	eb 0e                	jmp    f011e9ff <memset+0x22>
		*p++ = c;
f011e9f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e9f4:	8d 50 01             	lea    0x1(%eax),%edx
f011e9f7:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011e9fa:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e9fd:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011e9ff:	ff 4d f8             	decl   -0x8(%ebp)
f011ea02:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011ea06:	79 e9                	jns    f011e9f1 <memset+0x14>
		*p++ = c;

	return v;
f011ea08:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ea0b:	c9                   	leave  
f011ea0c:	c3                   	ret    

f011ea0d <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011ea0d:	55                   	push   %ebp
f011ea0e:	89 e5                	mov    %esp,%ebp
f011ea10:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ea13:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea16:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ea19:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea1c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011ea1f:	eb 16                	jmp    f011ea37 <memcpy+0x2a>
		*d++ = *s++;
f011ea21:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ea24:	8d 50 01             	lea    0x1(%eax),%edx
f011ea27:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ea2a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ea2d:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ea30:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ea33:	8a 12                	mov    (%edx),%dl
f011ea35:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011ea37:	8b 45 10             	mov    0x10(%ebp),%eax
f011ea3a:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ea3d:	89 55 10             	mov    %edx,0x10(%ebp)
f011ea40:	85 c0                	test   %eax,%eax
f011ea42:	75 dd                	jne    f011ea21 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011ea44:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ea47:	c9                   	leave  
f011ea48:	c3                   	ret    

f011ea49 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011ea49:	55                   	push   %ebp
f011ea4a:	89 e5                	mov    %esp,%ebp
f011ea4c:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ea4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea52:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ea55:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea58:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011ea5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ea5e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ea61:	73 50                	jae    f011eab3 <memmove+0x6a>
f011ea63:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ea66:	8b 45 10             	mov    0x10(%ebp),%eax
f011ea69:	01 d0                	add    %edx,%eax
f011ea6b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ea6e:	76 43                	jbe    f011eab3 <memmove+0x6a>
		s += n;
f011ea70:	8b 45 10             	mov    0x10(%ebp),%eax
f011ea73:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011ea76:	8b 45 10             	mov    0x10(%ebp),%eax
f011ea79:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011ea7c:	eb 10                	jmp    f011ea8e <memmove+0x45>
			*--d = *--s;
f011ea7e:	ff 4d f8             	decl   -0x8(%ebp)
f011ea81:	ff 4d fc             	decl   -0x4(%ebp)
f011ea84:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ea87:	8a 10                	mov    (%eax),%dl
f011ea89:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ea8c:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011ea8e:	8b 45 10             	mov    0x10(%ebp),%eax
f011ea91:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ea94:	89 55 10             	mov    %edx,0x10(%ebp)
f011ea97:	85 c0                	test   %eax,%eax
f011ea99:	75 e3                	jne    f011ea7e <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011ea9b:	eb 23                	jmp    f011eac0 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011ea9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011eaa0:	8d 50 01             	lea    0x1(%eax),%edx
f011eaa3:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011eaa6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011eaa9:	8d 4a 01             	lea    0x1(%edx),%ecx
f011eaac:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011eaaf:	8a 12                	mov    (%edx),%dl
f011eab1:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011eab3:	8b 45 10             	mov    0x10(%ebp),%eax
f011eab6:	8d 50 ff             	lea    -0x1(%eax),%edx
f011eab9:	89 55 10             	mov    %edx,0x10(%ebp)
f011eabc:	85 c0                	test   %eax,%eax
f011eabe:	75 dd                	jne    f011ea9d <memmove+0x54>
			*d++ = *s++;

	return dst;
f011eac0:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011eac3:	c9                   	leave  
f011eac4:	c3                   	ret    

f011eac5 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011eac5:	55                   	push   %ebp
f011eac6:	89 e5                	mov    %esp,%ebp
f011eac8:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011eacb:	8b 45 08             	mov    0x8(%ebp),%eax
f011eace:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011ead1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ead4:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ead7:	eb 2a                	jmp    f011eb03 <memcmp+0x3e>
		if (*s1 != *s2)
f011ead9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011eadc:	8a 10                	mov    (%eax),%dl
f011eade:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011eae1:	8a 00                	mov    (%eax),%al
f011eae3:	38 c2                	cmp    %al,%dl
f011eae5:	74 16                	je     f011eafd <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011eae7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011eaea:	8a 00                	mov    (%eax),%al
f011eaec:	0f b6 d0             	movzbl %al,%edx
f011eaef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011eaf2:	8a 00                	mov    (%eax),%al
f011eaf4:	0f b6 c0             	movzbl %al,%eax
f011eaf7:	29 c2                	sub    %eax,%edx
f011eaf9:	89 d0                	mov    %edx,%eax
f011eafb:	eb 18                	jmp    f011eb15 <memcmp+0x50>
		s1++, s2++;
f011eafd:	ff 45 fc             	incl   -0x4(%ebp)
f011eb00:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011eb03:	8b 45 10             	mov    0x10(%ebp),%eax
f011eb06:	8d 50 ff             	lea    -0x1(%eax),%edx
f011eb09:	89 55 10             	mov    %edx,0x10(%ebp)
f011eb0c:	85 c0                	test   %eax,%eax
f011eb0e:	75 c9                	jne    f011ead9 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011eb10:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011eb15:	c9                   	leave  
f011eb16:	c3                   	ret    

f011eb17 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011eb17:	55                   	push   %ebp
f011eb18:	89 e5                	mov    %esp,%ebp
f011eb1a:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011eb1d:	8b 55 08             	mov    0x8(%ebp),%edx
f011eb20:	8b 45 10             	mov    0x10(%ebp),%eax
f011eb23:	01 d0                	add    %edx,%eax
f011eb25:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011eb28:	eb 15                	jmp    f011eb3f <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011eb2a:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb2d:	8a 00                	mov    (%eax),%al
f011eb2f:	0f b6 d0             	movzbl %al,%edx
f011eb32:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eb35:	0f b6 c0             	movzbl %al,%eax
f011eb38:	39 c2                	cmp    %eax,%edx
f011eb3a:	74 0d                	je     f011eb49 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011eb3c:	ff 45 08             	incl   0x8(%ebp)
f011eb3f:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb42:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011eb45:	72 e3                	jb     f011eb2a <memfind+0x13>
f011eb47:	eb 01                	jmp    f011eb4a <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011eb49:	90                   	nop
	return (void *) s;
f011eb4a:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011eb4d:	c9                   	leave  
f011eb4e:	c3                   	ret    

f011eb4f <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011eb4f:	55                   	push   %ebp
f011eb50:	89 e5                	mov    %esp,%ebp
f011eb52:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011eb55:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011eb5c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011eb63:	eb 03                	jmp    f011eb68 <strtol+0x19>
		s++;
f011eb65:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011eb68:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb6b:	8a 00                	mov    (%eax),%al
f011eb6d:	3c 20                	cmp    $0x20,%al
f011eb6f:	74 f4                	je     f011eb65 <strtol+0x16>
f011eb71:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb74:	8a 00                	mov    (%eax),%al
f011eb76:	3c 09                	cmp    $0x9,%al
f011eb78:	74 eb                	je     f011eb65 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011eb7a:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb7d:	8a 00                	mov    (%eax),%al
f011eb7f:	3c 2b                	cmp    $0x2b,%al
f011eb81:	75 05                	jne    f011eb88 <strtol+0x39>
		s++;
f011eb83:	ff 45 08             	incl   0x8(%ebp)
f011eb86:	eb 13                	jmp    f011eb9b <strtol+0x4c>
	else if (*s == '-')
f011eb88:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb8b:	8a 00                	mov    (%eax),%al
f011eb8d:	3c 2d                	cmp    $0x2d,%al
f011eb8f:	75 0a                	jne    f011eb9b <strtol+0x4c>
		s++, neg = 1;
f011eb91:	ff 45 08             	incl   0x8(%ebp)
f011eb94:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011eb9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011eb9f:	74 06                	je     f011eba7 <strtol+0x58>
f011eba1:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011eba5:	75 20                	jne    f011ebc7 <strtol+0x78>
f011eba7:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebaa:	8a 00                	mov    (%eax),%al
f011ebac:	3c 30                	cmp    $0x30,%al
f011ebae:	75 17                	jne    f011ebc7 <strtol+0x78>
f011ebb0:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebb3:	40                   	inc    %eax
f011ebb4:	8a 00                	mov    (%eax),%al
f011ebb6:	3c 78                	cmp    $0x78,%al
f011ebb8:	75 0d                	jne    f011ebc7 <strtol+0x78>
		s += 2, base = 16;
f011ebba:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011ebbe:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011ebc5:	eb 28                	jmp    f011ebef <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011ebc7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ebcb:	75 15                	jne    f011ebe2 <strtol+0x93>
f011ebcd:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebd0:	8a 00                	mov    (%eax),%al
f011ebd2:	3c 30                	cmp    $0x30,%al
f011ebd4:	75 0c                	jne    f011ebe2 <strtol+0x93>
		s++, base = 8;
f011ebd6:	ff 45 08             	incl   0x8(%ebp)
f011ebd9:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011ebe0:	eb 0d                	jmp    f011ebef <strtol+0xa0>
	else if (base == 0)
f011ebe2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ebe6:	75 07                	jne    f011ebef <strtol+0xa0>
		base = 10;
f011ebe8:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011ebef:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebf2:	8a 00                	mov    (%eax),%al
f011ebf4:	3c 2f                	cmp    $0x2f,%al
f011ebf6:	7e 19                	jle    f011ec11 <strtol+0xc2>
f011ebf8:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebfb:	8a 00                	mov    (%eax),%al
f011ebfd:	3c 39                	cmp    $0x39,%al
f011ebff:	7f 10                	jg     f011ec11 <strtol+0xc2>
			dig = *s - '0';
f011ec01:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec04:	8a 00                	mov    (%eax),%al
f011ec06:	0f be c0             	movsbl %al,%eax
f011ec09:	83 e8 30             	sub    $0x30,%eax
f011ec0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ec0f:	eb 42                	jmp    f011ec53 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011ec11:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec14:	8a 00                	mov    (%eax),%al
f011ec16:	3c 60                	cmp    $0x60,%al
f011ec18:	7e 19                	jle    f011ec33 <strtol+0xe4>
f011ec1a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec1d:	8a 00                	mov    (%eax),%al
f011ec1f:	3c 7a                	cmp    $0x7a,%al
f011ec21:	7f 10                	jg     f011ec33 <strtol+0xe4>
			dig = *s - 'a' + 10;
f011ec23:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec26:	8a 00                	mov    (%eax),%al
f011ec28:	0f be c0             	movsbl %al,%eax
f011ec2b:	83 e8 57             	sub    $0x57,%eax
f011ec2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ec31:	eb 20                	jmp    f011ec53 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011ec33:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec36:	8a 00                	mov    (%eax),%al
f011ec38:	3c 40                	cmp    $0x40,%al
f011ec3a:	7e 39                	jle    f011ec75 <strtol+0x126>
f011ec3c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec3f:	8a 00                	mov    (%eax),%al
f011ec41:	3c 5a                	cmp    $0x5a,%al
f011ec43:	7f 30                	jg     f011ec75 <strtol+0x126>
			dig = *s - 'A' + 10;
f011ec45:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec48:	8a 00                	mov    (%eax),%al
f011ec4a:	0f be c0             	movsbl %al,%eax
f011ec4d:	83 e8 37             	sub    $0x37,%eax
f011ec50:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011ec53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec56:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ec59:	7d 19                	jge    f011ec74 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011ec5b:	ff 45 08             	incl   0x8(%ebp)
f011ec5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ec61:	0f af 45 10          	imul   0x10(%ebp),%eax
f011ec65:	89 c2                	mov    %eax,%edx
f011ec67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec6a:	01 d0                	add    %edx,%eax
f011ec6c:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011ec6f:	e9 7b ff ff ff       	jmp    f011ebef <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011ec74:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011ec75:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ec79:	74 08                	je     f011ec83 <strtol+0x134>
		*endptr = (char *) s;
f011ec7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec7e:	8b 55 08             	mov    0x8(%ebp),%edx
f011ec81:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011ec83:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011ec87:	74 07                	je     f011ec90 <strtol+0x141>
f011ec89:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ec8c:	f7 d8                	neg    %eax
f011ec8e:	eb 03                	jmp    f011ec93 <strtol+0x144>
f011ec90:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ec93:	c9                   	leave  
f011ec94:	c3                   	ret    

f011ec95 <ltostr>:

void
ltostr(long value, char *str)
{
f011ec95:	55                   	push   %ebp
f011ec96:	89 e5                	mov    %esp,%ebp
f011ec98:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011ec9b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011eca2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011eca9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ecad:	79 13                	jns    f011ecc2 <ltostr+0x2d>
	{
		neg = 1;
f011ecaf:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011ecb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ecb9:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011ecbc:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011ecbf:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011ecc2:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecc5:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011ecca:	99                   	cltd   
f011eccb:	f7 f9                	idiv   %ecx
f011eccd:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011ecd0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ecd3:	8d 50 01             	lea    0x1(%eax),%edx
f011ecd6:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ecd9:	89 c2                	mov    %eax,%edx
f011ecdb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ecde:	01 d0                	add    %edx,%eax
f011ece0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ece3:	83 c2 30             	add    $0x30,%edx
f011ece6:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011ece8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011eceb:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011ecf0:	f7 e9                	imul   %ecx
f011ecf2:	c1 fa 02             	sar    $0x2,%edx
f011ecf5:	89 c8                	mov    %ecx,%eax
f011ecf7:	c1 f8 1f             	sar    $0x1f,%eax
f011ecfa:	29 c2                	sub    %eax,%edx
f011ecfc:	89 d0                	mov    %edx,%eax
f011ecfe:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011ed01:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ed05:	75 bb                	jne    f011ecc2 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011ed07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011ed0e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ed11:	48                   	dec    %eax
f011ed12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011ed15:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011ed19:	74 3d                	je     f011ed58 <ltostr+0xc3>
		start = 1 ;
f011ed1b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011ed22:	eb 34                	jmp    f011ed58 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011ed24:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed27:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed2a:	01 d0                	add    %edx,%eax
f011ed2c:	8a 00                	mov    (%eax),%al
f011ed2e:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011ed31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed34:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed37:	01 c2                	add    %eax,%edx
f011ed39:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011ed3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed3f:	01 c8                	add    %ecx,%eax
f011ed41:	8a 00                	mov    (%eax),%al
f011ed43:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011ed45:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ed48:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed4b:	01 c2                	add    %eax,%edx
f011ed4d:	8a 45 eb             	mov    -0x15(%ebp),%al
f011ed50:	88 02                	mov    %al,(%edx)
		start++ ;
f011ed52:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011ed55:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011ed58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ed5b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011ed5e:	7c c4                	jl     f011ed24 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011ed60:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011ed63:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed66:	01 d0                	add    %edx,%eax
f011ed68:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011ed6b:	90                   	nop
f011ed6c:	c9                   	leave  
f011ed6d:	c3                   	ret    

f011ed6e <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011ed6e:	55                   	push   %ebp
f011ed6f:	89 e5                	mov    %esp,%ebp
f011ed71:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011ed74:	ff 75 08             	pushl  0x8(%ebp)
f011ed77:	e8 73 fa ff ff       	call   f011e7ef <strlen>
f011ed7c:	83 c4 04             	add    $0x4,%esp
f011ed7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011ed82:	ff 75 0c             	pushl  0xc(%ebp)
f011ed85:	e8 65 fa ff ff       	call   f011e7ef <strlen>
f011ed8a:	83 c4 04             	add    $0x4,%esp
f011ed8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011ed90:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011ed97:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ed9e:	eb 17                	jmp    f011edb7 <strcconcat+0x49>
		final[s] = str1[s] ;
f011eda0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011eda3:	8b 45 10             	mov    0x10(%ebp),%eax
f011eda6:	01 c2                	add    %eax,%edx
f011eda8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011edab:	8b 45 08             	mov    0x8(%ebp),%eax
f011edae:	01 c8                	add    %ecx,%eax
f011edb0:	8a 00                	mov    (%eax),%al
f011edb2:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011edb4:	ff 45 fc             	incl   -0x4(%ebp)
f011edb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011edba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011edbd:	7c e1                	jl     f011eda0 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011edbf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011edc6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011edcd:	eb 1f                	jmp    f011edee <strcconcat+0x80>
		final[s++] = str2[i] ;
f011edcf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011edd2:	8d 50 01             	lea    0x1(%eax),%edx
f011edd5:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011edd8:	89 c2                	mov    %eax,%edx
f011edda:	8b 45 10             	mov    0x10(%ebp),%eax
f011eddd:	01 c2                	add    %eax,%edx
f011eddf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011ede2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ede5:	01 c8                	add    %ecx,%eax
f011ede7:	8a 00                	mov    (%eax),%al
f011ede9:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011edeb:	ff 45 f8             	incl   -0x8(%ebp)
f011edee:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011edf1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011edf4:	7c d9                	jl     f011edcf <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011edf6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011edf9:	8b 45 10             	mov    0x10(%ebp),%eax
f011edfc:	01 d0                	add    %edx,%eax
f011edfe:	c6 00 00             	movb   $0x0,(%eax)
}
f011ee01:	90                   	nop
f011ee02:	c9                   	leave  
f011ee03:	c3                   	ret    

f011ee04 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011ee04:	55                   	push   %ebp
f011ee05:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011ee07:	8b 45 14             	mov    0x14(%ebp),%eax
f011ee0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011ee10:	8b 45 14             	mov    0x14(%ebp),%eax
f011ee13:	8b 00                	mov    (%eax),%eax
f011ee15:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ee1c:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee1f:	01 d0                	add    %edx,%eax
f011ee21:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011ee27:	eb 0c                	jmp    f011ee35 <strsplit+0x31>
			*string++ = 0;
f011ee29:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee2c:	8d 50 01             	lea    0x1(%eax),%edx
f011ee2f:	89 55 08             	mov    %edx,0x8(%ebp)
f011ee32:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011ee35:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee38:	8a 00                	mov    (%eax),%al
f011ee3a:	84 c0                	test   %al,%al
f011ee3c:	74 18                	je     f011ee56 <strsplit+0x52>
f011ee3e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee41:	8a 00                	mov    (%eax),%al
f011ee43:	0f be c0             	movsbl %al,%eax
f011ee46:	50                   	push   %eax
f011ee47:	ff 75 0c             	pushl  0xc(%ebp)
f011ee4a:	e8 32 fb ff ff       	call   f011e981 <strchr>
f011ee4f:	83 c4 08             	add    $0x8,%esp
f011ee52:	85 c0                	test   %eax,%eax
f011ee54:	75 d3                	jne    f011ee29 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011ee56:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee59:	8a 00                	mov    (%eax),%al
f011ee5b:	84 c0                	test   %al,%al
f011ee5d:	74 5a                	je     f011eeb9 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011ee5f:	8b 45 14             	mov    0x14(%ebp),%eax
f011ee62:	8b 00                	mov    (%eax),%eax
f011ee64:	83 f8 0f             	cmp    $0xf,%eax
f011ee67:	75 07                	jne    f011ee70 <strsplit+0x6c>
		{
			return 0;
f011ee69:	b8 00 00 00 00       	mov    $0x0,%eax
f011ee6e:	eb 66                	jmp    f011eed6 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011ee70:	8b 45 14             	mov    0x14(%ebp),%eax
f011ee73:	8b 00                	mov    (%eax),%eax
f011ee75:	8d 48 01             	lea    0x1(%eax),%ecx
f011ee78:	8b 55 14             	mov    0x14(%ebp),%edx
f011ee7b:	89 0a                	mov    %ecx,(%edx)
f011ee7d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ee84:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee87:	01 c2                	add    %eax,%edx
f011ee89:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee8c:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011ee8e:	eb 03                	jmp    f011ee93 <strsplit+0x8f>
			string++;
f011ee90:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011ee93:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee96:	8a 00                	mov    (%eax),%al
f011ee98:	84 c0                	test   %al,%al
f011ee9a:	74 8b                	je     f011ee27 <strsplit+0x23>
f011ee9c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee9f:	8a 00                	mov    (%eax),%al
f011eea1:	0f be c0             	movsbl %al,%eax
f011eea4:	50                   	push   %eax
f011eea5:	ff 75 0c             	pushl  0xc(%ebp)
f011eea8:	e8 d4 fa ff ff       	call   f011e981 <strchr>
f011eead:	83 c4 08             	add    $0x8,%esp
f011eeb0:	85 c0                	test   %eax,%eax
f011eeb2:	74 dc                	je     f011ee90 <strsplit+0x8c>
			string++;
	}
f011eeb4:	e9 6e ff ff ff       	jmp    f011ee27 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011eeb9:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011eeba:	8b 45 14             	mov    0x14(%ebp),%eax
f011eebd:	8b 00                	mov    (%eax),%eax
f011eebf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011eec6:	8b 45 10             	mov    0x10(%ebp),%eax
f011eec9:	01 d0                	add    %edx,%eax
f011eecb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011eed1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011eed6:	c9                   	leave  
f011eed7:	c3                   	ret    

f011eed8 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011eed8:	55                   	push   %ebp
f011eed9:	89 e5                	mov    %esp,%ebp
f011eedb:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f011eede:	83 ec 04             	sub    $0x4,%esp
f011eee1:	68 9c ff 12 f0       	push   $0xf012ff9c
f011eee6:	68 3f 01 00 00       	push   $0x13f
f011eeeb:	68 be ff 12 f0       	push   $0xf012ffbe
f011eef0:	e8 44 14 fe ff       	call   f0100339 <_panic>

f011eef5 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011eef5:	55                   	push   %ebp
f011eef6:	89 e5                	mov    %esp,%ebp
f011eef8:	83 ec 18             	sub    $0x18,%esp
f011eefb:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011ef02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ef05:	89 c2                	mov    %eax,%edx
f011ef07:	ec                   	in     (%dx),%al
f011ef08:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011ef0b:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011ef0e:	0f b6 c0             	movzbl %al,%eax
f011ef11:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ef14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ef17:	25 c0 00 00 00       	and    $0xc0,%eax
f011ef1c:	83 f8 40             	cmp    $0x40,%eax
f011ef1f:	75 10                	jne    f011ef31 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f011ef21:	83 ec 0c             	sub    $0xc,%esp
f011ef24:	68 a0 c3 5e f0       	push   $0xf05ec3a0
f011ef29:	e8 8e fd fe ff       	call   f010ecbc <wakeup_one>
f011ef2e:	83 c4 10             	add    $0x10,%esp
	}

}
f011ef31:	90                   	nop
f011ef32:	c9                   	leave  
f011ef33:	c3                   	ret    

f011ef34 <ide_init>:

void ide_init()
{
f011ef34:	55                   	push   %ebp
f011ef35:	89 e5                	mov    %esp,%ebp
f011ef37:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f011ef3a:	83 ec 08             	sub    $0x8,%esp
f011ef3d:	68 f5 ee 11 f0       	push   $0xf011eef5
f011ef42:	6a 0e                	push   $0xe
f011ef44:	e8 2a e1 fe ff       	call   f010d073 <irq_install_handler>
f011ef49:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f011ef4c:	83 ec 08             	sub    $0x8,%esp
f011ef4f:	68 cc ff 12 f0       	push   $0xf012ffcc
f011ef54:	68 a0 c3 5e f0       	push   $0xf05ec3a0
f011ef59:	e8 c4 fc fe ff       	call   f010ec22 <init_channel>
f011ef5e:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f011ef61:	83 ec 08             	sub    $0x8,%esp
f011ef64:	68 d9 ff 12 f0       	push   $0xf012ffd9
f011ef69:	68 c0 c9 5e f0       	push   $0xf05ec9c0
f011ef6e:	e8 be f8 fe ff       	call   f010e831 <init_spinlock>
f011ef73:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f011ef76:	90                   	nop
f011ef77:	c9                   	leave  
f011ef78:	c3                   	ret    

f011ef79 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f011ef79:	55                   	push   %ebp
f011ef7a:	89 e5                	mov    %esp,%ebp
f011ef7c:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011ef7f:	90                   	nop
f011ef80:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011ef87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ef8a:	89 c2                	mov    %eax,%edx
f011ef8c:	ec                   	in     (%dx),%al
f011ef8d:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011ef90:	8a 45 ef             	mov    -0x11(%ebp),%al
f011ef93:	0f b6 c0             	movzbl %al,%eax
f011ef96:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ef99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ef9c:	25 c0 00 00 00       	and    $0xc0,%eax
f011efa1:	83 f8 40             	cmp    $0x40,%eax
f011efa4:	75 da                	jne    f011ef80 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011efa6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011efaa:	74 24                	je     f011efd0 <ide_wait_ready+0x57>
f011efac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011efaf:	83 e0 21             	and    $0x21,%eax
f011efb2:	85 c0                	test   %eax,%eax
f011efb4:	74 1a                	je     f011efd0 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011efb6:	83 ec 0c             	sub    $0xc,%esp
f011efb9:	ff 75 f4             	pushl  -0xc(%ebp)
f011efbc:	ff 75 f4             	pushl  -0xc(%ebp)
f011efbf:	68 ec ff 12 f0       	push   $0xf012ffec
f011efc4:	6a 5d                	push   $0x5d
f011efc6:	68 0f 00 13 f0       	push   $0xf013000f
f011efcb:	e8 69 13 fe ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011efd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011efd5:	c9                   	leave  
f011efd6:	c3                   	ret    

f011efd7 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011efd7:	55                   	push   %ebp
f011efd8:	89 e5                	mov    %esp,%ebp
f011efda:	57                   	push   %edi
f011efdb:	53                   	push   %ebx
f011efdc:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f011efdf:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011efe6:	76 16                	jbe    f011effe <ide_read+0x27>
f011efe8:	68 1a 00 13 f0       	push   $0xf013001a
f011efed:	68 27 00 13 f0       	push   $0xf0130027
f011eff2:	6a 68                	push   $0x68
f011eff4:	68 0f 00 13 f0       	push   $0xf013000f
f011eff9:	e8 3b 13 fe ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f011effe:	83 ec 0c             	sub    $0xc,%esp
f011f001:	6a 00                	push   $0x0
f011f003:	e8 71 ff ff ff       	call   f011ef79 <ide_wait_ready>
f011f008:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f011f00b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f00e:	0f b6 c0             	movzbl %al,%eax
f011f011:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011f018:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011f01b:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011f01e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f021:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011f022:	8b 45 08             	mov    0x8(%ebp),%eax
f011f025:	0f b6 c0             	movzbl %al,%eax
f011f028:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011f02f:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011f032:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011f035:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f038:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011f039:	8b 45 08             	mov    0x8(%ebp),%eax
f011f03c:	c1 e8 08             	shr    $0x8,%eax
f011f03f:	0f b6 c0             	movzbl %al,%eax
f011f042:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011f049:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011f04c:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011f04f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f052:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011f053:	8b 45 08             	mov    0x8(%ebp),%eax
f011f056:	c1 e8 10             	shr    $0x10,%eax
f011f059:	0f b6 c0             	movzbl %al,%eax
f011f05c:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011f063:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011f066:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011f069:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f06c:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011f06d:	a1 50 c2 5e f0       	mov    0xf05ec250,%eax
f011f072:	83 e0 01             	and    $0x1,%eax
f011f075:	c1 e0 04             	shl    $0x4,%eax
f011f078:	88 c2                	mov    %al,%dl
f011f07a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f07d:	c1 e8 18             	shr    $0x18,%eax
f011f080:	83 e0 0f             	and    $0xf,%eax
f011f083:	09 d0                	or     %edx,%eax
f011f085:	83 c8 e0             	or     $0xffffffe0,%eax
f011f088:	0f b6 c0             	movzbl %al,%eax
f011f08b:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011f092:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011f095:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011f098:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f09b:	ee                   	out    %al,(%dx)
f011f09c:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011f0a3:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f011f0a7:	8a 45 d7             	mov    -0x29(%ebp),%al
f011f0aa:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011f0ad:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011f0ae:	eb 55                	jmp    f011f105 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f011f0b0:	83 ec 0c             	sub    $0xc,%esp
f011f0b3:	6a 01                	push   $0x1
f011f0b5:	e8 bf fe ff ff       	call   f011ef79 <ide_wait_ready>
f011f0ba:	83 c4 10             	add    $0x10,%esp
f011f0bd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f0c0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f0c4:	79 05                	jns    f011f0cb <ide_read+0xf4>
			return r;
f011f0c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f0c9:	eb 45                	jmp    f011f110 <ide_read+0x139>
f011f0cb:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011f0d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f0d5:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011f0d8:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011f0df:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f0e2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011f0e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f0e8:	89 cb                	mov    %ecx,%ebx
f011f0ea:	89 df                	mov    %ebx,%edi
f011f0ec:	89 c1                	mov    %eax,%ecx
f011f0ee:	fc                   	cld    
f011f0ef:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011f0f1:	89 c8                	mov    %ecx,%eax
f011f0f3:	89 fb                	mov    %edi,%ebx
f011f0f5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011f0f8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011f0fb:	ff 4d 10             	decl   0x10(%ebp)
f011f0fe:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011f105:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f109:	75 a5                	jne    f011f0b0 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f011f10b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f110:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f113:	5b                   	pop    %ebx
f011f114:	5f                   	pop    %edi
f011f115:	5d                   	pop    %ebp
f011f116:	c3                   	ret    

f011f117 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011f117:	55                   	push   %ebp
f011f118:	89 e5                	mov    %esp,%ebp
f011f11a:	56                   	push   %esi
f011f11b:	53                   	push   %ebx
f011f11c:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011f11f:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011f126:	76 19                	jbe    f011f141 <ide_write+0x2a>
f011f128:	68 1a 00 13 f0       	push   $0xf013001a
f011f12d:	68 27 00 13 f0       	push   $0xf0130027
f011f132:	68 82 00 00 00       	push   $0x82
f011f137:	68 0f 00 13 f0       	push   $0xf013000f
f011f13c:	e8 f8 11 fe ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f011f141:	83 ec 0c             	sub    $0xc,%esp
f011f144:	6a 00                	push   $0x0
f011f146:	e8 2e fe ff ff       	call   f011ef79 <ide_wait_ready>
f011f14b:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f011f14e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f151:	0f b6 c0             	movzbl %al,%eax
f011f154:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011f15b:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011f15e:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011f161:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f164:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011f165:	8b 45 08             	mov    0x8(%ebp),%eax
f011f168:	0f b6 c0             	movzbl %al,%eax
f011f16b:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011f172:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011f175:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011f178:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f17b:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011f17c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f17f:	c1 e8 08             	shr    $0x8,%eax
f011f182:	0f b6 c0             	movzbl %al,%eax
f011f185:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011f18c:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011f18f:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011f192:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f195:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011f196:	8b 45 08             	mov    0x8(%ebp),%eax
f011f199:	c1 e8 10             	shr    $0x10,%eax
f011f19c:	0f b6 c0             	movzbl %al,%eax
f011f19f:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011f1a6:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011f1a9:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011f1ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f1af:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011f1b0:	a1 50 c2 5e f0       	mov    0xf05ec250,%eax
f011f1b5:	83 e0 01             	and    $0x1,%eax
f011f1b8:	c1 e0 04             	shl    $0x4,%eax
f011f1bb:	88 c2                	mov    %al,%dl
f011f1bd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1c0:	c1 e8 18             	shr    $0x18,%eax
f011f1c3:	83 e0 0f             	and    $0xf,%eax
f011f1c6:	09 d0                	or     %edx,%eax
f011f1c8:	83 c8 e0             	or     $0xffffffe0,%eax
f011f1cb:	0f b6 c0             	movzbl %al,%eax
f011f1ce:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011f1d5:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011f1d8:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011f1db:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f1de:	ee                   	out    %al,(%dx)
f011f1df:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011f1e6:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f011f1ea:	8a 45 d7             	mov    -0x29(%ebp),%al
f011f1ed:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011f1f0:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011f1f1:	eb 55                	jmp    f011f248 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f011f1f3:	83 ec 0c             	sub    $0xc,%esp
f011f1f6:	6a 01                	push   $0x1
f011f1f8:	e8 7c fd ff ff       	call   f011ef79 <ide_wait_ready>
f011f1fd:	83 c4 10             	add    $0x10,%esp
f011f200:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f203:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f207:	79 05                	jns    f011f20e <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f011f209:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f20c:	eb 45                	jmp    f011f253 <ide_write+0x13c>
f011f20e:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011f215:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f218:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011f21b:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011f222:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f225:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011f228:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f22b:	89 cb                	mov    %ecx,%ebx
f011f22d:	89 de                	mov    %ebx,%esi
f011f22f:	89 c1                	mov    %eax,%ecx
f011f231:	fc                   	cld    
f011f232:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011f234:	89 c8                	mov    %ecx,%eax
f011f236:	89 f3                	mov    %esi,%ebx
f011f238:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011f23b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011f23e:	ff 4d 10             	decl   0x10(%ebp)
f011f241:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011f248:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f24c:	75 a5                	jne    f011f1f3 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011f24e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f253:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f256:	5b                   	pop    %ebx
f011f257:	5e                   	pop    %esi
f011f258:	5d                   	pop    %ebp
f011f259:	c3                   	ret    

f011f25a <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f011f25a:	55                   	push   %ebp
f011f25b:	89 e5                	mov    %esp,%ebp
f011f25d:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011f260:	8b 45 08             	mov    0x8(%ebp),%eax
f011f263:	83 e8 04             	sub    $0x4,%eax
f011f266:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f011f269:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f26c:	8b 00                	mov    (%eax),%eax
f011f26e:	83 e0 fe             	and    $0xfffffffe,%eax
}
f011f271:	c9                   	leave  
f011f272:	c3                   	ret    

f011f273 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f011f273:	55                   	push   %ebp
f011f274:	89 e5                	mov    %esp,%ebp
f011f276:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011f279:	8b 45 08             	mov    0x8(%ebp),%eax
f011f27c:	83 e8 04             	sub    $0x4,%eax
f011f27f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f011f282:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f285:	8b 00                	mov    (%eax),%eax
f011f287:	83 e0 01             	and    $0x1,%eax
f011f28a:	85 c0                	test   %eax,%eax
f011f28c:	0f 94 c0             	sete   %al
}
f011f28f:	c9                   	leave  
f011f290:	c3                   	ret    

f011f291 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f011f291:	55                   	push   %ebp
f011f292:	89 e5                	mov    %esp,%ebp
f011f294:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f011f297:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f011f29e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f2a1:	83 f8 02             	cmp    $0x2,%eax
f011f2a4:	74 2b                	je     f011f2d1 <alloc_block+0x40>
f011f2a6:	83 f8 02             	cmp    $0x2,%eax
f011f2a9:	7f 07                	jg     f011f2b2 <alloc_block+0x21>
f011f2ab:	83 f8 01             	cmp    $0x1,%eax
f011f2ae:	74 0e                	je     f011f2be <alloc_block+0x2d>
f011f2b0:	eb 58                	jmp    f011f30a <alloc_block+0x79>
f011f2b2:	83 f8 03             	cmp    $0x3,%eax
f011f2b5:	74 2d                	je     f011f2e4 <alloc_block+0x53>
f011f2b7:	83 f8 04             	cmp    $0x4,%eax
f011f2ba:	74 3b                	je     f011f2f7 <alloc_block+0x66>
f011f2bc:	eb 4c                	jmp    f011f30a <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f011f2be:	83 ec 0c             	sub    $0xc,%esp
f011f2c1:	ff 75 08             	pushl  0x8(%ebp)
f011f2c4:	e8 05 03 00 00       	call   f011f5ce <alloc_block_FF>
f011f2c9:	83 c4 10             	add    $0x10,%esp
f011f2cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f2cf:	eb 4a                	jmp    f011f31b <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f011f2d1:	83 ec 0c             	sub    $0xc,%esp
f011f2d4:	ff 75 08             	pushl  0x8(%ebp)
f011f2d7:	e8 d3 18 00 00       	call   f0120baf <alloc_block_NF>
f011f2dc:	83 c4 10             	add    $0x10,%esp
f011f2df:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f2e2:	eb 37                	jmp    f011f31b <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f011f2e4:	83 ec 0c             	sub    $0xc,%esp
f011f2e7:	ff 75 08             	pushl  0x8(%ebp)
f011f2ea:	e8 1e 07 00 00       	call   f011fa0d <alloc_block_BF>
f011f2ef:	83 c4 10             	add    $0x10,%esp
f011f2f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f2f5:	eb 24                	jmp    f011f31b <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f011f2f7:	83 ec 0c             	sub    $0xc,%esp
f011f2fa:	ff 75 08             	pushl  0x8(%ebp)
f011f2fd:	e8 90 18 00 00       	call   f0120b92 <alloc_block_WF>
f011f302:	83 c4 10             	add    $0x10,%esp
f011f305:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f308:	eb 11                	jmp    f011f31b <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f011f30a:	83 ec 0c             	sub    $0xc,%esp
f011f30d:	68 3c 00 13 f0       	push   $0xf013003c
f011f312:	e8 74 1c fe ff       	call   f0100f8b <cprintf>
f011f317:	83 c4 10             	add    $0x10,%esp
		break;
f011f31a:	90                   	nop
	}
	return va;
f011f31b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f31e:	c9                   	leave  
f011f31f:	c3                   	ret    

f011f320 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f011f320:	55                   	push   %ebp
f011f321:	89 e5                	mov    %esp,%ebp
f011f323:	53                   	push   %ebx
f011f324:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f011f327:	83 ec 0c             	sub    $0xc,%esp
f011f32a:	68 5c 00 13 f0       	push   $0xf013005c
f011f32f:	e8 57 1c fe ff       	call   f0100f8b <cprintf>
f011f334:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f011f337:	83 ec 0c             	sub    $0xc,%esp
f011f33a:	68 87 00 13 f0       	push   $0xf0130087
f011f33f:	e8 47 1c fe ff       	call   f0100f8b <cprintf>
f011f344:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f011f347:	8b 45 08             	mov    0x8(%ebp),%eax
f011f34a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f34d:	eb 37                	jmp    f011f386 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f011f34f:	83 ec 0c             	sub    $0xc,%esp
f011f352:	ff 75 f4             	pushl  -0xc(%ebp)
f011f355:	e8 19 ff ff ff       	call   f011f273 <is_free_block>
f011f35a:	83 c4 10             	add    $0x10,%esp
f011f35d:	0f be d8             	movsbl %al,%ebx
f011f360:	83 ec 0c             	sub    $0xc,%esp
f011f363:	ff 75 f4             	pushl  -0xc(%ebp)
f011f366:	e8 ef fe ff ff       	call   f011f25a <get_block_size>
f011f36b:	83 c4 10             	add    $0x10,%esp
f011f36e:	83 ec 04             	sub    $0x4,%esp
f011f371:	53                   	push   %ebx
f011f372:	50                   	push   %eax
f011f373:	68 9f 00 13 f0       	push   $0xf013009f
f011f378:	e8 0e 1c fe ff       	call   f0100f8b <cprintf>
f011f37d:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f011f380:	8b 45 10             	mov    0x10(%ebp),%eax
f011f383:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f386:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f38a:	74 07                	je     f011f393 <print_blocks_list+0x73>
f011f38c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f38f:	8b 00                	mov    (%eax),%eax
f011f391:	eb 05                	jmp    f011f398 <print_blocks_list+0x78>
f011f393:	b8 00 00 00 00       	mov    $0x0,%eax
f011f398:	89 45 10             	mov    %eax,0x10(%ebp)
f011f39b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f39e:	85 c0                	test   %eax,%eax
f011f3a0:	75 ad                	jne    f011f34f <print_blocks_list+0x2f>
f011f3a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f3a6:	75 a7                	jne    f011f34f <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f011f3a8:	83 ec 0c             	sub    $0xc,%esp
f011f3ab:	68 5c 00 13 f0       	push   $0xf013005c
f011f3b0:	e8 d6 1b fe ff       	call   f0100f8b <cprintf>
f011f3b5:	83 c4 10             	add    $0x10,%esp

}
f011f3b8:	90                   	nop
f011f3b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f3bc:	c9                   	leave  
f011f3bd:	c3                   	ret    

f011f3be <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f011f3be:	55                   	push   %ebp
f011f3bf:	89 e5                	mov    %esp,%ebp
f011f3c1:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f011f3c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f3c7:	83 e0 01             	and    $0x1,%eax
f011f3ca:	85 c0                	test   %eax,%eax
f011f3cc:	74 03                	je     f011f3d1 <initialize_dynamic_allocator+0x13>
f011f3ce:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f011f3d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f3d5:	0f 84 bb 01 00 00    	je     f011f596 <initialize_dynamic_allocator+0x1d8>
                return ;
            is_initialized = 1;
f011f3db:	c7 05 54 c2 5e f0 01 	movl   $0x1,0xf05ec254
f011f3e2:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f011f3e5:	8b 55 08             	mov    0x8(%ebp),%edx
f011f3e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f3eb:	01 d0                	add    %edx,%eax
f011f3ed:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f011f3f2:	0f 87 a1 01 00 00    	ja     f011f599 <initialize_dynamic_allocator+0x1db>
        return;
    if(daStart < KERNEL_HEAP_START)
f011f3f8:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f011f3ff:	0f 86 97 01 00 00    	jbe    f011f59c <initialize_dynamic_allocator+0x1de>
        return;

     struct BlockElement * element = NULL;
f011f405:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f011f40c:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f011f411:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f414:	e9 87 00 00 00       	jmp    f011f4a0 <initialize_dynamic_allocator+0xe2>
     {
        LIST_REMOVE(&freeBlocksList,element);
f011f419:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f41d:	75 14                	jne    f011f433 <initialize_dynamic_allocator+0x75>
f011f41f:	83 ec 04             	sub    $0x4,%esp
f011f422:	68 b7 00 13 f0       	push   $0xf01300b7
f011f427:	6a 79                	push   $0x79
f011f429:	68 d5 00 13 f0       	push   $0xf01300d5
f011f42e:	e8 06 0f fe ff       	call   f0100339 <_panic>
f011f433:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f436:	8b 00                	mov    (%eax),%eax
f011f438:	85 c0                	test   %eax,%eax
f011f43a:	74 10                	je     f011f44c <initialize_dynamic_allocator+0x8e>
f011f43c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f43f:	8b 00                	mov    (%eax),%eax
f011f441:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f444:	8b 52 04             	mov    0x4(%edx),%edx
f011f447:	89 50 04             	mov    %edx,0x4(%eax)
f011f44a:	eb 0b                	jmp    f011f457 <initialize_dynamic_allocator+0x99>
f011f44c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f44f:	8b 40 04             	mov    0x4(%eax),%eax
f011f452:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f457:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f45a:	8b 40 04             	mov    0x4(%eax),%eax
f011f45d:	85 c0                	test   %eax,%eax
f011f45f:	74 0f                	je     f011f470 <initialize_dynamic_allocator+0xb2>
f011f461:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f464:	8b 40 04             	mov    0x4(%eax),%eax
f011f467:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f46a:	8b 12                	mov    (%edx),%edx
f011f46c:	89 10                	mov    %edx,(%eax)
f011f46e:	eb 0a                	jmp    f011f47a <initialize_dynamic_allocator+0xbc>
f011f470:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f473:	8b 00                	mov    (%eax),%eax
f011f475:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011f47a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f47d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f483:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f486:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f48d:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f492:	48                   	dec    %eax
f011f493:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
        return;
    if(daStart < KERNEL_HEAP_START)
        return;

     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f011f498:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f011f49d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f4a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f4a4:	74 07                	je     f011f4ad <initialize_dynamic_allocator+0xef>
f011f4a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f4a9:	8b 00                	mov    (%eax),%eax
f011f4ab:	eb 05                	jmp    f011f4b2 <initialize_dynamic_allocator+0xf4>
f011f4ad:	b8 00 00 00 00       	mov    $0x0,%eax
f011f4b2:	a3 d8 c5 5e f0       	mov    %eax,0xf05ec5d8
f011f4b7:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f011f4bc:	85 c0                	test   %eax,%eax
f011f4be:	0f 85 55 ff ff ff    	jne    f011f419 <initialize_dynamic_allocator+0x5b>
f011f4c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f4c8:	0f 85 4b ff ff ff    	jne    f011f419 <initialize_dynamic_allocator+0x5b>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f011f4ce:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f011f4d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f4d7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    struct Block_Start_End* end_block = (struct Block_Start_End*) (daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End));
f011f4dd:	8b 55 08             	mov    0x8(%ebp),%edx
f011f4e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f4e3:	01 d0                	add    %edx,%eax
f011f4e5:	83 e8 04             	sub    $0x4,%eax
f011f4e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    end_block->info = 1;
f011f4eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f4ee:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f011f4f4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4f7:	83 c0 08             	add    $0x8,%eax
f011f4fa:	89 45 e8             	mov    %eax,-0x18(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f011f4fd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f500:	83 c0 04             	add    $0x4,%eax
f011f503:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f506:	83 ea 08             	sub    $0x8,%edx
f011f509:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f011f50b:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f50e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f511:	01 d0                	add    %edx,%eax
f011f513:	83 e8 08             	sub    $0x8,%eax
f011f516:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f519:	83 ea 08             	sub    $0x8,%edx
f011f51c:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f011f51e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f521:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f011f527:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f52a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f011f531:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011f535:	75 17                	jne    f011f54e <initialize_dynamic_allocator+0x190>
f011f537:	83 ec 04             	sub    $0x4,%esp
f011f53a:	68 f0 00 13 f0       	push   $0xf01300f0
f011f53f:	68 91 00 00 00       	push   $0x91
f011f544:	68 d5 00 13 f0       	push   $0xf01300d5
f011f549:	e8 eb 0d fe ff       	call   f0100339 <_panic>
f011f54e:	8b 15 d0 c5 5e f0    	mov    0xf05ec5d0,%edx
f011f554:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f557:	89 10                	mov    %edx,(%eax)
f011f559:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f55c:	8b 00                	mov    (%eax),%eax
f011f55e:	85 c0                	test   %eax,%eax
f011f560:	74 0d                	je     f011f56f <initialize_dynamic_allocator+0x1b1>
f011f562:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f011f567:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f56a:	89 50 04             	mov    %edx,0x4(%eax)
f011f56d:	eb 08                	jmp    f011f577 <initialize_dynamic_allocator+0x1b9>
f011f56f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f572:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f577:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f57a:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011f57f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f582:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f589:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f58e:	40                   	inc    %eax
f011f58f:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f011f594:	eb 07                	jmp    f011f59d <initialize_dynamic_allocator+0x1df>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f011f596:	90                   	nop
f011f597:	eb 04                	jmp    f011f59d <initialize_dynamic_allocator+0x1df>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f011f599:	90                   	nop
f011f59a:	eb 01                	jmp    f011f59d <initialize_dynamic_allocator+0x1df>
    if(daStart < KERNEL_HEAP_START)
        return;
f011f59c:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f011f59d:	c9                   	leave  
f011f59e:	c3                   	ret    

f011f59f <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f011f59f:	55                   	push   %ebp
f011f5a0:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f011f5a2:	8b 45 10             	mov    0x10(%ebp),%eax
f011f5a5:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f011f5a8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5ab:	8d 50 fc             	lea    -0x4(%eax),%edx
f011f5ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5b1:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f011f5b3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5b6:	83 e8 04             	sub    $0x4,%eax
f011f5b9:	8b 00                	mov    (%eax),%eax
f011f5bb:	83 e0 fe             	and    $0xfffffffe,%eax
f011f5be:	8d 50 f8             	lea    -0x8(%eax),%edx
f011f5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5c4:	01 c2                	add    %eax,%edx
f011f5c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5c9:	89 02                	mov    %eax,(%edx)
}
f011f5cb:	90                   	nop
f011f5cc:	5d                   	pop    %ebp
f011f5cd:	c3                   	ret    

f011f5ce <alloc_block_FF>:

//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size)
{
f011f5ce:	55                   	push   %ebp
f011f5cf:	89 e5                	mov    %esp,%ebp
f011f5d1:	83 ec 48             	sub    $0x48,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f011f5d4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5d7:	83 e0 01             	and    $0x1,%eax
f011f5da:	85 c0                	test   %eax,%eax
f011f5dc:	74 03                	je     f011f5e1 <alloc_block_FF+0x13>
f011f5de:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f011f5e1:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f011f5e5:	77 07                	ja     f011f5ee <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f011f5e7:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f011f5ee:	a1 54 c2 5e f0       	mov    0xf05ec254,%eax
f011f5f3:	85 c0                	test   %eax,%eax
f011f5f5:	75 73                	jne    f011f66a <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f011f5f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5fa:	83 c0 10             	add    $0x10,%eax
f011f5fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f011f600:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f011f607:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f60a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f60d:	01 d0                	add    %edx,%eax
f011f60f:	48                   	dec    %eax
f011f610:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f613:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f616:	ba 00 00 00 00       	mov    $0x0,%edx
f011f61b:	f7 75 ec             	divl   -0x14(%ebp)
f011f61e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f621:	29 d0                	sub    %edx,%eax
f011f623:	c1 e8 0c             	shr    $0xc,%eax
f011f626:	83 ec 0c             	sub    $0xc,%esp
f011f629:	50                   	push   %eax
f011f62a:	e8 cf 95 fe ff       	call   f0108bfe <sbrk>
f011f62f:	83 c4 10             	add    $0x10,%esp
f011f632:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f011f635:	83 ec 0c             	sub    $0xc,%esp
f011f638:	6a 00                	push   $0x0
f011f63a:	e8 bf 95 fe ff       	call   f0108bfe <sbrk>
f011f63f:	83 c4 10             	add    $0x10,%esp
f011f642:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f011f645:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f648:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f011f64b:	83 ec 08             	sub    $0x8,%esp
f011f64e:	50                   	push   %eax
f011f64f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f652:	e8 67 fd ff ff       	call   f011f3be <initialize_dynamic_allocator>
f011f657:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f011f65a:	83 ec 0c             	sub    $0xc,%esp
f011f65d:	68 13 01 13 f0       	push   $0xf0130113
f011f662:	e8 24 19 fe ff       	call   f0100f8b <cprintf>
f011f667:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f011f66a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f66e:	75 0a                	jne    f011f67a <alloc_block_FF+0xac>
	        return NULL;
f011f670:	b8 00 00 00 00       	mov    $0x0,%eax
f011f675:	e9 91 03 00 00       	jmp    f011fa0b <alloc_block_FF+0x43d>
	    }
	    struct BlockElement *blk = NULL;
f011f67a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f011f681:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f011f686:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f689:	e9 f3 02 00 00       	jmp    f011f981 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f011f68e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f691:	89 45 cc             	mov    %eax,-0x34(%ebp)
	        uint32 blk_size = get_block_size(va);
f011f694:	83 ec 0c             	sub    $0xc,%esp
f011f697:	ff 75 cc             	pushl  -0x34(%ebp)
f011f69a:	e8 bb fb ff ff       	call   f011f25a <get_block_size>
f011f69f:	83 c4 10             	add    $0x10,%esp
f011f6a2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	        if (blk_size >= size + 2 * sizeof(uint32)) {
f011f6a5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6a8:	83 c0 08             	add    $0x8,%eax
f011f6ab:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011f6ae:	0f 87 c5 02 00 00    	ja     f011f979 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f011f6b4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6b7:	83 c0 18             	add    $0x18,%eax
f011f6ba:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011f6bd:	0f 87 19 02 00 00    	ja     f011f8dc <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f011f6c3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f6c6:	2b 45 08             	sub    0x8(%ebp),%eax
f011f6c9:	83 e8 08             	sub    $0x8,%eax
f011f6cc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32)); // casting to char because its 1 byte size
f011f6cf:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6d2:	8d 50 08             	lea    0x8(%eax),%edx
f011f6d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f6d8:	01 d0                	add    %edx,%eax
f011f6da:	89 45 c0             	mov    %eax,-0x40(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f011f6dd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6e0:	83 c0 08             	add    $0x8,%eax
f011f6e3:	83 ec 04             	sub    $0x4,%esp
f011f6e6:	6a 01                	push   $0x1
f011f6e8:	50                   	push   %eax
f011f6e9:	ff 75 cc             	pushl  -0x34(%ebp)
f011f6ec:	e8 ae fe ff ff       	call   f011f59f <set_block_data>
f011f6f1:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f011f6f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f6f7:	8b 40 04             	mov    0x4(%eax),%eax
f011f6fa:	85 c0                	test   %eax,%eax
f011f6fc:	75 68                	jne    f011f766 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f011f6fe:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011f702:	75 17                	jne    f011f71b <alloc_block_FF+0x14d>
f011f704:	83 ec 04             	sub    $0x4,%esp
f011f707:	68 f0 00 13 f0       	push   $0xf01300f0
f011f70c:	68 d2 00 00 00       	push   $0xd2
f011f711:	68 d5 00 13 f0       	push   $0xf01300d5
f011f716:	e8 1e 0c fe ff       	call   f0100339 <_panic>
f011f71b:	8b 15 d0 c5 5e f0    	mov    0xf05ec5d0,%edx
f011f721:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f724:	89 10                	mov    %edx,(%eax)
f011f726:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f729:	8b 00                	mov    (%eax),%eax
f011f72b:	85 c0                	test   %eax,%eax
f011f72d:	74 0d                	je     f011f73c <alloc_block_FF+0x16e>
f011f72f:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f011f734:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011f737:	89 50 04             	mov    %edx,0x4(%eax)
f011f73a:	eb 08                	jmp    f011f744 <alloc_block_FF+0x176>
f011f73c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f73f:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f744:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f747:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011f74c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f74f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f756:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f75b:	40                   	inc    %eax
f011f75c:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f011f761:	e9 dc 00 00 00       	jmp    f011f842 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f011f766:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f769:	8b 00                	mov    (%eax),%eax
f011f76b:	85 c0                	test   %eax,%eax
f011f76d:	75 65                	jne    f011f7d4 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f011f76f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011f773:	75 17                	jne    f011f78c <alloc_block_FF+0x1be>
f011f775:	83 ec 04             	sub    $0x4,%esp
f011f778:	68 24 01 13 f0       	push   $0xf0130124
f011f77d:	68 d6 00 00 00       	push   $0xd6
f011f782:	68 d5 00 13 f0       	push   $0xf01300d5
f011f787:	e8 ad 0b fe ff       	call   f0100339 <_panic>
f011f78c:	8b 15 d4 c5 5e f0    	mov    0xf05ec5d4,%edx
f011f792:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f795:	89 50 04             	mov    %edx,0x4(%eax)
f011f798:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f79b:	8b 40 04             	mov    0x4(%eax),%eax
f011f79e:	85 c0                	test   %eax,%eax
f011f7a0:	74 0c                	je     f011f7ae <alloc_block_FF+0x1e0>
f011f7a2:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f011f7a7:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011f7aa:	89 10                	mov    %edx,(%eax)
f011f7ac:	eb 08                	jmp    f011f7b6 <alloc_block_FF+0x1e8>
f011f7ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f7b1:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011f7b6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f7b9:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f7be:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f7c1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f7c7:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f7cc:	40                   	inc    %eax
f011f7cd:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f011f7d2:	eb 6e                	jmp    f011f842 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f011f7d4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f7d8:	74 06                	je     f011f7e0 <alloc_block_FF+0x212>
f011f7da:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011f7de:	75 17                	jne    f011f7f7 <alloc_block_FF+0x229>
f011f7e0:	83 ec 04             	sub    $0x4,%esp
f011f7e3:	68 48 01 13 f0       	push   $0xf0130148
f011f7e8:	68 da 00 00 00       	push   $0xda
f011f7ed:	68 d5 00 13 f0       	push   $0xf01300d5
f011f7f2:	e8 42 0b fe ff       	call   f0100339 <_panic>
f011f7f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f7fa:	8b 10                	mov    (%eax),%edx
f011f7fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f7ff:	89 10                	mov    %edx,(%eax)
f011f801:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f804:	8b 00                	mov    (%eax),%eax
f011f806:	85 c0                	test   %eax,%eax
f011f808:	74 0b                	je     f011f815 <alloc_block_FF+0x247>
f011f80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f80d:	8b 00                	mov    (%eax),%eax
f011f80f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011f812:	89 50 04             	mov    %edx,0x4(%eax)
f011f815:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f818:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011f81b:	89 10                	mov    %edx,(%eax)
f011f81d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f820:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f823:	89 50 04             	mov    %edx,0x4(%eax)
f011f826:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f829:	8b 00                	mov    (%eax),%eax
f011f82b:	85 c0                	test   %eax,%eax
f011f82d:	75 08                	jne    f011f837 <alloc_block_FF+0x269>
f011f82f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f832:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f837:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f83c:	40                   	inc    %eax
f011f83d:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f011f842:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f846:	75 17                	jne    f011f85f <alloc_block_FF+0x291>
f011f848:	83 ec 04             	sub    $0x4,%esp
f011f84b:	68 b7 00 13 f0       	push   $0xf01300b7
f011f850:	68 dc 00 00 00       	push   $0xdc
f011f855:	68 d5 00 13 f0       	push   $0xf01300d5
f011f85a:	e8 da 0a fe ff       	call   f0100339 <_panic>
f011f85f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f862:	8b 00                	mov    (%eax),%eax
f011f864:	85 c0                	test   %eax,%eax
f011f866:	74 10                	je     f011f878 <alloc_block_FF+0x2aa>
f011f868:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f86b:	8b 00                	mov    (%eax),%eax
f011f86d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f870:	8b 52 04             	mov    0x4(%edx),%edx
f011f873:	89 50 04             	mov    %edx,0x4(%eax)
f011f876:	eb 0b                	jmp    f011f883 <alloc_block_FF+0x2b5>
f011f878:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f87b:	8b 40 04             	mov    0x4(%eax),%eax
f011f87e:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f883:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f886:	8b 40 04             	mov    0x4(%eax),%eax
f011f889:	85 c0                	test   %eax,%eax
f011f88b:	74 0f                	je     f011f89c <alloc_block_FF+0x2ce>
f011f88d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f890:	8b 40 04             	mov    0x4(%eax),%eax
f011f893:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f896:	8b 12                	mov    (%edx),%edx
f011f898:	89 10                	mov    %edx,(%eax)
f011f89a:	eb 0a                	jmp    f011f8a6 <alloc_block_FF+0x2d8>
f011f89c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f89f:	8b 00                	mov    (%eax),%eax
f011f8a1:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011f8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f8a9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f8af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f8b2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f8b9:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f8be:	48                   	dec    %eax
f011f8bf:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
				set_block_data(new_block_va, remaining_size, 0);
f011f8c4:	83 ec 04             	sub    $0x4,%esp
f011f8c7:	6a 00                	push   $0x0
f011f8c9:	ff 75 c4             	pushl  -0x3c(%ebp)
f011f8cc:	ff 75 c0             	pushl  -0x40(%ebp)
f011f8cf:	e8 cb fc ff ff       	call   f011f59f <set_block_data>
f011f8d4:	83 c4 10             	add    $0x10,%esp
f011f8d7:	e9 95 00 00 00       	jmp    f011f971 <alloc_block_FF+0x3a3>
	            }
	            else
	            {
	            	set_block_data(va, blk_size, 1);
f011f8dc:	83 ec 04             	sub    $0x4,%esp
f011f8df:	6a 01                	push   $0x1
f011f8e1:	ff 75 c8             	pushl  -0x38(%ebp)
f011f8e4:	ff 75 cc             	pushl  -0x34(%ebp)
f011f8e7:	e8 b3 fc ff ff       	call   f011f59f <set_block_data>
f011f8ec:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f011f8ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f8f3:	75 17                	jne    f011f90c <alloc_block_FF+0x33e>
f011f8f5:	83 ec 04             	sub    $0x4,%esp
f011f8f8:	68 b7 00 13 f0       	push   $0xf01300b7
f011f8fd:	68 e2 00 00 00       	push   $0xe2
f011f902:	68 d5 00 13 f0       	push   $0xf01300d5
f011f907:	e8 2d 0a fe ff       	call   f0100339 <_panic>
f011f90c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f90f:	8b 00                	mov    (%eax),%eax
f011f911:	85 c0                	test   %eax,%eax
f011f913:	74 10                	je     f011f925 <alloc_block_FF+0x357>
f011f915:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f918:	8b 00                	mov    (%eax),%eax
f011f91a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f91d:	8b 52 04             	mov    0x4(%edx),%edx
f011f920:	89 50 04             	mov    %edx,0x4(%eax)
f011f923:	eb 0b                	jmp    f011f930 <alloc_block_FF+0x362>
f011f925:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f928:	8b 40 04             	mov    0x4(%eax),%eax
f011f92b:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011f930:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f933:	8b 40 04             	mov    0x4(%eax),%eax
f011f936:	85 c0                	test   %eax,%eax
f011f938:	74 0f                	je     f011f949 <alloc_block_FF+0x37b>
f011f93a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f93d:	8b 40 04             	mov    0x4(%eax),%eax
f011f940:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f943:	8b 12                	mov    (%edx),%edx
f011f945:	89 10                	mov    %edx,(%eax)
f011f947:	eb 0a                	jmp    f011f953 <alloc_block_FF+0x385>
f011f949:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f94c:	8b 00                	mov    (%eax),%eax
f011f94e:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011f953:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f956:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f95c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f95f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f966:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011f96b:	48                   	dec    %eax
f011f96c:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
	            }
	            return va;
f011f971:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f974:	e9 92 00 00 00       	jmp    f011fa0b <alloc_block_FF+0x43d>

	 if (size == 0) {
	        return NULL;
	    }
	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f011f979:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f011f97e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f981:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f985:	74 07                	je     f011f98e <alloc_block_FF+0x3c0>
f011f987:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f98a:	8b 00                	mov    (%eax),%eax
f011f98c:	eb 05                	jmp    f011f993 <alloc_block_FF+0x3c5>
f011f98e:	b8 00 00 00 00       	mov    $0x0,%eax
f011f993:	a3 d8 c5 5e f0       	mov    %eax,0xf05ec5d8
f011f998:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f011f99d:	85 c0                	test   %eax,%eax
f011f99f:	0f 85 e9 fc ff ff    	jne    f011f68e <alloc_block_FF+0xc0>
f011f9a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f9a9:	0f 85 df fc ff ff    	jne    f011f68e <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f011f9af:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9b2:	83 c0 08             	add    $0x8,%eax
f011f9b5:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f011f9b8:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f011f9bf:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011f9c2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f9c5:	01 d0                	add    %edx,%eax
f011f9c7:	48                   	dec    %eax
f011f9c8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011f9cb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011f9ce:	ba 00 00 00 00       	mov    $0x0,%edx
f011f9d3:	f7 75 d8             	divl   -0x28(%ebp)
f011f9d6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011f9d9:	29 d0                	sub    %edx,%eax
f011f9db:	c1 e8 0c             	shr    $0xc,%eax
f011f9de:	83 ec 0c             	sub    $0xc,%esp
f011f9e1:	50                   	push   %eax
f011f9e2:	e8 17 92 fe ff       	call   f0108bfe <sbrk>
f011f9e7:	83 c4 10             	add    $0x10,%esp
f011f9ea:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f011f9ed:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f011f9f1:	75 07                	jne    f011f9fa <alloc_block_FF+0x42c>
			return NULL; // Allocation failed
f011f9f3:	b8 00 00 00 00       	mov    $0x0,%eax
f011f9f8:	eb 11                	jmp    f011fa0b <alloc_block_FF+0x43d>
		}
		//set_block_data(new_mem, required_size, 1);
		alloc_block_FF(size);
f011f9fa:	83 ec 0c             	sub    $0xc,%esp
f011f9fd:	ff 75 08             	pushl  0x8(%ebp)
f011fa00:	e8 c9 fb ff ff       	call   f011f5ce <alloc_block_FF>
f011fa05:	83 c4 10             	add    $0x10,%esp
		return new_mem;
f011fa08:	8b 45 d0             	mov    -0x30(%ebp),%eax
}
f011fa0b:	c9                   	leave  
f011fa0c:	c3                   	ret    

f011fa0d <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f011fa0d:	55                   	push   %ebp
f011fa0e:	89 e5                	mov    %esp,%ebp
f011fa10:	83 ec 58             	sub    $0x58,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f011fa13:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa16:	83 e0 01             	and    $0x1,%eax
f011fa19:	85 c0                	test   %eax,%eax
f011fa1b:	74 03                	je     f011fa20 <alloc_block_BF+0x13>
f011fa1d:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f011fa20:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f011fa24:	77 07                	ja     f011fa2d <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f011fa26:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f011fa2d:	a1 54 c2 5e f0       	mov    0xf05ec254,%eax
f011fa32:	85 c0                	test   %eax,%eax
f011fa34:	75 73                	jne    f011faa9 <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f011fa36:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa39:	83 c0 10             	add    $0x10,%eax
f011fa3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f011fa3f:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f011fa46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fa49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fa4c:	01 d0                	add    %edx,%eax
f011fa4e:	48                   	dec    %eax
f011fa4f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011fa52:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fa55:	ba 00 00 00 00       	mov    $0x0,%edx
f011fa5a:	f7 75 e0             	divl   -0x20(%ebp)
f011fa5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fa60:	29 d0                	sub    %edx,%eax
f011fa62:	c1 e8 0c             	shr    $0xc,%eax
f011fa65:	83 ec 0c             	sub    $0xc,%esp
f011fa68:	50                   	push   %eax
f011fa69:	e8 90 91 fe ff       	call   f0108bfe <sbrk>
f011fa6e:	83 c4 10             	add    $0x10,%esp
f011fa71:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f011fa74:	83 ec 0c             	sub    $0xc,%esp
f011fa77:	6a 00                	push   $0x0
f011fa79:	e8 80 91 fe ff       	call   f0108bfe <sbrk>
f011fa7e:	83 c4 10             	add    $0x10,%esp
f011fa81:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f011fa84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fa87:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011fa8a:	83 ec 08             	sub    $0x8,%esp
f011fa8d:	50                   	push   %eax
f011fa8e:	ff 75 d8             	pushl  -0x28(%ebp)
f011fa91:	e8 28 f9 ff ff       	call   f011f3be <initialize_dynamic_allocator>
f011fa96:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f011fa99:	83 ec 0c             	sub    $0xc,%esp
f011fa9c:	68 13 01 13 f0       	push   $0xf0130113
f011faa1:	e8 e5 14 fe ff       	call   f0100f8b <cprintf>
f011faa6:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f011faa9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f011fab0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f011fab7:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f011fabe:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f011fac5:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f011faca:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011facd:	e9 1d 01 00 00       	jmp    f011fbef <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f011fad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fad5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		uint32 blk_size = get_block_size(va);
f011fad8:	83 ec 0c             	sub    $0xc,%esp
f011fadb:	ff 75 b8             	pushl  -0x48(%ebp)
f011fade:	e8 77 f7 ff ff       	call   f011f25a <get_block_size>
f011fae3:	83 c4 10             	add    $0x10,%esp
f011fae6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f011fae9:	8b 45 08             	mov    0x8(%ebp),%eax
f011faec:	83 c0 08             	add    $0x8,%eax
f011faef:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011faf2:	0f 87 ef 00 00 00    	ja     f011fbe7 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f011faf8:	8b 45 08             	mov    0x8(%ebp),%eax
f011fafb:	83 c0 18             	add    $0x18,%eax
f011fafe:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011fb01:	77 1d                	ja     f011fb20 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f011fb03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fb06:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011fb09:	0f 86 d8 00 00 00    	jbe    f011fbe7 <alloc_block_BF+0x1da>
				{
					best_va = va;
f011fb0f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011fb12:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f011fb15:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011fb18:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fb1b:	e9 c7 00 00 00       	jmp    f011fbe7 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f011fb20:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb23:	83 c0 08             	add    $0x8,%eax
f011fb26:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011fb29:	0f 85 9d 00 00 00    	jne    f011fbcc <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f011fb2f:	83 ec 04             	sub    $0x4,%esp
f011fb32:	6a 01                	push   $0x1
f011fb34:	ff 75 b4             	pushl  -0x4c(%ebp)
f011fb37:	ff 75 b8             	pushl  -0x48(%ebp)
f011fb3a:	e8 60 fa ff ff       	call   f011f59f <set_block_data>
f011fb3f:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f011fb42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fb46:	75 17                	jne    f011fb5f <alloc_block_BF+0x152>
f011fb48:	83 ec 04             	sub    $0x4,%esp
f011fb4b:	68 b7 00 13 f0       	push   $0xf01300b7
f011fb50:	68 21 01 00 00       	push   $0x121
f011fb55:	68 d5 00 13 f0       	push   $0xf01300d5
f011fb5a:	e8 da 07 fe ff       	call   f0100339 <_panic>
f011fb5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb62:	8b 00                	mov    (%eax),%eax
f011fb64:	85 c0                	test   %eax,%eax
f011fb66:	74 10                	je     f011fb78 <alloc_block_BF+0x16b>
f011fb68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb6b:	8b 00                	mov    (%eax),%eax
f011fb6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb70:	8b 52 04             	mov    0x4(%edx),%edx
f011fb73:	89 50 04             	mov    %edx,0x4(%eax)
f011fb76:	eb 0b                	jmp    f011fb83 <alloc_block_BF+0x176>
f011fb78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb7b:	8b 40 04             	mov    0x4(%eax),%eax
f011fb7e:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011fb83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb86:	8b 40 04             	mov    0x4(%eax),%eax
f011fb89:	85 c0                	test   %eax,%eax
f011fb8b:	74 0f                	je     f011fb9c <alloc_block_BF+0x18f>
f011fb8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb90:	8b 40 04             	mov    0x4(%eax),%eax
f011fb93:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb96:	8b 12                	mov    (%edx),%edx
f011fb98:	89 10                	mov    %edx,(%eax)
f011fb9a:	eb 0a                	jmp    f011fba6 <alloc_block_BF+0x199>
f011fb9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb9f:	8b 00                	mov    (%eax),%eax
f011fba1:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011fba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fba9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fbaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbb2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fbb9:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011fbbe:	48                   	dec    %eax
f011fbbf:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
					return va;
f011fbc4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011fbc7:	e9 86 03 00 00       	jmp    f011ff52 <alloc_block_BF+0x545>
				}
				else
				{
					if (best_blk_size > blk_size)
f011fbcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fbcf:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011fbd2:	76 13                	jbe    f011fbe7 <alloc_block_BF+0x1da>
					{
						internal = 1;
f011fbd4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f011fbdb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011fbde:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f011fbe1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011fbe4:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f011fbe7:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f011fbec:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fbef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fbf3:	74 07                	je     f011fbfc <alloc_block_BF+0x1ef>
f011fbf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbf8:	8b 00                	mov    (%eax),%eax
f011fbfa:	eb 05                	jmp    f011fc01 <alloc_block_BF+0x1f4>
f011fbfc:	b8 00 00 00 00       	mov    $0x0,%eax
f011fc01:	a3 d8 c5 5e f0       	mov    %eax,0xf05ec5d8
f011fc06:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f011fc0b:	85 c0                	test   %eax,%eax
f011fc0d:	0f 85 bf fe ff ff    	jne    f011fad2 <alloc_block_BF+0xc5>
f011fc13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fc17:	0f 85 b5 fe ff ff    	jne    f011fad2 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f011fc1d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fc21:	0f 84 26 02 00 00    	je     f011fe4d <alloc_block_BF+0x440>
f011fc27:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011fc2b:	0f 85 1c 02 00 00    	jne    f011fe4d <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f011fc31:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fc34:	2b 45 08             	sub    0x8(%ebp),%eax
f011fc37:	83 e8 08             	sub    $0x8,%eax
f011fc3a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f011fc3d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc40:	8d 50 08             	lea    0x8(%eax),%edx
f011fc43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fc46:	01 d0                	add    %edx,%eax
f011fc48:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f011fc4b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc4e:	83 c0 08             	add    $0x8,%eax
f011fc51:	83 ec 04             	sub    $0x4,%esp
f011fc54:	6a 01                	push   $0x1
f011fc56:	50                   	push   %eax
f011fc57:	ff 75 f0             	pushl  -0x10(%ebp)
f011fc5a:	e8 40 f9 ff ff       	call   f011f59f <set_block_data>
f011fc5f:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f011fc62:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fc65:	8b 40 04             	mov    0x4(%eax),%eax
f011fc68:	85 c0                	test   %eax,%eax
f011fc6a:	75 68                	jne    f011fcd4 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f011fc6c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011fc70:	75 17                	jne    f011fc89 <alloc_block_BF+0x27c>
f011fc72:	83 ec 04             	sub    $0x4,%esp
f011fc75:	68 f0 00 13 f0       	push   $0xf01300f0
f011fc7a:	68 3a 01 00 00       	push   $0x13a
f011fc7f:	68 d5 00 13 f0       	push   $0xf01300d5
f011fc84:	e8 b0 06 fe ff       	call   f0100339 <_panic>
f011fc89:	8b 15 d0 c5 5e f0    	mov    0xf05ec5d0,%edx
f011fc8f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fc92:	89 10                	mov    %edx,(%eax)
f011fc94:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fc97:	8b 00                	mov    (%eax),%eax
f011fc99:	85 c0                	test   %eax,%eax
f011fc9b:	74 0d                	je     f011fcaa <alloc_block_BF+0x29d>
f011fc9d:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f011fca2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011fca5:	89 50 04             	mov    %edx,0x4(%eax)
f011fca8:	eb 08                	jmp    f011fcb2 <alloc_block_BF+0x2a5>
f011fcaa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fcad:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011fcb2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fcb5:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011fcba:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fcbd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fcc4:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011fcc9:	40                   	inc    %eax
f011fcca:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f011fccf:	e9 dc 00 00 00       	jmp    f011fdb0 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f011fcd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fcd7:	8b 00                	mov    (%eax),%eax
f011fcd9:	85 c0                	test   %eax,%eax
f011fcdb:	75 65                	jne    f011fd42 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f011fcdd:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011fce1:	75 17                	jne    f011fcfa <alloc_block_BF+0x2ed>
f011fce3:	83 ec 04             	sub    $0x4,%esp
f011fce6:	68 24 01 13 f0       	push   $0xf0130124
f011fceb:	68 3f 01 00 00       	push   $0x13f
f011fcf0:	68 d5 00 13 f0       	push   $0xf01300d5
f011fcf5:	e8 3f 06 fe ff       	call   f0100339 <_panic>
f011fcfa:	8b 15 d4 c5 5e f0    	mov    0xf05ec5d4,%edx
f011fd00:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd03:	89 50 04             	mov    %edx,0x4(%eax)
f011fd06:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd09:	8b 40 04             	mov    0x4(%eax),%eax
f011fd0c:	85 c0                	test   %eax,%eax
f011fd0e:	74 0c                	je     f011fd1c <alloc_block_BF+0x30f>
f011fd10:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f011fd15:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011fd18:	89 10                	mov    %edx,(%eax)
f011fd1a:	eb 08                	jmp    f011fd24 <alloc_block_BF+0x317>
f011fd1c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd1f:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011fd24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd27:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011fd2c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd2f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fd35:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011fd3a:	40                   	inc    %eax
f011fd3b:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f011fd40:	eb 6e                	jmp    f011fdb0 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f011fd42:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fd46:	74 06                	je     f011fd4e <alloc_block_BF+0x341>
f011fd48:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011fd4c:	75 17                	jne    f011fd65 <alloc_block_BF+0x358>
f011fd4e:	83 ec 04             	sub    $0x4,%esp
f011fd51:	68 48 01 13 f0       	push   $0xf0130148
f011fd56:	68 44 01 00 00       	push   $0x144
f011fd5b:	68 d5 00 13 f0       	push   $0xf01300d5
f011fd60:	e8 d4 05 fe ff       	call   f0100339 <_panic>
f011fd65:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd68:	8b 10                	mov    (%eax),%edx
f011fd6a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd6d:	89 10                	mov    %edx,(%eax)
f011fd6f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd72:	8b 00                	mov    (%eax),%eax
f011fd74:	85 c0                	test   %eax,%eax
f011fd76:	74 0b                	je     f011fd83 <alloc_block_BF+0x376>
f011fd78:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd7b:	8b 00                	mov    (%eax),%eax
f011fd7d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011fd80:	89 50 04             	mov    %edx,0x4(%eax)
f011fd83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd86:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011fd89:	89 10                	mov    %edx,(%eax)
f011fd8b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd8e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fd91:	89 50 04             	mov    %edx,0x4(%eax)
f011fd94:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fd97:	8b 00                	mov    (%eax),%eax
f011fd99:	85 c0                	test   %eax,%eax
f011fd9b:	75 08                	jne    f011fda5 <alloc_block_BF+0x398>
f011fd9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fda0:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011fda5:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011fdaa:	40                   	inc    %eax
f011fdab:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f011fdb0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fdb4:	75 17                	jne    f011fdcd <alloc_block_BF+0x3c0>
f011fdb6:	83 ec 04             	sub    $0x4,%esp
f011fdb9:	68 b7 00 13 f0       	push   $0xf01300b7
f011fdbe:	68 46 01 00 00       	push   $0x146
f011fdc3:	68 d5 00 13 f0       	push   $0xf01300d5
f011fdc8:	e8 6c 05 fe ff       	call   f0100339 <_panic>
f011fdcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fdd0:	8b 00                	mov    (%eax),%eax
f011fdd2:	85 c0                	test   %eax,%eax
f011fdd4:	74 10                	je     f011fde6 <alloc_block_BF+0x3d9>
f011fdd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fdd9:	8b 00                	mov    (%eax),%eax
f011fddb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fdde:	8b 52 04             	mov    0x4(%edx),%edx
f011fde1:	89 50 04             	mov    %edx,0x4(%eax)
f011fde4:	eb 0b                	jmp    f011fdf1 <alloc_block_BF+0x3e4>
f011fde6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fde9:	8b 40 04             	mov    0x4(%eax),%eax
f011fdec:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011fdf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fdf4:	8b 40 04             	mov    0x4(%eax),%eax
f011fdf7:	85 c0                	test   %eax,%eax
f011fdf9:	74 0f                	je     f011fe0a <alloc_block_BF+0x3fd>
f011fdfb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fdfe:	8b 40 04             	mov    0x4(%eax),%eax
f011fe01:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fe04:	8b 12                	mov    (%edx),%edx
f011fe06:	89 10                	mov    %edx,(%eax)
f011fe08:	eb 0a                	jmp    f011fe14 <alloc_block_BF+0x407>
f011fe0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fe0d:	8b 00                	mov    (%eax),%eax
f011fe0f:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011fe14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fe17:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fe1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fe20:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fe27:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011fe2c:	48                   	dec    %eax
f011fe2d:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
			set_block_data(new_block_va, remaining_size, 0);
f011fe32:	83 ec 04             	sub    $0x4,%esp
f011fe35:	6a 00                	push   $0x0
f011fe37:	ff 75 d0             	pushl  -0x30(%ebp)
f011fe3a:	ff 75 cc             	pushl  -0x34(%ebp)
f011fe3d:	e8 5d f7 ff ff       	call   f011f59f <set_block_data>
f011fe42:	83 c4 10             	add    $0x10,%esp
			return best_va;
f011fe45:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fe48:	e9 05 01 00 00       	jmp    f011ff52 <alloc_block_BF+0x545>
	}
	else if(internal == 1)
f011fe4d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011fe51:	0f 85 9a 00 00 00    	jne    f011fef1 <alloc_block_BF+0x4e4>
	{
		set_block_data(best_va, best_blk_size, 1);
f011fe57:	83 ec 04             	sub    $0x4,%esp
f011fe5a:	6a 01                	push   $0x1
f011fe5c:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe5f:	ff 75 f0             	pushl  -0x10(%ebp)
f011fe62:	e8 38 f7 ff ff       	call   f011f59f <set_block_data>
f011fe67:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f011fe6a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe6e:	75 17                	jne    f011fe87 <alloc_block_BF+0x47a>
f011fe70:	83 ec 04             	sub    $0x4,%esp
f011fe73:	68 b7 00 13 f0       	push   $0xf01300b7
f011fe78:	68 4d 01 00 00       	push   $0x14d
f011fe7d:	68 d5 00 13 f0       	push   $0xf01300d5
f011fe82:	e8 b2 04 fe ff       	call   f0100339 <_panic>
f011fe87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fe8a:	8b 00                	mov    (%eax),%eax
f011fe8c:	85 c0                	test   %eax,%eax
f011fe8e:	74 10                	je     f011fea0 <alloc_block_BF+0x493>
f011fe90:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fe93:	8b 00                	mov    (%eax),%eax
f011fe95:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fe98:	8b 52 04             	mov    0x4(%edx),%edx
f011fe9b:	89 50 04             	mov    %edx,0x4(%eax)
f011fe9e:	eb 0b                	jmp    f011feab <alloc_block_BF+0x49e>
f011fea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fea3:	8b 40 04             	mov    0x4(%eax),%eax
f011fea6:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f011feab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011feae:	8b 40 04             	mov    0x4(%eax),%eax
f011feb1:	85 c0                	test   %eax,%eax
f011feb3:	74 0f                	je     f011fec4 <alloc_block_BF+0x4b7>
f011feb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011feb8:	8b 40 04             	mov    0x4(%eax),%eax
f011febb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011febe:	8b 12                	mov    (%edx),%edx
f011fec0:	89 10                	mov    %edx,(%eax)
f011fec2:	eb 0a                	jmp    f011fece <alloc_block_BF+0x4c1>
f011fec4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fec7:	8b 00                	mov    (%eax),%eax
f011fec9:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f011fece:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fed1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fed7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011feda:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fee1:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f011fee6:	48                   	dec    %eax
f011fee7:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
		return best_va;
f011feec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011feef:	eb 61                	jmp    f011ff52 <alloc_block_BF+0x545>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f011fef1:	8b 45 08             	mov    0x8(%ebp),%eax
f011fef4:	83 c0 08             	add    $0x8,%eax
f011fef7:	89 45 c8             	mov    %eax,-0x38(%ebp)
	void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f011fefa:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f011ff01:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011ff04:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ff07:	01 d0                	add    %edx,%eax
f011ff09:	48                   	dec    %eax
f011ff0a:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011ff0d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ff10:	ba 00 00 00 00       	mov    $0x0,%edx
f011ff15:	f7 75 c4             	divl   -0x3c(%ebp)
f011ff18:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ff1b:	29 d0                	sub    %edx,%eax
f011ff1d:	c1 e8 0c             	shr    $0xc,%eax
f011ff20:	83 ec 0c             	sub    $0xc,%esp
f011ff23:	50                   	push   %eax
f011ff24:	e8 d5 8c fe ff       	call   f0108bfe <sbrk>
f011ff29:	83 c4 10             	add    $0x10,%esp
f011ff2c:	89 45 bc             	mov    %eax,-0x44(%ebp)
	if (new_mem == (void *)-1) {
f011ff2f:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f011ff33:	75 07                	jne    f011ff3c <alloc_block_BF+0x52f>
		return NULL; // Allocation failed
f011ff35:	b8 00 00 00 00       	mov    $0x0,%eax
f011ff3a:	eb 16                	jmp    f011ff52 <alloc_block_BF+0x545>
	}
	set_block_data(new_mem, required_size, 1);
f011ff3c:	83 ec 04             	sub    $0x4,%esp
f011ff3f:	6a 01                	push   $0x1
f011ff41:	ff 75 c8             	pushl  -0x38(%ebp)
f011ff44:	ff 75 bc             	pushl  -0x44(%ebp)
f011ff47:	e8 53 f6 ff ff       	call   f011f59f <set_block_data>
f011ff4c:	83 c4 10             	add    $0x10,%esp
	return new_mem;
f011ff4f:	8b 45 bc             	mov    -0x44(%ebp),%eax
}
f011ff52:	c9                   	leave  
f011ff53:	c3                   	ret    

f011ff54 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f011ff54:	55                   	push   %ebp
f011ff55:	89 e5                	mov    %esp,%ebp
f011ff57:	53                   	push   %ebx
f011ff58:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f011ff5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ff62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f011ff69:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ff6d:	74 1e                	je     f011ff8d <merging+0x39>
f011ff6f:	ff 75 08             	pushl  0x8(%ebp)
f011ff72:	e8 e3 f2 ff ff       	call   f011f25a <get_block_size>
f011ff77:	83 c4 04             	add    $0x4,%esp
f011ff7a:	89 c2                	mov    %eax,%edx
f011ff7c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff7f:	01 d0                	add    %edx,%eax
f011ff81:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ff84:	75 07                	jne    f011ff8d <merging+0x39>
		prev_is_free = 1;
f011ff86:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f011ff8d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ff91:	74 1e                	je     f011ffb1 <merging+0x5d>
f011ff93:	ff 75 10             	pushl  0x10(%ebp)
f011ff96:	e8 bf f2 ff ff       	call   f011f25a <get_block_size>
f011ff9b:	83 c4 04             	add    $0x4,%esp
f011ff9e:	89 c2                	mov    %eax,%edx
f011ffa0:	8b 45 10             	mov    0x10(%ebp),%eax
f011ffa3:	01 d0                	add    %edx,%eax
f011ffa5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ffa8:	75 07                	jne    f011ffb1 <merging+0x5d>
		next_is_free = 1;
f011ffaa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f011ffb1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ffb5:	0f 84 cc 00 00 00    	je     f0120087 <merging+0x133>
f011ffbb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ffbf:	0f 84 c2 00 00 00    	je     f0120087 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f011ffc5:	ff 75 08             	pushl  0x8(%ebp)
f011ffc8:	e8 8d f2 ff ff       	call   f011f25a <get_block_size>
f011ffcd:	83 c4 04             	add    $0x4,%esp
f011ffd0:	89 c3                	mov    %eax,%ebx
f011ffd2:	ff 75 10             	pushl  0x10(%ebp)
f011ffd5:	e8 80 f2 ff ff       	call   f011f25a <get_block_size>
f011ffda:	83 c4 04             	add    $0x4,%esp
f011ffdd:	01 c3                	add    %eax,%ebx
f011ffdf:	ff 75 0c             	pushl  0xc(%ebp)
f011ffe2:	e8 73 f2 ff ff       	call   f011f25a <get_block_size>
f011ffe7:	83 c4 04             	add    $0x4,%esp
f011ffea:	01 d8                	add    %ebx,%eax
f011ffec:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f011ffef:	6a 00                	push   $0x0
f011fff1:	ff 75 ec             	pushl  -0x14(%ebp)
f011fff4:	ff 75 08             	pushl  0x8(%ebp)
f011fff7:	e8 a3 f5 ff ff       	call   f011f59f <set_block_data>
f011fffc:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f011ffff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120003:	75 17                	jne    f012001c <merging+0xc8>
f0120005:	83 ec 04             	sub    $0x4,%esp
f0120008:	68 b7 00 13 f0       	push   $0xf01300b7
f012000d:	68 6a 01 00 00       	push   $0x16a
f0120012:	68 d5 00 13 f0       	push   $0xf01300d5
f0120017:	e8 1d 03 fe ff       	call   f0100339 <_panic>
f012001c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012001f:	8b 00                	mov    (%eax),%eax
f0120021:	85 c0                	test   %eax,%eax
f0120023:	74 10                	je     f0120035 <merging+0xe1>
f0120025:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120028:	8b 00                	mov    (%eax),%eax
f012002a:	8b 55 0c             	mov    0xc(%ebp),%edx
f012002d:	8b 52 04             	mov    0x4(%edx),%edx
f0120030:	89 50 04             	mov    %edx,0x4(%eax)
f0120033:	eb 0b                	jmp    f0120040 <merging+0xec>
f0120035:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120038:	8b 40 04             	mov    0x4(%eax),%eax
f012003b:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120040:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120043:	8b 40 04             	mov    0x4(%eax),%eax
f0120046:	85 c0                	test   %eax,%eax
f0120048:	74 0f                	je     f0120059 <merging+0x105>
f012004a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012004d:	8b 40 04             	mov    0x4(%eax),%eax
f0120050:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120053:	8b 12                	mov    (%edx),%edx
f0120055:	89 10                	mov    %edx,(%eax)
f0120057:	eb 0a                	jmp    f0120063 <merging+0x10f>
f0120059:	8b 45 0c             	mov    0xc(%ebp),%eax
f012005c:	8b 00                	mov    (%eax),%eax
f012005e:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f0120063:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120066:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012006c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012006f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120076:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f012007b:	48                   	dec    %eax
f012007c:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0120081:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120082:	e9 ea 02 00 00       	jmp    f0120371 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0120087:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012008b:	74 3b                	je     f01200c8 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f012008d:	83 ec 0c             	sub    $0xc,%esp
f0120090:	ff 75 08             	pushl  0x8(%ebp)
f0120093:	e8 c2 f1 ff ff       	call   f011f25a <get_block_size>
f0120098:	83 c4 10             	add    $0x10,%esp
f012009b:	89 c3                	mov    %eax,%ebx
f012009d:	83 ec 0c             	sub    $0xc,%esp
f01200a0:	ff 75 10             	pushl  0x10(%ebp)
f01200a3:	e8 b2 f1 ff ff       	call   f011f25a <get_block_size>
f01200a8:	83 c4 10             	add    $0x10,%esp
f01200ab:	01 d8                	add    %ebx,%eax
f01200ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01200b0:	83 ec 04             	sub    $0x4,%esp
f01200b3:	6a 00                	push   $0x0
f01200b5:	ff 75 e8             	pushl  -0x18(%ebp)
f01200b8:	ff 75 08             	pushl  0x8(%ebp)
f01200bb:	e8 df f4 ff ff       	call   f011f59f <set_block_data>
f01200c0:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01200c3:	e9 a9 02 00 00       	jmp    f0120371 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f01200c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01200cc:	0f 84 2d 01 00 00    	je     f01201ff <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f01200d2:	83 ec 0c             	sub    $0xc,%esp
f01200d5:	ff 75 10             	pushl  0x10(%ebp)
f01200d8:	e8 7d f1 ff ff       	call   f011f25a <get_block_size>
f01200dd:	83 c4 10             	add    $0x10,%esp
f01200e0:	89 c3                	mov    %eax,%ebx
f01200e2:	83 ec 0c             	sub    $0xc,%esp
f01200e5:	ff 75 0c             	pushl  0xc(%ebp)
f01200e8:	e8 6d f1 ff ff       	call   f011f25a <get_block_size>
f01200ed:	83 c4 10             	add    $0x10,%esp
f01200f0:	01 d8                	add    %ebx,%eax
f01200f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f01200f5:	83 ec 04             	sub    $0x4,%esp
f01200f8:	6a 00                	push   $0x0
f01200fa:	ff 75 e4             	pushl  -0x1c(%ebp)
f01200fd:	ff 75 10             	pushl  0x10(%ebp)
f0120100:	e8 9a f4 ff ff       	call   f011f59f <set_block_data>
f0120105:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0120108:	8b 45 10             	mov    0x10(%ebp),%eax
f012010b:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f012010e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120112:	74 06                	je     f012011a <merging+0x1c6>
f0120114:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0120118:	75 17                	jne    f0120131 <merging+0x1dd>
f012011a:	83 ec 04             	sub    $0x4,%esp
f012011d:	68 7c 01 13 f0       	push   $0xf013017c
f0120122:	68 7a 01 00 00       	push   $0x17a
f0120127:	68 d5 00 13 f0       	push   $0xf01300d5
f012012c:	e8 08 02 fe ff       	call   f0100339 <_panic>
f0120131:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120134:	8b 50 04             	mov    0x4(%eax),%edx
f0120137:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012013a:	89 50 04             	mov    %edx,0x4(%eax)
f012013d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120140:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120143:	89 10                	mov    %edx,(%eax)
f0120145:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120148:	8b 40 04             	mov    0x4(%eax),%eax
f012014b:	85 c0                	test   %eax,%eax
f012014d:	74 0d                	je     f012015c <merging+0x208>
f012014f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120152:	8b 40 04             	mov    0x4(%eax),%eax
f0120155:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120158:	89 10                	mov    %edx,(%eax)
f012015a:	eb 08                	jmp    f0120164 <merging+0x210>
f012015c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012015f:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f0120164:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120167:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012016a:	89 50 04             	mov    %edx,0x4(%eax)
f012016d:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120172:	40                   	inc    %eax
f0120173:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
		LIST_REMOVE(&freeBlocksList, next_block);
f0120178:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012017c:	75 17                	jne    f0120195 <merging+0x241>
f012017e:	83 ec 04             	sub    $0x4,%esp
f0120181:	68 b7 00 13 f0       	push   $0xf01300b7
f0120186:	68 7b 01 00 00       	push   $0x17b
f012018b:	68 d5 00 13 f0       	push   $0xf01300d5
f0120190:	e8 a4 01 fe ff       	call   f0100339 <_panic>
f0120195:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120198:	8b 00                	mov    (%eax),%eax
f012019a:	85 c0                	test   %eax,%eax
f012019c:	74 10                	je     f01201ae <merging+0x25a>
f012019e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201a1:	8b 00                	mov    (%eax),%eax
f01201a3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01201a6:	8b 52 04             	mov    0x4(%edx),%edx
f01201a9:	89 50 04             	mov    %edx,0x4(%eax)
f01201ac:	eb 0b                	jmp    f01201b9 <merging+0x265>
f01201ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201b1:	8b 40 04             	mov    0x4(%eax),%eax
f01201b4:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f01201b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201bc:	8b 40 04             	mov    0x4(%eax),%eax
f01201bf:	85 c0                	test   %eax,%eax
f01201c1:	74 0f                	je     f01201d2 <merging+0x27e>
f01201c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201c6:	8b 40 04             	mov    0x4(%eax),%eax
f01201c9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01201cc:	8b 12                	mov    (%edx),%edx
f01201ce:	89 10                	mov    %edx,(%eax)
f01201d0:	eb 0a                	jmp    f01201dc <merging+0x288>
f01201d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201d5:	8b 00                	mov    (%eax),%eax
f01201d7:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f01201dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201df:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01201e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201e8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01201ef:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f01201f4:	48                   	dec    %eax
f01201f5:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01201fa:	e9 72 01 00 00       	jmp    f0120371 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f01201ff:	8b 45 10             	mov    0x10(%ebp),%eax
f0120202:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0120205:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120209:	74 79                	je     f0120284 <merging+0x330>
f012020b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012020f:	74 73                	je     f0120284 <merging+0x330>
f0120211:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120215:	74 06                	je     f012021d <merging+0x2c9>
f0120217:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012021b:	75 17                	jne    f0120234 <merging+0x2e0>
f012021d:	83 ec 04             	sub    $0x4,%esp
f0120220:	68 48 01 13 f0       	push   $0xf0130148
f0120225:	68 81 01 00 00       	push   $0x181
f012022a:	68 d5 00 13 f0       	push   $0xf01300d5
f012022f:	e8 05 01 fe ff       	call   f0100339 <_panic>
f0120234:	8b 45 08             	mov    0x8(%ebp),%eax
f0120237:	8b 10                	mov    (%eax),%edx
f0120239:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012023c:	89 10                	mov    %edx,(%eax)
f012023e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120241:	8b 00                	mov    (%eax),%eax
f0120243:	85 c0                	test   %eax,%eax
f0120245:	74 0b                	je     f0120252 <merging+0x2fe>
f0120247:	8b 45 08             	mov    0x8(%ebp),%eax
f012024a:	8b 00                	mov    (%eax),%eax
f012024c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012024f:	89 50 04             	mov    %edx,0x4(%eax)
f0120252:	8b 45 08             	mov    0x8(%ebp),%eax
f0120255:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120258:	89 10                	mov    %edx,(%eax)
f012025a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012025d:	8b 55 08             	mov    0x8(%ebp),%edx
f0120260:	89 50 04             	mov    %edx,0x4(%eax)
f0120263:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120266:	8b 00                	mov    (%eax),%eax
f0120268:	85 c0                	test   %eax,%eax
f012026a:	75 08                	jne    f0120274 <merging+0x320>
f012026c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012026f:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120274:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120279:	40                   	inc    %eax
f012027a:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f012027f:	e9 ce 00 00 00       	jmp    f0120352 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0120284:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120288:	74 65                	je     f01202ef <merging+0x39b>
f012028a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012028e:	75 17                	jne    f01202a7 <merging+0x353>
f0120290:	83 ec 04             	sub    $0x4,%esp
f0120293:	68 24 01 13 f0       	push   $0xf0130124
f0120298:	68 82 01 00 00       	push   $0x182
f012029d:	68 d5 00 13 f0       	push   $0xf01300d5
f01202a2:	e8 92 00 fe ff       	call   f0100339 <_panic>
f01202a7:	8b 15 d4 c5 5e f0    	mov    0xf05ec5d4,%edx
f01202ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01202b0:	89 50 04             	mov    %edx,0x4(%eax)
f01202b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01202b6:	8b 40 04             	mov    0x4(%eax),%eax
f01202b9:	85 c0                	test   %eax,%eax
f01202bb:	74 0c                	je     f01202c9 <merging+0x375>
f01202bd:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f01202c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01202c5:	89 10                	mov    %edx,(%eax)
f01202c7:	eb 08                	jmp    f01202d1 <merging+0x37d>
f01202c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01202cc:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f01202d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01202d4:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f01202d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01202dc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01202e2:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f01202e7:	40                   	inc    %eax
f01202e8:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f01202ed:	eb 63                	jmp    f0120352 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f01202ef:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01202f3:	75 17                	jne    f012030c <merging+0x3b8>
f01202f5:	83 ec 04             	sub    $0x4,%esp
f01202f8:	68 f0 00 13 f0       	push   $0xf01300f0
f01202fd:	68 85 01 00 00       	push   $0x185
f0120302:	68 d5 00 13 f0       	push   $0xf01300d5
f0120307:	e8 2d 00 fe ff       	call   f0100339 <_panic>
f012030c:	8b 15 d0 c5 5e f0    	mov    0xf05ec5d0,%edx
f0120312:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120315:	89 10                	mov    %edx,(%eax)
f0120317:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012031a:	8b 00                	mov    (%eax),%eax
f012031c:	85 c0                	test   %eax,%eax
f012031e:	74 0d                	je     f012032d <merging+0x3d9>
f0120320:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f0120325:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120328:	89 50 04             	mov    %edx,0x4(%eax)
f012032b:	eb 08                	jmp    f0120335 <merging+0x3e1>
f012032d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120330:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120335:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120338:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f012033d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120340:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120347:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f012034c:	40                   	inc    %eax
f012034d:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
		}
		set_block_data(va, get_block_size(va), 0);
f0120352:	83 ec 0c             	sub    $0xc,%esp
f0120355:	ff 75 10             	pushl  0x10(%ebp)
f0120358:	e8 fd ee ff ff       	call   f011f25a <get_block_size>
f012035d:	83 c4 10             	add    $0x10,%esp
f0120360:	83 ec 04             	sub    $0x4,%esp
f0120363:	6a 00                	push   $0x0
f0120365:	50                   	push   %eax
f0120366:	ff 75 10             	pushl  0x10(%ebp)
f0120369:	e8 31 f2 ff ff       	call   f011f59f <set_block_data>
f012036e:	83 c4 10             	add    $0x10,%esp
	}
}
f0120371:	90                   	nop
f0120372:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120375:	c9                   	leave  
f0120376:	c3                   	ret    

f0120377 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0120377:	55                   	push   %ebp
f0120378:	89 e5                	mov    %esp,%ebp
f012037a:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f012037d:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f0120382:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0120385:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f012038a:	3b 45 08             	cmp    0x8(%ebp),%eax
f012038d:	73 1b                	jae    f01203aa <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f012038f:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f0120394:	83 ec 04             	sub    $0x4,%esp
f0120397:	ff 75 08             	pushl  0x8(%ebp)
f012039a:	6a 00                	push   $0x0
f012039c:	50                   	push   %eax
f012039d:	e8 b2 fb ff ff       	call   f011ff54 <merging>
f01203a2:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01203a5:	e9 8b 00 00 00       	jmp    f0120435 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01203aa:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f01203af:	3b 45 08             	cmp    0x8(%ebp),%eax
f01203b2:	76 18                	jbe    f01203cc <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01203b4:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f01203b9:	83 ec 04             	sub    $0x4,%esp
f01203bc:	ff 75 08             	pushl  0x8(%ebp)
f01203bf:	50                   	push   %eax
f01203c0:	6a 00                	push   $0x0
f01203c2:	e8 8d fb ff ff       	call   f011ff54 <merging>
f01203c7:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01203ca:	eb 69                	jmp    f0120435 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01203cc:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f01203d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01203d4:	eb 39                	jmp    f012040f <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f01203d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203d9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01203dc:	73 29                	jae    f0120407 <free_block+0x90>
f01203de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203e1:	8b 00                	mov    (%eax),%eax
f01203e3:	3b 45 08             	cmp    0x8(%ebp),%eax
f01203e6:	76 1f                	jbe    f0120407 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01203e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203eb:	8b 00                	mov    (%eax),%eax
f01203ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01203f0:	83 ec 04             	sub    $0x4,%esp
f01203f3:	ff 75 08             	pushl  0x8(%ebp)
f01203f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01203f9:	ff 75 f4             	pushl  -0xc(%ebp)
f01203fc:	e8 53 fb ff ff       	call   f011ff54 <merging>
f0120401:	83 c4 10             	add    $0x10,%esp
			break;
f0120404:	90                   	nop
		}
	}
}
f0120405:	eb 2e                	jmp    f0120435 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0120407:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f012040c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012040f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120413:	74 07                	je     f012041c <free_block+0xa5>
f0120415:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120418:	8b 00                	mov    (%eax),%eax
f012041a:	eb 05                	jmp    f0120421 <free_block+0xaa>
f012041c:	b8 00 00 00 00       	mov    $0x0,%eax
f0120421:	a3 d8 c5 5e f0       	mov    %eax,0xf05ec5d8
f0120426:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f012042b:	85 c0                	test   %eax,%eax
f012042d:	75 a7                	jne    f01203d6 <free_block+0x5f>
f012042f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120433:	75 a1                	jne    f01203d6 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0120435:	90                   	nop
f0120436:	c9                   	leave  
f0120437:	c3                   	ret    

f0120438 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0120438:	55                   	push   %ebp
f0120439:	89 e5                	mov    %esp,%ebp
f012043b:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f012043e:	ff 75 08             	pushl  0x8(%ebp)
f0120441:	e8 14 ee ff ff       	call   f011f25a <get_block_size>
f0120446:	83 c4 04             	add    $0x4,%esp
f0120449:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f012044c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120453:	eb 17                	jmp    f012046c <copy_data+0x34>
f0120455:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120458:	8b 45 0c             	mov    0xc(%ebp),%eax
f012045b:	01 c2                	add    %eax,%edx
f012045d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120460:	8b 45 08             	mov    0x8(%ebp),%eax
f0120463:	01 c8                	add    %ecx,%eax
f0120465:	8a 00                	mov    (%eax),%al
f0120467:	88 02                	mov    %al,(%edx)
f0120469:	ff 45 fc             	incl   -0x4(%ebp)
f012046c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012046f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0120472:	72 e1                	jb     f0120455 <copy_data+0x1d>
}
f0120474:	90                   	nop
f0120475:	c9                   	leave  
f0120476:	c3                   	ret    

f0120477 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0120477:	55                   	push   %ebp
f0120478:	89 e5                	mov    %esp,%ebp
f012047a:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f012047d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120481:	75 23                	jne    f01204a6 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0120483:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120487:	74 13                	je     f012049c <realloc_block_FF+0x25>
f0120489:	83 ec 0c             	sub    $0xc,%esp
f012048c:	ff 75 0c             	pushl  0xc(%ebp)
f012048f:	e8 3a f1 ff ff       	call   f011f5ce <alloc_block_FF>
f0120494:	83 c4 10             	add    $0x10,%esp
f0120497:	e9 f4 06 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>
		return NULL;
f012049c:	b8 00 00 00 00       	mov    $0x0,%eax
f01204a1:	e9 ea 06 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f01204a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01204aa:	75 18                	jne    f01204c4 <realloc_block_FF+0x4d>
	{
		free_block(va);
f01204ac:	83 ec 0c             	sub    $0xc,%esp
f01204af:	ff 75 08             	pushl  0x8(%ebp)
f01204b2:	e8 c0 fe ff ff       	call   f0120377 <free_block>
f01204b7:	83 c4 10             	add    $0x10,%esp
		return NULL;
f01204ba:	b8 00 00 00 00       	mov    $0x0,%eax
f01204bf:	e9 cc 06 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f01204c4:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f01204c8:	77 07                	ja     f01204d1 <realloc_block_FF+0x5a>
f01204ca:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f01204d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204d4:	83 e0 01             	and    $0x1,%eax
f01204d7:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f01204da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204dd:	83 c0 08             	add    $0x8,%eax
f01204e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f01204e3:	83 ec 0c             	sub    $0xc,%esp
f01204e6:	ff 75 08             	pushl  0x8(%ebp)
f01204e9:	e8 6c ed ff ff       	call   f011f25a <get_block_size>
f01204ee:	83 c4 10             	add    $0x10,%esp
f01204f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01204f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01204f7:	83 e8 08             	sub    $0x8,%eax
f01204fa:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f01204fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0120500:	83 e8 04             	sub    $0x4,%eax
f0120503:	8b 00                	mov    (%eax),%eax
f0120505:	83 e0 fe             	and    $0xfffffffe,%eax
f0120508:	89 c2                	mov    %eax,%edx
f012050a:	8b 45 08             	mov    0x8(%ebp),%eax
f012050d:	01 d0                	add    %edx,%eax
f012050f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0120512:	83 ec 0c             	sub    $0xc,%esp
f0120515:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120518:	e8 3d ed ff ff       	call   f011f25a <get_block_size>
f012051d:	83 c4 10             	add    $0x10,%esp
f0120520:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0120523:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120526:	83 e8 08             	sub    $0x8,%eax
f0120529:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f012052c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012052f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0120532:	75 08                	jne    f012053c <realloc_block_FF+0xc5>
	{
		 return va;
f0120534:	8b 45 08             	mov    0x8(%ebp),%eax
f0120537:	e9 54 06 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f012053c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012053f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0120542:	0f 83 e5 03 00 00    	jae    f012092d <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0120548:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012054b:	2b 45 0c             	sub    0xc(%ebp),%eax
f012054e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0120551:	83 ec 0c             	sub    $0xc,%esp
f0120554:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120557:	e8 17 ed ff ff       	call   f011f273 <is_free_block>
f012055c:	83 c4 10             	add    $0x10,%esp
f012055f:	84 c0                	test   %al,%al
f0120561:	0f 84 3b 01 00 00    	je     f01206a2 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0120567:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012056a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012056d:	01 d0                	add    %edx,%eax
f012056f:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0120572:	83 ec 04             	sub    $0x4,%esp
f0120575:	6a 01                	push   $0x1
f0120577:	ff 75 f0             	pushl  -0x10(%ebp)
f012057a:	ff 75 08             	pushl  0x8(%ebp)
f012057d:	e8 1d f0 ff ff       	call   f011f59f <set_block_data>
f0120582:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0120585:	8b 45 08             	mov    0x8(%ebp),%eax
f0120588:	83 e8 04             	sub    $0x4,%eax
f012058b:	8b 00                	mov    (%eax),%eax
f012058d:	83 e0 fe             	and    $0xfffffffe,%eax
f0120590:	89 c2                	mov    %eax,%edx
f0120592:	8b 45 08             	mov    0x8(%ebp),%eax
f0120595:	01 d0                	add    %edx,%eax
f0120597:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f012059a:	83 ec 04             	sub    $0x4,%esp
f012059d:	6a 00                	push   $0x0
f012059f:	ff 75 cc             	pushl  -0x34(%ebp)
f01205a2:	ff 75 c8             	pushl  -0x38(%ebp)
f01205a5:	e8 f5 ef ff ff       	call   f011f59f <set_block_data>
f01205aa:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f01205ad:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01205b1:	74 06                	je     f01205b9 <realloc_block_FF+0x142>
f01205b3:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01205b7:	75 17                	jne    f01205d0 <realloc_block_FF+0x159>
f01205b9:	83 ec 04             	sub    $0x4,%esp
f01205bc:	68 48 01 13 f0       	push   $0xf0130148
f01205c1:	68 e3 01 00 00       	push   $0x1e3
f01205c6:	68 d5 00 13 f0       	push   $0xf01300d5
f01205cb:	e8 69 fd fd ff       	call   f0100339 <_panic>
f01205d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01205d3:	8b 10                	mov    (%eax),%edx
f01205d5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01205d8:	89 10                	mov    %edx,(%eax)
f01205da:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01205dd:	8b 00                	mov    (%eax),%eax
f01205df:	85 c0                	test   %eax,%eax
f01205e1:	74 0b                	je     f01205ee <realloc_block_FF+0x177>
f01205e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01205e6:	8b 00                	mov    (%eax),%eax
f01205e8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01205eb:	89 50 04             	mov    %edx,0x4(%eax)
f01205ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01205f1:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01205f4:	89 10                	mov    %edx,(%eax)
f01205f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01205f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01205fc:	89 50 04             	mov    %edx,0x4(%eax)
f01205ff:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120602:	8b 00                	mov    (%eax),%eax
f0120604:	85 c0                	test   %eax,%eax
f0120606:	75 08                	jne    f0120610 <realloc_block_FF+0x199>
f0120608:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012060b:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120610:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120615:	40                   	inc    %eax
f0120616:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f012061b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012061f:	75 17                	jne    f0120638 <realloc_block_FF+0x1c1>
f0120621:	83 ec 04             	sub    $0x4,%esp
f0120624:	68 b7 00 13 f0       	push   $0xf01300b7
f0120629:	68 e4 01 00 00       	push   $0x1e4
f012062e:	68 d5 00 13 f0       	push   $0xf01300d5
f0120633:	e8 01 fd fd ff       	call   f0100339 <_panic>
f0120638:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012063b:	8b 00                	mov    (%eax),%eax
f012063d:	85 c0                	test   %eax,%eax
f012063f:	74 10                	je     f0120651 <realloc_block_FF+0x1da>
f0120641:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120644:	8b 00                	mov    (%eax),%eax
f0120646:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120649:	8b 52 04             	mov    0x4(%edx),%edx
f012064c:	89 50 04             	mov    %edx,0x4(%eax)
f012064f:	eb 0b                	jmp    f012065c <realloc_block_FF+0x1e5>
f0120651:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120654:	8b 40 04             	mov    0x4(%eax),%eax
f0120657:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f012065c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012065f:	8b 40 04             	mov    0x4(%eax),%eax
f0120662:	85 c0                	test   %eax,%eax
f0120664:	74 0f                	je     f0120675 <realloc_block_FF+0x1fe>
f0120666:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120669:	8b 40 04             	mov    0x4(%eax),%eax
f012066c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012066f:	8b 12                	mov    (%edx),%edx
f0120671:	89 10                	mov    %edx,(%eax)
f0120673:	eb 0a                	jmp    f012067f <realloc_block_FF+0x208>
f0120675:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120678:	8b 00                	mov    (%eax),%eax
f012067a:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f012067f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120682:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120688:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012068b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120692:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120697:	48                   	dec    %eax
f0120698:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f012069d:	e9 83 02 00 00       	jmp    f0120925 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f01206a2:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f01206a6:	0f 86 69 02 00 00    	jbe    f0120915 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f01206ac:	83 ec 04             	sub    $0x4,%esp
f01206af:	6a 01                	push   $0x1
f01206b1:	ff 75 f0             	pushl  -0x10(%ebp)
f01206b4:	ff 75 08             	pushl  0x8(%ebp)
f01206b7:	e8 e3 ee ff ff       	call   f011f59f <set_block_data>
f01206bc:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01206bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01206c2:	83 e8 04             	sub    $0x4,%eax
f01206c5:	8b 00                	mov    (%eax),%eax
f01206c7:	83 e0 fe             	and    $0xfffffffe,%eax
f01206ca:	89 c2                	mov    %eax,%edx
f01206cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01206cf:	01 d0                	add    %edx,%eax
f01206d1:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f01206d4:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f01206d9:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f01206dc:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01206e0:	75 68                	jne    f012074a <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f01206e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01206e6:	75 17                	jne    f01206ff <realloc_block_FF+0x288>
f01206e8:	83 ec 04             	sub    $0x4,%esp
f01206eb:	68 f0 00 13 f0       	push   $0xf01300f0
f01206f0:	68 f3 01 00 00       	push   $0x1f3
f01206f5:	68 d5 00 13 f0       	push   $0xf01300d5
f01206fa:	e8 3a fc fd ff       	call   f0100339 <_panic>
f01206ff:	8b 15 d0 c5 5e f0    	mov    0xf05ec5d0,%edx
f0120705:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120708:	89 10                	mov    %edx,(%eax)
f012070a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012070d:	8b 00                	mov    (%eax),%eax
f012070f:	85 c0                	test   %eax,%eax
f0120711:	74 0d                	je     f0120720 <realloc_block_FF+0x2a9>
f0120713:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f0120718:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012071b:	89 50 04             	mov    %edx,0x4(%eax)
f012071e:	eb 08                	jmp    f0120728 <realloc_block_FF+0x2b1>
f0120720:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120723:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120728:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012072b:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f0120730:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120733:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012073a:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f012073f:	40                   	inc    %eax
f0120740:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f0120745:	e9 b0 01 00 00       	jmp    f01208fa <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f012074a:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f012074f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120752:	76 68                	jbe    f01207bc <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0120754:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0120758:	75 17                	jne    f0120771 <realloc_block_FF+0x2fa>
f012075a:	83 ec 04             	sub    $0x4,%esp
f012075d:	68 f0 00 13 f0       	push   $0xf01300f0
f0120762:	68 f8 01 00 00       	push   $0x1f8
f0120767:	68 d5 00 13 f0       	push   $0xf01300d5
f012076c:	e8 c8 fb fd ff       	call   f0100339 <_panic>
f0120771:	8b 15 d0 c5 5e f0    	mov    0xf05ec5d0,%edx
f0120777:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012077a:	89 10                	mov    %edx,(%eax)
f012077c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012077f:	8b 00                	mov    (%eax),%eax
f0120781:	85 c0                	test   %eax,%eax
f0120783:	74 0d                	je     f0120792 <realloc_block_FF+0x31b>
f0120785:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f012078a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012078d:	89 50 04             	mov    %edx,0x4(%eax)
f0120790:	eb 08                	jmp    f012079a <realloc_block_FF+0x323>
f0120792:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120795:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f012079a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012079d:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f01207a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01207ac:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f01207b1:	40                   	inc    %eax
f01207b2:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f01207b7:	e9 3e 01 00 00       	jmp    f01208fa <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f01207bc:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f01207c1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01207c4:	73 68                	jae    f012082e <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f01207c6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01207ca:	75 17                	jne    f01207e3 <realloc_block_FF+0x36c>
f01207cc:	83 ec 04             	sub    $0x4,%esp
f01207cf:	68 24 01 13 f0       	push   $0xf0130124
f01207d4:	68 fd 01 00 00       	push   $0x1fd
f01207d9:	68 d5 00 13 f0       	push   $0xf01300d5
f01207de:	e8 56 fb fd ff       	call   f0100339 <_panic>
f01207e3:	8b 15 d4 c5 5e f0    	mov    0xf05ec5d4,%edx
f01207e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207ec:	89 50 04             	mov    %edx,0x4(%eax)
f01207ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207f2:	8b 40 04             	mov    0x4(%eax),%eax
f01207f5:	85 c0                	test   %eax,%eax
f01207f7:	74 0c                	je     f0120805 <realloc_block_FF+0x38e>
f01207f9:	a1 d4 c5 5e f0       	mov    0xf05ec5d4,%eax
f01207fe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120801:	89 10                	mov    %edx,(%eax)
f0120803:	eb 08                	jmp    f012080d <realloc_block_FF+0x396>
f0120805:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120808:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f012080d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120810:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120815:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120818:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012081e:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120823:	40                   	inc    %eax
f0120824:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
f0120829:	e9 cc 00 00 00       	jmp    f01208fa <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f012082e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0120835:	a1 d0 c5 5e f0       	mov    0xf05ec5d0,%eax
f012083a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012083d:	e9 8a 00 00 00       	jmp    f01208cc <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0120842:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120845:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120848:	73 7a                	jae    f01208c4 <realloc_block_FF+0x44d>
f012084a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012084d:	8b 00                	mov    (%eax),%eax
f012084f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120852:	73 70                	jae    f01208c4 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0120854:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120858:	74 06                	je     f0120860 <realloc_block_FF+0x3e9>
f012085a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012085e:	75 17                	jne    f0120877 <realloc_block_FF+0x400>
f0120860:	83 ec 04             	sub    $0x4,%esp
f0120863:	68 48 01 13 f0       	push   $0xf0130148
f0120868:	68 07 02 00 00       	push   $0x207
f012086d:	68 d5 00 13 f0       	push   $0xf01300d5
f0120872:	e8 c2 fa fd ff       	call   f0100339 <_panic>
f0120877:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012087a:	8b 10                	mov    (%eax),%edx
f012087c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012087f:	89 10                	mov    %edx,(%eax)
f0120881:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120884:	8b 00                	mov    (%eax),%eax
f0120886:	85 c0                	test   %eax,%eax
f0120888:	74 0b                	je     f0120895 <realloc_block_FF+0x41e>
f012088a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012088d:	8b 00                	mov    (%eax),%eax
f012088f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120892:	89 50 04             	mov    %edx,0x4(%eax)
f0120895:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120898:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012089b:	89 10                	mov    %edx,(%eax)
f012089d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01208a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01208a3:	89 50 04             	mov    %edx,0x4(%eax)
f01208a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01208a9:	8b 00                	mov    (%eax),%eax
f01208ab:	85 c0                	test   %eax,%eax
f01208ad:	75 08                	jne    f01208b7 <realloc_block_FF+0x440>
f01208af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01208b2:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f01208b7:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f01208bc:	40                   	inc    %eax
f01208bd:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
							break;
f01208c2:	eb 36                	jmp    f01208fa <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f01208c4:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f01208c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01208cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208d0:	74 07                	je     f01208d9 <realloc_block_FF+0x462>
f01208d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208d5:	8b 00                	mov    (%eax),%eax
f01208d7:	eb 05                	jmp    f01208de <realloc_block_FF+0x467>
f01208d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01208de:	a3 d8 c5 5e f0       	mov    %eax,0xf05ec5d8
f01208e3:	a1 d8 c5 5e f0       	mov    0xf05ec5d8,%eax
f01208e8:	85 c0                	test   %eax,%eax
f01208ea:	0f 85 52 ff ff ff    	jne    f0120842 <realloc_block_FF+0x3cb>
f01208f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208f4:	0f 85 48 ff ff ff    	jne    f0120842 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f01208fa:	83 ec 04             	sub    $0x4,%esp
f01208fd:	6a 00                	push   $0x0
f01208ff:	ff 75 d8             	pushl  -0x28(%ebp)
f0120902:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120905:	e8 95 ec ff ff       	call   f011f59f <set_block_data>
f012090a:	83 c4 10             	add    $0x10,%esp
				return va;
f012090d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120910:	e9 7b 02 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0120915:	83 ec 0c             	sub    $0xc,%esp
f0120918:	68 b1 01 13 f0       	push   $0xf01301b1
f012091d:	e8 69 06 fe ff       	call   f0100f8b <cprintf>
f0120922:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0120925:	8b 45 08             	mov    0x8(%ebp),%eax
f0120928:	e9 63 02 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f012092d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120930:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0120933:	0f 86 4d 02 00 00    	jbe    f0120b86 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0120939:	83 ec 0c             	sub    $0xc,%esp
f012093c:	ff 75 e4             	pushl  -0x1c(%ebp)
f012093f:	e8 2f e9 ff ff       	call   f011f273 <is_free_block>
f0120944:	83 c4 10             	add    $0x10,%esp
f0120947:	84 c0                	test   %al,%al
f0120949:	0f 84 37 02 00 00    	je     f0120b86 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f012094f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120952:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0120955:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0120958:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012095b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f012095e:	76 38                	jbe    f0120998 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0120960:	83 ec 0c             	sub    $0xc,%esp
f0120963:	ff 75 08             	pushl  0x8(%ebp)
f0120966:	e8 0c fa ff ff       	call   f0120377 <free_block>
f012096b:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f012096e:	83 ec 0c             	sub    $0xc,%esp
f0120971:	ff 75 0c             	pushl  0xc(%ebp)
f0120974:	e8 55 ec ff ff       	call   f011f5ce <alloc_block_FF>
f0120979:	83 c4 10             	add    $0x10,%esp
f012097c:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f012097f:	83 ec 08             	sub    $0x8,%esp
f0120982:	ff 75 c0             	pushl  -0x40(%ebp)
f0120985:	ff 75 08             	pushl  0x8(%ebp)
f0120988:	e8 ab fa ff ff       	call   f0120438 <copy_data>
f012098d:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0120990:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120993:	e9 f8 01 00 00       	jmp    f0120b90 <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0120998:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012099b:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f012099e:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f01209a1:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f01209a5:	0f 87 a0 00 00 00    	ja     f0120a4b <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f01209ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01209af:	75 17                	jne    f01209c8 <realloc_block_FF+0x551>
f01209b1:	83 ec 04             	sub    $0x4,%esp
f01209b4:	68 b7 00 13 f0       	push   $0xf01300b7
f01209b9:	68 25 02 00 00       	push   $0x225
f01209be:	68 d5 00 13 f0       	push   $0xf01300d5
f01209c3:	e8 71 f9 fd ff       	call   f0100339 <_panic>
f01209c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01209cb:	8b 00                	mov    (%eax),%eax
f01209cd:	85 c0                	test   %eax,%eax
f01209cf:	74 10                	je     f01209e1 <realloc_block_FF+0x56a>
f01209d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01209d4:	8b 00                	mov    (%eax),%eax
f01209d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01209d9:	8b 52 04             	mov    0x4(%edx),%edx
f01209dc:	89 50 04             	mov    %edx,0x4(%eax)
f01209df:	eb 0b                	jmp    f01209ec <realloc_block_FF+0x575>
f01209e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01209e4:	8b 40 04             	mov    0x4(%eax),%eax
f01209e7:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f01209ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01209ef:	8b 40 04             	mov    0x4(%eax),%eax
f01209f2:	85 c0                	test   %eax,%eax
f01209f4:	74 0f                	je     f0120a05 <realloc_block_FF+0x58e>
f01209f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01209f9:	8b 40 04             	mov    0x4(%eax),%eax
f01209fc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01209ff:	8b 12                	mov    (%edx),%edx
f0120a01:	89 10                	mov    %edx,(%eax)
f0120a03:	eb 0a                	jmp    f0120a0f <realloc_block_FF+0x598>
f0120a05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120a08:	8b 00                	mov    (%eax),%eax
f0120a0a:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f0120a0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120a12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120a18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120a1b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a22:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120a27:	48                   	dec    %eax
f0120a28:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0120a2d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a30:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120a33:	01 d0                	add    %edx,%eax
f0120a35:	83 ec 04             	sub    $0x4,%esp
f0120a38:	6a 01                	push   $0x1
f0120a3a:	50                   	push   %eax
f0120a3b:	ff 75 08             	pushl  0x8(%ebp)
f0120a3e:	e8 5c eb ff ff       	call   f011f59f <set_block_data>
f0120a43:	83 c4 10             	add    $0x10,%esp
f0120a46:	e9 36 01 00 00       	jmp    f0120b81 <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0120a4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a4e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120a51:	01 d0                	add    %edx,%eax
f0120a53:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0120a56:	83 ec 04             	sub    $0x4,%esp
f0120a59:	6a 01                	push   $0x1
f0120a5b:	ff 75 f0             	pushl  -0x10(%ebp)
f0120a5e:	ff 75 08             	pushl  0x8(%ebp)
f0120a61:	e8 39 eb ff ff       	call   f011f59f <set_block_data>
f0120a66:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0120a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a6c:	83 e8 04             	sub    $0x4,%eax
f0120a6f:	8b 00                	mov    (%eax),%eax
f0120a71:	83 e0 fe             	and    $0xfffffffe,%eax
f0120a74:	89 c2                	mov    %eax,%edx
f0120a76:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a79:	01 d0                	add    %edx,%eax
f0120a7b:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0120a7e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120a82:	74 06                	je     f0120a8a <realloc_block_FF+0x613>
f0120a84:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0120a88:	75 17                	jne    f0120aa1 <realloc_block_FF+0x62a>
f0120a8a:	83 ec 04             	sub    $0x4,%esp
f0120a8d:	68 48 01 13 f0       	push   $0xf0130148
f0120a92:	68 31 02 00 00       	push   $0x231
f0120a97:	68 d5 00 13 f0       	push   $0xf01300d5
f0120a9c:	e8 98 f8 fd ff       	call   f0100339 <_panic>
f0120aa1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120aa4:	8b 10                	mov    (%eax),%edx
f0120aa6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120aa9:	89 10                	mov    %edx,(%eax)
f0120aab:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120aae:	8b 00                	mov    (%eax),%eax
f0120ab0:	85 c0                	test   %eax,%eax
f0120ab2:	74 0b                	je     f0120abf <realloc_block_FF+0x648>
f0120ab4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120ab7:	8b 00                	mov    (%eax),%eax
f0120ab9:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0120abc:	89 50 04             	mov    %edx,0x4(%eax)
f0120abf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120ac2:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0120ac5:	89 10                	mov    %edx,(%eax)
f0120ac7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120aca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120acd:	89 50 04             	mov    %edx,0x4(%eax)
f0120ad0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120ad3:	8b 00                	mov    (%eax),%eax
f0120ad5:	85 c0                	test   %eax,%eax
f0120ad7:	75 08                	jne    f0120ae1 <realloc_block_FF+0x66a>
f0120ad9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120adc:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120ae1:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120ae6:	40                   	inc    %eax
f0120ae7:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0120aec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120af0:	75 17                	jne    f0120b09 <realloc_block_FF+0x692>
f0120af2:	83 ec 04             	sub    $0x4,%esp
f0120af5:	68 b7 00 13 f0       	push   $0xf01300b7
f0120afa:	68 32 02 00 00       	push   $0x232
f0120aff:	68 d5 00 13 f0       	push   $0xf01300d5
f0120b04:	e8 30 f8 fd ff       	call   f0100339 <_panic>
f0120b09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b0c:	8b 00                	mov    (%eax),%eax
f0120b0e:	85 c0                	test   %eax,%eax
f0120b10:	74 10                	je     f0120b22 <realloc_block_FF+0x6ab>
f0120b12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b15:	8b 00                	mov    (%eax),%eax
f0120b17:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120b1a:	8b 52 04             	mov    0x4(%edx),%edx
f0120b1d:	89 50 04             	mov    %edx,0x4(%eax)
f0120b20:	eb 0b                	jmp    f0120b2d <realloc_block_FF+0x6b6>
f0120b22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b25:	8b 40 04             	mov    0x4(%eax),%eax
f0120b28:	a3 d4 c5 5e f0       	mov    %eax,0xf05ec5d4
f0120b2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b30:	8b 40 04             	mov    0x4(%eax),%eax
f0120b33:	85 c0                	test   %eax,%eax
f0120b35:	74 0f                	je     f0120b46 <realloc_block_FF+0x6cf>
f0120b37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b3a:	8b 40 04             	mov    0x4(%eax),%eax
f0120b3d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120b40:	8b 12                	mov    (%edx),%edx
f0120b42:	89 10                	mov    %edx,(%eax)
f0120b44:	eb 0a                	jmp    f0120b50 <realloc_block_FF+0x6d9>
f0120b46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b49:	8b 00                	mov    (%eax),%eax
f0120b4b:	a3 d0 c5 5e f0       	mov    %eax,0xf05ec5d0
f0120b50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120b59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b5c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b63:	a1 dc c5 5e f0       	mov    0xf05ec5dc,%eax
f0120b68:	48                   	dec    %eax
f0120b69:	a3 dc c5 5e f0       	mov    %eax,0xf05ec5dc
				set_block_data(next_new_va, remaining_size, 0);
f0120b6e:	83 ec 04             	sub    $0x4,%esp
f0120b71:	6a 00                	push   $0x0
f0120b73:	ff 75 bc             	pushl  -0x44(%ebp)
f0120b76:	ff 75 b8             	pushl  -0x48(%ebp)
f0120b79:	e8 21 ea ff ff       	call   f011f59f <set_block_data>
f0120b7e:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0120b81:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b84:	eb 0a                	jmp    f0120b90 <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0120b86:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f0120b8d:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120b90:	c9                   	leave  
f0120b91:	c3                   	ret    

f0120b92 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0120b92:	55                   	push   %ebp
f0120b93:	89 e5                	mov    %esp,%ebp
f0120b95:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0120b98:	83 ec 04             	sub    $0x4,%esp
f0120b9b:	68 b8 01 13 f0       	push   $0xf01301b8
f0120ba0:	68 45 02 00 00       	push   $0x245
f0120ba5:	68 d5 00 13 f0       	push   $0xf01300d5
f0120baa:	e8 8a f7 fd ff       	call   f0100339 <_panic>

f0120baf <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0120baf:	55                   	push   %ebp
f0120bb0:	89 e5                	mov    %esp,%ebp
f0120bb2:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0120bb5:	83 ec 04             	sub    $0x4,%esp
f0120bb8:	68 e0 01 13 f0       	push   $0xf01301e0
f0120bbd:	68 4e 02 00 00       	push   $0x24e
f0120bc2:	68 d5 00 13 f0       	push   $0xf01300d5
f0120bc7:	e8 6d f7 fd ff       	call   f0100339 <_panic>

f0120bcc <__moddi3>:
f0120bcc:	55                   	push   %ebp
f0120bcd:	57                   	push   %edi
f0120bce:	56                   	push   %esi
f0120bcf:	53                   	push   %ebx
f0120bd0:	83 ec 2c             	sub    $0x2c,%esp
f0120bd3:	8b 74 24 40          	mov    0x40(%esp),%esi
f0120bd7:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0120bdb:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0120bdf:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0120be3:	89 d8                	mov    %ebx,%eax
f0120be5:	85 ff                	test   %edi,%edi
f0120be7:	0f 88 d3 00 00 00    	js     f0120cc0 <__moddi3+0xf4>
f0120bed:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0120bf4:	00 
f0120bf5:	85 c0                	test   %eax,%eax
f0120bf7:	0f 88 ab 00 00 00    	js     f0120ca8 <__moddi3+0xdc>
f0120bfd:	89 0c 24             	mov    %ecx,(%esp)
f0120c00:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0120c04:	89 74 24 10          	mov    %esi,0x10(%esp)
f0120c08:	89 fb                	mov    %edi,%ebx
f0120c0a:	8b 14 24             	mov    (%esp),%edx
f0120c0d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0120c11:	89 d0                	mov    %edx,%eax
f0120c13:	89 54 24 18          	mov    %edx,0x18(%esp)
f0120c17:	89 ca                	mov    %ecx,%edx
f0120c19:	8b 0c 24             	mov    (%esp),%ecx
f0120c1c:	89 34 24             	mov    %esi,(%esp)
f0120c1f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0120c23:	85 d2                	test   %edx,%edx
f0120c25:	75 15                	jne    f0120c3c <__moddi3+0x70>
f0120c27:	89 c7                	mov    %eax,%edi
f0120c29:	39 d8                	cmp    %ebx,%eax
f0120c2b:	76 5b                	jbe    f0120c88 <__moddi3+0xbc>
f0120c2d:	89 f0                	mov    %esi,%eax
f0120c2f:	89 da                	mov    %ebx,%edx
f0120c31:	f7 f7                	div    %edi
f0120c33:	89 d3                	mov    %edx,%ebx
f0120c35:	89 d8                	mov    %ebx,%eax
f0120c37:	31 d2                	xor    %edx,%edx
f0120c39:	eb 09                	jmp    f0120c44 <__moddi3+0x78>
f0120c3b:	90                   	nop
f0120c3c:	39 fa                	cmp    %edi,%edx
f0120c3e:	76 1c                	jbe    f0120c5c <__moddi3+0x90>
f0120c40:	89 f0                	mov    %esi,%eax
f0120c42:	89 fa                	mov    %edi,%edx
f0120c44:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0120c48:	85 c9                	test   %ecx,%ecx
f0120c4a:	74 07                	je     f0120c53 <__moddi3+0x87>
f0120c4c:	f7 d8                	neg    %eax
f0120c4e:	83 d2 00             	adc    $0x0,%edx
f0120c51:	f7 da                	neg    %edx
f0120c53:	83 c4 2c             	add    $0x2c,%esp
f0120c56:	5b                   	pop    %ebx
f0120c57:	5e                   	pop    %esi
f0120c58:	5f                   	pop    %edi
f0120c59:	5d                   	pop    %ebp
f0120c5a:	c3                   	ret    
f0120c5b:	90                   	nop
f0120c5c:	0f bd c2             	bsr    %edx,%eax
f0120c5f:	83 f0 1f             	xor    $0x1f,%eax
f0120c62:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0120c66:	75 6c                	jne    f0120cd4 <__moddi3+0x108>
f0120c68:	39 fa                	cmp    %edi,%edx
f0120c6a:	72 05                	jb     f0120c71 <__moddi3+0xa5>
f0120c6c:	3b 0c 24             	cmp    (%esp),%ecx
f0120c6f:	77 0e                	ja     f0120c7f <__moddi3+0xb3>
f0120c71:	8b 34 24             	mov    (%esp),%esi
f0120c74:	29 ce                	sub    %ecx,%esi
f0120c76:	19 d3                	sbb    %edx,%ebx
f0120c78:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0120c7c:	89 34 24             	mov    %esi,(%esp)
f0120c7f:	8b 04 24             	mov    (%esp),%eax
f0120c82:	8b 54 24 14          	mov    0x14(%esp),%edx
f0120c86:	eb bc                	jmp    f0120c44 <__moddi3+0x78>
f0120c88:	85 c9                	test   %ecx,%ecx
f0120c8a:	75 0b                	jne    f0120c97 <__moddi3+0xcb>
f0120c8c:	b8 01 00 00 00       	mov    $0x1,%eax
f0120c91:	31 d2                	xor    %edx,%edx
f0120c93:	f7 f1                	div    %ecx
f0120c95:	89 c1                	mov    %eax,%ecx
f0120c97:	89 d8                	mov    %ebx,%eax
f0120c99:	31 d2                	xor    %edx,%edx
f0120c9b:	f7 f1                	div    %ecx
f0120c9d:	8b 04 24             	mov    (%esp),%eax
f0120ca0:	f7 f1                	div    %ecx
f0120ca2:	89 d3                	mov    %edx,%ebx
f0120ca4:	eb 8f                	jmp    f0120c35 <__moddi3+0x69>
f0120ca6:	66 90                	xchg   %ax,%ax
f0120ca8:	89 c8                	mov    %ecx,%eax
f0120caa:	89 da                	mov    %ebx,%edx
f0120cac:	f7 d8                	neg    %eax
f0120cae:	83 d2 00             	adc    $0x0,%edx
f0120cb1:	f7 da                	neg    %edx
f0120cb3:	89 04 24             	mov    %eax,(%esp)
f0120cb6:	89 54 24 04          	mov    %edx,0x4(%esp)
f0120cba:	e9 45 ff ff ff       	jmp    f0120c04 <__moddi3+0x38>
f0120cbf:	90                   	nop
f0120cc0:	f7 de                	neg    %esi
f0120cc2:	83 d7 00             	adc    $0x0,%edi
f0120cc5:	f7 df                	neg    %edi
f0120cc7:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0120cce:	ff 
f0120ccf:	e9 21 ff ff ff       	jmp    f0120bf5 <__moddi3+0x29>
f0120cd4:	b8 20 00 00 00       	mov    $0x20,%eax
f0120cd9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0120cdd:	29 f8                	sub    %edi,%eax
f0120cdf:	89 c6                	mov    %eax,%esi
f0120ce1:	89 44 24 14          	mov    %eax,0x14(%esp)
f0120ce5:	89 f9                	mov    %edi,%ecx
f0120ce7:	d3 e2                	shl    %cl,%edx
f0120ce9:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0120ced:	89 e8                	mov    %ebp,%eax
f0120cef:	89 f1                	mov    %esi,%ecx
f0120cf1:	d3 e8                	shr    %cl,%eax
f0120cf3:	09 d0                	or     %edx,%eax
f0120cf5:	89 04 24             	mov    %eax,(%esp)
f0120cf8:	89 ea                	mov    %ebp,%edx
f0120cfa:	89 f9                	mov    %edi,%ecx
f0120cfc:	d3 e2                	shl    %cl,%edx
f0120cfe:	89 d7                	mov    %edx,%edi
f0120d00:	89 da                	mov    %ebx,%edx
f0120d02:	d3 e2                	shl    %cl,%edx
f0120d04:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0120d08:	d3 e5                	shl    %cl,%ebp
f0120d0a:	8b 44 24 10          	mov    0x10(%esp),%eax
f0120d0e:	89 f1                	mov    %esi,%ecx
f0120d10:	d3 e8                	shr    %cl,%eax
f0120d12:	09 d0                	or     %edx,%eax
f0120d14:	d3 eb                	shr    %cl,%ebx
f0120d16:	89 da                	mov    %ebx,%edx
f0120d18:	f7 34 24             	divl   (%esp)
f0120d1b:	89 d3                	mov    %edx,%ebx
f0120d1d:	f7 e7                	mul    %edi
f0120d1f:	89 c6                	mov    %eax,%esi
f0120d21:	89 d1                	mov    %edx,%ecx
f0120d23:	39 d3                	cmp    %edx,%ebx
f0120d25:	72 29                	jb     f0120d50 <__moddi3+0x184>
f0120d27:	74 33                	je     f0120d5c <__moddi3+0x190>
f0120d29:	89 e8                	mov    %ebp,%eax
f0120d2b:	29 f0                	sub    %esi,%eax
f0120d2d:	19 cb                	sbb    %ecx,%ebx
f0120d2f:	89 de                	mov    %ebx,%esi
f0120d31:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0120d35:	d3 e6                	shl    %cl,%esi
f0120d37:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0120d3b:	89 f9                	mov    %edi,%ecx
f0120d3d:	d3 e8                	shr    %cl,%eax
f0120d3f:	09 c6                	or     %eax,%esi
f0120d41:	89 f0                	mov    %esi,%eax
f0120d43:	89 f9                	mov    %edi,%ecx
f0120d45:	d3 eb                	shr    %cl,%ebx
f0120d47:	89 da                	mov    %ebx,%edx
f0120d49:	e9 f6 fe ff ff       	jmp    f0120c44 <__moddi3+0x78>
f0120d4e:	66 90                	xchg   %ax,%ax
f0120d50:	29 f8                	sub    %edi,%eax
f0120d52:	1b 14 24             	sbb    (%esp),%edx
f0120d55:	89 d1                	mov    %edx,%ecx
f0120d57:	89 c6                	mov    %eax,%esi
f0120d59:	eb ce                	jmp    f0120d29 <__moddi3+0x15d>
f0120d5b:	90                   	nop
f0120d5c:	39 c5                	cmp    %eax,%ebp
f0120d5e:	72 f0                	jb     f0120d50 <__moddi3+0x184>
f0120d60:	89 d9                	mov    %ebx,%ecx
f0120d62:	eb c5                	jmp    f0120d29 <__moddi3+0x15d>

f0120d64 <__udivdi3>:
f0120d64:	55                   	push   %ebp
f0120d65:	57                   	push   %edi
f0120d66:	56                   	push   %esi
f0120d67:	53                   	push   %ebx
f0120d68:	83 ec 1c             	sub    $0x1c,%esp
f0120d6b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0120d6f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0120d73:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0120d77:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0120d7b:	89 ca                	mov    %ecx,%edx
f0120d7d:	89 f8                	mov    %edi,%eax
f0120d7f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0120d83:	85 f6                	test   %esi,%esi
f0120d85:	75 2d                	jne    f0120db4 <__udivdi3+0x50>
f0120d87:	39 cf                	cmp    %ecx,%edi
f0120d89:	77 65                	ja     f0120df0 <__udivdi3+0x8c>
f0120d8b:	89 fd                	mov    %edi,%ebp
f0120d8d:	85 ff                	test   %edi,%edi
f0120d8f:	75 0b                	jne    f0120d9c <__udivdi3+0x38>
f0120d91:	b8 01 00 00 00       	mov    $0x1,%eax
f0120d96:	31 d2                	xor    %edx,%edx
f0120d98:	f7 f7                	div    %edi
f0120d9a:	89 c5                	mov    %eax,%ebp
f0120d9c:	31 d2                	xor    %edx,%edx
f0120d9e:	89 c8                	mov    %ecx,%eax
f0120da0:	f7 f5                	div    %ebp
f0120da2:	89 c1                	mov    %eax,%ecx
f0120da4:	89 d8                	mov    %ebx,%eax
f0120da6:	f7 f5                	div    %ebp
f0120da8:	89 cf                	mov    %ecx,%edi
f0120daa:	89 fa                	mov    %edi,%edx
f0120dac:	83 c4 1c             	add    $0x1c,%esp
f0120daf:	5b                   	pop    %ebx
f0120db0:	5e                   	pop    %esi
f0120db1:	5f                   	pop    %edi
f0120db2:	5d                   	pop    %ebp
f0120db3:	c3                   	ret    
f0120db4:	39 ce                	cmp    %ecx,%esi
f0120db6:	77 28                	ja     f0120de0 <__udivdi3+0x7c>
f0120db8:	0f bd fe             	bsr    %esi,%edi
f0120dbb:	83 f7 1f             	xor    $0x1f,%edi
f0120dbe:	75 40                	jne    f0120e00 <__udivdi3+0x9c>
f0120dc0:	39 ce                	cmp    %ecx,%esi
f0120dc2:	72 0a                	jb     f0120dce <__udivdi3+0x6a>
f0120dc4:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0120dc8:	0f 87 9e 00 00 00    	ja     f0120e6c <__udivdi3+0x108>
f0120dce:	b8 01 00 00 00       	mov    $0x1,%eax
f0120dd3:	89 fa                	mov    %edi,%edx
f0120dd5:	83 c4 1c             	add    $0x1c,%esp
f0120dd8:	5b                   	pop    %ebx
f0120dd9:	5e                   	pop    %esi
f0120dda:	5f                   	pop    %edi
f0120ddb:	5d                   	pop    %ebp
f0120ddc:	c3                   	ret    
f0120ddd:	8d 76 00             	lea    0x0(%esi),%esi
f0120de0:	31 ff                	xor    %edi,%edi
f0120de2:	31 c0                	xor    %eax,%eax
f0120de4:	89 fa                	mov    %edi,%edx
f0120de6:	83 c4 1c             	add    $0x1c,%esp
f0120de9:	5b                   	pop    %ebx
f0120dea:	5e                   	pop    %esi
f0120deb:	5f                   	pop    %edi
f0120dec:	5d                   	pop    %ebp
f0120ded:	c3                   	ret    
f0120dee:	66 90                	xchg   %ax,%ax
f0120df0:	89 d8                	mov    %ebx,%eax
f0120df2:	f7 f7                	div    %edi
f0120df4:	31 ff                	xor    %edi,%edi
f0120df6:	89 fa                	mov    %edi,%edx
f0120df8:	83 c4 1c             	add    $0x1c,%esp
f0120dfb:	5b                   	pop    %ebx
f0120dfc:	5e                   	pop    %esi
f0120dfd:	5f                   	pop    %edi
f0120dfe:	5d                   	pop    %ebp
f0120dff:	c3                   	ret    
f0120e00:	bd 20 00 00 00       	mov    $0x20,%ebp
f0120e05:	89 eb                	mov    %ebp,%ebx
f0120e07:	29 fb                	sub    %edi,%ebx
f0120e09:	89 f9                	mov    %edi,%ecx
f0120e0b:	d3 e6                	shl    %cl,%esi
f0120e0d:	89 c5                	mov    %eax,%ebp
f0120e0f:	88 d9                	mov    %bl,%cl
f0120e11:	d3 ed                	shr    %cl,%ebp
f0120e13:	89 e9                	mov    %ebp,%ecx
f0120e15:	09 f1                	or     %esi,%ecx
f0120e17:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0120e1b:	89 f9                	mov    %edi,%ecx
f0120e1d:	d3 e0                	shl    %cl,%eax
f0120e1f:	89 c5                	mov    %eax,%ebp
f0120e21:	89 d6                	mov    %edx,%esi
f0120e23:	88 d9                	mov    %bl,%cl
f0120e25:	d3 ee                	shr    %cl,%esi
f0120e27:	89 f9                	mov    %edi,%ecx
f0120e29:	d3 e2                	shl    %cl,%edx
f0120e2b:	8b 44 24 08          	mov    0x8(%esp),%eax
f0120e2f:	88 d9                	mov    %bl,%cl
f0120e31:	d3 e8                	shr    %cl,%eax
f0120e33:	09 c2                	or     %eax,%edx
f0120e35:	89 d0                	mov    %edx,%eax
f0120e37:	89 f2                	mov    %esi,%edx
f0120e39:	f7 74 24 0c          	divl   0xc(%esp)
f0120e3d:	89 d6                	mov    %edx,%esi
f0120e3f:	89 c3                	mov    %eax,%ebx
f0120e41:	f7 e5                	mul    %ebp
f0120e43:	39 d6                	cmp    %edx,%esi
f0120e45:	72 19                	jb     f0120e60 <__udivdi3+0xfc>
f0120e47:	74 0b                	je     f0120e54 <__udivdi3+0xf0>
f0120e49:	89 d8                	mov    %ebx,%eax
f0120e4b:	31 ff                	xor    %edi,%edi
f0120e4d:	e9 58 ff ff ff       	jmp    f0120daa <__udivdi3+0x46>
f0120e52:	66 90                	xchg   %ax,%ax
f0120e54:	8b 54 24 08          	mov    0x8(%esp),%edx
f0120e58:	89 f9                	mov    %edi,%ecx
f0120e5a:	d3 e2                	shl    %cl,%edx
f0120e5c:	39 c2                	cmp    %eax,%edx
f0120e5e:	73 e9                	jae    f0120e49 <__udivdi3+0xe5>
f0120e60:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0120e63:	31 ff                	xor    %edi,%edi
f0120e65:	e9 40 ff ff ff       	jmp    f0120daa <__udivdi3+0x46>
f0120e6a:	66 90                	xchg   %ax,%ax
f0120e6c:	31 c0                	xor    %eax,%eax
f0120e6e:	e9 37 ff ff ff       	jmp    f0120daa <__udivdi3+0x46>
f0120e73:	90                   	nop

f0120e74 <__umoddi3>:
f0120e74:	55                   	push   %ebp
f0120e75:	57                   	push   %edi
f0120e76:	56                   	push   %esi
f0120e77:	53                   	push   %ebx
f0120e78:	83 ec 1c             	sub    $0x1c,%esp
f0120e7b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0120e7f:	8b 74 24 34          	mov    0x34(%esp),%esi
f0120e83:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0120e87:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0120e8b:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0120e8f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0120e93:	89 f3                	mov    %esi,%ebx
f0120e95:	89 fa                	mov    %edi,%edx
f0120e97:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0120e9b:	89 34 24             	mov    %esi,(%esp)
f0120e9e:	85 c0                	test   %eax,%eax
f0120ea0:	75 1a                	jne    f0120ebc <__umoddi3+0x48>
f0120ea2:	39 f7                	cmp    %esi,%edi
f0120ea4:	0f 86 a2 00 00 00    	jbe    f0120f4c <__umoddi3+0xd8>
f0120eaa:	89 c8                	mov    %ecx,%eax
f0120eac:	89 f2                	mov    %esi,%edx
f0120eae:	f7 f7                	div    %edi
f0120eb0:	89 d0                	mov    %edx,%eax
f0120eb2:	31 d2                	xor    %edx,%edx
f0120eb4:	83 c4 1c             	add    $0x1c,%esp
f0120eb7:	5b                   	pop    %ebx
f0120eb8:	5e                   	pop    %esi
f0120eb9:	5f                   	pop    %edi
f0120eba:	5d                   	pop    %ebp
f0120ebb:	c3                   	ret    
f0120ebc:	39 f0                	cmp    %esi,%eax
f0120ebe:	0f 87 ac 00 00 00    	ja     f0120f70 <__umoddi3+0xfc>
f0120ec4:	0f bd e8             	bsr    %eax,%ebp
f0120ec7:	83 f5 1f             	xor    $0x1f,%ebp
f0120eca:	0f 84 ac 00 00 00    	je     f0120f7c <__umoddi3+0x108>
f0120ed0:	bf 20 00 00 00       	mov    $0x20,%edi
f0120ed5:	29 ef                	sub    %ebp,%edi
f0120ed7:	89 fe                	mov    %edi,%esi
f0120ed9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0120edd:	89 e9                	mov    %ebp,%ecx
f0120edf:	d3 e0                	shl    %cl,%eax
f0120ee1:	89 d7                	mov    %edx,%edi
f0120ee3:	89 f1                	mov    %esi,%ecx
f0120ee5:	d3 ef                	shr    %cl,%edi
f0120ee7:	09 c7                	or     %eax,%edi
f0120ee9:	89 e9                	mov    %ebp,%ecx
f0120eeb:	d3 e2                	shl    %cl,%edx
f0120eed:	89 14 24             	mov    %edx,(%esp)
f0120ef0:	89 d8                	mov    %ebx,%eax
f0120ef2:	d3 e0                	shl    %cl,%eax
f0120ef4:	89 c2                	mov    %eax,%edx
f0120ef6:	8b 44 24 08          	mov    0x8(%esp),%eax
f0120efa:	d3 e0                	shl    %cl,%eax
f0120efc:	89 44 24 04          	mov    %eax,0x4(%esp)
f0120f00:	8b 44 24 08          	mov    0x8(%esp),%eax
f0120f04:	89 f1                	mov    %esi,%ecx
f0120f06:	d3 e8                	shr    %cl,%eax
f0120f08:	09 d0                	or     %edx,%eax
f0120f0a:	d3 eb                	shr    %cl,%ebx
f0120f0c:	89 da                	mov    %ebx,%edx
f0120f0e:	f7 f7                	div    %edi
f0120f10:	89 d3                	mov    %edx,%ebx
f0120f12:	f7 24 24             	mull   (%esp)
f0120f15:	89 c6                	mov    %eax,%esi
f0120f17:	89 d1                	mov    %edx,%ecx
f0120f19:	39 d3                	cmp    %edx,%ebx
f0120f1b:	0f 82 87 00 00 00    	jb     f0120fa8 <__umoddi3+0x134>
f0120f21:	0f 84 91 00 00 00    	je     f0120fb8 <__umoddi3+0x144>
f0120f27:	8b 54 24 04          	mov    0x4(%esp),%edx
f0120f2b:	29 f2                	sub    %esi,%edx
f0120f2d:	19 cb                	sbb    %ecx,%ebx
f0120f2f:	89 d8                	mov    %ebx,%eax
f0120f31:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0120f35:	d3 e0                	shl    %cl,%eax
f0120f37:	89 e9                	mov    %ebp,%ecx
f0120f39:	d3 ea                	shr    %cl,%edx
f0120f3b:	09 d0                	or     %edx,%eax
f0120f3d:	89 e9                	mov    %ebp,%ecx
f0120f3f:	d3 eb                	shr    %cl,%ebx
f0120f41:	89 da                	mov    %ebx,%edx
f0120f43:	83 c4 1c             	add    $0x1c,%esp
f0120f46:	5b                   	pop    %ebx
f0120f47:	5e                   	pop    %esi
f0120f48:	5f                   	pop    %edi
f0120f49:	5d                   	pop    %ebp
f0120f4a:	c3                   	ret    
f0120f4b:	90                   	nop
f0120f4c:	89 fd                	mov    %edi,%ebp
f0120f4e:	85 ff                	test   %edi,%edi
f0120f50:	75 0b                	jne    f0120f5d <__umoddi3+0xe9>
f0120f52:	b8 01 00 00 00       	mov    $0x1,%eax
f0120f57:	31 d2                	xor    %edx,%edx
f0120f59:	f7 f7                	div    %edi
f0120f5b:	89 c5                	mov    %eax,%ebp
f0120f5d:	89 f0                	mov    %esi,%eax
f0120f5f:	31 d2                	xor    %edx,%edx
f0120f61:	f7 f5                	div    %ebp
f0120f63:	89 c8                	mov    %ecx,%eax
f0120f65:	f7 f5                	div    %ebp
f0120f67:	89 d0                	mov    %edx,%eax
f0120f69:	e9 44 ff ff ff       	jmp    f0120eb2 <__umoddi3+0x3e>
f0120f6e:	66 90                	xchg   %ax,%ax
f0120f70:	89 c8                	mov    %ecx,%eax
f0120f72:	89 f2                	mov    %esi,%edx
f0120f74:	83 c4 1c             	add    $0x1c,%esp
f0120f77:	5b                   	pop    %ebx
f0120f78:	5e                   	pop    %esi
f0120f79:	5f                   	pop    %edi
f0120f7a:	5d                   	pop    %ebp
f0120f7b:	c3                   	ret    
f0120f7c:	3b 04 24             	cmp    (%esp),%eax
f0120f7f:	72 06                	jb     f0120f87 <__umoddi3+0x113>
f0120f81:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0120f85:	77 0f                	ja     f0120f96 <__umoddi3+0x122>
f0120f87:	89 f2                	mov    %esi,%edx
f0120f89:	29 f9                	sub    %edi,%ecx
f0120f8b:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0120f8f:	89 14 24             	mov    %edx,(%esp)
f0120f92:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0120f96:	8b 44 24 04          	mov    0x4(%esp),%eax
f0120f9a:	8b 14 24             	mov    (%esp),%edx
f0120f9d:	83 c4 1c             	add    $0x1c,%esp
f0120fa0:	5b                   	pop    %ebx
f0120fa1:	5e                   	pop    %esi
f0120fa2:	5f                   	pop    %edi
f0120fa3:	5d                   	pop    %ebp
f0120fa4:	c3                   	ret    
f0120fa5:	8d 76 00             	lea    0x0(%esi),%esi
f0120fa8:	2b 04 24             	sub    (%esp),%eax
f0120fab:	19 fa                	sbb    %edi,%edx
f0120fad:	89 d1                	mov    %edx,%ecx
f0120faf:	89 c6                	mov    %eax,%esi
f0120fb1:	e9 71 ff ff ff       	jmp    f0120f27 <__umoddi3+0xb3>
f0120fb6:	66 90                	xchg   %ax,%ax
f0120fb8:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0120fbc:	72 ea                	jb     f0120fa8 <__umoddi3+0x134>
f0120fbe:	89 d9                	mov    %ebx,%ecx
f0120fc0:	e9 62 ff ff ff       	jmp    f0120f27 <__umoddi3+0xb3>
