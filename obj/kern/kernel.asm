
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 f8 33 ac f0 01 	movl   $0x1,0xf0ac33f8
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 44 33 ac f0 01 	movl   $0x1,0xf0ac3344
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 50 60 65 f2       	mov    $0xf2656050,%edx
f010006a:	b8 04 a1 69 f0       	mov    $0xf069a104,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 04 a1 69 f0       	push   $0xf069a104
f010007e:	e8 87 fd 01 00       	call   f011fe0a <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 20 25 12 f0       	push   $0xf0122520
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 67 25 12 f0       	push   $0xf0122567
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 7b 25 12 f0       	push   $0xf012257b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 8f 25 12 f0       	push   $0xf012258f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 9b 25 12 f0       	push   $0xf012259b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 a3 25 12 f0       	push   $0xf01225a3
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 b8 91 00 00       	call   f01092e0 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 a3 f4 00 00       	call   f010f5d3 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 8c f5 00 00       	call   f010f6d0 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 67 f5 00 00       	call   f010f6b8 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 87 f5 00 00       	call   f010f6e8 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 f8 01 02 00       	call   f0120361 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 b1 25 12 f0       	push   $0xf01225b1
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 0e ac 00 00       	call   f010ad8c <env_init>
		ts_init();
f010017e:	e8 f2 cd 00 00       	call   f010cf75 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 9b 25 12 f0       	push   $0xf012259b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 c4 25 12 f0       	push   $0xf01225c4
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ed 25 12 f0       	push   $0xf01225ed
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 03 26 12 f0       	push   $0xf0122603
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 20 26 12 f0       	push   $0xf0122620
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 3f 26 12 f0       	push   $0xf012263f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 5c 26 12 f0       	push   $0xf012265c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 80 26 12 f0       	push   $0xf0122680
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 a0 26 12 f0       	push   $0xf01226a0
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 c4 26 12 f0       	push   $0xf01226c4
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 5c 36 ec f0 00 	movl   $0x0,0xf0ec365c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 0c 27 12 f0       	push   $0xf012270c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 38 27 12 f0       	push   $0xf0122738
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 5d 27 12 f0       	push   $0xf012275d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 64 27 12 f0       	push   $0xf0122764
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 ac 27 12 f0       	push   $0xf01227ac
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 f4 27 12 f0       	push   $0xf01227f4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 ac 27 12 f0       	push   $0xf01227ac
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 64 27 12 f0       	push   $0xf0122764
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 39 28 12 f0       	push   $0xf0122839
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 9c b6 00 00       	call   f010b9e0 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 20 a1 69 f0       	mov    %eax,0xf069a120

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 40 28 12 f0       	push   $0xf0122840
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 65 28 12 f0       	push   $0xf0122865
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 f8 b5 00 00       	call   f010b99e <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 67 28 12 f0       	push   $0xf0122867
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 20 a1 69 f0       	mov    %eax,0xf069a120

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 71 28 12 f0       	push   $0xf0122871
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 65 28 12 f0       	push   $0xf0122865
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 9a b5 00 00       	call   f010b9e0 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 3f b5 00 00       	call   f010b99e <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 20 a1 69 f0       	mov    %eax,0xf069a120

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 71 28 12 f0       	push   $0xf0122871
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 65 28 12 f0       	push   $0xf0122865
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 28 b5 00 00       	call   f010b9e0 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 cd b4 00 00       	call   f010b99e <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 8a 28 12 f0       	push   $0xf012288a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 65 28 12 f0       	push   $0xf0122865
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 44 a1 69 f0       	mov    0xf069a144,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 a8 28 12 f0       	push   $0xf01228a8
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 44 a1 69 f0       	mov    %eax,0xf069a144
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 04 dc 00 00       	call   f010e279 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 48 a1 69 f0 b4 	movl   $0x3b4,0xf069a148
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 48 a1 69 f0 d4 	movl   $0x3d4,0xf069a148
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 48 a1 69 f0       	mov    0xf069a148,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 48 a1 69 f0       	mov    0xf069a148,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 48 a1 69 f0       	mov    0xf069a148,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 48 a1 69 f0       	mov    0xf069a148,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 4c a1 69 f0       	mov    %eax,0xf069a14c
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 4c a1 69 f0    	mov    0xf069a14c,%edx
f010087a:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
		text_length = 0;
f01008a6:	c7 05 40 a1 69 f0 00 	movl   $0x0,0xf069a140
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d 50 a1 69 f0 	mov    0xf069a150,%cx
f01008b7:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d 4c a1 69 f0    	mov    0xf069a14c,%ecx
f0100972:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 50 a1 69 f0 	mov    %dx,0xf069a150
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 40 a1 69 f0    	mov    0xf069a140,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 40 a1 69 f0       	mov    0xf069a140,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 40 a1 69 f0       	mov    %eax,0xf069a140
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 4c a1 69 f0       	mov    0xf069a14c,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 4c a1 69 f0       	mov    0xf069a14c,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 4f f4 01 00       	call   f011fe3a <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 4c a1 69 f0    	mov    0xf069a14c,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 50 a1 69 f0    	mov    %ax,0xf069a150
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 48 a1 69 f0       	mov    0xf069a148,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 48 a1 69 f0    	mov    0xf069a148,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 48 a1 69 f0       	mov    0xf069a148,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 48 a1 69 f0    	mov    0xf069a148,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 68 a3 69 f0       	mov    %eax,0xf069a368
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 68 a3 69 f0       	mov    %eax,0xf069a368
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 68 a3 69 f0       	mov    %eax,0xf069a368
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 68 a3 69 f0       	mov    %eax,0xf069a368
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 f1 17 f0    	mov    -0xfe80ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 68 a3 69 f0       	mov    %eax,0xf069a368

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 f5 17 f0 	mov    -0xfe80ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 40 a1 69 f0       	mov    0xf069a140,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 40 a1 69 f0    	mov    0xf069a140,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 40 a1 69 f0       	mov    0xf069a140,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 40 a1 69 f0       	mov    %eax,0xf069a140
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 50 a1 69 f0    	mov    0xf069a150,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 4c a1 69 f0    	mov    0xf069a14c,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 4c a1 69 f0       	mov    0xf069a14c,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 40 a1 69 f0       	mov    0xf069a140,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 68 a3 69 f0       	mov    0xf069a368,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 bb 28 12 f0       	push   $0xf01228bb
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 64 d5 00 00       	call   f010e279 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 64 a3 69 f0       	mov    0xf069a364,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 64 a3 69 f0    	mov    %edx,0xf069a364
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 60 a1 69 f0    	mov    %dl,-0xf965ea0(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 64 a3 69 f0       	mov    0xf069a364,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 64 a3 69 f0 00 	movl   $0x0,0xf069a364
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 60 a3 69 f0    	mov    0xf069a360,%edx
f0100d7f:	a1 64 a3 69 f0       	mov    0xf069a364,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 60 a3 69 f0       	mov    0xf069a360,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 60 a3 69 f0    	mov    %edx,0xf069a360
f0100d96:	8a 80 60 a1 69 f0    	mov    -0xf965ea0(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 60 a3 69 f0       	mov    0xf069a360,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 60 a3 69 f0 00 	movl   $0x0,0xf069a360
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 60 a3 69 f0    	mov    0xf069a360,%edx
f0100dd0:	a1 64 a3 69 f0       	mov    0xf069a364,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 60 a3 69 f0       	mov    0xf069a360,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 60 a3 69 f0    	mov    %edx,0xf069a360
f0100de7:	8a 80 60 a1 69 f0    	mov    -0xf965ea0(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 60 a3 69 f0       	mov    0xf069a360,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 60 a3 69 f0 00 	movl   $0x0,0xf069a360
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 44 a1 69 f0       	mov    0xf069a144,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 c7 28 12 f0       	push   $0xf01228c7
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 1f ab 00 00       	call   f010b9e0 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 e4 28 12 f0       	push   $0xf01228e4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 0b 29 12 f0       	push   $0xf012290b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 d8 aa 00 00       	call   f010b9e0 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 20 29 12 f0       	push   $0xf0122920
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 0b 29 12 f0       	push   $0xf012290b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 d7 e5 01 00       	call   f011f55a <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 20 c7 ed f0       	add    $0xf0edc720,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 24 ec 01 00       	call   f011fc1c <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 40 17 ee f0       	push   $0xf0ee1740
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 27 ee 01 00       	call   f011fe3a <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 20 c7 ed f0       	add    $0xf0edc720,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 20 c7 ed f0       	add    $0xf0edc720,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 62 eb 01 00       	call   f011fc1c <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 40 17 ee f0       	push   $0xf0ee1740
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 65 ed 01 00       	call   f011fe3a <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 20 37 ec f0       	add    $0xf0ec3720,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 a2 ec 01 00       	call   f011fe0a <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 4c 29 12 f0       	push   $0xf012294c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 4f 29 12 f0       	push   $0xf012294f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 20 37 ec f0       	push   $0xf0ec3720
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 47 e9 01 00       	call   f011fc1c <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 5c e9 01 00       	call   f011fc6b <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 ff e8 01 00       	call   f011fc1c <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 5f 29 12 f0       	push   $0xf012295f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 da ee 01 00       	call   f0120231 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 64 29 12 f0       	push   $0xf0122964
f010137e:	50                   	push   %eax
f010137f:	e8 a4 e9 01 00       	call   f011fd28 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 68 29 12 f0       	push   $0xf0122968
f0101399:	50                   	push   %eax
f010139a:	e8 89 e9 01 00       	call   f011fd28 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 6d 29 12 f0       	push   $0xf012296d
f01013b4:	50                   	push   %eax
f01013b5:	e8 6e e9 01 00       	call   f011fd28 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 6d 29 12 f0       	push   $0xf012296d
f01013d5:	50                   	push   %eax
f01013d6:	e8 4d e9 01 00       	call   f011fd28 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 f5 e7 01 00       	call   f011fc1c <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 f7 e7 01 00       	call   f011fc6b <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 d6 e7 01 00       	call   f011fc6b <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 53 e7 01 00       	call   f011fc1c <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 6e e8 01 00       	call   f011fd60 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 a3 e6 01 00       	call   f011fc1c <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 20 37 ec f0       	add    $0xf0ec3720,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 6e e8 01 00       	call   f011fe0a <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 20 37 ec f0    	add    $0xf0ec3720,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 d9 e6 01 00       	call   f011fc99 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 19 e6 01 00       	call   f011fc1c <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 31 e7 01 00       	call   f011fd60 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 7c e5 01 00       	call   f011fc1c <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 1c e5 01 00       	call   f011fc1c <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 20 37 ec f0       	add    $0xf0ec3720,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 e7 e6 01 00       	call   f011fe0a <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 20 37 ec f0    	add    $0xf0ec3720,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 52 e5 01 00       	call   f011fc99 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 94 e4 01 00       	call   f011fc1c <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 af e5 01 00       	call   f011fd60 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 fa e3 01 00       	call   f011fc1c <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 a0 e3 01 00       	call   f011fc1c <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 20 37 ec f0       	add    $0xf0ec3720,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 6b e5 01 00       	call   f011fe0a <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 20 37 ec f0    	add    $0xf0ec3720,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 d6 e3 01 00       	call   f011fc99 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 20 37 ec f0       	add    $0xf0ec3720,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 20 37 ec f0       	push   $0xf0ec3720
f0101929:	e8 ee e2 01 00       	call   f011fc1c <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 95 e2 01 00       	call   f011fc1c <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 82 e2 01 00       	call   f011fc1c <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 20 37 ec f0    	lea    -0xf13c8e0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 20 37 ec f0       	add    $0xf0ec3720,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 27 e2 01 00       	call   f011fc1c <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 20 c7 ed f0    	lea    -0xf1238e0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 20 c7 ed f0       	add    $0xf0edc720,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 1c e2 01 00       	call   f011fe3a <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 20 13 ee f0       	push   $0xf0ee1320
f0101c3a:	e8 fb e1 01 00       	call   f011fe3a <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 20 c7 ed f0       	add    $0xf0edc720,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 cb e0 01 00       	call   f011fd28 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 f5 17 f0       	mov    %eax,0xf017f530
f0101c6f:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 20 c7 ed f0       	add    $0xf0edc720,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 ad e1 01 00       	call   f011fe3a <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 5c 36 ec f0       	mov    0xf0ec365c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 77 29 12 f0       	mov    $0xf0122977,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 77 2d 12 f0       	mov    $0xf0122d77,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 77 31 12 f0       	mov    $0xf0123177,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 5c 36 ec f0 00 	movl   $0x0,0xf0ec365c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 d8 35 ec f0 00 	movl   $0x0,0xf0ec35d8
f0101d59:	00 00 00 
f0101d5c:	c7 05 dc 35 ec f0 00 	movl   $0x0,0xf0ec35dc
f0101d63:	00 00 00 
f0101d66:	c7 05 e4 35 ec f0 00 	movl   $0x0,0xf0ec35e4
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 84 e0 01 00       	call   f011fe0a <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 71 29 12 f0       	push   $0xf0122971
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 8e 9e 00 00       	call   f010bc6d <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 00 37 ec f0       	mov    %eax,0xf0ec3700
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 20 17 ee f0       	mov    %eax,0xf0ee1720
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 00 37 ec f0       	mov    0xf0ec3700,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 00 37 ec f0    	mov    %edx,0xf0ec3700
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 20 17 ee f0       	mov    0xf0ee1720,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 20 17 ee f0       	mov    %eax,0xf0ee1720
f0101e98:	a1 20 17 ee f0       	mov    0xf0ee1720,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 00 37 ec f0       	mov    %eax,0xf0ec3700
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 20 17 ee f0       	mov    %eax,0xf0ee1720
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 00 37 ec f0       	mov    0xf0ec3700,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 00 37 ec f0    	mov    %edx,0xf0ec3700
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 20 17 ee f0       	mov    0xf0ee1720,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 20 17 ee f0       	mov    %eax,0xf0ee1720
f0101ed4:	a1 20 17 ee f0       	mov    0xf0ee1720,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 5f 29 12 f0       	push   $0xf012295f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 1b e3 01 00       	call   f0120231 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 77 35 12 f0       	push   $0xf0123577
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 e4 35 ec f0       	mov    0xf0ec35e4,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 90 35 12 f0       	push   $0xf0123590
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 e1 35 12 f0       	push   $0xf01235e1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 fc 35 12 f0       	push   $0xf01235fc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 e4 35 ec f0       	mov    0xf0ec35e4,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 2c 36 12 f0       	push   $0xf012362c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 e1 35 12 f0       	push   $0xf01235e1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 56 36 12 f0       	push   $0xf0123656
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 e0 35 ec f0       	mov    %eax,0xf0ec35e0
f010203b:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 60 36 12 f0       	push   $0xf0123660
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 c3 36 12 f0       	push   $0xf01236c3
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 cc 36 12 f0       	push   $0xf01236cc
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 e0 35 ec f0       	mov    %eax,0xf0ec35e0
f010218b:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 f5 17 f0       	add    $0xf017f548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 d4 36 12 f0       	push   $0xf01236d4
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 e1 35 12 f0       	push   $0xf01235e1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 dc 35 ec f0       	mov    %eax,0xf0ec35dc
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 d8 35 ec f0       	mov    %eax,0xf0ec35d8
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 e4 35 ec f0       	mov    0xf0ec35e4,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 e4 35 ec f0       	mov    %eax,0xf0ec35e4

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 e0 35 ec f0       	mov    %eax,0xf0ec35e0
f0102292:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 4a da 01 00       	call   f011fd28 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 d8 35 ec f0    	mov    0xf0ec35d8,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 d8 35 ec f0    	mov    0xf0ec35d8,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010238d:	a3 dc 35 ec f0       	mov    %eax,0xf0ec35dc
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023a3:	a3 d8 35 ec f0       	mov    %eax,0xf0ec35d8
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 e4 35 ec f0       	mov    0xf0ec35e4,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 e4 35 ec f0       	mov    %eax,0xf0ec35e4
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 d8 35 ec f0    	mov    0xf0ec35d8,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 d8 35 ec f0    	mov    0xf0ec35d8,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010248c:	a3 dc 35 ec f0       	mov    %eax,0xf0ec35dc
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01024a2:	a3 d8 35 ec f0       	mov    %eax,0xf0ec35d8
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 e4 35 ec f0       	mov    0xf0ec35e4,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 e4 35 ec f0       	mov    %eax,0xf0ec35e4
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 f8 33 ac f0 00 	movl   $0x0,0xf0ac33f8
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 f8 33 ac f0 01 	movl   $0x1,0xf0ac33f8
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 f8 33 ac f0 02 	movl   $0x2,0xf0ac33f8
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 f8 33 ac f0 03 	movl   $0x3,0xf0ac33f8
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 f8 33 ac f0 04 	movl   $0x4,0xf0ac33f8
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 44 33 ac f0 01 	movl   $0x1,0xf0ac3344
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 44 33 ac f0 02 	movl   $0x2,0xf0ac3344
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 44 33 ac f0 03 	movl   $0x3,0xf0ac3344
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 44 33 ac f0 04 	movl   $0x4,0xf0ac3344
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 44 33 ac f0       	mov    0xf0ac3344,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 44 33 ac f0       	mov    0xf0ac3344,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 44 33 ac f0       	mov    0xf0ac3344,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 44 33 ac f0       	mov    0xf0ac3344,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 f4 36 12 f0       	push   $0xf01236f4
f0102662:	6a 56                	push   $0x56
f0102664:	68 1c 37 12 f0       	push   $0xf012371c
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 60 33 ac f0    	mov    0xf0ac3360,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 f5 17 f0       	add    $0xf017f544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 9f 3f 12 f0       	push   $0xf0123f9f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 a8 3f 12 f0       	push   $0xf0123fa8
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 bd 3f 12 f0       	push   $0xf0123fbd
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 d9 3f 12 f0       	push   $0xf0123fd9
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 f4 3f 12 f0       	push   $0xf0123ff4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 19 25 12 00       	mov    $0x122519,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 19 25 12 f0       	push   $0xf0122519
f010278e:	68 30 40 12 f0       	push   $0xf0124030
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 04 a1 69 00       	mov    $0x69a104,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 04 a1 69 f0       	push   $0xf069a104
f01027a9:	68 6c 40 12 f0       	push   $0xf012406c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 50 60 65 02       	mov    $0x2656050,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 50 60 65 f2       	push   $0xf2656050
f01027c4:	68 b4 40 12 f0       	push   $0xf01240b4
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 50 60 65 f2       	mov    $0xf2656050,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 f0 40 12 f0       	push   $0xf01240f0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 52 d7 01 00       	call   f011ff7c <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 11 d7 01 00       	call   f011ff7c <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 a7 91 00 00       	call   f010ba30 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 db d6 01 00       	call   f011ff7c <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 1c 41 12 f0       	push   $0xf012411c
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 55 d6 01 00       	call   f011ff7c <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 d2 d2 01 00       	call   f011fc1c <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 d7 d5 01 00       	call   f011ff7c <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 46 41 12 f0       	push   $0xf0124146
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 8b d5 01 00       	call   f011ff7c <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 21 90 00 00       	call   f010ba30 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 55 d5 01 00       	call   f011ff7c <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 46 41 12 f0       	push   $0xf0124146
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 60 41 12 f0       	push   $0xf0124160
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 c4 d4 01 00       	call   f011ff7c <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 8a 41 12 f0       	push   $0xf012418a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 8d 41 12 f0       	push   $0xf012418d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 67 d4 01 00       	call   f011ff7c <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 fd 8e 00 00       	call   f010ba30 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 31 d4 01 00       	call   f011ff7c <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 16 d4 01 00       	call   f011ff7c <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 8f 41 12 f0       	push   $0xf012418f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 7a d3 01 00       	call   f011ff7c <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 10 8e 00 00       	call   f010ba30 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 33 d3 01 00       	call   f011ff7c <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 48 6c 00 00       	call   f01098cd <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 f9 6a 00 00       	call   f010978a <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 a0 41 12 f0       	push   $0xf01241a0
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 3e d2 01 00       	call   f011ff7c <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 d4 8c 00 00       	call   f010ba30 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 f7 d1 01 00       	call   f011ff7c <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 ca 41 12 f0       	push   $0xf01241ca
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 e4 41 12 f0       	push   $0xf01241e4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 28 42 12 f0       	push   $0xf0124228
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 10 35 ac f0       	mov    0xf0ac3510,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 80 42 12 f0       	push   $0xf0124280
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 fc c6 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 bc 42 12 f0       	push   $0xf01242bc
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 27 d0 01 00       	call   f011ff7c <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 0c d0 01 00       	call   f011ff7c <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 f1 cf 01 00       	call   f011ff7c <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 7b c6 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 c0 cf 01 00       	call   f011ff7c <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 a3 cf 01 00       	call   f011ff7c <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 88 cf 01 00       	call   f011ff7c <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 15 c6 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 68 43 12 f0       	push   $0xf0124368
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 40 cf 01 00       	call   f011ff7c <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 f8 43 12 f0       	push   $0xf01243f8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 b3 c5 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 90 44 12 f0       	push   $0xf0124490
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 e8 44 12 f0       	push   $0xf01244e8
f010309d:	68 2d 45 12 f0       	push   $0xf012452d
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 42 45 12 f0       	push   $0xf0124542
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 e8 44 12 f0       	push   $0xf01244e8
f01030bc:	68 2d 45 12 f0       	push   $0xf012452d
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 42 45 12 f0       	push   $0xf0124542
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 7b 7e 00 00       	call   f010af62 <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 56 45 12 f0       	push   $0xf0124556
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 68 45 12 f0       	push   $0xf0124568
f0103117:	68 2d 45 12 f0       	push   $0xf012452d
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 42 45 12 f0       	push   $0xf0124542
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 98 45 12 f0       	push   $0xf0124598
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 10 35 ac f0 00 	movl   $0x0,0xf0ac3510
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 b1 cd 01 00       	call   f011ff7c <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 98 45 12 f0       	push   $0xf0124598
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 10 35 ac f0 00 	movl   $0x0,0xf0ac3510
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 b0 45 12 f0       	push   $0xf01245b0
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 c7 cc 01 00       	call   f011ff7c <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 c4 c2 00 00       	call   f010f590 <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 10 46 12 f0       	push   $0xf0124610
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 9e c2 00 00       	call   f010f590 <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 54 46 12 f0       	push   $0xf0124654
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 94 46 12 f0       	push   $0xf0124694
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 3c cc 01 00       	call   f011ff7c <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 b2 c2 00 00       	call   f010f603 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 e8 46 12 f0       	push   $0xf01246e8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 4d c2 00 00       	call   f010f5c3 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 1c 47 12 f0       	push   $0xf012471c
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 3b c2 00 00       	call   f010f5d3 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 48 47 12 f0       	push   $0xf0124748
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 29 c2 00 00       	call   f010f5e3 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 70 47 12 f0       	push   $0xf0124770
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 90 cb 01 00       	call   f011ff7c <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 a4 47 12 f0       	push   $0xf01247a4
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 3c cb 01 00       	call   f011ff7c <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 09 cb 01 00       	call   f011ff7c <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 dc 47 12 f0       	push   $0xf01247dc
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 24 32 ac f0    	mov    0xf0ac3224,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 09 48 12 f0       	push   $0xf0124809
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 8d 41 12 f0       	push   $0xf012418d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 64 ca 01 00       	call   f011ff7c <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 49 ca 01 00       	call   f011ff7c <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 10 48 12 f0       	push   $0xf0124810
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 8d 41 12 f0       	push   $0xf012418d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 4c 48 12 f0       	push   $0xf012484c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 24 32 ac f0    	mov    0xf0ac3224,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 09 48 12 f0       	push   $0xf0124809
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 8d 41 12 f0       	push   $0xf012418d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 80 48 12 f0       	push   $0xf0124880
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 10 48 12 f0       	push   $0xf0124810
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 bc 48 12 f0       	push   $0xf01248bc
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 0b c9 01 00       	call   f011ff7c <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 ea b6 01 00       	call   f011ed70 <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 e4 48 12 f0       	push   $0xf01248e4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 0c 49 12 f0       	push   $0xf012490c
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 68 bf 00 00       	call   f010f631 <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 30 49 12 f0       	push   $0xf0124930
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 2f bf 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 58 49 12 f0       	push   $0xf0124958
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 0c bf 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 98 49 12 f0       	push   $0xf0124998
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 1f bf 00 00       	call   f010f64c <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 d4 49 12 f0       	push   $0xf01249d4
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 1f bf 00 00       	call   f010f667 <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 f8 49 12 f0       	push   $0xf01249f8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 28 4a 12 f0       	push   $0xf0124a28
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 54 4a 12 f0       	push   $0xf0124a54
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 84 4a 12 f0       	push   $0xf0124a84
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 b4 4a 12 f0       	push   $0xf0124ab4
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 e4 4a 12 f0       	push   $0xf0124ae4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 14 4b 12 f0       	push   $0xf0124b14
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 40 4b 12 f0       	push   $0xf0124b40
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 6c 4b 12 f0       	push   $0xf0124b6c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 98 4b 12 f0       	push   $0xf0124b98
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 c4 4b 12 f0       	push   $0xf0124bc4
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 f0 4b 12 f0       	push   $0xf0124bf0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 f0 4b 12 f0       	push   $0xf0124bf0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 24 4c 12 f0       	push   $0xf0124c24
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 54 4c 12 f0       	push   $0xf0124c54
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 84 4c 12 f0       	push   $0xf0124c84
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 b8 4c 12 f0       	push   $0xf0124cb8
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 f4 4c 12 f0       	push   $0xf0124cf4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 24 4d 12 f0       	push   $0xf0124d24
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 50 4d 12 f0       	push   $0xf0124d50
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 7c 4d 12 f0       	push   $0xf0124d7c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 ac 4d 12 f0       	push   $0xf0124dac
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 ff bc 00 00       	call   f010f6de <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 dc 4d 12 f0       	push   $0xf0124ddc
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 b9 bc 00 00       	call   f010f6b8 <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 18 4e 12 f0       	push   $0xf0124e18
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 ba bc 00 00       	call   f010f6de <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 dc 4d 12 f0       	push   $0xf0124ddc
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 74 bc 00 00       	call   f010f6b8 <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 3c 4e 12 f0       	push   $0xf0124e3c
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 62 bc 00 00       	call   f010f6d0 <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 3d bc 00 00       	call   f010f6b8 <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 5c 4e 12 f0       	push   $0xf0124e5c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 2b bc 00 00       	call   f010f6d0 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 06 bc 00 00       	call   f010f6b8 <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 3c bc 00 00       	call   f010f6f6 <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 78 4e 12 f0       	push   $0xf0124e78
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 a8 4e 12 f0       	push   $0xf0124ea8
f0103ada:	e8 35 bf 01 00       	call   f011fa14 <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 8a c4 01 00       	call   f011ff7c <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 ea bb 00 00       	call   f010f6e8 <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 f0 bb 00 00       	call   f010f6f6 <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 d4 4e 12 f0       	push   $0xf0124ed4
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 f9 4e 12 f0       	push   $0xf0124ef9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 a5 bb 00 00       	call   f010f6de <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 14 4f 12 f0       	push   $0xf0124f14
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 72 bb 00 00       	call   f010f6c6 <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 64 4f 12 f0       	push   $0xf0124f64
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 ff c3 01 00       	call   f011ff7c <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 5f bb 00 00       	call   f010f6e8 <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 65 bb 00 00       	call   f010f6f6 <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 d4 4e 12 f0       	push   $0xf0124ed4
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 2a bb 00 00       	call   f010f6de <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 14 4f 12 f0       	push   $0xf0124f14
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 f7 ba 00 00       	call   f010f6c6 <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 64 4f 12 f0       	push   $0xf0124f64
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 0e bb 00 00       	call   f010f6f6 <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 aa 4f 12 f0       	push   $0xf0124faa
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 41 c6 00 00       	call   f0110255 <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 c7 c7 01 00       	call   f0120404 <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 d8 c8 01 00       	call   f0120544 <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 c8 4f 12 f0       	push   $0xf0124fc8
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 df 4f 12 f0       	push   $0xf0124fdf
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 40 35 ec f0 00 	movl   $0x0,0xf0ec3540
f0103c9f:	00 00 00 
f0103ca2:	c7 05 44 35 ec f0 00 	movl   $0x0,0xf0ec3544
f0103ca9:	00 00 00 
f0103cac:	c7 05 4c 35 ec f0 00 	movl   $0x0,0xf0ec354c
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 fc 4f 12 f0       	push   $0xf0124ffc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 df 4f 12 f0       	push   $0xf0124fdf
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 40 35 ec f0    	mov    0xf0ec3540,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 40 35 ec f0    	mov    0xf0ec3540,%edx
f0103d36:	8b 1d 20 2c 6c f0    	mov    0xf06c2c20,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 44 35 ec f0       	mov    %eax,0xf0ec3544
f0103d68:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 40 35 ec f0       	mov    %eax,0xf0ec3540
f0103d81:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 4c 35 ec f0       	mov    0xf0ec354c,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 4c 35 ec f0       	mov    %eax,0xf0ec354c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 20 2c 6c f0    	mov    0xf06c2c20,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 50 35 ec f0       	push   $0xf0ec3550
f0103e0a:	e8 5f be 00 00       	call   f010fc6e <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 40 35 ec f0       	mov    0xf0ec3540,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 1f 50 12 f0       	push   $0xf012501f
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 df 4f 12 f0       	push   $0xf0124fdf
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 44 35 ec f0       	mov    %eax,0xf0ec3544
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 40 35 ec f0       	mov    %eax,0xf0ec3540
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 4c 35 ec f0       	mov    0xf0ec354c,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 4c 35 ec f0       	mov    %eax,0xf0ec354c
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 50 35 ec f0       	push   $0xf0ec3550
f0103ed6:	e8 1a be 00 00       	call   f010fcf5 <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 50 35 ec f0       	push   $0xf0ec3550
f0103efc:	e8 6d bd 00 00       	call   f010fc6e <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 fc 4f 12 f0       	push   $0xf0124ffc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 df 4f 12 f0       	push   $0xf0124fdf
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 40 35 ec f0    	mov    0xf0ec3540,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 40 35 ec f0    	mov    0xf0ec3540,%edx
f0103f5b:	8b 1d 20 2c 6c f0    	mov    0xf06c2c20,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 44 35 ec f0       	mov    %eax,0xf0ec3544
f0103f8d:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 40 35 ec f0       	mov    %eax,0xf0ec3540
f0103fa6:	8b 0d 20 2c 6c f0    	mov    0xf06c2c20,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 4c 35 ec f0       	mov    0xf0ec354c,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 4c 35 ec f0       	mov    %eax,0xf0ec354c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 50 35 ec f0       	push   $0xf0ec3550
f0103fd4:	e8 1c bd 00 00       	call   f010fcf5 <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 b1 58 00 00       	call   f01098cd <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 40 50 12 f0       	push   $0xf0125040
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 df 4f 12 f0       	push   $0xf0124fdf
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 a1 54 00 00       	call   f010952a <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 ac 57 00 00       	call   f0109870 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 29 bd 01 00       	call   f011fe0a <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 fc 33 ac f0       	mov    0xf0ac33fc,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 70 50 12 f0       	push   $0xf0125070
f0104192:	68 96 50 12 f0       	push   $0xf0125096
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 df 4f 12 f0       	push   $0xf0124fdf
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 70 50 12 f0       	push   $0xf0125070
f0104245:	68 96 50 12 f0       	push   $0xf0125096
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 df 4f 12 f0       	push   $0xf0124fdf
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 70 50 12 f0       	push   $0xf0125070
f010430b:	68 96 50 12 f0       	push   $0xf0125096
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 df 4f 12 f0       	push   $0xf0124fdf
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 ac 50 12 f0       	push   $0xf01250ac
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 df 4f 12 f0       	push   $0xf0124fdf
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 f8 50 12 f0       	push   $0xf01250f8
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 df 4f 12 f0       	push   $0xf0124fdf
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 dd 56 00 00       	call   f0109c64 <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 55 52 00 00       	call   f01098cd <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 9e 50 00 00       	call   f010978a <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 76 50 00 00       	call   f010978a <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 2c 50 00 00       	call   f010978a <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 80 4d 00 00       	call   f010952a <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 9e 50 00 00       	call   f0109870 <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 15 b6 01 00       	call   f011fe0a <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 78 50 00 00       	call   f01098cd <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 50 35 ec f0       	push   $0xf0ec3550
f01048b3:	e8 b6 b3 00 00       	call   f010fc6e <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 4c 35 ec f0       	mov    0xf0ec354c,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 50 35 ec f0       	push   $0xf0ec3550
f01048cb:	e8 25 b4 00 00       	call   f010fcf5 <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 28 4c 00 00       	call   f010952a <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 46 4f 00 00       	call   f0109870 <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 bd b4 01 00       	call   f011fe0a <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 70 50 12 f0       	push   $0xf0125070
f010496b:	68 96 50 12 f0       	push   $0xf0125096
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 df 4f 12 f0       	push   $0xf0124fdf
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 74 51 12 f0       	push   $0xf0125174
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 f0 b9 01 00       	call   f0120544 <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 08 35 ac f0 00 	movl   $0x0,0xf0ac3508
f0104c05:	00 00 00 
f0104c08:	c7 05 0c 35 ac f0 00 	movl   $0x0,0xf0ac350c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 58 96 00 00       	call   f010e279 <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 98 51 12 f0       	push   $0xf0125198
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 f4 51 12 f0       	push   $0xf01251f4
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 98 51 12 f0       	push   $0xf0125198
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 f4 51 12 f0       	push   $0xf01251f4
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 08 52 12 f0       	push   $0xf0125208
f0104fbb:	68 16 52 12 f0       	push   $0xf0125216
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 2b 52 12 f0       	push   $0xf012522b
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 44 52 12 f0       	push   $0xf0125244
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 2b 52 12 f0       	push   $0xf012522b
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 67 52 12 f0       	push   $0xf0125267
f0105072:	6a 44                	push   $0x44
f0105074:	68 2b 52 12 f0       	push   $0xf012522b
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 08 52 12 f0       	push   $0xf0125208
f0105104:	68 16 52 12 f0       	push   $0xf0125216
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 2b 52 12 f0       	push   $0xf012522b
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 67 52 12 f0       	push   $0xf0125267
f010512d:	6a 52                	push   $0x52
f010512f:	68 2b 52 12 f0       	push   $0xf012522b
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105227:	e8 42 aa 00 00       	call   f010fc6e <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 44 45 00 00       	call   f010978a <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 2a 45 00 00       	call   f010978a <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 60 2e 6c f0       	push   $0xf06c2e60
f010526b:	e8 85 aa 00 00       	call   f010fcf5 <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105284:	e8 fe ab 00 00       	call   f010fe87 <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 88 52 12 f0       	push   $0xf0125288
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 2b 52 12 f0       	push   $0xf012522b
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 c9 52 12 f0       	push   $0xf01252c9
f01052b2:	68 16 52 12 f0       	push   $0xf0125216
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 2b 52 12 f0       	push   $0xf012522b
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 60 2e 6c f0       	push   $0xf06c2e60
f01052f5:	e8 8d ab 00 00       	call   f010fe87 <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 88 52 12 f0       	push   $0xf0125288
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 2b 52 12 f0       	push   $0xf012522b
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 d8 52 12 f0       	push   $0xf01252d8
f010532e:	68 16 52 12 f0       	push   $0xf0125216
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 2b 52 12 f0       	push   $0xf012522b
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 67 52 12 f0       	push   $0xf0125267
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 2b 52 12 f0       	push   $0xf012522b
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105453:	e8 2f aa 00 00       	call   f010fe87 <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 88 52 12 f0       	push   $0xf0125288
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 2b 52 12 f0       	push   $0xf012522b
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 c9 52 12 f0       	push   $0xf01252c9
f0105481:	68 16 52 12 f0       	push   $0xf0125216
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 2b 52 12 f0       	push   $0xf012522b
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 d0 2e 6c f0       	push   $0xf06c2ed0
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 60 2e 6c f0       	push   $0xf06c2e60
f01054c3:	e8 bf a9 00 00       	call   f010fe87 <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 88 52 12 f0       	push   $0xf0125288
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 2b 52 12 f0       	push   $0xf012522b
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 04 53 12 f0       	push   $0xf0125304
f01054fc:	68 16 52 12 f0       	push   $0xf0125216
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 2b 52 12 f0       	push   $0xf012522b
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 67 52 12 f0       	push   $0xf0125267
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 2b 52 12 f0       	push   $0xf012522b
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 d4 2e 6c f0       	mov    %eax,0xf06c2ed4
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 d0 2e 6c f0       	mov    %eax,0xf06c2ed0
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 dc 2e 6c f0       	mov    0xf06c2edc,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 dc 2e 6c f0       	mov    %eax,0xf06c2edc
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 60 2e 6c f0       	push   $0xf06c2e60
f01055b3:	e8 cf a8 00 00       	call   f010fe87 <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 88 52 12 f0       	push   $0xf0125288
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 2b 52 12 f0       	push   $0xf012522b
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 c9 52 12 f0       	push   $0xf01252c9
f01055e1:	68 16 52 12 f0       	push   $0xf0125216
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 2b 52 12 f0       	push   $0xf012522b
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 e4 a0 00 00       	call   f010f6de <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 59 76 00 00       	call   f010cc62 <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 e0 2e 6c f0       	push   $0xf06c2ee0
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 60 2e 6c f0       	push   $0xf06c2e60
f010563a:	e8 48 a8 00 00       	call   f010fe87 <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 88 52 12 f0       	push   $0xf0125288
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 2b 52 12 f0       	push   $0xf012522b
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 30 53 12 f0       	push   $0xf0125330
f0105673:	68 16 52 12 f0       	push   $0xf0125216
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 2b 52 12 f0       	push   $0xf012522b
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 67 52 12 f0       	push   $0xf0125267
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 2b 52 12 f0       	push   $0xf012522b
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 e4 2e 6c f0       	mov    %eax,0xf06c2ee4
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 e0 2e 6c f0       	mov    %eax,0xf06c2ee0
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 ec 2e 6c f0       	mov    0xf06c2eec,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 ec 2e 6c f0       	mov    %eax,0xf06c2eec
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 60 2e 6c f0       	push   $0xf06c2e60
f010572a:	e8 3f a5 00 00       	call   f010fc6e <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 5b 53 12 f0       	push   $0xf012535b
f010573d:	68 16 52 12 f0       	push   $0xf0125216
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 2b 52 12 f0       	push   $0xf012522b
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105767:	e8 89 a5 00 00       	call   f010fcf5 <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105780:	e8 e9 a4 00 00       	call   f010fc6e <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 60 2e 6c f0       	push   $0xf06c2e60
f01057d7:	e8 19 a5 00 00       	call   f010fcf5 <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 d8 2e 6c f0       	mov    %eax,0xf06c2ed8
f0105804:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 60 2e 6c f0       	push   $0xf06c2e60
f010581e:	e8 d2 a4 00 00       	call   f010fcf5 <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105837:	e8 4b a6 00 00       	call   f010fe87 <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105850:	e8 19 a4 00 00       	call   f010fc6e <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 d8 2e 6c f0       	mov    %eax,0xf06c2ed8
f01058b6:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 67 52 12 f0       	push   $0xf0125267
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 2b 52 12 f0       	push   $0xf012522b
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 a5 5f 00 00       	call   f010b9e0 <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 63 53 12 f0       	push   $0xf0125363
f0105a49:	68 16 52 12 f0       	push   $0xf0125216
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 2b 52 12 f0       	push   $0xf012522b
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 c2 60 00 00       	call   f010bb61 <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105aad:	e8 43 a2 00 00       	call   f010fcf5 <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105ac6:	e8 a3 a1 00 00       	call   f010fc6e <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 74 53 12 f0       	push   $0xf0125374
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 d8 2e 6c f0       	mov    %eax,0xf06c2ed8
f0105b4c:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 9c 53 12 f0       	push   $0xf012539c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 67 52 12 f0       	push   $0xf0125267
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 2b 52 12 f0       	push   $0xf012522b
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 c8 53 12 f0       	push   $0xf01253c8
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 e8 2e 6c f0       	mov    %eax,0xf06c2ee8
f0105d65:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105d7c:	e8 74 9f 00 00       	call   f010fcf5 <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 03 5c 00 00       	call   f010b998 <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 ee 53 12 f0       	push   $0xf01253ee
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 2e 5c 00 00       	call   f010b9e0 <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 63 53 12 f0       	push   $0xf0125363
f0105dc0:	68 16 52 12 f0       	push   $0xf0125216
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 2b 52 12 f0       	push   $0xf012522b
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 f4 53 12 f0       	push   $0xf01253f4
f0105df5:	68 16 52 12 f0       	push   $0xf0125216
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 2b 52 12 f0       	push   $0xf012522b
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 18 54 12 f0       	push   $0xf0125418
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 66 5b 00 00       	call   f010b998 <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 ee 53 12 f0       	push   $0xf01253ee
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 10 5d 00 00       	call   f010bb61 <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 60 2e 6c f0       	push   $0xf06c2e60
f0105e62:	e8 07 9e 00 00       	call   f010fc6e <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 44 54 12 f0       	push   $0xf0125444
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 66 54 12 f0       	push   $0xf0125466
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 d8 2e 6c f0       	mov    %eax,0xf06c2ed8
f0105ecb:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 70 54 12 f0       	push   $0xf0125470
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 8c 54 12 f0       	push   $0xf012548c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 c0 54 12 f0       	push   $0xf01254c0
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 66 54 12 f0       	push   $0xf0125466
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 e8 54 12 f0       	push   $0xf01254e8
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 8c 54 12 f0       	push   $0xf012548c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 0c 55 12 f0       	push   $0xf012550c
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 66 54 12 f0       	push   $0xf0125466
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 e8 2e 6c f0       	mov    %eax,0xf06c2ee8
f0106041:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 2e 55 12 f0       	push   $0xf012552e
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 60 2e 6c f0       	push   $0xf06c2e60
f010606a:	e8 86 9c 00 00       	call   f010fcf5 <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106083:	e8 e6 9b 00 00       	call   f010fc6e <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 dc 2e 6c f0       	mov    0xf06c2edc,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 d0 2e 6c f0       	push   $0xf06c2ed0
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 60 2e 6c f0       	push   $0xf06c2e60
f01060d7:	e8 19 9c 00 00       	call   f010fcf5 <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 4c 55 12 f0       	push   $0xf012554c
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 2b 52 12 f0       	push   $0xf012522b
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106118:	e8 51 9b 00 00       	call   f010fc6e <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 88 55 12 f0       	push   $0xf0125588
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 d0 2e 6c f0       	mov    0xf06c2ed0,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 b4 55 12 f0       	push   $0xf01255b4
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 1a 58 00 00       	call   f010b998 <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 ee 53 12 f0       	push   $0xf01253ee
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 d8 2e 6c f0       	mov    %eax,0xf06c2ed8
f01061b1:	a1 d8 2e 6c f0       	mov    0xf06c2ed8,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 c7 55 12 f0       	push   $0xf01255c7
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 8c 54 12 f0       	push   $0xf012548c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 e4 55 12 f0       	push   $0xf01255e4
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 b4 55 12 f0       	push   $0xf01255b4
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 67 52 12 f0       	push   $0xf0125267
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 2b 52 12 f0       	push   $0xf012522b
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 9a 56 00 00       	call   f010b998 <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 ee 53 12 f0       	push   $0xf01253ee
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 e8 54 12 f0       	push   $0xf01254e8
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 8c 54 12 f0       	push   $0xf012548c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 18 56 12 f0       	push   $0xf0125618
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 b4 55 12 f0       	push   $0xf01255b4
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 a5 55 00 00       	call   f010b998 <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 ee 53 12 f0       	push   $0xf01253ee
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 e8 2e 6c f0       	mov    %eax,0xf06c2ee8
f0106426:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 2e 55 12 f0       	push   $0xf012552e
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 94 55 00 00       	call   f010b9e0 <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 f4 53 12 f0       	push   $0xf01253f4
f010646b:	68 16 52 12 f0       	push   $0xf0125216
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 2b 52 12 f0       	push   $0xf012522b
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 18 54 12 f0       	push   $0xf0125418
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 f0 54 00 00       	call   f010b998 <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 ee 53 12 f0       	push   $0xf01253ee
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 a1 56 00 00       	call   f010bb61 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 60 2e 6c f0       	push   $0xf06c2e60
f01064c8:	e8 28 98 00 00       	call   f010fcf5 <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 60 2e 6c f0       	push   $0xf06c2e60
f01064e3:	e8 86 97 00 00       	call   f010fc6e <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 67 52 12 f0       	push   $0xf0125267
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 2b 52 12 f0       	push   $0xf012522b
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 60 2e 6c f0       	push   $0xf06c2e60
f010664e:	e8 a2 96 00 00       	call   f010fcf5 <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 08 35 ac f0       	mov    0xf0ac3508,%eax
f0106661:	8b 15 0c 35 ac f0    	mov    0xf0ac350c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 44 56 12 f0       	push   $0xf0125644
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 2b 52 12 f0       	push   $0xf012522b
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 44 56 12 f0       	push   $0xf0125644
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 2b 52 12 f0       	push   $0xf012522b
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 44 56 12 f0       	push   $0xf0125644
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 2b 52 12 f0       	push   $0xf012522b
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 44 56 12 f0       	push   $0xf0125644
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 2b 52 12 f0       	push   $0xf012522b
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 54 33 ac f0       	mov    0xf0ac3354,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 54 33 ac f0       	mov    0xf0ac3354,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 54 33 ac f0       	mov    0xf0ac3354,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 38 30 ac f0 00 	movl   $0x0,0xf0ac3038
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 d0 2e 6c f0       	push   $0xf06c2ed0
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 e0 2e 6c f0       	push   $0xf06c2ee0
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 58 56 12 f0       	push   $0xf0125658
f0106781:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106786:	e8 b2 94 00 00       	call   f010fc3d <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 6c 56 12 f0       	push   $0xf012566c
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 a2 56 12 f0       	push   $0xf01256a2
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 01 86 01 00       	call   f011edd8 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 60 2e 6c f0       	push   $0xf06c2e60
f01067fb:	e8 6e 94 00 00       	call   f010fc6e <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 54 33 ac f0       	mov    0xf0ac3354,%eax
f0106808:	8b 04 85 4c f9 17 f0 	mov    -0xfe806b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 c7 51 00 00       	call   f010b9e0 <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 e2 51 00 00       	call   f010ba09 <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 a9 85 01 00       	call   f011edde <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 c6 51 00 00       	call   f010ba09 <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 ae 51 00 00       	call   f010ba09 <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 1b 54 00 00       	call   f010bc84 <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 b4 56 12 f0       	push   $0xf01256b4
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 a2 56 12 f0       	push   $0xf01256a2
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 22 51 00 00       	call   f010b9e0 <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 eb 56 12 f0       	push   $0xf01256eb
f01068d2:	68 05 57 12 f0       	push   $0xf0125705
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 a2 56 12 f0       	push   $0xf01256a2
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 1a 57 12 f0       	push   $0xf012571a
f01068fd:	68 05 57 12 f0       	push   $0xf0125705
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 a2 56 12 f0       	push   $0xf01256a2
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 54 53 00 00       	call   f010bc6d <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 e6 50 00 00       	call   f010ba09 <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106990:	e8 60 93 00 00       	call   f010fcf5 <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 c4 35 ec f0 01 	movb   $0x1,0xf0ec35c4
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 61 2b 00 00       	call   f010952a <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 f0 2e 6c f0       	mov    %eax,0xf06c2ef0
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 48 2b 00 00       	call   f010952a <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 24 32 ac f0       	mov    %eax,0xf0ac3224
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 30 57 12 f0       	push   $0xf0125730
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 54 33 ac f0 00 	movl   $0x0,0xf0ac3354
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 58 57 12 f0       	push   $0xf0125758
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 a2 56 12 f0       	push   $0xf01256a2
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 58 57 12 f0       	push   $0xf0125758
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 a2 56 12 f0       	push   $0xf01256a2
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106ab4:	e8 ce 93 00 00       	call   f010fe87 <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 6c 57 12 f0       	push   $0xf012576c
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 a2 56 12 f0       	push   $0xf01256a2
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 fd 4e 00 00       	call   f010b9e0 <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 24 32 ac f0       	mov    0xf0ac3224,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106b3d:	e8 45 93 00 00       	call   f010fe87 <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 b8 57 12 f0       	push   $0xf01257b8
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 a2 56 12 f0       	push   $0xf01256a2
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 58 57 12 f0       	push   $0xf0125758
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 a2 56 12 f0       	push   $0xf01256a2
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 60 2e 6c f0       	push   $0xf06c2e60
f0106b85:	e8 fd 92 00 00       	call   f010fe87 <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 08 58 12 f0       	push   $0xf0125808
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 a2 56 12 f0       	push   $0xf01256a2
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 58 57 12 f0       	push   $0xf0125758
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 a2 56 12 f0       	push   $0xf01256a2
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 58 57 12 f0       	push   $0xf0125758
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 a2 56 12 f0       	push   $0xf01256a2
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 08 35 ac f0       	mov    0xf0ac3508,%eax
f0106bea:	8b 15 0c 35 ac f0    	mov    0xf0ac350c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 08 35 ac f0       	mov    %eax,0xf0ac3508
f0106bfb:	89 15 0c 35 ac f0    	mov    %edx,0xf0ac350c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 da 4d 00 00       	call   f010b9e0 <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 ed 89 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 c3 4e 00 00       	call   f010bb02 <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 92 4d 00 00       	call   f010b9e0 <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 a5 30 00 00       	call   f0109d28 <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 a2 2f 00 00       	call   f0109c64 <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 78 30 00 00       	call   f0109e04 <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 5e 30 00 00       	call   f0109e28 <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 6c a3 69 f0 01 	movl   $0x1,0xf069a36c
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 6c a3 69 f0       	mov    0xf069a36c,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 6c a3 69 f0       	mov    0xf069a36c,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 6c a3 69 f0       	mov    0xf069a36c,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 6c a3 69 f0       	mov    0xf069a36c,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 40 30 ac f0       	mov    $0xf0ac3040,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 1b 5f 00 00       	call   f010d0b0 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 62 8c 01 00       	call   f011fe0a <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 55 58 12 f0       	push   $0xf0125855
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 6c 58 12 f0       	push   $0xf012586c
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 7b 58 12 f0       	push   $0xf012587b
f010727e:	6a 61                	push   $0x61
f0107280:	68 6c 58 12 f0       	push   $0xf012586c
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 24 35 ec f0       	mov    %eax,0xf0ec3524
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 84 58 12 f0       	push   $0xf0125884
f0107662:	6a 57                	push   $0x57
f0107664:	68 b8 58 12 f0       	push   $0xf01258b8
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 64 36 ec f0       	mov    %eax,0xf0ec3664
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 84 58 12 f0       	push   $0xf0125884
f0107693:	6a 63                	push   $0x63
f0107695:	68 b8 58 12 f0       	push   $0xf01258b8
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 77 25 00 00       	call   f0109c64 <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 f8 30 ac f0    	mov    0xf0ac30f8,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 60 33 ac f0       	mov    %eax,0xf0ac3360
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 20 2c 6c f0       	mov    %eax,0xf06c2c20
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 d8 69 01 00       	call   f011e17a <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 d8 58 12 f0       	push   $0xf01258d8
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 74 a3 69 f0       	mov    %eax,0xf069a374
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 74 a3 69 f0       	mov    0xf069a374,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 84 58 12 f0       	push   $0xf0125884
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 b8 58 12 f0       	push   $0xf01258b8
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 24 35 ec f0    	mov    0xf0ec3524,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 dc 78 01 00       	call   f011f14d <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 30 30 ac f0 19 	movl   $0x19,0xf0ac3030
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 20 35 ec f0 50 	movl   $0xf2656050,0xf0ec3520
f0107899:	60 65 f2 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 20 35 ec f0       	mov    %eax,0xf0ec3520

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 20 35 ec f0    	mov    0xf0ec3520,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 20 35 ec f0       	mov    %eax,0xf0ec3520

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 1b 85 01 00       	call   f011fe0a <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 00 59 12 f0       	push   $0xf0125900
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 b8 58 12 f0       	push   $0xf01258b8
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 84 58 12 f0       	push   $0xf0125884
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 b8 58 12 f0       	push   $0xf01258b8
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 f8 30 ac f0       	mov    %eax,0xf0ac30f8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 30 59 12 f0       	push   $0xf0125930
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 53 59 12 f0       	push   $0xf0125953
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 84 58 12 f0       	push   $0xf0125884
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 b8 58 12 f0       	push   $0xf01258b8
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 84 58 12 f0       	push   $0xf0125884
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 b8 58 12 f0       	push   $0xf01258b8
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 60 33 ac f0    	mov    0xf0ac3360,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 70 59 12 f0       	push   $0xf0125970
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 95 59 12 f0       	push   $0xf0125995
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 60 33 ac f0    	mov    0xf0ac3360,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 00 2f ac f0 00 	movl   $0x0,0xf0ac2f00
f0107ddc:	00 00 00 
f0107ddf:	c7 05 04 2f ac f0 00 	movl   $0x0,0xf0ac2f04
f0107de6:	00 00 00 
f0107de9:	c7 05 0c 2f ac f0 00 	movl   $0x0,0xf0ac2f0c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 10 2f ac f0 00 	movl   $0x0,0xf0ac2f10
f0107dfa:	00 00 00 
f0107dfd:	c7 05 14 2f ac f0 00 	movl   $0x0,0xf0ac2f14
f0107e04:	00 00 00 
f0107e07:	c7 05 1c 2f ac f0 00 	movl   $0x0,0xf0ac2f1c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 af 59 12 f0       	push   $0xf01259af
f0107e19:	68 20 2f ac f0       	push   $0xf0ac2f20
f0107e1e:	e8 1a 7e 00 00       	call   f010fc3d <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 60 33 ac f0       	mov    0xf0ac3360,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 60 33 ac f0       	mov    0xf0ac3360,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 60 33 ac f0       	mov    0xf0ac3360,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 fc 33 ac f0 00 	movl   $0xf0001000,0xf0ac33fc
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 cc 35 ec f0 00 	movl   $0xf0002000,0xf0ec35cc
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 fc 33 ac f0    	mov    0xf0ac33fc,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 cc 35 ec f0    	mov    0xf0ec35cc,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 c0 59 12 f0       	push   $0xf01259c0
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 e3 59 12 f0       	push   $0xf01259e3
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 00 2f ac f0    	mov    0xf0ac2f00,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 00 2f ac f0    	mov    0xf0ac2f00,%edx
f0107f37:	8b 1d 60 33 ac f0    	mov    0xf0ac3360,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 04 2f ac f0       	mov    %eax,0xf0ac2f04
f0107f69:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 00 2f ac f0       	mov    %eax,0xf0ac2f00
f0107f82:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 0c 2f ac f0       	mov    %eax,0xf0ac2f0c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 00 5a 12 f0       	push   $0xf0125a00
f0108012:	6a 68                	push   $0x68
f0108014:	68 e3 59 12 f0       	push   $0xf01259e3
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 c0 59 12 f0       	push   $0xf01259c0
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 e3 59 12 f0       	push   $0xf01259e3
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 00 2f ac f0    	mov    0xf0ac2f00,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 00 2f ac f0    	mov    0xf0ac2f00,%edx
f0108108:	8b 1d 60 33 ac f0    	mov    0xf0ac3360,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 04 2f ac f0       	mov    %eax,0xf0ac2f04
f010813a:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 00 2f ac f0       	mov    %eax,0xf0ac2f00
f0108153:	8b 0d 60 33 ac f0    	mov    0xf0ac3360,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 0c 2f ac f0       	mov    %eax,0xf0ac2f0c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 5e 7c 01 00       	call   f011fe0a <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 20 2f ac f0       	push   $0xf0ac2f20
f01081c0:	e8 c2 7c 00 00       	call   f010fe87 <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 20 2f ac f0       	push   $0xf0ac2f20
f01081d9:	e8 90 7a 00 00       	call   f010fc6e <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 00 2f ac f0    	mov    0xf0ac2f00,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 34 5a 12 f0       	push   $0xf0125a34
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 e3 59 12 f0       	push   $0xf01259e3
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 81 5a 12 f0       	push   $0xf0125a81
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 e3 59 12 f0       	push   $0xf01259e3
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 04 2f ac f0       	mov    %eax,0xf0ac2f04
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 00 2f ac f0       	mov    %eax,0xf0ac2f00
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 0c 2f ac f0       	mov    %eax,0xf0ac2f0c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 9c 1a 00 00       	call   f0109d71 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 20 2f ac f0       	push   $0xf0ac2f20
f01082f7:	e8 f9 79 00 00       	call   f010fcf5 <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 20 2f ac f0       	push   $0xf0ac2f20
f0108314:	e8 6e 7b 00 00       	call   f010fe87 <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 20 2f ac f0       	push   $0xf0ac2f20
f010832d:	e8 3c 79 00 00       	call   f010fc6e <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 c0 59 12 f0       	push   $0xf01259c0
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 e3 59 12 f0       	push   $0xf01259e3
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 00 2f ac f0    	mov    0xf0ac2f00,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 00 2f ac f0       	mov    0xf0ac2f00,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 04 2f ac f0       	mov    %eax,0xf0ac2f04
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 00 2f ac f0       	mov    %eax,0xf0ac2f00
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 0c 2f ac f0       	mov    %eax,0xf0ac2f0c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 20 2f ac f0       	push   $0xf0ac2f20
f01083b4:	e8 3c 79 00 00       	call   f010fcf5 <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 9d 14 00 00       	call   f01098cd <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 a0 5a 12 f0       	push   $0xf0125aa0
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 e3 59 12 f0       	push   $0xf01259e3
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 56 72 00 00       	call   f010f700 <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 ef 13 00 00       	call   f01098cd <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 a0 5a 12 f0       	push   $0xf0125aa0
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 e3 59 12 f0       	push   $0xf01259e3
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 d1 0f 00 00       	call   f010952a <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 cf 5a 12 f0       	push   $0xf0125acf
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 e3 59 12 f0       	push   $0xf01259e3
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 d5 12 00 00       	call   f0109870 <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 55 78 01 00       	call   f011fe0a <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 a0 5a 12 f0       	push   $0xf0125aa0
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 e3 59 12 f0       	push   $0xf01259e3
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 9d 77 01 00       	call   f011fe0a <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 ec 5a 12 f0       	push   $0xf0125aec
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp
		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 05 10 00 00       	call   f01098cd <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 a0 5a 12 f0       	push   $0xf0125aa0
f01088f6:	68 f9 01 00 00       	push   $0x1f9
f01088fb:	68 e3 59 12 f0       	push   $0xf01259e3
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 20 2f ac f0       	push   $0xf0ac2f20
f0108987:	e8 fb 74 00 00       	call   f010fe87 <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 20 2f ac f0       	push   $0xf0ac2f20
f01089a0:	e8 c9 72 00 00       	call   f010fc6e <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 00 2f ac f0       	mov    0xf0ac2f00,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 08 2f ac f0       	mov    0xf0ac2f08,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 08 2f ac f0       	mov    %eax,0xf0ac2f08
f01089e3:	a1 08 2f ac f0       	mov    0xf0ac2f08,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 1c 2f ac f0       	mov    0xf0ac2f1c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 20 2f ac f0       	push   $0xf0ac2f20
f0108a08:	e8 e8 72 00 00       	call   f010fcf5 <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 c0 2d 6c f0 00 	movl   $0x0,0xf06c2dc0
f0108a51:	00 00 00 
f0108a54:	c7 05 c4 2d 6c f0 00 	movl   $0x0,0xf06c2dc4
f0108a5b:	00 00 00 
f0108a5e:	c7 05 cc 2d 6c f0 00 	movl   $0x0,0xf06c2dcc
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 1c 5b 12 f0       	push   $0xf0125b1c
f0108a70:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108a75:	e8 c3 71 00 00       	call   f010fc3d <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 4b 01 00 00       	call   f0108bdf <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 0c 2f ac f0    	mov    0xf0ac2f0c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 3c                	jmp    f0108b05 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 52 0a 00 00       	call   f010952a <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 1a                	jmp    f0108b05 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108aee:	c1 e0 02             	shl    $0x2,%eax
f0108af1:	83 ec 04             	sub    $0x4,%esp
f0108af4:	50                   	push   %eax
f0108af5:	6a 00                	push   $0x0
f0108af7:	ff 75 f4             	pushl  -0xc(%ebp)
f0108afa:	e8 0b 73 01 00       	call   f011fe0a <memset>
f0108aff:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108b05:	c9                   	leave  
f0108b06:	c3                   	ret    

f0108b07 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b07:	55                   	push   %ebp
f0108b08:	89 e5                	mov    %esp,%ebp
f0108b0a:	83 ec 28             	sub    $0x28,%esp
f0108b0d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108b10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108b13:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b1a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b20:	01 d0                	add    %edx,%eax
f0108b22:	48                   	dec    %eax
f0108b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b29:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b2e:	f7 75 f4             	divl   -0xc(%ebp)
f0108b31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b34:	29 d0                	sub    %edx,%eax
f0108b36:	c1 e8 0c             	shr    $0xc,%eax
f0108b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108b3c:	83 ec 0c             	sub    $0xc,%esp
f0108b3f:	6a 60                	push   $0x60
f0108b41:	e8 e4 09 00 00       	call   f010952a <kmalloc>
f0108b46:	83 c4 10             	add    $0x10,%esp
f0108b49:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108b4c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108b50:	75 0a                	jne    f0108b5c <create_share+0x55>
f0108b52:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b57:	e9 81 00 00 00       	jmp    f0108bdd <create_share+0xd6>
	created_share->references=1;
f0108b5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b5f:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b69:	01 c0                	add    %eax,%eax
f0108b6b:	d1 f8                	sar    %eax
f0108b6d:	89 c2                	mov    %eax,%edx
f0108b6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b72:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b77:	83 ec 0c             	sub    $0xc,%esp
f0108b7a:	50                   	push   %eax
f0108b7b:	e8 2f ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b80:	83 c4 10             	add    $0x10,%esp
f0108b83:	89 c2                	mov    %eax,%edx
f0108b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b88:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b8e:	8b 40 54             	mov    0x54(%eax),%eax
f0108b91:	85 c0                	test   %eax,%eax
f0108b93:	75 15                	jne    f0108baa <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108b95:	83 ec 0c             	sub    $0xc,%esp
f0108b98:	ff 75 e8             	pushl  -0x18(%ebp)
f0108b9b:	e8 ea 0b 00 00       	call   f010978a <kfree>
f0108ba0:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ba3:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ba8:	eb 33                	jmp    f0108bdd <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bad:	8b 55 08             	mov    0x8(%ebp),%edx
f0108bb0:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108bb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bb6:	83 c0 08             	add    $0x8,%eax
f0108bb9:	83 ec 08             	sub    $0x8,%esp
f0108bbc:	ff 75 0c             	pushl  0xc(%ebp)
f0108bbf:	50                   	push   %eax
f0108bc0:	e8 a6 70 01 00       	call   f011fc6b <strcpy>
f0108bc5:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108bc8:	8b 55 10             	mov    0x10(%ebp),%edx
f0108bcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bce:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108bd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bd4:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108bd7:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108bdd:	c9                   	leave  
f0108bde:	c3                   	ret    

f0108bdf <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bdf:	55                   	push   %ebp
f0108be0:	89 e5                	mov    %esp,%ebp
f0108be2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108bec:	83 ec 0c             	sub    $0xc,%esp
f0108bef:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108bf4:	e8 75 70 00 00       	call   f010fc6e <acquire_spinlock>
f0108bf9:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bfc:	a1 c0 2d 6c f0       	mov    0xf06c2dc0,%eax
f0108c01:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c04:	eb 41                	jmp    f0108c47 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c09:	8b 40 04             	mov    0x4(%eax),%eax
f0108c0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c0f:	75 2e                	jne    f0108c3f <get_share+0x60>
f0108c11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c14:	83 c0 08             	add    $0x8,%eax
f0108c17:	83 ec 08             	sub    $0x8,%esp
f0108c1a:	ff 75 0c             	pushl  0xc(%ebp)
f0108c1d:	50                   	push   %eax
f0108c1e:	e8 05 71 01 00       	call   f011fd28 <strcmp>
f0108c23:	83 c4 10             	add    $0x10,%esp
f0108c26:	85 c0                	test   %eax,%eax
f0108c28:	75 15                	jne    f0108c3f <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108c2a:	83 ec 0c             	sub    $0xc,%esp
f0108c2d:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108c32:	e8 be 70 00 00       	call   f010fcf5 <release_spinlock>
f0108c37:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c3d:	eb 44                	jmp    f0108c83 <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c3f:	a1 c8 2d 6c f0       	mov    0xf06c2dc8,%eax
f0108c44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c4b:	74 08                	je     f0108c55 <get_share+0x76>
f0108c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c50:	8b 40 58             	mov    0x58(%eax),%eax
f0108c53:	eb 05                	jmp    f0108c5a <get_share+0x7b>
f0108c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c5a:	a3 c8 2d 6c f0       	mov    %eax,0xf06c2dc8
f0108c5f:	a1 c8 2d 6c f0       	mov    0xf06c2dc8,%eax
f0108c64:	85 c0                	test   %eax,%eax
f0108c66:	75 9e                	jne    f0108c06 <get_share+0x27>
f0108c68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c6c:	75 98                	jne    f0108c06 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108c6e:	83 ec 0c             	sub    $0xc,%esp
f0108c71:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108c76:	e8 7a 70 00 00       	call   f010fcf5 <release_spinlock>
f0108c7b:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108c7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c83:	c9                   	leave  
f0108c84:	c3                   	ret    

f0108c85 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c85:	55                   	push   %ebp
f0108c86:	89 e5                	mov    %esp,%ebp
f0108c88:	83 ec 48             	sub    $0x48,%esp
f0108c8b:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c8e:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c91:	e8 4a 2d 00 00       	call   f010b9e0 <get_cpu_proc>
f0108c96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c99:	83 ec 08             	sub    $0x8,%esp
f0108c9c:	ff 75 0c             	pushl  0xc(%ebp)
f0108c9f:	ff 75 08             	pushl  0x8(%ebp)
f0108ca2:	e8 38 ff ff ff       	call   f0108bdf <get_share>
f0108ca7:	83 c4 10             	add    $0x10,%esp
f0108caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108cad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108cb1:	74 0a                	je     f0108cbd <createSharedObject+0x38>
f0108cb3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108cb8:	e9 59 01 00 00       	jmp    f0108e16 <createSharedObject+0x191>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108cbd:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108cc1:	50                   	push   %eax
f0108cc2:	ff 75 10             	pushl  0x10(%ebp)
f0108cc5:	ff 75 0c             	pushl  0xc(%ebp)
f0108cc8:	ff 75 08             	pushl  0x8(%ebp)
f0108ccb:	e8 37 fe ff ff       	call   f0108b07 <create_share>
f0108cd0:	83 c4 10             	add    $0x10,%esp
f0108cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108cd6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108cda:	75 0a                	jne    f0108ce6 <createSharedObject+0x61>
f0108cdc:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108ce1:	e9 30 01 00 00       	jmp    f0108e16 <createSharedObject+0x191>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108ce6:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ced:	8b 55 10             	mov    0x10(%ebp),%edx
f0108cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cf3:	01 d0                	add    %edx,%eax
f0108cf5:	48                   	dec    %eax
f0108cf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cfc:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d01:	f7 75 e4             	divl   -0x1c(%ebp)
f0108d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d07:	29 d0                	sub    %edx,%eax
f0108d09:	c1 e8 0c             	shr    $0xc,%eax
f0108d0c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (int k = 0; k < num_pages; k++)
f0108d0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d16:	eb 6c                	jmp    f0108d84 <createSharedObject+0xff>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108d18:	83 ec 0c             	sub    $0xc,%esp
f0108d1b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108d1e:	50                   	push   %eax
f0108d1f:	e8 8e f4 ff ff       	call   f01081b2 <allocate_frame>
f0108d24:	83 c4 10             	add    $0x10,%esp
f0108d27:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0108d2a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0108d2e:	75 3d                	jne    f0108d6d <createSharedObject+0xe8>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f0108d30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d33:	c1 e0 0c             	shl    $0xc,%eax
f0108d36:	89 c2                	mov    %eax,%edx
f0108d38:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d3b:	01 d0                	add    %edx,%eax
f0108d3d:	89 c1                	mov    %eax,%ecx
f0108d3f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d45:	8b 40 64             	mov    0x64(%eax),%eax
f0108d48:	6a 06                	push   $0x6
f0108d4a:	51                   	push   %ecx
f0108d4b:	52                   	push   %edx
f0108d4c:	50                   	push   %eax
f0108d4d:	e8 2d f9 ff ff       	call   f010867f <map_frame>
f0108d52:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0108d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d58:	8b 40 54             	mov    0x54(%eax),%eax
f0108d5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d5e:	c1 e2 02             	shl    $0x2,%edx
f0108d61:	01 c2                	add    %eax,%edx
f0108d63:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d66:	89 02                	mov    %eax,(%edx)
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0108d68:	ff 45 f4             	incl   -0xc(%ebp)
f0108d6b:	eb 17                	jmp    f0108d84 <createSharedObject+0xff>
			//cprintf("Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)virtual_address + (k * PAGE_SIZE)))]);
			//cprintf("Index1 : %d\n",PDX((uint32)((uint32)virtual_address + (k * PAGE_SIZE))));
		}
		else
		{
			panic("No Memory");
f0108d6d:	83 ec 04             	sub    $0x4,%esp
f0108d70:	68 28 5b 12 f0       	push   $0xf0125b28
f0108d75:	68 a8 00 00 00       	push   $0xa8
f0108d7a:	68 34 5b 12 f0       	push   $0xf0125b34
f0108d7f:	e8 b5 75 ff ff       	call   f0100339 <_panic>
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0108d84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d87:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108d8a:	72 8c                	jb     f0108d18 <createSharedObject+0x93>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108d8c:	83 ec 0c             	sub    $0xc,%esp
f0108d8f:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108d94:	e8 d5 6e 00 00       	call   f010fc6e <acquire_spinlock>
f0108d99:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108d9c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108da0:	75 17                	jne    f0108db9 <createSharedObject+0x134>
f0108da2:	83 ec 04             	sub    $0x4,%esp
f0108da5:	68 58 5b 12 f0       	push   $0xf0125b58
f0108daa:	68 ad 00 00 00       	push   $0xad
f0108daf:	68 34 5b 12 f0       	push   $0xf0125b34
f0108db4:	e8 80 75 ff ff       	call   f0100339 <_panic>
f0108db9:	8b 15 c4 2d 6c f0    	mov    0xf06c2dc4,%edx
f0108dbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc2:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108dc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc8:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108dcb:	85 c0                	test   %eax,%eax
f0108dcd:	74 0d                	je     f0108ddc <createSharedObject+0x157>
f0108dcf:	a1 c4 2d 6c f0       	mov    0xf06c2dc4,%eax
f0108dd4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108dd7:	89 50 58             	mov    %edx,0x58(%eax)
f0108dda:	eb 08                	jmp    f0108de4 <createSharedObject+0x15f>
f0108ddc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ddf:	a3 c0 2d 6c f0       	mov    %eax,0xf06c2dc0
f0108de4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de7:	a3 c4 2d 6c f0       	mov    %eax,0xf06c2dc4
f0108dec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108def:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108df6:	a1 cc 2d 6c f0       	mov    0xf06c2dcc,%eax
f0108dfb:	40                   	inc    %eax
f0108dfc:	a3 cc 2d 6c f0       	mov    %eax,0xf06c2dcc
	release_spinlock(&AllShares.shareslock);
f0108e01:	83 ec 0c             	sub    $0xc,%esp
f0108e04:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108e09:	e8 e7 6e 00 00       	call   f010fcf5 <release_spinlock>
f0108e0e:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f0108e11:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e14:	8b 00                	mov    (%eax),%eax
}
f0108e16:	c9                   	leave  
f0108e17:	c3                   	ret    

f0108e18 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108e18:	55                   	push   %ebp
f0108e19:	89 e5                	mov    %esp,%ebp
f0108e1b:	53                   	push   %ebx
f0108e1c:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108e1f:	e8 bc 2b 00 00       	call   f010b9e0 <get_cpu_proc>
f0108e24:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0108e27:	83 ec 08             	sub    $0x8,%esp
f0108e2a:	ff 75 0c             	pushl  0xc(%ebp)
f0108e2d:	ff 75 08             	pushl  0x8(%ebp)
f0108e30:	e8 aa fd ff ff       	call   f0108bdf <get_share>
f0108e35:	83 c4 10             	add    $0x10,%esp
f0108e38:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0108e3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108e3f:	75 0a                	jne    f0108e4b <getSharedObject+0x33>
f0108e41:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108e46:	e9 b7 00 00 00       	jmp    f0108f02 <getSharedObject+0xea>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0108e4b:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0108e52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e55:	8b 40 48             	mov    0x48(%eax),%eax
f0108e58:	89 c2                	mov    %eax,%edx
f0108e5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e5d:	01 d0                	add    %edx,%eax
f0108e5f:	48                   	dec    %eax
f0108e60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108e63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e66:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e6b:	f7 75 e8             	divl   -0x18(%ebp)
f0108e6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e71:	29 d0                	sub    %edx,%eax
f0108e73:	85 c0                	test   %eax,%eax
f0108e75:	79 05                	jns    f0108e7c <getSharedObject+0x64>
f0108e77:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108e7c:	c1 f8 0c             	sar    $0xc,%eax
f0108e7f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f0108e82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108e89:	eb 44                	jmp    f0108ecf <getSharedObject+0xb7>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f0108e8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e8e:	8a 40 50             	mov    0x50(%eax),%al
f0108e91:	0f b6 c0             	movzbl %al,%eax
f0108e94:	01 c0                	add    %eax,%eax
f0108e96:	83 c8 04             	or     $0x4,%eax
f0108e99:	89 c3                	mov    %eax,%ebx
f0108e9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e9e:	c1 e0 0c             	shl    $0xc,%eax
f0108ea1:	89 c2                	mov    %eax,%edx
f0108ea3:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ea6:	01 d0                	add    %edx,%eax
f0108ea8:	89 c1                	mov    %eax,%ecx
f0108eaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ead:	8b 40 54             	mov    0x54(%eax),%eax
f0108eb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108eb3:	c1 e2 02             	shl    $0x2,%edx
f0108eb6:	01 d0                	add    %edx,%eax
f0108eb8:	8b 10                	mov    (%eax),%edx
f0108eba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ebd:	8b 40 64             	mov    0x64(%eax),%eax
f0108ec0:	53                   	push   %ebx
f0108ec1:	51                   	push   %ecx
f0108ec2:	52                   	push   %edx
f0108ec3:	50                   	push   %eax
f0108ec4:	e8 b6 f7 ff ff       	call   f010867f <map_frame>
f0108ec9:	83 c4 10             	add    $0x10,%esp

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ecc:	ff 45 f4             	incl   -0xc(%ebp)
f0108ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ed2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0108ed5:	72 b4                	jb     f0108e8b <getSharedObject+0x73>
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
		//isTableExist[PDX((uint32)((uint32)virtual_address + (i * PAGE_SIZE)))][myenv->env_id]++;
		//cprintf("Page Index2 : %d\n",isTableExist[PDX((uint32)((uint32)virtual_address + (i * PAGE_SIZE)))]);
		//cprintf("Index2 : %d\n",PDX((uint32)((uint32)virtual_address + (i * PAGE_SIZE))));
	}
	shared_obj->references++;
f0108ed7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eda:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108edd:	8d 50 01             	lea    0x1(%eax),%edx
f0108ee0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee3:	89 50 4c             	mov    %edx,0x4c(%eax)
	cprintf("References : %d\n",shared_obj->references);
f0108ee6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee9:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108eec:	83 ec 08             	sub    $0x8,%esp
f0108eef:	50                   	push   %eax
f0108ef0:	68 7b 5b 12 f0       	push   $0xf0125b7b
f0108ef5:	e8 91 80 ff ff       	call   f0100f8b <cprintf>
f0108efa:	83 c4 10             	add    $0x10,%esp
	return shared_obj->ID;
f0108efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f00:	8b 00                	mov    (%eax),%eax
}
f0108f02:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108f05:	c9                   	leave  
f0108f06:	c3                   	ret    

f0108f07 <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108f07:	55                   	push   %ebp
f0108f08:	89 e5                	mov    %esp,%ebp
f0108f0a:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0108f0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f11:	0f 84 ca 00 00 00    	je     f0108fe1 <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f0108f17:	83 ec 0c             	sub    $0xc,%esp
f0108f1a:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108f1f:	e8 4a 6d 00 00       	call   f010fc6e <acquire_spinlock>
f0108f24:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f0108f27:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f2b:	75 17                	jne    f0108f44 <free_share+0x3d>
f0108f2d:	83 ec 04             	sub    $0x4,%esp
f0108f30:	68 8c 5b 12 f0       	push   $0xf0125b8c
f0108f35:	68 de 00 00 00       	push   $0xde
f0108f3a:	68 34 5b 12 f0       	push   $0xf0125b34
f0108f3f:	e8 f5 73 ff ff       	call   f0100339 <_panic>
f0108f44:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f47:	8b 40 58             	mov    0x58(%eax),%eax
f0108f4a:	85 c0                	test   %eax,%eax
f0108f4c:	74 11                	je     f0108f5f <free_share+0x58>
f0108f4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f51:	8b 40 58             	mov    0x58(%eax),%eax
f0108f54:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f57:	8b 52 5c             	mov    0x5c(%edx),%edx
f0108f5a:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108f5d:	eb 0b                	jmp    f0108f6a <free_share+0x63>
f0108f5f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f62:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108f65:	a3 c4 2d 6c f0       	mov    %eax,0xf06c2dc4
f0108f6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f6d:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108f70:	85 c0                	test   %eax,%eax
f0108f72:	74 11                	je     f0108f85 <free_share+0x7e>
f0108f74:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f77:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f7d:	8b 52 58             	mov    0x58(%edx),%edx
f0108f80:	89 50 58             	mov    %edx,0x58(%eax)
f0108f83:	eb 0b                	jmp    f0108f90 <free_share+0x89>
f0108f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f88:	8b 40 58             	mov    0x58(%eax),%eax
f0108f8b:	a3 c0 2d 6c f0       	mov    %eax,0xf06c2dc0
f0108f90:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f93:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108f9a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f9d:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f0108fa4:	a1 cc 2d 6c f0       	mov    0xf06c2dcc,%eax
f0108fa9:	48                   	dec    %eax
f0108faa:	a3 cc 2d 6c f0       	mov    %eax,0xf06c2dcc
    release_spinlock(&AllShares.shareslock);
f0108faf:	83 ec 0c             	sub    $0xc,%esp
f0108fb2:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108fb7:	e8 39 6d 00 00       	call   f010fcf5 <release_spinlock>
f0108fbc:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f0108fbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fc2:	8b 40 54             	mov    0x54(%eax),%eax
f0108fc5:	83 ec 0c             	sub    $0xc,%esp
f0108fc8:	50                   	push   %eax
f0108fc9:	e8 bc 07 00 00       	call   f010978a <kfree>
f0108fce:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f0108fd1:	83 ec 0c             	sub    $0xc,%esp
f0108fd4:	ff 75 08             	pushl  0x8(%ebp)
f0108fd7:	e8 ae 07 00 00       	call   f010978a <kfree>
f0108fdc:	83 c4 10             	add    $0x10,%esp
f0108fdf:	eb 01                	jmp    f0108fe2 <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0108fe1:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f0108fe2:	c9                   	leave  
f0108fe3:	c3                   	ret    

f0108fe4 <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f0108fe4:	55                   	push   %ebp
f0108fe5:	89 e5                	mov    %esp,%ebp
f0108fe7:	83 ec 18             	sub    $0x18,%esp
    struct Share* founded = NULL;
f0108fea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0108ff1:	83 ec 0c             	sub    $0xc,%esp
f0108ff4:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0108ff9:	e8 70 6c 00 00       	call   f010fc6e <acquire_spinlock>
f0108ffe:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109001:	a1 c0 2d 6c f0       	mov    0xf06c2dc0,%eax
f0109006:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109009:	eb 27                	jmp    f0109032 <get_Share_id+0x4e>
            if(founded->ID == sharedObjectID)
f010900b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010900e:	8b 00                	mov    (%eax),%eax
f0109010:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109013:	75 15                	jne    f010902a <get_Share_id+0x46>
            {
                release_spinlock(&AllShares.shareslock);
f0109015:	83 ec 0c             	sub    $0xc,%esp
f0109018:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f010901d:	e8 d3 6c 00 00       	call   f010fcf5 <release_spinlock>
f0109022:	83 c4 10             	add    $0x10,%esp
                return founded;
f0109025:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109028:	eb 44                	jmp    f010906e <get_Share_id+0x8a>
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f010902a:	a1 c8 2d 6c f0       	mov    0xf06c2dc8,%eax
f010902f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109032:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109036:	74 08                	je     f0109040 <get_Share_id+0x5c>
f0109038:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010903b:	8b 40 58             	mov    0x58(%eax),%eax
f010903e:	eb 05                	jmp    f0109045 <get_Share_id+0x61>
f0109040:	b8 00 00 00 00       	mov    $0x0,%eax
f0109045:	a3 c8 2d 6c f0       	mov    %eax,0xf06c2dc8
f010904a:	a1 c8 2d 6c f0       	mov    0xf06c2dc8,%eax
f010904f:	85 c0                	test   %eax,%eax
f0109051:	75 b8                	jne    f010900b <get_Share_id+0x27>
f0109053:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109057:	75 b2                	jne    f010900b <get_Share_id+0x27>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f0109059:	83 ec 0c             	sub    $0xc,%esp
f010905c:	68 d0 2d 6c f0       	push   $0xf06c2dd0
f0109061:	e8 8f 6c 00 00       	call   f010fcf5 <release_spinlock>
f0109066:	83 c4 10             	add    $0x10,%esp
        return NULL;
f0109069:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010906e:	c9                   	leave  
f010906f:	c3                   	ret    

f0109070 <freeSharedObject>:
bool entered = 0;
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0109070:	55                   	push   %ebp
f0109071:	89 e5                	mov    %esp,%ebp
f0109073:	83 ec 38             	sub    $0x38,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
    //panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
		struct Env* myenv = get_cpu_proc();
f0109076:	e8 65 29 00 00       	call   f010b9e0 <get_cpu_proc>
f010907b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f010907e:	83 ec 08             	sub    $0x8,%esp
f0109081:	ff 75 0c             	pushl  0xc(%ebp)
f0109084:	ff 75 08             	pushl  0x8(%ebp)
f0109087:	e8 58 ff ff ff       	call   f0108fe4 <get_Share_id>
f010908c:	83 c4 10             	add    $0x10,%esp
f010908f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        cprintf("Share : %x \n",ptr_share);
f0109092:	83 ec 08             	sub    $0x8,%esp
f0109095:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109098:	68 aa 5b 12 f0       	push   $0xf0125baa
f010909d:	e8 e9 7e ff ff       	call   f0100f8b <cprintf>
f01090a2:	83 c4 10             	add    $0x10,%esp
        if(ptr_share == NULL) return -1;
f01090a5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01090a9:	75 0a                	jne    f01090b5 <freeSharedObject+0x45>
f01090ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01090b0:	e9 b4 01 00 00       	jmp    f0109269 <freeSharedObject+0x1f9>
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f01090b5:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01090bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01090bf:	8b 40 48             	mov    0x48(%eax),%eax
f01090c2:	89 c2                	mov    %eax,%edx
f01090c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01090c7:	01 d0                	add    %edx,%eax
f01090c9:	48                   	dec    %eax
f01090ca:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01090cd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01090d0:	ba 00 00 00 00       	mov    $0x0,%edx
f01090d5:	f7 75 e0             	divl   -0x20(%ebp)
f01090d8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01090db:	29 d0                	sub    %edx,%eax
f01090dd:	85 c0                	test   %eax,%eax
f01090df:	79 05                	jns    f01090e6 <freeSharedObject+0x76>
f01090e1:	05 ff 0f 00 00       	add    $0xfff,%eax
f01090e6:	c1 f8 0c             	sar    $0xc,%eax
f01090e9:	89 45 d8             	mov    %eax,-0x28(%ebp)
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01090ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01090f3:	e9 06 01 00 00       	jmp    f01091fe <freeSharedObject+0x18e>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
f01090f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090fb:	c1 e0 0c             	shl    $0xc,%eax
f01090fe:	89 c2                	mov    %eax,%edx
f0109100:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109103:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109106:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109109:	8b 40 64             	mov    0x64(%eax),%eax
f010910c:	83 ec 04             	sub    $0x4,%esp
f010910f:	8d 55 cc             	lea    -0x34(%ebp),%edx
f0109112:	52                   	push   %edx
f0109113:	51                   	push   %ecx
f0109114:	50                   	push   %eax
f0109115:	e8 d5 f2 ff ff       	call   f01083ef <get_page_table>
f010911a:	83 c4 10             	add    $0x10,%esp
f010911d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
f0109120:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109123:	c1 e0 0c             	shl    $0xc,%eax
f0109126:	89 c2                	mov    %eax,%edx
f0109128:	8b 45 0c             	mov    0xc(%ebp),%eax
f010912b:	01 c2                	add    %eax,%edx
f010912d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109130:	8b 40 64             	mov    0x64(%eax),%eax
f0109133:	83 ec 08             	sub    $0x8,%esp
f0109136:	52                   	push   %edx
f0109137:	50                   	push   %eax
f0109138:	e8 a2 f6 ff ff       	call   f01087df <unmap_frame>
f010913d:	83 c4 10             	add    $0x10,%esp
				cprintf("Enter free page table\n");
				kfree((void*)ptr_page_table);
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
			}
			}*/
			bool isFree = 1;
f0109140:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
			//ptr_page_table[PTX(virtual_address)] = pte_available_bits;
			for(int i=0;i<1024;i++)
f0109147:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010914e:	eb 22                	jmp    f0109172 <freeSharedObject+0x102>
			{

				if((EXTRACT_ADDRESS(ptr_page_table[i])) != 0){
f0109150:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109153:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109156:	c1 e2 02             	shl    $0x2,%edx
f0109159:	01 d0                	add    %edx,%eax
f010915b:	8b 00                	mov    (%eax),%eax
f010915d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109162:	85 c0                	test   %eax,%eax
f0109164:	74 09                	je     f010916f <freeSharedObject+0xff>
					isFree = 0;
f0109166:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					break;
f010916d:	eb 0c                	jmp    f010917b <freeSharedObject+0x10b>
			}
			}*/
			bool isFree = 1;
			//uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
			//ptr_page_table[PTX(virtual_address)] = pte_available_bits;
			for(int i=0;i<1024;i++)
f010916f:	ff 45 ec             	incl   -0x14(%ebp)
f0109172:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0109179:	7e d5                	jle    f0109150 <freeSharedObject+0xe0>
				if((EXTRACT_ADDRESS(ptr_page_table[i])) != 0){
					isFree = 0;
					break;
				}
			}
			if(!entered || myenv->env_id==2048 || myenv->env_id==2051 || myenv->env_id==2052){
f010917b:	a1 70 a3 69 f0       	mov    0xf069a370,%eax
f0109180:	85 c0                	test   %eax,%eax
f0109182:	74 27                	je     f01091ab <freeSharedObject+0x13b>
f0109184:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109187:	8b 40 10             	mov    0x10(%eax),%eax
f010918a:	3d 00 08 00 00       	cmp    $0x800,%eax
f010918f:	74 1a                	je     f01091ab <freeSharedObject+0x13b>
f0109191:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109194:	8b 40 10             	mov    0x10(%eax),%eax
f0109197:	3d 03 08 00 00       	cmp    $0x803,%eax
f010919c:	74 0d                	je     f01091ab <freeSharedObject+0x13b>
f010919e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01091a1:	8b 40 10             	mov    0x10(%eax),%eax
f01091a4:	3d 04 08 00 00       	cmp    $0x804,%eax
f01091a9:	75 50                	jne    f01091fb <freeSharedObject+0x18b>
				entered = 1;
f01091ab:	c7 05 70 a3 69 f0 01 	movl   $0x1,0xf069a370
f01091b2:	00 00 00 
			if(isFree)
f01091b5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01091b9:	74 40                	je     f01091fb <freeSharedObject+0x18b>
			{
				cprintf("Enter G\n");
f01091bb:	83 ec 0c             	sub    $0xc,%esp
f01091be:	68 b7 5b 12 f0       	push   $0xf0125bb7
f01091c3:	e8 c3 7d ff ff       	call   f0100f8b <cprintf>
f01091c8:	83 c4 10             	add    $0x10,%esp
				kfree((void*)ptr_page_table);
f01091cb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01091ce:	83 ec 0c             	sub    $0xc,%esp
f01091d1:	50                   	push   %eax
f01091d2:	e8 b3 05 00 00       	call   f010978a <kfree>
f01091d7:	83 c4 10             	add    $0x10,%esp
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
f01091da:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01091dd:	8b 40 64             	mov    0x64(%eax),%eax
f01091e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01091e3:	c1 e2 0c             	shl    $0xc,%edx
f01091e6:	89 d1                	mov    %edx,%ecx
f01091e8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01091eb:	01 ca                	add    %ecx,%edx
f01091ed:	c1 ea 16             	shr    $0x16,%edx
f01091f0:	c1 e2 02             	shl    $0x2,%edx
f01091f3:	01 d0                	add    %edx,%eax
f01091f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        cprintf("Share : %x \n",ptr_share);
        if(ptr_share == NULL) return -1;
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01091fb:	ff 45 f4             	incl   -0xc(%ebp)
f01091fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109201:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0109204:	0f 82 ee fe ff ff    	jb     f01090f8 <freeSharedObject+0x88>
			}
		}



        ptr_share->references--;
f010920a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010920d:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109210:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109213:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109216:	89 50 4c             	mov    %edx,0x4c(%eax)

        if(ptr_share->references < 1){
f0109219:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010921c:	8b 40 4c             	mov    0x4c(%eax),%eax
f010921f:	85 c0                	test   %eax,%eax
f0109221:	75 1e                	jne    f0109241 <freeSharedObject+0x1d1>
        	cprintf("Enter References\n");
f0109223:	83 ec 0c             	sub    $0xc,%esp
f0109226:	68 c0 5b 12 f0       	push   $0xf0125bc0
f010922b:	e8 5b 7d ff ff       	call   f0100f8b <cprintf>
f0109230:	83 c4 10             	add    $0x10,%esp
            free_share(ptr_share);
f0109233:	83 ec 0c             	sub    $0xc,%esp
f0109236:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109239:	e8 c9 fc ff ff       	call   f0108f07 <free_share>
f010923e:	83 c4 10             	add    $0x10,%esp
        }
        cprintf("References2 : %d\n",ptr_share->references);
f0109241:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109244:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109247:	83 ec 08             	sub    $0x8,%esp
f010924a:	50                   	push   %eax
f010924b:	68 d2 5b 12 f0       	push   $0xf0125bd2
f0109250:	e8 36 7d ff ff       	call   f0100f8b <cprintf>
f0109255:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109258:	0f 20 d8             	mov    %cr3,%eax
f010925b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010925e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109261:	0f 22 d8             	mov    %eax,%cr3
        tlbflush();
        return 0;
f0109264:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109269:	c9                   	leave  
f010926a:	c3                   	ret    

f010926b <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010926b:	55                   	push   %ebp
f010926c:	89 e5                	mov    %esp,%ebp
f010926e:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f0109273:	83 f8 01             	cmp    $0x1,%eax
f0109276:	75 04                	jne    f010927c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0109278:	b0 01                	mov    $0x1,%al
f010927a:	eb 02                	jmp    f010927e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010927c:	b0 00                	mov    $0x0,%al
f010927e:	5d                   	pop    %ebp
f010927f:	c3                   	ret    

f0109280 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0109280:	55                   	push   %ebp
f0109281:	89 e5                	mov    %esp,%ebp
f0109283:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f0109288:	83 f8 02             	cmp    $0x2,%eax
f010928b:	75 04                	jne    f0109291 <isKHeapPlacementStrategyBESTFIT+0x11>
f010928d:	b0 01                	mov    $0x1,%al
f010928f:	eb 02                	jmp    f0109293 <isKHeapPlacementStrategyBESTFIT+0x13>
f0109291:	b0 00                	mov    $0x0,%al
f0109293:	5d                   	pop    %ebp
f0109294:	c3                   	ret    

f0109295 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0109295:	55                   	push   %ebp
f0109296:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0109298:	8b 45 08             	mov    0x8(%ebp),%eax
f010929b:	8b 15 60 33 ac f0    	mov    0xf0ac3360,%edx
f01092a1:	29 d0                	sub    %edx,%eax
f01092a3:	c1 f8 03             	sar    $0x3,%eax
f01092a6:	89 c2                	mov    %eax,%edx
f01092a8:	89 d0                	mov    %edx,%eax
f01092aa:	c1 e0 02             	shl    $0x2,%eax
f01092ad:	01 d0                	add    %edx,%eax
f01092af:	c1 e0 02             	shl    $0x2,%eax
f01092b2:	01 d0                	add    %edx,%eax
f01092b4:	c1 e0 02             	shl    $0x2,%eax
f01092b7:	01 d0                	add    %edx,%eax
f01092b9:	89 c1                	mov    %eax,%ecx
f01092bb:	c1 e1 08             	shl    $0x8,%ecx
f01092be:	01 c8                	add    %ecx,%eax
f01092c0:	89 c1                	mov    %eax,%ecx
f01092c2:	c1 e1 10             	shl    $0x10,%ecx
f01092c5:	01 c8                	add    %ecx,%eax
f01092c7:	01 c0                	add    %eax,%eax
f01092c9:	01 d0                	add    %edx,%eax
}
f01092cb:	5d                   	pop    %ebp
f01092cc:	c3                   	ret    

f01092cd <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f01092cd:	55                   	push   %ebp
f01092ce:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01092d0:	ff 75 08             	pushl  0x8(%ebp)
f01092d3:	e8 bd ff ff ff       	call   f0109295 <to_frame_number>
f01092d8:	83 c4 04             	add    $0x4,%esp
f01092db:	c1 e0 0c             	shl    $0xc,%eax
}
f01092de:	c9                   	leave  
f01092df:	c3                   	ret    

f01092e0 <initialize_kheap_dynamic_allocator>:
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC



int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f01092e0:	55                   	push   %ebp
f01092e1:	89 e5                	mov    %esp,%ebp
f01092e3:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f01092e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01092e9:	a3 c8 35 ec f0       	mov    %eax,0xf0ec35c8
	hard_limit = daLimit;
f01092ee:	8b 45 10             	mov    0x10(%ebp),%eax
f01092f1:	a3 f4 33 ac f0       	mov    %eax,0xf0ac33f4
	brk = daStart + initSizeToAllocate;
f01092f6:	8b 55 08             	mov    0x8(%ebp),%edx
f01092f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092fc:	01 d0                	add    %edx,%eax
f01092fe:	a3 c0 35 ec f0       	mov    %eax,0xf0ec35c0

	if(brk > daLimit) panic("exceeds Limit");
f0109303:	a1 c0 35 ec f0       	mov    0xf0ec35c0,%eax
f0109308:	3b 45 10             	cmp    0x10(%ebp),%eax
f010930b:	76 14                	jbe    f0109321 <initialize_kheap_dynamic_allocator+0x41>
f010930d:	83 ec 04             	sub    $0x4,%esp
f0109310:	68 e4 5b 12 f0       	push   $0xf0125be4
f0109315:	6a 1a                	push   $0x1a
f0109317:	68 f2 5b 12 f0       	push   $0xf0125bf2
f010931c:	e8 18 70 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0109321:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f0109328:	8b 45 10             	mov    0x10(%ebp),%eax
f010932b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f010932e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109331:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f0109334:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109337:	c1 e8 0c             	shr    $0xc,%eax
f010933a:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f010933d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109344:	e9 8a 00 00 00       	jmp    f01093d3 <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0109349:	83 ec 0c             	sub    $0xc,%esp
f010934c:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010934f:	50                   	push   %eax
f0109350:	e8 5d ee ff ff       	call   f01081b2 <allocate_frame>
f0109355:	83 c4 10             	add    $0x10,%esp
f0109358:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f010935b:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010935f:	74 5e                	je     f01093bf <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f0109361:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109364:	c1 e0 0c             	shl    $0xc,%eax
f0109367:	89 c2                	mov    %eax,%edx
f0109369:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010936c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010936f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0109372:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109377:	6a 02                	push   $0x2
f0109379:	51                   	push   %ecx
f010937a:	52                   	push   %edx
f010937b:	50                   	push   %eax
f010937c:	e8 fe f2 ff ff       	call   f010867f <map_frame>
f0109381:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0109384:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109387:	c1 e0 0c             	shl    $0xc,%eax
f010938a:	89 c2                	mov    %eax,%edx
f010938c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010938f:	01 d0                	add    %edx,%eax
f0109391:	83 ec 0c             	sub    $0xc,%esp
f0109394:	50                   	push   %eax
f0109395:	e8 d6 04 00 00       	call   f0109870 <kheap_physical_address>
f010939a:	83 c4 10             	add    $0x10,%esp
f010939d:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f01093a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093a3:	c1 e8 0c             	shr    $0xc,%eax
f01093a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01093a9:	c1 e2 0c             	shl    $0xc,%edx
f01093ac:	89 d1                	mov    %edx,%ecx
f01093ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01093b1:	01 ca                	add    %ecx,%edx
f01093b3:	89 14 85 20 35 ac f0 	mov    %edx,-0xf53cae0(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f01093ba:	ff 45 f4             	incl   -0xc(%ebp)
f01093bd:	eb 14                	jmp    f01093d3 <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f01093bf:	83 ec 04             	sub    $0x4,%esp
f01093c2:	68 03 5c 12 f0       	push   $0xf0125c03
f01093c7:	6a 2f                	push   $0x2f
f01093c9:	68 f2 5b 12 f0       	push   $0xf0125bf2
f01093ce:	e8 66 6f ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f01093d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093d6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01093d9:	0f 82 6a ff ff ff    	jb     f0109349 <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f01093df:	83 ec 08             	sub    $0x8,%esp
f01093e2:	ff 75 0c             	pushl  0xc(%ebp)
f01093e5:	ff 75 08             	pushl  0x8(%ebp)
f01093e8:	e8 fe 73 01 00       	call   f01207eb <initialize_dynamic_allocator>
f01093ed:	83 c4 10             	add    $0x10,%esp

	return 0;
f01093f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01093f5:	c9                   	leave  
f01093f6:	c3                   	ret    

f01093f7 <sbrk>:

void* sbrk(int numOfPages)
{
f01093f7:	55                   	push   %ebp
f01093f8:	89 e5                	mov    %esp,%ebp
f01093fa:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f01093fd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109401:	0f 8e d6 00 00 00    	jle    f01094dd <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f0109407:	8b 45 08             	mov    0x8(%ebp),%eax
f010940a:	c1 e0 0c             	shl    $0xc,%eax
f010940d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f0109410:	a1 c0 35 ec f0       	mov    0xf0ec35c0,%eax
f0109415:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f0109418:	8b 15 c0 35 ec f0    	mov    0xf0ec35c0,%edx
f010941e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109421:	01 c2                	add    %eax,%edx
f0109423:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f0109428:	39 c2                	cmp    %eax,%edx
f010942a:	76 0a                	jbe    f0109436 <sbrk+0x3f>
f010942c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109431:	e9 b9 00 00 00       	jmp    f01094ef <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f0109436:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010943d:	eb 7d                	jmp    f01094bc <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f010943f:	83 ec 0c             	sub    $0xc,%esp
f0109442:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0109445:	50                   	push   %eax
f0109446:	e8 67 ed ff ff       	call   f01081b2 <allocate_frame>
f010944b:	83 c4 10             	add    $0x10,%esp
f010944e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f0109451:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0109455:	74 5e                	je     f01094b5 <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f0109457:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010945a:	c1 e0 0c             	shl    $0xc,%eax
f010945d:	89 c2                	mov    %eax,%edx
f010945f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109462:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109465:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109468:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010946d:	6a 02                	push   $0x2
f010946f:	51                   	push   %ecx
f0109470:	52                   	push   %edx
f0109471:	50                   	push   %eax
f0109472:	e8 08 f2 ff ff       	call   f010867f <map_frame>
f0109477:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f010947a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010947d:	c1 e0 0c             	shl    $0xc,%eax
f0109480:	89 c2                	mov    %eax,%edx
f0109482:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109485:	01 d0                	add    %edx,%eax
f0109487:	83 ec 0c             	sub    $0xc,%esp
f010948a:	50                   	push   %eax
f010948b:	e8 e0 03 00 00       	call   f0109870 <kheap_physical_address>
f0109490:	83 c4 10             	add    $0x10,%esp
f0109493:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f0109496:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109499:	c1 e8 0c             	shr    $0xc,%eax
f010949c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010949f:	c1 e2 0c             	shl    $0xc,%edx
f01094a2:	89 d1                	mov    %edx,%ecx
f01094a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01094a7:	01 ca                	add    %ecx,%edx
f01094a9:	89 14 85 20 35 ac f0 	mov    %edx,-0xf53cae0(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f01094b0:	ff 45 f4             	incl   -0xc(%ebp)
f01094b3:	eb 07                	jmp    f01094bc <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f01094b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01094ba:	eb 33                	jmp    f01094ef <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f01094bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094bf:	3b 45 08             	cmp    0x8(%ebp),%eax
f01094c2:	0f 8c 77 ff ff ff    	jl     f010943f <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f01094c8:	8b 15 c0 35 ec f0    	mov    0xf0ec35c0,%edx
f01094ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01094d1:	01 d0                	add    %edx,%eax
f01094d3:	a3 c0 35 ec f0       	mov    %eax,0xf0ec35c0
		return (void *)prev_brk;
f01094d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094db:	eb 12                	jmp    f01094ef <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f01094dd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01094e1:	75 07                	jne    f01094ea <sbrk+0xf3>
	{
		return (void *) brk;
f01094e3:	a1 c0 35 ec f0       	mov    0xf0ec35c0,%eax
f01094e8:	eb 05                	jmp    f01094ef <sbrk+0xf8>
	}

	return (void *)-1;
f01094ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f01094ef:	c9                   	leave  
f01094f0:	c3                   	ret    

f01094f1 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f01094f1:	55                   	push   %ebp
f01094f2:	89 e5                	mov    %esp,%ebp
f01094f4:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f01094f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01094fe:	83 ec 04             	sub    $0x4,%esp
f0109501:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109504:	50                   	push   %eax
f0109505:	ff 75 0c             	pushl  0xc(%ebp)
f0109508:	ff 75 08             	pushl  0x8(%ebp)
f010950b:	e8 59 f2 ff ff       	call   f0108769 <get_frame_info>
f0109510:	83 c4 10             	add    $0x10,%esp
f0109513:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f0109516:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010951a:	75 07                	jne    f0109523 <isPageAllocated+0x32>
f010951c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109521:	eb 05                	jmp    f0109528 <isPageAllocated+0x37>
	return 1;
f0109523:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0109528:	c9                   	leave  
f0109529:	c3                   	ret    

f010952a <kmalloc>:

void *kmalloc(unsigned int size)
{
f010952a:	55                   	push   %ebp
f010952b:	89 e5                	mov    %esp,%ebp
f010952d:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0109530:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0109537:	8b 55 08             	mov    0x8(%ebp),%edx
f010953a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010953d:	01 d0                	add    %edx,%eax
f010953f:	48                   	dec    %eax
f0109540:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109543:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109546:	ba 00 00 00 00       	mov    $0x0,%edx
f010954b:	f7 75 d8             	divl   -0x28(%ebp)
f010954e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109551:	29 d0                	sub    %edx,%eax
f0109553:	c1 e8 0c             	shr    $0xc,%eax
f0109556:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f0109559:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0109560:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f0109565:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109568:	29 c2                	sub    %eax,%edx
f010956a:	89 d0                	mov    %edx,%eax
f010956c:	48                   	dec    %eax
f010956d:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0109570:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109573:	ba 00 00 00 00       	mov    $0x0,%edx
f0109578:	f7 75 cc             	divl   -0x34(%ebp)
f010957b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010957e:	29 d0                	sub    %edx,%eax
f0109580:	c1 e8 0c             	shr    $0xc,%eax
f0109583:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f0109586:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f010958d:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109594:	77 42                	ja     f01095d8 <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f0109596:	e8 d0 fc ff ff       	call   f010926b <isKHeapPlacementStrategyFIRSTFIT>
f010959b:	84 c0                	test   %al,%al
f010959d:	74 16                	je     f01095b5 <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f010959f:	83 ec 0c             	sub    $0xc,%esp
f01095a2:	ff 75 08             	pushl  0x8(%ebp)
f01095a5:	e8 5d 74 01 00       	call   f0120a07 <alloc_block_FF>
f01095aa:	83 c4 10             	add    $0x10,%esp
f01095ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01095b0:	e9 d0 01 00 00       	jmp    f0109785 <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f01095b5:	e8 c6 fc ff ff       	call   f0109280 <isKHeapPlacementStrategyBESTFIT>
f01095ba:	84 c0                	test   %al,%al
f01095bc:	0f 84 c3 01 00 00    	je     f0109785 <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f01095c2:	83 ec 0c             	sub    $0xc,%esp
f01095c5:	ff 75 08             	pushl  0x8(%ebp)
f01095c8:	e8 f6 78 01 00       	call   f0120ec3 <alloc_block_BF>
f01095cd:	83 c4 10             	add    $0x10,%esp
f01095d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01095d3:	e9 ad 01 00 00       	jmp    f0109785 <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f01095d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01095db:	48                   	dec    %eax
f01095dc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01095df:	0f 86 99 01 00 00    	jbe    f010977e <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f01095e5:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f01095ea:	05 00 10 00 00       	add    $0x1000,%eax
f01095ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01095f2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01095f9:	e9 86 00 00 00       	jmp    f0109684 <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01095fe:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109603:	83 ec 08             	sub    $0x8,%esp
f0109606:	ff 75 f0             	pushl  -0x10(%ebp)
f0109609:	50                   	push   %eax
f010960a:	e8 e2 fe ff ff       	call   f01094f1 <isPageAllocated>
f010960f:	83 c4 10             	add    $0x10,%esp
f0109612:	85 c0                	test   %eax,%eax
f0109614:	75 61                	jne    f0109677 <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f0109616:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109619:	05 00 10 00 00       	add    $0x1000,%eax
f010961e:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f0109621:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f0109628:	eb 3d                	jmp    f0109667 <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f010962a:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f0109631:	76 0a                	jbe    f010963d <kmalloc+0x113>
f0109633:	b8 00 00 00 00       	mov    $0x0,%eax
f0109638:	e9 4b 01 00 00       	jmp    f0109788 <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f010963d:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109642:	83 ec 08             	sub    $0x8,%esp
f0109645:	ff 75 e8             	pushl  -0x18(%ebp)
f0109648:	50                   	push   %eax
f0109649:	e8 a3 fe ff ff       	call   f01094f1 <isPageAllocated>
f010964e:	83 c4 10             	add    $0x10,%esp
f0109651:	85 c0                	test   %eax,%eax
f0109653:	74 08                	je     f010965d <kmalloc+0x133>
					{

						i = j;
f0109655:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109658:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f010965b:	eb 1a                	jmp    f0109677 <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f010965d:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0109664:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f0109667:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010966a:	48                   	dec    %eax
f010966b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010966e:	77 ba                	ja     f010962a <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0109670:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f0109677:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010967b:	75 16                	jne    f0109693 <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f010967d:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109684:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010968b:	0f 86 6d ff ff ff    	jbe    f01095fe <kmalloc+0xd4>
f0109691:	eb 01                	jmp    f0109694 <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109693:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0109694:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109698:	75 0a                	jne    f01096a4 <kmalloc+0x17a>
f010969a:	b8 00 00 00 00       	mov    $0x0,%eax
f010969f:	e9 e4 00 00 00       	jmp    f0109788 <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f01096a4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01096ab:	eb 57                	jmp    f0109704 <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f01096ad:	83 ec 0c             	sub    $0xc,%esp
f01096b0:	8d 45 b8             	lea    -0x48(%ebp),%eax
f01096b3:	50                   	push   %eax
f01096b4:	e8 f9 ea ff ff       	call   f01081b2 <allocate_frame>
f01096b9:	83 c4 10             	add    $0x10,%esp
f01096bc:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f01096bf:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f01096c3:	74 28                	je     f01096ed <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
f01096c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01096c8:	c1 e0 0c             	shl    $0xc,%eax
f01096cb:	89 c2                	mov    %eax,%edx
f01096cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096d0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01096d3:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01096d6:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01096db:	6a 02                	push   $0x2
f01096dd:	51                   	push   %ecx
f01096de:	52                   	push   %edx
f01096df:	50                   	push   %eax
f01096e0:	e8 9a ef ff ff       	call   f010867f <map_frame>
f01096e5:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01096e8:	ff 45 e0             	incl   -0x20(%ebp)
f01096eb:	eb 17                	jmp    f0109704 <kmalloc+0x1da>
				//cprintf("kmalloc Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)i + (k * PAGE_SIZE)))]);
				//cprintf("kmalloc Index1 : %d\n",PDX((uint32)((uint32)i + (k * PAGE_SIZE))));
			}
			else
			{
				panic("No Memory");
f01096ed:	83 ec 04             	sub    $0x4,%esp
f01096f0:	68 03 5c 12 f0       	push   $0xf0125c03
f01096f5:	68 b8 00 00 00       	push   $0xb8
f01096fa:	68 f2 5b 12 f0       	push   $0xf0125bf2
f01096ff:	e8 35 6c ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f0109704:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109707:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010970a:	72 a1                	jb     f01096ad <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f010970c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010970f:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f0109712:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f0109717:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010971a:	29 c2                	sub    %eax,%edx
f010971c:	89 d0                	mov    %edx,%eax
f010971e:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109723:	c1 e8 0c             	shr    $0xc,%eax
f0109726:	89 c2                	mov    %eax,%edx
f0109728:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010972b:	89 04 95 00 2f 6c f0 	mov    %eax,-0xf93d100(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f0109732:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109739:	eb 39                	jmp    f0109774 <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f010973b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010973e:	c1 e0 0c             	shl    $0xc,%eax
f0109741:	89 c2                	mov    %eax,%edx
f0109743:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109746:	01 d0                	add    %edx,%eax
f0109748:	83 ec 0c             	sub    $0xc,%esp
f010974b:	50                   	push   %eax
f010974c:	e8 1f 01 00 00       	call   f0109870 <kheap_physical_address>
f0109751:	83 c4 10             	add    $0x10,%esp
f0109754:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f0109757:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010975a:	c1 e8 0c             	shr    $0xc,%eax
f010975d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109760:	c1 e2 0c             	shl    $0xc,%edx
f0109763:	89 d1                	mov    %edx,%ecx
f0109765:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109768:	01 ca                	add    %ecx,%edx
f010976a:	89 14 85 20 35 ac f0 	mov    %edx,-0xf53cae0(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109771:	ff 45 dc             	incl   -0x24(%ebp)
f0109774:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109777:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010977a:	72 bf                	jb     f010973b <kmalloc+0x211>
f010977c:	eb 07                	jmp    f0109785 <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f010977e:	b8 00 00 00 00       	mov    $0x0,%eax
f0109783:	eb 03                	jmp    f0109788 <kmalloc+0x25e>
	}
	return ptr;
f0109785:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109788:	c9                   	leave  
f0109789:	c3                   	ret    

f010978a <kfree>:

void kfree(void *va)
{
f010978a:	55                   	push   %ebp
f010978b:	89 e5                	mov    %esp,%ebp
f010978d:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109790:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f0109795:	05 00 10 00 00       	add    $0x1000,%eax
f010979a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f010979d:	8b 55 08             	mov    0x8(%ebp),%edx
f01097a0:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f01097a5:	39 c2                	cmp    %eax,%edx
f01097a7:	73 13                	jae    f01097bc <kfree+0x32>
        free_block(va);
f01097a9:	83 ec 0c             	sub    $0xc,%esp
f01097ac:	ff 75 08             	pushl  0x8(%ebp)
f01097af:	e8 17 81 01 00       	call   f01218cb <free_block>
f01097b4:	83 c4 10             	add    $0x10,%esp
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f01097b7:	e9 b1 00 00 00       	jmp    f010986d <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01097bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01097bf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01097c2:	0f 82 8e 00 00 00    	jb     f0109856 <kfree+0xcc>
f01097c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01097cb:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f01097d0:	0f 87 80 00 00 00    	ja     f0109856 <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f01097d6:	8b 55 08             	mov    0x8(%ebp),%edx
f01097d9:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f01097de:	29 c2                	sub    %eax,%edx
f01097e0:	89 d0                	mov    %edx,%eax
f01097e2:	2d 00 10 00 00       	sub    $0x1000,%eax
f01097e7:	c1 e8 0c             	shr    $0xc,%eax
f01097ea:	8b 04 85 00 2f 6c f0 	mov    -0xf93d100(,%eax,4),%eax
f01097f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f01097f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01097fb:	eb 4f                	jmp    f010984c <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f01097fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109800:	c1 e0 0c             	shl    $0xc,%eax
f0109803:	89 c2                	mov    %eax,%edx
f0109805:	8b 45 08             	mov    0x8(%ebp),%eax
f0109808:	01 d0                	add    %edx,%eax
f010980a:	83 ec 0c             	sub    $0xc,%esp
f010980d:	50                   	push   %eax
f010980e:	e8 5d 00 00 00       	call   f0109870 <kheap_physical_address>
f0109813:	83 c4 10             	add    $0x10,%esp
f0109816:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f0109819:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010981c:	c1 e8 0c             	shr    $0xc,%eax
f010981f:	c7 04 85 20 35 ac f0 	movl   $0x0,-0xf53cae0(,%eax,4)
f0109826:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f010982a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010982d:	c1 e0 0c             	shl    $0xc,%eax
f0109830:	89 c2                	mov    %eax,%edx
f0109832:	8b 45 08             	mov    0x8(%ebp),%eax
f0109835:	01 c2                	add    %eax,%edx
f0109837:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010983c:	83 ec 08             	sub    $0x8,%esp
f010983f:	52                   	push   %edx
f0109840:	50                   	push   %eax
f0109841:	e8 99 ef ff ff       	call   f01087df <unmap_frame>
f0109846:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f0109849:	ff 45 f4             	incl   -0xc(%ebp)
f010984c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010984f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109852:	72 a9                	jb     f01097fd <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109854:	eb 17                	jmp    f010986d <kfree+0xe3>
			//isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
			//cprintf("kfree Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)va + (i * PAGE_SIZE)))]);
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f0109856:	83 ec 04             	sub    $0x4,%esp
f0109859:	68 10 5c 12 f0       	push   $0xf0125c10
f010985e:	68 e2 00 00 00       	push   $0xe2
f0109863:	68 f2 5b 12 f0       	push   $0xf0125bf2
f0109868:	e8 cc 6a ff ff       	call   f0100339 <_panic>
    }
}
f010986d:	90                   	nop
f010986e:	c9                   	leave  
f010986f:	c3                   	ret    

f0109870 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f0109870:	55                   	push   %ebp
f0109871:	89 e5                	mov    %esp,%ebp
f0109873:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109876:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f010987d:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109882:	83 ec 04             	sub    $0x4,%esp
f0109885:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109888:	52                   	push   %edx
f0109889:	ff 75 08             	pushl  0x8(%ebp)
f010988c:	50                   	push   %eax
f010988d:	e8 d7 ee ff ff       	call   f0108769 <get_frame_info>
f0109892:	83 c4 10             	add    $0x10,%esp
f0109895:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109898:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010989c:	75 07                	jne    f01098a5 <kheap_physical_address+0x35>
		return 0;
f010989e:	b8 00 00 00 00       	mov    $0x0,%eax
f01098a3:	eb 26                	jmp    f01098cb <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f01098a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01098a8:	25 ff 0f 00 00       	and    $0xfff,%eax
f01098ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f01098b0:	83 ec 0c             	sub    $0xc,%esp
f01098b3:	ff 75 f4             	pushl  -0xc(%ebp)
f01098b6:	e8 12 fa ff ff       	call   f01092cd <to_physical_address>
f01098bb:	83 c4 10             	add    $0x10,%esp
f01098be:	89 c2                	mov    %eax,%edx
f01098c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098c3:	01 d0                	add    %edx,%eax
f01098c5:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f01098c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01098cb:	c9                   	leave  
f01098cc:	c3                   	ret    

f01098cd <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f01098cd:	55                   	push   %ebp
f01098ce:	89 e5                	mov    %esp,%ebp
f01098d0:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f01098d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01098d6:	25 ff 0f 00 00       	and    $0xfff,%eax
f01098db:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f01098de:	8b 45 08             	mov    0x8(%ebp),%eax
f01098e1:	c1 e8 0c             	shr    $0xc,%eax
f01098e4:	8b 04 85 20 35 ac f0 	mov    -0xf53cae0(,%eax,4),%eax
f01098eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f01098ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01098f2:	74 06                	je     f01098fa <kheap_virtual_address+0x2d>
f01098f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01098f7:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f01098fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01098fd:	c9                   	leave  
f01098fe:	c3                   	ret    

f01098ff <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f01098ff:	55                   	push   %ebp
f0109900:	89 e5                	mov    %esp,%ebp
f0109902:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f0109905:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f010990c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109910:	75 16                	jne    f0109928 <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109912:	83 ec 0c             	sub    $0xc,%esp
f0109915:	ff 75 0c             	pushl  0xc(%ebp)
f0109918:	e8 0d fc ff ff       	call   f010952a <kmalloc>
f010991d:	83 c4 10             	add    $0x10,%esp
f0109920:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109923:	e9 37 03 00 00       	jmp    f0109c5f <krealloc+0x360>
	} else if(new_size == 0){
f0109928:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010992c:	75 13                	jne    f0109941 <krealloc+0x42>
		kfree(va);
f010992e:	83 ec 0c             	sub    $0xc,%esp
f0109931:	ff 75 08             	pushl  0x8(%ebp)
f0109934:	e8 51 fe ff ff       	call   f010978a <kfree>
f0109939:	83 c4 10             	add    $0x10,%esp
f010993c:	e9 1e 03 00 00       	jmp    f0109c5f <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109941:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f0109946:	05 00 10 00 00       	add    $0x1000,%eax
f010994b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f010994e:	8b 55 08             	mov    0x8(%ebp),%edx
f0109951:	a1 f4 33 ac f0       	mov    0xf0ac33f4,%eax
f0109956:	39 c2                	cmp    %eax,%edx
f0109958:	73 19                	jae    f0109973 <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f010995a:	83 ec 08             	sub    $0x8,%esp
f010995d:	ff 75 0c             	pushl  0xc(%ebp)
f0109960:	ff 75 08             	pushl  0x8(%ebp)
f0109963:	e8 63 80 01 00       	call   f01219cb <realloc_block_FF>
f0109968:	83 c4 10             	add    $0x10,%esp
f010996b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010996e:	e9 ec 02 00 00       	jmp    f0109c5f <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109973:	8b 45 08             	mov    0x8(%ebp),%eax
f0109976:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0109979:	0f 82 c8 02 00 00    	jb     f0109c47 <krealloc+0x348>
f010997f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109982:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109987:	0f 87 ba 02 00 00    	ja     f0109c47 <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f010998d:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f0109994:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109997:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010999a:	01 d0                	add    %edx,%eax
f010999c:	48                   	dec    %eax
f010999d:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01099a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01099a3:	ba 00 00 00 00       	mov    $0x0,%edx
f01099a8:	f7 75 d4             	divl   -0x2c(%ebp)
f01099ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01099ae:	29 d0                	sub    %edx,%eax
f01099b0:	c1 e8 0c             	shr    $0xc,%eax
f01099b3:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f01099b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01099b9:	c1 e8 0c             	shr    $0xc,%eax
f01099bc:	8b 04 85 00 2f 6c f0 	mov    -0xf93d100(,%eax,4),%eax
f01099c3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f01099c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01099c9:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01099cc:	0f 87 ee 00 00 00    	ja     f0109ac0 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f01099d2:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f01099d9:	77 63                	ja     f0109a3e <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f01099db:	e8 8b f8 ff ff       	call   f010926b <isKHeapPlacementStrategyFIRSTFIT>
f01099e0:	84 c0                	test   %al,%al
f01099e2:	74 13                	je     f01099f7 <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f01099e4:	83 ec 0c             	sub    $0xc,%esp
f01099e7:	ff 75 0c             	pushl  0xc(%ebp)
f01099ea:	e8 18 70 01 00       	call   f0120a07 <alloc_block_FF>
f01099ef:	83 c4 10             	add    $0x10,%esp
f01099f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01099f5:	eb 1a                	jmp    f0109a11 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f01099f7:	e8 84 f8 ff ff       	call   f0109280 <isKHeapPlacementStrategyBESTFIT>
f01099fc:	84 c0                	test   %al,%al
f01099fe:	74 11                	je     f0109a11 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109a00:	83 ec 0c             	sub    $0xc,%esp
f0109a03:	ff 75 0c             	pushl  0xc(%ebp)
f0109a06:	e8 b8 74 01 00       	call   f0120ec3 <alloc_block_BF>
f0109a0b:	83 c4 10             	add    $0x10,%esp
f0109a0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109a11:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109a15:	74 14                	je     f0109a2b <krealloc+0x12c>
f0109a17:	83 ec 04             	sub    $0x4,%esp
f0109a1a:	ff 75 0c             	pushl  0xc(%ebp)
f0109a1d:	ff 75 08             	pushl  0x8(%ebp)
f0109a20:	ff 75 f4             	pushl  -0xc(%ebp)
f0109a23:	e8 12 64 01 00       	call   f011fe3a <memcpy>
f0109a28:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109a2b:	83 ec 0c             	sub    $0xc,%esp
f0109a2e:	ff 75 08             	pushl  0x8(%ebp)
f0109a31:	e8 54 fd ff ff       	call   f010978a <kfree>
f0109a36:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109a39:	e9 20 02 00 00       	jmp    f0109c5e <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f0109a3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109a41:	c1 e0 0c             	shl    $0xc,%eax
f0109a44:	89 c2                	mov    %eax,%edx
f0109a46:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a49:	01 d0                	add    %edx,%eax
f0109a4b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109a4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109a55:	eb 4f                	jmp    f0109aa6 <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f0109a57:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a5a:	c1 e0 0c             	shl    $0xc,%eax
f0109a5d:	89 c2                	mov    %eax,%edx
f0109a5f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109a62:	01 d0                	add    %edx,%eax
f0109a64:	83 ec 0c             	sub    $0xc,%esp
f0109a67:	50                   	push   %eax
f0109a68:	e8 03 fe ff ff       	call   f0109870 <kheap_physical_address>
f0109a6d:	83 c4 10             	add    $0x10,%esp
f0109a70:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f0109a73:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109a76:	c1 e8 0c             	shr    $0xc,%eax
f0109a79:	c7 04 85 20 35 ac f0 	movl   $0x0,-0xf53cae0(,%eax,4)
f0109a80:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f0109a84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a87:	c1 e0 0c             	shl    $0xc,%eax
f0109a8a:	89 c2                	mov    %eax,%edx
f0109a8c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109a8f:	01 c2                	add    %eax,%edx
f0109a91:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109a96:	83 ec 08             	sub    $0x8,%esp
f0109a99:	52                   	push   %edx
f0109a9a:	50                   	push   %eax
f0109a9b:	e8 3f ed ff ff       	call   f01087df <unmap_frame>
f0109aa0:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109aa3:	ff 45 f0             	incl   -0x10(%ebp)
f0109aa6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109aa9:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109aac:	89 c2                	mov    %eax,%edx
f0109aae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ab1:	39 c2                	cmp    %eax,%edx
f0109ab3:	77 a2                	ja     f0109a57 <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109ab5:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ab8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109abb:	e9 9e 01 00 00       	jmp    f0109c5e <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109ac0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109ac3:	c1 e0 0c             	shl    $0xc,%eax
f0109ac6:	89 c2                	mov    %eax,%edx
f0109ac8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109acb:	01 d0                	add    %edx,%eax
f0109acd:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109ad0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109ad7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109ade:	eb 33                	jmp    f0109b13 <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109ae0:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109ae7:	0f 87 19 01 00 00    	ja     f0109c06 <krealloc+0x307>
f0109aed:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109af2:	83 ec 08             	sub    $0x8,%esp
f0109af5:	ff 75 ec             	pushl  -0x14(%ebp)
f0109af8:	50                   	push   %eax
f0109af9:	e8 f3 f9 ff ff       	call   f01094f1 <isPageAllocated>
f0109afe:	83 c4 10             	add    $0x10,%esp
f0109b01:	85 c0                	test   %eax,%eax
f0109b03:	0f 85 fd 00 00 00    	jne    f0109c06 <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109b09:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109b10:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109b13:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b16:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109b19:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109b1c:	77 c2                	ja     f0109ae0 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109b1e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109b25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109b2c:	eb 5c                	jmp    f0109b8a <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109b2e:	83 ec 0c             	sub    $0xc,%esp
f0109b31:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109b34:	50                   	push   %eax
f0109b35:	e8 78 e6 ff ff       	call   f01081b2 <allocate_frame>
f0109b3a:	83 c4 10             	add    $0x10,%esp
f0109b3d:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109b40:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109b44:	74 2d                	je     f0109b73 <krealloc+0x274>
f0109b46:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109b49:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109b4c:	01 d0                	add    %edx,%eax
f0109b4e:	c1 e0 0c             	shl    $0xc,%eax
f0109b51:	89 c2                	mov    %eax,%edx
f0109b53:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b56:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109b59:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109b5c:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0109b61:	6a 02                	push   $0x2
f0109b63:	51                   	push   %ecx
f0109b64:	52                   	push   %edx
f0109b65:	50                   	push   %eax
f0109b66:	e8 14 eb ff ff       	call   f010867f <map_frame>
f0109b6b:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109b6e:	ff 45 e0             	incl   -0x20(%ebp)
f0109b71:	eb 17                	jmp    f0109b8a <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109b73:	83 ec 04             	sub    $0x4,%esp
f0109b76:	68 03 5c 12 f0       	push   $0xf0125c03
f0109b7b:	68 4f 01 00 00       	push   $0x14f
f0109b80:	68 f2 5b 12 f0       	push   $0xf0125bf2
f0109b85:	e8 af 67 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109b8a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b8d:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109b90:	89 c2                	mov    %eax,%edx
f0109b92:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109b95:	39 c2                	cmp    %eax,%edx
f0109b97:	77 95                	ja     f0109b2e <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109b99:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b9c:	c1 e8 0c             	shr    $0xc,%eax
f0109b9f:	89 c2                	mov    %eax,%edx
f0109ba1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ba4:	89 04 95 00 2f 6c f0 	mov    %eax,-0xf93d100(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109bab:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109bb2:	eb 43                	jmp    f0109bf7 <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109bb4:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109bb7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109bba:	01 d0                	add    %edx,%eax
f0109bbc:	c1 e0 0c             	shl    $0xc,%eax
f0109bbf:	89 c2                	mov    %eax,%edx
f0109bc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bc4:	01 d0                	add    %edx,%eax
f0109bc6:	83 ec 0c             	sub    $0xc,%esp
f0109bc9:	50                   	push   %eax
f0109bca:	e8 a1 fc ff ff       	call   f0109870 <kheap_physical_address>
f0109bcf:	83 c4 10             	add    $0x10,%esp
f0109bd2:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109bd5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109bd8:	c1 e8 0c             	shr    $0xc,%eax
f0109bdb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109bde:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109be1:	01 ca                	add    %ecx,%edx
f0109be3:	89 d1                	mov    %edx,%ecx
f0109be5:	c1 e1 0c             	shl    $0xc,%ecx
f0109be8:	8b 55 08             	mov    0x8(%ebp),%edx
f0109beb:	01 ca                	add    %ecx,%edx
f0109bed:	89 14 85 20 35 ac f0 	mov    %edx,-0xf53cae0(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109bf4:	ff 45 dc             	incl   -0x24(%ebp)
f0109bf7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109bfa:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109bfd:	89 c2                	mov    %eax,%edx
f0109bff:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109c02:	39 c2                	cmp    %eax,%edx
f0109c04:	77 ae                	ja     f0109bb4 <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109c06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109c0a:	75 52                	jne    f0109c5e <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109c0c:	83 ec 0c             	sub    $0xc,%esp
f0109c0f:	ff 75 0c             	pushl  0xc(%ebp)
f0109c12:	e8 13 f9 ff ff       	call   f010952a <kmalloc>
f0109c17:	83 c4 10             	add    $0x10,%esp
f0109c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109c1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109c21:	74 14                	je     f0109c37 <krealloc+0x338>
f0109c23:	83 ec 04             	sub    $0x4,%esp
f0109c26:	ff 75 0c             	pushl  0xc(%ebp)
f0109c29:	ff 75 08             	pushl  0x8(%ebp)
f0109c2c:	ff 75 f4             	pushl  -0xc(%ebp)
f0109c2f:	e8 06 62 01 00       	call   f011fe3a <memcpy>
f0109c34:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109c37:	83 ec 0c             	sub    $0xc,%esp
f0109c3a:	ff 75 08             	pushl  0x8(%ebp)
f0109c3d:	e8 48 fb ff ff       	call   f010978a <kfree>
f0109c42:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109c45:	eb 17                	jmp    f0109c5e <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109c47:	83 ec 04             	sub    $0x4,%esp
f0109c4a:	68 38 5c 12 f0       	push   $0xf0125c38
f0109c4f:	68 5e 01 00 00       	push   $0x15e
f0109c54:	68 f2 5b 12 f0       	push   $0xf0125bf2
f0109c59:	e8 db 66 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109c5e:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109c5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109c62:	c9                   	leave  
f0109c63:	c3                   	ret    

f0109c64 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109c64:	55                   	push   %ebp
f0109c65:	89 e5                	mov    %esp,%ebp
f0109c67:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109c6a:	83 ec 04             	sub    $0x4,%esp
f0109c6d:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109c70:	50                   	push   %eax
f0109c71:	ff 75 0c             	pushl  0xc(%ebp)
f0109c74:	ff 75 08             	pushl  0x8(%ebp)
f0109c77:	e8 73 e7 ff ff       	call   f01083ef <get_page_table>
f0109c7c:	83 c4 10             	add    $0x10,%esp
f0109c7f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109c82:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c85:	85 c0                	test   %eax,%eax
f0109c87:	74 64                	je     f0109ced <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109c89:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c8c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c8f:	c1 ea 0c             	shr    $0xc,%edx
f0109c92:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109c98:	c1 e2 02             	shl    $0x2,%edx
f0109c9b:	01 c2                	add    %eax,%edx
f0109c9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ca0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109ca3:	c1 e9 0c             	shr    $0xc,%ecx
f0109ca6:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109cac:	c1 e1 02             	shl    $0x2,%ecx
f0109caf:	01 c8                	add    %ecx,%eax
f0109cb1:	8b 00                	mov    (%eax),%eax
f0109cb3:	0b 45 10             	or     0x10(%ebp),%eax
f0109cb6:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109cb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cbb:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cbe:	c1 ea 0c             	shr    $0xc,%edx
f0109cc1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109cc7:	c1 e2 02             	shl    $0x2,%edx
f0109cca:	01 d0                	add    %edx,%eax
f0109ccc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109ccf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109cd2:	c1 e9 0c             	shr    $0xc,%ecx
f0109cd5:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109cdb:	c1 e1 02             	shl    $0x2,%ecx
f0109cde:	01 ca                	add    %ecx,%edx
f0109ce0:	8b 12                	mov    (%edx),%edx
f0109ce2:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109ce5:	f7 d1                	not    %ecx
f0109ce7:	21 ca                	and    %ecx,%edx
f0109ce9:	89 10                	mov    %edx,(%eax)
f0109ceb:	eb 27                	jmp    f0109d14 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109ced:	83 ec 08             	sub    $0x8,%esp
f0109cf0:	ff 75 0c             	pushl  0xc(%ebp)
f0109cf3:	68 64 5c 12 f0       	push   $0xf0125c64
f0109cf8:	e8 8e 72 ff ff       	call   f0100f8b <cprintf>
f0109cfd:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109d00:	83 ec 04             	sub    $0x4,%esp
f0109d03:	68 8c 5c 12 f0       	push   $0xf0125c8c
f0109d08:	6a 1c                	push   $0x1c
f0109d0a:	68 00 5d 12 f0       	push   $0xf0125d00
f0109d0f:	e8 25 66 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109d14:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109d17:	83 ec 08             	sub    $0x8,%esp
f0109d1a:	50                   	push   %eax
f0109d1b:	6a 00                	push   $0x0
f0109d1d:	e8 97 e0 ff ff       	call   f0107db9 <tlb_invalidate>
f0109d22:	83 c4 10             	add    $0x10,%esp
}
f0109d25:	90                   	nop
f0109d26:	c9                   	leave  
f0109d27:	c3                   	ret    

f0109d28 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0109d28:	55                   	push   %ebp
f0109d29:	89 e5                	mov    %esp,%ebp
f0109d2b:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109d2e:	83 ec 04             	sub    $0x4,%esp
f0109d31:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d34:	50                   	push   %eax
f0109d35:	ff 75 0c             	pushl  0xc(%ebp)
f0109d38:	ff 75 08             	pushl  0x8(%ebp)
f0109d3b:	e8 af e6 ff ff       	call   f01083ef <get_page_table>
f0109d40:	83 c4 10             	add    $0x10,%esp
f0109d43:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0109d46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d49:	85 c0                	test   %eax,%eax
f0109d4b:	74 1d                	je     f0109d6a <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0109d4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d50:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d53:	c1 ea 0c             	shr    $0xc,%edx
f0109d56:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d5c:	c1 e2 02             	shl    $0x2,%edx
f0109d5f:	01 d0                	add    %edx,%eax
f0109d61:	8b 00                	mov    (%eax),%eax
f0109d63:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109d68:	eb 05                	jmp    f0109d6f <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0109d6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0109d6f:	c9                   	leave  
f0109d70:	c3                   	ret    

f0109d71 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0109d71:	55                   	push   %ebp
f0109d72:	89 e5                	mov    %esp,%ebp
f0109d74:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109d77:	83 ec 04             	sub    $0x4,%esp
f0109d7a:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d7d:	50                   	push   %eax
f0109d7e:	ff 75 0c             	pushl  0xc(%ebp)
f0109d81:	ff 75 08             	pushl  0x8(%ebp)
f0109d84:	e8 66 e6 ff ff       	call   f01083ef <get_page_table>
f0109d89:	83 c4 10             	add    $0x10,%esp
f0109d8c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109d8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d92:	85 c0                	test   %eax,%eax
f0109d94:	74 46                	je     f0109ddc <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0109d96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d99:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d9c:	c1 ea 0c             	shr    $0xc,%edx
f0109d9f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109da5:	c1 e2 02             	shl    $0x2,%edx
f0109da8:	01 d0                	add    %edx,%eax
f0109daa:	8b 00                	mov    (%eax),%eax
f0109dac:	83 ec 04             	sub    $0x4,%esp
f0109daf:	50                   	push   %eax
f0109db0:	ff 75 0c             	pushl  0xc(%ebp)
f0109db3:	68 1c 5d 12 f0       	push   $0xf0125d1c
f0109db8:	e8 ce 71 ff ff       	call   f0100f8b <cprintf>
f0109dbd:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0109dc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dc3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109dc6:	c1 ea 0c             	shr    $0xc,%edx
f0109dc9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109dcf:	c1 e2 02             	shl    $0x2,%edx
f0109dd2:	01 d0                	add    %edx,%eax
f0109dd4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109dda:	eb 14                	jmp    f0109df0 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109ddc:	83 ec 04             	sub    $0x4,%esp
f0109ddf:	68 44 5d 12 f0       	push   $0xf0125d44
f0109de4:	6a 47                	push   $0x47
f0109de6:	68 00 5d 12 f0       	push   $0xf0125d00
f0109deb:	e8 49 65 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109df0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109df3:	83 ec 08             	sub    $0x8,%esp
f0109df6:	50                   	push   %eax
f0109df7:	6a 00                	push   $0x0
f0109df9:	e8 bb df ff ff       	call   f0107db9 <tlb_invalidate>
f0109dfe:	83 c4 10             	add    $0x10,%esp
}
f0109e01:	90                   	nop
f0109e02:	c9                   	leave  
f0109e03:	c3                   	ret    

f0109e04 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109e04:	55                   	push   %ebp
f0109e05:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109e07:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e0a:	c1 e8 16             	shr    $0x16,%eax
f0109e0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e14:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e17:	01 d0                	add    %edx,%eax
f0109e19:	8b 00                	mov    (%eax),%eax
f0109e1b:	83 e0 20             	and    $0x20,%eax
f0109e1e:	85 c0                	test   %eax,%eax
f0109e20:	0f 95 c0             	setne  %al
f0109e23:	0f b6 c0             	movzbl %al,%eax
}
f0109e26:	5d                   	pop    %ebp
f0109e27:	c3                   	ret    

f0109e28 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0109e28:	55                   	push   %ebp
f0109e29:	89 e5                	mov    %esp,%ebp
f0109e2b:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0109e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e31:	c1 e8 16             	shr    $0x16,%eax
f0109e34:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e3b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e3e:	01 d0                	add    %edx,%eax
f0109e40:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e43:	c1 ea 16             	shr    $0x16,%edx
f0109e46:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109e4d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e50:	01 ca                	add    %ecx,%edx
f0109e52:	8b 12                	mov    (%edx),%edx
f0109e54:	83 e2 df             	and    $0xffffffdf,%edx
f0109e57:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109e59:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e5c:	83 ec 08             	sub    $0x8,%esp
f0109e5f:	50                   	push   %eax
f0109e60:	6a 00                	push   $0x0
f0109e62:	e8 52 df ff ff       	call   f0107db9 <tlb_invalidate>
f0109e67:	83 c4 10             	add    $0x10,%esp
}
f0109e6a:	90                   	nop
f0109e6b:	c9                   	leave  
f0109e6c:	c3                   	ret    

f0109e6d <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0109e6d:	55                   	push   %ebp
f0109e6e:	89 e5                	mov    %esp,%ebp
f0109e70:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0109e73:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e76:	c1 e8 16             	shr    $0x16,%eax
f0109e79:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e80:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e83:	01 d0                	add    %edx,%eax
f0109e85:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109e8b:	0f 20 d8             	mov    %cr3,%eax
f0109e8e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109e91:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109e94:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109e97:	90                   	nop
f0109e98:	c9                   	leave  
f0109e99:	c3                   	ret    

f0109e9a <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109e9a:	55                   	push   %ebp
f0109e9b:	89 e5                	mov    %esp,%ebp
f0109e9d:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f0109ea0:	83 ec 0c             	sub    $0xc,%esp
f0109ea3:	6a 18                	push   $0x18
f0109ea5:	e8 80 f6 ff ff       	call   f010952a <kmalloc>
f0109eaa:	83 c4 10             	add    $0x10,%esp
f0109ead:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f0109eb0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109eb4:	75 14                	jne    f0109eca <env_page_ws_list_create_element+0x30>
f0109eb6:	83 ec 04             	sub    $0x4,%esp
f0109eb9:	68 bc 5d 12 f0       	push   $0xf0125dbc
f0109ebe:	6a 19                	push   $0x19
f0109ec0:	68 ec 5d 12 f0       	push   $0xf0125dec
f0109ec5:	e8 6f 64 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f0109eca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ecd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109ed0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ed3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109ed6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ed9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109ede:	89 c2                	mov    %eax,%edx
f0109ee0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ee3:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f0109ee5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ee8:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f0109eec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109eef:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f0109ef6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ef9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f0109f00:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109f03:	c9                   	leave  
f0109f04:	c3                   	ret    

f0109f05 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109f05:	55                   	push   %ebp
f0109f06:	89 e5                	mov    %esp,%ebp
f0109f08:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109f0b:	83 ec 0c             	sub    $0xc,%esp
f0109f0e:	6a 02                	push   $0x2
f0109f10:	e8 06 57 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f0109f15:	83 c4 10             	add    $0x10,%esp
f0109f18:	85 c0                	test   %eax,%eax
f0109f1a:	0f 84 e5 03 00 00    	je     f010a305 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109f20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109f27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109f2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f31:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109f37:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109f3a:	e9 3b 02 00 00       	jmp    f010a17a <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109f3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f42:	8b 00                	mov    (%eax),%eax
f0109f44:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109f47:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f4a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f4f:	89 c2                	mov    %eax,%edx
f0109f51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109f57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109f5a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f5f:	39 c2                	cmp    %eax,%edx
f0109f61:	0f 85 07 02 00 00    	jne    f010a16e <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109f67:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f6a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109f70:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f76:	8b 10                	mov    (%eax),%edx
f0109f78:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f7b:	8b 40 64             	mov    0x64(%eax),%eax
f0109f7e:	83 ec 08             	sub    $0x8,%esp
f0109f81:	52                   	push   %edx
f0109f82:	50                   	push   %eax
f0109f83:	e8 57 e8 ff ff       	call   f01087df <unmap_frame>
f0109f88:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f0109f8b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109f8f:	75 14                	jne    f0109fa5 <env_page_ws_invalidate+0xa0>
f0109f91:	83 ec 04             	sub    $0x4,%esp
f0109f94:	68 0b 5e 12 f0       	push   $0xf0125e0b
f0109f99:	6a 2f                	push   $0x2f
f0109f9b:	68 ec 5d 12 f0       	push   $0xf0125dec
f0109fa0:	e8 94 63 ff ff       	call   f0100339 <_panic>
f0109fa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fa8:	8b 40 10             	mov    0x10(%eax),%eax
f0109fab:	85 c0                	test   %eax,%eax
f0109fad:	74 11                	je     f0109fc0 <env_page_ws_invalidate+0xbb>
f0109faf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fb2:	8b 40 10             	mov    0x10(%eax),%eax
f0109fb5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109fb8:	8b 52 14             	mov    0x14(%edx),%edx
f0109fbb:	89 50 14             	mov    %edx,0x14(%eax)
f0109fbe:	eb 0f                	jmp    f0109fcf <env_page_ws_invalidate+0xca>
f0109fc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fc3:	8b 50 14             	mov    0x14(%eax),%edx
f0109fc6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fc9:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109fcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fd2:	8b 40 14             	mov    0x14(%eax),%eax
f0109fd5:	85 c0                	test   %eax,%eax
f0109fd7:	74 11                	je     f0109fea <env_page_ws_invalidate+0xe5>
f0109fd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fdc:	8b 40 14             	mov    0x14(%eax),%eax
f0109fdf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109fe2:	8b 52 10             	mov    0x10(%edx),%edx
f0109fe5:	89 50 10             	mov    %edx,0x10(%eax)
f0109fe8:	eb 0f                	jmp    f0109ff9 <env_page_ws_invalidate+0xf4>
f0109fea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fed:	8b 50 10             	mov    0x10(%eax),%edx
f0109ff0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ff3:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f0109ff9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ffc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a003:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a006:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a00d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a010:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a016:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a019:	8b 45 08             	mov    0x8(%ebp),%eax
f010a01c:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a022:	83 ec 0c             	sub    $0xc,%esp
f010a025:	ff 75 f0             	pushl  -0x10(%ebp)
f010a028:	e8 5d f7 ff ff       	call   f010978a <kfree>
f010a02d:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a030:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a034:	0f 84 2b 01 00 00    	je     f010a165 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a03a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a03e:	75 14                	jne    f010a054 <env_page_ws_invalidate+0x14f>
f010a040:	83 ec 04             	sub    $0x4,%esp
f010a043:	68 0b 5e 12 f0       	push   $0xf0125e0b
f010a048:	6a 35                	push   $0x35
f010a04a:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a04f:	e8 e5 62 ff ff       	call   f0100339 <_panic>
f010a054:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a057:	8b 40 10             	mov    0x10(%eax),%eax
f010a05a:	85 c0                	test   %eax,%eax
f010a05c:	74 11                	je     f010a06f <env_page_ws_invalidate+0x16a>
f010a05e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a061:	8b 40 10             	mov    0x10(%eax),%eax
f010a064:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a067:	8b 52 14             	mov    0x14(%edx),%edx
f010a06a:	89 50 14             	mov    %edx,0x14(%eax)
f010a06d:	eb 0f                	jmp    f010a07e <env_page_ws_invalidate+0x179>
f010a06f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a072:	8b 50 14             	mov    0x14(%eax),%edx
f010a075:	8b 45 08             	mov    0x8(%ebp),%eax
f010a078:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a07e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a081:	8b 40 14             	mov    0x14(%eax),%eax
f010a084:	85 c0                	test   %eax,%eax
f010a086:	74 11                	je     f010a099 <env_page_ws_invalidate+0x194>
f010a088:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a08b:	8b 40 14             	mov    0x14(%eax),%eax
f010a08e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a091:	8b 52 10             	mov    0x10(%edx),%edx
f010a094:	89 50 10             	mov    %edx,0x10(%eax)
f010a097:	eb 0f                	jmp    f010a0a8 <env_page_ws_invalidate+0x1a3>
f010a099:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a09c:	8b 50 10             	mov    0x10(%eax),%edx
f010a09f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0a2:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a0a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0ab:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a0b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0b5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a0bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0bf:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a0c5:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a0c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0cb:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a0d1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0d5:	75 14                	jne    f010a0eb <env_page_ws_invalidate+0x1e6>
f010a0d7:	83 ec 04             	sub    $0x4,%esp
f010a0da:	68 2c 5e 12 f0       	push   $0xf0125e2c
f010a0df:	6a 36                	push   $0x36
f010a0e1:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a0e6:	e8 4e 62 ff ff       	call   f0100339 <_panic>
f010a0eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ee:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a0f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0f7:	89 50 14             	mov    %edx,0x14(%eax)
f010a0fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0fd:	8b 40 14             	mov    0x14(%eax),%eax
f010a100:	85 c0                	test   %eax,%eax
f010a102:	74 11                	je     f010a115 <env_page_ws_invalidate+0x210>
f010a104:	8b 45 08             	mov    0x8(%ebp),%eax
f010a107:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a10d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a110:	89 50 10             	mov    %edx,0x10(%eax)
f010a113:	eb 0c                	jmp    f010a121 <env_page_ws_invalidate+0x21c>
f010a115:	8b 45 08             	mov    0x8(%ebp),%eax
f010a118:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a11b:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a121:	8b 45 08             	mov    0x8(%ebp),%eax
f010a124:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a127:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a12d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a130:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a137:	8b 45 08             	mov    0x8(%ebp),%eax
f010a13a:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a140:	8d 50 01             	lea    0x1(%eax),%edx
f010a143:	8b 45 08             	mov    0x8(%ebp),%eax
f010a146:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a14c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a14f:	8b 10                	mov    (%eax),%edx
f010a151:	8b 45 08             	mov    0x8(%ebp),%eax
f010a154:	8b 40 64             	mov    0x64(%eax),%eax
f010a157:	6a 00                	push   $0x0
f010a159:	6a 01                	push   $0x1
f010a15b:	52                   	push   %edx
f010a15c:	50                   	push   %eax
f010a15d:	e8 02 fb ff ff       	call   f0109c64 <pt_set_page_permissions>
f010a162:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a165:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a16c:	eb 43                	jmp    f010a1b1 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a16e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a171:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a177:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a17a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a17e:	74 08                	je     f010a188 <env_page_ws_invalidate+0x283>
f010a180:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a183:	8b 40 10             	mov    0x10(%eax),%eax
f010a186:	eb 05                	jmp    f010a18d <env_page_ws_invalidate+0x288>
f010a188:	b8 00 00 00 00       	mov    $0x0,%eax
f010a18d:	8b 55 08             	mov    0x8(%ebp),%edx
f010a190:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a196:	8b 45 08             	mov    0x8(%ebp),%eax
f010a199:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a19f:	85 c0                	test   %eax,%eax
f010a1a1:	0f 85 98 fd ff ff    	jne    f0109f3f <env_page_ws_invalidate+0x3a>
f010a1a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a1ab:	0f 85 8e fd ff ff    	jne    f0109f3f <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a1b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a1b5:	0f 85 a4 02 00 00    	jne    f010a45f <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a1bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a1c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c5:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a1cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a1ce:	e9 f6 00 00 00       	jmp    f010a2c9 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a1d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1d6:	8b 00                	mov    (%eax),%eax
f010a1d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a1db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a1de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a1e3:	89 c2                	mov    %eax,%edx
f010a1e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1e8:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a1eb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a1ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a1f3:	39 c2                	cmp    %eax,%edx
f010a1f5:	0f 85 c2 00 00 00    	jne    f010a2bd <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a1fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1fe:	8b 10                	mov    (%eax),%edx
f010a200:	8b 45 08             	mov    0x8(%ebp),%eax
f010a203:	8b 40 64             	mov    0x64(%eax),%eax
f010a206:	83 ec 08             	sub    $0x8,%esp
f010a209:	52                   	push   %edx
f010a20a:	50                   	push   %eax
f010a20b:	e8 cf e5 ff ff       	call   f01087df <unmap_frame>
f010a210:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a213:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a217:	75 14                	jne    f010a22d <env_page_ws_invalidate+0x328>
f010a219:	83 ec 04             	sub    $0x4,%esp
f010a21c:	68 0b 5e 12 f0       	push   $0xf0125e0b
f010a221:	6a 46                	push   $0x46
f010a223:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a228:	e8 0c 61 ff ff       	call   f0100339 <_panic>
f010a22d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a230:	8b 40 10             	mov    0x10(%eax),%eax
f010a233:	85 c0                	test   %eax,%eax
f010a235:	74 11                	je     f010a248 <env_page_ws_invalidate+0x343>
f010a237:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a23a:	8b 40 10             	mov    0x10(%eax),%eax
f010a23d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a240:	8b 52 14             	mov    0x14(%edx),%edx
f010a243:	89 50 14             	mov    %edx,0x14(%eax)
f010a246:	eb 0f                	jmp    f010a257 <env_page_ws_invalidate+0x352>
f010a248:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a24b:	8b 50 14             	mov    0x14(%eax),%edx
f010a24e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a251:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a257:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a25a:	8b 40 14             	mov    0x14(%eax),%eax
f010a25d:	85 c0                	test   %eax,%eax
f010a25f:	74 11                	je     f010a272 <env_page_ws_invalidate+0x36d>
f010a261:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a264:	8b 40 14             	mov    0x14(%eax),%eax
f010a267:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a26a:	8b 52 10             	mov    0x10(%edx),%edx
f010a26d:	89 50 10             	mov    %edx,0x10(%eax)
f010a270:	eb 0f                	jmp    f010a281 <env_page_ws_invalidate+0x37c>
f010a272:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a275:	8b 50 10             	mov    0x10(%eax),%edx
f010a278:	8b 45 08             	mov    0x8(%ebp),%eax
f010a27b:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a281:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a284:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a28b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a28e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a295:	8b 45 08             	mov    0x8(%ebp),%eax
f010a298:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a29e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a2a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2a4:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a2aa:	83 ec 0c             	sub    $0xc,%esp
f010a2ad:	ff 75 f0             	pushl  -0x10(%ebp)
f010a2b0:	e8 d5 f4 ff ff       	call   f010978a <kfree>
f010a2b5:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a2b8:	e9 a2 01 00 00       	jmp    f010a45f <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c0:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a2c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a2c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a2cd:	74 08                	je     f010a2d7 <env_page_ws_invalidate+0x3d2>
f010a2cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2d2:	8b 40 10             	mov    0x10(%eax),%eax
f010a2d5:	eb 05                	jmp    f010a2dc <env_page_ws_invalidate+0x3d7>
f010a2d7:	b8 00 00 00 00       	mov    $0x0,%eax
f010a2dc:	8b 55 08             	mov    0x8(%ebp),%edx
f010a2df:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a2e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2e8:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a2ee:	85 c0                	test   %eax,%eax
f010a2f0:	0f 85 dd fe ff ff    	jne    f010a1d3 <env_page_ws_invalidate+0x2ce>
f010a2f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a2fa:	0f 85 d3 fe ff ff    	jne    f010a1d3 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a300:	e9 5a 01 00 00       	jmp    f010a45f <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a305:	8b 45 08             	mov    0x8(%ebp),%eax
f010a308:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a30e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a311:	e9 10 01 00 00       	jmp    f010a426 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a316:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a319:	8b 00                	mov    (%eax),%eax
f010a31b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a31e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a321:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a326:	89 c2                	mov    %eax,%edx
f010a328:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a32b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a32e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a331:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a336:	39 c2                	cmp    %eax,%edx
f010a338:	0f 85 dc 00 00 00    	jne    f010a41a <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a33e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a341:	8b 10                	mov    (%eax),%edx
f010a343:	8b 45 08             	mov    0x8(%ebp),%eax
f010a346:	8b 40 64             	mov    0x64(%eax),%eax
f010a349:	83 ec 08             	sub    $0x8,%esp
f010a34c:	52                   	push   %edx
f010a34d:	50                   	push   %eax
f010a34e:	e8 8c e4 ff ff       	call   f01087df <unmap_frame>
f010a353:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a356:	8b 45 08             	mov    0x8(%ebp),%eax
f010a359:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a35f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a362:	75 0f                	jne    f010a373 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a364:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a367:	8b 50 10             	mov    0x10(%eax),%edx
f010a36a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a36d:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a373:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a377:	75 14                	jne    f010a38d <env_page_ws_invalidate+0x488>
f010a379:	83 ec 04             	sub    $0x4,%esp
f010a37c:	68 0b 5e 12 f0       	push   $0xf0125e0b
f010a381:	6a 5c                	push   $0x5c
f010a383:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a388:	e8 ac 5f ff ff       	call   f0100339 <_panic>
f010a38d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a390:	8b 40 10             	mov    0x10(%eax),%eax
f010a393:	85 c0                	test   %eax,%eax
f010a395:	74 11                	je     f010a3a8 <env_page_ws_invalidate+0x4a3>
f010a397:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a39a:	8b 40 10             	mov    0x10(%eax),%eax
f010a39d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a3a0:	8b 52 14             	mov    0x14(%edx),%edx
f010a3a3:	89 50 14             	mov    %edx,0x14(%eax)
f010a3a6:	eb 0f                	jmp    f010a3b7 <env_page_ws_invalidate+0x4b2>
f010a3a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3ab:	8b 50 14             	mov    0x14(%eax),%edx
f010a3ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3b1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a3b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3ba:	8b 40 14             	mov    0x14(%eax),%eax
f010a3bd:	85 c0                	test   %eax,%eax
f010a3bf:	74 11                	je     f010a3d2 <env_page_ws_invalidate+0x4cd>
f010a3c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3c4:	8b 40 14             	mov    0x14(%eax),%eax
f010a3c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a3ca:	8b 52 10             	mov    0x10(%edx),%edx
f010a3cd:	89 50 10             	mov    %edx,0x10(%eax)
f010a3d0:	eb 0f                	jmp    f010a3e1 <env_page_ws_invalidate+0x4dc>
f010a3d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3d5:	8b 50 10             	mov    0x10(%eax),%edx
f010a3d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3db:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a3e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3e4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a3eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3ee:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a3f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3f8:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a3fe:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a401:	8b 45 08             	mov    0x8(%ebp),%eax
f010a404:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a40a:	83 ec 0c             	sub    $0xc,%esp
f010a40d:	ff 75 ec             	pushl  -0x14(%ebp)
f010a410:	e8 75 f3 ff ff       	call   f010978a <kfree>
f010a415:	83 c4 10             	add    $0x10,%esp

				break;
f010a418:	eb 45                	jmp    f010a45f <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a41a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a41d:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a423:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a426:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a42a:	74 08                	je     f010a434 <env_page_ws_invalidate+0x52f>
f010a42c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a42f:	8b 40 10             	mov    0x10(%eax),%eax
f010a432:	eb 05                	jmp    f010a439 <env_page_ws_invalidate+0x534>
f010a434:	b8 00 00 00 00       	mov    $0x0,%eax
f010a439:	8b 55 08             	mov    0x8(%ebp),%edx
f010a43c:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a442:	8b 45 08             	mov    0x8(%ebp),%eax
f010a445:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a44b:	85 c0                	test   %eax,%eax
f010a44d:	0f 85 c3 fe ff ff    	jne    f010a316 <env_page_ws_invalidate+0x411>
f010a453:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a457:	0f 85 b9 fe ff ff    	jne    f010a316 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a45d:	eb 00                	jmp    f010a45f <env_page_ws_invalidate+0x55a>
f010a45f:	90                   	nop
f010a460:	c9                   	leave  
f010a461:	c3                   	ret    

f010a462 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a462:	55                   	push   %ebp
f010a463:	89 e5                	mov    %esp,%ebp
f010a465:	53                   	push   %ebx
f010a466:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a469:	83 ec 0c             	sub    $0xc,%esp
f010a46c:	6a 02                	push   $0x2
f010a46e:	e8 a8 51 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010a473:	83 c4 10             	add    $0x10,%esp
f010a476:	85 c0                	test   %eax,%eax
f010a478:	0f 84 fe 00 00 00    	je     f010a57c <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a47e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a485:	83 ec 0c             	sub    $0xc,%esp
f010a488:	68 4f 5e 12 f0       	push   $0xf0125e4f
f010a48d:	e8 f9 6a ff ff       	call   f0100f8b <cprintf>
f010a492:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a495:	8b 45 08             	mov    0x8(%ebp),%eax
f010a498:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a49e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4a1:	eb 2c                	jmp    f010a4cf <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a4a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4a6:	8b 10                	mov    (%eax),%edx
f010a4a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4ab:	8d 48 01             	lea    0x1(%eax),%ecx
f010a4ae:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a4b1:	83 ec 04             	sub    $0x4,%esp
f010a4b4:	52                   	push   %edx
f010a4b5:	50                   	push   %eax
f010a4b6:	68 69 5e 12 f0       	push   $0xf0125e69
f010a4bb:	e8 cb 6a ff ff       	call   f0100f8b <cprintf>
f010a4c0:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a4c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4c6:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4d3:	74 08                	je     f010a4dd <env_page_ws_print+0x7b>
f010a4d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4d8:	8b 40 10             	mov    0x10(%eax),%eax
f010a4db:	eb 05                	jmp    f010a4e2 <env_page_ws_print+0x80>
f010a4dd:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4e2:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4e5:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a4eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4ee:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4f4:	85 c0                	test   %eax,%eax
f010a4f6:	75 ab                	jne    f010a4a3 <env_page_ws_print+0x41>
f010a4f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4fc:	75 a5                	jne    f010a4a3 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a4fe:	83 ec 0c             	sub    $0xc,%esp
f010a501:	68 71 5e 12 f0       	push   $0xf0125e71
f010a506:	e8 80 6a ff ff       	call   f0100f8b <cprintf>
f010a50b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a50e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a511:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a517:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a51a:	eb 2c                	jmp    f010a548 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a51c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a51f:	8b 10                	mov    (%eax),%edx
f010a521:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a524:	8d 48 01             	lea    0x1(%eax),%ecx
f010a527:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a52a:	83 ec 04             	sub    $0x4,%esp
f010a52d:	52                   	push   %edx
f010a52e:	50                   	push   %eax
f010a52f:	68 69 5e 12 f0       	push   $0xf0125e69
f010a534:	e8 52 6a ff ff       	call   f0100f8b <cprintf>
f010a539:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a53c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a53f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a545:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a548:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a54c:	74 08                	je     f010a556 <env_page_ws_print+0xf4>
f010a54e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a551:	8b 40 10             	mov    0x10(%eax),%eax
f010a554:	eb 05                	jmp    f010a55b <env_page_ws_print+0xf9>
f010a556:	b8 00 00 00 00       	mov    $0x0,%eax
f010a55b:	8b 55 08             	mov    0x8(%ebp),%edx
f010a55e:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a564:	8b 45 08             	mov    0x8(%ebp),%eax
f010a567:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a56d:	85 c0                	test   %eax,%eax
f010a56f:	75 ab                	jne    f010a51c <env_page_ws_print+0xba>
f010a571:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a575:	75 a5                	jne    f010a51c <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a577:	e9 5a 01 00 00       	jmp    f010a6d6 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a57c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a583:	83 ec 0c             	sub    $0xc,%esp
f010a586:	68 8c 5e 12 f0       	push   $0xf0125e8c
f010a58b:	e8 fb 69 ff ff       	call   f0100f8b <cprintf>
f010a590:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a593:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a59a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a59d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a5a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a5a6:	e9 d1 00 00 00       	jmp    f010a67c <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a5ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a5ae:	8b 00                	mov    (%eax),%eax
f010a5b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a5b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a5b6:	8b 40 08             	mov    0x8(%eax),%eax
f010a5b9:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a5bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5bf:	8b 40 64             	mov    0x64(%eax),%eax
f010a5c2:	83 ec 08             	sub    $0x8,%esp
f010a5c5:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a5c8:	50                   	push   %eax
f010a5c9:	e8 5a f7 ff ff       	call   f0109d28 <pt_get_page_permissions>
f010a5ce:	83 c4 10             	add    $0x10,%esp
f010a5d1:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a5d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a5d7:	83 e0 40             	and    $0x40,%eax
f010a5da:	85 c0                	test   %eax,%eax
f010a5dc:	0f 95 c0             	setne  %al
f010a5df:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a5e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a5e5:	83 e0 20             	and    $0x20,%eax
f010a5e8:	85 c0                	test   %eax,%eax
f010a5ea:	0f 95 c0             	setne  %al
f010a5ed:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a5f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a5f3:	25 00 02 00 00       	and    $0x200,%eax
f010a5f8:	85 c0                	test   %eax,%eax
f010a5fa:	0f 95 c0             	setne  %al
f010a5fd:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a600:	83 ec 04             	sub    $0x4,%esp
f010a603:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a606:	ff 75 ec             	pushl  -0x14(%ebp)
f010a609:	68 96 5e 12 f0       	push   $0xf0125e96
f010a60e:	e8 78 69 ff ff       	call   f0100f8b <cprintf>
f010a613:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a616:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a619:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a61c:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a620:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a624:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a628:	83 ec 08             	sub    $0x8,%esp
f010a62b:	53                   	push   %ebx
f010a62c:	ff 75 e0             	pushl  -0x20(%ebp)
f010a62f:	51                   	push   %ecx
f010a630:	52                   	push   %edx
f010a631:	50                   	push   %eax
f010a632:	68 a0 5e 12 f0       	push   $0xf0125ea0
f010a637:	e8 4f 69 ff ff       	call   f0100f8b <cprintf>
f010a63c:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a63f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a642:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a648:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a64b:	75 10                	jne    f010a65d <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a64d:	83 ec 0c             	sub    $0xc,%esp
f010a650:	68 e7 5e 12 f0       	push   $0xf0125ee7
f010a655:	e8 31 69 ff ff       	call   f0100f8b <cprintf>
f010a65a:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a65d:	83 ec 0c             	sub    $0xc,%esp
f010a660:	68 ec 5e 12 f0       	push   $0xf0125eec
f010a665:	e8 21 69 ff ff       	call   f0100f8b <cprintf>
f010a66a:	83 c4 10             	add    $0x10,%esp
			i++;
f010a66d:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a670:	8b 45 08             	mov    0x8(%ebp),%eax
f010a673:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a679:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a67c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a680:	74 08                	je     f010a68a <env_page_ws_print+0x228>
f010a682:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a685:	8b 40 10             	mov    0x10(%eax),%eax
f010a688:	eb 05                	jmp    f010a68f <env_page_ws_print+0x22d>
f010a68a:	b8 00 00 00 00       	mov    $0x0,%eax
f010a68f:	8b 55 08             	mov    0x8(%ebp),%edx
f010a692:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a698:	8b 45 08             	mov    0x8(%ebp),%eax
f010a69b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a6a1:	85 c0                	test   %eax,%eax
f010a6a3:	0f 85 02 ff ff ff    	jne    f010a5ab <env_page_ws_print+0x149>
f010a6a9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a6ad:	0f 85 f8 fe ff ff    	jne    f010a5ab <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a6b3:	eb 13                	jmp    f010a6c8 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a6b5:	83 ec 0c             	sub    $0xc,%esp
f010a6b8:	68 ee 5e 12 f0       	push   $0xf0125eee
f010a6bd:	e8 c9 68 ff ff       	call   f0100f8b <cprintf>
f010a6c2:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a6c5:	ff 45 ec             	incl   -0x14(%ebp)
f010a6c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6cb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a6d1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a6d4:	77 df                	ja     f010a6b5 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a6d6:	90                   	nop
f010a6d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a6da:	c9                   	leave  
f010a6db:	c3                   	ret    

f010a6dc <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a6dc:	55                   	push   %ebp
f010a6dd:	89 e5                	mov    %esp,%ebp
f010a6df:	53                   	push   %ebx
f010a6e0:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a6e3:	83 ec 0c             	sub    $0xc,%esp
f010a6e6:	68 00 5f 12 f0       	push   $0xf0125f00
f010a6eb:	e8 9b 68 ff ff       	call   f0100f8b <cprintf>
f010a6f0:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a6f3:	83 ec 0c             	sub    $0xc,%esp
f010a6f6:	68 35 5f 12 f0       	push   $0xf0125f35
f010a6fb:	e8 8b 68 ff ff       	call   f0100f8b <cprintf>
f010a700:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a703:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a70a:	e9 16 01 00 00       	jmp    f010a825 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a70f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a712:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a715:	89 d0                	mov    %edx,%eax
f010a717:	01 c0                	add    %eax,%eax
f010a719:	01 d0                	add    %edx,%eax
f010a71b:	c1 e0 03             	shl    $0x3,%eax
f010a71e:	01 c8                	add    %ecx,%eax
f010a720:	05 b0 00 00 00       	add    $0xb0,%eax
f010a725:	8a 00                	mov    (%eax),%al
f010a727:	84 c0                	test   %al,%al
f010a729:	74 43                	je     f010a76e <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a72b:	83 ec 0c             	sub    $0xc,%esp
f010a72e:	68 40 5f 12 f0       	push   $0xf0125f40
f010a733:	e8 53 68 ff ff       	call   f0100f8b <cprintf>
f010a738:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a73b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a73e:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a744:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a747:	75 10                	jne    f010a759 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a749:	83 ec 0c             	sub    $0xc,%esp
f010a74c:	68 4f 5f 12 f0       	push   $0xf0125f4f
f010a751:	e8 35 68 ff ff       	call   f0100f8b <cprintf>
f010a756:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a759:	83 ec 0c             	sub    $0xc,%esp
f010a75c:	68 ec 5e 12 f0       	push   $0xf0125eec
f010a761:	e8 25 68 ff ff       	call   f0100f8b <cprintf>
f010a766:	83 c4 10             	add    $0x10,%esp
			continue;
f010a769:	e9 b4 00 00 00       	jmp    f010a822 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a76e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a771:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a774:	89 d0                	mov    %edx,%eax
f010a776:	01 c0                	add    %eax,%eax
f010a778:	01 d0                	add    %edx,%eax
f010a77a:	c1 e0 03             	shl    $0x3,%eax
f010a77d:	01 c8                	add    %ecx,%eax
f010a77f:	05 ac 00 00 00       	add    $0xac,%eax
f010a784:	8b 00                	mov    (%eax),%eax
f010a786:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a789:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a78c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a78f:	89 d0                	mov    %edx,%eax
f010a791:	01 c0                	add    %eax,%eax
f010a793:	01 d0                	add    %edx,%eax
f010a795:	c1 e0 03             	shl    $0x3,%eax
f010a798:	01 c8                	add    %ecx,%eax
f010a79a:	05 ac 00 00 00       	add    $0xac,%eax
f010a79f:	8b 00                	mov    (%eax),%eax
f010a7a1:	83 ec 04             	sub    $0x4,%esp
f010a7a4:	50                   	push   %eax
f010a7a5:	ff 75 f4             	pushl  -0xc(%ebp)
f010a7a8:	68 55 5f 12 f0       	push   $0xf0125f55
f010a7ad:	e8 d9 67 ff ff       	call   f0100f8b <cprintf>
f010a7b2:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a7b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7bb:	89 d0                	mov    %edx,%eax
f010a7bd:	01 c0                	add    %eax,%eax
f010a7bf:	01 d0                	add    %edx,%eax
f010a7c1:	c1 e0 03             	shl    $0x3,%eax
f010a7c4:	01 c8                	add    %ecx,%eax
f010a7c6:	05 b4 00 00 00       	add    $0xb4,%eax
f010a7cb:	8b 18                	mov    (%eax),%ebx
f010a7cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7d0:	8b 40 64             	mov    0x64(%eax),%eax
f010a7d3:	83 ec 08             	sub    $0x8,%esp
f010a7d6:	ff 75 f0             	pushl  -0x10(%ebp)
f010a7d9:	50                   	push   %eax
f010a7da:	e8 25 f6 ff ff       	call   f0109e04 <pd_is_table_used>
f010a7df:	83 c4 10             	add    $0x10,%esp
f010a7e2:	83 ec 04             	sub    $0x4,%esp
f010a7e5:	53                   	push   %ebx
f010a7e6:	50                   	push   %eax
f010a7e7:	68 6c 5f 12 f0       	push   $0xf0125f6c
f010a7ec:	e8 9a 67 ff ff       	call   f0100f8b <cprintf>
f010a7f1:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a7f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7f7:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a7fd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a800:	75 10                	jne    f010a812 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a802:	83 ec 0c             	sub    $0xc,%esp
f010a805:	68 e7 5e 12 f0       	push   $0xf0125ee7
f010a80a:	e8 7c 67 ff ff       	call   f0100f8b <cprintf>
f010a80f:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a812:	83 ec 0c             	sub    $0xc,%esp
f010a815:	68 ec 5e 12 f0       	push   $0xf0125eec
f010a81a:	e8 6c 67 ff ff       	call   f0100f8b <cprintf>
f010a81f:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a822:	ff 45 f4             	incl   -0xc(%ebp)
f010a825:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a829:	0f 86 e0 fe ff ff    	jbe    f010a70f <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a82f:	90                   	nop
f010a830:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a833:	c9                   	leave  
f010a834:	c3                   	ret    

f010a835 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a835:	55                   	push   %ebp
f010a836:	89 e5                	mov    %esp,%ebp
f010a838:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a83b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a842:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a849:	eb 22                	jmp    f010a86d <env_table_ws_get_size+0x38>
f010a84b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a84e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a851:	89 d0                	mov    %edx,%eax
f010a853:	01 c0                	add    %eax,%eax
f010a855:	01 d0                	add    %edx,%eax
f010a857:	c1 e0 03             	shl    $0x3,%eax
f010a85a:	01 c8                	add    %ecx,%eax
f010a85c:	05 b0 00 00 00       	add    $0xb0,%eax
f010a861:	8a 00                	mov    (%eax),%al
f010a863:	84 c0                	test   %al,%al
f010a865:	75 03                	jne    f010a86a <env_table_ws_get_size+0x35>
f010a867:	ff 45 f8             	incl   -0x8(%ebp)
f010a86a:	ff 45 fc             	incl   -0x4(%ebp)
f010a86d:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a871:	7e d8                	jle    f010a84b <env_table_ws_get_size+0x16>
	return counter;
f010a873:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a876:	c9                   	leave  
f010a877:	c3                   	ret    

f010a878 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a878:	55                   	push   %ebp
f010a879:	89 e5                	mov    %esp,%ebp
f010a87b:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a87e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a885:	eb 4e                	jmp    f010a8d5 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a887:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a88a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a88d:	89 d0                	mov    %edx,%eax
f010a88f:	01 c0                	add    %eax,%eax
f010a891:	01 d0                	add    %edx,%eax
f010a893:	c1 e0 03             	shl    $0x3,%eax
f010a896:	01 c8                	add    %ecx,%eax
f010a898:	05 ac 00 00 00       	add    $0xac,%eax
f010a89d:	8b 00                	mov    (%eax),%eax
f010a89f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a8a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a8a5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a8aa:	89 c2                	mov    %eax,%edx
f010a8ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a8af:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a8b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8b5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a8ba:	39 c2                	cmp    %eax,%edx
f010a8bc:	75 14                	jne    f010a8d2 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a8be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8c1:	83 ec 08             	sub    $0x8,%esp
f010a8c4:	50                   	push   %eax
f010a8c5:	ff 75 08             	pushl  0x8(%ebp)
f010a8c8:	e8 bc 00 00 00       	call   f010a989 <env_table_ws_clear_entry>
f010a8cd:	83 c4 10             	add    $0x10,%esp
			break;
f010a8d0:	eb 09                	jmp    f010a8db <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a8d2:	ff 45 f4             	incl   -0xc(%ebp)
f010a8d5:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a8d9:	7e ac                	jle    f010a887 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a8db:	90                   	nop
f010a8dc:	c9                   	leave  
f010a8dd:	c3                   	ret    

f010a8de <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a8de:	55                   	push   %ebp
f010a8df:	89 e5                	mov    %esp,%ebp
f010a8e1:	53                   	push   %ebx
f010a8e2:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a8e5:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a8e9:	76 19                	jbe    f010a904 <env_table_ws_set_entry+0x26>
f010a8eb:	68 90 5f 12 f0       	push   $0xf0125f90
f010a8f0:	68 c1 5f 12 f0       	push   $0xf0125fc1
f010a8f5:	68 3f 01 00 00       	push   $0x13f
f010a8fa:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a8ff:	e8 35 5a ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a904:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a90b:	76 19                	jbe    f010a926 <env_table_ws_set_entry+0x48>
f010a90d:	68 d8 5f 12 f0       	push   $0xf0125fd8
f010a912:	68 c1 5f 12 f0       	push   $0xf0125fc1
f010a917:	68 40 01 00 00       	push   $0x140
f010a91c:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a921:	e8 13 5a ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a926:	8b 45 10             	mov    0x10(%ebp),%eax
f010a929:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a92f:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a934:	89 c1                	mov    %eax,%ecx
f010a936:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a939:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a93c:	89 d0                	mov    %edx,%eax
f010a93e:	01 c0                	add    %eax,%eax
f010a940:	01 d0                	add    %edx,%eax
f010a942:	c1 e0 03             	shl    $0x3,%eax
f010a945:	01 d8                	add    %ebx,%eax
f010a947:	05 ac 00 00 00       	add    $0xac,%eax
f010a94c:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a94e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a951:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a954:	89 d0                	mov    %edx,%eax
f010a956:	01 c0                	add    %eax,%eax
f010a958:	01 d0                	add    %edx,%eax
f010a95a:	c1 e0 03             	shl    $0x3,%eax
f010a95d:	01 c8                	add    %ecx,%eax
f010a95f:	05 b0 00 00 00       	add    $0xb0,%eax
f010a964:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a967:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a96a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a96d:	89 d0                	mov    %edx,%eax
f010a96f:	01 c0                	add    %eax,%eax
f010a971:	01 d0                	add    %edx,%eax
f010a973:	c1 e0 03             	shl    $0x3,%eax
f010a976:	01 c8                	add    %ecx,%eax
f010a978:	05 b4 00 00 00       	add    $0xb4,%eax
f010a97d:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a983:	90                   	nop
}
f010a984:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a987:	c9                   	leave  
f010a988:	c3                   	ret    

f010a989 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a989:	55                   	push   %ebp
f010a98a:	89 e5                	mov    %esp,%ebp
f010a98c:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a98f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a993:	76 19                	jbe    f010a9ae <env_table_ws_clear_entry+0x25>
f010a995:	68 90 5f 12 f0       	push   $0xf0125f90
f010a99a:	68 c1 5f 12 f0       	push   $0xf0125fc1
f010a99f:	68 4b 01 00 00       	push   $0x14b
f010a9a4:	68 ec 5d 12 f0       	push   $0xf0125dec
f010a9a9:	e8 8b 59 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010a9ae:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9b1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9b4:	89 d0                	mov    %edx,%eax
f010a9b6:	01 c0                	add    %eax,%eax
f010a9b8:	01 d0                	add    %edx,%eax
f010a9ba:	c1 e0 03             	shl    $0x3,%eax
f010a9bd:	01 c8                	add    %ecx,%eax
f010a9bf:	05 ac 00 00 00       	add    $0xac,%eax
f010a9c4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010a9ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9d0:	89 d0                	mov    %edx,%eax
f010a9d2:	01 c0                	add    %eax,%eax
f010a9d4:	01 d0                	add    %edx,%eax
f010a9d6:	c1 e0 03             	shl    $0x3,%eax
f010a9d9:	01 c8                	add    %ecx,%eax
f010a9db:	05 b0 00 00 00       	add    $0xb0,%eax
f010a9e0:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010a9e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9e6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9e9:	89 d0                	mov    %edx,%eax
f010a9eb:	01 c0                	add    %eax,%eax
f010a9ed:	01 d0                	add    %edx,%eax
f010a9ef:	c1 e0 03             	shl    $0x3,%eax
f010a9f2:	01 c8                	add    %ecx,%eax
f010a9f4:	05 b4 00 00 00       	add    $0xb4,%eax
f010a9f9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010a9ff:	90                   	nop
f010aa00:	c9                   	leave  
f010aa01:	c3                   	ret    

f010aa02 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010aa02:	55                   	push   %ebp
f010aa03:	89 e5                	mov    %esp,%ebp
f010aa05:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa08:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa0c:	76 19                	jbe    f010aa27 <env_table_ws_get_virtual_address+0x25>
f010aa0e:	68 90 5f 12 f0       	push   $0xf0125f90
f010aa13:	68 c1 5f 12 f0       	push   $0xf0125fc1
f010aa18:	68 53 01 00 00       	push   $0x153
f010aa1d:	68 ec 5d 12 f0       	push   $0xf0125dec
f010aa22:	e8 12 59 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aa27:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa2a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa2d:	89 d0                	mov    %edx,%eax
f010aa2f:	01 c0                	add    %eax,%eax
f010aa31:	01 d0                	add    %edx,%eax
f010aa33:	c1 e0 03             	shl    $0x3,%eax
f010aa36:	01 c8                	add    %ecx,%eax
f010aa38:	05 ac 00 00 00       	add    $0xac,%eax
f010aa3d:	8b 00                	mov    (%eax),%eax
f010aa3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aa42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa45:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010aa4a:	c9                   	leave  
f010aa4b:	c3                   	ret    

f010aa4c <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010aa4c:	55                   	push   %ebp
f010aa4d:	89 e5                	mov    %esp,%ebp
f010aa4f:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa52:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa56:	76 19                	jbe    f010aa71 <env_table_ws_get_time_stamp+0x25>
f010aa58:	68 90 5f 12 f0       	push   $0xf0125f90
f010aa5d:	68 c1 5f 12 f0       	push   $0xf0125fc1
f010aa62:	68 5a 01 00 00       	push   $0x15a
f010aa67:	68 ec 5d 12 f0       	push   $0xf0125dec
f010aa6c:	e8 c8 58 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010aa71:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa74:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa77:	89 d0                	mov    %edx,%eax
f010aa79:	01 c0                	add    %eax,%eax
f010aa7b:	01 d0                	add    %edx,%eax
f010aa7d:	c1 e0 03             	shl    $0x3,%eax
f010aa80:	01 c8                	add    %ecx,%eax
f010aa82:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa87:	8b 00                	mov    (%eax),%eax
}
f010aa89:	c9                   	leave  
f010aa8a:	c3                   	ret    

f010aa8b <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010aa8b:	55                   	push   %ebp
f010aa8c:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010aa8e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa91:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa94:	89 d0                	mov    %edx,%eax
f010aa96:	01 c0                	add    %eax,%eax
f010aa98:	01 d0                	add    %edx,%eax
f010aa9a:	c1 e0 03             	shl    $0x3,%eax
f010aa9d:	01 c8                	add    %ecx,%eax
f010aa9f:	05 b0 00 00 00       	add    $0xb0,%eax
f010aaa4:	8a 00                	mov    (%eax),%al
f010aaa6:	0f b6 c0             	movzbl %al,%eax
}
f010aaa9:	5d                   	pop    %ebp
f010aaaa:	c3                   	ret    

f010aaab <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010aaab:	55                   	push   %ebp
f010aaac:	89 e5                	mov    %esp,%ebp
f010aaae:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010aab1:	83 ec 04             	sub    $0x4,%esp
f010aab4:	68 0b 60 12 f0       	push   $0xf012600b
f010aab9:	68 6a 01 00 00       	push   $0x16a
f010aabe:	68 ec 5d 12 f0       	push   $0xf0125dec
f010aac3:	e8 71 58 ff ff       	call   f0100339 <_panic>

f010aac8 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010aac8:	55                   	push   %ebp
f010aac9:	89 e5                	mov    %esp,%ebp
f010aacb:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010aace:	83 ec 04             	sub    $0x4,%esp
f010aad1:	68 0b 60 12 f0       	push   $0xf012600b
f010aad6:	68 6f 01 00 00       	push   $0x16f
f010aadb:	68 ec 5d 12 f0       	push   $0xf0125dec
f010aae0:	e8 54 58 ff ff       	call   f0100339 <_panic>

f010aae5 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010aae5:	55                   	push   %ebp
f010aae6:	89 e5                	mov    %esp,%ebp
f010aae8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010aaeb:	83 ec 04             	sub    $0x4,%esp
f010aaee:	68 1c 60 12 f0       	push   $0xf012601c
f010aaf3:	6a 22                	push   $0x22
f010aaf5:	68 4a 60 12 f0       	push   $0xf012604a
f010aafa:	e8 3a 58 ff ff       	call   f0100339 <_panic>

f010aaff <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010aaff:	55                   	push   %ebp
f010ab00:	89 e5                	mov    %esp,%ebp
f010ab02:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ab05:	83 ec 04             	sub    $0x4,%esp
f010ab08:	68 68 60 12 f0       	push   $0xf0126068
f010ab0d:	6a 35                	push   $0x35
f010ab0f:	68 4a 60 12 f0       	push   $0xf012604a
f010ab14:	e8 20 58 ff ff       	call   f0100339 <_panic>

f010ab19 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010ab19:	55                   	push   %ebp
f010ab1a:	89 e5                	mov    %esp,%ebp
f010ab1c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010ab1f:	83 ec 04             	sub    $0x4,%esp
f010ab22:	68 98 60 12 f0       	push   $0xf0126098
f010ab27:	6a 45                	push   $0x45
f010ab29:	68 4a 60 12 f0       	push   $0xf012604a
f010ab2e:	e8 06 58 ff ff       	call   f0100339 <_panic>

f010ab33 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010ab33:	55                   	push   %ebp
f010ab34:	89 e5                	mov    %esp,%ebp
f010ab36:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010ab39:	83 ec 04             	sub    $0x4,%esp
f010ab3c:	68 c4 60 12 f0       	push   $0xf01260c4
f010ab41:	6a 53                	push   $0x53
f010ab43:	68 4a 60 12 f0       	push   $0xf012604a
f010ab48:	e8 ec 57 ff ff       	call   f0100339 <_panic>

f010ab4d <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ab4d:	55                   	push   %ebp
f010ab4e:	89 e5                	mov    %esp,%ebp
f010ab50:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ab53:	83 ec 04             	sub    $0x4,%esp
f010ab56:	68 f4 60 12 f0       	push   $0xf01260f4
f010ab5b:	6a 5d                	push   $0x5d
f010ab5d:	68 4a 60 12 f0       	push   $0xf012604a
f010ab62:	e8 d2 57 ff ff       	call   f0100339 <_panic>

f010ab67 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010ab67:	55                   	push   %ebp
f010ab68:	89 e5                	mov    %esp,%ebp
f010ab6a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010ab6d:	83 ec 04             	sub    $0x4,%esp
f010ab70:	68 2c 61 12 f0       	push   $0xf012612c
f010ab75:	6a 6a                	push   $0x6a
f010ab77:	68 4a 60 12 f0       	push   $0xf012604a
f010ab7c:	e8 b8 57 ff ff       	call   f0100339 <_panic>

f010ab81 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010ab81:	55                   	push   %ebp
f010ab82:	89 e5                	mov    %esp,%ebp
f010ab84:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010ab87:	e8 54 0e 00 00       	call   f010b9e0 <get_cpu_proc>
f010ab8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010ab8f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ab93:	7e 61                	jle    f010abf6 <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010ab95:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab98:	c1 e0 0c             	shl    $0xc,%eax
f010ab9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010ab9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aba1:	8b 40 7c             	mov    0x7c(%eax),%eax
f010aba4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010aba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abaa:	8b 50 7c             	mov    0x7c(%eax),%edx
f010abad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010abb0:	01 c2                	add    %eax,%edx
f010abb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abb5:	8b 40 78             	mov    0x78(%eax),%eax
f010abb8:	39 c2                	cmp    %eax,%edx
f010abba:	77 09                	ja     f010abc5 <sys_sbrk+0x44>
f010abbc:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f010abc1:	85 c0                	test   %eax,%eax
f010abc3:	75 07                	jne    f010abcc <sys_sbrk+0x4b>
f010abc5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010abca:	eb 3d                	jmp    f010ac09 <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010abcc:	83 ec 04             	sub    $0x4,%esp
f010abcf:	ff 75 f0             	pushl  -0x10(%ebp)
f010abd2:	ff 75 ec             	pushl  -0x14(%ebp)
f010abd5:	ff 75 f4             	pushl  -0xc(%ebp)
f010abd8:	e8 2e 00 00 00       	call   f010ac0b <allocate_user_mem>
f010abdd:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010abe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abe3:	8b 50 7c             	mov    0x7c(%eax),%edx
f010abe6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010abe9:	01 c2                	add    %eax,%edx
f010abeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abee:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010abf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010abf4:	eb 13                	jmp    f010ac09 <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010abf6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010abfa:	75 08                	jne    f010ac04 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010abfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abff:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ac02:	eb 05                	jmp    f010ac09 <sys_sbrk+0x88>
	}

	return (void *)-1;
f010ac04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010ac09:	c9                   	leave  
f010ac0a:	c3                   	ret    

f010ac0b <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac0b:	55                   	push   %ebp
f010ac0c:	89 e5                	mov    %esp,%ebp
f010ac0e:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010ac11:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010ac18:	8b 55 10             	mov    0x10(%ebp),%edx
f010ac1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac1e:	01 d0                	add    %edx,%eax
f010ac20:	48                   	dec    %eax
f010ac21:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ac24:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac27:	ba 00 00 00 00       	mov    $0x0,%edx
f010ac2c:	f7 75 f0             	divl   -0x10(%ebp)
f010ac2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac32:	29 d0                	sub    %edx,%eax
f010ac34:	c1 e8 0c             	shr    $0xc,%eax
f010ac37:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010ac3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ac41:	eb 78                	jmp    f010acbb <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010ac43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac46:	c1 e0 0c             	shl    $0xc,%eax
f010ac49:	89 c2                	mov    %eax,%edx
f010ac4b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac4e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010ac51:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac54:	8b 40 64             	mov    0x64(%eax),%eax
f010ac57:	83 ec 04             	sub    $0x4,%esp
f010ac5a:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010ac5d:	52                   	push   %edx
f010ac5e:	51                   	push   %ecx
f010ac5f:	50                   	push   %eax
f010ac60:	e8 8a d7 ff ff       	call   f01083ef <get_page_table>
f010ac65:	83 c4 10             	add    $0x10,%esp
f010ac68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010ac6b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010ac6f:	75 23                	jne    f010ac94 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac74:	c1 e0 0c             	shl    $0xc,%eax
f010ac77:	89 c2                	mov    %eax,%edx
f010ac79:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac7c:	01 c2                	add    %eax,%edx
f010ac7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac81:	8b 40 64             	mov    0x64(%eax),%eax
f010ac84:	83 ec 08             	sub    $0x8,%esp
f010ac87:	52                   	push   %edx
f010ac88:	50                   	push   %eax
f010ac89:	e8 b7 d8 ff ff       	call   f0108545 <create_page_table>
f010ac8e:	83 c4 10             	add    $0x10,%esp
f010ac91:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010ac94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac97:	c1 e0 0c             	shl    $0xc,%eax
f010ac9a:	89 c2                	mov    %eax,%edx
f010ac9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac9f:	01 c2                	add    %eax,%edx
f010aca1:	8b 45 08             	mov    0x8(%ebp),%eax
f010aca4:	8b 40 64             	mov    0x64(%eax),%eax
f010aca7:	6a 00                	push   $0x0
f010aca9:	68 00 02 00 00       	push   $0x200
f010acae:	52                   	push   %edx
f010acaf:	50                   	push   %eax
f010acb0:	e8 af ef ff ff       	call   f0109c64 <pt_set_page_permissions>
f010acb5:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010acb8:	ff 45 f4             	incl   -0xc(%ebp)
f010acbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acbe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010acc1:	72 80                	jb     f010ac43 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010acc3:	90                   	nop
f010acc4:	c9                   	leave  
f010acc5:	c3                   	ret    

f010acc6 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010acc6:	55                   	push   %ebp
f010acc7:	89 e5                	mov    %esp,%ebp
f010acc9:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010accc:	8b 45 10             	mov    0x10(%ebp),%eax
f010accf:	c1 e0 0c             	shl    $0xc,%eax
f010acd2:	89 c2                	mov    %eax,%edx
f010acd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acd7:	01 c2                	add    %eax,%edx
f010acd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010acdc:	8b 40 64             	mov    0x64(%eax),%eax
f010acdf:	68 00 02 00 00       	push   $0x200
f010ace4:	6a 00                	push   $0x0
f010ace6:	52                   	push   %edx
f010ace7:	50                   	push   %eax
f010ace8:	e8 77 ef ff ff       	call   f0109c64 <pt_set_page_permissions>
f010aced:	83 c4 10             	add    $0x10,%esp
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
f010acf0:	8b 45 10             	mov    0x10(%ebp),%eax
f010acf3:	c1 e0 0c             	shl    $0xc,%eax
f010acf6:	89 c2                	mov    %eax,%edx
f010acf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acfb:	01 d0                	add    %edx,%eax
f010acfd:	83 ec 08             	sub    $0x8,%esp
f010ad00:	50                   	push   %eax
f010ad01:	ff 75 08             	pushl  0x8(%ebp)
f010ad04:	e8 d8 97 ff ff       	call   f01044e1 <pf_read_env_page>
f010ad09:	83 c4 10             	add    $0x10,%esp
f010ad0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
f010ad0f:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%ebp)
f010ad13:	75 1e                	jne    f010ad33 <free_user_mem+0x6d>
f010ad15:	8b 45 10             	mov    0x10(%ebp),%eax
f010ad18:	c1 e0 0c             	shl    $0xc,%eax
f010ad1b:	89 c2                	mov    %eax,%edx
f010ad1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad20:	01 d0                	add    %edx,%eax
f010ad22:	83 ec 08             	sub    $0x8,%esp
f010ad25:	50                   	push   %eax
f010ad26:	ff 75 08             	pushl  0x8(%ebp)
f010ad29:	e8 d7 f1 ff ff       	call   f0109f05 <env_page_ws_invalidate>
f010ad2e:	83 c4 10             	add    $0x10,%esp
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);


}
f010ad31:	eb 1c                	jmp    f010ad4f <free_user_mem+0x89>
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);
f010ad33:	8b 45 10             	mov    0x10(%ebp),%eax
f010ad36:	c1 e0 0c             	shl    $0xc,%eax
f010ad39:	89 c2                	mov    %eax,%edx
f010ad3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad3e:	01 d0                	add    %edx,%eax
f010ad40:	83 ec 08             	sub    $0x8,%esp
f010ad43:	50                   	push   %eax
f010ad44:	ff 75 08             	pushl  0x8(%ebp)
f010ad47:	e8 58 98 ff ff       	call   f01045a4 <pf_remove_env_page>
f010ad4c:	83 c4 10             	add    $0x10,%esp


}
f010ad4f:	90                   	nop
f010ad50:	c9                   	leave  
f010ad51:	c3                   	ret    

f010ad52 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ad52:	55                   	push   %ebp
f010ad53:	89 e5                	mov    %esp,%ebp
f010ad55:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010ad58:	83 ec 04             	sub    $0x4,%esp
f010ad5b:	68 64 61 12 f0       	push   $0xf0126164
f010ad60:	68 de 00 00 00       	push   $0xde
f010ad65:	68 4a 60 12 f0       	push   $0xf012604a
f010ad6a:	e8 ca 55 ff ff       	call   f0100339 <_panic>

f010ad6f <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ad6f:	55                   	push   %ebp
f010ad70:	89 e5                	mov    %esp,%ebp
f010ad72:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010ad75:	83 ec 04             	sub    $0x4,%esp
f010ad78:	68 a4 61 12 f0       	push   $0xf01261a4
f010ad7d:	68 e8 00 00 00       	push   $0xe8
f010ad82:	68 4a 60 12 f0       	push   $0xf012604a
f010ad87:	e8 ad 55 ff ff       	call   f0100339 <_panic>

f010ad8c <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010ad8c:	55                   	push   %ebp
f010ad8d:	89 e5                	mov    %esp,%ebp
f010ad8f:	56                   	push   %esi
f010ad90:	53                   	push   %ebx
f010ad91:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010ad94:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010ad9b:	e9 b0 01 00 00       	jmp    f010af50 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010ada0:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010ada6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ada9:	89 d0                	mov    %edx,%eax
f010adab:	c1 e0 03             	shl    $0x3,%eax
f010adae:	01 d0                	add    %edx,%eax
f010adb0:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010adb7:	01 d8                	add    %ebx,%eax
f010adb9:	01 c0                	add    %eax,%eax
f010adbb:	01 d0                	add    %edx,%eax
f010adbd:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010adc4:	01 d8                	add    %ebx,%eax
f010adc6:	01 d0                	add    %edx,%eax
f010adc8:	01 c8                	add    %ecx,%eax
f010adca:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010add1:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010add7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adda:	89 d0                	mov    %edx,%eax
f010addc:	c1 e0 03             	shl    $0x3,%eax
f010addf:	01 d0                	add    %edx,%eax
f010ade1:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ade8:	01 d8                	add    %ebx,%eax
f010adea:	01 c0                	add    %eax,%eax
f010adec:	01 d0                	add    %edx,%eax
f010adee:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010adf5:	01 d8                	add    %ebx,%eax
f010adf7:	01 d0                	add    %edx,%eax
f010adf9:	01 c8                	add    %ecx,%eax
f010adfb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010ae02:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010ae08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae0b:	89 d0                	mov    %edx,%eax
f010ae0d:	c1 e0 03             	shl    $0x3,%eax
f010ae10:	01 d0                	add    %edx,%eax
f010ae12:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae19:	01 d8                	add    %ebx,%eax
f010ae1b:	01 c0                	add    %eax,%eax
f010ae1d:	01 d0                	add    %edx,%eax
f010ae1f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae26:	01 d8                	add    %ebx,%eax
f010ae28:	01 d0                	add    %edx,%eax
f010ae2a:	01 c8                	add    %ecx,%eax
f010ae2c:	85 c0                	test   %eax,%eax
f010ae2e:	75 14                	jne    f010ae44 <env_init+0xb8>
f010ae30:	83 ec 04             	sub    $0x4,%esp
f010ae33:	68 d0 61 12 f0       	push   $0xf01261d0
f010ae38:	6a 65                	push   $0x65
f010ae3a:	68 f3 61 12 f0       	push   $0xf01261f3
f010ae3f:	e8 f5 54 ff ff       	call   f0100339 <_panic>
f010ae44:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010ae4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae4d:	89 d0                	mov    %edx,%eax
f010ae4f:	c1 e0 03             	shl    $0x3,%eax
f010ae52:	01 d0                	add    %edx,%eax
f010ae54:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae5b:	01 d8                	add    %ebx,%eax
f010ae5d:	01 c0                	add    %eax,%eax
f010ae5f:	01 d0                	add    %edx,%eax
f010ae61:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae68:	01 d8                	add    %ebx,%eax
f010ae6a:	01 d0                	add    %edx,%eax
f010ae6c:	01 c8                	add    %ecx,%eax
f010ae6e:	8b 15 78 a3 69 f0    	mov    0xf069a378,%edx
f010ae74:	89 50 08             	mov    %edx,0x8(%eax)
f010ae77:	8b 40 08             	mov    0x8(%eax),%eax
f010ae7a:	85 c0                	test   %eax,%eax
f010ae7c:	74 35                	je     f010aeb3 <env_init+0x127>
f010ae7e:	8b 0d 78 a3 69 f0    	mov    0xf069a378,%ecx
f010ae84:	8b 1d 74 a3 69 f0    	mov    0xf069a374,%ebx
f010ae8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae8d:	89 d0                	mov    %edx,%eax
f010ae8f:	c1 e0 03             	shl    $0x3,%eax
f010ae92:	01 d0                	add    %edx,%eax
f010ae94:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010ae9b:	01 f0                	add    %esi,%eax
f010ae9d:	01 c0                	add    %eax,%eax
f010ae9f:	01 d0                	add    %edx,%eax
f010aea1:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010aea8:	01 f0                	add    %esi,%eax
f010aeaa:	01 d0                	add    %edx,%eax
f010aeac:	01 d8                	add    %ebx,%eax
f010aeae:	89 41 0c             	mov    %eax,0xc(%ecx)
f010aeb1:	eb 2f                	jmp    f010aee2 <env_init+0x156>
f010aeb3:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010aeb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aebc:	89 d0                	mov    %edx,%eax
f010aebe:	c1 e0 03             	shl    $0x3,%eax
f010aec1:	01 d0                	add    %edx,%eax
f010aec3:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aeca:	01 d8                	add    %ebx,%eax
f010aecc:	01 c0                	add    %eax,%eax
f010aece:	01 d0                	add    %edx,%eax
f010aed0:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aed7:	01 d8                	add    %ebx,%eax
f010aed9:	01 d0                	add    %edx,%eax
f010aedb:	01 c8                	add    %ecx,%eax
f010aedd:	a3 7c a3 69 f0       	mov    %eax,0xf069a37c
f010aee2:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010aee8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aeeb:	89 d0                	mov    %edx,%eax
f010aeed:	c1 e0 03             	shl    $0x3,%eax
f010aef0:	01 d0                	add    %edx,%eax
f010aef2:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aef9:	01 d8                	add    %ebx,%eax
f010aefb:	01 c0                	add    %eax,%eax
f010aefd:	01 d0                	add    %edx,%eax
f010aeff:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af06:	01 d8                	add    %ebx,%eax
f010af08:	01 d0                	add    %edx,%eax
f010af0a:	01 c8                	add    %ecx,%eax
f010af0c:	a3 78 a3 69 f0       	mov    %eax,0xf069a378
f010af11:	8b 0d 74 a3 69 f0    	mov    0xf069a374,%ecx
f010af17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af1a:	89 d0                	mov    %edx,%eax
f010af1c:	c1 e0 03             	shl    $0x3,%eax
f010af1f:	01 d0                	add    %edx,%eax
f010af21:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af28:	01 d8                	add    %ebx,%eax
f010af2a:	01 c0                	add    %eax,%eax
f010af2c:	01 d0                	add    %edx,%eax
f010af2e:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af35:	01 d8                	add    %ebx,%eax
f010af37:	01 d0                	add    %edx,%eax
f010af39:	01 c8                	add    %ecx,%eax
f010af3b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010af42:	a1 84 a3 69 f0       	mov    0xf069a384,%eax
f010af47:	40                   	inc    %eax
f010af48:	a3 84 a3 69 f0       	mov    %eax,0xf069a384
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010af4d:	ff 4d f4             	decl   -0xc(%ebp)
f010af50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010af54:	0f 89 46 fe ff ff    	jns    f010ada0 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010af5a:	90                   	nop
f010af5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010af5e:	5b                   	pop    %ebx
f010af5f:	5e                   	pop    %esi
f010af60:	5d                   	pop    %ebp
f010af61:	c3                   	ret    

f010af62 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010af62:	55                   	push   %ebp
f010af63:	89 e5                	mov    %esp,%ebp
f010af65:	57                   	push   %edi
f010af66:	56                   	push   %esi
f010af67:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010af6d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010af74:	83 ec 0c             	sub    $0xc,%esp
f010af77:	ff 75 08             	pushl  0x8(%ebp)
f010af7a:	e8 b8 1e 00 00       	call   f010ce37 <get_user_program_info>
f010af7f:	83 c4 10             	add    $0x10,%esp
f010af82:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010af85:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010af89:	75 0a                	jne    f010af95 <env_create+0x33>
	{
		return NULL;
f010af8b:	b8 00 00 00 00       	mov    $0x0,%eax
f010af90:	e9 aa 09 00 00       	jmp    f010b93f <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010af95:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010af98:	8b 40 08             	mov    0x8(%eax),%eax
f010af9b:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010af9e:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010afa5:	00 00 00 
	if(allocate_environment(&e) < 0)
f010afa8:	83 ec 0c             	sub    $0xc,%esp
f010afab:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010afb1:	50                   	push   %eax
f010afb2:	e8 96 0e 00 00       	call   f010be4d <allocate_environment>
f010afb7:	83 c4 10             	add    $0x10,%esp
f010afba:	85 c0                	test   %eax,%eax
f010afbc:	79 0a                	jns    f010afc8 <env_create+0x66>
	{
		return NULL;
f010afbe:	b8 00 00 00 00       	mov    $0x0,%eax
f010afc3:	e9 77 09 00 00       	jmp    f010b93f <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010afc8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010afcb:	8b 00                	mov    (%eax),%eax
f010afcd:	83 ec 0c             	sub    $0xc,%esp
f010afd0:	50                   	push   %eax
f010afd1:	e8 46 4c 01 00       	call   f011fc1c <strlen>
f010afd6:	83 c4 10             	add    $0x10,%esp
f010afd9:	83 f8 3f             	cmp    $0x3f,%eax
f010afdc:	7f 1d                	jg     f010affb <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010afde:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010afe1:	8b 00                	mov    (%eax),%eax
f010afe3:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010afe9:	83 c2 20             	add    $0x20,%edx
f010afec:	83 ec 08             	sub    $0x8,%esp
f010afef:	50                   	push   %eax
f010aff0:	52                   	push   %edx
f010aff1:	e8 75 4c 01 00       	call   f011fc6b <strcpy>
f010aff6:	83 c4 10             	add    $0x10,%esp
f010aff9:	eb 1d                	jmp    f010b018 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010affb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010affe:	8b 00                	mov    (%eax),%eax
f010b000:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b006:	83 c2 20             	add    $0x20,%edx
f010b009:	83 ec 04             	sub    $0x4,%esp
f010b00c:	6a 3f                	push   $0x3f
f010b00e:	50                   	push   %eax
f010b00f:	52                   	push   %edx
f010b010:	e8 84 4c 01 00       	call   f011fc99 <strncpy>
f010b015:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b018:	e8 fc 13 00 00       	call   f010c419 <create_user_directory>
f010b01d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b020:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b023:	83 ec 0c             	sub    $0xc,%esp
f010b026:	50                   	push   %eax
f010b027:	e8 44 e8 ff ff       	call   f0109870 <kheap_physical_address>
f010b02c:	83 c4 10             	add    $0x10,%esp
f010b02f:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b032:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b038:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b03b:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b041:	83 ec 0c             	sub    $0xc,%esp
f010b044:	6a 02                	push   $0x2
f010b046:	e8 d0 45 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010b04b:	83 c4 10             	add    $0x10,%esp
f010b04e:	85 c0                	test   %eax,%eax
f010b050:	74 21                	je     f010b073 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b052:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b058:	8b 55 10             	mov    0x10(%ebp),%edx
f010b05b:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b061:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b067:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b06a:	2b 55 10             	sub    0x10(%ebp),%edx
f010b06d:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b073:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b077:	75 12                	jne    f010b08b <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b079:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b07f:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b086:	00 00 00 
f010b089:	eb 0f                	jmp    f010b09a <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b08b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b091:	8b 55 14             	mov    0x14(%ebp),%edx
f010b094:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b09a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0a0:	83 ec 04             	sub    $0x4,%esp
f010b0a3:	ff 75 bc             	pushl  -0x44(%ebp)
f010b0a6:	ff 75 c0             	pushl  -0x40(%ebp)
f010b0a9:	50                   	push   %eax
f010b0aa:	e8 c8 14 00 00       	call   f010c577 <initialize_environment>
f010b0af:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b0b2:	e8 18 c1 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b0b7:	0f 20 d8             	mov    %cr3,%eax
f010b0ba:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b0bd:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b0c0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b0c3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0c9:	8b 40 68             	mov    0x68(%eax),%eax
f010b0cc:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b0d2:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b0d8:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b0db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b0e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b0e9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0ef:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b0f5:	48                   	dec    %eax
f010b0f6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b0f9:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b100:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b103:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b109:	83 ec 08             	sub    $0x8,%esp
f010b10c:	ff 75 c8             	pushl  -0x38(%ebp)
f010b10f:	50                   	push   %eax
f010b110:	e8 34 1a 00 00       	call   f010cb49 <PROGRAM_SEGMENT_FIRST>
f010b115:	83 c4 0c             	add    $0xc,%esp
f010b118:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b11e:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b124:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b129:	89 c7                	mov    %eax,%edi
f010b12b:	89 d6                	mov    %edx,%esi
f010b12d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b12f:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b135:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b138:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b13b:	8b 40 10             	mov    0x10(%eax),%eax
f010b13e:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b141:	75 07                	jne    f010b14a <env_create+0x1e8>
f010b143:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b14a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b14d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b150:	e9 fa 02 00 00       	jmp    f010b44f <env_create+0x4ed>
		{
			segment_counter++;
f010b155:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b158:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b15f:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b162:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b168:	83 ec 0c             	sub    $0xc,%esp
f010b16b:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b171:	52                   	push   %edx
f010b172:	ff 75 ec             	pushl  -0x14(%ebp)
f010b175:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b17b:	52                   	push   %edx
f010b17c:	ff 75 f4             	pushl  -0xc(%ebp)
f010b17f:	50                   	push   %eax
f010b180:	e8 86 0d 00 00       	call   f010bf0b <program_segment_alloc_map_copy_workingset>
f010b185:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b188:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b18e:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b191:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b194:	8b 00                	mov    (%eax),%eax
f010b196:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b199:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b19c:	8b 40 0c             	mov    0xc(%eax),%eax
f010b19f:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b1a2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b1a5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b1a8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b1ab:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b1b0:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b1b3:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b1ba:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b1bd:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b1c0:	01 d0                	add    %edx,%eax
f010b1c2:	48                   	dec    %eax
f010b1c3:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b1c6:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b1c9:	ba 00 00 00 00       	mov    $0x0,%edx
f010b1ce:	f7 75 9c             	divl   -0x64(%ebp)
f010b1d1:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b1d4:	29 d0                	sub    %edx,%eax
f010b1d6:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b1d9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b1dc:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b1df:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b1e2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b1e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b1e8:	8b 15 cc 35 ec f0    	mov    0xf0ec35cc,%edx
f010b1ee:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b1f1:	01 d0                	add    %edx,%eax
f010b1f3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b1f6:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b1fa:	74 73                	je     f010b26f <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b1fc:	a1 cc 35 ec f0       	mov    0xf0ec35cc,%eax
f010b201:	83 ec 04             	sub    $0x4,%esp
f010b204:	68 00 10 00 00       	push   $0x1000
f010b209:	6a 00                	push   $0x0
f010b20b:	50                   	push   %eax
f010b20c:	e8 f9 4b 01 00       	call   f011fe0a <memset>
f010b211:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b214:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b217:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b21a:	eb 13                	jmp    f010b22f <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b21c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b21f:	8a 10                	mov    (%eax),%dl
f010b221:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b224:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b226:	ff 45 dc             	incl   -0x24(%ebp)
f010b229:	ff 45 e4             	incl   -0x1c(%ebp)
f010b22c:	ff 45 e0             	incl   -0x20(%ebp)
f010b22f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b232:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b235:	72 e5                	jb     f010b21c <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b237:	8b 15 cc 35 ec f0    	mov    0xf0ec35cc,%edx
f010b23d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b243:	83 ec 04             	sub    $0x4,%esp
f010b246:	52                   	push   %edx
f010b247:	ff 75 a0             	pushl  -0x60(%ebp)
f010b24a:	50                   	push   %eax
f010b24b:	e8 e1 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b250:	83 c4 10             	add    $0x10,%esp
f010b253:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b256:	75 17                	jne    f010b26f <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b258:	83 ec 04             	sub    $0x4,%esp
f010b25b:	68 10 62 12 f0       	push   $0xf0126210
f010b260:	68 f5 00 00 00       	push   $0xf5
f010b265:	68 f3 61 12 f0       	push   $0xf01261f3
f010b26a:	e8 ca 50 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b26f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b272:	8b 50 04             	mov    0x4(%eax),%edx
f010b275:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b278:	01 d0                	add    %edx,%eax
f010b27a:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b27d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b280:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b285:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b288:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b28b:	8b 50 04             	mov    0x4(%eax),%edx
f010b28e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b291:	01 d0                	add    %edx,%eax
f010b293:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b296:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b299:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b29c:	eb 43                	jmp    f010b2e1 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b29e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b2a1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2a7:	83 ec 04             	sub    $0x4,%esp
f010b2aa:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b2ad:	52                   	push   %edx
f010b2ae:	50                   	push   %eax
f010b2af:	e8 7d 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b2b4:	83 c4 10             	add    $0x10,%esp
f010b2b7:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b2ba:	75 17                	jne    f010b2d3 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b2bc:	83 ec 04             	sub    $0x4,%esp
f010b2bf:	68 10 62 12 f0       	push   $0xf0126210
f010b2c4:	68 02 01 00 00       	push   $0x102
f010b2c9:	68 f3 61 12 f0       	push   $0xf01261f3
f010b2ce:	e8 66 50 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b2d3:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b2da:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b2e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b2e4:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b2e7:	72 b5                	jb     f010b29e <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b2e9:	a1 cc 35 ec f0       	mov    0xf0ec35cc,%eax
f010b2ee:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b2f1:	83 ec 04             	sub    $0x4,%esp
f010b2f4:	68 00 10 00 00       	push   $0x1000
f010b2f9:	6a 00                	push   $0x0
f010b2fb:	ff 75 e0             	pushl  -0x20(%ebp)
f010b2fe:	e8 07 4b 01 00       	call   f011fe0a <memset>
f010b303:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b306:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b309:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b30c:	eb 13                	jmp    f010b321 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b30e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b311:	8a 10                	mov    (%eax),%dl
f010b313:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b316:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b318:	ff 45 dc             	incl   -0x24(%ebp)
f010b31b:	ff 45 e4             	incl   -0x1c(%ebp)
f010b31e:	ff 45 e0             	incl   -0x20(%ebp)
f010b321:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b324:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b327:	72 e5                	jb     f010b30e <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b329:	8b 15 cc 35 ec f0    	mov    0xf0ec35cc,%edx
f010b32f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b335:	83 ec 04             	sub    $0x4,%esp
f010b338:	52                   	push   %edx
f010b339:	ff 75 88             	pushl  -0x78(%ebp)
f010b33c:	50                   	push   %eax
f010b33d:	e8 ef 8e ff ff       	call   f0104231 <pf_add_env_page>
f010b342:	83 c4 10             	add    $0x10,%esp
f010b345:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b348:	75 17                	jne    f010b361 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b34a:	83 ec 04             	sub    $0x4,%esp
f010b34d:	68 10 62 12 f0       	push   $0xf0126210
f010b352:	68 11 01 00 00       	push   $0x111
f010b357:	68 f3 61 12 f0       	push   $0xf01261f3
f010b35c:	e8 d8 4f ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b361:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b368:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b36b:	8b 50 04             	mov    0x4(%eax),%edx
f010b36e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b371:	01 c2                	add    %eax,%edx
f010b373:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b376:	01 d0                	add    %edx,%eax
f010b378:	48                   	dec    %eax
f010b379:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b37f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b385:	ba 00 00 00 00       	mov    $0x0,%edx
f010b38a:	f7 75 80             	divl   -0x80(%ebp)
f010b38d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b393:	29 d0                	sub    %edx,%eax
f010b395:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b398:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b39b:	8b 50 08             	mov    0x8(%eax),%edx
f010b39e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b3a1:	01 d0                	add    %edx,%eax
f010b3a3:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b3a6:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b3ac:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b3b3:	eb 41                	jmp    f010b3f6 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b3b5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3bb:	83 ec 04             	sub    $0x4,%esp
f010b3be:	6a 01                	push   $0x1
f010b3c0:	ff 75 d8             	pushl  -0x28(%ebp)
f010b3c3:	50                   	push   %eax
f010b3c4:	e8 37 8d ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b3c9:	83 c4 10             	add    $0x10,%esp
f010b3cc:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b3cf:	75 17                	jne    f010b3e8 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b3d1:	83 ec 04             	sub    $0x4,%esp
f010b3d4:	68 10 62 12 f0       	push   $0xf0126210
f010b3d9:	68 1e 01 00 00       	push   $0x11e
f010b3de:	68 f3 61 12 f0       	push   $0xf01261f3
f010b3e3:	e8 51 4f ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b3e8:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b3ef:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b3f6:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b3fd:	10 00 00 
f010b400:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b406:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b40c:	01 d0                	add    %edx,%eax
f010b40e:	48                   	dec    %eax
f010b40f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b415:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b41b:	ba 00 00 00 00       	mov    $0x0,%edx
f010b420:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b426:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b42c:	29 d0                	sub    %edx,%eax
f010b42e:	89 c2                	mov    %eax,%edx
f010b430:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b433:	39 c2                	cmp    %eax,%edx
f010b435:	0f 87 7a ff ff ff    	ja     f010b3b5 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b43b:	83 ec 08             	sub    $0x8,%esp
f010b43e:	ff 75 c8             	pushl  -0x38(%ebp)
f010b441:	ff 75 f4             	pushl  -0xc(%ebp)
f010b444:	e8 f5 15 00 00       	call   f010ca3e <PROGRAM_SEGMENT_NEXT>
f010b449:	83 c4 10             	add    $0x10,%esp
f010b44c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b44f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b453:	0f 85 fc fc ff ff    	jne    f010b155 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b459:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b45f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b465:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b468:	eb 77                	jmp    f010b4e1 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b46a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b46d:	8b 00                	mov    (%eax),%eax
f010b46f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b475:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b47b:	8b 40 64             	mov    0x64(%eax),%eax
f010b47e:	83 ec 04             	sub    $0x4,%esp
f010b481:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b487:	52                   	push   %edx
f010b488:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b48e:	50                   	push   %eax
f010b48f:	e8 5b cf ff ff       	call   f01083ef <get_page_table>
f010b494:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b497:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b49d:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b4a3:	c1 ea 0c             	shr    $0xc,%edx
f010b4a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b4ac:	c1 e2 02             	shl    $0x2,%edx
f010b4af:	01 d0                	add    %edx,%eax
f010b4b1:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b4b7:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b4bd:	c1 e9 0c             	shr    $0xc,%ecx
f010b4c0:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b4c6:	c1 e1 02             	shl    $0x2,%ecx
f010b4c9:	01 ca                	add    %ecx,%edx
f010b4cb:	8b 12                	mov    (%edx),%edx
f010b4cd:	83 e2 bf             	and    $0xffffffbf,%edx
f010b4d0:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b4d2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4d8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b4de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b4e1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4e7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b4eb:	74 08                	je     f010b4f5 <env_create+0x593>
f010b4ed:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b4f0:	8b 52 10             	mov    0x10(%edx),%edx
f010b4f3:	eb 05                	jmp    f010b4fa <env_create+0x598>
f010b4f5:	ba 00 00 00 00       	mov    $0x0,%edx
f010b4fa:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b500:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b506:	85 c0                	test   %eax,%eax
f010b508:	0f 85 5c ff ff ff    	jne    f010b46a <env_create+0x508>
f010b50e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b512:	0f 85 52 ff ff ff    	jne    f010b46a <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b518:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b51b:	8b 50 08             	mov    0x8(%eax),%edx
f010b51e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b524:	83 ec 08             	sub    $0x8,%esp
f010b527:	52                   	push   %edx
f010b528:	50                   	push   %eax
f010b529:	e8 d0 14 00 00       	call   f010c9fe <set_environment_entry_point>
f010b52e:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b531:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b537:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b53e:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b545:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b548:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b54f:	e9 42 03 00 00       	jmp    f010b896 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b554:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b55b:	00 00 00 
			allocate_frame(&pp);
f010b55e:	83 ec 0c             	sub    $0xc,%esp
f010b561:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b567:	50                   	push   %eax
f010b568:	e8 45 cc ff ff       	call   f01081b2 <allocate_frame>
f010b56d:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b570:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b576:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b57c:	8b 40 64             	mov    0x64(%eax),%eax
f010b57f:	6a 06                	push   $0x6
f010b581:	ff 75 d0             	pushl  -0x30(%ebp)
f010b584:	52                   	push   %edx
f010b585:	50                   	push   %eax
f010b586:	e8 f8 d2 ff ff       	call   f0108883 <loadtime_map_frame>
f010b58b:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b58e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b591:	83 ec 04             	sub    $0x4,%esp
f010b594:	68 00 10 00 00       	push   $0x1000
f010b599:	6a 00                	push   $0x0
f010b59b:	50                   	push   %eax
f010b59c:	e8 69 48 01 00       	call   f011fe0a <memset>
f010b5a1:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b5a4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5aa:	83 ec 08             	sub    $0x8,%esp
f010b5ad:	ff 75 d0             	pushl  -0x30(%ebp)
f010b5b0:	50                   	push   %eax
f010b5b1:	e8 e4 e8 ff ff       	call   f0109e9a <env_page_ws_list_create_element>
f010b5b6:	83 c4 10             	add    $0x10,%esp
f010b5b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b5bc:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b5c0:	75 17                	jne    f010b5d9 <env_create+0x677>
f010b5c2:	83 ec 04             	sub    $0x4,%esp
f010b5c5:	68 58 62 12 f0       	push   $0xf0126258
f010b5ca:	68 5d 01 00 00       	push   $0x15d
f010b5cf:	68 f3 61 12 f0       	push   $0xf01261f3
f010b5d4:	e8 60 4d ff ff       	call   f0100339 <_panic>
f010b5d9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5df:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b5e5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b5e8:	89 50 14             	mov    %edx,0x14(%eax)
f010b5eb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b5ee:	8b 40 14             	mov    0x14(%eax),%eax
f010b5f1:	85 c0                	test   %eax,%eax
f010b5f3:	74 14                	je     f010b609 <env_create+0x6a7>
f010b5f5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5fb:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b601:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b604:	89 50 10             	mov    %edx,0x10(%eax)
f010b607:	eb 0f                	jmp    f010b618 <env_create+0x6b6>
f010b609:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b60f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b612:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b618:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b61e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b621:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b627:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b62a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b631:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b637:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b63d:	42                   	inc    %edx
f010b63e:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b644:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b64a:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b650:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b656:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b65c:	39 c2                	cmp    %eax,%edx
f010b65e:	75 1a                	jne    f010b67a <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b660:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b666:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b66c:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b672:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b678:	eb 10                	jmp    f010b68a <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b67a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b680:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b687:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b68a:	83 ec 0c             	sub    $0xc,%esp
f010b68d:	6a 02                	push   $0x2
f010b68f:	e8 87 3f 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010b694:	83 c4 10             	add    $0x10,%esp
f010b697:	85 c0                	test   %eax,%eax
f010b699:	0f 84 d3 01 00 00    	je     f010b872 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b69f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b6a3:	75 17                	jne    f010b6bc <env_create+0x75a>
f010b6a5:	83 ec 04             	sub    $0x4,%esp
f010b6a8:	68 7b 62 12 f0       	push   $0xf012627b
f010b6ad:	68 6a 01 00 00       	push   $0x16a
f010b6b2:	68 f3 61 12 f0       	push   $0xf01261f3
f010b6b7:	e8 7d 4c ff ff       	call   f0100339 <_panic>
f010b6bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6bf:	8b 40 10             	mov    0x10(%eax),%eax
f010b6c2:	85 c0                	test   %eax,%eax
f010b6c4:	74 11                	je     f010b6d7 <env_create+0x775>
f010b6c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6c9:	8b 40 10             	mov    0x10(%eax),%eax
f010b6cc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6cf:	8b 52 14             	mov    0x14(%edx),%edx
f010b6d2:	89 50 14             	mov    %edx,0x14(%eax)
f010b6d5:	eb 12                	jmp    f010b6e9 <env_create+0x787>
f010b6d7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6dd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6e0:	8b 52 14             	mov    0x14(%edx),%edx
f010b6e3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b6e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6ec:	8b 40 14             	mov    0x14(%eax),%eax
f010b6ef:	85 c0                	test   %eax,%eax
f010b6f1:	74 11                	je     f010b704 <env_create+0x7a2>
f010b6f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6f6:	8b 40 14             	mov    0x14(%eax),%eax
f010b6f9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6fc:	8b 52 10             	mov    0x10(%edx),%edx
f010b6ff:	89 50 10             	mov    %edx,0x10(%eax)
f010b702:	eb 12                	jmp    f010b716 <env_create+0x7b4>
f010b704:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b70a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b70d:	8b 52 10             	mov    0x10(%edx),%edx
f010b710:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b716:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b719:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b720:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b723:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b72a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b730:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b736:	4a                   	dec    %edx
f010b737:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b73d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b743:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b749:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b74f:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b755:	39 c2                	cmp    %eax,%edx
f010b757:	0f 83 8d 00 00 00    	jae    f010b7ea <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b75d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b761:	75 17                	jne    f010b77a <env_create+0x818>
f010b763:	83 ec 04             	sub    $0x4,%esp
f010b766:	68 d0 61 12 f0       	push   $0xf01261d0
f010b76b:	68 6f 01 00 00       	push   $0x16f
f010b770:	68 f3 61 12 f0       	push   $0xf01261f3
f010b775:	e8 bf 4b ff ff       	call   f0100339 <_panic>
f010b77a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b780:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b786:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b789:	89 50 10             	mov    %edx,0x10(%eax)
f010b78c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b78f:	8b 40 10             	mov    0x10(%eax),%eax
f010b792:	85 c0                	test   %eax,%eax
f010b794:	74 14                	je     f010b7aa <env_create+0x848>
f010b796:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b79c:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b7a2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7a5:	89 50 14             	mov    %edx,0x14(%eax)
f010b7a8:	eb 0f                	jmp    f010b7b9 <env_create+0x857>
f010b7aa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7b0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7b3:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b7b9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7bf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7c2:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b7c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7cb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b7d2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7d8:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b7de:	42                   	inc    %edx
f010b7df:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b7e5:	e9 88 00 00 00       	jmp    f010b872 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b7ea:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b7ee:	75 17                	jne    f010b807 <env_create+0x8a5>
f010b7f0:	83 ec 04             	sub    $0x4,%esp
f010b7f3:	68 d0 61 12 f0       	push   $0xf01261d0
f010b7f8:	68 73 01 00 00       	push   $0x173
f010b7fd:	68 f3 61 12 f0       	push   $0xf01261f3
f010b802:	e8 32 4b ff ff       	call   f0100339 <_panic>
f010b807:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b80d:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b813:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b816:	89 50 10             	mov    %edx,0x10(%eax)
f010b819:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b81c:	8b 40 10             	mov    0x10(%eax),%eax
f010b81f:	85 c0                	test   %eax,%eax
f010b821:	74 14                	je     f010b837 <env_create+0x8d5>
f010b823:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b829:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b82f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b832:	89 50 14             	mov    %edx,0x14(%eax)
f010b835:	eb 0f                	jmp    f010b846 <env_create+0x8e4>
f010b837:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b83d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b840:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b846:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b84c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b84f:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b855:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b858:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b85f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b865:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b86b:	42                   	inc    %edx
f010b86c:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b872:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b878:	83 ec 04             	sub    $0x4,%esp
f010b87b:	6a 01                	push   $0x1
f010b87d:	ff 75 d0             	pushl  -0x30(%ebp)
f010b880:	50                   	push   %eax
f010b881:	e8 7a 88 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b886:	83 c4 10             	add    $0x10,%esp
f010b889:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b88f:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b896:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b899:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b89f:	0f 83 af fc ff ff    	jae    f010b554 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b8a5:	83 ec 0c             	sub    $0xc,%esp
f010b8a8:	6a 02                	push   $0x2
f010b8aa:	e8 6c 3d 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010b8af:	83 c4 10             	add    $0x10,%esp
f010b8b2:	85 c0                	test   %eax,%eax
f010b8b4:	74 72                	je     f010b928 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b8b6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b8bd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8c3:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b8c9:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b8cc:	eb 2b                	jmp    f010b8f9 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b8ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b8d1:	8b 10                	mov    (%eax),%edx
f010b8d3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8d9:	8b 40 64             	mov    0x64(%eax),%eax
f010b8dc:	6a 01                	push   $0x1
f010b8de:	6a 00                	push   $0x0
f010b8e0:	52                   	push   %edx
f010b8e1:	50                   	push   %eax
f010b8e2:	e8 7d e3 ff ff       	call   f0109c64 <pt_set_page_permissions>
f010b8e7:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b8ea:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8f0:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b8f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b8f9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8ff:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b903:	74 08                	je     f010b90d <env_create+0x9ab>
f010b905:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b908:	8b 52 10             	mov    0x10(%edx),%edx
f010b90b:	eb 05                	jmp    f010b912 <env_create+0x9b0>
f010b90d:	ba 00 00 00 00       	mov    $0x0,%edx
f010b912:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b918:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b91e:	85 c0                	test   %eax,%eax
f010b920:	75 ac                	jne    f010b8ce <env_create+0x96c>
f010b922:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b926:	75 a6                	jne    f010b8ce <env_create+0x96c>
f010b928:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b92b:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b92e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b931:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b934:	e8 e8 b8 ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b939:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b93f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b942:	5e                   	pop    %esi
f010b943:	5f                   	pop    %edi
f010b944:	5d                   	pop    %ebp
f010b945:	c3                   	ret    

f010b946 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b946:	55                   	push   %ebp
f010b947:	89 e5                	mov    %esp,%ebp
f010b949:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010b94c:	83 ec 0c             	sub    $0xc,%esp
f010b94f:	68 60 2e 6c f0       	push   $0xf06c2e60
f010b954:	e8 9c 43 00 00       	call   f010fcf5 <release_spinlock>
f010b959:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b95c:	a1 60 f9 17 f0       	mov    0xf017f960,%eax
f010b961:	85 c0                	test   %eax,%eax
f010b963:	74 30                	je     f010b995 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b965:	e8 76 00 00 00       	call   f010b9e0 <get_cpu_proc>
f010b96a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b96d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b970:	8b 40 10             	mov    0x10(%eax),%eax
f010b973:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b976:	83 c2 20             	add    $0x20,%edx
f010b979:	83 ec 04             	sub    $0x4,%esp
f010b97c:	50                   	push   %eax
f010b97d:	52                   	push   %edx
f010b97e:	68 99 62 12 f0       	push   $0xf0126299
f010b983:	e8 03 56 ff ff       	call   f0100f8b <cprintf>
f010b988:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b98b:	c7 05 60 f9 17 f0 00 	movl   $0x0,0xf017f960
f010b992:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b995:	90                   	nop
f010b996:	c9                   	leave  
f010b997:	c3                   	ret    

f010b998 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b998:	55                   	push   %ebp
f010b999:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010b99b:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010b99c:	5d                   	pop    %ebp
f010b99d:	c3                   	ret    

f010b99e <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b99e:	55                   	push   %ebp
f010b99f:	89 e5                	mov    %esp,%ebp
f010b9a1:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b9a4:	e8 37 00 00 00       	call   f010b9e0 <get_cpu_proc>
f010b9a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b9ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b9b0:	75 19                	jne    f010b9cb <env_exit+0x2d>
f010b9b2:	68 af 62 12 f0       	push   $0xf01262af
f010b9b7:	68 bf 62 12 f0       	push   $0xf01262bf
f010b9bc:	68 ed 01 00 00       	push   $0x1ed
f010b9c1:	68 f3 61 12 f0       	push   $0xf01261f3
f010b9c6:	e8 6e 49 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010b9cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b9ce:	8b 40 10             	mov    0x10(%eax),%eax
f010b9d1:	83 ec 0c             	sub    $0xc,%esp
f010b9d4:	50                   	push   %eax
f010b9d5:	e8 4f 9e ff ff       	call   f0105829 <sched_exit_env>
f010b9da:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010b9dd:	90                   	nop
f010b9de:	c9                   	leave  
f010b9df:	c3                   	ret    

f010b9e0 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010b9e0:	55                   	push   %ebp
f010b9e1:	89 e5                	mov    %esp,%ebp
f010b9e3:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010b9e6:	e8 e4 b7 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b9eb:	e8 1c b7 ff ff       	call   f010710c <mycpu>
f010b9f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010b9f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b9f6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b9fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010b9ff:	e8 1d b8 ff ff       	call   f0107221 <popcli>
	return p;
f010ba04:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010ba07:	c9                   	leave  
f010ba08:	c3                   	ret    

f010ba09 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010ba09:	55                   	push   %ebp
f010ba0a:	89 e5                	mov    %esp,%ebp
f010ba0c:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010ba0f:	e8 bb b7 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010ba14:	e8 f3 b6 ff ff       	call   f010710c <mycpu>
f010ba19:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010ba1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba1f:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba22:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010ba28:	e8 f4 b7 ff ff       	call   f0107221 <popcli>
}
f010ba2d:	90                   	nop
f010ba2e:	c9                   	leave  
f010ba2f:	c3                   	ret    

f010ba30 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010ba30:	55                   	push   %ebp
f010ba31:	89 e5                	mov    %esp,%ebp
f010ba33:	53                   	push   %ebx
f010ba34:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010ba37:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ba3b:	75 16                	jne    f010ba53 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010ba3d:	e8 9e ff ff ff       	call   f010b9e0 <get_cpu_proc>
f010ba42:	89 c2                	mov    %eax,%edx
f010ba44:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba47:	89 10                	mov    %edx,(%eax)
		return 0;
f010ba49:	b8 00 00 00 00       	mov    $0x0,%eax
f010ba4e:	e9 aa 00 00 00       	jmp    f010bafd <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010ba53:	8b 1d 74 a3 69 f0    	mov    0xf069a374,%ebx
f010ba59:	83 ec 0c             	sub    $0xc,%esp
f010ba5c:	68 ca 02 00 00       	push   $0x2ca
f010ba61:	e8 14 27 01 00       	call   f011e17a <nearest_pow2_ceil>
f010ba66:	83 c4 10             	add    $0x10,%esp
f010ba69:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ba6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba6f:	21 c2                	and    %eax,%edx
f010ba71:	89 d0                	mov    %edx,%eax
f010ba73:	c1 e0 03             	shl    $0x3,%eax
f010ba76:	01 d0                	add    %edx,%eax
f010ba78:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010ba7f:	01 c8                	add    %ecx,%eax
f010ba81:	01 c0                	add    %eax,%eax
f010ba83:	01 d0                	add    %edx,%eax
f010ba85:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010ba8c:	01 c8                	add    %ecx,%eax
f010ba8e:	01 d0                	add    %edx,%eax
f010ba90:	01 d8                	add    %ebx,%eax
f010ba92:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010ba95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba98:	8b 40 18             	mov    0x18(%eax),%eax
f010ba9b:	85 c0                	test   %eax,%eax
f010ba9d:	74 0b                	je     f010baaa <envid2env+0x7a>
f010ba9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baa2:	8b 40 10             	mov    0x10(%eax),%eax
f010baa5:	3b 45 08             	cmp    0x8(%ebp),%eax
f010baa8:	74 10                	je     f010baba <envid2env+0x8a>
		*env_store = 0;
f010baaa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010baad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bab3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bab8:	eb 43                	jmp    f010bafd <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010baba:	e8 21 ff ff ff       	call   f010b9e0 <get_cpu_proc>
f010babf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010bac2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010bac6:	74 28                	je     f010baf0 <envid2env+0xc0>
f010bac8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bacb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010bace:	74 20                	je     f010baf0 <envid2env+0xc0>
f010bad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bad3:	8b 50 14             	mov    0x14(%eax),%edx
f010bad6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bad9:	8b 40 10             	mov    0x10(%eax),%eax
f010badc:	39 c2                	cmp    %eax,%edx
f010bade:	74 10                	je     f010baf0 <envid2env+0xc0>
		*env_store = 0;
f010bae0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bae3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bae9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010baee:	eb 0d                	jmp    f010bafd <envid2env+0xcd>
	}

	*env_store = e;
f010baf0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010baf3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010baf6:	89 10                	mov    %edx,(%eax)
	return 0;
f010baf8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bafd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb00:	c9                   	leave  
f010bb01:	c3                   	ret    

f010bb02 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bb02:	55                   	push   %ebp
f010bb03:	89 e5                	mov    %esp,%ebp
f010bb05:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bb08:	83 ec 0c             	sub    $0xc,%esp
f010bb0b:	68 60 2e 6c f0       	push   $0xf06c2e60
f010bb10:	e8 59 41 00 00       	call   f010fc6e <acquire_spinlock>
f010bb15:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bb18:	e8 c3 fe ff ff       	call   f010b9e0 <get_cpu_proc>
f010bb1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bb20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb24:	75 19                	jne    f010bb3f <yield+0x3d>
f010bb26:	68 d4 62 12 f0       	push   $0xf01262d4
f010bb2b:	68 bf 62 12 f0       	push   $0xf01262bf
f010bb30:	68 4c 02 00 00       	push   $0x24c
f010bb35:	68 f3 61 12 f0       	push   $0xf01261f3
f010bb3a:	e8 fa 47 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010bb3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb42:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bb49:	e8 13 00 00 00       	call   f010bb61 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010bb4e:	83 ec 0c             	sub    $0xc,%esp
f010bb51:	68 60 2e 6c f0       	push   $0xf06c2e60
f010bb56:	e8 9a 41 00 00       	call   f010fcf5 <release_spinlock>
f010bb5b:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bb5e:	90                   	nop
f010bb5f:	c9                   	leave  
f010bb60:	c3                   	ret    

f010bb61 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bb61:	55                   	push   %ebp
f010bb62:	89 e5                	mov    %esp,%ebp
f010bb64:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bb67:	e8 74 fe ff ff       	call   f010b9e0 <get_cpu_proc>
f010bb6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bb6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb73:	75 19                	jne    f010bb8e <sched+0x2d>
f010bb75:	68 d4 62 12 f0       	push   $0xf01262d4
f010bb7a:	68 bf 62 12 f0       	push   $0xf01262bf
f010bb7f:	68 60 02 00 00       	push   $0x260
f010bb84:	68 f3 61 12 f0       	push   $0xf01261f3
f010bb89:	e8 ab 47 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010bb8e:	83 ec 0c             	sub    $0xc,%esp
f010bb91:	68 60 2e 6c f0       	push   $0xf06c2e60
f010bb96:	e8 ec 42 00 00       	call   f010fe87 <holding_spinlock>
f010bb9b:	83 c4 10             	add    $0x10,%esp
f010bb9e:	85 c0                	test   %eax,%eax
f010bba0:	75 17                	jne    f010bbb9 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bba2:	83 ec 04             	sub    $0x4,%esp
f010bba5:	68 e0 62 12 f0       	push   $0xf01262e0
f010bbaa:	68 64 02 00 00       	push   $0x264
f010bbaf:	68 f3 61 12 f0       	push   $0xf01261f3
f010bbb4:	e8 80 47 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bbb9:	e8 4e b5 ff ff       	call   f010710c <mycpu>
f010bbbe:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bbc4:	83 f8 01             	cmp    $0x1,%eax
f010bbc7:	74 20                	je     f010bbe9 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bbc9:	e8 3e b5 ff ff       	call   f010710c <mycpu>
f010bbce:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bbd4:	50                   	push   %eax
f010bbd5:	68 22 63 12 f0       	push   $0xf0126322
f010bbda:	68 67 02 00 00       	push   $0x267
f010bbdf:	68 f3 61 12 f0       	push   $0xf01261f3
f010bbe4:	e8 50 47 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bbe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbec:	8b 40 18             	mov    0x18(%eax),%eax
f010bbef:	83 f8 02             	cmp    $0x2,%eax
f010bbf2:	75 17                	jne    f010bc0b <sched+0xaa>
		panic("sched a running process");
f010bbf4:	83 ec 04             	sub    $0x4,%esp
f010bbf7:	68 39 63 12 f0       	push   $0xf0126339
f010bbfc:	68 6a 02 00 00       	push   $0x26a
f010bc01:	68 f3 61 12 f0       	push   $0xf01261f3
f010bc06:	e8 2e 47 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bc0b:	9c                   	pushf  
f010bc0c:	58                   	pop    %eax
f010bc0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bc10:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bc13:	25 00 02 00 00       	and    $0x200,%eax
f010bc18:	85 c0                	test   %eax,%eax
f010bc1a:	74 17                	je     f010bc33 <sched+0xd2>
		panic("sched is interruptible!");
f010bc1c:	83 ec 04             	sub    $0x4,%esp
f010bc1f:	68 51 63 12 f0       	push   $0xf0126351
f010bc24:	68 6c 02 00 00       	push   $0x26c
f010bc29:	68 f3 61 12 f0       	push   $0xf01261f3
f010bc2e:	e8 06 47 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bc33:	e8 d4 b4 ff ff       	call   f010710c <mycpu>
f010bc38:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bc3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bc41:	e8 c6 b4 ff ff       	call   f010710c <mycpu>
f010bc46:	8b 40 04             	mov    0x4(%eax),%eax
f010bc49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc4c:	83 c2 04             	add    $0x4,%edx
f010bc4f:	83 ec 08             	sub    $0x8,%esp
f010bc52:	50                   	push   %eax
f010bc53:	52                   	push   %edx
f010bc54:	e8 18 8f ff ff       	call   f0104b71 <context_switch>
f010bc59:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bc5c:	e8 ab b4 ff ff       	call   f010710c <mycpu>
f010bc61:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bc64:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bc6a:	90                   	nop
f010bc6b:	c9                   	leave  
f010bc6c:	c3                   	ret    

f010bc6d <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bc6d:	55                   	push   %ebp
f010bc6e:	89 e5                	mov    %esp,%ebp
f010bc70:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bc73:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f010bc78:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bc7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bc7e:	0f 22 d8             	mov    %eax,%cr3
}
f010bc81:	90                   	nop
f010bc82:	c9                   	leave  
f010bc83:	c3                   	ret    

f010bc84 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bc84:	55                   	push   %ebp
f010bc85:	89 e5                	mov    %esp,%ebp
f010bc87:	53                   	push   %ebx
f010bc88:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bc8b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bc8f:	75 17                	jne    f010bca8 <switchuvm+0x24>
		panic("switchuvm: no process");
f010bc91:	83 ec 04             	sub    $0x4,%esp
f010bc94:	68 69 63 12 f0       	push   $0xf0126369
f010bc99:	68 81 02 00 00       	push   $0x281
f010bc9e:	68 f3 61 12 f0       	push   $0xf01261f3
f010bca3:	e8 91 46 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bca8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcab:	8b 40 70             	mov    0x70(%eax),%eax
f010bcae:	85 c0                	test   %eax,%eax
f010bcb0:	75 17                	jne    f010bcc9 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bcb2:	83 ec 04             	sub    $0x4,%esp
f010bcb5:	68 7f 63 12 f0       	push   $0xf012637f
f010bcba:	68 83 02 00 00       	push   $0x283
f010bcbf:	68 f3 61 12 f0       	push   $0xf01261f3
f010bcc4:	e8 70 46 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010bcc9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bccc:	8b 40 64             	mov    0x64(%eax),%eax
f010bccf:	85 c0                	test   %eax,%eax
f010bcd1:	75 17                	jne    f010bcea <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bcd3:	83 ec 04             	sub    $0x4,%esp
f010bcd6:	68 94 63 12 f0       	push   $0xf0126394
f010bcdb:	68 85 02 00 00       	push   $0x285
f010bce0:	68 f3 61 12 f0       	push   $0xf01261f3
f010bce5:	e8 4f 46 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bcea:	e8 e0 b4 ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010bcef:	e8 18 b4 ff ff       	call   f010710c <mycpu>
f010bcf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bcf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bcfa:	8b 55 08             	mov    0x8(%ebp),%edx
f010bcfd:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bd03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd06:	83 c0 0c             	add    $0xc,%eax
f010bd09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd0c:	83 c2 0c             	add    $0xc,%edx
f010bd0f:	c1 ea 10             	shr    $0x10,%edx
f010bd12:	88 d3                	mov    %dl,%bl
f010bd14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd17:	83 c2 0c             	add    $0xc,%edx
f010bd1a:	c1 ea 18             	shr    $0x18,%edx
f010bd1d:	88 d1                	mov    %dl,%cl
f010bd1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd22:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bd29:	68 00 
f010bd2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd2e:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bd35:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd38:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bd3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd41:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd47:	83 e2 f0             	and    $0xfffffff0,%edx
f010bd4a:	83 ca 09             	or     $0x9,%edx
f010bd4d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd56:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd5c:	83 ca 10             	or     $0x10,%edx
f010bd5f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd68:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd6e:	83 e2 9f             	and    $0xffffff9f,%edx
f010bd71:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd7a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd80:	83 ca 80             	or     $0xffffff80,%edx
f010bd83:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd8c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bd92:	83 e2 f0             	and    $0xfffffff0,%edx
f010bd95:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bd9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd9e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bda4:	83 e2 ef             	and    $0xffffffef,%edx
f010bda7:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdb0:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdb6:	83 e2 df             	and    $0xffffffdf,%edx
f010bdb9:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdc8:	83 ca 40             	or     $0x40,%edx
f010bdcb:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdd4:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdda:	83 e2 7f             	and    $0x7f,%edx
f010bddd:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bde3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde6:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010bdec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdef:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdf5:	83 e2 ef             	and    $0xffffffef,%edx
f010bdf8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010bdfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be01:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be07:	8b 40 70             	mov    0x70(%eax),%eax
f010be0a:	05 00 80 00 00       	add    $0x8000,%eax
f010be0f:	89 c2                	mov    %eax,%edx
f010be11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be14:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010be17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be1a:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010be20:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010be26:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010be2a:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010be2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be30:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be36:	8b 40 68             	mov    0x68(%eax),%eax
f010be39:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010be3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be3f:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010be42:	e8 da b3 ff ff       	call   f0107221 <popcli>
}
f010be47:	90                   	nop
f010be48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010be4b:	c9                   	leave  
f010be4c:	c3                   	ret    

f010be4d <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010be4d:	55                   	push   %ebp
f010be4e:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010be50:	8b 15 78 a3 69 f0    	mov    0xf069a378,%edx
f010be56:	8b 45 08             	mov    0x8(%ebp),%eax
f010be59:	89 10                	mov    %edx,(%eax)
f010be5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010be5e:	8b 00                	mov    (%eax),%eax
f010be60:	85 c0                	test   %eax,%eax
f010be62:	75 07                	jne    f010be6b <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010be64:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010be69:	eb 11                	jmp    f010be7c <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010be6b:	8b 45 08             	mov    0x8(%ebp),%eax
f010be6e:	8b 00                	mov    (%eax),%eax
f010be70:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010be77:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010be7c:	5d                   	pop    %ebp
f010be7d:	c3                   	ret    

f010be7e <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010be7e:	55                   	push   %ebp
f010be7f:	89 e5                	mov    %esp,%ebp
f010be81:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010be84:	83 ec 04             	sub    $0x4,%esp
f010be87:	68 bc 05 00 00       	push   $0x5bc
f010be8c:	6a 00                	push   $0x0
f010be8e:	ff 75 08             	pushl  0x8(%ebp)
f010be91:	e8 74 3f 01 00       	call   f011fe0a <memset>
f010be96:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010be99:	8b 45 08             	mov    0x8(%ebp),%eax
f010be9c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010bea3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bea7:	75 17                	jne    f010bec0 <free_environment+0x42>
f010bea9:	83 ec 04             	sub    $0x4,%esp
f010beac:	68 d0 61 12 f0       	push   $0xf01261d0
f010beb1:	68 c0 02 00 00       	push   $0x2c0
f010beb6:	68 f3 61 12 f0       	push   $0xf01261f3
f010bebb:	e8 79 44 ff ff       	call   f0100339 <_panic>
f010bec0:	8b 15 78 a3 69 f0    	mov    0xf069a378,%edx
f010bec6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bec9:	89 50 08             	mov    %edx,0x8(%eax)
f010becc:	8b 45 08             	mov    0x8(%ebp),%eax
f010becf:	8b 40 08             	mov    0x8(%eax),%eax
f010bed2:	85 c0                	test   %eax,%eax
f010bed4:	74 0d                	je     f010bee3 <free_environment+0x65>
f010bed6:	a1 78 a3 69 f0       	mov    0xf069a378,%eax
f010bedb:	8b 55 08             	mov    0x8(%ebp),%edx
f010bede:	89 50 0c             	mov    %edx,0xc(%eax)
f010bee1:	eb 08                	jmp    f010beeb <free_environment+0x6d>
f010bee3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bee6:	a3 7c a3 69 f0       	mov    %eax,0xf069a37c
f010beeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010beee:	a3 78 a3 69 f0       	mov    %eax,0xf069a378
f010bef3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bef6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010befd:	a1 84 a3 69 f0       	mov    0xf069a384,%eax
f010bf02:	40                   	inc    %eax
f010bf03:	a3 84 a3 69 f0       	mov    %eax,0xf069a384
}
f010bf08:	90                   	nop
f010bf09:	c9                   	leave  
f010bf0a:	c3                   	ret    

f010bf0b <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010bf0b:	55                   	push   %ebp
f010bf0c:	89 e5                	mov    %esp,%ebp
f010bf0e:	53                   	push   %ebx
f010bf0f:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010bf12:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf15:	8b 40 0c             	mov    0xc(%eax),%eax
f010bf18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010bf1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf1e:	8b 40 08             	mov    0x8(%eax),%eax
f010bf21:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010bf24:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010bf2b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010bf2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bf31:	01 c2                	add    %eax,%edx
f010bf33:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bf36:	01 d0                	add    %edx,%eax
f010bf38:	48                   	dec    %eax
f010bf39:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bf3c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bf3f:	ba 00 00 00 00       	mov    $0x0,%edx
f010bf44:	f7 75 dc             	divl   -0x24(%ebp)
f010bf47:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bf4a:	29 d0                	sub    %edx,%eax
f010bf4c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010bf4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bf52:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010bf55:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bf58:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bf5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010bf60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010bf67:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010bf6e:	8b 45 10             	mov    0x10(%ebp),%eax
f010bf71:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010bf77:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010bf7e:	0f 85 f5 03 00 00    	jne    f010c379 <program_segment_alloc_map_copy_workingset+0x46e>
f010bf84:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf87:	83 c0 20             	add    $0x20,%eax
f010bf8a:	83 ec 08             	sub    $0x8,%esp
f010bf8d:	68 a8 63 12 f0       	push   $0xf01263a8
f010bf92:	50                   	push   %eax
f010bf93:	e8 90 3d 01 00       	call   f011fd28 <strcmp>
f010bf98:	83 c4 10             	add    $0x10,%esp
f010bf9b:	85 c0                	test   %eax,%eax
f010bf9d:	0f 84 d6 03 00 00    	je     f010c379 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010bfa3:	8b 45 14             	mov    0x14(%ebp),%eax
f010bfa6:	83 f8 06             	cmp    $0x6,%eax
f010bfa9:	76 05                	jbe    f010bfb0 <program_segment_alloc_map_copy_workingset+0xa5>
f010bfab:	b8 06 00 00 00       	mov    $0x6,%eax
f010bfb0:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bfb3:	e9 c1 03 00 00       	jmp    f010c379 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010bfb8:	83 ec 0c             	sub    $0xc,%esp
f010bfbb:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010bfbe:	50                   	push   %eax
f010bfbf:	e8 ee c1 ff ff       	call   f01081b2 <allocate_frame>
f010bfc4:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010bfc7:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010bfca:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfcd:	8b 40 64             	mov    0x64(%eax),%eax
f010bfd0:	6a 06                	push   $0x6
f010bfd2:	ff 75 f4             	pushl  -0xc(%ebp)
f010bfd5:	52                   	push   %edx
f010bfd6:	50                   	push   %eax
f010bfd7:	e8 a7 c8 ff ff       	call   f0108883 <loadtime_map_frame>
f010bfdc:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010bfdf:	83 ec 08             	sub    $0x8,%esp
f010bfe2:	ff 75 f4             	pushl  -0xc(%ebp)
f010bfe5:	ff 75 08             	pushl  0x8(%ebp)
f010bfe8:	e8 ad de ff ff       	call   f0109e9a <env_page_ws_list_create_element>
f010bfed:	83 c4 10             	add    $0x10,%esp
f010bff0:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010bff3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bff6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010bffd:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c001:	75 17                	jne    f010c01a <program_segment_alloc_map_copy_workingset+0x10f>
f010c003:	83 ec 04             	sub    $0x4,%esp
f010c006:	68 58 62 12 f0       	push   $0xf0126258
f010c00b:	68 ea 02 00 00       	push   $0x2ea
f010c010:	68 f3 61 12 f0       	push   $0xf01261f3
f010c015:	e8 1f 43 ff ff       	call   f0100339 <_panic>
f010c01a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c01d:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c023:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c026:	89 50 14             	mov    %edx,0x14(%eax)
f010c029:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c02c:	8b 40 14             	mov    0x14(%eax),%eax
f010c02f:	85 c0                	test   %eax,%eax
f010c031:	74 11                	je     f010c044 <program_segment_alloc_map_copy_workingset+0x139>
f010c033:	8b 45 08             	mov    0x8(%ebp),%eax
f010c036:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c03c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c03f:	89 50 10             	mov    %edx,0x10(%eax)
f010c042:	eb 0c                	jmp    f010c050 <program_segment_alloc_map_copy_workingset+0x145>
f010c044:	8b 45 08             	mov    0x8(%ebp),%eax
f010c047:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c04a:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c050:	8b 45 08             	mov    0x8(%ebp),%eax
f010c053:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c056:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c05c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c05f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c066:	8b 45 08             	mov    0x8(%ebp),%eax
f010c069:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c06f:	8d 50 01             	lea    0x1(%eax),%edx
f010c072:	8b 45 08             	mov    0x8(%ebp),%eax
f010c075:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c07b:	83 ec 0c             	sub    $0xc,%esp
f010c07e:	6a 02                	push   $0x2
f010c080:	e8 96 35 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010c085:	83 c4 10             	add    $0x10,%esp
f010c088:	85 c0                	test   %eax,%eax
f010c08a:	0f 84 b3 01 00 00    	je     f010c243 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c090:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c094:	75 17                	jne    f010c0ad <program_segment_alloc_map_copy_workingset+0x1a2>
f010c096:	83 ec 04             	sub    $0x4,%esp
f010c099:	68 7b 62 12 f0       	push   $0xf012627b
f010c09e:	68 f6 02 00 00       	push   $0x2f6
f010c0a3:	68 f3 61 12 f0       	push   $0xf01261f3
f010c0a8:	e8 8c 42 ff ff       	call   f0100339 <_panic>
f010c0ad:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0b0:	8b 40 10             	mov    0x10(%eax),%eax
f010c0b3:	85 c0                	test   %eax,%eax
f010c0b5:	74 11                	je     f010c0c8 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c0b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0ba:	8b 40 10             	mov    0x10(%eax),%eax
f010c0bd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0c0:	8b 52 14             	mov    0x14(%edx),%edx
f010c0c3:	89 50 14             	mov    %edx,0x14(%eax)
f010c0c6:	eb 0f                	jmp    f010c0d7 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c0c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0cb:	8b 50 14             	mov    0x14(%eax),%edx
f010c0ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0d1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c0d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0da:	8b 40 14             	mov    0x14(%eax),%eax
f010c0dd:	85 c0                	test   %eax,%eax
f010c0df:	74 11                	je     f010c0f2 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c0e1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0e4:	8b 40 14             	mov    0x14(%eax),%eax
f010c0e7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0ea:	8b 52 10             	mov    0x10(%edx),%edx
f010c0ed:	89 50 10             	mov    %edx,0x10(%eax)
f010c0f0:	eb 0f                	jmp    f010c101 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c0f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0f5:	8b 50 10             	mov    0x10(%eax),%edx
f010c0f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0fb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c101:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c104:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c10b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c10e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c115:	8b 45 08             	mov    0x8(%ebp),%eax
f010c118:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c11e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c121:	8b 45 08             	mov    0x8(%ebp),%eax
f010c124:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c12a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c12d:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c133:	8b 45 08             	mov    0x8(%ebp),%eax
f010c136:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c13c:	48                   	dec    %eax
f010c13d:	39 c2                	cmp    %eax,%edx
f010c13f:	0f 83 80 00 00 00    	jae    f010c1c5 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c145:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c149:	75 17                	jne    f010c162 <program_segment_alloc_map_copy_workingset+0x257>
f010c14b:	83 ec 04             	sub    $0x4,%esp
f010c14e:	68 d0 61 12 f0       	push   $0xf01261d0
f010c153:	68 fa 02 00 00       	push   $0x2fa
f010c158:	68 f3 61 12 f0       	push   $0xf01261f3
f010c15d:	e8 d7 41 ff ff       	call   f0100339 <_panic>
f010c162:	8b 45 08             	mov    0x8(%ebp),%eax
f010c165:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c16b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c16e:	89 50 10             	mov    %edx,0x10(%eax)
f010c171:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c174:	8b 40 10             	mov    0x10(%eax),%eax
f010c177:	85 c0                	test   %eax,%eax
f010c179:	74 11                	je     f010c18c <program_segment_alloc_map_copy_workingset+0x281>
f010c17b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c17e:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c184:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c187:	89 50 14             	mov    %edx,0x14(%eax)
f010c18a:	eb 0c                	jmp    f010c198 <program_segment_alloc_map_copy_workingset+0x28d>
f010c18c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c18f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c192:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c198:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c19e:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c1a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1a7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c1ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b1:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c1b7:	8d 50 01             	lea    0x1(%eax),%edx
f010c1ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1bd:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c1c3:	eb 7e                	jmp    f010c243 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c1c5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c1c9:	75 17                	jne    f010c1e2 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c1cb:	83 ec 04             	sub    $0x4,%esp
f010c1ce:	68 d0 61 12 f0       	push   $0xf01261d0
f010c1d3:	68 ff 02 00 00       	push   $0x2ff
f010c1d8:	68 f3 61 12 f0       	push   $0xf01261f3
f010c1dd:	e8 57 41 ff ff       	call   f0100339 <_panic>
f010c1e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e5:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c1eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1ee:	89 50 10             	mov    %edx,0x10(%eax)
f010c1f1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1f4:	8b 40 10             	mov    0x10(%eax),%eax
f010c1f7:	85 c0                	test   %eax,%eax
f010c1f9:	74 11                	je     f010c20c <program_segment_alloc_map_copy_workingset+0x301>
f010c1fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1fe:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c204:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c207:	89 50 14             	mov    %edx,0x14(%eax)
f010c20a:	eb 0c                	jmp    f010c218 <program_segment_alloc_map_copy_workingset+0x30d>
f010c20c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c20f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c212:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c218:	8b 45 08             	mov    0x8(%ebp),%eax
f010c21b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c21e:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c224:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c227:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c22e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c231:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c237:	8d 50 01             	lea    0x1(%eax),%edx
f010c23a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23d:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c243:	8b 45 08             	mov    0x8(%ebp),%eax
f010c246:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c24c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c24f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c255:	39 c2                	cmp    %eax,%edx
f010c257:	75 14                	jne    f010c26d <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c259:	8b 45 08             	mov    0x8(%ebp),%eax
f010c25c:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c262:	8b 45 08             	mov    0x8(%ebp),%eax
f010c265:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c26b:	eb 0d                	jmp    f010c27a <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c26d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c270:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c277:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c27a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c27d:	c1 e8 16             	shr    $0x16,%eax
f010c280:	89 c2                	mov    %eax,%edx
f010c282:	8b 45 18             	mov    0x18(%ebp),%eax
f010c285:	8b 00                	mov    (%eax),%eax
f010c287:	39 c2                	cmp    %eax,%edx
f010c289:	0f 84 d3 00 00 00    	je     f010c362 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c28f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c292:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c298:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c29b:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c29e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c2a1:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c2a6:	89 c1                	mov    %eax,%ecx
f010c2a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c2ab:	89 d0                	mov    %edx,%eax
f010c2ad:	01 c0                	add    %eax,%eax
f010c2af:	01 d0                	add    %edx,%eax
f010c2b1:	c1 e0 03             	shl    $0x3,%eax
f010c2b4:	01 d8                	add    %ebx,%eax
f010c2b6:	05 ac 00 00 00       	add    $0xac,%eax
f010c2bb:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c0:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c2c6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c2c9:	89 d0                	mov    %edx,%eax
f010c2cb:	01 c0                	add    %eax,%eax
f010c2cd:	01 d0                	add    %edx,%eax
f010c2cf:	c1 e0 03             	shl    $0x3,%eax
f010c2d2:	01 c8                	add    %ecx,%eax
f010c2d4:	05 b0 00 00 00       	add    $0xb0,%eax
f010c2d9:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c2dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2df:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c2e5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c2e8:	89 d0                	mov    %edx,%eax
f010c2ea:	01 c0                	add    %eax,%eax
f010c2ec:	01 d0                	add    %edx,%eax
f010c2ee:	c1 e0 03             	shl    $0x3,%eax
f010c2f1:	01 c8                	add    %ecx,%eax
f010c2f3:	05 b4 00 00 00       	add    $0xb4,%eax
f010c2f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c2fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c301:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c307:	8d 50 01             	lea    0x1(%eax),%edx
f010c30a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c30d:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c313:	8b 45 08             	mov    0x8(%ebp),%eax
f010c316:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c31c:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c321:	ba 00 00 00 00       	mov    $0x0,%edx
f010c326:	f7 f1                	div    %ecx
f010c328:	8b 45 08             	mov    0x8(%ebp),%eax
f010c32b:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c331:	8b 45 08             	mov    0x8(%ebp),%eax
f010c334:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c33a:	85 c0                	test   %eax,%eax
f010c33c:	75 17                	jne    f010c355 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c33e:	83 ec 04             	sub    $0x4,%esp
f010c341:	68 ac 63 12 f0       	push   $0xf01263ac
f010c346:	68 27 03 00 00       	push   $0x327
f010c34b:	68 f3 61 12 f0       	push   $0xf01261f3
f010c350:	e8 e4 3f ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c355:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c358:	c1 e8 16             	shr    $0x16,%eax
f010c35b:	89 c2                	mov    %eax,%edx
f010c35d:	8b 45 18             	mov    0x18(%ebp),%eax
f010c360:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c362:	8b 45 10             	mov    0x10(%ebp),%eax
f010c365:	8b 00                	mov    (%eax),%eax
f010c367:	8d 50 01             	lea    0x1(%eax),%edx
f010c36a:	8b 45 10             	mov    0x10(%ebp),%eax
f010c36d:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c36f:	ff 45 f0             	incl   -0x10(%ebp)
f010c372:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c379:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c37c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c37f:	73 0c                	jae    f010c38d <program_segment_alloc_map_copy_workingset+0x482>
f010c381:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c384:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c387:	0f 82 2b fc ff ff    	jb     f010bfb8 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c38d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c390:	8b 00                	mov    (%eax),%eax
f010c392:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c395:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c398:	8b 40 0c             	mov    0xc(%eax),%eax
f010c39b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c39e:	eb 10                	jmp    f010c3b0 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c3a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c3a3:	8a 10                	mov    (%eax),%dl
f010c3a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3a8:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c3aa:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c3ad:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c3b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c3b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c3b6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c3b9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c3be:	89 c2                	mov    %eax,%edx
f010c3c0:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3c3:	8b 00                	mov    (%eax),%eax
f010c3c5:	c1 e0 0c             	shl    $0xc,%eax
f010c3c8:	01 c2                	add    %eax,%edx
f010c3ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3cd:	39 c2                	cmp    %eax,%edx
f010c3cf:	76 1d                	jbe    f010c3ee <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c3d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3d4:	8b 50 04             	mov    0x4(%eax),%edx
f010c3d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c3da:	01 c2                	add    %eax,%edx
f010c3dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c3df:	39 c2                	cmp    %eax,%edx
f010c3e1:	77 bd                	ja     f010c3a0 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c3e3:	eb 09                	jmp    f010c3ee <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c3e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3e8:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c3eb:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c3ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c3f1:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c3f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c3f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c3fc:	89 c2                	mov    %eax,%edx
f010c3fe:	8b 45 10             	mov    0x10(%ebp),%eax
f010c401:	8b 00                	mov    (%eax),%eax
f010c403:	c1 e0 0c             	shl    $0xc,%eax
f010c406:	01 c2                	add    %eax,%edx
f010c408:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c40b:	39 c2                	cmp    %eax,%edx
f010c40d:	77 d6                	ja     f010c3e5 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c40f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c414:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c417:	c9                   	leave  
f010c418:	c3                   	ret    

f010c419 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c419:	55                   	push   %ebp
f010c41a:	89 e5                	mov    %esp,%ebp
f010c41c:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c41f:	83 ec 0c             	sub    $0xc,%esp
f010c422:	68 00 10 00 00       	push   $0x1000
f010c427:	e8 fe d0 ff ff       	call   f010952a <kmalloc>
f010c42c:	83 c4 10             	add    $0x10,%esp
f010c42f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c432:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c436:	75 17                	jne    f010c44f <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c438:	83 ec 04             	sub    $0x4,%esp
f010c43b:	68 4f 64 12 f0       	push   $0xf012644f
f010c440:	68 57 03 00 00       	push   $0x357
f010c445:	68 f3 61 12 f0       	push   $0xf01261f3
f010c44a:	e8 ea 3e ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c44f:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c452:	c9                   	leave  
f010c453:	c3                   	ret    

f010c454 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c454:	55                   	push   %ebp
f010c455:	89 e5                	mov    %esp,%ebp
f010c457:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c45a:	83 ec 0c             	sub    $0xc,%esp
f010c45d:	68 00 80 00 00       	push   $0x8000
f010c462:	e8 c3 d0 ff ff       	call   f010952a <kmalloc>
f010c467:	83 c4 10             	add    $0x10,%esp
f010c46a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c46d:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c474:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c477:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c47c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c47f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c482:	ba 00 00 00 00       	mov    $0x0,%edx
f010c487:	f7 75 ec             	divl   -0x14(%ebp)
f010c48a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c48d:	29 d0                	sub    %edx,%eax
f010c48f:	85 c0                	test   %eax,%eax
f010c491:	79 05                	jns    f010c498 <create_user_kern_stack+0x44>
f010c493:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c498:	c1 f8 0c             	sar    $0xc,%eax
f010c49b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c49e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c4a5:	eb 72                	jmp    f010c519 <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c4a7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c4ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4b1:	c1 e0 0c             	shl    $0xc,%eax
f010c4b4:	89 c2                	mov    %eax,%edx
f010c4b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c4b9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c4bc:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010c4c1:	83 ec 04             	sub    $0x4,%esp
f010c4c4:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c4c7:	52                   	push   %edx
f010c4c8:	51                   	push   %ecx
f010c4c9:	50                   	push   %eax
f010c4ca:	e8 9a c2 ff ff       	call   f0108769 <get_frame_info>
f010c4cf:	83 c4 10             	add    $0x10,%esp
f010c4d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c4d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4d8:	c1 e0 0c             	shl    $0xc,%eax
f010c4db:	89 c2                	mov    %eax,%edx
f010c4dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c4e0:	01 d0                	add    %edx,%eax
f010c4e2:	6a 01                	push   $0x1
f010c4e4:	50                   	push   %eax
f010c4e5:	ff 75 e0             	pushl  -0x20(%ebp)
f010c4e8:	ff 75 08             	pushl  0x8(%ebp)
f010c4eb:	e8 8f c1 ff ff       	call   f010867f <map_frame>
f010c4f0:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c4f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c4f7:	75 1d                	jne    f010c516 <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c4f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4fc:	c1 e0 0c             	shl    $0xc,%eax
f010c4ff:	89 c2                	mov    %eax,%edx
f010c501:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c504:	01 d0                	add    %edx,%eax
f010c506:	6a 01                	push   $0x1
f010c508:	6a 00                	push   $0x0
f010c50a:	50                   	push   %eax
f010c50b:	ff 75 08             	pushl  0x8(%ebp)
f010c50e:	e8 51 d7 ff ff       	call   f0109c64 <pt_set_page_permissions>
f010c513:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c516:	ff 45 f4             	incl   -0xc(%ebp)
f010c519:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c51c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c51f:	72 86                	jb     f010c4a7 <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c521:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c524:	c9                   	leave  
f010c525:	c3                   	ret    

f010c526 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c526:	55                   	push   %ebp
f010c527:	89 e5                	mov    %esp,%ebp
f010c529:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c52c:	83 ec 04             	sub    $0x4,%esp
f010c52f:	68 6c 64 12 f0       	push   $0xf012646c
f010c534:	68 8e 03 00 00       	push   $0x38e
f010c539:	68 f3 61 12 f0       	push   $0xf01261f3
f010c53e:	e8 f6 3d ff ff       	call   f0100339 <_panic>

f010c543 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c543:	55                   	push   %ebp
f010c544:	89 e5                	mov    %esp,%ebp
f010c546:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c549:	8b 45 08             	mov    0x8(%ebp),%eax
f010c54c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c54f:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c552:	8b 45 08             	mov    0x8(%ebp),%eax
f010c555:	8b 55 10             	mov    0x10(%ebp),%edx
f010c558:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c55b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c55e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c561:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c564:	83 ec 08             	sub    $0x8,%esp
f010c567:	6a 00                	push   $0x0
f010c569:	ff 75 0c             	pushl  0xc(%ebp)
f010c56c:	e8 7a 42 01 00       	call   f01207eb <initialize_dynamic_allocator>
f010c571:	83 c4 10             	add    $0x10,%esp
}
f010c574:	90                   	nop
f010c575:	c9                   	leave  
f010c576:	c3                   	ret    

f010c577 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c577:	55                   	push   %ebp
f010c578:	89 e5                	mov    %esp,%ebp
f010c57a:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c57d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c580:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c583:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c586:	8b 45 08             	mov    0x8(%ebp),%eax
f010c589:	8b 55 10             	mov    0x10(%ebp),%edx
f010c58c:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c58f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c596:	eb 17                	jmp    f010c5af <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c598:	8b 45 08             	mov    0x8(%ebp),%eax
f010c59b:	8b 40 64             	mov    0x64(%eax),%eax
f010c59e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c5a1:	c1 e2 02             	shl    $0x2,%edx
f010c5a4:	01 d0                	add    %edx,%eax
f010c5a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c5ac:	ff 45 f4             	incl   -0xc(%ebp)
f010c5af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5b2:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c5b7:	76 df                	jbe    f010c598 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c5b9:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c5c0:	eb 22                	jmp    f010c5e4 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c5c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c5:	8b 40 64             	mov    0x64(%eax),%eax
f010c5c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c5cb:	c1 e2 02             	shl    $0x2,%edx
f010c5ce:	01 c2                	add    %eax,%edx
f010c5d0:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f010c5d5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c5d8:	c1 e1 02             	shl    $0x2,%ecx
f010c5db:	01 c8                	add    %ecx,%eax
f010c5dd:	8b 00                	mov    (%eax),%eax
f010c5df:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c5e1:	ff 45 f4             	incl   -0xc(%ebp)
f010c5e4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c5eb:	7e d5                	jle    f010c5c2 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c5ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5f0:	8b 40 64             	mov    0x64(%eax),%eax
f010c5f3:	83 ec 0c             	sub    $0xc,%esp
f010c5f6:	50                   	push   %eax
f010c5f7:	e8 58 fe ff ff       	call   f010c454 <create_user_kern_stack>
f010c5fc:	83 c4 10             	add    $0x10,%esp
f010c5ff:	89 c2                	mov    %eax,%edx
f010c601:	8b 45 08             	mov    0x8(%ebp),%eax
f010c604:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c607:	8b 45 08             	mov    0x8(%ebp),%eax
f010c60a:	8b 40 70             	mov    0x70(%eax),%eax
f010c60d:	05 00 80 00 00       	add    $0x8000,%eax
f010c612:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c615:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c619:	8b 45 08             	mov    0x8(%ebp),%eax
f010c61c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c61f:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c621:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c625:	ba 64 e6 10 f0       	mov    $0xf010e664,%edx
f010c62a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c62d:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c62f:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c633:	8b 45 08             	mov    0x8(%ebp),%eax
f010c636:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c639:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c63c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c63f:	8b 40 04             	mov    0x4(%eax),%eax
f010c642:	83 ec 04             	sub    $0x4,%esp
f010c645:	6a 20                	push   $0x20
f010c647:	6a 00                	push   $0x0
f010c649:	50                   	push   %eax
f010c64a:	e8 bb 37 01 00       	call   f011fe0a <memset>
f010c64f:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c652:	8b 45 08             	mov    0x8(%ebp),%eax
f010c655:	8b 40 04             	mov    0x4(%eax),%eax
f010c658:	ba 46 b9 10 f0       	mov    $0xf010b946,%edx
f010c65d:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c660:	8b 45 08             	mov    0x8(%ebp),%eax
f010c663:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c66a:	00 00 00 
f010c66d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c670:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c677:	00 00 00 
f010c67a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c67d:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c684:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c687:	83 ec 0c             	sub    $0xc,%esp
f010c68a:	6a 02                	push   $0x2
f010c68c:	e8 8a 2f 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010c691:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c694:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c69b:	eb 54                	jmp    f010c6f1 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c69d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c6a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6a3:	89 d0                	mov    %edx,%eax
f010c6a5:	01 c0                	add    %eax,%eax
f010c6a7:	01 d0                	add    %edx,%eax
f010c6a9:	c1 e0 03             	shl    $0x3,%eax
f010c6ac:	01 c8                	add    %ecx,%eax
f010c6ae:	05 ac 00 00 00       	add    $0xac,%eax
f010c6b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c6b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c6bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6bf:	89 d0                	mov    %edx,%eax
f010c6c1:	01 c0                	add    %eax,%eax
f010c6c3:	01 d0                	add    %edx,%eax
f010c6c5:	c1 e0 03             	shl    $0x3,%eax
f010c6c8:	01 c8                	add    %ecx,%eax
f010c6ca:	05 b0 00 00 00       	add    $0xb0,%eax
f010c6cf:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c6d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c6d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6d8:	89 d0                	mov    %edx,%eax
f010c6da:	01 c0                	add    %eax,%eax
f010c6dc:	01 d0                	add    %edx,%eax
f010c6de:	c1 e0 03             	shl    $0x3,%eax
f010c6e1:	01 c8                	add    %ecx,%eax
f010c6e3:	05 b4 00 00 00       	add    $0xb4,%eax
f010c6e8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c6ee:	ff 45 f4             	incl   -0xc(%ebp)
f010c6f1:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c6f5:	7e a6                	jle    f010c69d <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c6f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6fa:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c701:	00 00 00 

	e->pageFaultsCounter=0;
f010c704:	8b 45 08             	mov    0x8(%ebp),%eax
f010c707:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c70e:	00 00 00 
	e->tableFaultsCounter=0;
f010c711:	8b 45 08             	mov    0x8(%ebp),%eax
f010c714:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c71b:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c71e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c721:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c728:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c72b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c72e:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c735:	00 00 00 

	e->nModifiedPages=0;
f010c738:	8b 45 08             	mov    0x8(%ebp),%eax
f010c73b:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c742:	00 00 00 
	e->nNotModifiedPages=0;
f010c745:	8b 45 08             	mov    0x8(%ebp),%eax
f010c748:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c74f:	00 00 00 
	e->nClocks = 0;
f010c752:	8b 45 08             	mov    0x8(%ebp),%eax
f010c755:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c75c:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c75f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c762:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c769:	00 00 00 
	e->nPageOut = 0;
f010c76c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c76f:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c776:	00 00 00 
	e->nNewPageAdded = 0;
f010c779:	8b 45 08             	mov    0x8(%ebp),%eax
f010c77c:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c783:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c786:	83 ec 04             	sub    $0x4,%esp
f010c789:	68 00 00 00 82       	push   $0x82000000
f010c78e:	68 00 00 00 80       	push   $0x80000000
f010c793:	ff 75 08             	pushl  0x8(%ebp)
f010c796:	e8 a8 fd ff ff       	call   f010c543 <initialize_uheap_dynamic_allocator>
f010c79b:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c79e:	83 ec 0c             	sub    $0xc,%esp
f010c7a1:	ff 75 08             	pushl  0x8(%ebp)
f010c7a4:	e8 06 00 00 00       	call   f010c7af <complete_environment_initialization>
f010c7a9:	83 c4 10             	add    $0x10,%esp
}
f010c7ac:	90                   	nop
f010c7ad:	c9                   	leave  
f010c7ae:	c3                   	ret    

f010c7af <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c7af:	55                   	push   %ebp
f010c7b0:	89 e5                	mov    %esp,%ebp
f010c7b2:	53                   	push   %ebx
f010c7b3:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c7b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7b9:	8b 40 64             	mov    0x64(%eax),%eax
f010c7bc:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c7c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c5:	8b 40 68             	mov    0x68(%eax),%eax
f010c7c8:	83 c8 03             	or     $0x3,%eax
f010c7cb:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c7cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7d0:	8b 40 64             	mov    0x64(%eax),%eax
f010c7d3:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c7d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7dc:	8b 40 68             	mov    0x68(%eax),%eax
f010c7df:	83 c8 05             	or     $0x5,%eax
f010c7e2:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c7e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7e7:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c7ee:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c7f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7f4:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c7fb:	00 00 00 
	e->disk_env_tabledir = 0;
f010c7fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c801:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c808:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c80b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c80e:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c815:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c818:	8b 45 08             	mov    0x8(%ebp),%eax
f010c81b:	8b 58 10             	mov    0x10(%eax),%ebx
f010c81e:	83 ec 0c             	sub    $0xc,%esp
f010c821:	68 ca 02 00 00       	push   $0x2ca
f010c826:	e8 84 19 01 00       	call   f011e1af <log2_ceil>
f010c82b:	83 c4 10             	add    $0x10,%esp
f010c82e:	ba 01 00 00 00       	mov    $0x1,%edx
f010c833:	88 c1                	mov    %al,%cl
f010c835:	d3 e2                	shl    %cl,%edx
f010c837:	89 d0                	mov    %edx,%eax
f010c839:	01 d8                	add    %ebx,%eax
f010c83b:	89 c3                	mov    %eax,%ebx
f010c83d:	83 ec 0c             	sub    $0xc,%esp
f010c840:	68 ca 02 00 00       	push   $0x2ca
f010c845:	e8 30 19 01 00       	call   f011e17a <nearest_pow2_ceil>
f010c84a:	83 c4 10             	add    $0x10,%esp
f010c84d:	f7 d8                	neg    %eax
f010c84f:	21 d8                	and    %ebx,%eax
f010c851:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c854:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c858:	7f 1e                	jg     f010c878 <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c85a:	83 ec 0c             	sub    $0xc,%esp
f010c85d:	68 ca 02 00 00       	push   $0x2ca
f010c862:	e8 48 19 01 00       	call   f011e1af <log2_ceil>
f010c867:	83 c4 10             	add    $0x10,%esp
f010c86a:	ba 01 00 00 00       	mov    $0x1,%edx
f010c86f:	88 c1                	mov    %al,%cl
f010c871:	d3 e2                	shl    %cl,%edx
f010c873:	89 d0                	mov    %edx,%eax
f010c875:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c878:	8b 45 08             	mov    0x8(%ebp),%eax
f010c87b:	8b 15 74 a3 69 f0    	mov    0xf069a374,%edx
f010c881:	29 d0                	sub    %edx,%eax
f010c883:	c1 f8 02             	sar    $0x2,%eax
f010c886:	89 c2                	mov    %eax,%edx
f010c888:	89 d0                	mov    %edx,%eax
f010c88a:	c1 e0 03             	shl    $0x3,%eax
f010c88d:	01 d0                	add    %edx,%eax
f010c88f:	c1 e0 03             	shl    $0x3,%eax
f010c892:	01 d0                	add    %edx,%eax
f010c894:	c1 e0 02             	shl    $0x2,%eax
f010c897:	01 d0                	add    %edx,%eax
f010c899:	01 c0                	add    %eax,%eax
f010c89b:	01 d0                	add    %edx,%eax
f010c89d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c8a4:	01 c8                	add    %ecx,%eax
f010c8a6:	c1 e0 02             	shl    $0x2,%eax
f010c8a9:	01 d0                	add    %edx,%eax
f010c8ab:	c1 e0 03             	shl    $0x3,%eax
f010c8ae:	01 d0                	add    %edx,%eax
f010c8b0:	c1 e0 05             	shl    $0x5,%eax
f010c8b3:	29 d0                	sub    %edx,%eax
f010c8b5:	c1 e0 02             	shl    $0x2,%eax
f010c8b8:	01 d0                	add    %edx,%eax
f010c8ba:	01 c0                	add    %eax,%eax
f010c8bc:	01 d0                	add    %edx,%eax
f010c8be:	c1 e0 03             	shl    $0x3,%eax
f010c8c1:	01 d0                	add    %edx,%eax
f010c8c3:	c1 e0 04             	shl    $0x4,%eax
f010c8c6:	29 d0                	sub    %edx,%eax
f010c8c8:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c8cb:	89 c2                	mov    %eax,%edx
f010c8cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8d0:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c8d3:	e8 08 f1 ff ff       	call   f010b9e0 <get_cpu_proc>
f010c8d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c8db:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c8df:	75 0c                	jne    f010c8ed <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c8e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c8eb:	eb 0c                	jmp    f010c8f9 <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c8ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c8f0:	8b 50 10             	mov    0x10(%eax),%edx
f010c8f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8f6:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c8f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8fc:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c903:	8b 45 08             	mov    0x8(%ebp),%eax
f010c906:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c90d:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c910:	8b 45 08             	mov    0x8(%ebp),%eax
f010c913:	8b 00                	mov    (%eax),%eax
f010c915:	83 ec 04             	sub    $0x4,%esp
f010c918:	6a 44                	push   $0x44
f010c91a:	6a 00                	push   $0x0
f010c91c:	50                   	push   %eax
f010c91d:	e8 e8 34 01 00       	call   f011fe0a <memset>
f010c922:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c925:	8b 45 08             	mov    0x8(%ebp),%eax
f010c928:	8b 00                	mov    (%eax),%eax
f010c92a:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c930:	8b 45 08             	mov    0x8(%ebp),%eax
f010c933:	8b 00                	mov    (%eax),%eax
f010c935:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c93b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c93e:	8b 00                	mov    (%eax),%eax
f010c940:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c946:	8b 45 08             	mov    0x8(%ebp),%eax
f010c949:	8b 00                	mov    (%eax),%eax
f010c94b:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c952:	8b 45 08             	mov    0x8(%ebp),%eax
f010c955:	8b 00                	mov    (%eax),%eax
f010c957:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c95d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c960:	8b 00                	mov    (%eax),%eax
f010c962:	8b 55 08             	mov    0x8(%ebp),%edx
f010c965:	8b 12                	mov    (%edx),%edx
f010c967:	8b 52 38             	mov    0x38(%edx),%edx
f010c96a:	80 ce 02             	or     $0x2,%dh
f010c96d:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c970:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c974:	75 17                	jne    f010c98d <complete_environment_initialization+0x1de>
f010c976:	83 ec 04             	sub    $0x4,%esp
f010c979:	68 7b 62 12 f0       	push   $0xf012627b
f010c97e:	68 67 04 00 00       	push   $0x467
f010c983:	68 f3 61 12 f0       	push   $0xf01261f3
f010c988:	e8 ac 39 ff ff       	call   f0100339 <_panic>
f010c98d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c990:	8b 40 08             	mov    0x8(%eax),%eax
f010c993:	85 c0                	test   %eax,%eax
f010c995:	74 11                	je     f010c9a8 <complete_environment_initialization+0x1f9>
f010c997:	8b 45 08             	mov    0x8(%ebp),%eax
f010c99a:	8b 40 08             	mov    0x8(%eax),%eax
f010c99d:	8b 55 08             	mov    0x8(%ebp),%edx
f010c9a0:	8b 52 0c             	mov    0xc(%edx),%edx
f010c9a3:	89 50 0c             	mov    %edx,0xc(%eax)
f010c9a6:	eb 0b                	jmp    f010c9b3 <complete_environment_initialization+0x204>
f010c9a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9ab:	8b 40 0c             	mov    0xc(%eax),%eax
f010c9ae:	a3 7c a3 69 f0       	mov    %eax,0xf069a37c
f010c9b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9b6:	8b 40 0c             	mov    0xc(%eax),%eax
f010c9b9:	85 c0                	test   %eax,%eax
f010c9bb:	74 11                	je     f010c9ce <complete_environment_initialization+0x21f>
f010c9bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9c0:	8b 40 0c             	mov    0xc(%eax),%eax
f010c9c3:	8b 55 08             	mov    0x8(%ebp),%edx
f010c9c6:	8b 52 08             	mov    0x8(%edx),%edx
f010c9c9:	89 50 08             	mov    %edx,0x8(%eax)
f010c9cc:	eb 0b                	jmp    f010c9d9 <complete_environment_initialization+0x22a>
f010c9ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9d1:	8b 40 08             	mov    0x8(%eax),%eax
f010c9d4:	a3 78 a3 69 f0       	mov    %eax,0xf069a378
f010c9d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c9e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9e6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c9ed:	a1 84 a3 69 f0       	mov    0xf069a384,%eax
f010c9f2:	48                   	dec    %eax
f010c9f3:	a3 84 a3 69 f0       	mov    %eax,0xf069a384
	return ;
f010c9f8:	90                   	nop
}
f010c9f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c9fc:	c9                   	leave  
f010c9fd:	c3                   	ret    

f010c9fe <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c9fe:	55                   	push   %ebp
f010c9ff:	89 e5                	mov    %esp,%ebp
f010ca01:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca04:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca07:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010ca0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca0d:	8b 00                	mov    (%eax),%eax
f010ca0f:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ca14:	74 17                	je     f010ca2d <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010ca16:	83 ec 04             	sub    $0x4,%esp
f010ca19:	68 a1 64 12 f0       	push   $0xf01264a1
f010ca1e:	68 73 04 00 00       	push   $0x473
f010ca23:	68 f3 61 12 f0       	push   $0xf01261f3
f010ca28:	e8 0c 39 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010ca2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca30:	8b 00                	mov    (%eax),%eax
f010ca32:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca35:	8b 52 18             	mov    0x18(%edx),%edx
f010ca38:	89 50 30             	mov    %edx,0x30(%eax)
}
f010ca3b:	90                   	nop
f010ca3c:	c9                   	leave  
f010ca3d:	c3                   	ret    

f010ca3e <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010ca3e:	55                   	push   %ebp
f010ca3f:	89 e5                	mov    %esp,%ebp
f010ca41:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010ca44:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca47:	8b 40 10             	mov    0x10(%eax),%eax
f010ca4a:	8d 48 01             	lea    0x1(%eax),%ecx
f010ca4d:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca50:	89 4a 10             	mov    %ecx,0x10(%edx)
f010ca53:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca56:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca59:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010ca5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca5f:	8b 00                	mov    (%eax),%eax
f010ca61:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ca66:	74 17                	je     f010ca7f <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010ca68:	83 ec 04             	sub    $0x4,%esp
f010ca6b:	68 a1 64 12 f0       	push   $0xf01264a1
f010ca70:	68 81 04 00 00       	push   $0x481
f010ca75:	68 f3 61 12 f0       	push   $0xf01261f3
f010ca7a:	e8 ba 38 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010ca7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca82:	8b 50 1c             	mov    0x1c(%eax),%edx
f010ca85:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca88:	01 d0                	add    %edx,%eax
f010ca8a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010ca8d:	eb 0f                	jmp    f010ca9e <PROGRAM_SEGMENT_NEXT+0x60>
f010ca8f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca92:	8b 40 10             	mov    0x10(%eax),%eax
f010ca95:	8d 50 01             	lea    0x1(%eax),%edx
f010ca98:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca9b:	89 50 10             	mov    %edx,0x10(%eax)
f010ca9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010caa1:	8b 40 10             	mov    0x10(%eax),%eax
f010caa4:	c1 e0 05             	shl    $0x5,%eax
f010caa7:	89 c2                	mov    %eax,%edx
f010caa9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010caac:	01 d0                	add    %edx,%eax
f010caae:	8b 00                	mov    (%eax),%eax
f010cab0:	83 f8 01             	cmp    $0x1,%eax
f010cab3:	74 13                	je     f010cac8 <PROGRAM_SEGMENT_NEXT+0x8a>
f010cab5:	8b 45 08             	mov    0x8(%ebp),%eax
f010cab8:	8b 50 10             	mov    0x10(%eax),%edx
f010cabb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cabe:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cac1:	0f b7 c0             	movzwl %ax,%eax
f010cac4:	39 c2                	cmp    %eax,%edx
f010cac6:	72 c7                	jb     f010ca8f <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010cac8:	8b 45 08             	mov    0x8(%ebp),%eax
f010cacb:	8b 40 10             	mov    0x10(%eax),%eax
f010cace:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010cad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cad4:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cad7:	0f b7 c0             	movzwl %ax,%eax
f010cada:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010cadd:	7e 63                	jle    f010cb42 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cadf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cae2:	c1 e0 05             	shl    $0x5,%eax
f010cae5:	89 c2                	mov    %eax,%edx
f010cae7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010caea:	01 d0                	add    %edx,%eax
f010caec:	8b 50 04             	mov    0x4(%eax),%edx
f010caef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010caf2:	01 c2                	add    %eax,%edx
f010caf4:	8b 45 08             	mov    0x8(%ebp),%eax
f010caf7:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010caf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cafc:	c1 e0 05             	shl    $0x5,%eax
f010caff:	89 c2                	mov    %eax,%edx
f010cb01:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb04:	01 d0                	add    %edx,%eax
f010cb06:	8b 50 14             	mov    0x14(%eax),%edx
f010cb09:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb0c:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010cb0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb12:	c1 e0 05             	shl    $0x5,%eax
f010cb15:	89 c2                	mov    %eax,%edx
f010cb17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb1a:	01 d0                	add    %edx,%eax
f010cb1c:	8b 50 10             	mov    0x10(%eax),%edx
f010cb1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb22:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010cb25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb28:	c1 e0 05             	shl    $0x5,%eax
f010cb2b:	89 c2                	mov    %eax,%edx
f010cb2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb30:	01 d0                	add    %edx,%eax
f010cb32:	8b 40 08             	mov    0x8(%eax),%eax
f010cb35:	89 c2                	mov    %eax,%edx
f010cb37:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb3a:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010cb3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb40:	eb 05                	jmp    f010cb47 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010cb42:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010cb47:	c9                   	leave  
f010cb48:	c3                   	ret    

f010cb49 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010cb49:	55                   	push   %ebp
f010cb4a:	89 e5                	mov    %esp,%ebp
f010cb4c:	57                   	push   %edi
f010cb4d:	56                   	push   %esi
f010cb4e:	53                   	push   %ebx
f010cb4f:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010cb52:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cb59:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cb5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb62:	8b 00                	mov    (%eax),%eax
f010cb64:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cb69:	74 17                	je     f010cb82 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cb6b:	83 ec 04             	sub    $0x4,%esp
f010cb6e:	68 a1 64 12 f0       	push   $0xf01264a1
f010cb73:	68 9d 04 00 00       	push   $0x49d
f010cb78:	68 f3 61 12 f0       	push   $0xf01261f3
f010cb7d:	e8 b7 37 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cb82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb85:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cb88:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb8b:	01 d0                	add    %edx,%eax
f010cb8d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cb90:	eb 07                	jmp    f010cb99 <PROGRAM_SEGMENT_FIRST+0x50>
f010cb92:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb95:	40                   	inc    %eax
f010cb96:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cb99:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb9c:	c1 e0 05             	shl    $0x5,%eax
f010cb9f:	89 c2                	mov    %eax,%edx
f010cba1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cba4:	01 d0                	add    %edx,%eax
f010cba6:	8b 00                	mov    (%eax),%eax
f010cba8:	83 f8 01             	cmp    $0x1,%eax
f010cbab:	74 10                	je     f010cbbd <PROGRAM_SEGMENT_FIRST+0x74>
f010cbad:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cbb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cbb3:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cbb6:	0f b7 c0             	movzwl %ax,%eax
f010cbb9:	39 c2                	cmp    %eax,%edx
f010cbbb:	72 d5                	jb     f010cb92 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cbbd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cbc0:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cbc3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cbc6:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cbc9:	0f b7 c0             	movzwl %ax,%eax
f010cbcc:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cbcf:	7e 68                	jle    f010cc39 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cbd1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cbd4:	c1 e0 05             	shl    $0x5,%eax
f010cbd7:	89 c2                	mov    %eax,%edx
f010cbd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cbdc:	01 d0                	add    %edx,%eax
f010cbde:	8b 50 04             	mov    0x4(%eax),%edx
f010cbe1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cbe4:	01 d0                	add    %edx,%eax
f010cbe6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cbe9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cbec:	c1 e0 05             	shl    $0x5,%eax
f010cbef:	89 c2                	mov    %eax,%edx
f010cbf1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cbf4:	01 d0                	add    %edx,%eax
f010cbf6:	8b 40 14             	mov    0x14(%eax),%eax
f010cbf9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cbfc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cbff:	c1 e0 05             	shl    $0x5,%eax
f010cc02:	89 c2                	mov    %eax,%edx
f010cc04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc07:	01 d0                	add    %edx,%eax
f010cc09:	8b 40 10             	mov    0x10(%eax),%eax
f010cc0c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cc0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc12:	c1 e0 05             	shl    $0x5,%eax
f010cc15:	89 c2                	mov    %eax,%edx
f010cc17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc1a:	01 d0                	add    %edx,%eax
f010cc1c:	8b 40 08             	mov    0x8(%eax),%eax
f010cc1f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cc22:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc25:	89 c3                	mov    %eax,%ebx
f010cc27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cc2a:	ba 05 00 00 00       	mov    $0x5,%edx
f010cc2f:	89 df                	mov    %ebx,%edi
f010cc31:	89 c6                	mov    %eax,%esi
f010cc33:	89 d1                	mov    %edx,%ecx
f010cc35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cc37:	eb 1c                	jmp    f010cc55 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cc39:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cc40:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc43:	89 c3                	mov    %eax,%ebx
f010cc45:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cc48:	ba 05 00 00 00       	mov    $0x5,%edx
f010cc4d:	89 df                	mov    %ebx,%edi
f010cc4f:	89 c6                	mov    %eax,%esi
f010cc51:	89 d1                	mov    %edx,%ecx
f010cc53:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cc55:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc58:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cc5b:	5b                   	pop    %ebx
f010cc5c:	5e                   	pop    %esi
f010cc5d:	5f                   	pop    %edi
f010cc5e:	5d                   	pop    %ebp
f010cc5f:	c2 04 00             	ret    $0x4

f010cc62 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cc62:	55                   	push   %ebp
f010cc63:	89 e5                	mov    %esp,%ebp
f010cc65:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cc68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010cc6f:	83 ec 0c             	sub    $0xc,%esp
f010cc72:	68 20 2f ac f0       	push   $0xf0ac2f20
f010cc77:	e8 f2 2f 00 00       	call   f010fc6e <acquire_spinlock>
f010cc7c:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cc7f:	a1 10 2f ac f0       	mov    0xf0ac2f10,%eax
f010cc84:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cc87:	e9 c3 00 00 00       	jmp    f010cd4f <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010cc8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc8f:	8b 40 0c             	mov    0xc(%eax),%eax
f010cc92:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cc95:	0f 85 ac 00 00 00    	jne    f010cd47 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cc9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc9e:	8b 50 10             	mov    0x10(%eax),%edx
f010cca1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cca4:	8b 40 0c             	mov    0xc(%eax),%eax
f010cca7:	8b 40 64             	mov    0x64(%eax),%eax
f010ccaa:	83 ec 08             	sub    $0x8,%esp
f010ccad:	52                   	push   %edx
f010ccae:	50                   	push   %eax
f010ccaf:	e8 bd d0 ff ff       	call   f0109d71 <pt_clear_page_table_entry>
f010ccb4:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010ccb7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ccbb:	75 17                	jne    f010ccd4 <cleanup_buffers+0x72>
f010ccbd:	83 ec 04             	sub    $0x4,%esp
f010ccc0:	68 7b 62 12 f0       	push   $0xf012627b
f010ccc5:	68 c6 04 00 00       	push   $0x4c6
f010ccca:	68 f3 61 12 f0       	push   $0xf01261f3
f010cccf:	e8 65 36 ff ff       	call   f0100339 <_panic>
f010ccd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccd7:	8b 00                	mov    (%eax),%eax
f010ccd9:	85 c0                	test   %eax,%eax
f010ccdb:	74 10                	je     f010cced <cleanup_buffers+0x8b>
f010ccdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cce0:	8b 00                	mov    (%eax),%eax
f010cce2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cce5:	8b 52 04             	mov    0x4(%edx),%edx
f010cce8:	89 50 04             	mov    %edx,0x4(%eax)
f010cceb:	eb 0b                	jmp    f010ccf8 <cleanup_buffers+0x96>
f010cced:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccf0:	8b 40 04             	mov    0x4(%eax),%eax
f010ccf3:	a3 14 2f ac f0       	mov    %eax,0xf0ac2f14
f010ccf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccfb:	8b 40 04             	mov    0x4(%eax),%eax
f010ccfe:	85 c0                	test   %eax,%eax
f010cd00:	74 0f                	je     f010cd11 <cleanup_buffers+0xaf>
f010cd02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd05:	8b 40 04             	mov    0x4(%eax),%eax
f010cd08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd0b:	8b 12                	mov    (%edx),%edx
f010cd0d:	89 10                	mov    %edx,(%eax)
f010cd0f:	eb 0a                	jmp    f010cd1b <cleanup_buffers+0xb9>
f010cd11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd14:	8b 00                	mov    (%eax),%eax
f010cd16:	a3 10 2f ac f0       	mov    %eax,0xf0ac2f10
f010cd1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd1e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cd24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd27:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cd2e:	a1 1c 2f ac f0       	mov    0xf0ac2f1c,%eax
f010cd33:	48                   	dec    %eax
f010cd34:	a3 1c 2f ac f0       	mov    %eax,0xf0ac2f1c

				free_frame(ptr_fi);
f010cd39:	83 ec 0c             	sub    $0xc,%esp
f010cd3c:	ff 75 f4             	pushl  -0xc(%ebp)
f010cd3f:	e8 c2 b5 ff ff       	call   f0108306 <free_frame>
f010cd44:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cd47:	a1 18 2f ac f0       	mov    0xf0ac2f18,%eax
f010cd4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cd4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd53:	74 07                	je     f010cd5c <cleanup_buffers+0xfa>
f010cd55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd58:	8b 00                	mov    (%eax),%eax
f010cd5a:	eb 05                	jmp    f010cd61 <cleanup_buffers+0xff>
f010cd5c:	b8 00 00 00 00       	mov    $0x0,%eax
f010cd61:	a3 18 2f ac f0       	mov    %eax,0xf0ac2f18
f010cd66:	a1 18 2f ac f0       	mov    0xf0ac2f18,%eax
f010cd6b:	85 c0                	test   %eax,%eax
f010cd6d:	0f 85 19 ff ff ff    	jne    f010cc8c <cleanup_buffers+0x2a>
f010cd73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd77:	0f 85 0f ff ff ff    	jne    f010cc8c <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010cd7d:	83 ec 0c             	sub    $0xc,%esp
f010cd80:	68 20 2f ac f0       	push   $0xf0ac2f20
f010cd85:	e8 6b 2f 00 00       	call   f010fcf5 <release_spinlock>
f010cd8a:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010cd8d:	90                   	nop
f010cd8e:	c9                   	leave  
f010cd8f:	c3                   	ret    

f010cd90 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010cd90:	55                   	push   %ebp
f010cd91:	89 e5                	mov    %esp,%ebp
f010cd93:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010cd96:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010cd9a:	7e 06                	jle    f010cda2 <set_program_priority+0x12>
f010cd9c:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cda0:	7e 14                	jle    f010cdb6 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010cda2:	83 ec 04             	sub    $0x4,%esp
f010cda5:	68 b8 64 12 f0       	push   $0xf01264b8
f010cdaa:	6a 10                	push   $0x10
f010cdac:	68 dc 64 12 f0       	push   $0xf01264dc
f010cdb1:	e8 83 35 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010cdb6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010cdba:	74 78                	je     f010ce34 <set_program_priority+0xa4>
		return;
	switch(priority)
f010cdbc:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cdc0:	77 56                	ja     f010ce18 <set_program_priority+0x88>
f010cdc2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cdc5:	c1 e0 02             	shl    $0x2,%eax
f010cdc8:	05 18 65 12 f0       	add    $0xf0126518,%eax
f010cdcd:	8b 00                	mov    (%eax),%eax
f010cdcf:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010cdd1:	83 ec 08             	sub    $0x8,%esp
f010cdd4:	6a 01                	push   $0x1
f010cdd6:	ff 75 08             	pushl  0x8(%ebp)
f010cdd9:	e8 ea dc ff ff       	call   f010aac8 <half_WS_Size>
f010cdde:	83 c4 10             	add    $0x10,%esp
			break;
f010cde1:	eb 35                	jmp    f010ce18 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010cde3:	83 ec 08             	sub    $0x8,%esp
f010cde6:	6a 00                	push   $0x0
f010cde8:	ff 75 08             	pushl  0x8(%ebp)
f010cdeb:	e8 d8 dc ff ff       	call   f010aac8 <half_WS_Size>
f010cdf0:	83 c4 10             	add    $0x10,%esp
			break;
f010cdf3:	eb 23                	jmp    f010ce18 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010cdf5:	83 ec 08             	sub    $0x8,%esp
f010cdf8:	6a 01                	push   $0x1
f010cdfa:	ff 75 08             	pushl  0x8(%ebp)
f010cdfd:	e8 a9 dc ff ff       	call   f010aaab <double_WS_Size>
f010ce02:	83 c4 10             	add    $0x10,%esp
			break;
f010ce05:	eb 11                	jmp    f010ce18 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010ce07:	83 ec 08             	sub    $0x8,%esp
f010ce0a:	6a 00                	push   $0x0
f010ce0c:	ff 75 08             	pushl  0x8(%ebp)
f010ce0f:	e8 97 dc ff ff       	call   f010aaab <double_WS_Size>
f010ce14:	83 c4 10             	add    $0x10,%esp
			break;
f010ce17:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010ce18:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce1b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010ce21:	83 ec 08             	sub    $0x8,%esp
f010ce24:	50                   	push   %eax
f010ce25:	68 f9 64 12 f0       	push   $0xf01264f9
f010ce2a:	e8 5c 41 ff ff       	call   f0100f8b <cprintf>
f010ce2f:	83 c4 10             	add    $0x10,%esp
f010ce32:	eb 01                	jmp    f010ce35 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010ce34:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010ce35:	c9                   	leave  
f010ce36:	c3                   	ret    

f010ce37 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010ce37:	55                   	push   %ebp
f010ce38:	89 e5                	mov    %esp,%ebp
f010ce3a:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ce44:	eb 29                	jmp    f010ce6f <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010ce46:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce49:	89 d0                	mov    %edx,%eax
f010ce4b:	01 c0                	add    %eax,%eax
f010ce4d:	01 d0                	add    %edx,%eax
f010ce4f:	c1 e0 02             	shl    $0x2,%eax
f010ce52:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010ce57:	8b 00                	mov    (%eax),%eax
f010ce59:	83 ec 08             	sub    $0x8,%esp
f010ce5c:	50                   	push   %eax
f010ce5d:	ff 75 08             	pushl  0x8(%ebp)
f010ce60:	e8 c3 2e 01 00       	call   f011fd28 <strcmp>
f010ce65:	83 c4 10             	add    $0x10,%esp
f010ce68:	85 c0                	test   %eax,%eax
f010ce6a:	74 0f                	je     f010ce7b <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce6c:	ff 45 f4             	incl   -0xc(%ebp)
f010ce6f:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ce74:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce77:	7c cd                	jl     f010ce46 <get_user_program_info+0xf>
f010ce79:	eb 01                	jmp    f010ce7c <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010ce7b:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010ce7c:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ce81:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce84:	75 1a                	jne    f010cea0 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010ce86:	83 ec 08             	sub    $0x8,%esp
f010ce89:	ff 75 08             	pushl  0x8(%ebp)
f010ce8c:	68 7d 72 12 f0       	push   $0xf012727d
f010ce91:	e8 f5 40 ff ff       	call   f0100f8b <cprintf>
f010ce96:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ce99:	b8 00 00 00 00       	mov    $0x0,%eax
f010ce9e:	eb 11                	jmp    f010ceb1 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010cea0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cea3:	89 d0                	mov    %edx,%eax
f010cea5:	01 c0                	add    %eax,%eax
f010cea7:	01 d0                	add    %edx,%eax
f010cea9:	c1 e0 02             	shl    $0x2,%eax
f010ceac:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010ceb1:	c9                   	leave  
f010ceb2:	c3                   	ret    

f010ceb3 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010ceb3:	55                   	push   %ebp
f010ceb4:	89 e5                	mov    %esp,%ebp
f010ceb6:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ceb9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cec0:	eb 2d                	jmp    f010ceef <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010cec2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cec5:	89 d0                	mov    %edx,%eax
f010cec7:	01 c0                	add    %eax,%eax
f010cec9:	01 d0                	add    %edx,%eax
f010cecb:	c1 e0 02             	shl    $0x2,%eax
f010cece:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010ced3:	8b 00                	mov    (%eax),%eax
f010ced5:	8b 55 08             	mov    0x8(%ebp),%edx
f010ced8:	83 c2 20             	add    $0x20,%edx
f010cedb:	83 ec 08             	sub    $0x8,%esp
f010cede:	50                   	push   %eax
f010cedf:	52                   	push   %edx
f010cee0:	e8 43 2e 01 00       	call   f011fd28 <strcmp>
f010cee5:	83 c4 10             	add    $0x10,%esp
f010cee8:	85 c0                	test   %eax,%eax
f010ceea:	74 0f                	je     f010cefb <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ceec:	ff 45 f4             	incl   -0xc(%ebp)
f010ceef:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cef4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cef7:	7c c9                	jl     f010cec2 <get_user_program_info_by_env+0xf>
f010cef9:	eb 01                	jmp    f010cefc <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010cefb:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cefc:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cf01:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf04:	75 17                	jne    f010cf1d <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010cf06:	83 ec 0c             	sub    $0xc,%esp
f010cf09:	68 98 72 12 f0       	push   $0xf0127298
f010cf0e:	e8 78 40 ff ff       	call   f0100f8b <cprintf>
f010cf13:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cf16:	b8 00 00 00 00       	mov    $0x0,%eax
f010cf1b:	eb 11                	jmp    f010cf2e <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010cf1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf20:	89 d0                	mov    %edx,%eax
f010cf22:	01 c0                	add    %eax,%eax
f010cf24:	01 d0                	add    %edx,%eax
f010cf26:	c1 e0 02             	shl    $0x2,%eax
f010cf29:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010cf2e:	c9                   	leave  
f010cf2f:	c3                   	ret    

f010cf30 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010cf30:	55                   	push   %ebp
f010cf31:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010cf33:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf36:	83 f8 13             	cmp    $0x13,%eax
f010cf39:	77 0c                	ja     f010cf47 <trapname+0x17>
		return excnames[trapno];
f010cf3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf3e:	8b 04 85 80 76 12 f0 	mov    -0xfed8980(,%eax,4),%eax
f010cf45:	eb 2c                	jmp    f010cf73 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010cf47:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010cf4b:	75 07                	jne    f010cf54 <trapname+0x24>
		return "System call";
f010cf4d:	b8 c0 72 12 f0       	mov    $0xf01272c0,%eax
f010cf52:	eb 1f                	jmp    f010cf73 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010cf54:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010cf58:	75 07                	jne    f010cf61 <trapname+0x31>
		return "Clock Interrupt";
f010cf5a:	b8 cc 72 12 f0       	mov    $0xf01272cc,%eax
f010cf5f:	eb 12                	jmp    f010cf73 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010cf61:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010cf65:	75 07                	jne    f010cf6e <trapname+0x3e>
		return "Keyboard Interrupt";
f010cf67:	b8 dc 72 12 f0       	mov    $0xf01272dc,%eax
f010cf6c:	eb 05                	jmp    f010cf73 <trapname+0x43>
	return "(unknown trap)";
f010cf6e:	b8 ef 72 12 f0       	mov    $0xf01272ef,%eax
}
f010cf73:	5d                   	pop    %ebp
f010cf74:	c3                   	ret    

f010cf75 <ts_init>:


void ts_init(void)
{
f010cf75:	55                   	push   %ebp
f010cf76:	89 e5                	mov    %esp,%ebp
f010cf78:	53                   	push   %ebx
f010cf79:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010cf7c:	e8 4e a2 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010cf81:	e8 86 a1 ff ff       	call   f010710c <mycpu>
f010cf86:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010cf89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf8c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010cf93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf96:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010cf9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf9f:	83 c0 0c             	add    $0xc,%eax
f010cfa2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cfa5:	83 c2 0c             	add    $0xc,%edx
f010cfa8:	c1 ea 10             	shr    $0x10,%edx
f010cfab:	88 d3                	mov    %dl,%bl
f010cfad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cfb0:	83 c2 0c             	add    $0xc,%edx
f010cfb3:	c1 ea 18             	shr    $0x18,%edx
f010cfb6:	88 d1                	mov    %dl,%cl
f010cfb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cfbb:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010cfc2:	68 00 
f010cfc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cfc7:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010cfce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfd1:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010cfd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfda:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cfe0:	83 e2 f0             	and    $0xfffffff0,%edx
f010cfe3:	83 ca 09             	or     $0x9,%edx
f010cfe6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cfec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfef:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cff5:	83 ca 10             	or     $0x10,%edx
f010cff8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cffe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d001:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d007:	83 e2 9f             	and    $0xffffff9f,%edx
f010d00a:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d010:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d013:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d019:	83 ca 80             	or     $0xffffff80,%edx
f010d01c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d022:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d025:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d02b:	83 e2 f0             	and    $0xfffffff0,%edx
f010d02e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d034:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d037:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d03d:	83 e2 ef             	and    $0xffffffef,%edx
f010d040:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d046:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d049:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d04f:	83 e2 df             	and    $0xffffffdf,%edx
f010d052:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d058:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d05b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d061:	83 ca 40             	or     $0x40,%edx
f010d064:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d06a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d06d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d073:	83 e2 7f             	and    $0x7f,%edx
f010d076:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d07c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d07f:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d085:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d088:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d08e:	83 e2 ef             	and    $0xffffffef,%edx
f010d091:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d097:	e8 85 a1 ff ff       	call   f0107221 <popcli>
f010d09c:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d0a2:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d0a6:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d0a9:	90                   	nop
f010d0aa:	83 c4 14             	add    $0x14,%esp
f010d0ad:	5b                   	pop    %ebx
f010d0ae:	5d                   	pop    %ebp
f010d0af:	c3                   	ret    

f010d0b0 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d0b0:	55                   	push   %ebp
f010d0b1:	89 e5                	mov    %esp,%ebp
f010d0b3:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d0b6:	b8 5e e5 10 f0       	mov    $0xf010e55e,%eax
f010d0bb:	66 a3 e0 a3 69 f0    	mov    %ax,0xf069a3e0
f010d0c1:	66 c7 05 e2 a3 69 f0 	movw   $0x8,0xf069a3e2
f010d0c8:	08 00 
f010d0ca:	a0 e4 a3 69 f0       	mov    0xf069a3e4,%al
f010d0cf:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0d2:	a2 e4 a3 69 f0       	mov    %al,0xf069a3e4
f010d0d7:	a0 e4 a3 69 f0       	mov    0xf069a3e4,%al
f010d0dc:	83 e0 1f             	and    $0x1f,%eax
f010d0df:	a2 e4 a3 69 f0       	mov    %al,0xf069a3e4
f010d0e4:	a0 e5 a3 69 f0       	mov    0xf069a3e5,%al
f010d0e9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0ec:	83 c8 0e             	or     $0xe,%eax
f010d0ef:	a2 e5 a3 69 f0       	mov    %al,0xf069a3e5
f010d0f4:	a0 e5 a3 69 f0       	mov    0xf069a3e5,%al
f010d0f9:	83 e0 ef             	and    $0xffffffef,%eax
f010d0fc:	a2 e5 a3 69 f0       	mov    %al,0xf069a3e5
f010d101:	a0 e5 a3 69 f0       	mov    0xf069a3e5,%al
f010d106:	83 e0 9f             	and    $0xffffff9f,%eax
f010d109:	a2 e5 a3 69 f0       	mov    %al,0xf069a3e5
f010d10e:	a0 e5 a3 69 f0       	mov    0xf069a3e5,%al
f010d113:	83 c8 80             	or     $0xffffff80,%eax
f010d116:	a2 e5 a3 69 f0       	mov    %al,0xf069a3e5
f010d11b:	b8 5e e5 10 f0       	mov    $0xf010e55e,%eax
f010d120:	c1 e8 10             	shr    $0x10,%eax
f010d123:	66 a3 e6 a3 69 f0    	mov    %ax,0xf069a3e6
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d129:	b8 66 e5 10 f0       	mov    $0xf010e566,%eax
f010d12e:	66 a3 10 a4 69 f0    	mov    %ax,0xf069a410
f010d134:	66 c7 05 12 a4 69 f0 	movw   $0x8,0xf069a412
f010d13b:	08 00 
f010d13d:	a0 14 a4 69 f0       	mov    0xf069a414,%al
f010d142:	83 e0 e0             	and    $0xffffffe0,%eax
f010d145:	a2 14 a4 69 f0       	mov    %al,0xf069a414
f010d14a:	a0 14 a4 69 f0       	mov    0xf069a414,%al
f010d14f:	83 e0 1f             	and    $0x1f,%eax
f010d152:	a2 14 a4 69 f0       	mov    %al,0xf069a414
f010d157:	a0 15 a4 69 f0       	mov    0xf069a415,%al
f010d15c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d15f:	83 c8 0e             	or     $0xe,%eax
f010d162:	a2 15 a4 69 f0       	mov    %al,0xf069a415
f010d167:	a0 15 a4 69 f0       	mov    0xf069a415,%al
f010d16c:	83 e0 ef             	and    $0xffffffef,%eax
f010d16f:	a2 15 a4 69 f0       	mov    %al,0xf069a415
f010d174:	a0 15 a4 69 f0       	mov    0xf069a415,%al
f010d179:	83 e0 9f             	and    $0xffffff9f,%eax
f010d17c:	a2 15 a4 69 f0       	mov    %al,0xf069a415
f010d181:	a0 15 a4 69 f0       	mov    0xf069a415,%al
f010d186:	83 c8 80             	or     $0xffffff80,%eax
f010d189:	a2 15 a4 69 f0       	mov    %al,0xf069a415
f010d18e:	b8 66 e5 10 f0       	mov    $0xf010e566,%eax
f010d193:	c1 e8 10             	shr    $0x10,%eax
f010d196:	66 a3 16 a4 69 f0    	mov    %ax,0xf069a416
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d19c:	b8 6e e5 10 f0       	mov    $0xf010e56e,%eax
f010d1a1:	66 a3 a0 a4 69 f0    	mov    %ax,0xf069a4a0
f010d1a7:	66 c7 05 a2 a4 69 f0 	movw   $0x8,0xf069a4a2
f010d1ae:	08 00 
f010d1b0:	a0 a4 a4 69 f0       	mov    0xf069a4a4,%al
f010d1b5:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1b8:	a2 a4 a4 69 f0       	mov    %al,0xf069a4a4
f010d1bd:	a0 a4 a4 69 f0       	mov    0xf069a4a4,%al
f010d1c2:	83 e0 1f             	and    $0x1f,%eax
f010d1c5:	a2 a4 a4 69 f0       	mov    %al,0xf069a4a4
f010d1ca:	a0 a5 a4 69 f0       	mov    0xf069a4a5,%al
f010d1cf:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1d2:	83 c8 0e             	or     $0xe,%eax
f010d1d5:	a2 a5 a4 69 f0       	mov    %al,0xf069a4a5
f010d1da:	a0 a5 a4 69 f0       	mov    0xf069a4a5,%al
f010d1df:	83 e0 ef             	and    $0xffffffef,%eax
f010d1e2:	a2 a5 a4 69 f0       	mov    %al,0xf069a4a5
f010d1e7:	a0 a5 a4 69 f0       	mov    0xf069a4a5,%al
f010d1ec:	83 c8 60             	or     $0x60,%eax
f010d1ef:	a2 a5 a4 69 f0       	mov    %al,0xf069a4a5
f010d1f4:	a0 a5 a4 69 f0       	mov    0xf069a4a5,%al
f010d1f9:	83 c8 80             	or     $0xffffff80,%eax
f010d1fc:	a2 a5 a4 69 f0       	mov    %al,0xf069a4a5
f010d201:	b8 6e e5 10 f0       	mov    $0xf010e56e,%eax
f010d206:	c1 e8 10             	shr    $0x10,%eax
f010d209:	66 a3 a6 a4 69 f0    	mov    %ax,0xf069a4a6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d20f:	b8 78 e5 10 f0       	mov    $0xf010e578,%eax
f010d214:	66 a3 a8 a4 69 f0    	mov    %ax,0xf069a4a8
f010d21a:	66 c7 05 aa a4 69 f0 	movw   $0x8,0xf069a4aa
f010d221:	08 00 
f010d223:	a0 ac a4 69 f0       	mov    0xf069a4ac,%al
f010d228:	83 e0 e0             	and    $0xffffffe0,%eax
f010d22b:	a2 ac a4 69 f0       	mov    %al,0xf069a4ac
f010d230:	a0 ac a4 69 f0       	mov    0xf069a4ac,%al
f010d235:	83 e0 1f             	and    $0x1f,%eax
f010d238:	a2 ac a4 69 f0       	mov    %al,0xf069a4ac
f010d23d:	a0 ad a4 69 f0       	mov    0xf069a4ad,%al
f010d242:	83 e0 f0             	and    $0xfffffff0,%eax
f010d245:	83 c8 0e             	or     $0xe,%eax
f010d248:	a2 ad a4 69 f0       	mov    %al,0xf069a4ad
f010d24d:	a0 ad a4 69 f0       	mov    0xf069a4ad,%al
f010d252:	83 e0 ef             	and    $0xffffffef,%eax
f010d255:	a2 ad a4 69 f0       	mov    %al,0xf069a4ad
f010d25a:	a0 ad a4 69 f0       	mov    0xf069a4ad,%al
f010d25f:	83 c8 60             	or     $0x60,%eax
f010d262:	a2 ad a4 69 f0       	mov    %al,0xf069a4ad
f010d267:	a0 ad a4 69 f0       	mov    0xf069a4ad,%al
f010d26c:	83 c8 80             	or     $0xffffff80,%eax
f010d26f:	a2 ad a4 69 f0       	mov    %al,0xf069a4ad
f010d274:	b8 78 e5 10 f0       	mov    $0xf010e578,%eax
f010d279:	c1 e8 10             	shr    $0x10,%eax
f010d27c:	66 a3 ae a4 69 f0    	mov    %ax,0xf069a4ae
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d282:	b8 82 e5 10 f0       	mov    $0xf010e582,%eax
f010d287:	66 a3 20 a5 69 f0    	mov    %ax,0xf069a520
f010d28d:	66 c7 05 22 a5 69 f0 	movw   $0x8,0xf069a522
f010d294:	08 00 
f010d296:	a0 24 a5 69 f0       	mov    0xf069a524,%al
f010d29b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d29e:	a2 24 a5 69 f0       	mov    %al,0xf069a524
f010d2a3:	a0 24 a5 69 f0       	mov    0xf069a524,%al
f010d2a8:	83 e0 1f             	and    $0x1f,%eax
f010d2ab:	a2 24 a5 69 f0       	mov    %al,0xf069a524
f010d2b0:	a0 25 a5 69 f0       	mov    0xf069a525,%al
f010d2b5:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2b8:	83 c8 0e             	or     $0xe,%eax
f010d2bb:	a2 25 a5 69 f0       	mov    %al,0xf069a525
f010d2c0:	a0 25 a5 69 f0       	mov    0xf069a525,%al
f010d2c5:	83 e0 ef             	and    $0xffffffef,%eax
f010d2c8:	a2 25 a5 69 f0       	mov    %al,0xf069a525
f010d2cd:	a0 25 a5 69 f0       	mov    0xf069a525,%al
f010d2d2:	83 c8 60             	or     $0x60,%eax
f010d2d5:	a2 25 a5 69 f0       	mov    %al,0xf069a525
f010d2da:	a0 25 a5 69 f0       	mov    0xf069a525,%al
f010d2df:	83 c8 80             	or     $0xffffff80,%eax
f010d2e2:	a2 25 a5 69 f0       	mov    %al,0xf069a525
f010d2e7:	b8 82 e5 10 f0       	mov    $0xf010e582,%eax
f010d2ec:	c1 e8 10             	shr    $0x10,%eax
f010d2ef:	66 a3 26 a5 69 f0    	mov    %ax,0xf069a526

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d2f5:	b8 8c e5 10 f0       	mov    $0xf010e58c,%eax
f010d2fa:	66 a3 a0 a3 69 f0    	mov    %ax,0xf069a3a0
f010d300:	66 c7 05 a2 a3 69 f0 	movw   $0x8,0xf069a3a2
f010d307:	08 00 
f010d309:	a0 a4 a3 69 f0       	mov    0xf069a3a4,%al
f010d30e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d311:	a2 a4 a3 69 f0       	mov    %al,0xf069a3a4
f010d316:	a0 a4 a3 69 f0       	mov    0xf069a3a4,%al
f010d31b:	83 e0 1f             	and    $0x1f,%eax
f010d31e:	a2 a4 a3 69 f0       	mov    %al,0xf069a3a4
f010d323:	a0 a5 a3 69 f0       	mov    0xf069a3a5,%al
f010d328:	83 e0 f0             	and    $0xfffffff0,%eax
f010d32b:	83 c8 0e             	or     $0xe,%eax
f010d32e:	a2 a5 a3 69 f0       	mov    %al,0xf069a3a5
f010d333:	a0 a5 a3 69 f0       	mov    0xf069a3a5,%al
f010d338:	83 e0 ef             	and    $0xffffffef,%eax
f010d33b:	a2 a5 a3 69 f0       	mov    %al,0xf069a3a5
f010d340:	a0 a5 a3 69 f0       	mov    0xf069a3a5,%al
f010d345:	83 c8 60             	or     $0x60,%eax
f010d348:	a2 a5 a3 69 f0       	mov    %al,0xf069a3a5
f010d34d:	a0 a5 a3 69 f0       	mov    0xf069a3a5,%al
f010d352:	83 c8 80             	or     $0xffffff80,%eax
f010d355:	a2 a5 a3 69 f0       	mov    %al,0xf069a3a5
f010d35a:	b8 8c e5 10 f0       	mov    $0xf010e58c,%eax
f010d35f:	c1 e8 10             	shr    $0x10,%eax
f010d362:	66 a3 a6 a3 69 f0    	mov    %ax,0xf069a3a6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d368:	b8 96 e5 10 f0       	mov    $0xf010e596,%eax
f010d36d:	66 a3 a8 a3 69 f0    	mov    %ax,0xf069a3a8
f010d373:	66 c7 05 aa a3 69 f0 	movw   $0x8,0xf069a3aa
f010d37a:	08 00 
f010d37c:	a0 ac a3 69 f0       	mov    0xf069a3ac,%al
f010d381:	83 e0 e0             	and    $0xffffffe0,%eax
f010d384:	a2 ac a3 69 f0       	mov    %al,0xf069a3ac
f010d389:	a0 ac a3 69 f0       	mov    0xf069a3ac,%al
f010d38e:	83 e0 1f             	and    $0x1f,%eax
f010d391:	a2 ac a3 69 f0       	mov    %al,0xf069a3ac
f010d396:	a0 ad a3 69 f0       	mov    0xf069a3ad,%al
f010d39b:	83 c8 0f             	or     $0xf,%eax
f010d39e:	a2 ad a3 69 f0       	mov    %al,0xf069a3ad
f010d3a3:	a0 ad a3 69 f0       	mov    0xf069a3ad,%al
f010d3a8:	83 e0 ef             	and    $0xffffffef,%eax
f010d3ab:	a2 ad a3 69 f0       	mov    %al,0xf069a3ad
f010d3b0:	a0 ad a3 69 f0       	mov    0xf069a3ad,%al
f010d3b5:	83 c8 60             	or     $0x60,%eax
f010d3b8:	a2 ad a3 69 f0       	mov    %al,0xf069a3ad
f010d3bd:	a0 ad a3 69 f0       	mov    0xf069a3ad,%al
f010d3c2:	83 c8 80             	or     $0xffffff80,%eax
f010d3c5:	a2 ad a3 69 f0       	mov    %al,0xf069a3ad
f010d3ca:	b8 96 e5 10 f0       	mov    $0xf010e596,%eax
f010d3cf:	c1 e8 10             	shr    $0x10,%eax
f010d3d2:	66 a3 ae a3 69 f0    	mov    %ax,0xf069a3ae
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d3d8:	b8 a0 e5 10 f0       	mov    $0xf010e5a0,%eax
f010d3dd:	66 a3 b0 a3 69 f0    	mov    %ax,0xf069a3b0
f010d3e3:	66 c7 05 b2 a3 69 f0 	movw   $0x8,0xf069a3b2
f010d3ea:	08 00 
f010d3ec:	a0 b4 a3 69 f0       	mov    0xf069a3b4,%al
f010d3f1:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3f4:	a2 b4 a3 69 f0       	mov    %al,0xf069a3b4
f010d3f9:	a0 b4 a3 69 f0       	mov    0xf069a3b4,%al
f010d3fe:	83 e0 1f             	and    $0x1f,%eax
f010d401:	a2 b4 a3 69 f0       	mov    %al,0xf069a3b4
f010d406:	a0 b5 a3 69 f0       	mov    0xf069a3b5,%al
f010d40b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d40e:	83 c8 0e             	or     $0xe,%eax
f010d411:	a2 b5 a3 69 f0       	mov    %al,0xf069a3b5
f010d416:	a0 b5 a3 69 f0       	mov    0xf069a3b5,%al
f010d41b:	83 e0 ef             	and    $0xffffffef,%eax
f010d41e:	a2 b5 a3 69 f0       	mov    %al,0xf069a3b5
f010d423:	a0 b5 a3 69 f0       	mov    0xf069a3b5,%al
f010d428:	83 c8 60             	or     $0x60,%eax
f010d42b:	a2 b5 a3 69 f0       	mov    %al,0xf069a3b5
f010d430:	a0 b5 a3 69 f0       	mov    0xf069a3b5,%al
f010d435:	83 c8 80             	or     $0xffffff80,%eax
f010d438:	a2 b5 a3 69 f0       	mov    %al,0xf069a3b5
f010d43d:	b8 a0 e5 10 f0       	mov    $0xf010e5a0,%eax
f010d442:	c1 e8 10             	shr    $0x10,%eax
f010d445:	66 a3 b6 a3 69 f0    	mov    %ax,0xf069a3b6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d44b:	b8 aa e5 10 f0       	mov    $0xf010e5aa,%eax
f010d450:	66 a3 b8 a3 69 f0    	mov    %ax,0xf069a3b8
f010d456:	66 c7 05 ba a3 69 f0 	movw   $0x8,0xf069a3ba
f010d45d:	08 00 
f010d45f:	a0 bc a3 69 f0       	mov    0xf069a3bc,%al
f010d464:	83 e0 e0             	and    $0xffffffe0,%eax
f010d467:	a2 bc a3 69 f0       	mov    %al,0xf069a3bc
f010d46c:	a0 bc a3 69 f0       	mov    0xf069a3bc,%al
f010d471:	83 e0 1f             	and    $0x1f,%eax
f010d474:	a2 bc a3 69 f0       	mov    %al,0xf069a3bc
f010d479:	a0 bd a3 69 f0       	mov    0xf069a3bd,%al
f010d47e:	83 c8 0f             	or     $0xf,%eax
f010d481:	a2 bd a3 69 f0       	mov    %al,0xf069a3bd
f010d486:	a0 bd a3 69 f0       	mov    0xf069a3bd,%al
f010d48b:	83 e0 ef             	and    $0xffffffef,%eax
f010d48e:	a2 bd a3 69 f0       	mov    %al,0xf069a3bd
f010d493:	a0 bd a3 69 f0       	mov    0xf069a3bd,%al
f010d498:	83 c8 60             	or     $0x60,%eax
f010d49b:	a2 bd a3 69 f0       	mov    %al,0xf069a3bd
f010d4a0:	a0 bd a3 69 f0       	mov    0xf069a3bd,%al
f010d4a5:	83 c8 80             	or     $0xffffff80,%eax
f010d4a8:	a2 bd a3 69 f0       	mov    %al,0xf069a3bd
f010d4ad:	b8 aa e5 10 f0       	mov    $0xf010e5aa,%eax
f010d4b2:	c1 e8 10             	shr    $0x10,%eax
f010d4b5:	66 a3 be a3 69 f0    	mov    %ax,0xf069a3be
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d4bb:	b8 b4 e5 10 f0       	mov    $0xf010e5b4,%eax
f010d4c0:	66 a3 c0 a3 69 f0    	mov    %ax,0xf069a3c0
f010d4c6:	66 c7 05 c2 a3 69 f0 	movw   $0x8,0xf069a3c2
f010d4cd:	08 00 
f010d4cf:	a0 c4 a3 69 f0       	mov    0xf069a3c4,%al
f010d4d4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4d7:	a2 c4 a3 69 f0       	mov    %al,0xf069a3c4
f010d4dc:	a0 c4 a3 69 f0       	mov    0xf069a3c4,%al
f010d4e1:	83 e0 1f             	and    $0x1f,%eax
f010d4e4:	a2 c4 a3 69 f0       	mov    %al,0xf069a3c4
f010d4e9:	a0 c5 a3 69 f0       	mov    0xf069a3c5,%al
f010d4ee:	83 c8 0f             	or     $0xf,%eax
f010d4f1:	a2 c5 a3 69 f0       	mov    %al,0xf069a3c5
f010d4f6:	a0 c5 a3 69 f0       	mov    0xf069a3c5,%al
f010d4fb:	83 e0 ef             	and    $0xffffffef,%eax
f010d4fe:	a2 c5 a3 69 f0       	mov    %al,0xf069a3c5
f010d503:	a0 c5 a3 69 f0       	mov    0xf069a3c5,%al
f010d508:	83 c8 60             	or     $0x60,%eax
f010d50b:	a2 c5 a3 69 f0       	mov    %al,0xf069a3c5
f010d510:	a0 c5 a3 69 f0       	mov    0xf069a3c5,%al
f010d515:	83 c8 80             	or     $0xffffff80,%eax
f010d518:	a2 c5 a3 69 f0       	mov    %al,0xf069a3c5
f010d51d:	b8 b4 e5 10 f0       	mov    $0xf010e5b4,%eax
f010d522:	c1 e8 10             	shr    $0x10,%eax
f010d525:	66 a3 c6 a3 69 f0    	mov    %ax,0xf069a3c6
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d52b:	b8 be e5 10 f0       	mov    $0xf010e5be,%eax
f010d530:	66 a3 c8 a3 69 f0    	mov    %ax,0xf069a3c8
f010d536:	66 c7 05 ca a3 69 f0 	movw   $0x8,0xf069a3ca
f010d53d:	08 00 
f010d53f:	a0 cc a3 69 f0       	mov    0xf069a3cc,%al
f010d544:	83 e0 e0             	and    $0xffffffe0,%eax
f010d547:	a2 cc a3 69 f0       	mov    %al,0xf069a3cc
f010d54c:	a0 cc a3 69 f0       	mov    0xf069a3cc,%al
f010d551:	83 e0 1f             	and    $0x1f,%eax
f010d554:	a2 cc a3 69 f0       	mov    %al,0xf069a3cc
f010d559:	a0 cd a3 69 f0       	mov    0xf069a3cd,%al
f010d55e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d561:	83 c8 0e             	or     $0xe,%eax
f010d564:	a2 cd a3 69 f0       	mov    %al,0xf069a3cd
f010d569:	a0 cd a3 69 f0       	mov    0xf069a3cd,%al
f010d56e:	83 e0 ef             	and    $0xffffffef,%eax
f010d571:	a2 cd a3 69 f0       	mov    %al,0xf069a3cd
f010d576:	a0 cd a3 69 f0       	mov    0xf069a3cd,%al
f010d57b:	83 c8 60             	or     $0x60,%eax
f010d57e:	a2 cd a3 69 f0       	mov    %al,0xf069a3cd
f010d583:	a0 cd a3 69 f0       	mov    0xf069a3cd,%al
f010d588:	83 c8 80             	or     $0xffffff80,%eax
f010d58b:	a2 cd a3 69 f0       	mov    %al,0xf069a3cd
f010d590:	b8 be e5 10 f0       	mov    $0xf010e5be,%eax
f010d595:	c1 e8 10             	shr    $0x10,%eax
f010d598:	66 a3 ce a3 69 f0    	mov    %ax,0xf069a3ce
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d59e:	b8 c8 e5 10 f0       	mov    $0xf010e5c8,%eax
f010d5a3:	66 a3 d0 a3 69 f0    	mov    %ax,0xf069a3d0
f010d5a9:	66 c7 05 d2 a3 69 f0 	movw   $0x8,0xf069a3d2
f010d5b0:	08 00 
f010d5b2:	a0 d4 a3 69 f0       	mov    0xf069a3d4,%al
f010d5b7:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5ba:	a2 d4 a3 69 f0       	mov    %al,0xf069a3d4
f010d5bf:	a0 d4 a3 69 f0       	mov    0xf069a3d4,%al
f010d5c4:	83 e0 1f             	and    $0x1f,%eax
f010d5c7:	a2 d4 a3 69 f0       	mov    %al,0xf069a3d4
f010d5cc:	a0 d5 a3 69 f0       	mov    0xf069a3d5,%al
f010d5d1:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5d4:	83 c8 0e             	or     $0xe,%eax
f010d5d7:	a2 d5 a3 69 f0       	mov    %al,0xf069a3d5
f010d5dc:	a0 d5 a3 69 f0       	mov    0xf069a3d5,%al
f010d5e1:	83 e0 ef             	and    $0xffffffef,%eax
f010d5e4:	a2 d5 a3 69 f0       	mov    %al,0xf069a3d5
f010d5e9:	a0 d5 a3 69 f0       	mov    0xf069a3d5,%al
f010d5ee:	83 c8 60             	or     $0x60,%eax
f010d5f1:	a2 d5 a3 69 f0       	mov    %al,0xf069a3d5
f010d5f6:	a0 d5 a3 69 f0       	mov    0xf069a3d5,%al
f010d5fb:	83 c8 80             	or     $0xffffff80,%eax
f010d5fe:	a2 d5 a3 69 f0       	mov    %al,0xf069a3d5
f010d603:	b8 c8 e5 10 f0       	mov    $0xf010e5c8,%eax
f010d608:	c1 e8 10             	shr    $0x10,%eax
f010d60b:	66 a3 d6 a3 69 f0    	mov    %ax,0xf069a3d6
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d611:	b8 d2 e5 10 f0       	mov    $0xf010e5d2,%eax
f010d616:	66 a3 d8 a3 69 f0    	mov    %ax,0xf069a3d8
f010d61c:	66 c7 05 da a3 69 f0 	movw   $0x8,0xf069a3da
f010d623:	08 00 
f010d625:	a0 dc a3 69 f0       	mov    0xf069a3dc,%al
f010d62a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d62d:	a2 dc a3 69 f0       	mov    %al,0xf069a3dc
f010d632:	a0 dc a3 69 f0       	mov    0xf069a3dc,%al
f010d637:	83 e0 1f             	and    $0x1f,%eax
f010d63a:	a2 dc a3 69 f0       	mov    %al,0xf069a3dc
f010d63f:	a0 dd a3 69 f0       	mov    0xf069a3dd,%al
f010d644:	83 e0 f0             	and    $0xfffffff0,%eax
f010d647:	83 c8 0e             	or     $0xe,%eax
f010d64a:	a2 dd a3 69 f0       	mov    %al,0xf069a3dd
f010d64f:	a0 dd a3 69 f0       	mov    0xf069a3dd,%al
f010d654:	83 e0 ef             	and    $0xffffffef,%eax
f010d657:	a2 dd a3 69 f0       	mov    %al,0xf069a3dd
f010d65c:	a0 dd a3 69 f0       	mov    0xf069a3dd,%al
f010d661:	83 c8 60             	or     $0x60,%eax
f010d664:	a2 dd a3 69 f0       	mov    %al,0xf069a3dd
f010d669:	a0 dd a3 69 f0       	mov    0xf069a3dd,%al
f010d66e:	83 c8 80             	or     $0xffffff80,%eax
f010d671:	a2 dd a3 69 f0       	mov    %al,0xf069a3dd
f010d676:	b8 d2 e5 10 f0       	mov    $0xf010e5d2,%eax
f010d67b:	c1 e8 10             	shr    $0x10,%eax
f010d67e:	66 a3 de a3 69 f0    	mov    %ax,0xf069a3de
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d684:	b8 d8 e5 10 f0       	mov    $0xf010e5d8,%eax
f010d689:	66 a3 f0 a3 69 f0    	mov    %ax,0xf069a3f0
f010d68f:	66 c7 05 f2 a3 69 f0 	movw   $0x8,0xf069a3f2
f010d696:	08 00 
f010d698:	a0 f4 a3 69 f0       	mov    0xf069a3f4,%al
f010d69d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6a0:	a2 f4 a3 69 f0       	mov    %al,0xf069a3f4
f010d6a5:	a0 f4 a3 69 f0       	mov    0xf069a3f4,%al
f010d6aa:	83 e0 1f             	and    $0x1f,%eax
f010d6ad:	a2 f4 a3 69 f0       	mov    %al,0xf069a3f4
f010d6b2:	a0 f5 a3 69 f0       	mov    0xf069a3f5,%al
f010d6b7:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6ba:	83 c8 0e             	or     $0xe,%eax
f010d6bd:	a2 f5 a3 69 f0       	mov    %al,0xf069a3f5
f010d6c2:	a0 f5 a3 69 f0       	mov    0xf069a3f5,%al
f010d6c7:	83 e0 ef             	and    $0xffffffef,%eax
f010d6ca:	a2 f5 a3 69 f0       	mov    %al,0xf069a3f5
f010d6cf:	a0 f5 a3 69 f0       	mov    0xf069a3f5,%al
f010d6d4:	83 c8 60             	or     $0x60,%eax
f010d6d7:	a2 f5 a3 69 f0       	mov    %al,0xf069a3f5
f010d6dc:	a0 f5 a3 69 f0       	mov    0xf069a3f5,%al
f010d6e1:	83 c8 80             	or     $0xffffff80,%eax
f010d6e4:	a2 f5 a3 69 f0       	mov    %al,0xf069a3f5
f010d6e9:	b8 d8 e5 10 f0       	mov    $0xf010e5d8,%eax
f010d6ee:	c1 e8 10             	shr    $0x10,%eax
f010d6f1:	66 a3 f6 a3 69 f0    	mov    %ax,0xf069a3f6
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d6f7:	b8 dc e5 10 f0       	mov    $0xf010e5dc,%eax
f010d6fc:	66 a3 f8 a3 69 f0    	mov    %ax,0xf069a3f8
f010d702:	66 c7 05 fa a3 69 f0 	movw   $0x8,0xf069a3fa
f010d709:	08 00 
f010d70b:	a0 fc a3 69 f0       	mov    0xf069a3fc,%al
f010d710:	83 e0 e0             	and    $0xffffffe0,%eax
f010d713:	a2 fc a3 69 f0       	mov    %al,0xf069a3fc
f010d718:	a0 fc a3 69 f0       	mov    0xf069a3fc,%al
f010d71d:	83 e0 1f             	and    $0x1f,%eax
f010d720:	a2 fc a3 69 f0       	mov    %al,0xf069a3fc
f010d725:	a0 fd a3 69 f0       	mov    0xf069a3fd,%al
f010d72a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d72d:	83 c8 0e             	or     $0xe,%eax
f010d730:	a2 fd a3 69 f0       	mov    %al,0xf069a3fd
f010d735:	a0 fd a3 69 f0       	mov    0xf069a3fd,%al
f010d73a:	83 e0 ef             	and    $0xffffffef,%eax
f010d73d:	a2 fd a3 69 f0       	mov    %al,0xf069a3fd
f010d742:	a0 fd a3 69 f0       	mov    0xf069a3fd,%al
f010d747:	83 c8 60             	or     $0x60,%eax
f010d74a:	a2 fd a3 69 f0       	mov    %al,0xf069a3fd
f010d74f:	a0 fd a3 69 f0       	mov    0xf069a3fd,%al
f010d754:	83 c8 80             	or     $0xffffff80,%eax
f010d757:	a2 fd a3 69 f0       	mov    %al,0xf069a3fd
f010d75c:	b8 dc e5 10 f0       	mov    $0xf010e5dc,%eax
f010d761:	c1 e8 10             	shr    $0x10,%eax
f010d764:	66 a3 fe a3 69 f0    	mov    %ax,0xf069a3fe
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d76a:	b8 e0 e5 10 f0       	mov    $0xf010e5e0,%eax
f010d76f:	66 a3 00 a4 69 f0    	mov    %ax,0xf069a400
f010d775:	66 c7 05 02 a4 69 f0 	movw   $0x8,0xf069a402
f010d77c:	08 00 
f010d77e:	a0 04 a4 69 f0       	mov    0xf069a404,%al
f010d783:	83 e0 e0             	and    $0xffffffe0,%eax
f010d786:	a2 04 a4 69 f0       	mov    %al,0xf069a404
f010d78b:	a0 04 a4 69 f0       	mov    0xf069a404,%al
f010d790:	83 e0 1f             	and    $0x1f,%eax
f010d793:	a2 04 a4 69 f0       	mov    %al,0xf069a404
f010d798:	a0 05 a4 69 f0       	mov    0xf069a405,%al
f010d79d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7a0:	83 c8 0e             	or     $0xe,%eax
f010d7a3:	a2 05 a4 69 f0       	mov    %al,0xf069a405
f010d7a8:	a0 05 a4 69 f0       	mov    0xf069a405,%al
f010d7ad:	83 e0 ef             	and    $0xffffffef,%eax
f010d7b0:	a2 05 a4 69 f0       	mov    %al,0xf069a405
f010d7b5:	a0 05 a4 69 f0       	mov    0xf069a405,%al
f010d7ba:	83 c8 60             	or     $0x60,%eax
f010d7bd:	a2 05 a4 69 f0       	mov    %al,0xf069a405
f010d7c2:	a0 05 a4 69 f0       	mov    0xf069a405,%al
f010d7c7:	83 c8 80             	or     $0xffffff80,%eax
f010d7ca:	a2 05 a4 69 f0       	mov    %al,0xf069a405
f010d7cf:	b8 e0 e5 10 f0       	mov    $0xf010e5e0,%eax
f010d7d4:	c1 e8 10             	shr    $0x10,%eax
f010d7d7:	66 a3 06 a4 69 f0    	mov    %ax,0xf069a406
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d7dd:	b8 e4 e5 10 f0       	mov    $0xf010e5e4,%eax
f010d7e2:	66 a3 08 a4 69 f0    	mov    %ax,0xf069a408
f010d7e8:	66 c7 05 0a a4 69 f0 	movw   $0x8,0xf069a40a
f010d7ef:	08 00 
f010d7f1:	a0 0c a4 69 f0       	mov    0xf069a40c,%al
f010d7f6:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7f9:	a2 0c a4 69 f0       	mov    %al,0xf069a40c
f010d7fe:	a0 0c a4 69 f0       	mov    0xf069a40c,%al
f010d803:	83 e0 1f             	and    $0x1f,%eax
f010d806:	a2 0c a4 69 f0       	mov    %al,0xf069a40c
f010d80b:	a0 0d a4 69 f0       	mov    0xf069a40d,%al
f010d810:	83 e0 f0             	and    $0xfffffff0,%eax
f010d813:	83 c8 0e             	or     $0xe,%eax
f010d816:	a2 0d a4 69 f0       	mov    %al,0xf069a40d
f010d81b:	a0 0d a4 69 f0       	mov    0xf069a40d,%al
f010d820:	83 e0 ef             	and    $0xffffffef,%eax
f010d823:	a2 0d a4 69 f0       	mov    %al,0xf069a40d
f010d828:	a0 0d a4 69 f0       	mov    0xf069a40d,%al
f010d82d:	83 c8 60             	or     $0x60,%eax
f010d830:	a2 0d a4 69 f0       	mov    %al,0xf069a40d
f010d835:	a0 0d a4 69 f0       	mov    0xf069a40d,%al
f010d83a:	83 c8 80             	or     $0xffffff80,%eax
f010d83d:	a2 0d a4 69 f0       	mov    %al,0xf069a40d
f010d842:	b8 e4 e5 10 f0       	mov    $0xf010e5e4,%eax
f010d847:	c1 e8 10             	shr    $0x10,%eax
f010d84a:	66 a3 0e a4 69 f0    	mov    %ax,0xf069a40e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d850:	b8 e8 e5 10 f0       	mov    $0xf010e5e8,%eax
f010d855:	66 a3 20 a4 69 f0    	mov    %ax,0xf069a420
f010d85b:	66 c7 05 22 a4 69 f0 	movw   $0x8,0xf069a422
f010d862:	08 00 
f010d864:	a0 24 a4 69 f0       	mov    0xf069a424,%al
f010d869:	83 e0 e0             	and    $0xffffffe0,%eax
f010d86c:	a2 24 a4 69 f0       	mov    %al,0xf069a424
f010d871:	a0 24 a4 69 f0       	mov    0xf069a424,%al
f010d876:	83 e0 1f             	and    $0x1f,%eax
f010d879:	a2 24 a4 69 f0       	mov    %al,0xf069a424
f010d87e:	a0 25 a4 69 f0       	mov    0xf069a425,%al
f010d883:	83 e0 f0             	and    $0xfffffff0,%eax
f010d886:	83 c8 0e             	or     $0xe,%eax
f010d889:	a2 25 a4 69 f0       	mov    %al,0xf069a425
f010d88e:	a0 25 a4 69 f0       	mov    0xf069a425,%al
f010d893:	83 e0 ef             	and    $0xffffffef,%eax
f010d896:	a2 25 a4 69 f0       	mov    %al,0xf069a425
f010d89b:	a0 25 a4 69 f0       	mov    0xf069a425,%al
f010d8a0:	83 c8 60             	or     $0x60,%eax
f010d8a3:	a2 25 a4 69 f0       	mov    %al,0xf069a425
f010d8a8:	a0 25 a4 69 f0       	mov    0xf069a425,%al
f010d8ad:	83 c8 80             	or     $0xffffff80,%eax
f010d8b0:	a2 25 a4 69 f0       	mov    %al,0xf069a425
f010d8b5:	b8 e8 e5 10 f0       	mov    $0xf010e5e8,%eax
f010d8ba:	c1 e8 10             	shr    $0x10,%eax
f010d8bd:	66 a3 26 a4 69 f0    	mov    %ax,0xf069a426
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d8c3:	b8 ee e5 10 f0       	mov    $0xf010e5ee,%eax
f010d8c8:	66 a3 28 a4 69 f0    	mov    %ax,0xf069a428
f010d8ce:	66 c7 05 2a a4 69 f0 	movw   $0x8,0xf069a42a
f010d8d5:	08 00 
f010d8d7:	a0 2c a4 69 f0       	mov    0xf069a42c,%al
f010d8dc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8df:	a2 2c a4 69 f0       	mov    %al,0xf069a42c
f010d8e4:	a0 2c a4 69 f0       	mov    0xf069a42c,%al
f010d8e9:	83 e0 1f             	and    $0x1f,%eax
f010d8ec:	a2 2c a4 69 f0       	mov    %al,0xf069a42c
f010d8f1:	a0 2d a4 69 f0       	mov    0xf069a42d,%al
f010d8f6:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8f9:	83 c8 0e             	or     $0xe,%eax
f010d8fc:	a2 2d a4 69 f0       	mov    %al,0xf069a42d
f010d901:	a0 2d a4 69 f0       	mov    0xf069a42d,%al
f010d906:	83 e0 ef             	and    $0xffffffef,%eax
f010d909:	a2 2d a4 69 f0       	mov    %al,0xf069a42d
f010d90e:	a0 2d a4 69 f0       	mov    0xf069a42d,%al
f010d913:	83 c8 60             	or     $0x60,%eax
f010d916:	a2 2d a4 69 f0       	mov    %al,0xf069a42d
f010d91b:	a0 2d a4 69 f0       	mov    0xf069a42d,%al
f010d920:	83 c8 80             	or     $0xffffff80,%eax
f010d923:	a2 2d a4 69 f0       	mov    %al,0xf069a42d
f010d928:	b8 ee e5 10 f0       	mov    $0xf010e5ee,%eax
f010d92d:	c1 e8 10             	shr    $0x10,%eax
f010d930:	66 a3 2e a4 69 f0    	mov    %ax,0xf069a42e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d936:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010d93b:	66 a3 30 a4 69 f0    	mov    %ax,0xf069a430
f010d941:	66 c7 05 32 a4 69 f0 	movw   $0x8,0xf069a432
f010d948:	08 00 
f010d94a:	a0 34 a4 69 f0       	mov    0xf069a434,%al
f010d94f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d952:	a2 34 a4 69 f0       	mov    %al,0xf069a434
f010d957:	a0 34 a4 69 f0       	mov    0xf069a434,%al
f010d95c:	83 e0 1f             	and    $0x1f,%eax
f010d95f:	a2 34 a4 69 f0       	mov    %al,0xf069a434
f010d964:	a0 35 a4 69 f0       	mov    0xf069a435,%al
f010d969:	83 e0 f0             	and    $0xfffffff0,%eax
f010d96c:	83 c8 0e             	or     $0xe,%eax
f010d96f:	a2 35 a4 69 f0       	mov    %al,0xf069a435
f010d974:	a0 35 a4 69 f0       	mov    0xf069a435,%al
f010d979:	83 e0 ef             	and    $0xffffffef,%eax
f010d97c:	a2 35 a4 69 f0       	mov    %al,0xf069a435
f010d981:	a0 35 a4 69 f0       	mov    0xf069a435,%al
f010d986:	83 c8 60             	or     $0x60,%eax
f010d989:	a2 35 a4 69 f0       	mov    %al,0xf069a435
f010d98e:	a0 35 a4 69 f0       	mov    0xf069a435,%al
f010d993:	83 c8 80             	or     $0xffffff80,%eax
f010d996:	a2 35 a4 69 f0       	mov    %al,0xf069a435
f010d99b:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010d9a0:	c1 e8 10             	shr    $0x10,%eax
f010d9a3:	66 a3 36 a4 69 f0    	mov    %ax,0xf069a436
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d9a9:	b8 f8 e5 10 f0       	mov    $0xf010e5f8,%eax
f010d9ae:	66 a3 38 a4 69 f0    	mov    %ax,0xf069a438
f010d9b4:	66 c7 05 3a a4 69 f0 	movw   $0x8,0xf069a43a
f010d9bb:	08 00 
f010d9bd:	a0 3c a4 69 f0       	mov    0xf069a43c,%al
f010d9c2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9c5:	a2 3c a4 69 f0       	mov    %al,0xf069a43c
f010d9ca:	a0 3c a4 69 f0       	mov    0xf069a43c,%al
f010d9cf:	83 e0 1f             	and    $0x1f,%eax
f010d9d2:	a2 3c a4 69 f0       	mov    %al,0xf069a43c
f010d9d7:	a0 3d a4 69 f0       	mov    0xf069a43d,%al
f010d9dc:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9df:	83 c8 0e             	or     $0xe,%eax
f010d9e2:	a2 3d a4 69 f0       	mov    %al,0xf069a43d
f010d9e7:	a0 3d a4 69 f0       	mov    0xf069a43d,%al
f010d9ec:	83 e0 ef             	and    $0xffffffef,%eax
f010d9ef:	a2 3d a4 69 f0       	mov    %al,0xf069a43d
f010d9f4:	a0 3d a4 69 f0       	mov    0xf069a43d,%al
f010d9f9:	83 c8 60             	or     $0x60,%eax
f010d9fc:	a2 3d a4 69 f0       	mov    %al,0xf069a43d
f010da01:	a0 3d a4 69 f0       	mov    0xf069a43d,%al
f010da06:	83 c8 80             	or     $0xffffff80,%eax
f010da09:	a2 3d a4 69 f0       	mov    %al,0xf069a43d
f010da0e:	b8 f8 e5 10 f0       	mov    $0xf010e5f8,%eax
f010da13:	c1 e8 10             	shr    $0x10,%eax
f010da16:	66 a3 3e a4 69 f0    	mov    %ax,0xf069a43e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010da1c:	b8 fe e5 10 f0       	mov    $0xf010e5fe,%eax
f010da21:	66 a3 b0 a4 69 f0    	mov    %ax,0xf069a4b0
f010da27:	66 c7 05 b2 a4 69 f0 	movw   $0x8,0xf069a4b2
f010da2e:	08 00 
f010da30:	a0 b4 a4 69 f0       	mov    0xf069a4b4,%al
f010da35:	83 e0 e0             	and    $0xffffffe0,%eax
f010da38:	a2 b4 a4 69 f0       	mov    %al,0xf069a4b4
f010da3d:	a0 b4 a4 69 f0       	mov    0xf069a4b4,%al
f010da42:	83 e0 1f             	and    $0x1f,%eax
f010da45:	a2 b4 a4 69 f0       	mov    %al,0xf069a4b4
f010da4a:	a0 b5 a4 69 f0       	mov    0xf069a4b5,%al
f010da4f:	83 e0 f0             	and    $0xfffffff0,%eax
f010da52:	83 c8 0e             	or     $0xe,%eax
f010da55:	a2 b5 a4 69 f0       	mov    %al,0xf069a4b5
f010da5a:	a0 b5 a4 69 f0       	mov    0xf069a4b5,%al
f010da5f:	83 e0 ef             	and    $0xffffffef,%eax
f010da62:	a2 b5 a4 69 f0       	mov    %al,0xf069a4b5
f010da67:	a0 b5 a4 69 f0       	mov    0xf069a4b5,%al
f010da6c:	83 c8 60             	or     $0x60,%eax
f010da6f:	a2 b5 a4 69 f0       	mov    %al,0xf069a4b5
f010da74:	a0 b5 a4 69 f0       	mov    0xf069a4b5,%al
f010da79:	83 c8 80             	or     $0xffffff80,%eax
f010da7c:	a2 b5 a4 69 f0       	mov    %al,0xf069a4b5
f010da81:	b8 fe e5 10 f0       	mov    $0xf010e5fe,%eax
f010da86:	c1 e8 10             	shr    $0x10,%eax
f010da89:	66 a3 b6 a4 69 f0    	mov    %ax,0xf069a4b6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010da8f:	b8 04 e6 10 f0       	mov    $0xf010e604,%eax
f010da94:	66 a3 b8 a4 69 f0    	mov    %ax,0xf069a4b8
f010da9a:	66 c7 05 ba a4 69 f0 	movw   $0x8,0xf069a4ba
f010daa1:	08 00 
f010daa3:	a0 bc a4 69 f0       	mov    0xf069a4bc,%al
f010daa8:	83 e0 e0             	and    $0xffffffe0,%eax
f010daab:	a2 bc a4 69 f0       	mov    %al,0xf069a4bc
f010dab0:	a0 bc a4 69 f0       	mov    0xf069a4bc,%al
f010dab5:	83 e0 1f             	and    $0x1f,%eax
f010dab8:	a2 bc a4 69 f0       	mov    %al,0xf069a4bc
f010dabd:	a0 bd a4 69 f0       	mov    0xf069a4bd,%al
f010dac2:	83 e0 f0             	and    $0xfffffff0,%eax
f010dac5:	83 c8 0e             	or     $0xe,%eax
f010dac8:	a2 bd a4 69 f0       	mov    %al,0xf069a4bd
f010dacd:	a0 bd a4 69 f0       	mov    0xf069a4bd,%al
f010dad2:	83 e0 ef             	and    $0xffffffef,%eax
f010dad5:	a2 bd a4 69 f0       	mov    %al,0xf069a4bd
f010dada:	a0 bd a4 69 f0       	mov    0xf069a4bd,%al
f010dadf:	83 c8 60             	or     $0x60,%eax
f010dae2:	a2 bd a4 69 f0       	mov    %al,0xf069a4bd
f010dae7:	a0 bd a4 69 f0       	mov    0xf069a4bd,%al
f010daec:	83 c8 80             	or     $0xffffff80,%eax
f010daef:	a2 bd a4 69 f0       	mov    %al,0xf069a4bd
f010daf4:	b8 04 e6 10 f0       	mov    $0xf010e604,%eax
f010daf9:	c1 e8 10             	shr    $0x10,%eax
f010dafc:	66 a3 be a4 69 f0    	mov    %ax,0xf069a4be
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010db02:	b8 0a e6 10 f0       	mov    $0xf010e60a,%eax
f010db07:	66 a3 c0 a4 69 f0    	mov    %ax,0xf069a4c0
f010db0d:	66 c7 05 c2 a4 69 f0 	movw   $0x8,0xf069a4c2
f010db14:	08 00 
f010db16:	a0 c4 a4 69 f0       	mov    0xf069a4c4,%al
f010db1b:	83 e0 e0             	and    $0xffffffe0,%eax
f010db1e:	a2 c4 a4 69 f0       	mov    %al,0xf069a4c4
f010db23:	a0 c4 a4 69 f0       	mov    0xf069a4c4,%al
f010db28:	83 e0 1f             	and    $0x1f,%eax
f010db2b:	a2 c4 a4 69 f0       	mov    %al,0xf069a4c4
f010db30:	a0 c5 a4 69 f0       	mov    0xf069a4c5,%al
f010db35:	83 e0 f0             	and    $0xfffffff0,%eax
f010db38:	83 c8 0e             	or     $0xe,%eax
f010db3b:	a2 c5 a4 69 f0       	mov    %al,0xf069a4c5
f010db40:	a0 c5 a4 69 f0       	mov    0xf069a4c5,%al
f010db45:	83 e0 ef             	and    $0xffffffef,%eax
f010db48:	a2 c5 a4 69 f0       	mov    %al,0xf069a4c5
f010db4d:	a0 c5 a4 69 f0       	mov    0xf069a4c5,%al
f010db52:	83 c8 60             	or     $0x60,%eax
f010db55:	a2 c5 a4 69 f0       	mov    %al,0xf069a4c5
f010db5a:	a0 c5 a4 69 f0       	mov    0xf069a4c5,%al
f010db5f:	83 c8 80             	or     $0xffffff80,%eax
f010db62:	a2 c5 a4 69 f0       	mov    %al,0xf069a4c5
f010db67:	b8 0a e6 10 f0       	mov    $0xf010e60a,%eax
f010db6c:	c1 e8 10             	shr    $0x10,%eax
f010db6f:	66 a3 c6 a4 69 f0    	mov    %ax,0xf069a4c6
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010db75:	b8 10 e6 10 f0       	mov    $0xf010e610,%eax
f010db7a:	66 a3 c8 a4 69 f0    	mov    %ax,0xf069a4c8
f010db80:	66 c7 05 ca a4 69 f0 	movw   $0x8,0xf069a4ca
f010db87:	08 00 
f010db89:	a0 cc a4 69 f0       	mov    0xf069a4cc,%al
f010db8e:	83 e0 e0             	and    $0xffffffe0,%eax
f010db91:	a2 cc a4 69 f0       	mov    %al,0xf069a4cc
f010db96:	a0 cc a4 69 f0       	mov    0xf069a4cc,%al
f010db9b:	83 e0 1f             	and    $0x1f,%eax
f010db9e:	a2 cc a4 69 f0       	mov    %al,0xf069a4cc
f010dba3:	a0 cd a4 69 f0       	mov    0xf069a4cd,%al
f010dba8:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbab:	83 c8 0e             	or     $0xe,%eax
f010dbae:	a2 cd a4 69 f0       	mov    %al,0xf069a4cd
f010dbb3:	a0 cd a4 69 f0       	mov    0xf069a4cd,%al
f010dbb8:	83 e0 ef             	and    $0xffffffef,%eax
f010dbbb:	a2 cd a4 69 f0       	mov    %al,0xf069a4cd
f010dbc0:	a0 cd a4 69 f0       	mov    0xf069a4cd,%al
f010dbc5:	83 c8 60             	or     $0x60,%eax
f010dbc8:	a2 cd a4 69 f0       	mov    %al,0xf069a4cd
f010dbcd:	a0 cd a4 69 f0       	mov    0xf069a4cd,%al
f010dbd2:	83 c8 80             	or     $0xffffff80,%eax
f010dbd5:	a2 cd a4 69 f0       	mov    %al,0xf069a4cd
f010dbda:	b8 10 e6 10 f0       	mov    $0xf010e610,%eax
f010dbdf:	c1 e8 10             	shr    $0x10,%eax
f010dbe2:	66 a3 ce a4 69 f0    	mov    %ax,0xf069a4ce
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010dbe8:	b8 16 e6 10 f0       	mov    $0xf010e616,%eax
f010dbed:	66 a3 d0 a4 69 f0    	mov    %ax,0xf069a4d0
f010dbf3:	66 c7 05 d2 a4 69 f0 	movw   $0x8,0xf069a4d2
f010dbfa:	08 00 
f010dbfc:	a0 d4 a4 69 f0       	mov    0xf069a4d4,%al
f010dc01:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc04:	a2 d4 a4 69 f0       	mov    %al,0xf069a4d4
f010dc09:	a0 d4 a4 69 f0       	mov    0xf069a4d4,%al
f010dc0e:	83 e0 1f             	and    $0x1f,%eax
f010dc11:	a2 d4 a4 69 f0       	mov    %al,0xf069a4d4
f010dc16:	a0 d5 a4 69 f0       	mov    0xf069a4d5,%al
f010dc1b:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc1e:	83 c8 0e             	or     $0xe,%eax
f010dc21:	a2 d5 a4 69 f0       	mov    %al,0xf069a4d5
f010dc26:	a0 d5 a4 69 f0       	mov    0xf069a4d5,%al
f010dc2b:	83 e0 ef             	and    $0xffffffef,%eax
f010dc2e:	a2 d5 a4 69 f0       	mov    %al,0xf069a4d5
f010dc33:	a0 d5 a4 69 f0       	mov    0xf069a4d5,%al
f010dc38:	83 c8 60             	or     $0x60,%eax
f010dc3b:	a2 d5 a4 69 f0       	mov    %al,0xf069a4d5
f010dc40:	a0 d5 a4 69 f0       	mov    0xf069a4d5,%al
f010dc45:	83 c8 80             	or     $0xffffff80,%eax
f010dc48:	a2 d5 a4 69 f0       	mov    %al,0xf069a4d5
f010dc4d:	b8 16 e6 10 f0       	mov    $0xf010e616,%eax
f010dc52:	c1 e8 10             	shr    $0x10,%eax
f010dc55:	66 a3 d6 a4 69 f0    	mov    %ax,0xf069a4d6
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dc5b:	b8 1c e6 10 f0       	mov    $0xf010e61c,%eax
f010dc60:	66 a3 d8 a4 69 f0    	mov    %ax,0xf069a4d8
f010dc66:	66 c7 05 da a4 69 f0 	movw   $0x8,0xf069a4da
f010dc6d:	08 00 
f010dc6f:	a0 dc a4 69 f0       	mov    0xf069a4dc,%al
f010dc74:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc77:	a2 dc a4 69 f0       	mov    %al,0xf069a4dc
f010dc7c:	a0 dc a4 69 f0       	mov    0xf069a4dc,%al
f010dc81:	83 e0 1f             	and    $0x1f,%eax
f010dc84:	a2 dc a4 69 f0       	mov    %al,0xf069a4dc
f010dc89:	a0 dd a4 69 f0       	mov    0xf069a4dd,%al
f010dc8e:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc91:	83 c8 0e             	or     $0xe,%eax
f010dc94:	a2 dd a4 69 f0       	mov    %al,0xf069a4dd
f010dc99:	a0 dd a4 69 f0       	mov    0xf069a4dd,%al
f010dc9e:	83 e0 ef             	and    $0xffffffef,%eax
f010dca1:	a2 dd a4 69 f0       	mov    %al,0xf069a4dd
f010dca6:	a0 dd a4 69 f0       	mov    0xf069a4dd,%al
f010dcab:	83 c8 60             	or     $0x60,%eax
f010dcae:	a2 dd a4 69 f0       	mov    %al,0xf069a4dd
f010dcb3:	a0 dd a4 69 f0       	mov    0xf069a4dd,%al
f010dcb8:	83 c8 80             	or     $0xffffff80,%eax
f010dcbb:	a2 dd a4 69 f0       	mov    %al,0xf069a4dd
f010dcc0:	b8 1c e6 10 f0       	mov    $0xf010e61c,%eax
f010dcc5:	c1 e8 10             	shr    $0x10,%eax
f010dcc8:	66 a3 de a4 69 f0    	mov    %ax,0xf069a4de
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dcce:	b8 22 e6 10 f0       	mov    $0xf010e622,%eax
f010dcd3:	66 a3 e0 a4 69 f0    	mov    %ax,0xf069a4e0
f010dcd9:	66 c7 05 e2 a4 69 f0 	movw   $0x8,0xf069a4e2
f010dce0:	08 00 
f010dce2:	a0 e4 a4 69 f0       	mov    0xf069a4e4,%al
f010dce7:	83 e0 e0             	and    $0xffffffe0,%eax
f010dcea:	a2 e4 a4 69 f0       	mov    %al,0xf069a4e4
f010dcef:	a0 e4 a4 69 f0       	mov    0xf069a4e4,%al
f010dcf4:	83 e0 1f             	and    $0x1f,%eax
f010dcf7:	a2 e4 a4 69 f0       	mov    %al,0xf069a4e4
f010dcfc:	a0 e5 a4 69 f0       	mov    0xf069a4e5,%al
f010dd01:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd04:	83 c8 0e             	or     $0xe,%eax
f010dd07:	a2 e5 a4 69 f0       	mov    %al,0xf069a4e5
f010dd0c:	a0 e5 a4 69 f0       	mov    0xf069a4e5,%al
f010dd11:	83 e0 ef             	and    $0xffffffef,%eax
f010dd14:	a2 e5 a4 69 f0       	mov    %al,0xf069a4e5
f010dd19:	a0 e5 a4 69 f0       	mov    0xf069a4e5,%al
f010dd1e:	83 c8 60             	or     $0x60,%eax
f010dd21:	a2 e5 a4 69 f0       	mov    %al,0xf069a4e5
f010dd26:	a0 e5 a4 69 f0       	mov    0xf069a4e5,%al
f010dd2b:	83 c8 80             	or     $0xffffff80,%eax
f010dd2e:	a2 e5 a4 69 f0       	mov    %al,0xf069a4e5
f010dd33:	b8 22 e6 10 f0       	mov    $0xf010e622,%eax
f010dd38:	c1 e8 10             	shr    $0x10,%eax
f010dd3b:	66 a3 e6 a4 69 f0    	mov    %ax,0xf069a4e6
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dd41:	b8 28 e6 10 f0       	mov    $0xf010e628,%eax
f010dd46:	66 a3 e8 a4 69 f0    	mov    %ax,0xf069a4e8
f010dd4c:	66 c7 05 ea a4 69 f0 	movw   $0x8,0xf069a4ea
f010dd53:	08 00 
f010dd55:	a0 ec a4 69 f0       	mov    0xf069a4ec,%al
f010dd5a:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd5d:	a2 ec a4 69 f0       	mov    %al,0xf069a4ec
f010dd62:	a0 ec a4 69 f0       	mov    0xf069a4ec,%al
f010dd67:	83 e0 1f             	and    $0x1f,%eax
f010dd6a:	a2 ec a4 69 f0       	mov    %al,0xf069a4ec
f010dd6f:	a0 ed a4 69 f0       	mov    0xf069a4ed,%al
f010dd74:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd77:	83 c8 0e             	or     $0xe,%eax
f010dd7a:	a2 ed a4 69 f0       	mov    %al,0xf069a4ed
f010dd7f:	a0 ed a4 69 f0       	mov    0xf069a4ed,%al
f010dd84:	83 e0 ef             	and    $0xffffffef,%eax
f010dd87:	a2 ed a4 69 f0       	mov    %al,0xf069a4ed
f010dd8c:	a0 ed a4 69 f0       	mov    0xf069a4ed,%al
f010dd91:	83 c8 60             	or     $0x60,%eax
f010dd94:	a2 ed a4 69 f0       	mov    %al,0xf069a4ed
f010dd99:	a0 ed a4 69 f0       	mov    0xf069a4ed,%al
f010dd9e:	83 c8 80             	or     $0xffffff80,%eax
f010dda1:	a2 ed a4 69 f0       	mov    %al,0xf069a4ed
f010dda6:	b8 28 e6 10 f0       	mov    $0xf010e628,%eax
f010ddab:	c1 e8 10             	shr    $0x10,%eax
f010ddae:	66 a3 ee a4 69 f0    	mov    %ax,0xf069a4ee
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010ddb4:	b8 2e e6 10 f0       	mov    $0xf010e62e,%eax
f010ddb9:	66 a3 f0 a4 69 f0    	mov    %ax,0xf069a4f0
f010ddbf:	66 c7 05 f2 a4 69 f0 	movw   $0x8,0xf069a4f2
f010ddc6:	08 00 
f010ddc8:	a0 f4 a4 69 f0       	mov    0xf069a4f4,%al
f010ddcd:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddd0:	a2 f4 a4 69 f0       	mov    %al,0xf069a4f4
f010ddd5:	a0 f4 a4 69 f0       	mov    0xf069a4f4,%al
f010ddda:	83 e0 1f             	and    $0x1f,%eax
f010dddd:	a2 f4 a4 69 f0       	mov    %al,0xf069a4f4
f010dde2:	a0 f5 a4 69 f0       	mov    0xf069a4f5,%al
f010dde7:	83 e0 f0             	and    $0xfffffff0,%eax
f010ddea:	83 c8 0e             	or     $0xe,%eax
f010dded:	a2 f5 a4 69 f0       	mov    %al,0xf069a4f5
f010ddf2:	a0 f5 a4 69 f0       	mov    0xf069a4f5,%al
f010ddf7:	83 e0 ef             	and    $0xffffffef,%eax
f010ddfa:	a2 f5 a4 69 f0       	mov    %al,0xf069a4f5
f010ddff:	a0 f5 a4 69 f0       	mov    0xf069a4f5,%al
f010de04:	83 c8 60             	or     $0x60,%eax
f010de07:	a2 f5 a4 69 f0       	mov    %al,0xf069a4f5
f010de0c:	a0 f5 a4 69 f0       	mov    0xf069a4f5,%al
f010de11:	83 c8 80             	or     $0xffffff80,%eax
f010de14:	a2 f5 a4 69 f0       	mov    %al,0xf069a4f5
f010de19:	b8 2e e6 10 f0       	mov    $0xf010e62e,%eax
f010de1e:	c1 e8 10             	shr    $0x10,%eax
f010de21:	66 a3 f6 a4 69 f0    	mov    %ax,0xf069a4f6
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010de27:	b8 34 e6 10 f0       	mov    $0xf010e634,%eax
f010de2c:	66 a3 f8 a4 69 f0    	mov    %ax,0xf069a4f8
f010de32:	66 c7 05 fa a4 69 f0 	movw   $0x8,0xf069a4fa
f010de39:	08 00 
f010de3b:	a0 fc a4 69 f0       	mov    0xf069a4fc,%al
f010de40:	83 e0 e0             	and    $0xffffffe0,%eax
f010de43:	a2 fc a4 69 f0       	mov    %al,0xf069a4fc
f010de48:	a0 fc a4 69 f0       	mov    0xf069a4fc,%al
f010de4d:	83 e0 1f             	and    $0x1f,%eax
f010de50:	a2 fc a4 69 f0       	mov    %al,0xf069a4fc
f010de55:	a0 fd a4 69 f0       	mov    0xf069a4fd,%al
f010de5a:	83 e0 f0             	and    $0xfffffff0,%eax
f010de5d:	83 c8 0e             	or     $0xe,%eax
f010de60:	a2 fd a4 69 f0       	mov    %al,0xf069a4fd
f010de65:	a0 fd a4 69 f0       	mov    0xf069a4fd,%al
f010de6a:	83 e0 ef             	and    $0xffffffef,%eax
f010de6d:	a2 fd a4 69 f0       	mov    %al,0xf069a4fd
f010de72:	a0 fd a4 69 f0       	mov    0xf069a4fd,%al
f010de77:	83 c8 60             	or     $0x60,%eax
f010de7a:	a2 fd a4 69 f0       	mov    %al,0xf069a4fd
f010de7f:	a0 fd a4 69 f0       	mov    0xf069a4fd,%al
f010de84:	83 c8 80             	or     $0xffffff80,%eax
f010de87:	a2 fd a4 69 f0       	mov    %al,0xf069a4fd
f010de8c:	b8 34 e6 10 f0       	mov    $0xf010e634,%eax
f010de91:	c1 e8 10             	shr    $0x10,%eax
f010de94:	66 a3 fe a4 69 f0    	mov    %ax,0xf069a4fe
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010de9a:	b8 3a e6 10 f0       	mov    $0xf010e63a,%eax
f010de9f:	66 a3 00 a5 69 f0    	mov    %ax,0xf069a500
f010dea5:	66 c7 05 02 a5 69 f0 	movw   $0x8,0xf069a502
f010deac:	08 00 
f010deae:	a0 04 a5 69 f0       	mov    0xf069a504,%al
f010deb3:	83 e0 e0             	and    $0xffffffe0,%eax
f010deb6:	a2 04 a5 69 f0       	mov    %al,0xf069a504
f010debb:	a0 04 a5 69 f0       	mov    0xf069a504,%al
f010dec0:	83 e0 1f             	and    $0x1f,%eax
f010dec3:	a2 04 a5 69 f0       	mov    %al,0xf069a504
f010dec8:	a0 05 a5 69 f0       	mov    0xf069a505,%al
f010decd:	83 e0 f0             	and    $0xfffffff0,%eax
f010ded0:	83 c8 0e             	or     $0xe,%eax
f010ded3:	a2 05 a5 69 f0       	mov    %al,0xf069a505
f010ded8:	a0 05 a5 69 f0       	mov    0xf069a505,%al
f010dedd:	83 e0 ef             	and    $0xffffffef,%eax
f010dee0:	a2 05 a5 69 f0       	mov    %al,0xf069a505
f010dee5:	a0 05 a5 69 f0       	mov    0xf069a505,%al
f010deea:	83 c8 60             	or     $0x60,%eax
f010deed:	a2 05 a5 69 f0       	mov    %al,0xf069a505
f010def2:	a0 05 a5 69 f0       	mov    0xf069a505,%al
f010def7:	83 c8 80             	or     $0xffffff80,%eax
f010defa:	a2 05 a5 69 f0       	mov    %al,0xf069a505
f010deff:	b8 3a e6 10 f0       	mov    $0xf010e63a,%eax
f010df04:	c1 e8 10             	shr    $0x10,%eax
f010df07:	66 a3 06 a5 69 f0    	mov    %ax,0xf069a506
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010df0d:	b8 40 e6 10 f0       	mov    $0xf010e640,%eax
f010df12:	66 a3 08 a5 69 f0    	mov    %ax,0xf069a508
f010df18:	66 c7 05 0a a5 69 f0 	movw   $0x8,0xf069a50a
f010df1f:	08 00 
f010df21:	a0 0c a5 69 f0       	mov    0xf069a50c,%al
f010df26:	83 e0 e0             	and    $0xffffffe0,%eax
f010df29:	a2 0c a5 69 f0       	mov    %al,0xf069a50c
f010df2e:	a0 0c a5 69 f0       	mov    0xf069a50c,%al
f010df33:	83 e0 1f             	and    $0x1f,%eax
f010df36:	a2 0c a5 69 f0       	mov    %al,0xf069a50c
f010df3b:	a0 0d a5 69 f0       	mov    0xf069a50d,%al
f010df40:	83 e0 f0             	and    $0xfffffff0,%eax
f010df43:	83 c8 0e             	or     $0xe,%eax
f010df46:	a2 0d a5 69 f0       	mov    %al,0xf069a50d
f010df4b:	a0 0d a5 69 f0       	mov    0xf069a50d,%al
f010df50:	83 e0 ef             	and    $0xffffffef,%eax
f010df53:	a2 0d a5 69 f0       	mov    %al,0xf069a50d
f010df58:	a0 0d a5 69 f0       	mov    0xf069a50d,%al
f010df5d:	83 c8 60             	or     $0x60,%eax
f010df60:	a2 0d a5 69 f0       	mov    %al,0xf069a50d
f010df65:	a0 0d a5 69 f0       	mov    0xf069a50d,%al
f010df6a:	83 c8 80             	or     $0xffffff80,%eax
f010df6d:	a2 0d a5 69 f0       	mov    %al,0xf069a50d
f010df72:	b8 40 e6 10 f0       	mov    $0xf010e640,%eax
f010df77:	c1 e8 10             	shr    $0x10,%eax
f010df7a:	66 a3 0e a5 69 f0    	mov    %ax,0xf069a50e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010df80:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010df85:	66 a3 10 a5 69 f0    	mov    %ax,0xf069a510
f010df8b:	66 c7 05 12 a5 69 f0 	movw   $0x8,0xf069a512
f010df92:	08 00 
f010df94:	a0 14 a5 69 f0       	mov    0xf069a514,%al
f010df99:	83 e0 e0             	and    $0xffffffe0,%eax
f010df9c:	a2 14 a5 69 f0       	mov    %al,0xf069a514
f010dfa1:	a0 14 a5 69 f0       	mov    0xf069a514,%al
f010dfa6:	83 e0 1f             	and    $0x1f,%eax
f010dfa9:	a2 14 a5 69 f0       	mov    %al,0xf069a514
f010dfae:	a0 15 a5 69 f0       	mov    0xf069a515,%al
f010dfb3:	83 e0 f0             	and    $0xfffffff0,%eax
f010dfb6:	83 c8 0e             	or     $0xe,%eax
f010dfb9:	a2 15 a5 69 f0       	mov    %al,0xf069a515
f010dfbe:	a0 15 a5 69 f0       	mov    0xf069a515,%al
f010dfc3:	83 e0 ef             	and    $0xffffffef,%eax
f010dfc6:	a2 15 a5 69 f0       	mov    %al,0xf069a515
f010dfcb:	a0 15 a5 69 f0       	mov    0xf069a515,%al
f010dfd0:	83 c8 60             	or     $0x60,%eax
f010dfd3:	a2 15 a5 69 f0       	mov    %al,0xf069a515
f010dfd8:	a0 15 a5 69 f0       	mov    0xf069a515,%al
f010dfdd:	83 c8 80             	or     $0xffffff80,%eax
f010dfe0:	a2 15 a5 69 f0       	mov    %al,0xf069a515
f010dfe5:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010dfea:	c1 e8 10             	shr    $0x10,%eax
f010dfed:	66 a3 16 a5 69 f0    	mov    %ax,0xf069a516
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010dff3:	b8 4c e6 10 f0       	mov    $0xf010e64c,%eax
f010dff8:	66 a3 18 a5 69 f0    	mov    %ax,0xf069a518
f010dffe:	66 c7 05 1a a5 69 f0 	movw   $0x8,0xf069a51a
f010e005:	08 00 
f010e007:	a0 1c a5 69 f0       	mov    0xf069a51c,%al
f010e00c:	83 e0 e0             	and    $0xffffffe0,%eax
f010e00f:	a2 1c a5 69 f0       	mov    %al,0xf069a51c
f010e014:	a0 1c a5 69 f0       	mov    0xf069a51c,%al
f010e019:	83 e0 1f             	and    $0x1f,%eax
f010e01c:	a2 1c a5 69 f0       	mov    %al,0xf069a51c
f010e021:	a0 1d a5 69 f0       	mov    0xf069a51d,%al
f010e026:	83 e0 f0             	and    $0xfffffff0,%eax
f010e029:	83 c8 0e             	or     $0xe,%eax
f010e02c:	a2 1d a5 69 f0       	mov    %al,0xf069a51d
f010e031:	a0 1d a5 69 f0       	mov    0xf069a51d,%al
f010e036:	83 e0 ef             	and    $0xffffffef,%eax
f010e039:	a2 1d a5 69 f0       	mov    %al,0xf069a51d
f010e03e:	a0 1d a5 69 f0       	mov    0xf069a51d,%al
f010e043:	83 c8 60             	or     $0x60,%eax
f010e046:	a2 1d a5 69 f0       	mov    %al,0xf069a51d
f010e04b:	a0 1d a5 69 f0       	mov    0xf069a51d,%al
f010e050:	83 c8 80             	or     $0xffffff80,%eax
f010e053:	a2 1d a5 69 f0       	mov    %al,0xf069a51d
f010e058:	b8 4c e6 10 f0       	mov    $0xf010e64c,%eax
f010e05d:	c1 e8 10             	shr    $0x10,%eax
f010e060:	66 a3 1e a5 69 f0    	mov    %ax,0xf069a51e
f010e066:	c7 45 fc a0 a3 69 f0 	movl   $0xf069a3a0,-0x4(%ebp)
f010e06d:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e074:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e077:	48                   	dec    %eax
f010e078:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e07c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e07f:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e083:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e086:	c1 e8 10             	shr    $0x10,%eax
f010e089:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e08d:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e090:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e093:	90                   	nop
f010e094:	c9                   	leave  
f010e095:	c3                   	ret    

f010e096 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e096:	55                   	push   %ebp
f010e097:	89 e5                	mov    %esp,%ebp
f010e099:	53                   	push   %ebx
f010e09a:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e09d:	83 ec 08             	sub    $0x8,%esp
f010e0a0:	ff 75 08             	pushl  0x8(%ebp)
f010e0a3:	68 fe 72 12 f0       	push   $0xf01272fe
f010e0a8:	e8 de 2e ff ff       	call   f0100f8b <cprintf>
f010e0ad:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e0b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0b3:	83 ec 0c             	sub    $0xc,%esp
f010e0b6:	50                   	push   %eax
f010e0b7:	e8 fd 00 00 00       	call   f010e1b9 <print_regs>
f010e0bc:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e0bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0c2:	8b 40 20             	mov    0x20(%eax),%eax
f010e0c5:	0f b7 c0             	movzwl %ax,%eax
f010e0c8:	83 ec 08             	sub    $0x8,%esp
f010e0cb:	50                   	push   %eax
f010e0cc:	68 10 73 12 f0       	push   $0xf0127310
f010e0d1:	e8 b5 2e ff ff       	call   f0100f8b <cprintf>
f010e0d6:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e0d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0dc:	8b 40 24             	mov    0x24(%eax),%eax
f010e0df:	0f b7 c0             	movzwl %ax,%eax
f010e0e2:	83 ec 08             	sub    $0x8,%esp
f010e0e5:	50                   	push   %eax
f010e0e6:	68 23 73 12 f0       	push   $0xf0127323
f010e0eb:	e8 9b 2e ff ff       	call   f0100f8b <cprintf>
f010e0f0:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e0f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0f6:	8b 58 28             	mov    0x28(%eax),%ebx
f010e0f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0fc:	8b 40 28             	mov    0x28(%eax),%eax
f010e0ff:	83 ec 0c             	sub    $0xc,%esp
f010e102:	50                   	push   %eax
f010e103:	e8 28 ee ff ff       	call   f010cf30 <trapname>
f010e108:	83 c4 10             	add    $0x10,%esp
f010e10b:	89 c2                	mov    %eax,%edx
f010e10d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e110:	8b 40 28             	mov    0x28(%eax),%eax
f010e113:	53                   	push   %ebx
f010e114:	52                   	push   %edx
f010e115:	50                   	push   %eax
f010e116:	68 36 73 12 f0       	push   $0xf0127336
f010e11b:	e8 6b 2e ff ff       	call   f0100f8b <cprintf>
f010e120:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e123:	8b 45 08             	mov    0x8(%ebp),%eax
f010e126:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e129:	83 ec 08             	sub    $0x8,%esp
f010e12c:	50                   	push   %eax
f010e12d:	68 4d 73 12 f0       	push   $0xf012734d
f010e132:	e8 54 2e ff ff       	call   f0100f8b <cprintf>
f010e137:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e13a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e13d:	8b 40 30             	mov    0x30(%eax),%eax
f010e140:	83 ec 08             	sub    $0x8,%esp
f010e143:	50                   	push   %eax
f010e144:	68 5c 73 12 f0       	push   $0xf012735c
f010e149:	e8 3d 2e ff ff       	call   f0100f8b <cprintf>
f010e14e:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e151:	8b 45 08             	mov    0x8(%ebp),%eax
f010e154:	8b 40 34             	mov    0x34(%eax),%eax
f010e157:	0f b7 c0             	movzwl %ax,%eax
f010e15a:	83 ec 08             	sub    $0x8,%esp
f010e15d:	50                   	push   %eax
f010e15e:	68 6b 73 12 f0       	push   $0xf012736b
f010e163:	e8 23 2e ff ff       	call   f0100f8b <cprintf>
f010e168:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e16b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e16e:	8b 40 38             	mov    0x38(%eax),%eax
f010e171:	83 ec 08             	sub    $0x8,%esp
f010e174:	50                   	push   %eax
f010e175:	68 7e 73 12 f0       	push   $0xf012737e
f010e17a:	e8 0c 2e ff ff       	call   f0100f8b <cprintf>
f010e17f:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e182:	8b 45 08             	mov    0x8(%ebp),%eax
f010e185:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e188:	83 ec 08             	sub    $0x8,%esp
f010e18b:	50                   	push   %eax
f010e18c:	68 8d 73 12 f0       	push   $0xf012738d
f010e191:	e8 f5 2d ff ff       	call   f0100f8b <cprintf>
f010e196:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e199:	8b 45 08             	mov    0x8(%ebp),%eax
f010e19c:	8b 40 40             	mov    0x40(%eax),%eax
f010e19f:	0f b7 c0             	movzwl %ax,%eax
f010e1a2:	83 ec 08             	sub    $0x8,%esp
f010e1a5:	50                   	push   %eax
f010e1a6:	68 9c 73 12 f0       	push   $0xf012739c
f010e1ab:	e8 db 2d ff ff       	call   f0100f8b <cprintf>
f010e1b0:	83 c4 10             	add    $0x10,%esp
}
f010e1b3:	90                   	nop
f010e1b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e1b7:	c9                   	leave  
f010e1b8:	c3                   	ret    

f010e1b9 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e1b9:	55                   	push   %ebp
f010e1ba:	89 e5                	mov    %esp,%ebp
f010e1bc:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e1bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1c2:	8b 00                	mov    (%eax),%eax
f010e1c4:	83 ec 08             	sub    $0x8,%esp
f010e1c7:	50                   	push   %eax
f010e1c8:	68 af 73 12 f0       	push   $0xf01273af
f010e1cd:	e8 b9 2d ff ff       	call   f0100f8b <cprintf>
f010e1d2:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e1d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1d8:	8b 40 04             	mov    0x4(%eax),%eax
f010e1db:	83 ec 08             	sub    $0x8,%esp
f010e1de:	50                   	push   %eax
f010e1df:	68 be 73 12 f0       	push   $0xf01273be
f010e1e4:	e8 a2 2d ff ff       	call   f0100f8b <cprintf>
f010e1e9:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e1ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1ef:	8b 40 08             	mov    0x8(%eax),%eax
f010e1f2:	83 ec 08             	sub    $0x8,%esp
f010e1f5:	50                   	push   %eax
f010e1f6:	68 cd 73 12 f0       	push   $0xf01273cd
f010e1fb:	e8 8b 2d ff ff       	call   f0100f8b <cprintf>
f010e200:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e203:	8b 45 08             	mov    0x8(%ebp),%eax
f010e206:	8b 40 0c             	mov    0xc(%eax),%eax
f010e209:	83 ec 08             	sub    $0x8,%esp
f010e20c:	50                   	push   %eax
f010e20d:	68 dc 73 12 f0       	push   $0xf01273dc
f010e212:	e8 74 2d ff ff       	call   f0100f8b <cprintf>
f010e217:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e21a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e21d:	8b 40 10             	mov    0x10(%eax),%eax
f010e220:	83 ec 08             	sub    $0x8,%esp
f010e223:	50                   	push   %eax
f010e224:	68 eb 73 12 f0       	push   $0xf01273eb
f010e229:	e8 5d 2d ff ff       	call   f0100f8b <cprintf>
f010e22e:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e231:	8b 45 08             	mov    0x8(%ebp),%eax
f010e234:	8b 40 14             	mov    0x14(%eax),%eax
f010e237:	83 ec 08             	sub    $0x8,%esp
f010e23a:	50                   	push   %eax
f010e23b:	68 fa 73 12 f0       	push   $0xf01273fa
f010e240:	e8 46 2d ff ff       	call   f0100f8b <cprintf>
f010e245:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e248:	8b 45 08             	mov    0x8(%ebp),%eax
f010e24b:	8b 40 18             	mov    0x18(%eax),%eax
f010e24e:	83 ec 08             	sub    $0x8,%esp
f010e251:	50                   	push   %eax
f010e252:	68 09 74 12 f0       	push   $0xf0127409
f010e257:	e8 2f 2d ff ff       	call   f0100f8b <cprintf>
f010e25c:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e25f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e262:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e265:	83 ec 08             	sub    $0x8,%esp
f010e268:	50                   	push   %eax
f010e269:	68 18 74 12 f0       	push   $0xf0127418
f010e26e:	e8 18 2d ff ff       	call   f0100f8b <cprintf>
f010e273:	83 c4 10             	add    $0x10,%esp
}
f010e276:	90                   	nop
f010e277:	c9                   	leave  
f010e278:	c3                   	ret    

f010e279 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e279:	55                   	push   %ebp
f010e27a:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e27c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e27f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e282:	89 14 85 a0 ab 69 f0 	mov    %edx,-0xf965460(,%eax,4)
}
f010e289:	90                   	nop
f010e28a:	5d                   	pop    %ebp
f010e28b:	c3                   	ret    

f010e28c <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e28c:	55                   	push   %ebp
f010e28d:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e28f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e292:	c7 04 85 a0 ab 69 f0 	movl   $0x0,-0xf965460(,%eax,4)
f010e299:	00 00 00 00 
}
f010e29d:	90                   	nop
f010e29e:	5d                   	pop    %ebp
f010e29f:	c3                   	ret    

f010e2a0 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e2a0:	55                   	push   %ebp
f010e2a1:	89 e5                	mov    %esp,%ebp
f010e2a3:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e2a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2a9:	8b 40 28             	mov    0x28(%eax),%eax
f010e2ac:	83 e8 20             	sub    $0x20,%eax
f010e2af:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e2b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2b5:	8b 04 85 a0 ab 69 f0 	mov    -0xf965460(,%eax,4),%eax
f010e2bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e2bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e2c3:	74 0e                	je     f010e2d3 <irq_dispatch+0x33>
	{
		handler(tf);
f010e2c5:	83 ec 0c             	sub    $0xc,%esp
f010e2c8:	ff 75 08             	pushl  0x8(%ebp)
f010e2cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2ce:	ff d0                	call   *%eax
f010e2d0:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e2d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2d6:	0f b6 c0             	movzbl %al,%eax
f010e2d9:	83 ec 0c             	sub    $0xc,%esp
f010e2dc:	50                   	push   %eax
f010e2dd:	e8 f1 8d ff ff       	call   f01070d3 <pic_sendEOI>
f010e2e2:	83 c4 10             	add    $0x10,%esp
}
f010e2e5:	90                   	nop
f010e2e6:	c9                   	leave  
f010e2e7:	c3                   	ret    

f010e2e8 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e2e8:	55                   	push   %ebp
f010e2e9:	89 e5                	mov    %esp,%ebp
f010e2eb:	57                   	push   %edi
f010e2ec:	56                   	push   %esi
f010e2ed:	53                   	push   %ebx
f010e2ee:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e2f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2f4:	8b 40 28             	mov    0x28(%eax),%eax
f010e2f7:	83 f8 0e             	cmp    $0xe,%eax
f010e2fa:	75 51                	jne    f010e34d <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e2fc:	a0 e0 ab 69 f0       	mov    0xf069abe0,%al
f010e301:	84 c0                	test   %al,%al
f010e303:	74 1f                	je     f010e324 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e305:	8b 45 08             	mov    0x8(%ebp),%eax
f010e308:	8b 40 30             	mov    0x30(%eax),%eax
f010e30b:	89 c2                	mov    %eax,%edx
f010e30d:	a0 e0 ab 69 f0       	mov    0xf069abe0,%al
f010e312:	0f b6 c0             	movzbl %al,%eax
f010e315:	01 d0                	add    %edx,%eax
f010e317:	89 c2                	mov    %eax,%edx
f010e319:	8b 45 08             	mov    0x8(%ebp),%eax
f010e31c:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e31f:	e9 0c 01 00 00       	jmp    f010e430 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e324:	83 ec 0c             	sub    $0xc,%esp
f010e327:	6a 01                	push   $0x1
f010e329:	e8 ed 12 00 00       	call   f010f61b <isPageReplacmentAlgorithmLRU>
f010e32e:	83 c4 10             	add    $0x10,%esp
f010e331:	85 c0                	test   %eax,%eax
f010e333:	74 05                	je     f010e33a <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e335:	e8 08 89 ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e33a:	83 ec 0c             	sub    $0xc,%esp
f010e33d:	ff 75 08             	pushl  0x8(%ebp)
f010e340:	e8 bb 13 00 00       	call   f010f700 <fault_handler>
f010e345:	83 c4 10             	add    $0x10,%esp
f010e348:	e9 e3 00 00 00       	jmp    f010e430 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e34d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e350:	8b 40 28             	mov    0x28(%eax),%eax
f010e353:	83 f8 30             	cmp    $0x30,%eax
f010e356:	75 6e                	jne    f010e3c6 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e358:	8b 45 08             	mov    0x8(%ebp),%eax
f010e35b:	8b 40 38             	mov    0x38(%eax),%eax
f010e35e:	25 00 02 00 00       	and    $0x200,%eax
f010e363:	85 c0                	test   %eax,%eax
f010e365:	74 06                	je     f010e36d <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e367:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e368:	e8 75 69 ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e36d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e370:	8b 78 04             	mov    0x4(%eax),%edi
f010e373:	8b 45 08             	mov    0x8(%ebp),%eax
f010e376:	8b 30                	mov    (%eax),%esi
f010e378:	8b 45 08             	mov    0x8(%ebp),%eax
f010e37b:	8b 58 10             	mov    0x10(%eax),%ebx
f010e37e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e381:	8b 48 18             	mov    0x18(%eax),%ecx
f010e384:	8b 45 08             	mov    0x8(%ebp),%eax
f010e387:	8b 50 14             	mov    0x14(%eax),%edx
f010e38a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e38d:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e390:	83 ec 08             	sub    $0x8,%esp
f010e393:	57                   	push   %edi
f010e394:	56                   	push   %esi
f010e395:	53                   	push   %ebx
f010e396:	51                   	push   %ecx
f010e397:	52                   	push   %edx
f010e398:	50                   	push   %eax
f010e399:	e8 a4 09 00 00       	call   f010ed42 <syscall>
f010e39e:	83 c4 20             	add    $0x20,%esp
f010e3a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e3a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3a7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e3aa:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e3ad:	9c                   	pushf  
f010e3ae:	58                   	pop    %eax
f010e3af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e3b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e3b5:	25 00 02 00 00       	and    $0x200,%eax
f010e3ba:	85 c0                	test   %eax,%eax
f010e3bc:	74 72                	je     f010e430 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e3be:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e3bf:	e8 f6 68 ff ff       	call   f0104cba <kclock_stop>
f010e3c4:	eb 6a                	jmp    f010e430 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e3c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3c9:	8b 40 28             	mov    0x28(%eax),%eax
f010e3cc:	83 f8 08             	cmp    $0x8,%eax
f010e3cf:	75 17                	jne    f010e3e8 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e3d1:	83 ec 04             	sub    $0x4,%esp
f010e3d4:	68 27 74 12 f0       	push   $0xf0127427
f010e3d9:	68 22 01 00 00       	push   $0x122
f010e3de:	68 36 74 12 f0       	push   $0xf0127436
f010e3e3:	e8 51 1f ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e3e8:	83 ec 0c             	sub    $0xc,%esp
f010e3eb:	ff 75 08             	pushl  0x8(%ebp)
f010e3ee:	e8 a3 fc ff ff       	call   f010e096 <print_trapframe>
f010e3f3:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e3f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f9:	8b 40 34             	mov    0x34(%eax),%eax
f010e3fc:	66 83 f8 08          	cmp    $0x8,%ax
f010e400:	75 17                	jne    f010e419 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e402:	83 ec 04             	sub    $0x4,%esp
f010e405:	68 47 74 12 f0       	push   $0xf0127447
f010e40a:	68 2a 01 00 00       	push   $0x12a
f010e40f:	68 36 74 12 f0       	push   $0xf0127436
f010e414:	e8 20 1f ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e419:	83 ec 04             	sub    $0x4,%esp
f010e41c:	68 60 74 12 f0       	push   $0xf0127460
f010e421:	68 2f 01 00 00       	push   $0x12f
f010e426:	68 36 74 12 f0       	push   $0xf0127436
f010e42b:	e8 09 1f ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e430:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e433:	5b                   	pop    %ebx
f010e434:	5e                   	pop    %esi
f010e435:	5f                   	pop    %edi
f010e436:	5d                   	pop    %ebp
f010e437:	c3                   	ret    

f010e438 <trap>:

void trap(struct Trapframe *tf)
{
f010e438:	55                   	push   %ebp
f010e439:	89 e5                	mov    %esp,%ebp
f010e43b:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e43e:	e8 77 68 ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e443:	9c                   	pushf  
f010e444:	58                   	pop    %eax
f010e445:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e448:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e44b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e44e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e451:	25 00 02 00 00       	and    $0x200,%eax
f010e456:	85 c0                	test   %eax,%eax
f010e458:	74 25                	je     f010e47f <trap+0x47>
	{
		print_trapframe(tf);
f010e45a:	83 ec 0c             	sub    $0xc,%esp
f010e45d:	ff 75 08             	pushl  0x8(%ebp)
f010e460:	e8 31 fc ff ff       	call   f010e096 <print_trapframe>
f010e465:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e468:	83 ec 04             	sub    $0x4,%esp
f010e46b:	68 80 74 12 f0       	push   $0xf0127480
f010e470:	68 45 01 00 00       	push   $0x145
f010e475:	68 36 74 12 f0       	push   $0xf0127436
f010e47a:	e8 ba 1e ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e47f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e486:	e8 55 d5 ff ff       	call   f010b9e0 <get_cpu_proc>
f010e48b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e48e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e491:	8b 40 34             	mov    0x34(%eax),%eax
f010e494:	0f b7 c0             	movzwl %ax,%eax
f010e497:	83 e0 03             	and    $0x3,%eax
f010e49a:	83 f8 03             	cmp    $0x3,%eax
f010e49d:	75 54                	jne    f010e4f3 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e49f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e4a3:	74 0b                	je     f010e4b0 <trap+0x78>
f010e4a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e4a8:	8b 40 18             	mov    0x18(%eax),%eax
f010e4ab:	83 f8 02             	cmp    $0x2,%eax
f010e4ae:	74 19                	je     f010e4c9 <trap+0x91>
f010e4b0:	68 c4 74 12 f0       	push   $0xf01274c4
f010e4b5:	68 f2 74 12 f0       	push   $0xf01274f2
f010e4ba:	68 4d 01 00 00       	push   $0x14d
f010e4bf:	68 36 74 12 f0       	push   $0xf0127436
f010e4c4:	e8 70 1e ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e4c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e4cc:	8b 00                	mov    (%eax),%eax
f010e4ce:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e4d1:	74 19                	je     f010e4ec <trap+0xb4>
f010e4d3:	68 07 75 12 f0       	push   $0xf0127507
f010e4d8:	68 f2 74 12 f0       	push   $0xf01274f2
f010e4dd:	68 4f 01 00 00       	push   $0x14f
f010e4e2:	68 36 74 12 f0       	push   $0xf0127436
f010e4e7:	e8 4d 1e ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e4ec:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e4f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4f6:	8b 40 28             	mov    0x28(%eax),%eax
f010e4f9:	83 f8 1f             	cmp    $0x1f,%eax
f010e4fc:	76 1b                	jbe    f010e519 <trap+0xe1>
f010e4fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010e501:	8b 40 28             	mov    0x28(%eax),%eax
f010e504:	83 f8 2f             	cmp    $0x2f,%eax
f010e507:	77 10                	ja     f010e519 <trap+0xe1>
	{
		irq_dispatch(tf);
f010e509:	83 ec 0c             	sub    $0xc,%esp
f010e50c:	ff 75 08             	pushl  0x8(%ebp)
f010e50f:	e8 8c fd ff ff       	call   f010e2a0 <irq_dispatch>
f010e514:	83 c4 10             	add    $0x10,%esp
f010e517:	eb 0e                	jmp    f010e527 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e519:	83 ec 0c             	sub    $0xc,%esp
f010e51c:	ff 75 08             	pushl  0x8(%ebp)
f010e51f:	e8 c4 fd ff ff       	call   f010e2e8 <trap_dispatch>
f010e524:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e527:	9c                   	pushf  
f010e528:	58                   	pop    %eax
f010e529:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e52c:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e52f:	25 00 02 00 00       	and    $0x200,%eax
f010e534:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e537:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e53b:	74 19                	je     f010e556 <trap+0x11e>
f010e53d:	68 1d 75 12 f0       	push   $0xf012751d
f010e542:	68 f2 74 12 f0       	push   $0xf01274f2
f010e547:	68 66 01 00 00       	push   $0x166
f010e54c:	68 36 74 12 f0       	push   $0xf0127436
f010e551:	e8 e3 1d ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e556:	e8 87 67 ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e55b:	90                   	nop
f010e55c:	c9                   	leave  
f010e55d:	c3                   	ret    

f010e55e <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e55e:	6a 08                	push   $0x8
f010e560:	e9 ed 00 00 00       	jmp    f010e652 <_alltraps>
f010e565:	90                   	nop

f010e566 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e566:	6a 0e                	push   $0xe
f010e568:	e9 e5 00 00 00       	jmp    f010e652 <_alltraps>
f010e56d:	90                   	nop

f010e56e <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e56e:	6a 00                	push   $0x0
f010e570:	6a 20                	push   $0x20
f010e572:	e9 db 00 00 00       	jmp    f010e652 <_alltraps>
f010e577:	90                   	nop

f010e578 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e578:	6a 00                	push   $0x0
f010e57a:	6a 21                	push   $0x21
f010e57c:	e9 d1 00 00 00       	jmp    f010e652 <_alltraps>
f010e581:	90                   	nop

f010e582 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e582:	6a 00                	push   $0x0
f010e584:	6a 30                	push   $0x30
f010e586:	e9 c7 00 00 00       	jmp    f010e652 <_alltraps>
f010e58b:	90                   	nop

f010e58c <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e58c:	6a 00                	push   $0x0
f010e58e:	6a 00                	push   $0x0
f010e590:	e9 bd 00 00 00       	jmp    f010e652 <_alltraps>
f010e595:	90                   	nop

f010e596 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e596:	6a 00                	push   $0x0
f010e598:	6a 01                	push   $0x1
f010e59a:	e9 b3 00 00 00       	jmp    f010e652 <_alltraps>
f010e59f:	90                   	nop

f010e5a0 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e5a0:	6a 00                	push   $0x0
f010e5a2:	6a 02                	push   $0x2
f010e5a4:	e9 a9 00 00 00       	jmp    f010e652 <_alltraps>
f010e5a9:	90                   	nop

f010e5aa <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e5aa:	6a 00                	push   $0x0
f010e5ac:	6a 03                	push   $0x3
f010e5ae:	e9 9f 00 00 00       	jmp    f010e652 <_alltraps>
f010e5b3:	90                   	nop

f010e5b4 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e5b4:	6a 00                	push   $0x0
f010e5b6:	6a 04                	push   $0x4
f010e5b8:	e9 95 00 00 00       	jmp    f010e652 <_alltraps>
f010e5bd:	90                   	nop

f010e5be <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e5be:	6a 00                	push   $0x0
f010e5c0:	6a 05                	push   $0x5
f010e5c2:	e9 8b 00 00 00       	jmp    f010e652 <_alltraps>
f010e5c7:	90                   	nop

f010e5c8 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e5c8:	6a 00                	push   $0x0
f010e5ca:	6a 06                	push   $0x6
f010e5cc:	e9 81 00 00 00       	jmp    f010e652 <_alltraps>
f010e5d1:	90                   	nop

f010e5d2 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e5d2:	6a 00                	push   $0x0
f010e5d4:	6a 07                	push   $0x7
f010e5d6:	eb 7a                	jmp    f010e652 <_alltraps>

f010e5d8 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e5d8:	6a 0a                	push   $0xa
f010e5da:	eb 76                	jmp    f010e652 <_alltraps>

f010e5dc <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e5dc:	6a 0b                	push   $0xb
f010e5de:	eb 72                	jmp    f010e652 <_alltraps>

f010e5e0 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e5e0:	6a 0c                	push   $0xc
f010e5e2:	eb 6e                	jmp    f010e652 <_alltraps>

f010e5e4 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e5e4:	6a 0d                	push   $0xd
f010e5e6:	eb 6a                	jmp    f010e652 <_alltraps>

f010e5e8 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e5e8:	6a 00                	push   $0x0
f010e5ea:	6a 10                	push   $0x10
f010e5ec:	eb 64                	jmp    f010e652 <_alltraps>

f010e5ee <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e5ee:	6a 11                	push   $0x11
f010e5f0:	eb 60                	jmp    f010e652 <_alltraps>

f010e5f2 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e5f2:	6a 00                	push   $0x0
f010e5f4:	6a 12                	push   $0x12
f010e5f6:	eb 5a                	jmp    f010e652 <_alltraps>

f010e5f8 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e5f8:	6a 00                	push   $0x0
f010e5fa:	6a 13                	push   $0x13
f010e5fc:	eb 54                	jmp    f010e652 <_alltraps>

f010e5fe <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e5fe:	6a 00                	push   $0x0
f010e600:	6a 22                	push   $0x22
f010e602:	eb 4e                	jmp    f010e652 <_alltraps>

f010e604 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e604:	6a 00                	push   $0x0
f010e606:	6a 23                	push   $0x23
f010e608:	eb 48                	jmp    f010e652 <_alltraps>

f010e60a <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e60a:	6a 00                	push   $0x0
f010e60c:	6a 24                	push   $0x24
f010e60e:	eb 42                	jmp    f010e652 <_alltraps>

f010e610 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e610:	6a 00                	push   $0x0
f010e612:	6a 25                	push   $0x25
f010e614:	eb 3c                	jmp    f010e652 <_alltraps>

f010e616 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e616:	6a 00                	push   $0x0
f010e618:	6a 26                	push   $0x26
f010e61a:	eb 36                	jmp    f010e652 <_alltraps>

f010e61c <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e61c:	6a 00                	push   $0x0
f010e61e:	6a 27                	push   $0x27
f010e620:	eb 30                	jmp    f010e652 <_alltraps>

f010e622 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e622:	6a 00                	push   $0x0
f010e624:	6a 28                	push   $0x28
f010e626:	eb 2a                	jmp    f010e652 <_alltraps>

f010e628 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e628:	6a 00                	push   $0x0
f010e62a:	6a 29                	push   $0x29
f010e62c:	eb 24                	jmp    f010e652 <_alltraps>

f010e62e <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e62e:	6a 00                	push   $0x0
f010e630:	6a 2a                	push   $0x2a
f010e632:	eb 1e                	jmp    f010e652 <_alltraps>

f010e634 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e634:	6a 00                	push   $0x0
f010e636:	6a 2b                	push   $0x2b
f010e638:	eb 18                	jmp    f010e652 <_alltraps>

f010e63a <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e63a:	6a 00                	push   $0x0
f010e63c:	6a 2c                	push   $0x2c
f010e63e:	eb 12                	jmp    f010e652 <_alltraps>

f010e640 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e640:	6a 00                	push   $0x0
f010e642:	6a 2d                	push   $0x2d
f010e644:	eb 0c                	jmp    f010e652 <_alltraps>

f010e646 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e646:	6a 00                	push   $0x0
f010e648:	6a 2e                	push   $0x2e
f010e64a:	eb 06                	jmp    f010e652 <_alltraps>

f010e64c <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e64c:	6a 00                	push   $0x0
f010e64e:	6a 2f                	push   $0x2f
f010e650:	eb 00                	jmp    f010e652 <_alltraps>

f010e652 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e652:	1e                   	push   %ds
push 	%es
f010e653:	06                   	push   %es
pushal
f010e654:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e655:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e659:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e65b:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e65d:	54                   	push   %esp
call 	trap
f010e65e:	e8 d5 fd ff ff       	call   f010e438 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e663:	59                   	pop    %ecx

f010e664 <trapret>:
.globl trapret
trapret:
popal
f010e664:	61                   	popa   
pop 	%es
f010e665:	07                   	pop    %es
pop 	%ds
f010e666:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e667:	83 c4 08             	add    $0x8,%esp
iret
f010e66a:	cf                   	iret   

f010e66b <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e66b:	55                   	push   %ebp
f010e66c:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e66e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e671:	8b 15 60 33 ac f0    	mov    0xf0ac3360,%edx
f010e677:	29 d0                	sub    %edx,%eax
f010e679:	c1 f8 03             	sar    $0x3,%eax
f010e67c:	89 c2                	mov    %eax,%edx
f010e67e:	89 d0                	mov    %edx,%eax
f010e680:	c1 e0 02             	shl    $0x2,%eax
f010e683:	01 d0                	add    %edx,%eax
f010e685:	c1 e0 02             	shl    $0x2,%eax
f010e688:	01 d0                	add    %edx,%eax
f010e68a:	c1 e0 02             	shl    $0x2,%eax
f010e68d:	01 d0                	add    %edx,%eax
f010e68f:	89 c1                	mov    %eax,%ecx
f010e691:	c1 e1 08             	shl    $0x8,%ecx
f010e694:	01 c8                	add    %ecx,%eax
f010e696:	89 c1                	mov    %eax,%ecx
f010e698:	c1 e1 10             	shl    $0x10,%ecx
f010e69b:	01 c8                	add    %ecx,%eax
f010e69d:	01 c0                	add    %eax,%eax
f010e69f:	01 d0                	add    %edx,%eax
}
f010e6a1:	5d                   	pop    %ebp
f010e6a2:	c3                   	ret    

f010e6a3 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e6a3:	55                   	push   %ebp
f010e6a4:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e6a6:	ff 75 08             	pushl  0x8(%ebp)
f010e6a9:	e8 bd ff ff ff       	call   f010e66b <to_frame_number>
f010e6ae:	83 c4 04             	add    $0x4,%esp
f010e6b1:	c1 e0 0c             	shl    $0xc,%eax
}
f010e6b4:	c9                   	leave  
f010e6b5:	c3                   	ret    

f010e6b6 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e6b6:	55                   	push   %ebp
f010e6b7:	89 e5                	mov    %esp,%ebp
f010e6b9:	83 ec 18             	sub    $0x18,%esp
f010e6bc:	8b 45 10             	mov    0x10(%ebp),%eax
f010e6bf:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e6c2:	e8 08 8b ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e6c7:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e6cb:	74 23                	je     f010e6f0 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e6cd:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010e6d2:	8b 40 10             	mov    0x10(%eax),%eax
f010e6d5:	8b 15 60 1b 65 f2    	mov    0xf2651b60,%edx
f010e6db:	83 c2 20             	add    $0x20,%edx
f010e6de:	83 ec 04             	sub    $0x4,%esp
f010e6e1:	50                   	push   %eax
f010e6e2:	52                   	push   %edx
f010e6e3:	68 d0 76 12 f0       	push   $0xf01276d0
f010e6e8:	e8 9e 28 ff ff       	call   f0100f8b <cprintf>
f010e6ed:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e6f0:	83 ec 04             	sub    $0x4,%esp
f010e6f3:	ff 75 08             	pushl  0x8(%ebp)
f010e6f6:	ff 75 0c             	pushl  0xc(%ebp)
f010e6f9:	68 d9 76 12 f0       	push   $0xf01276d9
f010e6fe:	e8 88 28 ff ff       	call   f0100f8b <cprintf>
f010e703:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e706:	e8 16 8b ff ff       	call   f0107221 <popcli>
}
f010e70b:	90                   	nop
f010e70c:	c9                   	leave  
f010e70d:	c3                   	ret    

f010e70e <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e70e:	55                   	push   %ebp
f010e70f:	89 e5                	mov    %esp,%ebp
f010e711:	83 ec 18             	sub    $0x18,%esp
f010e714:	8b 45 08             	mov    0x8(%ebp),%eax
f010e717:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e71a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e71e:	83 ec 08             	sub    $0x8,%esp
f010e721:	50                   	push   %eax
f010e722:	68 de 76 12 f0       	push   $0xf01276de
f010e727:	e8 5f 28 ff ff       	call   f0100f8b <cprintf>
f010e72c:	83 c4 10             	add    $0x10,%esp
}
f010e72f:	90                   	nop
f010e730:	c9                   	leave  
f010e731:	c3                   	ret    

f010e732 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e732:	55                   	push   %ebp
f010e733:	89 e5                	mov    %esp,%ebp
f010e735:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e738:	9c                   	pushf  
f010e739:	58                   	pop    %eax
f010e73a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e73d:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e740:	25 00 02 00 00       	and    $0x200,%eax
f010e745:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e748:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e74c:	74 10                	je     f010e75e <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e74e:	e8 71 26 ff ff       	call   f0100dc4 <cons_getc2>
f010e753:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e756:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e75a:	74 f2                	je     f010e74e <sys_cgetc+0x1c>
f010e75c:	eb 0e                	jmp    f010e76c <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e75e:	e8 06 26 ff ff       	call   f0100d69 <cons_getc>
f010e763:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e766:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e76a:	74 f2                	je     f010e75e <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e76c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e76f:	c9                   	leave  
f010e770:	c3                   	ret    

f010e771 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e771:	55                   	push   %ebp
f010e772:	89 e5                	mov    %esp,%ebp
f010e774:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e777:	e8 34 27 ff ff       	call   f0100eb0 <cons_lock>
}
f010e77c:	90                   	nop
f010e77d:	c9                   	leave  
f010e77e:	c3                   	ret    

f010e77f <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e77f:	55                   	push   %ebp
f010e780:	89 e5                	mov    %esp,%ebp
f010e782:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e785:	e8 6d 27 ff ff       	call   f0100ef7 <cons_unlock>
}
f010e78a:	90                   	nop
f010e78b:	c9                   	leave  
f010e78c:	c3                   	ret    

f010e78d <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e78d:	55                   	push   %ebp
f010e78e:	89 e5                	mov    %esp,%ebp
f010e790:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e793:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010e798:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e79b:	83 ec 0c             	sub    $0xc,%esp
f010e79e:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e7a1:	50                   	push   %eax
f010e7a2:	e8 0b 9a ff ff       	call   f01081b2 <allocate_frame>
f010e7a7:	83 c4 10             	add    $0x10,%esp
f010e7aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e7ad:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e7b1:	75 08                	jne    f010e7bb <__sys_allocate_page+0x2e>
		return r ;
f010e7b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7b6:	e9 e9 00 00 00       	jmp    f010e8a4 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e7bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7be:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e7c3:	77 0c                	ja     f010e7d1 <__sys_allocate_page+0x44>
f010e7c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7c8:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e7cd:	85 c0                	test   %eax,%eax
f010e7cf:	74 0a                	je     f010e7db <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e7d1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e7d6:	e9 c9 00 00 00       	jmp    f010e8a4 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e7db:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7de:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e7e3:	83 f8 04             	cmp    $0x4,%eax
f010e7e6:	74 0a                	je     f010e7f2 <__sys_allocate_page+0x65>
		return E_INVAL;
f010e7e8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e7ed:	e9 b2 00 00 00       	jmp    f010e8a4 <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e7f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e7f5:	83 ec 0c             	sub    $0xc,%esp
f010e7f8:	50                   	push   %eax
f010e7f9:	e8 a5 fe ff ff       	call   f010e6a3 <to_physical_address>
f010e7fe:	83 c4 10             	add    $0x10,%esp
f010e801:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e804:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e807:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e80a:	8b 40 64             	mov    0x64(%eax),%eax
f010e80d:	6a 02                	push   $0x2
f010e80f:	68 00 00 80 ef       	push   $0xef800000
f010e814:	52                   	push   %edx
f010e815:	50                   	push   %eax
f010e816:	e8 64 9e ff ff       	call   f010867f <map_frame>
f010e81b:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e81e:	83 ec 04             	sub    $0x4,%esp
f010e821:	68 00 10 00 00       	push   $0x1000
f010e826:	6a 00                	push   $0x0
f010e828:	68 00 00 80 ef       	push   $0xef800000
f010e82d:	e8 d8 15 01 00       	call   f011fe0a <memset>
f010e832:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e835:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e838:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e83b:	8b 40 08             	mov    0x8(%eax),%eax
f010e83e:	40                   	inc    %eax
f010e83f:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e843:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e846:	8b 40 64             	mov    0x64(%eax),%eax
f010e849:	83 ec 08             	sub    $0x8,%esp
f010e84c:	68 00 00 80 ef       	push   $0xef800000
f010e851:	50                   	push   %eax
f010e852:	e8 88 9f ff ff       	call   f01087df <unmap_frame>
f010e857:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e85a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e85d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e860:	8b 40 08             	mov    0x8(%eax),%eax
f010e863:	48                   	dec    %eax
f010e864:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e868:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e86b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e86e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e871:	8b 40 64             	mov    0x64(%eax),%eax
f010e874:	ff 75 0c             	pushl  0xc(%ebp)
f010e877:	51                   	push   %ecx
f010e878:	52                   	push   %edx
f010e879:	50                   	push   %eax
f010e87a:	e8 00 9e ff ff       	call   f010867f <map_frame>
f010e87f:	83 c4 10             	add    $0x10,%esp
f010e882:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e885:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e889:	75 14                	jne    f010e89f <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e88b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e88e:	83 ec 0c             	sub    $0xc,%esp
f010e891:	50                   	push   %eax
f010e892:	e8 28 9b ff ff       	call   f01083bf <decrement_references>
f010e897:	83 c4 10             	add    $0x10,%esp
		return r;
f010e89a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e89d:	eb 05                	jmp    f010e8a4 <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e89f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e8a4:	c9                   	leave  
f010e8a5:	c3                   	ret    

f010e8a6 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e8a6:	55                   	push   %ebp
f010e8a7:	89 e5                	mov    %esp,%ebp
f010e8a9:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e8ac:	83 ec 04             	sub    $0x4,%esp
f010e8af:	68 e1 76 12 f0       	push   $0xf01276e1
f010e8b4:	68 dc 00 00 00       	push   $0xdc
f010e8b9:	68 ff 76 12 f0       	push   $0xf01276ff
f010e8be:	e8 76 1a ff ff       	call   f0100339 <_panic>

f010e8c3 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e8c3:	55                   	push   %ebp
f010e8c4:	89 e5                	mov    %esp,%ebp
f010e8c6:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e8c9:	83 ec 04             	sub    $0x4,%esp
f010e8cc:	68 14 77 12 f0       	push   $0xf0127714
f010e8d1:	68 ed 00 00 00       	push   $0xed
f010e8d6:	68 ff 76 12 f0       	push   $0xf01276ff
f010e8db:	e8 59 1a ff ff       	call   f0100339 <_panic>

f010e8e0 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e8e0:	55                   	push   %ebp
f010e8e1:	89 e5                	mov    %esp,%ebp
f010e8e3:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e8e6:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010e8eb:	8b 40 64             	mov    0x64(%eax),%eax
f010e8ee:	83 ec 04             	sub    $0x4,%esp
f010e8f1:	ff 75 0c             	pushl  0xc(%ebp)
f010e8f4:	ff 75 08             	pushl  0x8(%ebp)
f010e8f7:	50                   	push   %eax
f010e8f8:	e8 6a c2 ff ff       	call   f010ab67 <calculate_required_frames>
f010e8fd:	83 c4 10             	add    $0x10,%esp
}
f010e900:	c9                   	leave  
f010e901:	c3                   	ret    

f010e902 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e902:	55                   	push   %ebp
f010e903:	89 e5                	mov    %esp,%ebp
f010e905:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e908:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e90b:	83 ec 0c             	sub    $0xc,%esp
f010e90e:	50                   	push   %eax
f010e90f:	e8 4d a0 ff ff       	call   f0108961 <calculate_available_frames>
f010e914:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e917:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e91a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e91d:	01 d0                	add    %edx,%eax
}
f010e91f:	c9                   	leave  
f010e920:	c3                   	ret    

f010e921 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e921:	55                   	push   %ebp
f010e922:	89 e5                	mov    %esp,%ebp
f010e924:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e927:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e92a:	83 ec 0c             	sub    $0xc,%esp
f010e92d:	50                   	push   %eax
f010e92e:	e8 2e a0 ff ff       	call   f0108961 <calculate_available_frames>
f010e933:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e936:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e939:	c9                   	leave  
f010e93a:	c3                   	ret    

f010e93b <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e93b:	55                   	push   %ebp
f010e93c:	89 e5                	mov    %esp,%ebp
f010e93e:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e941:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e944:	83 ec 0c             	sub    $0xc,%esp
f010e947:	50                   	push   %eax
f010e948:	e8 14 a0 ff ff       	call   f0108961 <calculate_available_frames>
f010e94d:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e950:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e953:	c9                   	leave  
f010e954:	c3                   	ret    

f010e955 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e955:	55                   	push   %ebp
f010e956:	89 e5                	mov    %esp,%ebp
f010e958:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e95b:	83 ec 0c             	sub    $0xc,%esp
f010e95e:	ff 75 08             	pushl  0x8(%ebp)
f010e961:	e8 4d 00 01 00       	call   f011e9b3 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e966:	83 c4 10             	add    $0x10,%esp
}
f010e969:	c9                   	leave  
f010e96a:	c3                   	ret    

f010e96b <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e96b:	55                   	push   %ebp
f010e96c:	89 e5                	mov    %esp,%ebp
f010e96e:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e971:	e8 68 ff 00 00       	call   f011e8de <scarce_memory>
}
f010e976:	90                   	nop
f010e977:	c9                   	leave  
f010e978:	c3                   	ret    

f010e979 <sys_clearFFL>:

void sys_clearFFL()
{
f010e979:	55                   	push   %ebp
f010e97a:	89 e5                	mov    %esp,%ebp
f010e97c:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010e97f:	83 ec 0c             	sub    $0xc,%esp
f010e982:	68 20 2f ac f0       	push   $0xf0ac2f20
f010e987:	e8 e2 12 00 00       	call   f010fc6e <acquire_spinlock>
f010e98c:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e98f:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f010e994:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e997:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e99e:	eb 12                	jmp    f010e9b2 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e9a0:	83 ec 0c             	sub    $0xc,%esp
f010e9a3:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9a6:	50                   	push   %eax
f010e9a7:	e8 06 98 ff ff       	call   f01081b2 <allocate_frame>
f010e9ac:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e9af:	ff 45 f4             	incl   -0xc(%ebp)
f010e9b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9b5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e9b8:	7c e6                	jl     f010e9a0 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010e9ba:	83 ec 0c             	sub    $0xc,%esp
f010e9bd:	68 20 2f ac f0       	push   $0xf0ac2f20
f010e9c2:	e8 2e 13 00 00       	call   f010fcf5 <release_spinlock>
f010e9c7:	83 c4 10             	add    $0x10,%esp
}
f010e9ca:	90                   	nop
f010e9cb:	c9                   	leave  
f010e9cc:	c3                   	ret    

f010e9cd <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e9cd:	55                   	push   %ebp
f010e9ce:	89 e5                	mov    %esp,%ebp
f010e9d0:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010e9d3:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010e9d8:	83 ec 0c             	sub    $0xc,%esp
f010e9db:	50                   	push   %eax
f010e9dc:	e8 1e 5e ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010e9e1:	83 c4 10             	add    $0x10,%esp
}
f010e9e4:	c9                   	leave  
f010e9e5:	c3                   	ret    

f010e9e6 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e9e6:	55                   	push   %ebp
f010e9e7:	89 e5                	mov    %esp,%ebp
f010e9e9:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010e9ec:	e8 ed 0c 00 00       	call   f010f6de <isBufferingEnabled>
f010e9f1:	84 c0                	test   %al,%al
f010e9f3:	74 19                	je     f010ea0e <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010e9f5:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010e9fa:	83 ec 04             	sub    $0x4,%esp
f010e9fd:	ff 75 0c             	pushl  0xc(%ebp)
f010ea00:	ff 75 08             	pushl  0x8(%ebp)
f010ea03:	50                   	push   %eax
f010ea04:	e8 49 c3 ff ff       	call   f010ad52 <__free_user_mem_with_buffering>
f010ea09:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ea0c:	eb 18                	jmp    f010ea26 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ea0e:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ea13:	83 ec 04             	sub    $0x4,%esp
f010ea16:	ff 75 0c             	pushl  0xc(%ebp)
f010ea19:	ff 75 08             	pushl  0x8(%ebp)
f010ea1c:	50                   	push   %eax
f010ea1d:	e8 a4 c2 ff ff       	call   f010acc6 <free_user_mem>
f010ea22:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ea25:	90                   	nop
}
f010ea26:	c9                   	leave  
f010ea27:	c3                   	ret    

f010ea28 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010ea28:	55                   	push   %ebp
f010ea29:	89 e5                	mov    %esp,%ebp
f010ea2b:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010ea2e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ea32:	75 07                	jne    f010ea3b <check_Param+0x13>
	{
		env_exit();
f010ea34:	e8 65 cf ff ff       	call   f010b99e <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ea39:	eb 25                	jmp    f010ea60 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010ea3b:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010ea42:	77 07                	ja     f010ea4b <check_Param+0x23>
f010ea44:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea47:	85 c0                	test   %eax,%eax
f010ea49:	78 07                	js     f010ea52 <check_Param+0x2a>
	{
		env_exit();
f010ea4b:	e8 4e cf ff ff       	call   f010b99e <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ea50:	eb 0e                	jmp    f010ea60 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010ea52:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010ea59:	76 05                	jbe    f010ea60 <check_Param+0x38>
	{
		env_exit();
f010ea5b:	e8 3e cf ff ff       	call   f010b99e <env_exit>
	}
}
f010ea60:	90                   	nop
f010ea61:	c9                   	leave  
f010ea62:	c3                   	ret    

f010ea63 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010ea63:	55                   	push   %ebp
f010ea64:	89 e5                	mov    %esp,%ebp
f010ea66:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010ea69:	83 ec 0c             	sub    $0xc,%esp
f010ea6c:	ff 75 08             	pushl  0x8(%ebp)
f010ea6f:	e8 b4 ff ff ff       	call   f010ea28 <check_Param>
f010ea74:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010ea77:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ea7c:	83 ec 04             	sub    $0x4,%esp
f010ea7f:	ff 75 0c             	pushl  0xc(%ebp)
f010ea82:	ff 75 08             	pushl  0x8(%ebp)
f010ea85:	50                   	push   %eax
f010ea86:	e8 80 c1 ff ff       	call   f010ac0b <allocate_user_mem>
f010ea8b:	83 c4 10             	add    $0x10,%esp
	return;
f010ea8e:	90                   	nop
}
f010ea8f:	c9                   	leave  
f010ea90:	c3                   	ret    

f010ea91 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010ea91:	55                   	push   %ebp
f010ea92:	89 e5                	mov    %esp,%ebp
f010ea94:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010ea97:	83 ec 0c             	sub    $0xc,%esp
f010ea9a:	ff 75 08             	pushl  0x8(%ebp)
f010ea9d:	e8 86 ff ff ff       	call   f010ea28 <check_Param>
f010eaa2:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010eaa5:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010eaaa:	8b 40 64             	mov    0x64(%eax),%eax
f010eaad:	ff 75 10             	pushl  0x10(%ebp)
f010eab0:	ff 75 0c             	pushl  0xc(%ebp)
f010eab3:	ff 75 08             	pushl  0x8(%ebp)
f010eab6:	50                   	push   %eax
f010eab7:	e8 77 c0 ff ff       	call   f010ab33 <allocate_chunk>
f010eabc:	83 c4 10             	add    $0x10,%esp
	return;
f010eabf:	90                   	nop
}
f010eac0:	c9                   	leave  
f010eac1:	c3                   	ret    

f010eac2 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010eac2:	55                   	push   %ebp
f010eac3:	89 e5                	mov    %esp,%ebp
f010eac5:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010eac8:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010eacd:	ff 75 10             	pushl  0x10(%ebp)
f010ead0:	ff 75 0c             	pushl  0xc(%ebp)
f010ead3:	ff 75 08             	pushl  0x8(%ebp)
f010ead6:	50                   	push   %eax
f010ead7:	e8 93 c2 ff ff       	call   f010ad6f <move_user_mem>
f010eadc:	83 c4 10             	add    $0x10,%esp
	return;
f010eadf:	90                   	nop
}
f010eae0:	c9                   	leave  
f010eae1:	c3                   	ret    

f010eae2 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010eae2:	55                   	push   %ebp
f010eae3:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010eae5:	a1 44 33 ac f0       	mov    0xf0ac3344,%eax
}
f010eaea:	5d                   	pop    %ebp
f010eaeb:	c3                   	ret    

f010eaec <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010eaec:	55                   	push   %ebp
f010eaed:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010eaef:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf2:	a3 44 33 ac f0       	mov    %eax,0xf0ac3344
}
f010eaf7:	90                   	nop
f010eaf8:	5d                   	pop    %ebp
f010eaf9:	c3                   	ret    

f010eafa <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010eafa:	55                   	push   %ebp
f010eafb:	89 e5                	mov    %esp,%ebp
f010eafd:	83 ec 18             	sub    $0x18,%esp
f010eb00:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb03:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010eb06:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010eb0a:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010eb0f:	8b 40 10             	mov    0x10(%eax),%eax
f010eb12:	83 ec 0c             	sub    $0xc,%esp
f010eb15:	ff 75 14             	pushl  0x14(%ebp)
f010eb18:	52                   	push   %edx
f010eb19:	ff 75 0c             	pushl  0xc(%ebp)
f010eb1c:	ff 75 08             	pushl  0x8(%ebp)
f010eb1f:	50                   	push   %eax
f010eb20:	e8 60 a1 ff ff       	call   f0108c85 <createSharedObject>
f010eb25:	83 c4 20             	add    $0x20,%esp
}
f010eb28:	c9                   	leave  
f010eb29:	c3                   	ret    

f010eb2a <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010eb2a:	55                   	push   %ebp
f010eb2b:	89 e5                	mov    %esp,%ebp
f010eb2d:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010eb30:	83 ec 08             	sub    $0x8,%esp
f010eb33:	ff 75 0c             	pushl  0xc(%ebp)
f010eb36:	ff 75 08             	pushl  0x8(%ebp)
f010eb39:	e8 42 9f ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010eb3e:	83 c4 10             	add    $0x10,%esp
}
f010eb41:	c9                   	leave  
f010eb42:	c3                   	ret    

f010eb43 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010eb43:	55                   	push   %ebp
f010eb44:	89 e5                	mov    %esp,%ebp
f010eb46:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010eb49:	83 ec 04             	sub    $0x4,%esp
f010eb4c:	ff 75 10             	pushl  0x10(%ebp)
f010eb4f:	ff 75 0c             	pushl  0xc(%ebp)
f010eb52:	ff 75 08             	pushl  0x8(%ebp)
f010eb55:	e8 be a2 ff ff       	call   f0108e18 <getSharedObject>
f010eb5a:	83 c4 10             	add    $0x10,%esp
}
f010eb5d:	c9                   	leave  
f010eb5e:	c3                   	ret    

f010eb5f <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010eb5f:	55                   	push   %ebp
f010eb60:	89 e5                	mov    %esp,%ebp
f010eb62:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010eb65:	83 ec 08             	sub    $0x8,%esp
f010eb68:	ff 75 0c             	pushl  0xc(%ebp)
f010eb6b:	ff 75 08             	pushl  0x8(%ebp)
f010eb6e:	e8 fd a4 ff ff       	call   f0109070 <freeSharedObject>
f010eb73:	83 c4 10             	add    $0x10,%esp
}
f010eb76:	c9                   	leave  
f010eb77:	c3                   	ret    

f010eb78 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010eb78:	55                   	push   %ebp
f010eb79:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010eb7b:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010eb80:	8b 40 10             	mov    0x10(%eax),%eax
}
f010eb83:	5d                   	pop    %ebp
f010eb84:	c3                   	ret    

f010eb85 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010eb85:	55                   	push   %ebp
f010eb86:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010eb88:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010eb8d:	89 c2                	mov    %eax,%edx
f010eb8f:	a1 74 a3 69 f0       	mov    0xf069a374,%eax
f010eb94:	29 c2                	sub    %eax,%edx
f010eb96:	89 d0                	mov    %edx,%eax
f010eb98:	c1 f8 02             	sar    $0x2,%eax
f010eb9b:	89 c2                	mov    %eax,%edx
f010eb9d:	89 d0                	mov    %edx,%eax
f010eb9f:	c1 e0 03             	shl    $0x3,%eax
f010eba2:	01 d0                	add    %edx,%eax
f010eba4:	c1 e0 03             	shl    $0x3,%eax
f010eba7:	01 d0                	add    %edx,%eax
f010eba9:	c1 e0 02             	shl    $0x2,%eax
f010ebac:	01 d0                	add    %edx,%eax
f010ebae:	01 c0                	add    %eax,%eax
f010ebb0:	01 d0                	add    %edx,%eax
f010ebb2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ebb9:	01 c8                	add    %ecx,%eax
f010ebbb:	c1 e0 02             	shl    $0x2,%eax
f010ebbe:	01 d0                	add    %edx,%eax
f010ebc0:	c1 e0 03             	shl    $0x3,%eax
f010ebc3:	01 d0                	add    %edx,%eax
f010ebc5:	c1 e0 05             	shl    $0x5,%eax
f010ebc8:	29 d0                	sub    %edx,%eax
f010ebca:	c1 e0 02             	shl    $0x2,%eax
f010ebcd:	01 d0                	add    %edx,%eax
f010ebcf:	01 c0                	add    %eax,%eax
f010ebd1:	01 d0                	add    %edx,%eax
f010ebd3:	c1 e0 03             	shl    $0x3,%eax
f010ebd6:	01 d0                	add    %edx,%eax
f010ebd8:	c1 e0 04             	shl    $0x4,%eax
f010ebdb:	29 d0                	sub    %edx,%eax
}
f010ebdd:	5d                   	pop    %ebp
f010ebde:	c3                   	ret    

f010ebdf <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ebdf:	55                   	push   %ebp
f010ebe0:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010ebe2:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ebe7:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ebea:	5d                   	pop    %ebp
f010ebeb:	c3                   	ret    

f010ebec <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ebec:	55                   	push   %ebp
f010ebed:	89 e5                	mov    %esp,%ebp
f010ebef:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010ebf2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ebf6:	75 0a                	jne    f010ec02 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010ebf8:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ebfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ec00:	eb 22                	jmp    f010ec24 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ec02:	83 ec 04             	sub    $0x4,%esp
f010ec05:	6a 00                	push   $0x0
f010ec07:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ec0a:	50                   	push   %eax
f010ec0b:	ff 75 08             	pushl  0x8(%ebp)
f010ec0e:	e8 1d ce ff ff       	call   f010ba30 <envid2env>
f010ec13:	83 c4 10             	add    $0x10,%esp
f010ec16:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ec19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec1d:	79 05                	jns    f010ec24 <sys_destroy_env+0x38>
	{
		return r;
f010ec1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec22:	eb 5e                	jmp    f010ec82 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010ec24:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ec27:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ec2c:	39 c2                	cmp    %eax,%edx
f010ec2e:	75 1b                	jne    f010ec4b <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ec30:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ec35:	8b 40 10             	mov    0x10(%eax),%eax
f010ec38:	83 ec 08             	sub    $0x8,%esp
f010ec3b:	50                   	push   %eax
f010ec3c:	68 33 77 12 f0       	push   $0xf0127733
f010ec41:	e8 45 23 ff ff       	call   f0100f8b <cprintf>
f010ec46:	83 c4 10             	add    $0x10,%esp
f010ec49:	eb 20                	jmp    f010ec6b <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ec4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec4e:	8b 50 10             	mov    0x10(%eax),%edx
f010ec51:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ec56:	8b 40 10             	mov    0x10(%eax),%eax
f010ec59:	83 ec 04             	sub    $0x4,%esp
f010ec5c:	52                   	push   %edx
f010ec5d:	50                   	push   %eax
f010ec5e:	68 4e 77 12 f0       	push   $0xf012774e
f010ec63:	e8 23 23 ff ff       	call   f0100f8b <cprintf>
f010ec68:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010ec6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec6e:	8b 40 10             	mov    0x10(%eax),%eax
f010ec71:	83 ec 0c             	sub    $0xc,%esp
f010ec74:	50                   	push   %eax
f010ec75:	e8 3e 6e ff ff       	call   f0105ab8 <sched_kill_env>
f010ec7a:	83 c4 10             	add    $0x10,%esp

	return 0;
f010ec7d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ec82:	c9                   	leave  
f010ec83:	c3                   	ret    

f010ec84 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010ec84:	55                   	push   %ebp
f010ec85:	89 e5                	mov    %esp,%ebp
f010ec87:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010ec8a:	e8 0f cd ff ff       	call   f010b99e <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010ec8f:	90                   	nop
f010ec90:	c9                   	leave  
f010ec91:	c3                   	ret    

f010ec92 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ec92:	55                   	push   %ebp
f010ec93:	89 e5                	mov    %esp,%ebp
f010ec95:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010ec98:	ff 75 14             	pushl  0x14(%ebp)
f010ec9b:	ff 75 10             	pushl  0x10(%ebp)
f010ec9e:	ff 75 0c             	pushl  0xc(%ebp)
f010eca1:	ff 75 08             	pushl  0x8(%ebp)
f010eca4:	e8 b9 c2 ff ff       	call   f010af62 <env_create>
f010eca9:	83 c4 10             	add    $0x10,%esp
f010ecac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ecaf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ecb3:	75 07                	jne    f010ecbc <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ecb5:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ecba:	eb 14                	jmp    f010ecd0 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ecbc:	83 ec 0c             	sub    $0xc,%esp
f010ecbf:	ff 75 f4             	pushl  -0xc(%ebp)
f010ecc2:	e8 55 6a ff ff       	call   f010571c <sched_new_env>
f010ecc7:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ecca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eccd:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ecd0:	c9                   	leave  
f010ecd1:	c3                   	ret    

f010ecd2 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ecd2:	55                   	push   %ebp
f010ecd3:	89 e5                	mov    %esp,%ebp
f010ecd5:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ecd8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecdb:	83 ec 0c             	sub    $0xc,%esp
f010ecde:	50                   	push   %eax
f010ecdf:	e8 8e 6a ff ff       	call   f0105772 <sched_run_env>
f010ece4:	83 c4 10             	add    $0x10,%esp
}
f010ece7:	90                   	nop
f010ece8:	c9                   	leave  
f010ece9:	c3                   	ret    

f010ecea <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ecea:	55                   	push   %ebp
f010eceb:	89 e5                	mov    %esp,%ebp
f010eced:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ecf0:	0f 31                	rdtsc  
f010ecf2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ecf5:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010ecf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ecfb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ecfe:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ed01:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ed04:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ed07:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ed0a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ed0d:	89 01                	mov    %eax,(%ecx)
f010ed0f:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010ed12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed15:	c9                   	leave  
f010ed16:	c2 04 00             	ret    $0x4

f010ed19 <sys_rcr2>:

uint32 sys_rcr2()
{
f010ed19:	55                   	push   %ebp
f010ed1a:	89 e5                	mov    %esp,%ebp
f010ed1c:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010ed1f:	0f 20 d0             	mov    %cr2,%eax
f010ed22:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010ed25:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ed28:	90                   	nop
}
f010ed29:	c9                   	leave  
f010ed2a:	c3                   	ret    

f010ed2b <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ed2b:	55                   	push   %ebp
f010ed2c:	89 e5                	mov    %esp,%ebp
f010ed2e:	83 ec 04             	sub    $0x4,%esp
f010ed31:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed34:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010ed37:	8a 45 fc             	mov    -0x4(%ebp),%al
f010ed3a:	a2 e0 ab 69 f0       	mov    %al,0xf069abe0
}
f010ed3f:	90                   	nop
f010ed40:	c9                   	leave  
f010ed41:	c3                   	ret    

f010ed42 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010ed42:	55                   	push   %ebp
f010ed43:	89 e5                	mov    %esp,%ebp
f010ed45:	56                   	push   %esi
f010ed46:	53                   	push   %ebx
f010ed47:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010ed4a:	e8 91 cc ff ff       	call   f010b9e0 <get_cpu_proc>
f010ed4f:	a3 60 1b 65 f2       	mov    %eax,0xf2651b60
	assert(cur_env != NULL);
f010ed54:	a1 60 1b 65 f2       	mov    0xf2651b60,%eax
f010ed59:	85 c0                	test   %eax,%eax
f010ed5b:	75 19                	jne    f010ed76 <syscall+0x34>
f010ed5d:	68 66 77 12 f0       	push   $0xf0127766
f010ed62:	68 76 77 12 f0       	push   $0xf0127776
f010ed67:	68 05 02 00 00       	push   $0x205
f010ed6c:	68 ff 76 12 f0       	push   $0xf01276ff
f010ed71:	e8 c3 15 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010ed76:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010ed7a:	0f 87 06 04 00 00    	ja     f010f186 <syscall+0x444>
f010ed80:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed83:	c1 e0 02             	shl    $0x2,%eax
f010ed86:	05 8c 77 12 f0       	add    $0xf012778c,%eax
f010ed8b:	8b 00                	mov    (%eax),%eax
f010ed8d:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010ed8f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed92:	83 ec 0c             	sub    $0xc,%esp
f010ed95:	50                   	push   %eax
f010ed96:	e8 e6 bd ff ff       	call   f010ab81 <sys_sbrk>
f010ed9b:	83 c4 10             	add    $0x10,%esp
f010ed9e:	e9 e8 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010eda3:	83 ec 08             	sub    $0x8,%esp
f010eda6:	ff 75 10             	pushl  0x10(%ebp)
f010eda9:	ff 75 0c             	pushl  0xc(%ebp)
f010edac:	e8 35 fc ff ff       	call   f010e9e6 <sys_free_user_mem>
f010edb1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010edb4:	b8 00 00 00 00       	mov    $0x0,%eax
f010edb9:	e9 cd 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010edbe:	83 ec 08             	sub    $0x8,%esp
f010edc1:	ff 75 10             	pushl  0x10(%ebp)
f010edc4:	ff 75 0c             	pushl  0xc(%ebp)
f010edc7:	e8 97 fc ff ff       	call   f010ea63 <sys_allocate_user_mem>
f010edcc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010edcf:	b8 00 00 00 00       	mov    $0x0,%eax
f010edd4:	e9 b2 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010edd9:	8b 45 14             	mov    0x14(%ebp),%eax
f010eddc:	0f b6 d0             	movzbl %al,%edx
f010eddf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ede2:	83 ec 04             	sub    $0x4,%esp
f010ede5:	52                   	push   %edx
f010ede6:	ff 75 10             	pushl  0x10(%ebp)
f010ede9:	50                   	push   %eax
f010edea:	e8 c7 f8 ff ff       	call   f010e6b6 <sys_cputs>
f010edef:	83 c4 10             	add    $0x10,%esp
		return 0;
f010edf2:	b8 00 00 00 00       	mov    $0x0,%eax
f010edf7:	e9 8f 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010edfc:	e8 31 f9 ff ff       	call   f010e732 <sys_cgetc>
f010ee01:	e9 85 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010ee06:	e8 66 f9 ff ff       	call   f010e771 <sys_lock_cons>
		return 0;
f010ee0b:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee10:	e9 76 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010ee15:	e8 65 f9 ff ff       	call   f010e77f <sys_unlock_cons>
		return 0;
f010ee1a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee1f:	e9 67 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010ee24:	83 ec 08             	sub    $0x8,%esp
f010ee27:	ff 75 10             	pushl  0x10(%ebp)
f010ee2a:	ff 75 0c             	pushl  0xc(%ebp)
f010ee2d:	e8 ae fa ff ff       	call   f010e8e0 <sys_calculate_required_frames>
f010ee32:	83 c4 10             	add    $0x10,%esp
f010ee35:	e9 51 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010ee3a:	e8 c3 fa ff ff       	call   f010e902 <sys_calculate_free_frames>
f010ee3f:	e9 47 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010ee44:	e8 d8 fa ff ff       	call   f010e921 <sys_calculate_modified_frames>
f010ee49:	e9 3d 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010ee4e:	e8 e8 fa ff ff       	call   f010e93b <sys_calculate_notmod_frames>
f010ee53:	e9 33 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010ee58:	e8 70 fb ff ff       	call   f010e9cd <sys_pf_calculate_allocated_pages>
f010ee5d:	e9 29 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010ee62:	83 ec 0c             	sub    $0xc,%esp
f010ee65:	ff 75 0c             	pushl  0xc(%ebp)
f010ee68:	e8 e8 fa ff ff       	call   f010e955 <sys_calculate_pages_tobe_removed_ready_exit>
f010ee6d:	83 c4 10             	add    $0x10,%esp
f010ee70:	e9 16 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010ee75:	e8 f1 fa ff ff       	call   f010e96b <sys_scarce_memory>
		return 0;
f010ee7a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee7f:	e9 07 03 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010ee84:	83 ec 04             	sub    $0x4,%esp
f010ee87:	ff 75 14             	pushl  0x14(%ebp)
f010ee8a:	ff 75 10             	pushl  0x10(%ebp)
f010ee8d:	ff 75 0c             	pushl  0xc(%ebp)
f010ee90:	e8 fc fb ff ff       	call   f010ea91 <sys_allocate_chunk>
f010ee95:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee98:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee9d:	e9 e9 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010eea2:	8b 55 10             	mov    0x10(%ebp),%edx
f010eea5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eea8:	83 ec 08             	sub    $0x8,%esp
f010eeab:	52                   	push   %edx
f010eeac:	50                   	push   %eax
f010eead:	e8 db f8 ff ff       	call   f010e78d <__sys_allocate_page>
f010eeb2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eeb5:	b8 00 00 00 00       	mov    $0x0,%eax
f010eeba:	e9 cc 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010eebf:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010eec2:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010eec5:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010eec8:	8b 55 10             	mov    0x10(%ebp),%edx
f010eecb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eece:	83 ec 0c             	sub    $0xc,%esp
f010eed1:	56                   	push   %esi
f010eed2:	53                   	push   %ebx
f010eed3:	51                   	push   %ecx
f010eed4:	52                   	push   %edx
f010eed5:	50                   	push   %eax
f010eed6:	e8 cb f9 ff ff       	call   f010e8a6 <__sys_map_frame>
f010eedb:	83 c4 20             	add    $0x20,%esp
		return 0;
f010eede:	b8 00 00 00 00       	mov    $0x0,%eax
f010eee3:	e9 a3 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010eee8:	8b 55 10             	mov    0x10(%ebp),%edx
f010eeeb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eeee:	83 ec 08             	sub    $0x8,%esp
f010eef1:	52                   	push   %edx
f010eef2:	50                   	push   %eax
f010eef3:	e8 cb f9 ff ff       	call   f010e8c3 <__sys_unmap_frame>
f010eef8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eefb:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef00:	e9 86 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010ef05:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef08:	0f be c0             	movsbl %al,%eax
f010ef0b:	83 ec 0c             	sub    $0xc,%esp
f010ef0e:	50                   	push   %eax
f010ef0f:	e8 fa f7 ff ff       	call   f010e70e <sys_cputc>
f010ef14:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef17:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef1c:	e9 6a 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010ef21:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef24:	0f be c0             	movsbl %al,%eax
f010ef27:	83 ec 0c             	sub    $0xc,%esp
f010ef2a:	50                   	push   %eax
f010ef2b:	e8 49 fa ff ff       	call   f010e979 <sys_clearFFL>
f010ef30:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef33:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef38:	e9 4e 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010ef3d:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010ef40:	8b 45 14             	mov    0x14(%ebp),%eax
f010ef43:	0f b6 d0             	movzbl %al,%edx
f010ef46:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef49:	51                   	push   %ecx
f010ef4a:	52                   	push   %edx
f010ef4b:	ff 75 10             	pushl  0x10(%ebp)
f010ef4e:	50                   	push   %eax
f010ef4f:	e8 a6 fb ff ff       	call   f010eafa <sys_createSharedObject>
f010ef54:	83 c4 10             	add    $0x10,%esp
f010ef57:	e9 2f 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010ef5c:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010ef5f:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef62:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef65:	83 ec 04             	sub    $0x4,%esp
f010ef68:	51                   	push   %ecx
f010ef69:	52                   	push   %edx
f010ef6a:	50                   	push   %eax
f010ef6b:	e8 d3 fb ff ff       	call   f010eb43 <sys_getSharedObject>
f010ef70:	83 c4 10             	add    $0x10,%esp
f010ef73:	e9 13 02 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010ef78:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef7e:	83 ec 08             	sub    $0x8,%esp
f010ef81:	52                   	push   %edx
f010ef82:	50                   	push   %eax
f010ef83:	e8 d7 fb ff ff       	call   f010eb5f <sys_freeSharedObject>
f010ef88:	83 c4 10             	add    $0x10,%esp
f010ef8b:	e9 fb 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010ef90:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef93:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef96:	83 ec 08             	sub    $0x8,%esp
f010ef99:	52                   	push   %edx
f010ef9a:	50                   	push   %eax
f010ef9b:	e8 8a fb ff ff       	call   f010eb2a <sys_getSizeOfSharedObject>
f010efa0:	83 c4 10             	add    $0x10,%esp
f010efa3:	e9 e3 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010efa8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efab:	ff 75 18             	pushl  0x18(%ebp)
f010efae:	ff 75 14             	pushl  0x14(%ebp)
f010efb1:	ff 75 10             	pushl  0x10(%ebp)
f010efb4:	50                   	push   %eax
f010efb5:	e8 d8 fc ff ff       	call   f010ec92 <sys_create_env>
f010efba:	83 c4 10             	add    $0x10,%esp
f010efbd:	e9 c9 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010efc2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efc5:	83 ec 0c             	sub    $0xc,%esp
f010efc8:	50                   	push   %eax
f010efc9:	e8 04 fd ff ff       	call   f010ecd2 <sys_run_env>
f010efce:	83 c4 10             	add    $0x10,%esp
		return 0;
f010efd1:	b8 00 00 00 00       	mov    $0x0,%eax
f010efd6:	e9 b0 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010efdb:	e8 a5 fb ff ff       	call   f010eb85 <sys_getenvindex>
f010efe0:	e9 a6 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010efe5:	e8 8e fb ff ff       	call   f010eb78 <sys_getenvid>
f010efea:	e9 9c 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010efef:	e8 eb fb ff ff       	call   f010ebdf <sys_getparentenvid>
f010eff4:	e9 92 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010eff9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010effc:	83 ec 0c             	sub    $0xc,%esp
f010efff:	50                   	push   %eax
f010f000:	e8 e7 fb ff ff       	call   f010ebec <sys_destroy_env>
f010f005:	83 c4 10             	add    $0x10,%esp
f010f008:	e9 7e 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f00d:	e8 72 fc ff ff       	call   f010ec84 <sys_exit_env>
		return 0;
f010f012:	b8 00 00 00 00       	mov    $0x0,%eax
f010f017:	e9 6f 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f01c:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f01f:	83 ec 0c             	sub    $0xc,%esp
f010f022:	50                   	push   %eax
f010f023:	e8 c2 fc ff ff       	call   f010ecea <sys_get_virtual_time>
f010f028:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f02b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f02e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f031:	8b 45 10             	mov    0x10(%ebp),%eax
f010f034:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f037:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f03a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f03d:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f03f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f042:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f045:	89 10                	mov    %edx,(%eax)
		return 0;
f010f047:	b8 00 00 00 00       	mov    $0x0,%eax
f010f04c:	e9 3a 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f051:	83 ec 04             	sub    $0x4,%esp
f010f054:	ff 75 14             	pushl  0x14(%ebp)
f010f057:	ff 75 10             	pushl  0x10(%ebp)
f010f05a:	ff 75 0c             	pushl  0xc(%ebp)
f010f05d:	e8 60 fa ff ff       	call   f010eac2 <sys_move_user_mem>
f010f062:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f065:	b8 00 00 00 00       	mov    $0x0,%eax
f010f06a:	e9 1c 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f06f:	e8 a5 fc ff ff       	call   f010ed19 <sys_rcr2>
f010f074:	e9 12 01 00 00       	jmp    f010f18b <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f079:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f07c:	0f b6 c0             	movzbl %al,%eax
f010f07f:	83 ec 0c             	sub    $0xc,%esp
f010f082:	50                   	push   %eax
f010f083:	e8 a3 fc ff ff       	call   f010ed2b <sys_bypassPageFault>
f010f088:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f08b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f090:	e9 f6 00 00 00       	jmp    f010f18b <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010f095:	e8 f8 ee 00 00       	call   f011df92 <rsttst>
		return 0;
f010f09a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f09f:	e9 e7 00 00 00       	jmp    f010f18b <syscall+0x449>
	case SYS_inctst:
		inctst();
f010f0a4:	e8 31 ef 00 00       	call   f011dfda <inctst>
		return 0;
f010f0a9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0ae:	e9 d8 00 00 00       	jmp    f010f18b <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010f0b3:	83 ec 0c             	sub    $0xc,%esp
f010f0b6:	ff 75 0c             	pushl  0xc(%ebp)
f010f0b9:	e8 5e f0 00 00       	call   f011e11c <chktst>
f010f0be:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0c1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0c6:	e9 c0 00 00 00       	jmp    f010f18b <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010f0cb:	e8 3e ef 00 00       	call   f011e00e <gettst>
f010f0d0:	e9 b6 00 00 00       	jmp    f010f18b <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f0d5:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f0d8:	8b 45 18             	mov    0x18(%ebp),%eax
f010f0db:	0f be c0             	movsbl %al,%eax
f010f0de:	83 ec 0c             	sub    $0xc,%esp
f010f0e1:	52                   	push   %edx
f010f0e2:	50                   	push   %eax
f010f0e3:	ff 75 14             	pushl  0x14(%ebp)
f010f0e6:	ff 75 10             	pushl  0x10(%ebp)
f010f0e9:	ff 75 0c             	pushl  0xc(%ebp)
f010f0ec:	e8 27 ef 00 00       	call   f011e018 <tst>
f010f0f1:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f0f4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0f9:	e9 8d 00 00 00       	jmp    f010f18b <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f0fe:	e8 df f9 ff ff       	call   f010eae2 <sys_get_heap_strategy>
f010f103:	e9 83 00 00 00       	jmp    f010f18b <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f108:	83 ec 0c             	sub    $0xc,%esp
f010f10b:	ff 75 0c             	pushl  0xc(%ebp)
f010f10e:	e8 d9 f9 ff ff       	call   f010eaec <sys_set_uheap_strategy>
f010f113:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f116:	b8 00 00 00 00       	mov    $0x0,%eax
f010f11b:	eb 6e                	jmp    f010f18b <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f11d:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f120:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f123:	8b 55 10             	mov    0x10(%ebp),%edx
f010f126:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f129:	53                   	push   %ebx
f010f12a:	51                   	push   %ecx
f010f12b:	52                   	push   %edx
f010f12c:	50                   	push   %eax
f010f12d:	e8 b3 1d 00 00       	call   f0110ee5 <sys_check_LRU_lists>
f010f132:	83 c4 10             	add    $0x10,%esp
f010f135:	eb 54                	jmp    f010f18b <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f137:	8b 55 10             	mov    0x10(%ebp),%edx
f010f13a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f13d:	83 ec 08             	sub    $0x8,%esp
f010f140:	52                   	push   %edx
f010f141:	50                   	push   %eax
f010f142:	e8 60 1f 00 00       	call   f01110a7 <sys_check_LRU_lists_free>
f010f147:	83 c4 10             	add    $0x10,%esp
f010f14a:	eb 3f                	jmp    f010f18b <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f14c:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f14f:	8b 55 10             	mov    0x10(%ebp),%edx
f010f152:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f155:	51                   	push   %ecx
f010f156:	ff 75 14             	pushl  0x14(%ebp)
f010f159:	52                   	push   %edx
f010f15a:	50                   	push   %eax
f010f15b:	e8 d4 20 00 00       	call   f0111234 <sys_check_WS_list>
f010f160:	83 c4 10             	add    $0x10,%esp
f010f163:	eb 26                	jmp    f010f18b <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f165:	8b 55 10             	mov    0x10(%ebp),%edx
f010f168:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f16b:	83 ec 08             	sub    $0x8,%esp
f010f16e:	52                   	push   %edx
f010f16f:	50                   	push   %eax
f010f170:	e8 a8 f1 00 00       	call   f011e31d <sys_utilities>
f010f175:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f178:	b8 00 00 00 00       	mov    $0x0,%eax
f010f17d:	eb 0c                	jmp    f010f18b <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f17f:	b8 03 00 00 00       	mov    $0x3,%eax
f010f184:	eb 05                	jmp    f010f18b <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f186:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f18b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f18e:	5b                   	pop    %ebx
f010f18f:	5e                   	pop    %esi
f010f190:	5d                   	pop    %ebp
f010f191:	c3                   	ret    

f010f192 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f192:	55                   	push   %ebp
f010f193:	89 e5                	mov    %esp,%ebp
f010f195:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f198:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f19b:	8b 00                	mov    (%eax),%eax
f010f19d:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f1a0:	8b 45 10             	mov    0x10(%ebp),%eax
f010f1a3:	8b 00                	mov    (%eax),%eax
f010f1a5:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f1a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f1af:	e9 ca 00 00 00       	jmp    f010f27e <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f1b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f1b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f1ba:	01 d0                	add    %edx,%eax
f010f1bc:	89 c2                	mov    %eax,%edx
f010f1be:	c1 ea 1f             	shr    $0x1f,%edx
f010f1c1:	01 d0                	add    %edx,%eax
f010f1c3:	d1 f8                	sar    %eax
f010f1c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f1c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f1cb:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f1ce:	eb 03                	jmp    f010f1d3 <stab_binsearch+0x41>
			m--;
f010f1d0:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f1d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f1d6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f1d9:	7c 1e                	jl     f010f1f9 <stab_binsearch+0x67>
f010f1db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f1de:	89 d0                	mov    %edx,%eax
f010f1e0:	01 c0                	add    %eax,%eax
f010f1e2:	01 d0                	add    %edx,%eax
f010f1e4:	c1 e0 02             	shl    $0x2,%eax
f010f1e7:	89 c2                	mov    %eax,%edx
f010f1e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010f1ec:	01 d0                	add    %edx,%eax
f010f1ee:	8a 40 04             	mov    0x4(%eax),%al
f010f1f1:	0f b6 c0             	movzbl %al,%eax
f010f1f4:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f1f7:	75 d7                	jne    f010f1d0 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f1f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f1fc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f1ff:	7d 09                	jge    f010f20a <stab_binsearch+0x78>
			l = true_m + 1;
f010f201:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f204:	40                   	inc    %eax
f010f205:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f208:	eb 74                	jmp    f010f27e <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f20a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f211:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f214:	89 d0                	mov    %edx,%eax
f010f216:	01 c0                	add    %eax,%eax
f010f218:	01 d0                	add    %edx,%eax
f010f21a:	c1 e0 02             	shl    $0x2,%eax
f010f21d:	89 c2                	mov    %eax,%edx
f010f21f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f222:	01 d0                	add    %edx,%eax
f010f224:	8b 40 08             	mov    0x8(%eax),%eax
f010f227:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f22a:	73 11                	jae    f010f23d <stab_binsearch+0xab>
			*region_left = m;
f010f22c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f22f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f232:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f234:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f237:	40                   	inc    %eax
f010f238:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f23b:	eb 41                	jmp    f010f27e <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f23d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f240:	89 d0                	mov    %edx,%eax
f010f242:	01 c0                	add    %eax,%eax
f010f244:	01 d0                	add    %edx,%eax
f010f246:	c1 e0 02             	shl    $0x2,%eax
f010f249:	89 c2                	mov    %eax,%edx
f010f24b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f24e:	01 d0                	add    %edx,%eax
f010f250:	8b 40 08             	mov    0x8(%eax),%eax
f010f253:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f256:	76 14                	jbe    f010f26c <stab_binsearch+0xda>
			*region_right = m - 1;
f010f258:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f25b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f25e:	8b 45 10             	mov    0x10(%ebp),%eax
f010f261:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f263:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f266:	48                   	dec    %eax
f010f267:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f26a:	eb 12                	jmp    f010f27e <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f26c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f26f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f272:	89 10                	mov    %edx,(%eax)
			l = m;
f010f274:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f277:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f27a:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f27e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f281:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f284:	0f 8e 2a ff ff ff    	jle    f010f1b4 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f28a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f28e:	75 0f                	jne    f010f29f <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f290:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f293:	8b 00                	mov    (%eax),%eax
f010f295:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f298:	8b 45 10             	mov    0x10(%ebp),%eax
f010f29b:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f29d:	eb 3d                	jmp    f010f2dc <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f29f:	8b 45 10             	mov    0x10(%ebp),%eax
f010f2a2:	8b 00                	mov    (%eax),%eax
f010f2a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f2a7:	eb 03                	jmp    f010f2ac <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f2a9:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f2ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2af:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f2b1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f2b4:	7d 1e                	jge    f010f2d4 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f2b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f2b9:	89 d0                	mov    %edx,%eax
f010f2bb:	01 c0                	add    %eax,%eax
f010f2bd:	01 d0                	add    %edx,%eax
f010f2bf:	c1 e0 02             	shl    $0x2,%eax
f010f2c2:	89 c2                	mov    %eax,%edx
f010f2c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2c7:	01 d0                	add    %edx,%eax
f010f2c9:	8a 40 04             	mov    0x4(%eax),%al
f010f2cc:	0f b6 c0             	movzbl %al,%eax
f010f2cf:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f2d2:	75 d5                	jne    f010f2a9 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f2d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2d7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f2da:	89 10                	mov    %edx,(%eax)
	}
}
f010f2dc:	90                   	nop
f010f2dd:	c9                   	leave  
f010f2de:	c3                   	ret    

f010f2df <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f2df:	55                   	push   %ebp
f010f2e0:	89 e5                	mov    %esp,%ebp
f010f2e2:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f2e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2e8:	c7 00 48 78 12 f0    	movl   $0xf0127848,(%eax)
	info->eip_line = 0;
f010f2ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f2f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2fb:	c7 40 08 48 78 12 f0 	movl   $0xf0127848,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f302:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f305:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f30c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f30f:	8b 55 08             	mov    0x8(%ebp),%edx
f010f312:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f315:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f318:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f31f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f322:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f327:	76 1e                	jbe    f010f347 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f329:	c7 45 f4 dc 15 13 f0 	movl   $0xf01315dc,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f330:	c7 45 f0 e4 4f 16 f0 	movl   $0xf0164fe4,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f337:	c7 45 ec e5 4f 16 f0 	movl   $0xf0164fe5,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f33e:	c7 45 e8 d0 6c 17 f0 	movl   $0xf0176cd0,-0x18(%ebp)
f010f345:	eb 2a                	jmp    f010f371 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f347:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f34e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f351:	8b 00                	mov    (%eax),%eax
f010f353:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f356:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f359:	8b 40 04             	mov    0x4(%eax),%eax
f010f35c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f35f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f362:	8b 40 08             	mov    0x8(%eax),%eax
f010f365:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f368:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f36b:	8b 40 0c             	mov    0xc(%eax),%eax
f010f36e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f371:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f374:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f377:	76 0a                	jbe    f010f383 <debuginfo_eip+0xa4>
f010f379:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f37c:	48                   	dec    %eax
f010f37d:	8a 00                	mov    (%eax),%al
f010f37f:	84 c0                	test   %al,%al
f010f381:	74 0a                	je     f010f38d <debuginfo_eip+0xae>
		return -1;
f010f383:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f388:	e9 01 02 00 00       	jmp    f010f58e <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f38d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f394:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f39a:	29 c2                	sub    %eax,%edx
f010f39c:	89 d0                	mov    %edx,%eax
f010f39e:	c1 f8 02             	sar    $0x2,%eax
f010f3a1:	89 c2                	mov    %eax,%edx
f010f3a3:	89 d0                	mov    %edx,%eax
f010f3a5:	c1 e0 02             	shl    $0x2,%eax
f010f3a8:	01 d0                	add    %edx,%eax
f010f3aa:	c1 e0 02             	shl    $0x2,%eax
f010f3ad:	01 d0                	add    %edx,%eax
f010f3af:	c1 e0 02             	shl    $0x2,%eax
f010f3b2:	01 d0                	add    %edx,%eax
f010f3b4:	89 c1                	mov    %eax,%ecx
f010f3b6:	c1 e1 08             	shl    $0x8,%ecx
f010f3b9:	01 c8                	add    %ecx,%eax
f010f3bb:	89 c1                	mov    %eax,%ecx
f010f3bd:	c1 e1 10             	shl    $0x10,%ecx
f010f3c0:	01 c8                	add    %ecx,%eax
f010f3c2:	01 c0                	add    %eax,%eax
f010f3c4:	01 d0                	add    %edx,%eax
f010f3c6:	48                   	dec    %eax
f010f3c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f3ca:	ff 75 08             	pushl  0x8(%ebp)
f010f3cd:	6a 64                	push   $0x64
f010f3cf:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f3d2:	50                   	push   %eax
f010f3d3:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f3d6:	50                   	push   %eax
f010f3d7:	ff 75 f4             	pushl  -0xc(%ebp)
f010f3da:	e8 b3 fd ff ff       	call   f010f192 <stab_binsearch>
f010f3df:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f3e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f3e5:	85 c0                	test   %eax,%eax
f010f3e7:	75 0a                	jne    f010f3f3 <debuginfo_eip+0x114>
		return -1;
f010f3e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f3ee:	e9 9b 01 00 00       	jmp    f010f58e <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f3f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f3f6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f3f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f3fc:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f3ff:	ff 75 08             	pushl  0x8(%ebp)
f010f402:	6a 24                	push   $0x24
f010f404:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f407:	50                   	push   %eax
f010f408:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f40b:	50                   	push   %eax
f010f40c:	ff 75 f4             	pushl  -0xc(%ebp)
f010f40f:	e8 7e fd ff ff       	call   f010f192 <stab_binsearch>
f010f414:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f417:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f41a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f41d:	39 c2                	cmp    %eax,%edx
f010f41f:	0f 8f 86 00 00 00    	jg     f010f4ab <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f425:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f428:	89 c2                	mov    %eax,%edx
f010f42a:	89 d0                	mov    %edx,%eax
f010f42c:	01 c0                	add    %eax,%eax
f010f42e:	01 d0                	add    %edx,%eax
f010f430:	c1 e0 02             	shl    $0x2,%eax
f010f433:	89 c2                	mov    %eax,%edx
f010f435:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f438:	01 d0                	add    %edx,%eax
f010f43a:	8b 00                	mov    (%eax),%eax
f010f43c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f43f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f442:	29 d1                	sub    %edx,%ecx
f010f444:	89 ca                	mov    %ecx,%edx
f010f446:	39 d0                	cmp    %edx,%eax
f010f448:	73 22                	jae    f010f46c <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f44a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f44d:	89 c2                	mov    %eax,%edx
f010f44f:	89 d0                	mov    %edx,%eax
f010f451:	01 c0                	add    %eax,%eax
f010f453:	01 d0                	add    %edx,%eax
f010f455:	c1 e0 02             	shl    $0x2,%eax
f010f458:	89 c2                	mov    %eax,%edx
f010f45a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f45d:	01 d0                	add    %edx,%eax
f010f45f:	8b 10                	mov    (%eax),%edx
f010f461:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f464:	01 c2                	add    %eax,%edx
f010f466:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f469:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f46c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f46f:	89 c2                	mov    %eax,%edx
f010f471:	89 d0                	mov    %edx,%eax
f010f473:	01 c0                	add    %eax,%eax
f010f475:	01 d0                	add    %edx,%eax
f010f477:	c1 e0 02             	shl    $0x2,%eax
f010f47a:	89 c2                	mov    %eax,%edx
f010f47c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f47f:	01 d0                	add    %edx,%eax
f010f481:	8b 50 08             	mov    0x8(%eax),%edx
f010f484:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f487:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f48a:	8b 55 08             	mov    0x8(%ebp),%edx
f010f48d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f490:	8b 40 10             	mov    0x10(%eax),%eax
f010f493:	29 c2                	sub    %eax,%edx
f010f495:	89 d0                	mov    %edx,%eax
f010f497:	c1 f8 02             	sar    $0x2,%eax
f010f49a:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f49d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f4a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f4a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f4a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f4a9:	eb 15                	jmp    f010f4c0 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f4ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ae:	8b 55 08             	mov    0x8(%ebp),%edx
f010f4b1:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f4b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f4b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f4ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f4bd:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f4c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4c3:	8b 40 08             	mov    0x8(%eax),%eax
f010f4c6:	83 ec 08             	sub    $0x8,%esp
f010f4c9:	6a 3a                	push   $0x3a
f010f4cb:	50                   	push   %eax
f010f4cc:	e8 0d 09 01 00       	call   f011fdde <strfind>
f010f4d1:	83 c4 10             	add    $0x10,%esp
f010f4d4:	89 c2                	mov    %eax,%edx
f010f4d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4d9:	8b 40 08             	mov    0x8(%eax),%eax
f010f4dc:	29 c2                	sub    %eax,%edx
f010f4de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4e1:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f4e4:	eb 03                	jmp    f010f4e9 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f4e6:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f4e9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f4ec:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f4ef:	7c 4e                	jl     f010f53f <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f4f1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f4f4:	89 d0                	mov    %edx,%eax
f010f4f6:	01 c0                	add    %eax,%eax
f010f4f8:	01 d0                	add    %edx,%eax
f010f4fa:	c1 e0 02             	shl    $0x2,%eax
f010f4fd:	89 c2                	mov    %eax,%edx
f010f4ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f502:	01 d0                	add    %edx,%eax
f010f504:	8a 40 04             	mov    0x4(%eax),%al
f010f507:	3c 84                	cmp    $0x84,%al
f010f509:	74 34                	je     f010f53f <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f50b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f50e:	89 d0                	mov    %edx,%eax
f010f510:	01 c0                	add    %eax,%eax
f010f512:	01 d0                	add    %edx,%eax
f010f514:	c1 e0 02             	shl    $0x2,%eax
f010f517:	89 c2                	mov    %eax,%edx
f010f519:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f51c:	01 d0                	add    %edx,%eax
f010f51e:	8a 40 04             	mov    0x4(%eax),%al
f010f521:	3c 64                	cmp    $0x64,%al
f010f523:	75 c1                	jne    f010f4e6 <debuginfo_eip+0x207>
f010f525:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f528:	89 d0                	mov    %edx,%eax
f010f52a:	01 c0                	add    %eax,%eax
f010f52c:	01 d0                	add    %edx,%eax
f010f52e:	c1 e0 02             	shl    $0x2,%eax
f010f531:	89 c2                	mov    %eax,%edx
f010f533:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f536:	01 d0                	add    %edx,%eax
f010f538:	8b 40 08             	mov    0x8(%eax),%eax
f010f53b:	85 c0                	test   %eax,%eax
f010f53d:	74 a7                	je     f010f4e6 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f53f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f542:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f545:	7c 42                	jl     f010f589 <debuginfo_eip+0x2aa>
f010f547:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f54a:	89 d0                	mov    %edx,%eax
f010f54c:	01 c0                	add    %eax,%eax
f010f54e:	01 d0                	add    %edx,%eax
f010f550:	c1 e0 02             	shl    $0x2,%eax
f010f553:	89 c2                	mov    %eax,%edx
f010f555:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f558:	01 d0                	add    %edx,%eax
f010f55a:	8b 00                	mov    (%eax),%eax
f010f55c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f55f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f562:	29 d1                	sub    %edx,%ecx
f010f564:	89 ca                	mov    %ecx,%edx
f010f566:	39 d0                	cmp    %edx,%eax
f010f568:	73 1f                	jae    f010f589 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f56a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f56d:	89 d0                	mov    %edx,%eax
f010f56f:	01 c0                	add    %eax,%eax
f010f571:	01 d0                	add    %edx,%eax
f010f573:	c1 e0 02             	shl    $0x2,%eax
f010f576:	89 c2                	mov    %eax,%edx
f010f578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f57b:	01 d0                	add    %edx,%eax
f010f57d:	8b 10                	mov    (%eax),%edx
f010f57f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f582:	01 c2                	add    %eax,%edx
f010f584:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f587:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f589:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f58e:	c9                   	leave  
f010f58f:	c3                   	ret    

f010f590 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f590:	55                   	push   %ebp
f010f591:	89 e5                	mov    %esp,%ebp
f010f593:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f596:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f59a:	74 1c                	je     f010f5b8 <setPageReplacmentAlgorithmLRU+0x28>
f010f59c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f5a0:	74 16                	je     f010f5b8 <setPageReplacmentAlgorithmLRU+0x28>
f010f5a2:	68 54 78 12 f0       	push   $0xf0127854
f010f5a7:	68 9e 78 12 f0       	push   $0xf012789e
f010f5ac:	6a 1a                	push   $0x1a
f010f5ae:	68 b3 78 12 f0       	push   $0xf01278b3
f010f5b3:	e8 81 0d ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f5b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5bb:	a3 d0 35 ec f0       	mov    %eax,0xf0ec35d0
}
f010f5c0:	90                   	nop
f010f5c1:	c9                   	leave  
f010f5c2:	c3                   	ret    

f010f5c3 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f5c3:	55                   	push   %ebp
f010f5c4:	89 e5                	mov    %esp,%ebp
f010f5c6:	c7 05 d0 35 ec f0 03 	movl   $0x3,0xf0ec35d0
f010f5cd:	00 00 00 
f010f5d0:	90                   	nop
f010f5d1:	5d                   	pop    %ebp
f010f5d2:	c3                   	ret    

f010f5d3 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f5d3:	55                   	push   %ebp
f010f5d4:	89 e5                	mov    %esp,%ebp
f010f5d6:	c7 05 d0 35 ec f0 04 	movl   $0x4,0xf0ec35d0
f010f5dd:	00 00 00 
f010f5e0:	90                   	nop
f010f5e1:	5d                   	pop    %ebp
f010f5e2:	c3                   	ret    

f010f5e3 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f5e3:	55                   	push   %ebp
f010f5e4:	89 e5                	mov    %esp,%ebp
f010f5e6:	c7 05 d0 35 ec f0 05 	movl   $0x5,0xf0ec35d0
f010f5ed:	00 00 00 
f010f5f0:	90                   	nop
f010f5f1:	5d                   	pop    %ebp
f010f5f2:	c3                   	ret    

f010f5f3 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f5f3:	55                   	push   %ebp
f010f5f4:	89 e5                	mov    %esp,%ebp
f010f5f6:	c7 05 d0 35 ec f0 07 	movl   $0x7,0xf0ec35d0
f010f5fd:	00 00 00 
f010f600:	90                   	nop
f010f601:	5d                   	pop    %ebp
f010f602:	c3                   	ret    

f010f603 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f603:	55                   	push   %ebp
f010f604:	89 e5                	mov    %esp,%ebp
f010f606:	c7 05 d0 35 ec f0 06 	movl   $0x6,0xf0ec35d0
f010f60d:	00 00 00 
f010f610:	8b 45 08             	mov    0x8(%ebp),%eax
f010f613:	a3 f4 2e 6c f0       	mov    %eax,0xf06c2ef4
f010f618:	90                   	nop
f010f619:	5d                   	pop    %ebp
f010f61a:	c3                   	ret    

f010f61b <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f61b:	55                   	push   %ebp
f010f61c:	89 e5                	mov    %esp,%ebp
f010f61e:	8b 15 d0 35 ec f0    	mov    0xf0ec35d0,%edx
f010f624:	8b 45 08             	mov    0x8(%ebp),%eax
f010f627:	39 c2                	cmp    %eax,%edx
f010f629:	0f 94 c0             	sete   %al
f010f62c:	0f b6 c0             	movzbl %al,%eax
f010f62f:	5d                   	pop    %ebp
f010f630:	c3                   	ret    

f010f631 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f631:	55                   	push   %ebp
f010f632:	89 e5                	mov    %esp,%ebp
f010f634:	a1 d0 35 ec f0       	mov    0xf0ec35d0,%eax
f010f639:	83 f8 03             	cmp    $0x3,%eax
f010f63c:	75 07                	jne    f010f645 <isPageReplacmentAlgorithmCLOCK+0x14>
f010f63e:	b8 01 00 00 00       	mov    $0x1,%eax
f010f643:	eb 05                	jmp    f010f64a <isPageReplacmentAlgorithmCLOCK+0x19>
f010f645:	b8 00 00 00 00       	mov    $0x0,%eax
f010f64a:	5d                   	pop    %ebp
f010f64b:	c3                   	ret    

f010f64c <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f64c:	55                   	push   %ebp
f010f64d:	89 e5                	mov    %esp,%ebp
f010f64f:	a1 d0 35 ec f0       	mov    0xf0ec35d0,%eax
f010f654:	83 f8 04             	cmp    $0x4,%eax
f010f657:	75 07                	jne    f010f660 <isPageReplacmentAlgorithmFIFO+0x14>
f010f659:	b8 01 00 00 00       	mov    $0x1,%eax
f010f65e:	eb 05                	jmp    f010f665 <isPageReplacmentAlgorithmFIFO+0x19>
f010f660:	b8 00 00 00 00       	mov    $0x0,%eax
f010f665:	5d                   	pop    %ebp
f010f666:	c3                   	ret    

f010f667 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f667:	55                   	push   %ebp
f010f668:	89 e5                	mov    %esp,%ebp
f010f66a:	a1 d0 35 ec f0       	mov    0xf0ec35d0,%eax
f010f66f:	83 f8 05             	cmp    $0x5,%eax
f010f672:	75 07                	jne    f010f67b <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f674:	b8 01 00 00 00       	mov    $0x1,%eax
f010f679:	eb 05                	jmp    f010f680 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f67b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f680:	5d                   	pop    %ebp
f010f681:	c3                   	ret    

f010f682 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f682:	55                   	push   %ebp
f010f683:	89 e5                	mov    %esp,%ebp
f010f685:	a1 d0 35 ec f0       	mov    0xf0ec35d0,%eax
f010f68a:	83 f8 07             	cmp    $0x7,%eax
f010f68d:	75 07                	jne    f010f696 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f68f:	b8 01 00 00 00       	mov    $0x1,%eax
f010f694:	eb 05                	jmp    f010f69b <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f696:	b8 00 00 00 00       	mov    $0x0,%eax
f010f69b:	5d                   	pop    %ebp
f010f69c:	c3                   	ret    

f010f69d <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f69d:	55                   	push   %ebp
f010f69e:	89 e5                	mov    %esp,%ebp
f010f6a0:	a1 d0 35 ec f0       	mov    0xf0ec35d0,%eax
f010f6a5:	83 f8 06             	cmp    $0x6,%eax
f010f6a8:	75 07                	jne    f010f6b1 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f6aa:	b8 01 00 00 00       	mov    $0x1,%eax
f010f6af:	eb 05                	jmp    f010f6b6 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f6b1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6b6:	5d                   	pop    %ebp
f010f6b7:	c3                   	ret    

f010f6b8 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f6b8:	55                   	push   %ebp
f010f6b9:	89 e5                	mov    %esp,%ebp
f010f6bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6be:	a3 58 33 ac f0       	mov    %eax,0xf0ac3358
f010f6c3:	90                   	nop
f010f6c4:	5d                   	pop    %ebp
f010f6c5:	c3                   	ret    

f010f6c6 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f6c6:	55                   	push   %ebp
f010f6c7:	89 e5                	mov    %esp,%ebp
f010f6c9:	a1 58 33 ac f0       	mov    0xf0ac3358,%eax
f010f6ce:	5d                   	pop    %ebp
f010f6cf:	c3                   	ret    

f010f6d0 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f6d0:	55                   	push   %ebp
f010f6d1:	89 e5                	mov    %esp,%ebp
f010f6d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6d6:	a3 54 36 ec f0       	mov    %eax,0xf0ec3654
f010f6db:	90                   	nop
f010f6dc:	5d                   	pop    %ebp
f010f6dd:	c3                   	ret    

f010f6de <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f6de:	55                   	push   %ebp
f010f6df:	89 e5                	mov    %esp,%ebp
f010f6e1:	a1 54 36 ec f0       	mov    0xf0ec3654,%eax
f010f6e6:	5d                   	pop    %ebp
f010f6e7:	c3                   	ret    

f010f6e8 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f6e8:	55                   	push   %ebp
f010f6e9:	89 e5                	mov    %esp,%ebp
f010f6eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6ee:	a3 f0 36 ec f0       	mov    %eax,0xf0ec36f0
f010f6f3:	90                   	nop
f010f6f4:	5d                   	pop    %ebp
f010f6f5:	c3                   	ret    

f010f6f6 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f6f6:	55                   	push   %ebp
f010f6f7:	89 e5                	mov    %esp,%ebp
f010f6f9:	a1 f0 36 ec f0       	mov    0xf0ec36f0,%eax
f010f6fe:	5d                   	pop    %ebp
f010f6ff:	c3                   	ret    

f010f700 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f700:	55                   	push   %ebp
f010f701:	89 e5                	mov    %esp,%ebp
f010f703:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f706:	0f 20 d0             	mov    %cr2,%eax
f010f709:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f70c:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f70f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f712:	e8 c9 c2 ff ff       	call   f010b9e0 <get_cpu_proc>
f010f717:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f71a:	a1 ec ab 69 f0       	mov    0xf069abec,%eax
f010f71f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f722:	75 50                	jne    f010f774 <fault_handler+0x74>
f010f724:	a1 f8 ab 69 f0       	mov    0xf069abf8,%eax
f010f729:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f72c:	75 46                	jne    f010f774 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f72e:	a0 f4 ab 69 f0       	mov    0xf069abf4,%al
f010f733:	40                   	inc    %eax
f010f734:	a2 f4 ab 69 f0       	mov    %al,0xf069abf4
		if (num_repeated_fault == 3)
f010f739:	a0 f4 ab 69 f0       	mov    0xf069abf4,%al
f010f73e:	3c 03                	cmp    $0x3,%al
f010f740:	75 4d                	jne    f010f78f <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f742:	83 ec 0c             	sub    $0xc,%esp
f010f745:	ff 75 08             	pushl  0x8(%ebp)
f010f748:	e8 49 e9 ff ff       	call   f010e096 <print_trapframe>
f010f74d:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f750:	8b 15 e8 ab 69 f0    	mov    0xf069abe8,%edx
f010f756:	a1 f0 ab 69 f0       	mov    0xf069abf0,%eax
f010f75b:	83 ec 08             	sub    $0x8,%esp
f010f75e:	ff 75 ec             	pushl  -0x14(%ebp)
f010f761:	52                   	push   %edx
f010f762:	50                   	push   %eax
f010f763:	68 d0 78 12 f0       	push   $0xf01278d0
f010f768:	6a 58                	push   $0x58
f010f76a:	68 b3 78 12 f0       	push   $0xf01278b3
f010f76f:	e8 c5 0b ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f774:	a1 ec ab 69 f0       	mov    0xf069abec,%eax
f010f779:	a3 f0 ab 69 f0       	mov    %eax,0xf069abf0
		before_last_eip = last_eip;
f010f77e:	a1 e4 ab 69 f0       	mov    0xf069abe4,%eax
f010f783:	a3 e8 ab 69 f0       	mov    %eax,0xf069abe8
		num_repeated_fault = 0;
f010f788:	c6 05 f4 ab 69 f0 00 	movb   $0x0,0xf069abf4
	}
	last_eip = (uint32)tf->tf_eip;
f010f78f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f792:	8b 40 30             	mov    0x30(%eax),%eax
f010f795:	a3 e4 ab 69 f0       	mov    %eax,0xf069abe4
	last_fault_va = fault_va ;
f010f79a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f79d:	a3 ec ab 69 f0       	mov    %eax,0xf069abec
	last_faulted_env = cur_env;
f010f7a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f7a5:	a3 f8 ab 69 f0       	mov    %eax,0xf069abf8
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f7aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f7b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7b4:	8b 40 34             	mov    0x34(%eax),%eax
f010f7b7:	0f b7 c0             	movzwl %ax,%eax
f010f7ba:	83 e0 03             	and    $0x3,%eax
f010f7bd:	83 f8 03             	cmp    $0x3,%eax
f010f7c0:	75 07                	jne    f010f7c9 <fault_handler+0xc9>
		userTrap = 1;
f010f7c2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f7c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f7cd:	0f 85 c2 00 00 00    	jne    f010f895 <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f7d3:	e8 34 79 ff ff       	call   f010710c <mycpu>
f010f7d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f7db:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f7df:	74 2f                	je     f010f810 <fault_handler+0x110>
f010f7e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f7e4:	8b 40 70             	mov    0x70(%eax),%eax
f010f7e7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f7ea:	77 24                	ja     f010f810 <fault_handler+0x110>
f010f7ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f7ef:	8b 40 70             	mov    0x70(%eax),%eax
f010f7f2:	05 00 10 00 00       	add    $0x1000,%eax
f010f7f7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f7fa:	76 14                	jbe    f010f810 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f7fc:	83 ec 04             	sub    $0x4,%esp
f010f7ff:	68 40 79 12 f0       	push   $0xf0127940
f010f804:	6a 6f                	push   $0x6f
f010f806:	68 b3 78 12 f0       	push   $0xf01278b3
f010f80b:	e8 29 0b ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f810:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f813:	8b 40 08             	mov    0x8(%eax),%eax
f010f816:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f819:	77 5d                	ja     f010f878 <fault_handler+0x178>
f010f81b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f81e:	8b 40 08             	mov    0x8(%eax),%eax
f010f821:	05 00 10 00 00       	add    $0x1000,%eax
f010f826:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f829:	76 4d                	jbe    f010f878 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f82b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f82e:	ba 40 30 ac f0       	mov    $0xf0ac3040,%edx
f010f833:	29 d0                	sub    %edx,%eax
f010f835:	c1 f8 03             	sar    $0x3,%eax
f010f838:	89 c2                	mov    %eax,%edx
f010f83a:	89 d0                	mov    %edx,%eax
f010f83c:	c1 e0 02             	shl    $0x2,%eax
f010f83f:	01 d0                	add    %edx,%eax
f010f841:	01 c0                	add    %eax,%eax
f010f843:	01 d0                	add    %edx,%eax
f010f845:	c1 e0 03             	shl    $0x3,%eax
f010f848:	01 d0                	add    %edx,%eax
f010f84a:	89 c1                	mov    %eax,%ecx
f010f84c:	c1 e1 0b             	shl    $0xb,%ecx
f010f84f:	01 c8                	add    %ecx,%eax
f010f851:	c1 e0 05             	shl    $0x5,%eax
f010f854:	01 d0                	add    %edx,%eax
f010f856:	c1 e0 02             	shl    $0x2,%eax
f010f859:	01 d0                	add    %edx,%eax
f010f85b:	01 c0                	add    %eax,%eax
f010f85d:	01 d0                	add    %edx,%eax
f010f85f:	c1 e0 03             	shl    $0x3,%eax
f010f862:	01 d0                	add    %edx,%eax
f010f864:	f7 d8                	neg    %eax
f010f866:	50                   	push   %eax
f010f867:	68 68 79 12 f0       	push   $0xf0127968
f010f86c:	6a 71                	push   $0x71
f010f86e:	68 b3 78 12 f0       	push   $0xf01278b3
f010f873:	e8 c1 0a ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f878:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f87f:	76 3a                	jbe    f010f8bb <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f881:	83 ec 04             	sub    $0x4,%esp
f010f884:	68 9c 79 12 f0       	push   $0xf012799c
f010f889:	6a 74                	push   $0x74
f010f88b:	68 b3 78 12 f0       	push   $0xf01278b3
f010f890:	e8 a4 0a ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f895:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f89c:	76 1d                	jbe    f010f8bb <fault_handler+0x1bb>
f010f89e:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f8a5:	77 14                	ja     f010f8bb <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f8a7:	83 ec 04             	sub    $0x4,%esp
f010f8aa:	68 c0 79 12 f0       	push   $0xf01279c0
f010f8af:	6a 7c                	push   $0x7c
f010f8b1:	68 b3 78 12 f0       	push   $0xf01278b3
f010f8b6:	e8 7e 0a ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f8bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f8be:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f8c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f8c5:	75 25                	jne    f010f8ec <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f8c7:	83 ec 0c             	sub    $0xc,%esp
f010f8ca:	ff 75 08             	pushl  0x8(%ebp)
f010f8cd:	e8 c4 e7 ff ff       	call   f010e096 <print_trapframe>
f010f8d2:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f8d5:	83 ec 04             	sub    $0x4,%esp
f010f8d8:	68 e1 79 12 f0       	push   $0xf01279e1
f010f8dd:	68 85 00 00 00       	push   $0x85
f010f8e2:	68 b3 78 12 f0       	push   $0xf01278b3
f010f8e7:	e8 4d 0a ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f8ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f8ef:	8b 40 64             	mov    0x64(%eax),%eax
f010f8f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f8f5:	c1 ea 16             	shr    $0x16,%edx
f010f8f8:	c1 e2 02             	shl    $0x2,%edx
f010f8fb:	01 d0                	add    %edx,%eax
f010f8fd:	8b 00                	mov    (%eax),%eax
f010f8ff:	83 e0 01             	and    $0x1,%eax
f010f902:	85 c0                	test   %eax,%eax
f010f904:	75 2b                	jne    f010f931 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f906:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f909:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f90f:	8d 50 01             	lea    0x1(%eax),%edx
f010f912:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f915:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f91b:	83 ec 08             	sub    $0x8,%esp
f010f91e:	ff 75 ec             	pushl  -0x14(%ebp)
f010f921:	ff 75 e0             	pushl  -0x20(%ebp)
f010f924:	e8 1e 01 00 00       	call   f010fa47 <table_fault_handler>
f010f929:	83 c4 10             	add    $0x10,%esp
f010f92c:	e9 07 01 00 00       	jmp    f010fa38 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010f931:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f935:	0f 84 82 00 00 00    	je     f010f9bd <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f93b:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f942:	76 07                	jbe    f010f94b <fault_handler+0x24b>
			{
				env_exit();
f010f944:	e8 55 c0 ff ff       	call   f010b99e <env_exit>
f010f949:	eb 72                	jmp    f010f9bd <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010f94b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f94e:	8b 40 64             	mov    0x64(%eax),%eax
f010f951:	83 ec 08             	sub    $0x8,%esp
f010f954:	ff 75 ec             	pushl  -0x14(%ebp)
f010f957:	50                   	push   %eax
f010f958:	e8 cb a3 ff ff       	call   f0109d28 <pt_get_page_permissions>
f010f95d:	83 c4 10             	add    $0x10,%esp
f010f960:	25 00 02 00 00       	and    $0x200,%eax
f010f965:	85 c0                	test   %eax,%eax
f010f967:	75 17                	jne    f010f980 <fault_handler+0x280>
f010f969:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f96c:	85 c0                	test   %eax,%eax
f010f96e:	79 10                	jns    f010f980 <fault_handler+0x280>
f010f970:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010f977:	77 07                	ja     f010f980 <fault_handler+0x280>
			{
				env_exit();
f010f979:	e8 20 c0 ff ff       	call   f010b99e <env_exit>
f010f97e:	eb 3d                	jmp    f010f9bd <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (!(pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010f980:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f983:	8b 40 64             	mov    0x64(%eax),%eax
f010f986:	83 ec 08             	sub    $0x8,%esp
f010f989:	ff 75 ec             	pushl  -0x14(%ebp)
f010f98c:	50                   	push   %eax
f010f98d:	e8 96 a3 ff ff       	call   f0109d28 <pt_get_page_permissions>
f010f992:	83 c4 10             	add    $0x10,%esp
f010f995:	83 e0 01             	and    $0x1,%eax
f010f998:	85 c0                	test   %eax,%eax
f010f99a:	74 21                	je     f010f9bd <fault_handler+0x2bd>
f010f99c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f99f:	8b 40 64             	mov    0x64(%eax),%eax
f010f9a2:	83 ec 08             	sub    $0x8,%esp
f010f9a5:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9a8:	50                   	push   %eax
f010f9a9:	e8 7a a3 ff ff       	call   f0109d28 <pt_get_page_permissions>
f010f9ae:	83 c4 10             	add    $0x10,%esp
f010f9b1:	83 e0 02             	and    $0x2,%eax
f010f9b4:	85 c0                	test   %eax,%eax
f010f9b6:	75 05                	jne    f010f9bd <fault_handler+0x2bd>
			{
				env_exit();
f010f9b8:	e8 e1 bf ff ff       	call   f010b99e <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010f9bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9c0:	8b 40 64             	mov    0x64(%eax),%eax
f010f9c3:	83 ec 08             	sub    $0x8,%esp
f010f9c6:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9c9:	50                   	push   %eax
f010f9ca:	e8 59 a3 ff ff       	call   f0109d28 <pt_get_page_permissions>
f010f9cf:	83 c4 10             	add    $0x10,%esp
f010f9d2:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010f9d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f9d8:	83 e0 01             	and    $0x1,%eax
f010f9db:	85 c0                	test   %eax,%eax
f010f9dd:	74 17                	je     f010f9f6 <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010f9df:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9e2:	68 f8 79 12 f0       	push   $0xf01279f8
f010f9e7:	68 ad 00 00 00       	push   $0xad
f010f9ec:	68 b3 78 12 f0       	push   $0xf01278b3
f010f9f1:	e8 43 09 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010f9f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9f9:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010f9ff:	8d 50 01             	lea    0x1(%eax),%edx
f010fa02:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa05:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010fa0b:	e8 ce fc ff ff       	call   f010f6de <isBufferingEnabled>
f010fa10:	84 c0                	test   %al,%al
f010fa12:	74 13                	je     f010fa27 <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fa14:	83 ec 08             	sub    $0x8,%esp
f010fa17:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa1a:	ff 75 e0             	pushl  -0x20(%ebp)
f010fa1d:	e8 fe 01 00 00       	call   f010fc20 <__page_fault_handler_with_buffering>
f010fa22:	83 c4 10             	add    $0x10,%esp
f010fa25:	eb 11                	jmp    f010fa38 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010fa27:	83 ec 08             	sub    $0x8,%esp
f010fa2a:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa2d:	ff 75 e0             	pushl  -0x20(%ebp)
f010fa30:	e8 33 00 00 00       	call   f010fa68 <page_fault_handler>
f010fa35:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fa38:	0f 20 d8             	mov    %cr3,%eax
f010fa3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fa3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fa41:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fa44:	90                   	nop
f010fa45:	c9                   	leave  
f010fa46:	c3                   	ret    

f010fa47 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fa47:	55                   	push   %ebp
f010fa48:	89 e5                	mov    %esp,%ebp
f010fa4a:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fa4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa50:	8b 40 64             	mov    0x64(%eax),%eax
f010fa53:	83 ec 08             	sub    $0x8,%esp
f010fa56:	ff 75 0c             	pushl  0xc(%ebp)
f010fa59:	50                   	push   %eax
f010fa5a:	e8 e6 8a ff ff       	call   f0108545 <create_page_table>
f010fa5f:	83 c4 10             	add    $0x10,%esp
f010fa62:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fa65:	90                   	nop
f010fa66:	c9                   	leave  
f010fa67:	c3                   	ret    

f010fa68 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fa68:	55                   	push   %ebp
f010fa69:	89 e5                	mov    %esp,%ebp
f010fa6b:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fa6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fa75:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa78:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fa7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fa81:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa84:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fa8a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fa8d:	0f 86 74 01 00 00    	jbe    f010fc07 <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010fa93:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa96:	83 ec 08             	sub    $0x8,%esp
f010fa99:	50                   	push   %eax
f010fa9a:	ff 75 08             	pushl  0x8(%ebp)
f010fa9d:	e8 3f 4a ff ff       	call   f01044e1 <pf_read_env_page>
f010faa2:	83 c4 10             	add    $0x10,%esp
f010faa5:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010faa8:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010faac:	75 45                	jne    f010faf3 <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010faae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fab1:	85 c0                	test   %eax,%eax
f010fab3:	79 09                	jns    f010fabe <page_fault_handler+0x56>
f010fab5:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fabc:	76 35                	jbe    f010faf3 <page_fault_handler+0x8b>
f010fabe:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fac5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fac8:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010facd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fad3:	ba 00 00 00 00       	mov    $0x0,%edx
f010fad8:	f7 75 e8             	divl   -0x18(%ebp)
f010fadb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fade:	29 d0                	sub    %edx,%eax
f010fae0:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fae3:	77 09                	ja     f010faee <page_fault_handler+0x86>
f010fae5:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010faec:	76 05                	jbe    f010faf3 <page_fault_handler+0x8b>
			{
				env_exit();
f010faee:	e8 ab be ff ff       	call   f010b99e <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010faf3:	83 ec 0c             	sub    $0xc,%esp
f010faf6:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010faf9:	50                   	push   %eax
f010fafa:	e8 b3 86 ff ff       	call   f01081b2 <allocate_frame>
f010faff:	83 c4 10             	add    $0x10,%esp
f010fb02:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010fb05:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010fb09:	74 34                	je     f010fb3f <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010fb0b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010fb0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb11:	8b 40 64             	mov    0x64(%eax),%eax
f010fb14:	6a 06                	push   $0x6
f010fb16:	ff 75 0c             	pushl  0xc(%ebp)
f010fb19:	52                   	push   %edx
f010fb1a:	50                   	push   %eax
f010fb1b:	e8 5f 8b ff ff       	call   f010867f <map_frame>
f010fb20:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010fb23:	83 ec 08             	sub    $0x8,%esp
f010fb26:	ff 75 0c             	pushl  0xc(%ebp)
f010fb29:	ff 75 08             	pushl  0x8(%ebp)
f010fb2c:	e8 69 a3 ff ff       	call   f0109e9a <env_page_ws_list_create_element>
f010fb31:	83 c4 10             	add    $0x10,%esp
f010fb34:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fb37:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010fb3b:	75 30                	jne    f010fb6d <page_fault_handler+0x105>
f010fb3d:	eb 17                	jmp    f010fb56 <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010fb3f:	83 ec 04             	sub    $0x4,%esp
f010fb42:	68 3c 7a 12 f0       	push   $0xf0127a3c
f010fb47:	68 03 01 00 00       	push   $0x103
f010fb4c:	68 b3 78 12 f0       	push   $0xf01278b3
f010fb51:	e8 e3 07 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fb56:	83 ec 04             	sub    $0x4,%esp
f010fb59:	68 54 7a 12 f0       	push   $0xf0127a54
f010fb5e:	68 05 01 00 00       	push   $0x105
f010fb63:	68 b3 78 12 f0       	push   $0xf01278b3
f010fb68:	e8 cc 07 ff ff       	call   f0100339 <_panic>
f010fb6d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb70:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010fb76:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb79:	89 50 14             	mov    %edx,0x14(%eax)
f010fb7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb7f:	8b 40 14             	mov    0x14(%eax),%eax
f010fb82:	85 c0                	test   %eax,%eax
f010fb84:	74 11                	je     f010fb97 <page_fault_handler+0x12f>
f010fb86:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb89:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fb8f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fb92:	89 50 10             	mov    %edx,0x10(%eax)
f010fb95:	eb 0c                	jmp    f010fba3 <page_fault_handler+0x13b>
f010fb97:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb9a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fb9d:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010fba3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fba6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fba9:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010fbaf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbb2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010fbb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbbc:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fbc2:	8d 50 01             	lea    0x1(%eax),%edx
f010fbc5:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbc8:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010fbce:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbd1:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010fbd7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbda:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fbe0:	39 c2                	cmp    %eax,%edx
f010fbe2:	75 14                	jne    f010fbf8 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010fbe4:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbe7:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010fbed:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbf0:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fbf6:	eb 26                	jmp    f010fc1e <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010fbf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbfb:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010fc02:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fc05:	eb 17                	jmp    f010fc1e <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010fc07:	83 ec 04             	sub    $0x4,%esp
f010fc0a:	68 78 7a 12 f0       	push   $0xf0127a78
f010fc0f:	68 15 01 00 00       	push   $0x115
f010fc14:	68 b3 78 12 f0       	push   $0xf01278b3
f010fc19:	e8 1b 07 ff ff       	call   f0100339 <_panic>
	}
}
f010fc1e:	c9                   	leave  
f010fc1f:	c3                   	ret    

f010fc20 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fc20:	55                   	push   %ebp
f010fc21:	89 e5                	mov    %esp,%ebp
f010fc23:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010fc26:	83 ec 04             	sub    $0x4,%esp
f010fc29:	68 b8 7a 12 f0       	push   $0xf0127ab8
f010fc2e:	68 1d 01 00 00       	push   $0x11d
f010fc33:	68 b3 78 12 f0       	push   $0xf01278b3
f010fc38:	e8 fc 06 ff ff       	call   f0100339 <_panic>

f010fc3d <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010fc3d:	55                   	push   %ebp
f010fc3e:	89 e5                	mov    %esp,%ebp
f010fc40:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fc43:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc46:	83 c0 04             	add    $0x4,%eax
f010fc49:	83 ec 08             	sub    $0x8,%esp
f010fc4c:	ff 75 0c             	pushl  0xc(%ebp)
f010fc4f:	50                   	push   %eax
f010fc50:	e8 16 00 01 00       	call   f011fc6b <strcpy>
f010fc55:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fc58:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fc61:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc64:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fc6b:	90                   	nop
f010fc6c:	c9                   	leave  
f010fc6d:	c3                   	ret    

f010fc6e <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010fc6e:	55                   	push   %ebp
f010fc6f:	89 e5                	mov    %esp,%ebp
f010fc71:	53                   	push   %ebx
f010fc72:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010fc75:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc78:	83 ec 0c             	sub    $0xc,%esp
f010fc7b:	50                   	push   %eax
f010fc7c:	e8 06 02 00 00       	call   f010fe87 <holding_spinlock>
f010fc81:	83 c4 10             	add    $0x10,%esp
f010fc84:	85 c0                	test   %eax,%eax
f010fc86:	74 18                	je     f010fca0 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fc88:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc8b:	83 c0 04             	add    $0x4,%eax
f010fc8e:	50                   	push   %eax
f010fc8f:	68 fc 7a 12 f0       	push   $0xf0127afc
f010fc94:	6a 1f                	push   $0x1f
f010fc96:	68 39 7b 12 f0       	push   $0xf0127b39
f010fc9b:	e8 99 06 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010fca0:	e8 2a 75 ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fca5:	90                   	nop
f010fca6:	8b 45 08             	mov    0x8(%ebp),%eax
f010fca9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010fcac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fcb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fcb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fcb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010fcbc:	f0 87 02             	lock xchg %eax,(%edx)
f010fcbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010fcc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fcc5:	85 c0                	test   %eax,%eax
f010fcc7:	75 dd                	jne    f010fca6 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fcc9:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fcce:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fcd1:	e8 36 74 ff ff       	call   f010710c <mycpu>
f010fcd6:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010fcd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcdc:	83 c0 48             	add    $0x48,%eax
f010fcdf:	83 ec 08             	sub    $0x8,%esp
f010fce2:	50                   	push   %eax
f010fce3:	8d 45 08             	lea    0x8(%ebp),%eax
f010fce6:	50                   	push   %eax
f010fce7:	e8 74 00 00 00       	call   f010fd60 <getcallerpcs>
f010fcec:	83 c4 10             	add    $0x10,%esp

}
f010fcef:	90                   	nop
f010fcf0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fcf3:	c9                   	leave  
f010fcf4:	c3                   	ret    

f010fcf5 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010fcf5:	55                   	push   %ebp
f010fcf6:	89 e5                	mov    %esp,%ebp
f010fcf8:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010fcfb:	83 ec 0c             	sub    $0xc,%esp
f010fcfe:	ff 75 08             	pushl  0x8(%ebp)
f010fd01:	e8 81 01 00 00       	call   f010fe87 <holding_spinlock>
f010fd06:	83 c4 10             	add    $0x10,%esp
f010fd09:	85 c0                	test   %eax,%eax
f010fd0b:	75 26                	jne    f010fd33 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010fd0d:	83 ec 0c             	sub    $0xc,%esp
f010fd10:	ff 75 08             	pushl  0x8(%ebp)
f010fd13:	e8 08 01 00 00       	call   f010fe20 <printcallstack>
f010fd18:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010fd1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd1e:	83 c0 04             	add    $0x4,%eax
f010fd21:	50                   	push   %eax
f010fd22:	68 50 7b 12 f0       	push   $0xf0127b50
f010fd27:	6a 3c                	push   $0x3c
f010fd29:	68 39 7b 12 f0       	push   $0xf0127b39
f010fd2e:	e8 06 06 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010fd33:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd36:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010fd3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd40:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010fd47:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010fd4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd4f:	8b 55 08             	mov    0x8(%ebp),%edx
f010fd52:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010fd58:	e8 c4 74 ff ff       	call   f0107221 <popcli>
}
f010fd5d:	90                   	nop
f010fd5e:	c9                   	leave  
f010fd5f:	c3                   	ret    

f010fd60 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010fd60:	55                   	push   %ebp
f010fd61:	89 e5                	mov    %esp,%ebp
f010fd63:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010fd66:	e8 75 bc ff ff       	call   f010b9e0 <get_cpu_proc>
f010fd6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010fd6e:	e8 99 73 ff ff       	call   f010710c <mycpu>
f010fd73:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010fd76:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd79:	83 e8 08             	sub    $0x8,%eax
f010fd7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010fd7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010fd86:	eb 67                	jmp    f010fdef <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fd88:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fd8c:	74 67                	je     f010fdf5 <getcallerpcs+0x95>
f010fd8e:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010fd95:	76 5e                	jbe    f010fdf5 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fd97:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fd9a:	8b 40 08             	mov    0x8(%eax),%eax
f010fd9d:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fda2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fda5:	77 10                	ja     f010fdb7 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fda7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fdaa:	8b 40 08             	mov    0x8(%eax),%eax
f010fdad:	05 00 90 00 00       	add    $0x9000,%eax
f010fdb2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fdb5:	77 3e                	ja     f010fdf5 <getcallerpcs+0x95>
f010fdb7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fdbb:	74 10                	je     f010fdcd <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010fdbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fdc0:	8b 40 70             	mov    0x70(%eax),%eax
f010fdc3:	05 00 80 00 00       	add    $0x8000,%eax
f010fdc8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fdcb:	76 28                	jbe    f010fdf5 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010fdcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fdd0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fdd7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fdda:	01 c2                	add    %eax,%edx
f010fddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fddf:	8b 40 04             	mov    0x4(%eax),%eax
f010fde2:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010fde4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fde7:	8b 00                	mov    (%eax),%eax
f010fde9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010fdec:	ff 45 f0             	incl   -0x10(%ebp)
f010fdef:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fdf3:	7e 93                	jle    f010fd88 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010fdf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fdf8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010fdfb:	eb 18                	jmp    f010fe15 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010fdfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe00:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fe07:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe0a:	01 d0                	add    %edx,%eax
f010fe0c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010fe12:	ff 45 f0             	incl   -0x10(%ebp)
f010fe15:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fe19:	7e e2                	jle    f010fdfd <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010fe1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010fe1e:	c9                   	leave  
f010fe1f:	c3                   	ret    

f010fe20 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010fe20:	55                   	push   %ebp
f010fe21:	89 e5                	mov    %esp,%ebp
f010fe23:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010fe26:	83 ec 0c             	sub    $0xc,%esp
f010fe29:	68 8e 7b 12 f0       	push   $0xf0127b8e
f010fe2e:	e8 58 11 ff ff       	call   f0100f8b <cprintf>
f010fe33:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010fe36:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe39:	83 c0 48             	add    $0x48,%eax
f010fe3c:	83 ec 08             	sub    $0x8,%esp
f010fe3f:	50                   	push   %eax
f010fe40:	8d 45 08             	lea    0x8(%ebp),%eax
f010fe43:	50                   	push   %eax
f010fe44:	e8 17 ff ff ff       	call   f010fd60 <getcallerpcs>
f010fe49:	83 c4 10             	add    $0x10,%esp
f010fe4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010fe4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fe56:	eb 24                	jmp    f010fe7c <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010fe58:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fe5e:	83 c2 10             	add    $0x10,%edx
f010fe61:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010fe65:	83 ec 04             	sub    $0x4,%esp
f010fe68:	50                   	push   %eax
f010fe69:	ff 75 f4             	pushl  -0xc(%ebp)
f010fe6c:	68 9e 7b 12 f0       	push   $0xf0127b9e
f010fe71:	e8 15 11 ff ff       	call   f0100f8b <cprintf>
f010fe76:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010fe79:	ff 45 f4             	incl   -0xc(%ebp)
f010fe7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe7f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fe82:	7c d4                	jl     f010fe58 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010fe84:	90                   	nop
f010fe85:	c9                   	leave  
f010fe86:	c3                   	ret    

f010fe87 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010fe87:	55                   	push   %ebp
f010fe88:	89 e5                	mov    %esp,%ebp
f010fe8a:	53                   	push   %ebx
f010fe8b:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010fe8e:	e8 3c 73 ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010fe93:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe96:	8b 00                	mov    (%eax),%eax
f010fe98:	85 c0                	test   %eax,%eax
f010fe9a:	74 16                	je     f010feb2 <holding_spinlock+0x2b>
f010fe9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe9f:	8b 58 44             	mov    0x44(%eax),%ebx
f010fea2:	e8 65 72 ff ff       	call   f010710c <mycpu>
f010fea7:	39 c3                	cmp    %eax,%ebx
f010fea9:	75 07                	jne    f010feb2 <holding_spinlock+0x2b>
f010feab:	b8 01 00 00 00       	mov    $0x1,%eax
f010feb0:	eb 05                	jmp    f010feb7 <holding_spinlock+0x30>
f010feb2:	b8 00 00 00 00       	mov    $0x0,%eax
f010feb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010feba:	e8 62 73 ff ff       	call   f0107221 <popcli>
	return r;
f010febf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010fec2:	83 c4 14             	add    $0x14,%esp
f010fec5:	5b                   	pop    %ebx
f010fec6:	5d                   	pop    %ebp
f010fec7:	c3                   	ret    

f010fec8 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010fec8:	55                   	push   %ebp
f010fec9:	89 e5                	mov    %esp,%ebp
f010fecb:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010fece:	8b 45 08             	mov    0x8(%ebp),%eax
f010fed1:	83 c0 74             	add    $0x74,%eax
f010fed4:	83 ec 08             	sub    $0x8,%esp
f010fed7:	68 ad 7b 12 f0       	push   $0xf0127bad
f010fedc:	50                   	push   %eax
f010fedd:	e8 4c 01 00 00       	call   f011002e <init_channel>
f010fee2:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010fee5:	8b 45 08             	mov    0x8(%ebp),%eax
f010fee8:	83 c0 04             	add    $0x4,%eax
f010feeb:	83 ec 08             	sub    $0x8,%esp
f010feee:	68 c0 7b 12 f0       	push   $0xf0127bc0
f010fef3:	50                   	push   %eax
f010fef4:	e8 44 fd ff ff       	call   f010fc3d <init_spinlock>
f010fef9:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010fefc:	8b 45 08             	mov    0x8(%ebp),%eax
f010feff:	05 c4 00 00 00       	add    $0xc4,%eax
f010ff04:	83 ec 08             	sub    $0x8,%esp
f010ff07:	ff 75 0c             	pushl  0xc(%ebp)
f010ff0a:	50                   	push   %eax
f010ff0b:	e8 5b fd 00 00       	call   f011fc6b <strcpy>
f010ff10:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ff13:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff16:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ff1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff1f:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ff26:	00 00 00 
}
f010ff29:	90                   	nop
f010ff2a:	c9                   	leave  
f010ff2b:	c3                   	ret    

f010ff2c <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010ff2c:	55                   	push   %ebp
f010ff2d:	89 e5                	mov    %esp,%ebp
f010ff2f:	53                   	push   %ebx
f010ff30:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ff33:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff36:	83 c0 04             	add    $0x4,%eax
f010ff39:	83 ec 0c             	sub    $0xc,%esp
f010ff3c:	50                   	push   %eax
f010ff3d:	e8 2c fd ff ff       	call   f010fc6e <acquire_spinlock>
f010ff42:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ff45:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff48:	8b 00                	mov    (%eax),%eax
f010ff4a:	85 c0                	test   %eax,%eax
f010ff4c:	74 1c                	je     f010ff6a <holding_sleeplock+0x3e>
f010ff4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff51:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ff57:	e8 84 ba ff ff       	call   f010b9e0 <get_cpu_proc>
f010ff5c:	8b 40 10             	mov    0x10(%eax),%eax
f010ff5f:	39 c3                	cmp    %eax,%ebx
f010ff61:	75 07                	jne    f010ff6a <holding_sleeplock+0x3e>
f010ff63:	b8 01 00 00 00       	mov    $0x1,%eax
f010ff68:	eb 05                	jmp    f010ff6f <holding_sleeplock+0x43>
f010ff6a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010ff72:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff75:	83 c0 04             	add    $0x4,%eax
f010ff78:	83 ec 0c             	sub    $0xc,%esp
f010ff7b:	50                   	push   %eax
f010ff7c:	e8 74 fd ff ff       	call   f010fcf5 <release_spinlock>
f010ff81:	83 c4 10             	add    $0x10,%esp
	return r;
f010ff84:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ff87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ff8a:	c9                   	leave  
f010ff8b:	c3                   	ret    

f010ff8c <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010ff8c:	55                   	push   %ebp
f010ff8d:	89 e5                	mov    %esp,%ebp
f010ff8f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010ff92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff95:	83 c0 04             	add    $0x4,%eax
f010ff98:	83 ec 0c             	sub    $0xc,%esp
f010ff9b:	50                   	push   %eax
f010ff9c:	e8 cd fc ff ff       	call   f010fc6e <acquire_spinlock>
f010ffa1:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010ffa4:	eb 19                	jmp    f010ffbf <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010ffa6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa9:	8d 50 04             	lea    0x4(%eax),%edx
f010ffac:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffaf:	83 c0 74             	add    $0x74,%eax
f010ffb2:	83 ec 08             	sub    $0x8,%esp
f010ffb5:	52                   	push   %edx
f010ffb6:	50                   	push   %eax
f010ffb7:	e8 9f 00 00 00       	call   f011005b <sleep>
f010ffbc:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010ffbf:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffc2:	8b 00                	mov    (%eax),%eax
f010ffc4:	85 c0                	test   %eax,%eax
f010ffc6:	75 de                	jne    f010ffa6 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010ffc8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffcb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010ffd1:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffd4:	83 c0 04             	add    $0x4,%eax
f010ffd7:	83 ec 0c             	sub    $0xc,%esp
f010ffda:	50                   	push   %eax
f010ffdb:	e8 15 fd ff ff       	call   f010fcf5 <release_spinlock>
f010ffe0:	83 c4 10             	add    $0x10,%esp

}
f010ffe3:	90                   	nop
f010ffe4:	c9                   	leave  
f010ffe5:	c3                   	ret    

f010ffe6 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010ffe6:	55                   	push   %ebp
f010ffe7:	89 e5                	mov    %esp,%ebp
f010ffe9:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010ffec:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffef:	83 c0 04             	add    $0x4,%eax
f010fff2:	83 ec 0c             	sub    $0xc,%esp
f010fff5:	50                   	push   %eax
f010fff6:	e8 73 fc ff ff       	call   f010fc6e <acquire_spinlock>
f010fffb:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010fffe:	8b 45 08             	mov    0x8(%ebp),%eax
f0110001:	83 c0 74             	add    $0x74,%eax
f0110004:	83 ec 0c             	sub    $0xc,%esp
f0110007:	50                   	push   %eax
f0110008:	e8 3f 01 00 00       	call   f011014c <wakeup_all>
f011000d:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f0110010:	8b 45 08             	mov    0x8(%ebp),%eax
f0110013:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f0110019:	8b 45 08             	mov    0x8(%ebp),%eax
f011001c:	83 c0 04             	add    $0x4,%eax
f011001f:	83 ec 0c             	sub    $0xc,%esp
f0110022:	50                   	push   %eax
f0110023:	e8 cd fc ff ff       	call   f010fcf5 <release_spinlock>
f0110028:	83 c4 10             	add    $0x10,%esp
}
f011002b:	90                   	nop
f011002c:	c9                   	leave  
f011002d:	c3                   	ret    

f011002e <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f011002e:	55                   	push   %ebp
f011002f:	89 e5                	mov    %esp,%ebp
f0110031:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f0110034:	8b 45 08             	mov    0x8(%ebp),%eax
f0110037:	83 c0 10             	add    $0x10,%eax
f011003a:	83 ec 08             	sub    $0x8,%esp
f011003d:	ff 75 0c             	pushl  0xc(%ebp)
f0110040:	50                   	push   %eax
f0110041:	e8 25 fc 00 00       	call   f011fc6b <strcpy>
f0110046:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f0110049:	8b 45 08             	mov    0x8(%ebp),%eax
f011004c:	83 ec 0c             	sub    $0xc,%esp
f011004f:	50                   	push   %eax
f0110050:	e8 14 4f ff ff       	call   f0104f69 <init_queue>
f0110055:	83 c4 10             	add    $0x10,%esp
}
f0110058:	90                   	nop
f0110059:	c9                   	leave  
f011005a:	c3                   	ret    

f011005b <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f011005b:	55                   	push   %ebp
f011005c:	89 e5                	mov    %esp,%ebp
f011005e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f0110061:	83 ec 0c             	sub    $0xc,%esp
f0110064:	68 60 2e 6c f0       	push   $0xf06c2e60
f0110069:	e8 00 fc ff ff       	call   f010fc6e <acquire_spinlock>
f011006e:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f0110071:	e8 6a b9 ff ff       	call   f010b9e0 <get_cpu_proc>
f0110076:	89 c2                	mov    %eax,%edx
f0110078:	8b 45 08             	mov    0x8(%ebp),%eax
f011007b:	83 ec 08             	sub    $0x8,%esp
f011007e:	52                   	push   %edx
f011007f:	50                   	push   %eax
f0110080:	e8 25 4f ff ff       	call   f0104faa <enqueue>
f0110085:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f0110088:	e8 53 b9 ff ff       	call   f010b9e0 <get_cpu_proc>
f011008d:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f0110094:	83 ec 0c             	sub    $0xc,%esp
f0110097:	ff 75 0c             	pushl  0xc(%ebp)
f011009a:	e8 56 fc ff ff       	call   f010fcf5 <release_spinlock>
f011009f:	83 c4 10             	add    $0x10,%esp
	sched();
f01100a2:	e8 ba ba ff ff       	call   f010bb61 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f01100a7:	83 ec 0c             	sub    $0xc,%esp
f01100aa:	68 60 2e 6c f0       	push   $0xf06c2e60
f01100af:	e8 41 fc ff ff       	call   f010fcf5 <release_spinlock>
f01100b4:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f01100b7:	83 ec 0c             	sub    $0xc,%esp
f01100ba:	ff 75 0c             	pushl  0xc(%ebp)
f01100bd:	e8 ac fb ff ff       	call   f010fc6e <acquire_spinlock>
f01100c2:	83 c4 10             	add    $0x10,%esp
}
f01100c5:	90                   	nop
f01100c6:	c9                   	leave  
f01100c7:	c3                   	ret    

f01100c8 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f01100c8:	55                   	push   %ebp
f01100c9:	89 e5                	mov    %esp,%ebp
f01100cb:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f01100ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01100d1:	83 ec 0c             	sub    $0xc,%esp
f01100d4:	50                   	push   %eax
f01100d5:	e8 b8 4e ff ff       	call   f0104f92 <queue_size>
f01100da:	83 c4 10             	add    $0x10,%esp
f01100dd:	85 c0                	test   %eax,%eax
f01100df:	74 68                	je     f0110149 <wakeup_one+0x81>
		bool locked_by_me = 0;
f01100e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f01100e8:	83 ec 0c             	sub    $0xc,%esp
f01100eb:	68 60 2e 6c f0       	push   $0xf06c2e60
f01100f0:	e8 92 fd ff ff       	call   f010fe87 <holding_spinlock>
f01100f5:	83 c4 10             	add    $0x10,%esp
f01100f8:	85 c0                	test   %eax,%eax
f01100fa:	75 17                	jne    f0110113 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f01100fc:	83 ec 0c             	sub    $0xc,%esp
f01100ff:	68 60 2e 6c f0       	push   $0xf06c2e60
f0110104:	e8 65 fb ff ff       	call   f010fc6e <acquire_spinlock>
f0110109:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f011010c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f0110113:	8b 45 08             	mov    0x8(%ebp),%eax
f0110116:	83 ec 0c             	sub    $0xc,%esp
f0110119:	50                   	push   %eax
f011011a:	e8 1c 4f ff ff       	call   f010503b <dequeue>
f011011f:	83 c4 10             	add    $0x10,%esp
f0110122:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f0110125:	83 ec 0c             	sub    $0xc,%esp
f0110128:	ff 75 f0             	pushl  -0x10(%ebp)
f011012b:	e8 46 51 ff ff       	call   f0105276 <sched_insert_ready0>
f0110130:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f0110133:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110137:	74 10                	je     f0110149 <wakeup_one+0x81>
f0110139:	83 ec 0c             	sub    $0xc,%esp
f011013c:	68 60 2e 6c f0       	push   $0xf06c2e60
f0110141:	e8 af fb ff ff       	call   f010fcf5 <release_spinlock>
f0110146:	83 c4 10             	add    $0x10,%esp
	}
}
f0110149:	90                   	nop
f011014a:	c9                   	leave  
f011014b:	c3                   	ret    

f011014c <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f011014c:	55                   	push   %ebp
f011014d:	89 e5                	mov    %esp,%ebp
f011014f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f0110152:	83 ec 0c             	sub    $0xc,%esp
f0110155:	68 60 2e 6c f0       	push   $0xf06c2e60
f011015a:	e8 0f fb ff ff       	call   f010fc6e <acquire_spinlock>
f011015f:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f0110162:	eb 0e                	jmp    f0110172 <wakeup_all+0x26>
		wakeup_one(chan);
f0110164:	83 ec 0c             	sub    $0xc,%esp
f0110167:	ff 75 08             	pushl  0x8(%ebp)
f011016a:	e8 59 ff ff ff       	call   f01100c8 <wakeup_one>
f011016f:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f0110172:	8b 45 08             	mov    0x8(%ebp),%eax
f0110175:	83 ec 0c             	sub    $0xc,%esp
f0110178:	50                   	push   %eax
f0110179:	e8 14 4e ff ff       	call   f0104f92 <queue_size>
f011017e:	83 c4 10             	add    $0x10,%esp
f0110181:	85 c0                	test   %eax,%eax
f0110183:	75 df                	jne    f0110164 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f0110185:	83 ec 0c             	sub    $0xc,%esp
f0110188:	68 60 2e 6c f0       	push   $0xf06c2e60
f011018d:	e8 63 fb ff ff       	call   f010fcf5 <release_spinlock>
f0110192:	83 c4 10             	add    $0x10,%esp
}
f0110195:	90                   	nop
f0110196:	c9                   	leave  
f0110197:	c3                   	ret    

f0110198 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0110198:	55                   	push   %ebp
f0110199:	89 e5                	mov    %esp,%ebp
f011019b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f011019e:	83 ec 04             	sub    $0x4,%esp
f01101a1:	68 d4 7b 12 f0       	push   $0xf0127bd4
f01101a6:	6a 13                	push   $0x13
f01101a8:	68 fb 7b 12 f0       	push   $0xf0127bfb
f01101ad:	e8 87 01 ff ff       	call   f0100339 <_panic>

f01101b2 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f01101b2:	55                   	push   %ebp
f01101b3:	89 e5                	mov    %esp,%ebp
f01101b5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f01101b8:	83 ec 04             	sub    $0x4,%esp
f01101bb:	68 14 7c 12 f0       	push   $0xf0127c14
f01101c0:	6a 1b                	push   $0x1b
f01101c2:	68 fb 7b 12 f0       	push   $0xf0127bfb
f01101c7:	e8 6d 01 ff ff       	call   f0100339 <_panic>

f01101cc <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f01101cc:	55                   	push   %ebp
f01101cd:	89 e5                	mov    %esp,%ebp
f01101cf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f01101d2:	83 ec 04             	sub    $0x4,%esp
f01101d5:	68 3c 7c 12 f0       	push   $0xf0127c3c
f01101da:	6a 24                	push   $0x24
f01101dc:	68 fb 7b 12 f0       	push   $0xf0127bfb
f01101e1:	e8 53 01 ff ff       	call   f0100339 <_panic>

f01101e6 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f01101e6:	55                   	push   %ebp
f01101e7:	89 e5                	mov    %esp,%ebp
f01101e9:	c7 05 f8 33 ac f0 01 	movl   $0x1,0xf0ac33f8
f01101f0:	00 00 00 
f01101f3:	90                   	nop
f01101f4:	5d                   	pop    %ebp
f01101f5:	c3                   	ret    

f01101f6 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f01101f6:	55                   	push   %ebp
f01101f7:	89 e5                	mov    %esp,%ebp
f01101f9:	c7 05 f8 33 ac f0 02 	movl   $0x2,0xf0ac33f8
f0110200:	00 00 00 
f0110203:	90                   	nop
f0110204:	5d                   	pop    %ebp
f0110205:	c3                   	ret    

f0110206 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0110206:	55                   	push   %ebp
f0110207:	89 e5                	mov    %esp,%ebp
f0110209:	c7 05 f8 33 ac f0 03 	movl   $0x3,0xf0ac33f8
f0110210:	00 00 00 
f0110213:	90                   	nop
f0110214:	5d                   	pop    %ebp
f0110215:	c3                   	ret    

f0110216 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0110216:	55                   	push   %ebp
f0110217:	89 e5                	mov    %esp,%ebp
f0110219:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f011021e:	83 f8 01             	cmp    $0x1,%eax
f0110221:	75 04                	jne    f0110227 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0110223:	b0 01                	mov    $0x1,%al
f0110225:	eb 02                	jmp    f0110229 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0110227:	b0 00                	mov    $0x0,%al
f0110229:	5d                   	pop    %ebp
f011022a:	c3                   	ret    

f011022b <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f011022b:	55                   	push   %ebp
f011022c:	89 e5                	mov    %esp,%ebp
f011022e:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f0110233:	83 f8 02             	cmp    $0x2,%eax
f0110236:	75 04                	jne    f011023c <isKHeapPlacementStrategyBESTFIT+0x11>
f0110238:	b0 01                	mov    $0x1,%al
f011023a:	eb 02                	jmp    f011023e <isKHeapPlacementStrategyBESTFIT+0x13>
f011023c:	b0 00                	mov    $0x0,%al
f011023e:	5d                   	pop    %ebp
f011023f:	c3                   	ret    

f0110240 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0110240:	55                   	push   %ebp
f0110241:	89 e5                	mov    %esp,%ebp
f0110243:	a1 f8 33 ac f0       	mov    0xf0ac33f8,%eax
f0110248:	83 f8 03             	cmp    $0x3,%eax
f011024b:	75 04                	jne    f0110251 <isKHeapPlacementStrategyNEXTFIT+0x11>
f011024d:	b0 01                	mov    $0x1,%al
f011024f:	eb 02                	jmp    f0110253 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0110251:	b0 00                	mov    $0x0,%al
f0110253:	5d                   	pop    %ebp
f0110254:	c3                   	ret    

f0110255 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110255:	55                   	push   %ebp
f0110256:	89 e5                	mov    %esp,%ebp
f0110258:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f011025b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110262:	eb 26                	jmp    f011028a <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110264:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110267:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011026e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110271:	01 c2                	add    %eax,%edx
f0110273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110276:	40                   	inc    %eax
f0110277:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011027e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110281:	01 c8                	add    %ecx,%eax
f0110283:	8b 00                	mov    (%eax),%eax
f0110285:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110287:	ff 45 f4             	incl   -0xc(%ebp)
f011028a:	8b 45 08             	mov    0x8(%ebp),%eax
f011028d:	48                   	dec    %eax
f011028e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110291:	7f d1                	jg     f0110264 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f0110293:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0110296:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f011029d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01102a4:	eb 35                	jmp    f01102db <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f01102a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102a9:	89 d0                	mov    %edx,%eax
f01102ab:	01 c0                	add    %eax,%eax
f01102ad:	01 d0                	add    %edx,%eax
f01102af:	c1 e0 02             	shl    $0x2,%eax
f01102b2:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f01102b7:	8b 10                	mov    (%eax),%edx
f01102b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102bc:	8b 00                	mov    (%eax),%eax
f01102be:	83 ec 08             	sub    $0x8,%esp
f01102c1:	52                   	push   %edx
f01102c2:	50                   	push   %eax
f01102c3:	e8 60 fa 00 00       	call   f011fd28 <strcmp>
f01102c8:	83 c4 10             	add    $0x10,%esp
f01102cb:	85 c0                	test   %eax,%eax
f01102cd:	75 09                	jne    f01102d8 <tst_handler+0x83>
		{
			test_found = 1;
f01102cf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f01102d6:	eb 0f                	jmp    f01102e7 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01102d8:	ff 45 ec             	incl   -0x14(%ebp)
f01102db:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102de:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f01102e3:	39 c2                	cmp    %eax,%edx
f01102e5:	72 bf                	jb     f01102a6 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f01102e7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01102eb:	74 29                	je     f0110316 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f01102ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102f0:	89 d0                	mov    %edx,%eax
f01102f2:	01 c0                	add    %eax,%eax
f01102f4:	01 d0                	add    %edx,%eax
f01102f6:	c1 e0 02             	shl    $0x2,%eax
f01102f9:	05 08 fd 17 f0       	add    $0xf017fd08,%eax
f01102fe:	8b 00                	mov    (%eax),%eax
f0110300:	83 ec 08             	sub    $0x8,%esp
f0110303:	ff 75 0c             	pushl  0xc(%ebp)
f0110306:	ff 75 08             	pushl  0x8(%ebp)
f0110309:	ff d0                	call   *%eax
f011030b:	83 c4 10             	add    $0x10,%esp
f011030e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110311:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110314:	eb 1b                	jmp    f0110331 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0110316:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110319:	8b 00                	mov    (%eax),%eax
f011031b:	83 ec 08             	sub    $0x8,%esp
f011031e:	50                   	push   %eax
f011031f:	68 7c 7f 12 f0       	push   $0xf0127f7c
f0110324:	e8 62 0c ff ff       	call   f0100f8b <cprintf>
f0110329:	83 c4 10             	add    $0x10,%esp
		return 0;
f011032c:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110331:	c9                   	leave  
f0110332:	c3                   	ret    

f0110333 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110333:	55                   	push   %ebp
f0110334:	89 e5                	mov    %esp,%ebp
f0110336:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f0110339:	e8 69 d0 00 00       	call   f011d3a7 <test_three_creation_functions>
	return 0;
f011033e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110343:	c9                   	leave  
f0110344:	c3                   	ret    

f0110345 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0110345:	55                   	push   %ebp
f0110346:	89 e5                	mov    %esp,%ebp
f0110348:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f011034b:	e8 03 69 00 00       	call   f0116c53 <test_priority_normal_and_higher>
	return 0;
f0110350:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110355:	c9                   	leave  
f0110356:	c3                   	ret    

f0110357 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110357:	55                   	push   %ebp
f0110358:	89 e5                	mov    %esp,%ebp
f011035a:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f011035d:	e8 0b 69 00 00       	call   f0116c6d <test_priority_normal_and_lower>
	return 0;
f0110362:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110367:	c9                   	leave  
f0110368:	c3                   	ret    

f0110369 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f0110369:	55                   	push   %ebp
f011036a:	89 e5                	mov    %esp,%ebp
f011036c:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f011036f:	e8 e6 d1 00 00       	call   f011d55a <test_kfreeall>
	return 0;
f0110374:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110379:	c9                   	leave  
f011037a:	c3                   	ret    

f011037b <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f011037b:	55                   	push   %ebp
f011037c:	89 e5                	mov    %esp,%ebp
f011037e:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110381:	e8 f1 d1 00 00       	call   f011d577 <test_kexpand>
	return 0;
f0110386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011038b:	c9                   	leave  
f011038c:	c3                   	ret    

f011038d <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f011038d:	55                   	push   %ebp
f011038e:	89 e5                	mov    %esp,%ebp
f0110390:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f0110393:	e8 fc d1 00 00       	call   f011d594 <test_kshrink>
	return 0;
f0110398:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011039d:	c9                   	leave  
f011039e:	c3                   	ret    

f011039f <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f011039f:	55                   	push   %ebp
f01103a0:	89 e5                	mov    %esp,%ebp
f01103a2:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f01103a5:	e8 07 d2 00 00       	call   f011d5b1 <test_kfreelast>
	return 0;
f01103aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103af:	c9                   	leave  
f01103b0:	c3                   	ret    

f01103b1 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f01103b1:	55                   	push   %ebp
f01103b2:	89 e5                	mov    %esp,%ebp
f01103b4:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f01103b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103ba:	83 c0 04             	add    $0x4,%eax
f01103bd:	8b 00                	mov    (%eax),%eax
f01103bf:	83 ec 04             	sub    $0x4,%esp
f01103c2:	6a 0a                	push   $0xa
f01103c4:	6a 00                	push   $0x0
f01103c6:	50                   	push   %eax
f01103c7:	e8 b0 fb 00 00       	call   f011ff7c <strtol>
f01103cc:	83 c4 10             	add    $0x10,%esp
f01103cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f01103d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f01103d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f01103e0:	83 ec 0c             	sub    $0xc,%esp
f01103e3:	68 60 2e 6c f0       	push   $0xf06c2e60
f01103e8:	e8 81 f8 ff ff       	call   f010fc6e <acquire_spinlock>
f01103ed:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f01103f0:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f01103f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01103f8:	eb 3b                	jmp    f0110435 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f01103fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01103fd:	83 c0 20             	add    $0x20,%eax
f0110400:	83 ec 08             	sub    $0x8,%esp
f0110403:	68 8f 7f 12 f0       	push   $0xf0127f8f
f0110408:	50                   	push   %eax
f0110409:	e8 1a f9 00 00       	call   f011fd28 <strcmp>
f011040e:	83 c4 10             	add    $0x10,%esp
f0110411:	85 c0                	test   %eax,%eax
f0110413:	75 12                	jne    f0110427 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0110415:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110419:	74 07                	je     f0110422 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f011041b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110422:	ff 45 f4             	incl   -0xc(%ebp)
f0110425:	eb 06                	jmp    f011042d <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f0110427:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011042b:	74 31                	je     f011045e <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f011042d:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f0110432:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110435:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110439:	74 08                	je     f0110443 <tst_sc_MLFQ+0x92>
f011043b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011043e:	8b 40 08             	mov    0x8(%eax),%eax
f0110441:	eb 05                	jmp    f0110448 <tst_sc_MLFQ+0x97>
f0110443:	b8 00 00 00 00       	mov    $0x0,%eax
f0110448:	a3 e8 2e 6c f0       	mov    %eax,0xf06c2ee8
f011044d:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f0110452:	85 c0                	test   %eax,%eax
f0110454:	75 a4                	jne    f01103fa <tst_sc_MLFQ+0x49>
f0110456:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011045a:	75 9e                	jne    f01103fa <tst_sc_MLFQ+0x49>
f011045c:	eb 01                	jmp    f011045f <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f011045e:	90                   	nop
			}
		if(cnt == numOfSlave2)
f011045f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110462:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110465:	75 12                	jne    f0110479 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110467:	83 ec 0c             	sub    $0xc,%esp
f011046a:	68 98 7f 12 f0       	push   $0xf0127f98
f011046f:	e8 17 0b ff ff       	call   f0100f8b <cprintf>
f0110474:	83 c4 10             	add    $0x10,%esp
f0110477:	eb 17                	jmp    f0110490 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0110479:	83 ec 04             	sub    $0x4,%esp
f011047c:	68 d1 7f 12 f0       	push   $0xf0127fd1
f0110481:	68 9b 00 00 00       	push   $0x9b
f0110486:	68 e7 7f 12 f0       	push   $0xf0127fe7
f011048b:	e8 a9 fe fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0110490:	83 ec 0c             	sub    $0xc,%esp
f0110493:	68 60 2e 6c f0       	push   $0xf06c2e60
f0110498:	e8 58 f8 ff ff       	call   f010fcf5 <release_spinlock>
f011049d:	83 c4 10             	add    $0x10,%esp
	return 0;
f01104a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104a5:	c9                   	leave  
f01104a6:	c3                   	ret    

f01104a7 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f01104a7:	55                   	push   %ebp
f01104a8:	89 e5                	mov    %esp,%ebp
f01104aa:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f01104ad:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01104b1:	74 17                	je     f01104ca <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f01104b3:	83 ec 0c             	sub    $0xc,%esp
f01104b6:	68 00 80 12 f0       	push   $0xf0128000
f01104bb:	e8 cb 0a ff ff       	call   f0100f8b <cprintf>
f01104c0:	83 c4 10             	add    $0x10,%esp
		return 0;
f01104c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01104c8:	eb 45                	jmp    f011050f <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f01104ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104cd:	83 c0 04             	add    $0x4,%eax
f01104d0:	8b 00                	mov    (%eax),%eax
f01104d2:	83 ec 04             	sub    $0x4,%esp
f01104d5:	6a 0a                	push   $0xa
f01104d7:	6a 00                	push   $0x0
f01104d9:	50                   	push   %eax
f01104da:	e8 9d fa 00 00       	call   f011ff7c <strtol>
f01104df:	83 c4 10             	add    $0x10,%esp
f01104e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f01104e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104e8:	83 f8 01             	cmp    $0x1,%eax
f01104eb:	74 10                	je     f01104fd <tst_bsd_nice+0x56>
f01104ed:	83 f8 02             	cmp    $0x2,%eax
f01104f0:	74 12                	je     f0110504 <tst_bsd_nice+0x5d>
f01104f2:	85 c0                	test   %eax,%eax
f01104f4:	75 14                	jne    f011050a <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f01104f6:	e8 b9 d2 00 00       	call   f011d7b4 <test_bsd_nice_0>
		break;
f01104fb:	eb 0d                	jmp    f011050a <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f01104fd:	e8 3c d5 00 00       	call   f011da3e <test_bsd_nice_1>
		break;
f0110502:	eb 06                	jmp    f011050a <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0110504:	e8 49 d7 00 00       	call   f011dc52 <test_bsd_nice_2>
		break;
f0110509:	90                   	nop
	}
	return 0;
f011050a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011050f:	c9                   	leave  
f0110510:	c3                   	ret    

f0110511 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f0110511:	55                   	push   %ebp
f0110512:	89 e5                	mov    %esp,%ebp
f0110514:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f0110517:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011051b:	74 17                	je     f0110534 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f011051d:	83 ec 0c             	sub    $0xc,%esp
f0110520:	68 40 80 12 f0       	push   $0xf0128040
f0110525:	e8 61 0a ff ff       	call   f0100f8b <cprintf>
f011052a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011052d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110532:	eb 0a                	jmp    f011053e <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f0110534:	e8 3f 15 00 00       	call   f0111a78 <test_str2lower_function>
	return 0;
f0110539:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011053e:	c9                   	leave  
f011053f:	c3                   	ret    

f0110540 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f0110540:	55                   	push   %ebp
f0110541:	89 e5                	mov    %esp,%ebp
f0110543:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f0110546:	e8 63 11 00 00       	call   f01116ae <TestAutoCompleteCommand>
f011054b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f011054e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110553:	c9                   	leave  
f0110554:	c3                   	ret    

f0110555 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f0110555:	55                   	push   %ebp
f0110556:	89 e5                	mov    %esp,%ebp
f0110558:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011055b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011055f:	74 1a                	je     f011057b <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f0110561:	83 ec 0c             	sub    $0xc,%esp
f0110564:	68 74 80 12 f0       	push   $0xf0128074
f0110569:	e8 1d 0a ff ff       	call   f0100f8b <cprintf>
f011056e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110571:	b8 00 00 00 00       	mov    $0x0,%eax
f0110576:	e9 2f 01 00 00       	jmp    f01106aa <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f011057b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011057e:	83 c0 04             	add    $0x4,%eax
f0110581:	8b 00                	mov    (%eax),%eax
f0110583:	83 ec 08             	sub    $0x8,%esp
f0110586:	68 b1 80 12 f0       	push   $0xf01280b1
f011058b:	50                   	push   %eax
f011058c:	e8 97 f7 00 00       	call   f011fd28 <strcmp>
f0110591:	83 c4 10             	add    $0x10,%esp
f0110594:	85 c0                	test   %eax,%eax
f0110596:	75 0a                	jne    f01105a2 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f0110598:	e8 40 08 00 00       	call   f0110ddd <test_initialize_dynamic_allocator>
f011059d:	e9 03 01 00 00       	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f01105a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105a5:	83 c0 04             	add    $0x4,%eax
f01105a8:	8b 00                	mov    (%eax),%eax
f01105aa:	83 ec 08             	sub    $0x8,%esp
f01105ad:	68 b6 80 12 f0       	push   $0xf01280b6
f01105b2:	50                   	push   %eax
f01105b3:	e8 70 f7 00 00       	call   f011fd28 <strcmp>
f01105b8:	83 c4 10             	add    $0x10,%esp
f01105bb:	85 c0                	test   %eax,%eax
f01105bd:	75 0a                	jne    f01105c9 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f01105bf:	e8 4d 08 00 00       	call   f0110e11 <test_alloc_block_FF>
f01105c4:	e9 dc 00 00 00       	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f01105c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105cc:	83 c0 04             	add    $0x4,%eax
f01105cf:	8b 00                	mov    (%eax),%eax
f01105d1:	83 ec 08             	sub    $0x8,%esp
f01105d4:	68 be 80 12 f0       	push   $0xf01280be
f01105d9:	50                   	push   %eax
f01105da:	e8 49 f7 00 00       	call   f011fd28 <strcmp>
f01105df:	83 c4 10             	add    $0x10,%esp
f01105e2:	85 c0                	test   %eax,%eax
f01105e4:	75 0a                	jne    f01105f0 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f01105e6:	e8 43 08 00 00       	call   f0110e2e <test_alloc_block_BF>
f01105eb:	e9 b5 00 00 00       	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f01105f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105f3:	83 c0 04             	add    $0x4,%eax
f01105f6:	8b 00                	mov    (%eax),%eax
f01105f8:	83 ec 08             	sub    $0x8,%esp
f01105fb:	68 c6 80 12 f0       	push   $0xf01280c6
f0110600:	50                   	push   %eax
f0110601:	e8 22 f7 00 00       	call   f011fd28 <strcmp>
f0110606:	83 c4 10             	add    $0x10,%esp
f0110609:	85 c0                	test   %eax,%eax
f011060b:	75 0a                	jne    f0110617 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f011060d:	e8 3c 08 00 00       	call   f0110e4e <test_alloc_block_NF>
f0110612:	e9 8e 00 00 00       	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f0110617:	8b 45 0c             	mov    0xc(%ebp),%eax
f011061a:	83 c0 04             	add    $0x4,%eax
f011061d:	8b 00                	mov    (%eax),%eax
f011061f:	83 ec 08             	sub    $0x8,%esp
f0110622:	68 ce 80 12 f0       	push   $0xf01280ce
f0110627:	50                   	push   %eax
f0110628:	e8 fb f6 00 00       	call   f011fd28 <strcmp>
f011062d:	83 c4 10             	add    $0x10,%esp
f0110630:	85 c0                	test   %eax,%eax
f0110632:	75 07                	jne    f011063b <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f0110634:	e8 1b 08 00 00       	call   f0110e54 <test_free_block_FF>
f0110639:	eb 6a                	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f011063b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011063e:	83 c0 04             	add    $0x4,%eax
f0110641:	8b 00                	mov    (%eax),%eax
f0110643:	83 ec 08             	sub    $0x8,%esp
f0110646:	68 d5 80 12 f0       	push   $0xf01280d5
f011064b:	50                   	push   %eax
f011064c:	e8 d7 f6 00 00       	call   f011fd28 <strcmp>
f0110651:	83 c4 10             	add    $0x10,%esp
f0110654:	85 c0                	test   %eax,%eax
f0110656:	75 07                	jne    f011065f <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f0110658:	e8 14 08 00 00       	call   f0110e71 <test_free_block_BF>
f011065d:	eb 46                	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f011065f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110662:	83 c0 04             	add    $0x4,%eax
f0110665:	8b 00                	mov    (%eax),%eax
f0110667:	83 ec 08             	sub    $0x8,%esp
f011066a:	68 dc 80 12 f0       	push   $0xf01280dc
f011066f:	50                   	push   %eax
f0110670:	e8 b3 f6 00 00       	call   f011fd28 <strcmp>
f0110675:	83 c4 10             	add    $0x10,%esp
f0110678:	85 c0                	test   %eax,%eax
f011067a:	75 07                	jne    f0110683 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f011067c:	e8 0d 08 00 00       	call   f0110e8e <test_free_block_NF>
f0110681:	eb 22                	jmp    f01106a5 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f0110683:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110686:	83 c0 04             	add    $0x4,%eax
f0110689:	8b 00                	mov    (%eax),%eax
f011068b:	83 ec 08             	sub    $0x8,%esp
f011068e:	68 e3 80 12 f0       	push   $0xf01280e3
f0110693:	50                   	push   %eax
f0110694:	e8 8f f6 00 00       	call   f011fd28 <strcmp>
f0110699:	83 c4 10             	add    $0x10,%esp
f011069c:	85 c0                	test   %eax,%eax
f011069e:	75 05                	jne    f01106a5 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f01106a0:	e8 06 08 00 00       	call   f0110eab <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f01106a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106aa:	c9                   	leave  
f01106ab:	c3                   	ret    

f01106ac <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f01106ac:	55                   	push   %ebp
f01106ad:	89 e5                	mov    %esp,%ebp
f01106af:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01106b2:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01106b6:	74 1a                	je     f01106d2 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f01106b8:	83 ec 0c             	sub    $0xc,%esp
f01106bb:	68 f0 80 12 f0       	push   $0xf01280f0
f01106c0:	e8 c6 08 ff ff       	call   f0100f8b <cprintf>
f01106c5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01106c8:	b8 00 00 00 00       	mov    $0x0,%eax
f01106cd:	e9 e1 00 00 00       	jmp    f01107b3 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f01106d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106d5:	83 c0 04             	add    $0x4,%eax
f01106d8:	8b 00                	mov    (%eax),%eax
f01106da:	83 ec 08             	sub    $0x8,%esp
f01106dd:	68 29 81 12 f0       	push   $0xf0128129
f01106e2:	50                   	push   %eax
f01106e3:	e8 40 f6 00 00       	call   f011fd28 <strcmp>
f01106e8:	83 c4 10             	add    $0x10,%esp
f01106eb:	85 c0                	test   %eax,%eax
f01106ed:	75 0a                	jne    f01106f9 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f01106ef:	e8 97 1c 00 00       	call   f011238b <test_cut_paste_pages>
f01106f4:	e9 b5 00 00 00       	jmp    f01107ae <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01106f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106fc:	83 c0 04             	add    $0x4,%eax
f01106ff:	8b 00                	mov    (%eax),%eax
f0110701:	83 ec 08             	sub    $0x8,%esp
f0110704:	68 32 81 12 f0       	push   $0xf0128132
f0110709:	50                   	push   %eax
f011070a:	e8 19 f6 00 00       	call   f011fd28 <strcmp>
f011070f:	83 c4 10             	add    $0x10,%esp
f0110712:	85 c0                	test   %eax,%eax
f0110714:	75 0a                	jne    f0110720 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f0110716:	e8 bb 26 00 00       	call   f0112dd6 <test_copy_paste_chunk>
f011071b:	e9 8e 00 00 00       	jmp    f01107ae <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f0110720:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110723:	83 c0 04             	add    $0x4,%eax
f0110726:	8b 00                	mov    (%eax),%eax
f0110728:	83 ec 08             	sub    $0x8,%esp
f011072b:	68 3c 81 12 f0       	push   $0xf012813c
f0110730:	50                   	push   %eax
f0110731:	e8 f2 f5 00 00       	call   f011fd28 <strcmp>
f0110736:	83 c4 10             	add    $0x10,%esp
f0110739:	85 c0                	test   %eax,%eax
f011073b:	75 07                	jne    f0110744 <tst_chunks+0x98>
	{
		test_share_chunk();
f011073d:	e8 92 37 00 00       	call   f0113ed4 <test_share_chunk>
f0110742:	eb 6a                	jmp    f01107ae <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f0110744:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110747:	83 c0 04             	add    $0x4,%eax
f011074a:	8b 00                	mov    (%eax),%eax
f011074c:	83 ec 08             	sub    $0x8,%esp
f011074f:	68 42 81 12 f0       	push   $0xf0128142
f0110754:	50                   	push   %eax
f0110755:	e8 ce f5 00 00       	call   f011fd28 <strcmp>
f011075a:	83 c4 10             	add    $0x10,%esp
f011075d:	85 c0                	test   %eax,%eax
f011075f:	75 07                	jne    f0110768 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110761:	e8 96 41 00 00       	call   f01148fc <test_allocate_chunk>
f0110766:	eb 46                	jmp    f01107ae <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110768:	8b 45 0c             	mov    0xc(%ebp),%eax
f011076b:	83 c0 04             	add    $0x4,%eax
f011076e:	8b 00                	mov    (%eax),%eax
f0110770:	83 ec 08             	sub    $0x8,%esp
f0110773:	68 4b 81 12 f0       	push   $0xf012814b
f0110778:	50                   	push   %eax
f0110779:	e8 aa f5 00 00       	call   f011fd28 <strcmp>
f011077e:	83 c4 10             	add    $0x10,%esp
f0110781:	85 c0                	test   %eax,%eax
f0110783:	75 07                	jne    f011078c <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110785:	e8 79 4a 00 00       	call   f0115203 <test_calculate_required_frames>
f011078a:	eb 22                	jmp    f01107ae <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f011078c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011078f:	83 c0 04             	add    $0x4,%eax
f0110792:	8b 00                	mov    (%eax),%eax
f0110794:	83 ec 08             	sub    $0x8,%esp
f0110797:	68 5a 81 12 f0       	push   $0xf012815a
f011079c:	50                   	push   %eax
f011079d:	e8 86 f5 00 00       	call   f011fd28 <strcmp>
f01107a2:	83 c4 10             	add    $0x10,%esp
f01107a5:	85 c0                	test   %eax,%eax
f01107a7:	75 05                	jne    f01107ae <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f01107a9:	e8 c9 52 00 00       	call   f0115a77 <test_calculate_allocated_space>
	}
	return 0;
f01107ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01107b3:	c9                   	leave  
f01107b4:	c3                   	ret    

f01107b5 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f01107b5:	55                   	push   %ebp
f01107b6:	89 e5                	mov    %esp,%ebp
f01107b8:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01107bb:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01107bf:	74 1a                	je     f01107db <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f01107c1:	83 ec 0c             	sub    $0xc,%esp
f01107c4:	68 6c 81 12 f0       	push   $0xf012816c
f01107c9:	e8 bd 07 ff ff       	call   f0100f8b <cprintf>
f01107ce:	83 c4 10             	add    $0x10,%esp
		return 0;
f01107d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01107d6:	e9 ba 00 00 00       	jmp    f0110895 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f01107db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107de:	83 c0 04             	add    $0x4,%eax
f01107e1:	8b 00                	mov    (%eax),%eax
f01107e3:	83 ec 08             	sub    $0x8,%esp
f01107e6:	68 a2 81 12 f0       	push   $0xf01281a2
f01107eb:	50                   	push   %eax
f01107ec:	e8 37 f5 00 00       	call   f011fd28 <strcmp>
f01107f1:	83 c4 10             	add    $0x10,%esp
f01107f4:	85 c0                	test   %eax,%eax
f01107f6:	75 0a                	jne    f0110802 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01107f8:	e8 01 16 00 00       	call   f0111dfe <test_pt_set_page_permissions>
f01107fd:	e9 8e 00 00 00       	jmp    f0110890 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f0110802:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110805:	83 c0 04             	add    $0x4,%eax
f0110808:	8b 00                	mov    (%eax),%eax
f011080a:	83 ec 08             	sub    $0x8,%esp
f011080d:	68 aa 81 12 f0       	push   $0xf01281aa
f0110812:	50                   	push   %eax
f0110813:	e8 10 f5 00 00       	call   f011fd28 <strcmp>
f0110818:	83 c4 10             	add    $0x10,%esp
f011081b:	85 c0                	test   %eax,%eax
f011081d:	75 07                	jne    f0110826 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f011081f:	e8 49 18 00 00       	call   f011206d <test_pt_set_page_permissions_invalid_va>
f0110824:	eb 6a                	jmp    f0110890 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f0110826:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110829:	83 c0 04             	add    $0x4,%eax
f011082c:	8b 00                	mov    (%eax),%eax
f011082e:	83 ec 08             	sub    $0x8,%esp
f0110831:	68 b2 81 12 f0       	push   $0xf01281b2
f0110836:	50                   	push   %eax
f0110837:	e8 ec f4 00 00       	call   f011fd28 <strcmp>
f011083c:	83 c4 10             	add    $0x10,%esp
f011083f:	85 c0                	test   %eax,%eax
f0110841:	75 07                	jne    f011084a <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f0110843:	e8 6e 18 00 00       	call   f01120b6 <test_pt_get_page_permissions>
f0110848:	eb 46                	jmp    f0110890 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f011084a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011084d:	83 c0 04             	add    $0x4,%eax
f0110850:	8b 00                	mov    (%eax),%eax
f0110852:	83 ec 08             	sub    $0x8,%esp
f0110855:	68 ba 81 12 f0       	push   $0xf01281ba
f011085a:	50                   	push   %eax
f011085b:	e8 c8 f4 00 00       	call   f011fd28 <strcmp>
f0110860:	83 c4 10             	add    $0x10,%esp
f0110863:	85 c0                	test   %eax,%eax
f0110865:	75 07                	jne    f011086e <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110867:	e8 8e 19 00 00       	call   f01121fa <test_pt_clear_page_table_entry>
f011086c:	eb 22                	jmp    f0110890 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f011086e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110871:	83 c0 04             	add    $0x4,%eax
f0110874:	8b 00                	mov    (%eax),%eax
f0110876:	83 ec 08             	sub    $0x8,%esp
f0110879:	68 c1 81 12 f0       	push   $0xf01281c1
f011087e:	50                   	push   %eax
f011087f:	e8 a4 f4 00 00       	call   f011fd28 <strcmp>
f0110884:	83 c4 10             	add    $0x10,%esp
f0110887:	85 c0                	test   %eax,%eax
f0110889:	75 05                	jne    f0110890 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f011088b:	e8 c3 1a 00 00       	call   f0112353 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0110890:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110895:	c9                   	leave  
f0110896:	c3                   	ret    

f0110897 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110897:	55                   	push   %ebp
f0110898:	89 e5                	mov    %esp,%ebp
f011089a:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f011089d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108a0:	83 c0 08             	add    $0x8,%eax
f01108a3:	8b 00                	mov    (%eax),%eax
f01108a5:	83 ec 08             	sub    $0x8,%esp
f01108a8:	68 c8 81 12 f0       	push   $0xf01281c8
f01108ad:	50                   	push   %eax
f01108ae:	e8 75 f4 00 00       	call   f011fd28 <strcmp>
f01108b3:	83 c4 10             	add    $0x10,%esp
f01108b6:	85 c0                	test   %eax,%eax
f01108b8:	75 20                	jne    f01108da <tst_kheap+0x43>
f01108ba:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01108be:	74 1a                	je     f01108da <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f01108c0:	83 ec 0c             	sub    $0xc,%esp
f01108c3:	68 d0 81 12 f0       	push   $0xf01281d0
f01108c8:	e8 be 06 ff ff       	call   f0100f8b <cprintf>
f01108cd:	83 c4 10             	add    $0x10,%esp
		return 0;
f01108d0:	b8 00 00 00 00       	mov    $0x0,%eax
f01108d5:	e9 42 04 00 00       	jmp    f0110d1c <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f01108da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108dd:	83 c0 08             	add    $0x8,%eax
f01108e0:	8b 00                	mov    (%eax),%eax
f01108e2:	83 ec 08             	sub    $0x8,%esp
f01108e5:	68 c8 81 12 f0       	push   $0xf01281c8
f01108ea:	50                   	push   %eax
f01108eb:	e8 38 f4 00 00       	call   f011fd28 <strcmp>
f01108f0:	83 c4 10             	add    $0x10,%esp
f01108f3:	85 c0                	test   %eax,%eax
f01108f5:	74 43                	je     f011093a <tst_kheap+0xa3>
f01108f7:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01108fb:	74 3d                	je     f011093a <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f01108fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110900:	83 c0 08             	add    $0x8,%eax
f0110903:	8b 00                	mov    (%eax),%eax
f0110905:	83 ec 08             	sub    $0x8,%esp
f0110908:	68 20 82 12 f0       	push   $0xf0128220
f011090d:	50                   	push   %eax
f011090e:	e8 15 f4 00 00       	call   f011fd28 <strcmp>
f0110913:	83 c4 10             	add    $0x10,%esp
f0110916:	85 c0                	test   %eax,%eax
f0110918:	74 20                	je     f011093a <tst_kheap+0xa3>
f011091a:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f011091e:	74 1a                	je     f011093a <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f0110920:	83 ec 0c             	sub    $0xc,%esp
f0110923:	68 2c 82 12 f0       	push   $0xf012822c
f0110928:	e8 5e 06 ff ff       	call   f0100f8b <cprintf>
f011092d:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110930:	b8 00 00 00 00       	mov    $0x0,%eax
f0110935:	e9 e2 03 00 00       	jmp    f0110d1c <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f011093a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011093d:	83 c0 04             	add    $0x4,%eax
f0110940:	8b 00                	mov    (%eax),%eax
f0110942:	83 ec 08             	sub    $0x8,%esp
f0110945:	68 71 82 12 f0       	push   $0xf0128271
f011094a:	50                   	push   %eax
f011094b:	e8 d8 f3 00 00       	call   f011fd28 <strcmp>
f0110950:	83 c4 10             	add    $0x10,%esp
f0110953:	85 c0                	test   %eax,%eax
f0110955:	74 1d                	je     f0110974 <tst_kheap+0xdd>
f0110957:	8b 45 0c             	mov    0xc(%ebp),%eax
f011095a:	83 c0 04             	add    $0x4,%eax
f011095d:	8b 00                	mov    (%eax),%eax
f011095f:	83 ec 08             	sub    $0x8,%esp
f0110962:	68 74 82 12 f0       	push   $0xf0128274
f0110967:	50                   	push   %eax
f0110968:	e8 bb f3 00 00       	call   f011fd28 <strcmp>
f011096d:	83 c4 10             	add    $0x10,%esp
f0110970:	85 c0                	test   %eax,%eax
f0110972:	75 1a                	jne    f011098e <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f0110974:	e8 6d f8 ff ff       	call   f01101e6 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110979:	83 ec 0c             	sub    $0xc,%esp
f011097c:	68 78 82 12 f0       	push   $0xf0128278
f0110981:	e8 05 06 ff ff       	call   f0100f8b <cprintf>
f0110986:	83 c4 10             	add    $0x10,%esp
f0110989:	e9 a0 00 00 00       	jmp    f0110a2e <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f011098e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110991:	83 c0 04             	add    $0x4,%eax
f0110994:	8b 00                	mov    (%eax),%eax
f0110996:	83 ec 08             	sub    $0x8,%esp
f0110999:	68 a5 82 12 f0       	push   $0xf01282a5
f011099e:	50                   	push   %eax
f011099f:	e8 84 f3 00 00       	call   f011fd28 <strcmp>
f01109a4:	83 c4 10             	add    $0x10,%esp
f01109a7:	85 c0                	test   %eax,%eax
f01109a9:	74 1d                	je     f01109c8 <tst_kheap+0x131>
f01109ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109ae:	83 c0 04             	add    $0x4,%eax
f01109b1:	8b 00                	mov    (%eax),%eax
f01109b3:	83 ec 08             	sub    $0x8,%esp
f01109b6:	68 a8 82 12 f0       	push   $0xf01282a8
f01109bb:	50                   	push   %eax
f01109bc:	e8 67 f3 00 00       	call   f011fd28 <strcmp>
f01109c1:	83 c4 10             	add    $0x10,%esp
f01109c4:	85 c0                	test   %eax,%eax
f01109c6:	75 17                	jne    f01109df <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f01109c8:	e8 29 f8 ff ff       	call   f01101f6 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f01109cd:	83 ec 0c             	sub    $0xc,%esp
f01109d0:	68 ac 82 12 f0       	push   $0xf01282ac
f01109d5:	e8 b1 05 ff ff       	call   f0100f8b <cprintf>
f01109da:	83 c4 10             	add    $0x10,%esp
f01109dd:	eb 4f                	jmp    f0110a2e <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f01109df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109e2:	83 c0 04             	add    $0x4,%eax
f01109e5:	8b 00                	mov    (%eax),%eax
f01109e7:	83 ec 08             	sub    $0x8,%esp
f01109ea:	68 d8 82 12 f0       	push   $0xf01282d8
f01109ef:	50                   	push   %eax
f01109f0:	e8 33 f3 00 00       	call   f011fd28 <strcmp>
f01109f5:	83 c4 10             	add    $0x10,%esp
f01109f8:	85 c0                	test   %eax,%eax
f01109fa:	74 1d                	je     f0110a19 <tst_kheap+0x182>
f01109fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109ff:	83 c0 04             	add    $0x4,%eax
f0110a02:	8b 00                	mov    (%eax),%eax
f0110a04:	83 ec 08             	sub    $0x8,%esp
f0110a07:	68 db 82 12 f0       	push   $0xf01282db
f0110a0c:	50                   	push   %eax
f0110a0d:	e8 16 f3 00 00       	call   f011fd28 <strcmp>
f0110a12:	83 c4 10             	add    $0x10,%esp
f0110a15:	85 c0                	test   %eax,%eax
f0110a17:	75 15                	jne    f0110a2e <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f0110a19:	e8 e8 f7 ff ff       	call   f0110206 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110a1e:	83 ec 0c             	sub    $0xc,%esp
f0110a21:	68 e0 82 12 f0       	push   $0xf01282e0
f0110a26:	e8 60 05 ff ff       	call   f0100f8b <cprintf>
f0110a2b:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a31:	83 c0 08             	add    $0x8,%eax
f0110a34:	8b 00                	mov    (%eax),%eax
f0110a36:	83 ec 08             	sub    $0x8,%esp
f0110a39:	68 c8 81 12 f0       	push   $0xf01281c8
f0110a3e:	50                   	push   %eax
f0110a3f:	e8 e4 f2 00 00       	call   f011fd28 <strcmp>
f0110a44:	83 c4 10             	add    $0x10,%esp
f0110a47:	85 c0                	test   %eax,%eax
f0110a49:	0f 85 13 01 00 00    	jne    f0110b62 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a52:	83 c0 0c             	add    $0xc,%eax
f0110a55:	8b 00                	mov    (%eax),%eax
f0110a57:	83 ec 04             	sub    $0x4,%esp
f0110a5a:	6a 0a                	push   $0xa
f0110a5c:	6a 00                	push   $0x0
f0110a5e:	50                   	push   %eax
f0110a5f:	e8 18 f5 00 00       	call   f011ff7c <strtol>
f0110a64:	83 c4 10             	add    $0x10,%esp
f0110a67:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110a6a:	e8 a7 f7 ff ff       	call   f0110216 <isKHeapPlacementStrategyFIRSTFIT>
f0110a6f:	84 c0                	test   %al,%al
f0110a71:	74 54                	je     f0110ac7 <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110a73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110a77:	75 1a                	jne    f0110a93 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110a79:	83 ec 0c             	sub    $0xc,%esp
f0110a7c:	68 0c 83 12 f0       	push   $0xf012830c
f0110a81:	e8 05 05 ff ff       	call   f0100f8b <cprintf>
f0110a86:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110a89:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a8e:	e9 89 02 00 00       	jmp    f0110d1c <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110a93:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110a97:	75 0a                	jne    f0110aa3 <tst_kheap+0x20c>
				test_kmalloc();
f0110a99:	e8 ec 61 00 00       	call   f0116c8a <test_kmalloc>
f0110a9e:	e9 b5 00 00 00       	jmp    f0110b58 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110aa3:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110aa7:	75 0a                	jne    f0110ab3 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110aa9:	e8 68 6d 00 00       	call   f0117816 <test_kmalloc_firstfit1>
f0110aae:	e9 a5 00 00 00       	jmp    f0110b58 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110ab3:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110ab7:	0f 85 9b 00 00 00    	jne    f0110b58 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110abd:	e8 38 78 00 00       	call   f01182fa <test_kmalloc_firstfit2>
f0110ac2:	e9 91 00 00 00       	jmp    f0110b58 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110ac7:	e8 5f f7 ff ff       	call   f011022b <isKHeapPlacementStrategyBESTFIT>
f0110acc:	84 c0                	test   %al,%al
f0110ace:	74 47                	je     f0110b17 <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110ad0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110ad4:	75 1a                	jne    f0110af0 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110ad6:	83 ec 0c             	sub    $0xc,%esp
f0110ad9:	68 5c 83 12 f0       	push   $0xf012835c
f0110ade:	e8 a8 04 ff ff       	call   f0100f8b <cprintf>
f0110ae3:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110ae6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110aeb:	e9 2c 02 00 00       	jmp    f0110d1c <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110af0:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110af4:	75 07                	jne    f0110afd <tst_kheap+0x266>
				test_kmalloc();
f0110af6:	e8 8f 61 00 00       	call   f0116c8a <test_kmalloc>
f0110afb:	eb 5b                	jmp    f0110b58 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110afd:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110b01:	75 07                	jne    f0110b0a <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110b03:	e8 2b c8 00 00       	call   f011d333 <test_kmalloc_bestfit1>
f0110b08:	eb 4e                	jmp    f0110b58 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110b0a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110b0e:	75 48                	jne    f0110b58 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110b10:	e8 3b c8 00 00       	call   f011d350 <test_kmalloc_bestfit2>
f0110b15:	eb 41                	jmp    f0110b58 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110b17:	e8 24 f7 ff ff       	call   f0110240 <isKHeapPlacementStrategyNEXTFIT>
f0110b1c:	84 c0                	test   %al,%al
f0110b1e:	74 38                	je     f0110b58 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110b20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b24:	75 1a                	jne    f0110b40 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110b26:	83 ec 0c             	sub    $0xc,%esp
f0110b29:	68 ac 83 12 f0       	push   $0xf01283ac
f0110b2e:	e8 58 04 ff ff       	call   f0100f8b <cprintf>
f0110b33:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110b36:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b3b:	e9 dc 01 00 00       	jmp    f0110d1c <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110b40:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110b44:	75 07                	jne    f0110b4d <tst_kheap+0x2b6>
				test_kmalloc();
f0110b46:	e8 3f 61 00 00       	call   f0116c8a <test_kmalloc>
f0110b4b:	eb 0b                	jmp    f0110b58 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110b4d:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110b51:	75 05                	jne    f0110b58 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110b53:	e8 be c7 00 00       	call   f011d316 <test_kmalloc_nextfit>
		}
		return 0;
f0110b58:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b5d:	e9 ba 01 00 00       	jmp    f0110d1c <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110b62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b65:	83 c0 08             	add    $0x8,%eax
f0110b68:	8b 00                	mov    (%eax),%eax
f0110b6a:	83 ec 08             	sub    $0x8,%esp
f0110b6d:	68 fa 83 12 f0       	push   $0xf01283fa
f0110b72:	50                   	push   %eax
f0110b73:	e8 b0 f1 00 00       	call   f011fd28 <strcmp>
f0110b78:	83 c4 10             	add    $0x10,%esp
f0110b7b:	85 c0                	test   %eax,%eax
f0110b7d:	75 2f                	jne    f0110bae <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110b7f:	e8 92 f6 ff ff       	call   f0110216 <isKHeapPlacementStrategyFIRSTFIT>
f0110b84:	84 c0                	test   %al,%al
f0110b86:	74 0f                	je     f0110b97 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110b88:	e8 74 82 00 00       	call   f0118e01 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110b8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b92:	e9 85 01 00 00       	jmp    f0110d1c <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110b97:	83 ec 04             	sub    $0x4,%esp
f0110b9a:	68 00 84 12 f0       	push   $0xf0128400
f0110b9f:	68 ac 01 00 00       	push   $0x1ac
f0110ba4:	68 e7 7f 12 f0       	push   $0xf0127fe7
f0110ba9:	e8 8b f7 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110bae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bb1:	83 c0 08             	add    $0x8,%eax
f0110bb4:	8b 00                	mov    (%eax),%eax
f0110bb6:	83 ec 08             	sub    $0x8,%esp
f0110bb9:	68 41 84 12 f0       	push   $0xf0128441
f0110bbe:	50                   	push   %eax
f0110bbf:	e8 64 f1 00 00       	call   f011fd28 <strcmp>
f0110bc4:	83 c4 10             	add    $0x10,%esp
f0110bc7:	85 c0                	test   %eax,%eax
f0110bc9:	75 28                	jne    f0110bf3 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110bcb:	e8 5b f6 ff ff       	call   f011022b <isKHeapPlacementStrategyBESTFIT>
f0110bd0:	84 c0                	test   %al,%al
f0110bd2:	75 09                	jne    f0110bdd <tst_kheap+0x346>
f0110bd4:	e8 3d f6 ff ff       	call   f0110216 <isKHeapPlacementStrategyFIRSTFIT>
f0110bd9:	84 c0                	test   %al,%al
f0110bdb:	74 07                	je     f0110be4 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110bdd:	e8 ee 8a 00 00       	call   f01196d0 <test_kfree_bestfirstfit>
f0110be2:	eb 05                	jmp    f0110be9 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110be4:	e8 a1 c7 00 00       	call   f011d38a <test_kfree>
		}
		return 0;
f0110be9:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bee:	e9 29 01 00 00       	jmp    f0110d1c <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110bf3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bf6:	83 c0 08             	add    $0x8,%eax
f0110bf9:	8b 00                	mov    (%eax),%eax
f0110bfb:	83 ec 08             	sub    $0x8,%esp
f0110bfe:	68 47 84 12 f0       	push   $0xf0128447
f0110c03:	50                   	push   %eax
f0110c04:	e8 1f f1 00 00       	call   f011fd28 <strcmp>
f0110c09:	83 c4 10             	add    $0x10,%esp
f0110c0c:	85 c0                	test   %eax,%eax
f0110c0e:	75 0f                	jne    f0110c1f <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0110c10:	e8 17 a1 00 00       	call   f011ad2c <test_kheap_phys_addr>
		return 0;
f0110c15:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c1a:	e9 fd 00 00 00       	jmp    f0110d1c <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110c1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c22:	83 c0 08             	add    $0x8,%eax
f0110c25:	8b 00                	mov    (%eax),%eax
f0110c27:	83 ec 08             	sub    $0x8,%esp
f0110c2a:	68 51 84 12 f0       	push   $0xf0128451
f0110c2f:	50                   	push   %eax
f0110c30:	e8 f3 f0 00 00       	call   f011fd28 <strcmp>
f0110c35:	83 c4 10             	add    $0x10,%esp
f0110c38:	85 c0                	test   %eax,%eax
f0110c3a:	75 0f                	jne    f0110c4b <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110c3c:	e8 ce ae 00 00       	call   f011bb0f <test_kheap_virt_addr>
		return 0;
f0110c41:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c46:	e9 d1 00 00 00       	jmp    f0110d1c <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110c4b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c4e:	83 c0 08             	add    $0x8,%eax
f0110c51:	8b 00                	mov    (%eax),%eax
f0110c53:	83 ec 08             	sub    $0x8,%esp
f0110c56:	68 20 82 12 f0       	push   $0xf0128220
f0110c5b:	50                   	push   %eax
f0110c5c:	e8 c7 f0 00 00       	call   f011fd28 <strcmp>
f0110c61:	83 c4 10             	add    $0x10,%esp
f0110c64:	85 c0                	test   %eax,%eax
f0110c66:	0f 85 89 00 00 00    	jne    f0110cf5 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110c6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c6f:	83 c0 0c             	add    $0xc,%eax
f0110c72:	8b 00                	mov    (%eax),%eax
f0110c74:	83 ec 04             	sub    $0x4,%esp
f0110c77:	6a 0a                	push   $0xa
f0110c79:	6a 00                	push   $0x0
f0110c7b:	50                   	push   %eax
f0110c7c:	e8 fb f2 00 00       	call   f011ff7c <strtol>
f0110c81:	83 c4 10             	add    $0x10,%esp
f0110c84:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110c87:	e8 8a f5 ff ff       	call   f0110216 <isKHeapPlacementStrategyFIRSTFIT>
f0110c8c:	84 c0                	test   %al,%al
f0110c8e:	74 42                	je     f0110cd2 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110c90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110c94:	75 17                	jne    f0110cad <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110c96:	83 ec 0c             	sub    $0xc,%esp
f0110c99:	68 0c 83 12 f0       	push   $0xf012830c
f0110c9e:	e8 e8 02 ff ff       	call   f0100f8b <cprintf>
f0110ca3:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110ca6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cab:	eb 6f                	jmp    f0110d1c <tst_kheap+0x485>
			}
			if (testNum==1)
f0110cad:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110cb1:	75 07                	jne    f0110cba <tst_kheap+0x423>
				test_krealloc_FF1();
f0110cb3:	e8 50 c9 00 00       	call   f011d608 <test_krealloc_FF1>
f0110cb8:	eb 18                	jmp    f0110cd2 <tst_kheap+0x43b>
			else if (testNum==2)
f0110cba:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110cbe:	75 07                	jne    f0110cc7 <tst_kheap+0x430>
				test_krealloc_FF2();
f0110cc0:	e8 60 c9 00 00       	call   f011d625 <test_krealloc_FF2>
f0110cc5:	eb 0b                	jmp    f0110cd2 <tst_kheap+0x43b>
			else if (testNum==3)
f0110cc7:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110ccb:	75 05                	jne    f0110cd2 <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110ccd:	e8 70 c9 00 00       	call   f011d642 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f0110cd2:	e8 69 f5 ff ff       	call   f0110240 <isKHeapPlacementStrategyNEXTFIT>
f0110cd7:	84 c0                	test   %al,%al
f0110cd9:	74 05                	je     f0110ce0 <tst_kheap+0x449>
		{
			test_krealloc();
f0110cdb:	e8 ee c8 00 00       	call   f011d5ce <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0110ce0:	e8 46 f5 ff ff       	call   f011022b <isKHeapPlacementStrategyBESTFIT>
f0110ce5:	84 c0                	test   %al,%al
f0110ce7:	74 05                	je     f0110cee <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110ce9:	e8 fd c8 00 00       	call   f011d5eb <test_krealloc_BF>
		}
		return 0;
f0110cee:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cf3:	eb 27                	jmp    f0110d1c <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f0110cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cf8:	83 c0 08             	add    $0x8,%eax
f0110cfb:	8b 00                	mov    (%eax),%eax
f0110cfd:	83 ec 08             	sub    $0x8,%esp
f0110d00:	68 5b 84 12 f0       	push   $0xf012845b
f0110d05:	50                   	push   %eax
f0110d06:	e8 1d f0 00 00       	call   f011fd28 <strcmp>
f0110d0b:	83 c4 10             	add    $0x10,%esp
f0110d0e:	85 c0                	test   %eax,%eax
f0110d10:	75 05                	jne    f0110d17 <tst_kheap+0x480>
	{
		test_ksbrk();
f0110d12:	e8 1d bb 00 00       	call   f011c834 <test_ksbrk>
	}
	return 0;
f0110d17:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110d1c:	c9                   	leave  
f0110d1d:	c3                   	ret    

f0110d1e <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f0110d1e:	55                   	push   %ebp
f0110d1f:	89 e5                	mov    %esp,%ebp
f0110d21:	83 ec 28             	sub    $0x28,%esp
f0110d24:	8b 45 14             	mov    0x14(%ebp),%eax
f0110d27:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0110d2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d2d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110d30:	74 1d                	je     f0110d4f <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0110d32:	83 ec 04             	sub    $0x4,%esp
f0110d35:	ff 75 08             	pushl  0x8(%ebp)
f0110d38:	ff 75 0c             	pushl  0xc(%ebp)
f0110d3b:	68 60 84 12 f0       	push   $0xf0128460
f0110d40:	e8 46 02 ff ff       	call   f0100f8b <cprintf>
f0110d45:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d48:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d4d:	eb 55                	jmp    f0110da4 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0110d4f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d52:	8b 40 fc             	mov    -0x4(%eax),%eax
f0110d55:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110d58:	8b 45 10             	mov    0x10(%ebp),%eax
f0110d5b:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110d5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d61:	01 d0                	add    %edx,%eax
f0110d63:	8b 00                	mov    (%eax),%eax
f0110d65:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110d68:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110d6c:	0b 45 10             	or     0x10(%ebp),%eax
f0110d6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0110d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110d75:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110d78:	75 08                	jne    f0110d82 <check_block+0x64>
f0110d7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d7d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110d80:	74 1d                	je     f0110d9f <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0110d82:	ff 75 f0             	pushl  -0x10(%ebp)
f0110d85:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d88:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d8b:	68 90 84 12 f0       	push   $0xf0128490
f0110d90:	e8 f6 01 ff ff       	call   f0100f8b <cprintf>
f0110d95:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d98:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d9d:	eb 05                	jmp    f0110da4 <check_block+0x86>
	}
	return 1;
f0110d9f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110da4:	c9                   	leave  
f0110da5:	c3                   	ret    

f0110da6 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110da6:	55                   	push   %ebp
f0110da7:	89 e5                	mov    %esp,%ebp
f0110da9:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110dac:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0110db1:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110db4:	74 20                	je     f0110dd6 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f0110db6:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0110dbb:	83 ec 04             	sub    $0x4,%esp
f0110dbe:	50                   	push   %eax
f0110dbf:	ff 75 08             	pushl  0x8(%ebp)
f0110dc2:	68 cc 84 12 f0       	push   $0xf01284cc
f0110dc7:	e8 bf 01 ff ff       	call   f0100f8b <cprintf>
f0110dcc:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110dcf:	b8 00 00 00 00       	mov    $0x0,%eax
f0110dd4:	eb 05                	jmp    f0110ddb <check_list_size+0x35>
	}
	return 1;
f0110dd6:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110ddb:	c9                   	leave  
f0110ddc:	c3                   	ret    

f0110ddd <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110ddd:	55                   	push   %ebp
f0110dde:	89 e5                	mov    %esp,%ebp
f0110de0:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f0110de3:	83 ec 04             	sub    $0x4,%esp
f0110de6:	68 00 85 12 f0       	push   $0xf0128500
f0110deb:	6a 3f                	push   $0x3f
f0110ded:	68 60 85 12 f0       	push   $0xf0128560
f0110df2:	e8 42 f5 fe ff       	call   f0100339 <_panic>

f0110df7 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f0110df7:	55                   	push   %ebp
f0110df8:	89 e5                	mov    %esp,%ebp
f0110dfa:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110dfd:	83 ec 04             	sub    $0x4,%esp
f0110e00:	68 84 85 12 f0       	push   $0xf0128584
f0110e05:	6a 61                	push   $0x61
f0110e07:	68 60 85 12 f0       	push   $0xf0128560
f0110e0c:	e8 28 f5 fe ff       	call   f0100339 <_panic>

f0110e11 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0110e11:	55                   	push   %ebp
f0110e12:	89 e5                	mov    %esp,%ebp
f0110e14:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e17:	83 ec 04             	sub    $0x4,%esp
f0110e1a:	68 d4 85 12 f0       	push   $0xf01285d4
f0110e1f:	68 e7 00 00 00       	push   $0xe7
f0110e24:	68 60 85 12 f0       	push   $0xf0128560
f0110e29:	e8 0b f5 fe ff       	call   f0100339 <_panic>

f0110e2e <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f0110e2e:	55                   	push   %ebp
f0110e2f:	89 e5                	mov    %esp,%ebp
f0110e31:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e37:	83 ec 04             	sub    $0x4,%esp
f0110e3a:	68 28 86 12 f0       	push   $0xf0128628
f0110e3f:	68 88 01 00 00       	push   $0x188
f0110e44:	68 60 85 12 f0       	push   $0xf0128560
f0110e49:	e8 eb f4 fe ff       	call   f0100339 <_panic>

f0110e4e <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f0110e4e:	55                   	push   %ebp
f0110e4f:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0110e51:	90                   	nop
f0110e52:	5d                   	pop    %ebp
f0110e53:	c3                   	ret    

f0110e54 <test_free_block_FF>:

void test_free_block_FF()
{
f0110e54:	55                   	push   %ebp
f0110e55:	89 e5                	mov    %esp,%ebp
f0110e57:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e5a:	83 ec 04             	sub    $0x4,%esp
f0110e5d:	68 7c 86 12 f0       	push   $0xf012867c
f0110e62:	68 4e 02 00 00       	push   $0x24e
f0110e67:	68 60 85 12 f0       	push   $0xf0128560
f0110e6c:	e8 c8 f4 fe ff       	call   f0100339 <_panic>

f0110e71 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0110e71:	55                   	push   %ebp
f0110e72:	89 e5                	mov    %esp,%ebp
f0110e74:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e77:	83 ec 04             	sub    $0x4,%esp
f0110e7a:	68 7c 86 12 f0       	push   $0xf012867c
f0110e7f:	68 9a 03 00 00       	push   $0x39a
f0110e84:	68 60 85 12 f0       	push   $0xf0128560
f0110e89:	e8 ab f4 fe ff       	call   f0100339 <_panic>

f0110e8e <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110e8e:	55                   	push   %ebp
f0110e8f:	89 e5                	mov    %esp,%ebp
f0110e91:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0110e94:	83 ec 04             	sub    $0x4,%esp
f0110e97:	68 c9 86 12 f0       	push   $0xf01286c9
f0110e9c:	68 ba 04 00 00       	push   $0x4ba
f0110ea1:	68 60 85 12 f0       	push   $0xf0128560
f0110ea6:	e8 8e f4 fe ff       	call   f0100339 <_panic>

f0110eab <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110eab:	55                   	push   %ebp
f0110eac:	89 e5                	mov    %esp,%ebp
f0110eae:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110eb1:	83 ec 04             	sub    $0x4,%esp
f0110eb4:	68 7c 86 12 f0       	push   $0xf012867c
f0110eb9:	68 c0 04 00 00       	push   $0x4c0
f0110ebe:	68 60 85 12 f0       	push   $0xf0128560
f0110ec3:	e8 71 f4 fe ff       	call   f0100339 <_panic>

f0110ec8 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110ec8:	55                   	push   %ebp
f0110ec9:	89 e5                	mov    %esp,%ebp
f0110ecb:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110ece:	83 ec 04             	sub    $0x4,%esp
f0110ed1:	68 7c 86 12 f0       	push   $0xf012867c
f0110ed6:	68 e7 05 00 00       	push   $0x5e7
f0110edb:	68 60 85 12 f0       	push   $0xf0128560
f0110ee0:	e8 54 f4 fe ff       	call   f0100339 <_panic>

f0110ee5 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0110ee5:	55                   	push   %ebp
f0110ee6:	89 e5                	mov    %esp,%ebp
f0110ee8:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110eeb:	e8 f0 aa ff ff       	call   f010b9e0 <get_cpu_proc>
f0110ef0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0110ef3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110ef7:	75 16                	jne    f0110f0f <sys_check_LRU_lists+0x2a>
f0110ef9:	68 dc 86 12 f0       	push   $0xf01286dc
f0110efe:	68 ec 86 12 f0       	push   $0xf01286ec
f0110f03:	6a 10                	push   $0x10
f0110f05:	68 01 87 12 f0       	push   $0xf0128701
f0110f0a:	e8 2a f4 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0110f0f:	83 ec 0c             	sub    $0xc,%esp
f0110f12:	68 20 87 12 f0       	push   $0xf0128720
f0110f17:	e8 6f 00 ff ff       	call   f0100f8b <cprintf>
f0110f1c:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0110f1f:	83 ec 0c             	sub    $0xc,%esp
f0110f22:	ff 75 e0             	pushl  -0x20(%ebp)
f0110f25:	e8 38 95 ff ff       	call   f010a462 <env_page_ws_print>
f0110f2a:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0110f2d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110f30:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0110f33:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0110f3a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0110f41:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110f45:	0f 84 a5 00 00 00    	je     f0110ff0 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0110f4b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110f52:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110f55:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110f5b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110f5e:	eb 4a                	jmp    f0110faa <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0110f60:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110f63:	8b 00                	mov    (%eax),%eax
f0110f65:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110f68:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110f6b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110f70:	89 c2                	mov    %eax,%edx
f0110f72:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110f75:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110f7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0110f7f:	01 c8                	add    %ecx,%eax
f0110f81:	8b 00                	mov    (%eax),%eax
f0110f83:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110f86:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110f89:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110f8e:	39 c2                	cmp    %eax,%edx
f0110f90:	74 09                	je     f0110f9b <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0110f92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110f99:	eb 3e                	jmp    f0110fd9 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0110f9b:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110f9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110fa1:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110fa7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110faa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110fae:	74 08                	je     f0110fb8 <sys_check_LRU_lists+0xd3>
f0110fb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110fb3:	8b 40 10             	mov    0x10(%eax),%eax
f0110fb6:	eb 05                	jmp    f0110fbd <sys_check_LRU_lists+0xd8>
f0110fb8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fbd:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110fc0:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0110fc6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110fc9:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110fcf:	85 c0                	test   %eax,%eax
f0110fd1:	75 8d                	jne    f0110f60 <sys_check_LRU_lists+0x7b>
f0110fd3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110fd7:	75 87                	jne    f0110f60 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0110fd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110fdc:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f0110fe2:	8b 45 10             	mov    0x10(%ebp),%eax
f0110fe5:	39 c2                	cmp    %eax,%edx
f0110fe7:	74 07                	je     f0110ff0 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0110fe9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0110ff0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0110ff4:	0f 84 a5 00 00 00    	je     f011109f <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0110ffa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111001:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111004:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011100a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011100d:	eb 4a                	jmp    f0111059 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f011100f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111012:	8b 00                	mov    (%eax),%eax
f0111014:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111017:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011101a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011101f:	89 c2                	mov    %eax,%edx
f0111021:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111024:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011102b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011102e:	01 c8                	add    %ecx,%eax
f0111030:	8b 00                	mov    (%eax),%eax
f0111032:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0111035:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111038:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011103d:	39 c2                	cmp    %eax,%edx
f011103f:	74 09                	je     f011104a <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0111041:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0111048:	eb 3e                	jmp    f0111088 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f011104a:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011104d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111050:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111056:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111059:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011105d:	74 08                	je     f0111067 <sys_check_LRU_lists+0x182>
f011105f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111062:	8b 40 10             	mov    0x10(%eax),%eax
f0111065:	eb 05                	jmp    f011106c <sys_check_LRU_lists+0x187>
f0111067:	b8 00 00 00 00       	mov    $0x0,%eax
f011106c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011106f:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0111075:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111078:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011107e:	85 c0                	test   %eax,%eax
f0111080:	75 8d                	jne    f011100f <sys_check_LRU_lists+0x12a>
f0111082:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111086:	75 87                	jne    f011100f <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0111088:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011108b:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f0111091:	8b 45 14             	mov    0x14(%ebp),%eax
f0111094:	39 c2                	cmp    %eax,%edx
f0111096:	74 07                	je     f011109f <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0111098:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f011109f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01110a2:	23 45 f0             	and    -0x10(%ebp),%eax
}
f01110a5:	c9                   	leave  
f01110a6:	c3                   	ret    

f01110a7 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f01110a7:	55                   	push   %ebp
f01110a8:	89 e5                	mov    %esp,%ebp
f01110aa:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01110ad:	e8 2e a9 ff ff       	call   f010b9e0 <get_cpu_proc>
f01110b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01110b5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01110b9:	75 16                	jne    f01110d1 <sys_check_LRU_lists_free+0x2a>
f01110bb:	68 dc 86 12 f0       	push   $0xf01286dc
f01110c0:	68 ec 86 12 f0       	push   $0xf01286ec
f01110c5:	6a 45                	push   $0x45
f01110c7:	68 01 87 12 f0       	push   $0xf0128701
f01110cc:	e8 68 f2 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f01110d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01110d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f01110d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01110de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01110e1:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01110e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01110ea:	eb 65                	jmp    f0111151 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f01110ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01110f3:	eb 3a                	jmp    f011112f <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01110f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01110f8:	8b 00                	mov    (%eax),%eax
f01110fa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01110fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111100:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111105:	89 c2                	mov    %eax,%edx
f0111107:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011110a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111111:	8b 45 08             	mov    0x8(%ebp),%eax
f0111114:	01 c8                	add    %ecx,%eax
f0111116:	8b 00                	mov    (%eax),%eax
f0111118:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011111b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011111e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111123:	39 c2                	cmp    %eax,%edx
f0111125:	75 05                	jne    f011112c <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0111127:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011112a:	eb 0b                	jmp    f0111137 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f011112c:	ff 45 ec             	incl   -0x14(%ebp)
f011112f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111132:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111135:	7c be                	jl     f01110f5 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111137:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011113b:	7e 08                	jle    f0111145 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f011113d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111140:	e9 ed 00 00 00       	jmp    f0111232 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111145:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111148:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011114e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111151:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111155:	74 08                	je     f011115f <sys_check_LRU_lists_free+0xb8>
f0111157:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011115a:	8b 40 10             	mov    0x10(%eax),%eax
f011115d:	eb 05                	jmp    f0111164 <sys_check_LRU_lists_free+0xbd>
f011115f:	b8 00 00 00 00       	mov    $0x0,%eax
f0111164:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111167:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f011116d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111170:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111176:	85 c0                	test   %eax,%eax
f0111178:	0f 85 6e ff ff ff    	jne    f01110ec <sys_check_LRU_lists_free+0x45>
f011117e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111182:	0f 85 64 ff ff ff    	jne    f01110ec <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111188:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011118b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111191:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111194:	eb 62                	jmp    f01111f8 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111196:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011119d:	eb 3a                	jmp    f01111d9 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011119f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01111a2:	8b 00                	mov    (%eax),%eax
f01111a4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01111a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111af:	89 c2                	mov    %eax,%edx
f01111b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01111b4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01111bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01111be:	01 c8                	add    %ecx,%eax
f01111c0:	8b 00                	mov    (%eax),%eax
f01111c2:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01111c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01111c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111cd:	39 c2                	cmp    %eax,%edx
f01111cf:	75 05                	jne    f01111d6 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f01111d1:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01111d4:	eb 0b                	jmp    f01111e1 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f01111d6:	ff 45 e8             	incl   -0x18(%ebp)
f01111d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01111dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01111df:	7c be                	jl     f011119f <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01111e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01111e5:	7e 05                	jle    f01111ec <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f01111e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01111ea:	eb 46                	jmp    f0111232 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01111ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111ef:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01111f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01111f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111fc:	74 08                	je     f0111206 <sys_check_LRU_lists_free+0x15f>
f01111fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111201:	8b 40 10             	mov    0x10(%eax),%eax
f0111204:	eb 05                	jmp    f011120b <sys_check_LRU_lists_free+0x164>
f0111206:	b8 00 00 00 00       	mov    $0x0,%eax
f011120b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011120e:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0111214:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111217:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011121d:	85 c0                	test   %eax,%eax
f011121f:	0f 85 71 ff ff ff    	jne    f0111196 <sys_check_LRU_lists_free+0xef>
f0111225:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111229:	0f 85 67 ff ff ff    	jne    f0111196 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f011122f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111232:	c9                   	leave  
f0111233:	c3                   	ret    

f0111234 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0111234:	55                   	push   %ebp
f0111235:	89 e5                	mov    %esp,%ebp
f0111237:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f011123a:	e8 a1 a7 ff ff       	call   f010b9e0 <get_cpu_proc>
f011123f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0111242:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111246:	75 16                	jne    f011125e <sys_check_WS_list+0x2a>
f0111248:	68 dc 86 12 f0       	push   $0xf01286dc
f011124d:	68 ec 86 12 f0       	push   $0xf01286ec
f0111252:	6a 79                	push   $0x79
f0111254:	68 01 87 12 f0       	push   $0xf0128701
f0111259:	e8 db f0 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011125e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111261:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0111264:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f011126b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011126f:	74 06                	je     f0111277 <sys_check_WS_list+0x43>
f0111271:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111275:	75 1f                	jne    f0111296 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111277:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011127a:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0111280:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111283:	39 c2                	cmp    %eax,%edx
f0111285:	74 0f                	je     f0111296 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111287:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011128e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111291:	e9 15 03 00 00       	jmp    f01115ab <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111296:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011129a:	74 39                	je     f01112d5 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011129c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011129f:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01112a5:	8b 00                	mov    (%eax),%eax
f01112a7:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01112aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01112ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112b2:	89 c2                	mov    %eax,%edx
f01112b4:	8b 45 10             	mov    0x10(%ebp),%eax
f01112b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f01112ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01112bd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112c2:	39 c2                	cmp    %eax,%edx
f01112c4:	74 0f                	je     f01112d5 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f01112c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01112cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01112d0:	e9 d6 02 00 00       	jmp    f01115ab <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f01112d5:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f01112d9:	0f 85 3c 01 00 00    	jne    f011141b <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f01112df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f01112e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01112ea:	74 4c                	je     f0111338 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01112ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01112f3:	eb 3b                	jmp    f0111330 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01112f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01112ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0111302:	01 d0                	add    %edx,%eax
f0111304:	8b 00                	mov    (%eax),%eax
f0111306:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0111309:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011130c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111311:	89 c2                	mov    %eax,%edx
f0111313:	8b 45 10             	mov    0x10(%ebp),%eax
f0111316:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0111319:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011131c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111321:	39 c2                	cmp    %eax,%edx
f0111323:	75 08                	jne    f011132d <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0111325:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111328:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f011132b:	eb 0b                	jmp    f0111338 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011132d:	ff 45 e8             	incl   -0x18(%ebp)
f0111330:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111333:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111336:	7c bd                	jl     f01112f5 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0111338:	83 ec 08             	sub    $0x8,%esp
f011133b:	ff 75 ec             	pushl  -0x14(%ebp)
f011133e:	68 48 87 12 f0       	push   $0xf0128748
f0111343:	e8 43 fc fe ff       	call   f0100f8b <cprintf>
f0111348:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f011134b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011134e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111354:	85 c0                	test   %eax,%eax
f0111356:	74 0e                	je     f0111366 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0111358:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011135b:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111361:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111364:	eb 0c                	jmp    f0111372 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111366:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111369:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011136f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0111372:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111375:	8b 00                	mov    (%eax),%eax
f0111377:	83 ec 08             	sub    $0x8,%esp
f011137a:	50                   	push   %eax
f011137b:	68 67 87 12 f0       	push   $0xf0128767
f0111380:	e8 06 fc fe ff       	call   f0100f8b <cprintf>
f0111385:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111388:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011138f:	eb 79                	jmp    f011140a <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0111391:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111394:	8b 00                	mov    (%eax),%eax
f0111396:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111399:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011139c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01113a1:	89 c2                	mov    %eax,%edx
f01113a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01113a6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01113ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01113b0:	01 c8                	add    %ecx,%eax
f01113b2:	8b 00                	mov    (%eax),%eax
f01113b4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01113b7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01113ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01113bf:	39 c2                	cmp    %eax,%edx
f01113c1:	74 0c                	je     f01113cf <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f01113c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01113ca:	e9 d9 01 00 00       	jmp    f01115a8 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f01113cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01113d2:	40                   	inc    %eax
f01113d3:	89 c2                	mov    %eax,%edx
f01113d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113d8:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f01113de:	89 d0                	mov    %edx,%eax
f01113e0:	ba 00 00 00 00       	mov    $0x0,%edx
f01113e5:	f7 f1                	div    %ecx
f01113e7:	89 d0                	mov    %edx,%eax
f01113e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f01113ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113ef:	8b 40 10             	mov    0x10(%eax),%eax
f01113f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f01113f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01113f9:	75 0c                	jne    f0111407 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01113fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113fe:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111404:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111407:	ff 45 e4             	incl   -0x1c(%ebp)
f011140a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011140d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111410:	0f 8c 7b ff ff ff    	jl     f0111391 <sys_check_WS_list+0x15d>
f0111416:	e9 8d 01 00 00       	jmp    f01115a8 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f011141b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011141f:	74 0a                	je     f011142b <sys_check_WS_list+0x1f7>
f0111421:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0111425:	0f 85 be 00 00 00    	jne    f01114e9 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011142b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0111432:	e9 a1 00 00 00       	jmp    f01114d8 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0111437:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011143e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111441:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111447:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011144a:	eb 47                	jmp    f0111493 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011144c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011144f:	8b 00                	mov    (%eax),%eax
f0111451:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0111454:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111457:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011145c:	89 c2                	mov    %eax,%edx
f011145e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111461:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111468:	8b 45 08             	mov    0x8(%ebp),%eax
f011146b:	01 c8                	add    %ecx,%eax
f011146d:	8b 00                	mov    (%eax),%eax
f011146f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0111472:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111475:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011147a:	39 c2                	cmp    %eax,%edx
f011147c:	75 09                	jne    f0111487 <sys_check_WS_list+0x253>
				{
					found = 1;
f011147e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0111485:	eb 3b                	jmp    f01114c2 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111487:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011148a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111490:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111493:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111497:	74 08                	je     f01114a1 <sys_check_WS_list+0x26d>
f0111499:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011149c:	8b 40 10             	mov    0x10(%eax),%eax
f011149f:	eb 05                	jmp    f01114a6 <sys_check_WS_list+0x272>
f01114a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01114a6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01114a9:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01114af:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114b2:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01114b8:	85 c0                	test   %eax,%eax
f01114ba:	75 90                	jne    f011144c <sys_check_WS_list+0x218>
f01114bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114c0:	75 8a                	jne    f011144c <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f01114c2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01114c6:	75 0d                	jne    f01114d5 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f01114c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01114cf:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01114d0:	e9 d3 00 00 00       	jmp    f01115a8 <sys_check_WS_list+0x374>
f01114d5:	ff 45 e0             	incl   -0x20(%ebp)
f01114d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114db:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01114de:	0f 8c 53 ff ff ff    	jl     f0111437 <sys_check_WS_list+0x203>
f01114e4:	e9 bf 00 00 00       	jmp    f01115a8 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f01114e9:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f01114ed:	0f 85 b5 00 00 00    	jne    f01115a8 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01114f3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01114fa:	e9 9d 00 00 00       	jmp    f011159c <sys_check_WS_list+0x368>
		{
			bool found = 0;
f01114ff:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111506:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111509:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011150f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111512:	eb 47                	jmp    f011155b <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0111514:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111517:	8b 00                	mov    (%eax),%eax
f0111519:	89 45 b0             	mov    %eax,-0x50(%ebp)
f011151c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011151f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111524:	89 c2                	mov    %eax,%edx
f0111526:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111529:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111530:	8b 45 08             	mov    0x8(%ebp),%eax
f0111533:	01 c8                	add    %ecx,%eax
f0111535:	8b 00                	mov    (%eax),%eax
f0111537:	89 45 ac             	mov    %eax,-0x54(%ebp)
f011153a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011153d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111542:	39 c2                	cmp    %eax,%edx
f0111544:	75 09                	jne    f011154f <sys_check_WS_list+0x31b>
				{
					found = 1;
f0111546:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f011154d:	eb 3b                	jmp    f011158a <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011154f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111552:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111558:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011155b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011155f:	74 08                	je     f0111569 <sys_check_WS_list+0x335>
f0111561:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111564:	8b 40 10             	mov    0x10(%eax),%eax
f0111567:	eb 05                	jmp    f011156e <sys_check_WS_list+0x33a>
f0111569:	b8 00 00 00 00       	mov    $0x0,%eax
f011156e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111571:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111577:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011157a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111580:	85 c0                	test   %eax,%eax
f0111582:	75 90                	jne    f0111514 <sys_check_WS_list+0x2e0>
f0111584:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111588:	75 8a                	jne    f0111514 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f011158a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011158e:	74 09                	je     f0111599 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0111590:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111597:	eb 0f                	jmp    f01115a8 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111599:	ff 45 d8             	incl   -0x28(%ebp)
f011159c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011159f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01115a2:	0f 8c 57 ff ff ff    	jl     f01114ff <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f01115a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f01115ab:	c9                   	leave  
f01115ac:	c3                   	ret    

f01115ad <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01115ad:	55                   	push   %ebp
f01115ae:	89 e5                	mov    %esp,%ebp
f01115b0:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01115b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f01115ba:	8b 15 e4 35 ec f0    	mov    0xf0ec35e4,%edx
f01115c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01115c3:	39 c2                	cmp    %eax,%edx
f01115c5:	74 0a                	je     f01115d1 <hasExpectedCommands+0x24>
		return 0;
f01115c7:	b8 00 00 00 00       	mov    $0x0,%eax
f01115cc:	e9 8b 00 00 00       	jmp    f011165c <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f01115d1:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f01115d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01115d9:	eb 55                	jmp    f0111630 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01115db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01115e2:	eb 2a                	jmp    f011160e <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f01115e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01115ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01115f1:	01 d0                	add    %edx,%eax
f01115f3:	8b 10                	mov    (%eax),%edx
f01115f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01115f8:	8b 00                	mov    (%eax),%eax
f01115fa:	83 ec 08             	sub    $0x8,%esp
f01115fd:	52                   	push   %edx
f01115fe:	50                   	push   %eax
f01115ff:	e8 24 e7 00 00       	call   f011fd28 <strcmp>
f0111604:	83 c4 10             	add    $0x10,%esp
f0111607:	85 c0                	test   %eax,%eax
f0111609:	74 0d                	je     f0111618 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011160b:	ff 45 f0             	incl   -0x10(%ebp)
f011160e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111611:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111614:	7c ce                	jl     f01115e4 <hasExpectedCommands+0x37>
f0111616:	eb 01                	jmp    f0111619 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0111618:	90                   	nop
		if (i == commandsCount)
f0111619:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011161c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011161f:	75 07                	jne    f0111628 <hasExpectedCommands+0x7b>
			return 0;
f0111621:	b8 00 00 00 00       	mov    $0x0,%eax
f0111626:	eb 34                	jmp    f011165c <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0111628:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f011162d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111630:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111634:	74 08                	je     f011163e <hasExpectedCommands+0x91>
f0111636:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111639:	8b 40 10             	mov    0x10(%eax),%eax
f011163c:	eb 05                	jmp    f0111643 <hasExpectedCommands+0x96>
f011163e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111643:	a3 e0 35 ec f0       	mov    %eax,0xf0ec35e0
f0111648:	a1 e0 35 ec f0       	mov    0xf0ec35e0,%eax
f011164d:	85 c0                	test   %eax,%eax
f011164f:	75 8a                	jne    f01115db <hasExpectedCommands+0x2e>
f0111651:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111655:	75 84                	jne    f01115db <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0111657:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011165c:	c9                   	leave  
f011165d:	c3                   	ret    

f011165e <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f011165e:	55                   	push   %ebp
f011165f:	89 e5                	mov    %esp,%ebp
f0111661:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111664:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011166b:	eb 2e                	jmp    f011169b <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f011166d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111670:	89 d0                	mov    %edx,%eax
f0111672:	01 c0                	add    %eax,%eax
f0111674:	01 d0                	add    %edx,%eax
f0111676:	c1 e0 03             	shl    $0x3,%eax
f0111679:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f011167e:	8b 00                	mov    (%eax),%eax
f0111680:	83 ec 08             	sub    $0x8,%esp
f0111683:	ff 75 08             	pushl  0x8(%ebp)
f0111686:	50                   	push   %eax
f0111687:	e8 9c e6 00 00       	call   f011fd28 <strcmp>
f011168c:	83 c4 10             	add    $0x10,%esp
f011168f:	85 c0                	test   %eax,%eax
f0111691:	75 05                	jne    f0111698 <getIndexOfCommand+0x3a>
			return i;
f0111693:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111696:	eb 14                	jmp    f01116ac <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111698:	ff 45 f4             	incl   -0xc(%ebp)
f011169b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011169e:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01116a3:	39 c2                	cmp    %eax,%edx
f01116a5:	72 c6                	jb     f011166d <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01116a7:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01116ac:	c9                   	leave  
f01116ad:	c3                   	ret    

f01116ae <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01116ae:	55                   	push   %ebp
f01116af:	89 e5                	mov    %esp,%ebp
f01116b1:	57                   	push   %edi
f01116b2:	56                   	push   %esi
f01116b3:	53                   	push   %ebx
f01116b4:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f01116ba:	83 ec 0c             	sub    $0xc,%esp
f01116bd:	68 a0 87 12 f0       	push   $0xf01287a0
f01116c2:	e8 c4 f8 fe ff       	call   f0100f8b <cprintf>
f01116c7:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01116ca:	83 ec 0c             	sub    $0xc,%esp
f01116cd:	68 c4 87 12 f0       	push   $0xf01287c4
f01116d2:	e8 b4 f8 fe ff       	call   f0100f8b <cprintf>
f01116d7:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f01116da:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f01116e1:	c7 45 8c df 87 12 f0 	movl   $0xf01287df,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f01116e8:	83 ec 08             	sub    $0x8,%esp
f01116eb:	8d 45 8c             	lea    -0x74(%ebp),%eax
f01116ee:	50                   	push   %eax
f01116ef:	6a 01                	push   $0x1
f01116f1:	e8 da 0a ff ff       	call   f01021d0 <process_command>
f01116f6:	83 c4 10             	add    $0x10,%esp
f01116f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01116fc:	83 ec 0c             	sub    $0xc,%esp
f01116ff:	68 ec 87 12 f0       	push   $0xf01287ec
f0111704:	e8 82 f8 fe ff       	call   f0100f8b <cprintf>
f0111709:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f011170c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011170f:	83 ec 0c             	sub    $0xc,%esp
f0111712:	50                   	push   %eax
f0111713:	e8 46 ff ff ff       	call   f011165e <getIndexOfCommand>
f0111718:	83 c4 10             	add    $0x10,%esp
f011171b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011171e:	75 0f                	jne    f011172f <TestAutoCompleteCommand+0x81>
f0111720:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f0111725:	85 c0                	test   %eax,%eax
f0111727:	75 06                	jne    f011172f <TestAutoCompleteCommand+0x81>
		eval += 15;
f0111729:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011172d:	eb 10                	jmp    f011173f <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011172f:	83 ec 0c             	sub    $0xc,%esp
f0111732:	68 1c 88 12 f0       	push   $0xf012881c
f0111737:	e8 4f f8 fe ff       	call   f0100f8b <cprintf>
f011173c:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f011173f:	83 ec 0c             	sub    $0xc,%esp
f0111742:	68 6c 88 12 f0       	push   $0xf012886c
f0111747:	e8 3f f8 fe ff       	call   f0100f8b <cprintf>
f011174c:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f011174f:	c7 45 88 92 88 12 f0 	movl   $0xf0128892,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0111756:	83 ec 08             	sub    $0x8,%esp
f0111759:	8d 45 88             	lea    -0x78(%ebp),%eax
f011175c:	50                   	push   %eax
f011175d:	6a 01                	push   $0x1
f011175f:	e8 6c 0a ff ff       	call   f01021d0 <process_command>
f0111764:	83 c4 10             	add    $0x10,%esp
f0111767:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f011176a:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011176e:	75 30                	jne    f01117a0 <TestAutoCompleteCommand+0xf2>
f0111770:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111773:	bb 70 8c 12 f0       	mov    $0xf0128c70,%ebx
f0111778:	ba 03 00 00 00       	mov    $0x3,%edx
f011177d:	89 c7                	mov    %eax,%edi
f011177f:	89 de                	mov    %ebx,%esi
f0111781:	89 d1                	mov    %edx,%ecx
f0111783:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111785:	83 ec 08             	sub    $0x8,%esp
f0111788:	6a 03                	push   $0x3
f011178a:	8d 45 90             	lea    -0x70(%ebp),%eax
f011178d:	50                   	push   %eax
f011178e:	e8 1a fe ff ff       	call   f01115ad <hasExpectedCommands>
f0111793:	83 c4 10             	add    $0x10,%esp
f0111796:	85 c0                	test   %eax,%eax
f0111798:	74 06                	je     f01117a0 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f011179a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011179e:	eb 10                	jmp    f01117b0 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01117a0:	83 ec 0c             	sub    $0xc,%esp
f01117a3:	68 98 88 12 f0       	push   $0xf0128898
f01117a8:	e8 de f7 fe ff       	call   f0100f8b <cprintf>
f01117ad:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f01117b0:	83 ec 0c             	sub    $0xc,%esp
f01117b3:	68 e8 88 12 f0       	push   $0xf01288e8
f01117b8:	e8 ce f7 fe ff       	call   f0100f8b <cprintf>
f01117bd:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f01117c0:	c7 45 84 0d 89 12 f0 	movl   $0xf012890d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f01117c7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01117ca:	83 ec 04             	sub    $0x4,%esp
f01117cd:	50                   	push   %eax
f01117ce:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01117d1:	50                   	push   %eax
f01117d2:	68 10 89 12 f0       	push   $0xf0128910
f01117d7:	e8 af f7 fe ff       	call   f0100f8b <cprintf>
f01117dc:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f01117df:	83 ec 08             	sub    $0x8,%esp
f01117e2:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01117e5:	50                   	push   %eax
f01117e6:	6a 01                	push   $0x1
f01117e8:	e8 e3 09 ff ff       	call   f01021d0 <process_command>
f01117ed:	83 c4 10             	add    $0x10,%esp
f01117f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f01117f3:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01117f7:	75 1b                	jne    f0111814 <TestAutoCompleteCommand+0x166>
f01117f9:	83 ec 08             	sub    $0x8,%esp
f01117fc:	6a 01                	push   $0x1
f01117fe:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111801:	50                   	push   %eax
f0111802:	e8 a6 fd ff ff       	call   f01115ad <hasExpectedCommands>
f0111807:	83 c4 10             	add    $0x10,%esp
f011180a:	85 c0                	test   %eax,%eax
f011180c:	74 06                	je     f0111814 <TestAutoCompleteCommand+0x166>
		eval += 15;
f011180e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111812:	eb 10                	jmp    f0111824 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111814:	83 ec 0c             	sub    $0xc,%esp
f0111817:	68 30 89 12 f0       	push   $0xf0128930
f011181c:	e8 6a f7 fe ff       	call   f0100f8b <cprintf>
f0111821:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0111824:	83 ec 0c             	sub    $0xc,%esp
f0111827:	68 88 89 12 f0       	push   $0xf0128988
f011182c:	e8 5a f7 fe ff       	call   f0100f8b <cprintf>
f0111831:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0111834:	c7 45 80 ae 89 12 f0 	movl   $0xf01289ae,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f011183b:	83 ec 08             	sub    $0x8,%esp
f011183e:	8d 45 80             	lea    -0x80(%ebp),%eax
f0111841:	50                   	push   %eax
f0111842:	6a 01                	push   $0x1
f0111844:	e8 87 09 ff ff       	call   f01021d0 <process_command>
f0111849:	83 c4 10             	add    $0x10,%esp
f011184c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f011184f:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111853:	75 0f                	jne    f0111864 <TestAutoCompleteCommand+0x1b6>
f0111855:	a1 e4 35 ec f0       	mov    0xf0ec35e4,%eax
f011185a:	85 c0                	test   %eax,%eax
f011185c:	75 06                	jne    f0111864 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f011185e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111862:	eb 10                	jmp    f0111874 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111864:	83 ec 0c             	sub    $0xc,%esp
f0111867:	68 b4 89 12 f0       	push   $0xf01289b4
f011186c:	e8 1a f7 fe ff       	call   f0100f8b <cprintf>
f0111871:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111874:	83 ec 0c             	sub    $0xc,%esp
f0111877:	68 04 8a 12 f0       	push   $0xf0128a04
f011187c:	e8 0a f7 fe ff       	call   f0100f8b <cprintf>
f0111881:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111884:	c7 85 7c ff ff ff 29 	movl   $0xf0128a29,-0x84(%ebp)
f011188b:	8a 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f011188e:	83 ec 08             	sub    $0x8,%esp
f0111891:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111897:	50                   	push   %eax
f0111898:	6a 01                	push   $0x1
f011189a:	e8 31 09 ff ff       	call   f01021d0 <process_command>
f011189f:	83 c4 10             	add    $0x10,%esp
f01118a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f01118a5:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01118a9:	75 30                	jne    f01118db <TestAutoCompleteCommand+0x22d>
f01118ab:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01118ae:	bb 00 8d 12 f0       	mov    $0xf0128d00,%ebx
f01118b3:	ba 0c 00 00 00       	mov    $0xc,%edx
f01118b8:	89 c7                	mov    %eax,%edi
f01118ba:	89 de                	mov    %ebx,%esi
f01118bc:	89 d1                	mov    %edx,%ecx
f01118be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01118c0:	83 ec 08             	sub    $0x8,%esp
f01118c3:	6a 0c                	push   $0xc
f01118c5:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01118c8:	50                   	push   %eax
f01118c9:	e8 df fc ff ff       	call   f01115ad <hasExpectedCommands>
f01118ce:	83 c4 10             	add    $0x10,%esp
f01118d1:	85 c0                	test   %eax,%eax
f01118d3:	74 06                	je     f01118db <TestAutoCompleteCommand+0x22d>
		eval += 10;
f01118d5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01118d9:	eb 10                	jmp    f01118eb <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f01118db:	83 ec 0c             	sub    $0xc,%esp
f01118de:	68 2c 8a 12 f0       	push   $0xf0128a2c
f01118e3:	e8 a3 f6 fe ff       	call   f0100f8b <cprintf>
f01118e8:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f01118eb:	83 ec 0c             	sub    $0xc,%esp
f01118ee:	68 84 8a 12 f0       	push   $0xf0128a84
f01118f3:	e8 93 f6 fe ff       	call   f0100f8b <cprintf>
f01118f8:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01118fb:	c7 85 78 ff ff ff a9 	movl   $0xf0128aa9,-0x88(%ebp)
f0111902:	8a 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111905:	83 ec 08             	sub    $0x8,%esp
f0111908:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f011190e:	50                   	push   %eax
f011190f:	6a 01                	push   $0x1
f0111911:	e8 ba 08 ff ff       	call   f01021d0 <process_command>
f0111916:	83 c4 10             	add    $0x10,%esp
f0111919:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f011191c:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111920:	75 30                	jne    f0111952 <TestAutoCompleteCommand+0x2a4>
f0111922:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111925:	bb 48 8d 12 f0       	mov    $0xf0128d48,%ebx
f011192a:	ba 05 00 00 00       	mov    $0x5,%edx
f011192f:	89 c7                	mov    %eax,%edi
f0111931:	89 de                	mov    %ebx,%esi
f0111933:	89 d1                	mov    %edx,%ecx
f0111935:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111937:	83 ec 08             	sub    $0x8,%esp
f011193a:	6a 05                	push   $0x5
f011193c:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011193f:	50                   	push   %eax
f0111940:	e8 68 fc ff ff       	call   f01115ad <hasExpectedCommands>
f0111945:	83 c4 10             	add    $0x10,%esp
f0111948:	85 c0                	test   %eax,%eax
f011194a:	74 06                	je     f0111952 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f011194c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111950:	eb 10                	jmp    f0111962 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111952:	83 ec 0c             	sub    $0xc,%esp
f0111955:	68 ac 8a 12 f0       	push   $0xf0128aac
f011195a:	e8 2c f6 fe ff       	call   f0100f8b <cprintf>
f011195f:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111962:	83 ec 0c             	sub    $0xc,%esp
f0111965:	68 04 8b 12 f0       	push   $0xf0128b04
f011196a:	e8 1c f6 fe ff       	call   f0100f8b <cprintf>
f011196f:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111972:	c7 85 70 ff ff ff 30 	movl   $0xf0128b30,-0x90(%ebp)
f0111979:	8b 12 f0 
f011197c:	c7 85 74 ff ff ff 35 	movl   $0xf0128b35,-0x8c(%ebp)
f0111983:	8b 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111986:	83 ec 08             	sub    $0x8,%esp
f0111989:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f011198f:	50                   	push   %eax
f0111990:	6a 02                	push   $0x2
f0111992:	e8 39 08 ff ff       	call   f01021d0 <process_command>
f0111997:	83 c4 10             	add    $0x10,%esp
f011199a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f011199d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01119a3:	83 ec 0c             	sub    $0xc,%esp
f01119a6:	50                   	push   %eax
f01119a7:	e8 b2 fc ff ff       	call   f011165e <getIndexOfCommand>
f01119ac:	83 c4 10             	add    $0x10,%esp
f01119af:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01119b2:	75 0f                	jne    f01119c3 <TestAutoCompleteCommand+0x315>
f01119b4:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f01119b9:	85 c0                	test   %eax,%eax
f01119bb:	75 06                	jne    f01119c3 <TestAutoCompleteCommand+0x315>
		eval += 10;
f01119bd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01119c1:	eb 10                	jmp    f01119d3 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01119c3:	83 ec 0c             	sub    $0xc,%esp
f01119c6:	68 3c 8b 12 f0       	push   $0xf0128b3c
f01119cb:	e8 bb f5 fe ff       	call   f0100f8b <cprintf>
f01119d0:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f01119d3:	83 ec 0c             	sub    $0xc,%esp
f01119d6:	68 8c 8b 12 f0       	push   $0xf0128b8c
f01119db:	e8 ab f5 fe ff       	call   f0100f8b <cprintf>
f01119e0:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f01119e3:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01119e9:	bb 70 8d 12 f0       	mov    $0xf0128d70,%ebx
f01119ee:	ba 03 00 00 00       	mov    $0x3,%edx
f01119f3:	89 c7                	mov    %eax,%edi
f01119f5:	89 de                	mov    %ebx,%esi
f01119f7:	89 d1                	mov    %edx,%ecx
f01119f9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01119fb:	83 ec 08             	sub    $0x8,%esp
f01119fe:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111a04:	50                   	push   %eax
f0111a05:	6a 03                	push   $0x3
f0111a07:	e8 c4 07 ff ff       	call   f01021d0 <process_command>
f0111a0c:	83 c4 10             	add    $0x10,%esp
f0111a0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111a12:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111a18:	83 ec 0c             	sub    $0xc,%esp
f0111a1b:	50                   	push   %eax
f0111a1c:	e8 3d fc ff ff       	call   f011165e <getIndexOfCommand>
f0111a21:	83 c4 10             	add    $0x10,%esp
f0111a24:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111a27:	75 0f                	jne    f0111a38 <TestAutoCompleteCommand+0x38a>
f0111a29:	a1 d8 35 ec f0       	mov    0xf0ec35d8,%eax
f0111a2e:	85 c0                	test   %eax,%eax
f0111a30:	75 06                	jne    f0111a38 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111a32:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a36:	eb 10                	jmp    f0111a48 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a38:	83 ec 0c             	sub    $0xc,%esp
f0111a3b:	68 c0 8b 12 f0       	push   $0xf0128bc0
f0111a40:	e8 46 f5 fe ff       	call   f0100f8b <cprintf>
f0111a45:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111a48:	83 ec 08             	sub    $0x8,%esp
f0111a4b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111a4e:	68 10 8c 12 f0       	push   $0xf0128c10
f0111a53:	e8 33 f5 fe ff       	call   f0100f8b <cprintf>
f0111a58:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111a5b:	83 ec 0c             	sub    $0xc,%esp
f0111a5e:	68 40 8c 12 f0       	push   $0xf0128c40
f0111a63:	e8 23 f5 fe ff       	call   f0100f8b <cprintf>
f0111a68:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111a6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111a70:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111a73:	5b                   	pop    %ebx
f0111a74:	5e                   	pop    %esi
f0111a75:	5f                   	pop    %edi
f0111a76:	5d                   	pop    %ebp
f0111a77:	c3                   	ret    

f0111a78 <test_str2lower_function>:

int test_str2lower_function()
{
f0111a78:	55                   	push   %ebp
f0111a79:	89 e5                	mov    %esp,%ebp
f0111a7b:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111a81:	83 ec 0c             	sub    $0xc,%esp
f0111a84:	68 7c 8d 12 f0       	push   $0xf0128d7c
f0111a89:	e8 fd f4 fe ff       	call   f0100f8b <cprintf>
f0111a8e:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111a91:	83 ec 0c             	sub    $0xc,%esp
f0111a94:	68 9d 8d 12 f0       	push   $0xf0128d9d
f0111a99:	e8 ed f4 fe ff       	call   f0100f8b <cprintf>
f0111a9e:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111aa1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111aa8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111aaf:	c7 45 ec b7 8d 12 f0 	movl   $0xf0128db7,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111ab6:	83 ec 08             	sub    $0x8,%esp
f0111ab9:	ff 75 ec             	pushl  -0x14(%ebp)
f0111abc:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111ac2:	50                   	push   %eax
f0111ac3:	e8 3d e8 00 00       	call   f0120305 <str2lower>
f0111ac8:	83 c4 10             	add    $0x10,%esp
f0111acb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111ace:	83 ec 0c             	sub    $0xc,%esp
f0111ad1:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ad4:	e8 43 e1 00 00       	call   f011fc1c <strlen>
f0111ad9:	83 c4 10             	add    $0x10,%esp
f0111adc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111adf:	83 ec 08             	sub    $0x8,%esp
f0111ae2:	68 c2 8d 12 f0       	push   $0xf0128dc2
f0111ae7:	ff 75 e8             	pushl  -0x18(%ebp)
f0111aea:	e8 39 e2 00 00       	call   f011fd28 <strcmp>
f0111aef:	83 c4 10             	add    $0x10,%esp
f0111af2:	85 c0                	test   %eax,%eax
f0111af4:	75 13                	jne    f0111b09 <test_str2lower_function+0x91>
f0111af6:	83 ec 0c             	sub    $0xc,%esp
f0111af9:	ff 75 ec             	pushl  -0x14(%ebp)
f0111afc:	e8 1b e1 00 00       	call   f011fc1c <strlen>
f0111b01:	83 c4 10             	add    $0x10,%esp
f0111b04:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b07:	74 15                	je     f0111b1e <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111b09:	83 ec 08             	sub    $0x8,%esp
f0111b0c:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b0f:	68 d0 8d 12 f0       	push   $0xf0128dd0
f0111b14:	e8 72 f4 fe ff       	call   f0100f8b <cprintf>
f0111b19:	83 c4 10             	add    $0x10,%esp
f0111b1c:	eb 04                	jmp    f0111b22 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111b1e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111b22:	c7 45 e0 32 8e 12 f0 	movl   $0xf0128e32,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111b29:	83 ec 08             	sub    $0x8,%esp
f0111b2c:	ff 75 e0             	pushl  -0x20(%ebp)
f0111b2f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111b35:	50                   	push   %eax
f0111b36:	e8 ca e7 00 00       	call   f0120305 <str2lower>
f0111b3b:	83 c4 10             	add    $0x10,%esp
f0111b3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111b41:	83 ec 0c             	sub    $0xc,%esp
f0111b44:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b47:	e8 d0 e0 00 00       	call   f011fc1c <strlen>
f0111b4c:	83 c4 10             	add    $0x10,%esp
f0111b4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111b52:	83 ec 08             	sub    $0x8,%esp
f0111b55:	68 32 8e 12 f0       	push   $0xf0128e32
f0111b5a:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b5d:	e8 c6 e1 00 00       	call   f011fd28 <strcmp>
f0111b62:	83 c4 10             	add    $0x10,%esp
f0111b65:	85 c0                	test   %eax,%eax
f0111b67:	75 13                	jne    f0111b7c <test_str2lower_function+0x104>
f0111b69:	83 ec 0c             	sub    $0xc,%esp
f0111b6c:	ff 75 e0             	pushl  -0x20(%ebp)
f0111b6f:	e8 a8 e0 00 00       	call   f011fc1c <strlen>
f0111b74:	83 c4 10             	add    $0x10,%esp
f0111b77:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b7a:	74 15                	je     f0111b91 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111b7c:	83 ec 08             	sub    $0x8,%esp
f0111b7f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b82:	68 34 8e 12 f0       	push   $0xf0128e34
f0111b87:	e8 ff f3 fe ff       	call   f0100f8b <cprintf>
f0111b8c:	83 c4 10             	add    $0x10,%esp
f0111b8f:	eb 04                	jmp    f0111b95 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111b91:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111b95:	c7 45 dc 8c 8e 12 f0 	movl   $0xf0128e8c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111b9c:	83 ec 08             	sub    $0x8,%esp
f0111b9f:	ff 75 dc             	pushl  -0x24(%ebp)
f0111ba2:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111ba8:	50                   	push   %eax
f0111ba9:	e8 57 e7 00 00       	call   f0120305 <str2lower>
f0111bae:	83 c4 10             	add    $0x10,%esp
f0111bb1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111bb4:	83 ec 0c             	sub    $0xc,%esp
f0111bb7:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bba:	e8 5d e0 00 00       	call   f011fc1c <strlen>
f0111bbf:	83 c4 10             	add    $0x10,%esp
f0111bc2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111bc5:	83 ec 08             	sub    $0x8,%esp
f0111bc8:	68 8c 8e 12 f0       	push   $0xf0128e8c
f0111bcd:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bd0:	e8 53 e1 00 00       	call   f011fd28 <strcmp>
f0111bd5:	83 c4 10             	add    $0x10,%esp
f0111bd8:	85 c0                	test   %eax,%eax
f0111bda:	75 13                	jne    f0111bef <test_str2lower_function+0x177>
f0111bdc:	83 ec 0c             	sub    $0xc,%esp
f0111bdf:	ff 75 dc             	pushl  -0x24(%ebp)
f0111be2:	e8 35 e0 00 00       	call   f011fc1c <strlen>
f0111be7:	83 c4 10             	add    $0x10,%esp
f0111bea:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111bed:	74 15                	je     f0111c04 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111bef:	83 ec 08             	sub    $0x8,%esp
f0111bf2:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bf5:	68 98 8e 12 f0       	push   $0xf0128e98
f0111bfa:	e8 8c f3 fe ff       	call   f0100f8b <cprintf>
f0111bff:	83 c4 10             	add    $0x10,%esp
f0111c02:	eb 04                	jmp    f0111c08 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111c04:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111c08:	c7 45 d8 fb 8e 12 f0 	movl   $0xf0128efb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111c0f:	83 ec 08             	sub    $0x8,%esp
f0111c12:	ff 75 d8             	pushl  -0x28(%ebp)
f0111c15:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111c1b:	50                   	push   %eax
f0111c1c:	e8 e4 e6 00 00       	call   f0120305 <str2lower>
f0111c21:	83 c4 10             	add    $0x10,%esp
f0111c24:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111c27:	83 ec 0c             	sub    $0xc,%esp
f0111c2a:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c2d:	e8 ea df 00 00       	call   f011fc1c <strlen>
f0111c32:	83 c4 10             	add    $0x10,%esp
f0111c35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111c38:	83 ec 08             	sub    $0x8,%esp
f0111c3b:	68 fb 8e 12 f0       	push   $0xf0128efb
f0111c40:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c43:	e8 e0 e0 00 00       	call   f011fd28 <strcmp>
f0111c48:	83 c4 10             	add    $0x10,%esp
f0111c4b:	85 c0                	test   %eax,%eax
f0111c4d:	75 13                	jne    f0111c62 <test_str2lower_function+0x1ea>
f0111c4f:	83 ec 0c             	sub    $0xc,%esp
f0111c52:	ff 75 d8             	pushl  -0x28(%ebp)
f0111c55:	e8 c2 df 00 00       	call   f011fc1c <strlen>
f0111c5a:	83 c4 10             	add    $0x10,%esp
f0111c5d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111c60:	74 15                	je     f0111c77 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111c62:	83 ec 08             	sub    $0x8,%esp
f0111c65:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c68:	68 08 8f 12 f0       	push   $0xf0128f08
f0111c6d:	e8 19 f3 fe ff       	call   f0100f8b <cprintf>
f0111c72:	83 c4 10             	add    $0x10,%esp
f0111c75:	eb 04                	jmp    f0111c7b <test_str2lower_function+0x203>
	else
		eval += 15;
f0111c77:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111c7b:	c7 45 d4 6a 8f 12 f0 	movl   $0xf0128f6a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111c82:	83 ec 08             	sub    $0x8,%esp
f0111c85:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111c88:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111c8e:	50                   	push   %eax
f0111c8f:	e8 71 e6 00 00       	call   f0120305 <str2lower>
f0111c94:	83 c4 10             	add    $0x10,%esp
f0111c97:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111c9a:	83 ec 0c             	sub    $0xc,%esp
f0111c9d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ca0:	e8 77 df 00 00       	call   f011fc1c <strlen>
f0111ca5:	83 c4 10             	add    $0x10,%esp
f0111ca8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111cab:	83 ec 08             	sub    $0x8,%esp
f0111cae:	68 80 8f 12 f0       	push   $0xf0128f80
f0111cb3:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cb6:	e8 6d e0 00 00       	call   f011fd28 <strcmp>
f0111cbb:	83 c4 10             	add    $0x10,%esp
f0111cbe:	85 c0                	test   %eax,%eax
f0111cc0:	75 13                	jne    f0111cd5 <test_str2lower_function+0x25d>
f0111cc2:	83 ec 0c             	sub    $0xc,%esp
f0111cc5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111cc8:	e8 4f df 00 00       	call   f011fc1c <strlen>
f0111ccd:	83 c4 10             	add    $0x10,%esp
f0111cd0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111cd3:	74 15                	je     f0111cea <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111cd5:	83 ec 08             	sub    $0x8,%esp
f0111cd8:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cdb:	68 98 8f 12 f0       	push   $0xf0128f98
f0111ce0:	e8 a6 f2 fe ff       	call   f0100f8b <cprintf>
f0111ce5:	83 c4 10             	add    $0x10,%esp
f0111ce8:	eb 04                	jmp    f0111cee <test_str2lower_function+0x276>
	else
		eval += 15;
f0111cea:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111cee:	c7 45 d0 05 90 12 f0 	movl   $0xf0129005,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111cf5:	83 ec 08             	sub    $0x8,%esp
f0111cf8:	ff 75 d0             	pushl  -0x30(%ebp)
f0111cfb:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111d01:	50                   	push   %eax
f0111d02:	e8 fe e5 00 00       	call   f0120305 <str2lower>
f0111d07:	83 c4 10             	add    $0x10,%esp
f0111d0a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d0d:	83 ec 0c             	sub    $0xc,%esp
f0111d10:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d13:	e8 04 df 00 00       	call   f011fc1c <strlen>
f0111d18:	83 c4 10             	add    $0x10,%esp
f0111d1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111d1e:	83 ec 08             	sub    $0x8,%esp
f0111d21:	68 11 90 12 f0       	push   $0xf0129011
f0111d26:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d29:	e8 fa df 00 00       	call   f011fd28 <strcmp>
f0111d2e:	83 c4 10             	add    $0x10,%esp
f0111d31:	85 c0                	test   %eax,%eax
f0111d33:	75 13                	jne    f0111d48 <test_str2lower_function+0x2d0>
f0111d35:	83 ec 0c             	sub    $0xc,%esp
f0111d38:	ff 75 d0             	pushl  -0x30(%ebp)
f0111d3b:	e8 dc de 00 00       	call   f011fc1c <strlen>
f0111d40:	83 c4 10             	add    $0x10,%esp
f0111d43:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d46:	74 15                	je     f0111d5d <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111d48:	83 ec 08             	sub    $0x8,%esp
f0111d4b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d4e:	68 20 90 12 f0       	push   $0xf0129020
f0111d53:	e8 33 f2 fe ff       	call   f0100f8b <cprintf>
f0111d58:	83 c4 10             	add    $0x10,%esp
f0111d5b:	eb 04                	jmp    f0111d61 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111d5d:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111d61:	c7 45 cc 83 90 12 f0 	movl   $0xf0129083,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111d68:	83 ec 08             	sub    $0x8,%esp
f0111d6b:	ff 75 cc             	pushl  -0x34(%ebp)
f0111d6e:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111d74:	50                   	push   %eax
f0111d75:	e8 8b e5 00 00       	call   f0120305 <str2lower>
f0111d7a:	83 c4 10             	add    $0x10,%esp
f0111d7d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d80:	83 ec 0c             	sub    $0xc,%esp
f0111d83:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d86:	e8 91 de 00 00       	call   f011fc1c <strlen>
f0111d8b:	83 c4 10             	add    $0x10,%esp
f0111d8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111d91:	83 ec 08             	sub    $0x8,%esp
f0111d94:	68 9e 90 12 f0       	push   $0xf012909e
f0111d99:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d9c:	e8 87 df 00 00       	call   f011fd28 <strcmp>
f0111da1:	83 c4 10             	add    $0x10,%esp
f0111da4:	85 c0                	test   %eax,%eax
f0111da6:	75 13                	jne    f0111dbb <test_str2lower_function+0x343>
f0111da8:	83 ec 0c             	sub    $0xc,%esp
f0111dab:	ff 75 cc             	pushl  -0x34(%ebp)
f0111dae:	e8 69 de 00 00       	call   f011fc1c <strlen>
f0111db3:	83 c4 10             	add    $0x10,%esp
f0111db6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111db9:	74 15                	je     f0111dd0 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111dbb:	83 ec 08             	sub    $0x8,%esp
f0111dbe:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dc1:	68 bc 90 12 f0       	push   $0xf01290bc
f0111dc6:	e8 c0 f1 fe ff       	call   f0100f8b <cprintf>
f0111dcb:	83 c4 10             	add    $0x10,%esp
f0111dce:	eb 04                	jmp    f0111dd4 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111dd0:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111dd4:	83 ec 08             	sub    $0x8,%esp
f0111dd7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111dda:	68 30 91 12 f0       	push   $0xf0129130
f0111ddf:	e8 a7 f1 fe ff       	call   f0100f8b <cprintf>
f0111de4:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111de7:	83 ec 0c             	sub    $0xc,%esp
f0111dea:	68 40 8c 12 f0       	push   $0xf0128c40
f0111def:	e8 97 f1 fe ff       	call   f0100f8b <cprintf>
f0111df4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111df7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111dfc:	c9                   	leave  
f0111dfd:	c3                   	ret    

f0111dfe <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111dfe:	55                   	push   %ebp
f0111dff:	89 e5                	mov    %esp,%ebp
f0111e01:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111e04:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111e0b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111e12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e19:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111e1e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e21:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e24:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e27:	50                   	push   %eax
f0111e28:	e8 37 7e ff ff       	call   f0109c64 <pt_set_page_permissions>
f0111e2d:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e30:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111e35:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e38:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e3b:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e3e:	50                   	push   %eax
f0111e3f:	e8 74 4b 00 00       	call   f01169b8 <CP>
f0111e44:	83 c4 10             	add    $0x10,%esp
f0111e47:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111e4a:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111e4e:	74 17                	je     f0111e67 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111e50:	83 ec 04             	sub    $0x4,%esp
f0111e53:	68 60 91 12 f0       	push   $0xf0129160
f0111e58:	68 23 01 00 00       	push   $0x123
f0111e5d:	68 82 91 12 f0       	push   $0xf0129182
f0111e62:	e8 d2 e4 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111e67:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111e6e:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0111e75:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e7c:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111e81:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e84:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e87:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e8a:	50                   	push   %eax
f0111e8b:	e8 d4 7d ff ff       	call   f0109c64 <pt_set_page_permissions>
f0111e90:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e93:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111e98:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e9b:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ea1:	50                   	push   %eax
f0111ea2:	e8 11 4b 00 00       	call   f01169b8 <CP>
f0111ea7:	83 c4 10             	add    $0x10,%esp
f0111eaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111ead:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111eb1:	74 17                	je     f0111eca <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0111eb3:	83 ec 04             	sub    $0x4,%esp
f0111eb6:	68 a0 91 12 f0       	push   $0xf01291a0
f0111ebb:	68 2f 01 00 00       	push   $0x12f
f0111ec0:	68 82 91 12 f0       	push   $0xf0129182
f0111ec5:	e8 6f e4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111eca:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111ed1:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111ed8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111edf:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111ee4:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ee7:	ff 75 f0             	pushl  -0x10(%ebp)
f0111eea:	ff 75 f4             	pushl  -0xc(%ebp)
f0111eed:	50                   	push   %eax
f0111eee:	e8 71 7d ff ff       	call   f0109c64 <pt_set_page_permissions>
f0111ef3:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ef6:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111efb:	ff 75 ec             	pushl  -0x14(%ebp)
f0111efe:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f01:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f04:	50                   	push   %eax
f0111f05:	e8 ae 4a 00 00       	call   f01169b8 <CP>
f0111f0a:	83 c4 10             	add    $0x10,%esp
f0111f0d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f10:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f14:	74 17                	je     f0111f2d <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0111f16:	83 ec 04             	sub    $0x4,%esp
f0111f19:	68 c4 91 12 f0       	push   $0xf01291c4
f0111f1e:	68 3a 01 00 00       	push   $0x13a
f0111f23:	68 82 91 12 f0       	push   $0xf0129182
f0111f28:	e8 0c e4 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111f2d:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0111f34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111f3b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f42:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111f47:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f4a:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f4d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f50:	50                   	push   %eax
f0111f51:	e8 0e 7d ff ff       	call   f0109c64 <pt_set_page_permissions>
f0111f56:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f59:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111f5e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f61:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f64:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f67:	50                   	push   %eax
f0111f68:	e8 4b 4a 00 00       	call   f01169b8 <CP>
f0111f6d:	83 c4 10             	add    $0x10,%esp
f0111f70:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f73:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f77:	74 17                	je     f0111f90 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111f79:	83 ec 04             	sub    $0x4,%esp
f0111f7c:	68 e8 91 12 f0       	push   $0xf01291e8
f0111f81:	68 46 01 00 00       	push   $0x146
f0111f86:	68 82 91 12 f0       	push   $0xf0129182
f0111f8b:	e8 a9 e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111f90:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0111f97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111f9e:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fa5:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111faa:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fad:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fb0:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fb3:	50                   	push   %eax
f0111fb4:	e8 ab 7c ff ff       	call   f0109c64 <pt_set_page_permissions>
f0111fb9:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fbc:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0111fc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fc4:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fc7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fca:	50                   	push   %eax
f0111fcb:	e8 e8 49 00 00       	call   f01169b8 <CP>
f0111fd0:	83 c4 10             	add    $0x10,%esp
f0111fd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111fd6:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111fda:	74 17                	je     f0111ff3 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0111fdc:	83 ec 04             	sub    $0x4,%esp
f0111fdf:	68 0c 92 12 f0       	push   $0xf012920c
f0111fe4:	68 52 01 00 00       	push   $0x152
f0111fe9:	68 82 91 12 f0       	push   $0xf0129182
f0111fee:	e8 46 e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0111ff3:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0111ffa:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0112001:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112008:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011200d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112010:	ff 75 f0             	pushl  -0x10(%ebp)
f0112013:	ff 75 f4             	pushl  -0xc(%ebp)
f0112016:	50                   	push   %eax
f0112017:	e8 48 7c ff ff       	call   f0109c64 <pt_set_page_permissions>
f011201c:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011201f:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0112024:	ff 75 ec             	pushl  -0x14(%ebp)
f0112027:	ff 75 f0             	pushl  -0x10(%ebp)
f011202a:	ff 75 f4             	pushl  -0xc(%ebp)
f011202d:	50                   	push   %eax
f011202e:	e8 85 49 00 00       	call   f01169b8 <CP>
f0112033:	83 c4 10             	add    $0x10,%esp
f0112036:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112039:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011203d:	74 17                	je     f0112056 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f011203f:	83 ec 04             	sub    $0x4,%esp
f0112042:	68 30 92 12 f0       	push   $0xf0129230
f0112047:	68 5e 01 00 00       	push   $0x15e
f011204c:	68 82 91 12 f0       	push   $0xf0129182
f0112051:	e8 e3 e2 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112056:	83 ec 0c             	sub    $0xc,%esp
f0112059:	68 5c 92 12 f0       	push   $0xf012925c
f011205e:	e8 28 ef fe ff       	call   f0100f8b <cprintf>
f0112063:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112066:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011206b:	c9                   	leave  
f011206c:	c3                   	ret    

f011206d <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f011206d:	55                   	push   %ebp
f011206e:	89 e5                	mov    %esp,%ebp
f0112070:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0112073:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f011207a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0112081:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112088:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011208d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112090:	ff 75 f0             	pushl  -0x10(%ebp)
f0112093:	ff 75 f4             	pushl  -0xc(%ebp)
f0112096:	50                   	push   %eax
f0112097:	e8 c8 7b ff ff       	call   f0109c64 <pt_set_page_permissions>
f011209c:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f011209f:	83 ec 04             	sub    $0x4,%esp
f01120a2:	68 ac 92 12 f0       	push   $0xf01292ac
f01120a7:	68 6b 01 00 00       	push   $0x16b
f01120ac:	68 82 91 12 f0       	push   $0xf0129182
f01120b1:	e8 83 e2 fe ff       	call   f0100339 <_panic>

f01120b6 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f01120b6:	55                   	push   %ebp
f01120b7:	89 e5                	mov    %esp,%ebp
f01120b9:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f01120bc:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f01120c3:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01120c8:	83 ec 08             	sub    $0x8,%esp
f01120cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01120ce:	50                   	push   %eax
f01120cf:	e8 54 7c ff ff       	call   f0109d28 <pt_get_page_permissions>
f01120d4:	83 c4 10             	add    $0x10,%esp
f01120d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f01120da:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f01120de:	74 17                	je     f01120f7 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f01120e0:	83 ec 04             	sub    $0x4,%esp
f01120e3:	68 48 93 12 f0       	push   $0xf0129348
f01120e8:	68 79 01 00 00       	push   $0x179
f01120ed:	68 82 91 12 f0       	push   $0xf0129182
f01120f2:	e8 42 e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01120f7:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01120fe:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0112103:	83 ec 08             	sub    $0x8,%esp
f0112106:	ff 75 f4             	pushl  -0xc(%ebp)
f0112109:	50                   	push   %eax
f011210a:	e8 19 7c ff ff       	call   f0109d28 <pt_get_page_permissions>
f011210f:	83 c4 10             	add    $0x10,%esp
f0112112:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0112115:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112119:	74 17                	je     f0112132 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f011211b:	83 ec 04             	sub    $0x4,%esp
f011211e:	68 6c 93 12 f0       	push   $0xf012936c
f0112123:	68 81 01 00 00       	push   $0x181
f0112128:	68 82 91 12 f0       	push   $0xf0129182
f011212d:	e8 07 e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0112132:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112139:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011213e:	83 ec 08             	sub    $0x8,%esp
f0112141:	ff 75 f4             	pushl  -0xc(%ebp)
f0112144:	50                   	push   %eax
f0112145:	e8 de 7b ff ff       	call   f0109d28 <pt_get_page_permissions>
f011214a:	83 c4 10             	add    $0x10,%esp
f011214d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112150:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112154:	74 17                	je     f011216d <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112156:	83 ec 04             	sub    $0x4,%esp
f0112159:	68 90 93 12 f0       	push   $0xf0129390
f011215e:	68 89 01 00 00       	push   $0x189
f0112163:	68 82 91 12 f0       	push   $0xf0129182
f0112168:	e8 cc e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f011216d:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112174:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0112179:	83 ec 08             	sub    $0x8,%esp
f011217c:	ff 75 f4             	pushl  -0xc(%ebp)
f011217f:	50                   	push   %eax
f0112180:	e8 a3 7b ff ff       	call   f0109d28 <pt_get_page_permissions>
f0112185:	83 c4 10             	add    $0x10,%esp
f0112188:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011218b:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011218f:	74 17                	je     f01121a8 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0112191:	83 ec 04             	sub    $0x4,%esp
f0112194:	68 b4 93 12 f0       	push   $0xf01293b4
f0112199:	68 90 01 00 00       	push   $0x190
f011219e:	68 82 91 12 f0       	push   $0xf0129182
f01121a3:	e8 91 e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01121a8:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01121af:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01121b4:	83 ec 08             	sub    $0x8,%esp
f01121b7:	ff 75 f4             	pushl  -0xc(%ebp)
f01121ba:	50                   	push   %eax
f01121bb:	e8 68 7b ff ff       	call   f0109d28 <pt_get_page_permissions>
f01121c0:	83 c4 10             	add    $0x10,%esp
f01121c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f01121c6:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f01121ca:	74 17                	je     f01121e3 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f01121cc:	83 ec 04             	sub    $0x4,%esp
f01121cf:	68 d8 93 12 f0       	push   $0xf01293d8
f01121d4:	68 97 01 00 00       	push   $0x197
f01121d9:	68 82 91 12 f0       	push   $0xf0129182
f01121de:	e8 56 e1 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f01121e3:	83 ec 0c             	sub    $0xc,%esp
f01121e6:	68 fc 93 12 f0       	push   $0xf01293fc
f01121eb:	e8 9b ed fe ff       	call   f0100f8b <cprintf>
f01121f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01121f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01121f8:	c9                   	leave  
f01121f9:	c3                   	ret    

f01121fa <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01121fa:	55                   	push   %ebp
f01121fb:	89 e5                	mov    %esp,%ebp
f01121fd:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0112200:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112207:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011220c:	83 ec 08             	sub    $0x8,%esp
f011220f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112212:	50                   	push   %eax
f0112213:	e8 59 7b ff ff       	call   f0109d71 <pt_clear_page_table_entry>
f0112218:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f011221b:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0112220:	83 ec 08             	sub    $0x8,%esp
f0112223:	ff 75 f4             	pushl  -0xc(%ebp)
f0112226:	50                   	push   %eax
f0112227:	e8 e8 46 00 00       	call   f0116914 <CE>
f011222c:	83 c4 10             	add    $0x10,%esp
f011222f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112232:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112236:	74 17                	je     f011224f <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0112238:	83 ec 04             	sub    $0x4,%esp
f011223b:	68 44 94 12 f0       	push   $0xf0129444
f0112240:	68 a7 01 00 00       	push   $0x1a7
f0112245:	68 82 91 12 f0       	push   $0xf0129182
f011224a:	e8 ea e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f011224f:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112256:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011225b:	83 ec 08             	sub    $0x8,%esp
f011225e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112261:	50                   	push   %eax
f0112262:	e8 0a 7b ff ff       	call   f0109d71 <pt_clear_page_table_entry>
f0112267:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f011226a:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011226f:	83 ec 08             	sub    $0x8,%esp
f0112272:	ff 75 f4             	pushl  -0xc(%ebp)
f0112275:	50                   	push   %eax
f0112276:	e8 99 46 00 00       	call   f0116914 <CE>
f011227b:	83 c4 10             	add    $0x10,%esp
f011227e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112281:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112285:	74 17                	je     f011229e <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112287:	83 ec 04             	sub    $0x4,%esp
f011228a:	68 70 94 12 f0       	push   $0xf0129470
f011228f:	68 af 01 00 00       	push   $0x1af
f0112294:	68 82 91 12 f0       	push   $0xf0129182
f0112299:	e8 9b e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f011229e:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01122a5:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01122aa:	83 ec 08             	sub    $0x8,%esp
f01122ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01122b0:	50                   	push   %eax
f01122b1:	e8 bb 7a ff ff       	call   f0109d71 <pt_clear_page_table_entry>
f01122b6:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01122b9:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01122be:	83 ec 08             	sub    $0x8,%esp
f01122c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01122c4:	50                   	push   %eax
f01122c5:	e8 4a 46 00 00       	call   f0116914 <CE>
f01122ca:	83 c4 10             	add    $0x10,%esp
f01122cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01122d0:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01122d4:	74 17                	je     f01122ed <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f01122d6:	83 ec 04             	sub    $0x4,%esp
f01122d9:	68 9c 94 12 f0       	push   $0xf012949c
f01122de:	68 b7 01 00 00       	push   $0x1b7
f01122e3:	68 82 91 12 f0       	push   $0xf0129182
f01122e8:	e8 4c e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f01122ed:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01122f4:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f01122f9:	83 ec 08             	sub    $0x8,%esp
f01122fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01122ff:	50                   	push   %eax
f0112300:	e8 6c 7a ff ff       	call   f0109d71 <pt_clear_page_table_entry>
f0112305:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112308:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011230d:	83 ec 08             	sub    $0x8,%esp
f0112310:	ff 75 f4             	pushl  -0xc(%ebp)
f0112313:	50                   	push   %eax
f0112314:	e8 fb 45 00 00       	call   f0116914 <CE>
f0112319:	83 c4 10             	add    $0x10,%esp
f011231c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011231f:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112323:	74 17                	je     f011233c <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0112325:	83 ec 04             	sub    $0x4,%esp
f0112328:	68 c8 94 12 f0       	push   $0xf01294c8
f011232d:	68 bf 01 00 00       	push   $0x1bf
f0112332:	68 82 91 12 f0       	push   $0xf0129182
f0112337:	e8 fd df fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f011233c:	83 ec 0c             	sub    $0xc,%esp
f011233f:	68 f4 94 12 f0       	push   $0xf01294f4
f0112344:	e8 42 ec fe ff       	call   f0100f8b <cprintf>
f0112349:	83 c4 10             	add    $0x10,%esp
	return 0;
f011234c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112351:	c9                   	leave  
f0112352:	c3                   	ret    

f0112353 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0112353:	55                   	push   %ebp
f0112354:	89 e5                	mov    %esp,%ebp
f0112356:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112359:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112360:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0112365:	83 ec 08             	sub    $0x8,%esp
f0112368:	ff 75 f4             	pushl  -0xc(%ebp)
f011236b:	50                   	push   %eax
f011236c:	e8 00 7a ff ff       	call   f0109d71 <pt_clear_page_table_entry>
f0112371:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0112374:	83 ec 04             	sub    $0x4,%esp
f0112377:	68 40 95 12 f0       	push   $0xf0129540
f011237c:	68 ca 01 00 00       	push   $0x1ca
f0112381:	68 82 91 12 f0       	push   $0xf0129182
f0112386:	e8 ae df fe ff       	call   f0100339 <_panic>

f011238b <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f011238b:	55                   	push   %ebp
f011238c:	89 e5                	mov    %esp,%ebp
f011238e:	57                   	push   %edi
f011238f:	56                   	push   %esi
f0112390:	53                   	push   %ebx
f0112391:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112397:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011239d:	bb 84 98 12 f0       	mov    $0xf0129884,%ebx
f01123a2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01123a7:	89 c7                	mov    %eax,%edi
f01123a9:	89 de                	mov    %ebx,%esi
f01123ab:	89 d1                	mov    %edx,%ecx
f01123ad:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01123af:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01123b5:	b9 23 00 00 00       	mov    $0x23,%ecx
f01123ba:	b0 00                	mov    $0x0,%al
f01123bc:	89 d7                	mov    %edx,%edi
f01123be:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01123c0:	6a 00                	push   $0x0
f01123c2:	6a 0a                	push   $0xa
f01123c4:	6a 14                	push   $0x14
f01123c6:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01123cc:	50                   	push   %eax
f01123cd:	e8 90 8b ff ff       	call   f010af62 <env_create>
f01123d2:	83 c4 10             	add    $0x10,%esp
f01123d5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01123d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01123db:	8b 40 64             	mov    0x64(%eax),%eax
f01123de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01123e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01123e4:	8b 40 68             	mov    0x68(%eax),%eax
f01123e7:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01123ea:	8b 45 90             	mov    -0x70(%ebp),%eax
f01123ed:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01123f0:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f01123f7:	75 70 20 
f01123fa:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112401:	00 00 00 
f0112404:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f011240a:	b9 03 00 00 00       	mov    $0x3,%ecx
f011240f:	b8 00 00 00 00       	mov    $0x0,%eax
f0112414:	89 d7                	mov    %edx,%edi
f0112416:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112418:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011241b:	8b 40 10             	mov    0x10(%eax),%eax
f011241e:	83 ec 08             	sub    $0x8,%esp
f0112421:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112427:	52                   	push   %edx
f0112428:	50                   	push   %eax
f0112429:	e8 94 dc 00 00       	call   f01200c2 <ltostr>
f011242e:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112431:	83 ec 04             	sub    $0x4,%esp
f0112434:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011243a:	50                   	push   %eax
f011243b:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112441:	50                   	push   %eax
f0112442:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112448:	50                   	push   %eax
f0112449:	e8 4d dd 00 00       	call   f012019b <strcconcat>
f011244e:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112451:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112458:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f011245f:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0112466:	83 ec 0c             	sub    $0xc,%esp
f0112469:	ff 75 d4             	pushl  -0x2c(%ebp)
f011246c:	e8 85 45 00 00       	call   f01169f6 <ClearUserSpace>
f0112471:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0112474:	83 ec 04             	sub    $0x4,%esp
f0112477:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011247d:	50                   	push   %eax
f011247e:	68 d6 95 12 f0       	push   $0xf01295d6
f0112483:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112489:	50                   	push   %eax
f011248a:	e8 0c dd 00 00       	call   f012019b <strcconcat>
f011248f:	83 c4 10             	add    $0x10,%esp
f0112492:	83 ec 0c             	sub    $0xc,%esp
f0112495:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011249b:	50                   	push   %eax
f011249c:	e8 5a fa fe ff       	call   f0101efb <execute_command>
f01124a1:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01124a4:	83 ec 04             	sub    $0x4,%esp
f01124a7:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01124ad:	50                   	push   %eax
f01124ae:	68 e1 95 12 f0       	push   $0xf01295e1
f01124b3:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01124b9:	50                   	push   %eax
f01124ba:	e8 dc dc 00 00       	call   f012019b <strcconcat>
f01124bf:	83 c4 10             	add    $0x10,%esp
f01124c2:	83 ec 0c             	sub    $0xc,%esp
f01124c5:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01124cb:	50                   	push   %eax
f01124cc:	e8 2a fa fe ff       	call   f0101efb <execute_command>
f01124d1:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01124d4:	83 ec 04             	sub    $0x4,%esp
f01124d7:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01124dd:	50                   	push   %eax
f01124de:	68 ec 95 12 f0       	push   $0xf01295ec
f01124e3:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01124e9:	50                   	push   %eax
f01124ea:	e8 ac dc 00 00       	call   f012019b <strcconcat>
f01124ef:	83 c4 10             	add    $0x10,%esp
f01124f2:	83 ec 0c             	sub    $0xc,%esp
f01124f5:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01124fb:	50                   	push   %eax
f01124fc:	e8 fa f9 fe ff       	call   f0101efb <execute_command>
f0112501:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0112504:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f011250b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011250e:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112511:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0112518:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011251b:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f011251e:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0112525:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112528:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f011252b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011252e:	83 ec 08             	sub    $0x8,%esp
f0112531:	50                   	push   %eax
f0112532:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112535:	e8 9d 44 00 00       	call   f01169d7 <GP>
f011253a:	83 c4 10             	add    $0x10,%esp
f011253d:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112540:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0112547:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f011254e:	e8 af c3 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112553:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112556:	83 ec 0c             	sub    $0xc,%esp
f0112559:	68 f8 95 12 f0       	push   $0xf01295f8
f011255e:	e8 28 ea fe ff       	call   f0100f8b <cprintf>
f0112563:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112566:	6a 03                	push   $0x3
f0112568:	68 00 00 90 02       	push   $0x2900000
f011256d:	68 00 00 80 02       	push   $0x2800000
f0112572:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112575:	e8 6b 85 ff ff       	call   f010aae5 <cut_paste_pages>
f011257a:	83 c4 10             	add    $0x10,%esp
f011257d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112580:	e8 7d c3 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112585:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112588:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f011258f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112593:	75 08                	jne    f011259d <test_cut_paste_pages+0x212>
f0112595:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112598:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011259b:	74 2b                	je     f01125c8 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f011259d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01125a0:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01125a3:	83 ec 0c             	sub    $0xc,%esp
f01125a6:	50                   	push   %eax
f01125a7:	ff 75 b4             	pushl  -0x4c(%ebp)
f01125aa:	68 28 96 12 f0       	push   $0xf0129628
f01125af:	68 04 02 00 00       	push   $0x204
f01125b4:	68 82 91 12 f0       	push   $0xf0129182
f01125b9:	e8 18 df fe ff       	call   f01004d6 <_warn>
f01125be:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01125c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f01125c8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01125cc:	74 04                	je     f01125d2 <test_cut_paste_pages+0x247>
f01125ce:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01125d2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01125d9:	83 ec 08             	sub    $0x8,%esp
f01125dc:	6a 00                	push   $0x0
f01125de:	6a 01                	push   $0x1
f01125e0:	6a 00                	push   $0x0
f01125e2:	68 ff 0f 00 00       	push   $0xfff
f01125e7:	ff 75 bc             	pushl  -0x44(%ebp)
f01125ea:	6a 01                	push   $0x1
f01125ec:	68 00 30 00 00       	push   $0x3000
f01125f1:	68 00 00 90 02       	push   $0x2900000
f01125f6:	68 00 00 80 02       	push   $0x2800000
f01125fb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125fe:	e8 27 44 00 00       	call   f0116a2a <CCP>
f0112603:	83 c4 30             	add    $0x30,%esp
f0112606:	83 f8 01             	cmp    $0x1,%eax
f0112609:	74 21                	je     f011262c <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011260b:	83 ec 04             	sub    $0x4,%esp
f011260e:	68 7c 96 12 f0       	push   $0xf012967c
f0112613:	68 0c 02 00 00       	push   $0x20c
f0112618:	68 82 91 12 f0       	push   $0xf0129182
f011261d:	e8 b4 de fe ff       	call   f01004d6 <_warn>
f0112622:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112625:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f011262c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112630:	74 04                	je     f0112636 <test_cut_paste_pages+0x2ab>
f0112632:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0112636:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f011263d:	83 ec 04             	sub    $0x4,%esp
f0112640:	6a 00                	push   $0x0
f0112642:	68 00 00 90 02       	push   $0x2900000
f0112647:	ff 75 d4             	pushl  -0x2c(%ebp)
f011264a:	e8 b7 41 00 00       	call   f0116806 <CB>
f011264f:	83 c4 10             	add    $0x10,%esp
f0112652:	85 c0                	test   %eax,%eax
f0112654:	0f 84 f6 00 00 00    	je     f0112750 <test_cut_paste_pages+0x3c5>
f011265a:	83 ec 04             	sub    $0x4,%esp
f011265d:	6a 00                	push   $0x0
f011265f:	68 00 10 90 02       	push   $0x2901000
f0112664:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112667:	e8 9a 41 00 00       	call   f0116806 <CB>
f011266c:	83 c4 10             	add    $0x10,%esp
f011266f:	85 c0                	test   %eax,%eax
f0112671:	0f 84 d9 00 00 00    	je     f0112750 <test_cut_paste_pages+0x3c5>
f0112677:	83 ec 04             	sub    $0x4,%esp
f011267a:	6a 00                	push   $0x0
f011267c:	68 00 20 90 02       	push   $0x2902000
f0112681:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112684:	e8 7d 41 00 00       	call   f0116806 <CB>
f0112689:	83 c4 10             	add    $0x10,%esp
f011268c:	85 c0                	test   %eax,%eax
f011268e:	0f 84 bc 00 00 00    	je     f0112750 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112694:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f011269b:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01126a2:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01126a9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01126ac:	8a 00                	mov    (%eax),%al
f01126ae:	3c 61                	cmp    $0x61,%al
f01126b0:	75 12                	jne    f01126c4 <test_cut_paste_pages+0x339>
f01126b2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01126b5:	8a 00                	mov    (%eax),%al
f01126b7:	3c 62                	cmp    $0x62,%al
f01126b9:	75 09                	jne    f01126c4 <test_cut_paste_pages+0x339>
f01126bb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01126be:	8a 00                	mov    (%eax),%al
f01126c0:	3c 63                	cmp    $0x63,%al
f01126c2:	74 21                	je     f01126e5 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01126c4:	83 ec 04             	sub    $0x4,%esp
f01126c7:	68 c8 96 12 f0       	push   $0xf01296c8
f01126cc:	68 19 02 00 00       	push   $0x219
f01126d1:	68 82 91 12 f0       	push   $0xf0129182
f01126d6:	e8 fb dd fe ff       	call   f01004d6 <_warn>
f01126db:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01126de:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01126e5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01126e9:	74 04                	je     f01126ef <test_cut_paste_pages+0x364>
f01126eb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01126ef:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01126f6:	83 ec 04             	sub    $0x4,%esp
f01126f9:	6a 01                	push   $0x1
f01126fb:	68 00 10 90 02       	push   $0x2901000
f0112700:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112703:	e8 fe 40 00 00       	call   f0116806 <CB>
f0112708:	83 c4 10             	add    $0x10,%esp
f011270b:	85 c0                	test   %eax,%eax
f011270d:	74 41                	je     f0112750 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f011270f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112712:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0112715:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112718:	8a 00                	mov    (%eax),%al
f011271a:	3c 79                	cmp    $0x79,%al
f011271c:	74 21                	je     f011273f <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011271e:	83 ec 04             	sub    $0x4,%esp
f0112721:	68 c8 96 12 f0       	push   $0xf01296c8
f0112726:	68 24 02 00 00       	push   $0x224
f011272b:	68 82 91 12 f0       	push   $0xf0129182
f0112730:	e8 a1 dd fe ff       	call   f01004d6 <_warn>
f0112735:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112738:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f011273f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112743:	74 04                	je     f0112749 <test_cut_paste_pages+0x3be>
f0112745:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112749:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112750:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112753:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112756:	6a 02                	push   $0x2
f0112758:	68 00 f0 bf 02       	push   $0x2bff000
f011275d:	68 00 10 90 02       	push   $0x2901000
f0112762:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112765:	e8 7b 83 ff ff       	call   f010aae5 <cut_paste_pages>
f011276a:	83 c4 10             	add    $0x10,%esp
f011276d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112770:	e8 8d c1 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112775:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112778:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011277c:	75 0b                	jne    f0112789 <test_cut_paste_pages+0x3fe>
f011277e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112781:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112784:	83 f8 01             	cmp    $0x1,%eax
f0112787:	74 2b                	je     f01127b4 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112789:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011278c:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011278f:	83 ec 0c             	sub    $0xc,%esp
f0112792:	50                   	push   %eax
f0112793:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112796:	68 28 96 12 f0       	push   $0xf0129628
f011279b:	68 35 02 00 00       	push   $0x235
f01127a0:	68 82 91 12 f0       	push   $0xf0129182
f01127a5:	e8 2c dd fe ff       	call   f01004d6 <_warn>
f01127aa:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01127ad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01127b4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127b8:	74 04                	je     f01127be <test_cut_paste_pages+0x433>
f01127ba:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01127be:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01127c5:	83 ec 08             	sub    $0x8,%esp
f01127c8:	6a 00                	push   $0x0
f01127ca:	6a 01                	push   $0x1
f01127cc:	6a 00                	push   $0x0
f01127ce:	68 ff 0f 00 00       	push   $0xfff
f01127d3:	ff 75 bc             	pushl  -0x44(%ebp)
f01127d6:	6a 01                	push   $0x1
f01127d8:	68 00 20 00 00       	push   $0x2000
f01127dd:	68 00 f0 bf 02       	push   $0x2bff000
f01127e2:	68 00 10 90 02       	push   $0x2901000
f01127e7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127ea:	e8 3b 42 00 00       	call   f0116a2a <CCP>
f01127ef:	83 c4 30             	add    $0x30,%esp
f01127f2:	83 f8 01             	cmp    $0x1,%eax
f01127f5:	74 21                	je     f0112818 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01127f7:	83 ec 04             	sub    $0x4,%esp
f01127fa:	68 7c 96 12 f0       	push   $0xf012967c
f01127ff:	68 3d 02 00 00       	push   $0x23d
f0112804:	68 82 91 12 f0       	push   $0xf0129182
f0112809:	e8 c8 dc fe ff       	call   f01004d6 <_warn>
f011280e:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112811:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112818:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011281c:	74 04                	je     f0112822 <test_cut_paste_pages+0x497>
f011281e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112822:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112829:	83 ec 04             	sub    $0x4,%esp
f011282c:	6a 00                	push   $0x0
f011282e:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112833:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112836:	e8 cb 3f 00 00       	call   f0116806 <CB>
f011283b:	83 c4 10             	add    $0x10,%esp
f011283e:	85 c0                	test   %eax,%eax
f0112840:	74 6b                	je     f01128ad <test_cut_paste_pages+0x522>
f0112842:	83 ec 04             	sub    $0x4,%esp
f0112845:	6a 00                	push   $0x0
f0112847:	68 ff 0f c0 02       	push   $0x2c00fff
f011284c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011284f:	e8 b2 3f 00 00       	call   f0116806 <CB>
f0112854:	83 c4 10             	add    $0x10,%esp
f0112857:	85 c0                	test   %eax,%eax
f0112859:	74 52                	je     f01128ad <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f011285b:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112862:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112869:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011286c:	8a 00                	mov    (%eax),%al
f011286e:	3c 79                	cmp    $0x79,%al
f0112870:	75 09                	jne    f011287b <test_cut_paste_pages+0x4f0>
f0112872:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112875:	8a 00                	mov    (%eax),%al
f0112877:	3c 63                	cmp    $0x63,%al
f0112879:	74 21                	je     f011289c <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011287b:	83 ec 04             	sub    $0x4,%esp
f011287e:	68 c8 96 12 f0       	push   $0xf01296c8
f0112883:	68 49 02 00 00       	push   $0x249
f0112888:	68 82 91 12 f0       	push   $0xf0129182
f011288d:	e8 44 dc fe ff       	call   f01004d6 <_warn>
f0112892:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112895:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011289c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01128a0:	74 04                	je     f01128a6 <test_cut_paste_pages+0x51b>
f01128a2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01128a6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01128ad:	83 ec 0c             	sub    $0xc,%esp
f01128b0:	68 01 97 12 f0       	push   $0xf0129701
f01128b5:	e8 d1 e6 fe ff       	call   f0100f8b <cprintf>
f01128ba:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f01128bd:	83 ec 0c             	sub    $0xc,%esp
f01128c0:	68 10 97 12 f0       	push   $0xf0129710
f01128c5:	e8 c1 e6 fe ff       	call   f0100f8b <cprintf>
f01128ca:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01128cd:	83 ec 04             	sub    $0x4,%esp
f01128d0:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01128d6:	50                   	push   %eax
f01128d7:	68 39 97 12 f0       	push   $0xf0129739
f01128dc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01128e2:	50                   	push   %eax
f01128e3:	e8 b3 d8 00 00       	call   f012019b <strcconcat>
f01128e8:	83 c4 10             	add    $0x10,%esp
f01128eb:	83 ec 0c             	sub    $0xc,%esp
f01128ee:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01128f4:	50                   	push   %eax
f01128f5:	e8 01 f6 fe ff       	call   f0101efb <execute_command>
f01128fa:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01128fd:	83 ec 04             	sub    $0x4,%esp
f0112900:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112906:	50                   	push   %eax
f0112907:	68 44 97 12 f0       	push   $0xf0129744
f011290c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112912:	50                   	push   %eax
f0112913:	e8 83 d8 00 00       	call   f012019b <strcconcat>
f0112918:	83 c4 10             	add    $0x10,%esp
f011291b:	83 ec 0c             	sub    $0xc,%esp
f011291e:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112924:	50                   	push   %eax
f0112925:	e8 d1 f5 fe ff       	call   f0101efb <execute_command>
f011292a:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f011292d:	83 ec 04             	sub    $0x4,%esp
f0112930:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112936:	50                   	push   %eax
f0112937:	68 4f 97 12 f0       	push   $0xf012974f
f011293c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112942:	50                   	push   %eax
f0112943:	e8 53 d8 00 00       	call   f012019b <strcconcat>
f0112948:	83 c4 10             	add    $0x10,%esp
f011294b:	83 ec 0c             	sub    $0xc,%esp
f011294e:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112954:	50                   	push   %eax
f0112955:	e8 a1 f5 fe ff       	call   f0101efb <execute_command>
f011295a:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f011295d:	83 ec 04             	sub    $0x4,%esp
f0112960:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112966:	50                   	push   %eax
f0112967:	68 5a 97 12 f0       	push   $0xf012975a
f011296c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112972:	50                   	push   %eax
f0112973:	e8 23 d8 00 00       	call   f012019b <strcconcat>
f0112978:	83 c4 10             	add    $0x10,%esp
f011297b:	83 ec 0c             	sub    $0xc,%esp
f011297e:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112984:	50                   	push   %eax
f0112985:	e8 71 f5 fe ff       	call   f0101efb <execute_command>
f011298a:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f011298d:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112994:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112997:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f011299a:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f01129a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129a4:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f01129a7:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f01129ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129b1:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f01129b4:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f01129bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129be:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f01129c1:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f01129c8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129cb:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01129ce:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01129d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129d8:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01129db:	83 ec 08             	sub    $0x8,%esp
f01129de:	68 00 00 c0 01       	push   $0x1c00000
f01129e3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129e6:	e8 ec 3f 00 00       	call   f01169d7 <GP>
f01129eb:	83 c4 10             	add    $0x10,%esp
f01129ee:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f01129f1:	83 ec 08             	sub    $0x8,%esp
f01129f4:	68 00 00 40 01       	push   $0x1400000
f01129f9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129fc:	e8 d6 3f 00 00       	call   f01169d7 <GP>
f0112a01:	83 c4 10             	add    $0x10,%esp
f0112a04:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112a07:	e8 f6 be ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112a0c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112a0f:	6a 01                	push   $0x1
f0112a11:	68 00 00 40 01       	push   $0x1400000
f0112a16:	68 00 00 c0 01       	push   $0x1c00000
f0112a1b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a1e:	e8 c2 80 ff ff       	call   f010aae5 <cut_paste_pages>
f0112a23:	83 c4 10             	add    $0x10,%esp
f0112a26:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112a29:	e8 d4 be ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112a2e:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112a31:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112a35:	75 08                	jne    f0112a3f <test_cut_paste_pages+0x6b4>
f0112a37:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112a3a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112a3d:	74 2b                	je     f0112a6a <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112a3f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112a42:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112a45:	83 ec 0c             	sub    $0xc,%esp
f0112a48:	50                   	push   %eax
f0112a49:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112a4c:	68 68 97 12 f0       	push   $0xf0129768
f0112a51:	68 6c 02 00 00       	push   $0x26c
f0112a56:	68 82 91 12 f0       	push   $0xf0129182
f0112a5b:	e8 76 da fe ff       	call   f01004d6 <_warn>
f0112a60:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112a63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112a6a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a6e:	74 04                	je     f0112a74 <test_cut_paste_pages+0x6e9>
f0112a70:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112a74:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112a7b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112a82:	83 ec 08             	sub    $0x8,%esp
f0112a85:	6a 00                	push   $0x0
f0112a87:	68 ff 0f 00 00       	push   $0xfff
f0112a8c:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112a8f:	68 ff 0f 00 00       	push   $0xfff
f0112a94:	ff 75 a0             	pushl  -0x60(%ebp)
f0112a97:	6a 01                	push   $0x1
f0112a99:	68 00 10 00 00       	push   $0x1000
f0112a9e:	68 00 00 40 01       	push   $0x1400000
f0112aa3:	68 00 00 c0 01       	push   $0x1c00000
f0112aa8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112aab:	e8 7a 3f 00 00       	call   f0116a2a <CCP>
f0112ab0:	83 c4 30             	add    $0x30,%esp
f0112ab3:	83 f8 01             	cmp    $0x1,%eax
f0112ab6:	74 28                	je     f0112ae0 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112ab8:	83 ec 04             	sub    $0x4,%esp
f0112abb:	68 7c 96 12 f0       	push   $0xf012967c
f0112ac0:	68 75 02 00 00       	push   $0x275
f0112ac5:	68 82 91 12 f0       	push   $0xf0129182
f0112aca:	e8 07 da fe ff       	call   f01004d6 <_warn>
f0112acf:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112ad2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112ad9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112ae0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ae4:	74 04                	je     f0112aea <test_cut_paste_pages+0x75f>
f0112ae6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112aea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112af1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112af5:	0f 84 92 00 00 00    	je     f0112b8d <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112afb:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112b02:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112b09:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112b10:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112b17:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112b1e:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112b25:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112b28:	8a 00                	mov    (%eax),%al
f0112b2a:	3c 61                	cmp    $0x61,%al
f0112b2c:	75 2d                	jne    f0112b5b <test_cut_paste_pages+0x7d0>
f0112b2e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112b31:	8a 00                	mov    (%eax),%al
f0112b33:	3c 78                	cmp    $0x78,%al
f0112b35:	75 24                	jne    f0112b5b <test_cut_paste_pages+0x7d0>
f0112b37:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112b3a:	8a 00                	mov    (%eax),%al
f0112b3c:	3c 62                	cmp    $0x62,%al
f0112b3e:	75 1b                	jne    f0112b5b <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112b40:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112b43:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112b45:	3c 79                	cmp    $0x79,%al
f0112b47:	75 12                	jne    f0112b5b <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112b49:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b4c:	8a 00                	mov    (%eax),%al
f0112b4e:	3c 63                	cmp    $0x63,%al
f0112b50:	75 09                	jne    f0112b5b <test_cut_paste_pages+0x7d0>
f0112b52:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112b55:	8a 00                	mov    (%eax),%al
f0112b57:	3c 7a                	cmp    $0x7a,%al
f0112b59:	74 21                	je     f0112b7c <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112b5b:	83 ec 04             	sub    $0x4,%esp
f0112b5e:	68 c8 96 12 f0       	push   $0xf01296c8
f0112b63:	68 87 02 00 00       	push   $0x287
f0112b68:	68 82 91 12 f0       	push   $0xf0129182
f0112b6d:	e8 64 d9 fe ff       	call   f01004d6 <_warn>
f0112b72:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112b75:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112b7c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b80:	74 04                	je     f0112b86 <test_cut_paste_pages+0x7fb>
f0112b82:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b86:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112b8d:	e8 70 bd ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112b92:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112b95:	6a 03                	push   $0x3
f0112b97:	68 00 f0 bf 01       	push   $0x1bff000
f0112b9c:	68 00 00 40 01       	push   $0x1400000
f0112ba1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ba4:	e8 3c 7f ff ff       	call   f010aae5 <cut_paste_pages>
f0112ba9:	83 c4 10             	add    $0x10,%esp
f0112bac:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112baf:	e8 4e bd ff ff       	call   f010e902 <sys_calculate_free_frames>
f0112bb4:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112bb7:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112bbb:	75 08                	jne    f0112bc5 <test_cut_paste_pages+0x83a>
f0112bbd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112bc0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112bc3:	74 2b                	je     f0112bf0 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112bc5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112bc8:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112bcb:	83 ec 0c             	sub    $0xc,%esp
f0112bce:	50                   	push   %eax
f0112bcf:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112bd2:	68 68 97 12 f0       	push   $0xf0129768
f0112bd7:	68 96 02 00 00       	push   $0x296
f0112bdc:	68 82 91 12 f0       	push   $0xf0129182
f0112be1:	e8 f0 d8 fe ff       	call   f01004d6 <_warn>
f0112be6:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112be9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112bf0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112bf4:	74 04                	je     f0112bfa <test_cut_paste_pages+0x86f>
f0112bf6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112bfa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0112c01:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112c08:	83 ec 04             	sub    $0x4,%esp
f0112c0b:	6a 00                	push   $0x0
f0112c0d:	68 00 00 40 01       	push   $0x1400000
f0112c12:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c15:	e8 ec 3b 00 00       	call   f0116806 <CB>
f0112c1a:	83 c4 10             	add    $0x10,%esp
f0112c1d:	83 f8 01             	cmp    $0x1,%eax
f0112c20:	0f 85 80 00 00 00    	jne    f0112ca6 <test_cut_paste_pages+0x91b>
f0112c26:	83 ec 04             	sub    $0x4,%esp
f0112c29:	6a 00                	push   $0x0
f0112c2b:	68 00 10 40 01       	push   $0x1401000
f0112c30:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c33:	e8 ce 3b 00 00       	call   f0116806 <CB>
f0112c38:	83 c4 10             	add    $0x10,%esp
f0112c3b:	83 f8 01             	cmp    $0x1,%eax
f0112c3e:	75 66                	jne    f0112ca6 <test_cut_paste_pages+0x91b>
f0112c40:	83 ec 04             	sub    $0x4,%esp
f0112c43:	6a 00                	push   $0x0
f0112c45:	68 00 20 40 01       	push   $0x1402000
f0112c4a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c4d:	e8 b4 3b 00 00       	call   f0116806 <CB>
f0112c52:	83 c4 10             	add    $0x10,%esp
f0112c55:	83 f8 01             	cmp    $0x1,%eax
f0112c58:	75 4c                	jne    f0112ca6 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112c5a:	83 ec 04             	sub    $0x4,%esp
f0112c5d:	6a 00                	push   $0x0
f0112c5f:	68 00 f0 bf 01       	push   $0x1bff000
f0112c64:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c67:	e8 9a 3b 00 00       	call   f0116806 <CB>
f0112c6c:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112c6f:	85 c0                	test   %eax,%eax
f0112c71:	75 33                	jne    f0112ca6 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112c73:	83 ec 04             	sub    $0x4,%esp
f0112c76:	6a 00                	push   $0x0
f0112c78:	68 00 00 c0 01       	push   $0x1c00000
f0112c7d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c80:	e8 81 3b 00 00       	call   f0116806 <CB>
f0112c85:	83 c4 10             	add    $0x10,%esp
f0112c88:	83 f8 01             	cmp    $0x1,%eax
f0112c8b:	75 19                	jne    f0112ca6 <test_cut_paste_pages+0x91b>
f0112c8d:	83 ec 04             	sub    $0x4,%esp
f0112c90:	6a 00                	push   $0x0
f0112c92:	68 00 10 c0 01       	push   $0x1c01000
f0112c97:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c9a:	e8 67 3b 00 00       	call   f0116806 <CB>
f0112c9f:	83 c4 10             	add    $0x10,%esp
f0112ca2:	85 c0                	test   %eax,%eax
f0112ca4:	74 28                	je     f0112cce <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112ca6:	83 ec 04             	sub    $0x4,%esp
f0112ca9:	68 c8 97 12 f0       	push   $0xf01297c8
f0112cae:	68 9f 02 00 00       	push   $0x29f
f0112cb3:	68 82 91 12 f0       	push   $0xf0129182
f0112cb8:	e8 19 d8 fe ff       	call   f01004d6 <_warn>
f0112cbd:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112cc0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112cc7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112cce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112cd2:	74 04                	je     f0112cd8 <test_cut_paste_pages+0x94d>
f0112cd4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112cd8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112cdf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112ce3:	0f 84 99 00 00 00    	je     f0112d82 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112ce9:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112cf0:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112cf7:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112cfe:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112d05:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112d0c:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112d13:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d16:	8a 00                	mov    (%eax),%al
f0112d18:	3c 61                	cmp    $0x61,%al
f0112d1a:	75 2d                	jne    f0112d49 <test_cut_paste_pages+0x9be>
f0112d1c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112d1f:	8a 00                	mov    (%eax),%al
f0112d21:	3c 78                	cmp    $0x78,%al
f0112d23:	75 24                	jne    f0112d49 <test_cut_paste_pages+0x9be>
f0112d25:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112d28:	8a 00                	mov    (%eax),%al
f0112d2a:	3c 62                	cmp    $0x62,%al
f0112d2c:	75 1b                	jne    f0112d49 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112d2e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112d31:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112d33:	3c 79                	cmp    $0x79,%al
f0112d35:	75 12                	jne    f0112d49 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112d37:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112d3a:	8a 00                	mov    (%eax),%al
f0112d3c:	3c 63                	cmp    $0x63,%al
f0112d3e:	75 09                	jne    f0112d49 <test_cut_paste_pages+0x9be>
f0112d40:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112d43:	8a 00                	mov    (%eax),%al
f0112d45:	3c 7a                	cmp    $0x7a,%al
f0112d47:	74 28                	je     f0112d71 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112d49:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112d50:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112d57:	83 ec 04             	sub    $0x4,%esp
f0112d5a:	68 c8 96 12 f0       	push   $0xf01296c8
f0112d5f:	68 b3 02 00 00       	push   $0x2b3
f0112d64:	68 82 91 12 f0       	push   $0xf0129182
f0112d69:	e8 68 d7 fe ff       	call   f01004d6 <_warn>
f0112d6e:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112d71:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d75:	74 04                	je     f0112d7b <test_cut_paste_pages+0x9f0>
f0112d77:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112d7b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112d82:	83 ec 0c             	sub    $0xc,%esp
f0112d85:	68 01 98 12 f0       	push   $0xf0129801
f0112d8a:	e8 fc e1 fe ff       	call   f0100f8b <cprintf>
f0112d8f:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112d92:	83 ec 08             	sub    $0x8,%esp
f0112d95:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112d98:	68 10 98 12 f0       	push   $0xf0129810
f0112d9d:	e8 e9 e1 fe ff       	call   f0100f8b <cprintf>
f0112da2:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112da5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112da9:	75 10                	jne    f0112dbb <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112dab:	83 ec 0c             	sub    $0xc,%esp
f0112dae:	68 44 98 12 f0       	push   $0xf0129844
f0112db3:	e8 d3 e1 fe ff       	call   f0100f8b <cprintf>
f0112db8:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112dbb:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f0112dc0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112dc3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112dc6:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112dc9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112dce:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112dd1:	5b                   	pop    %ebx
f0112dd2:	5e                   	pop    %esi
f0112dd3:	5f                   	pop    %edi
f0112dd4:	5d                   	pop    %ebp
f0112dd5:	c3                   	ret    

f0112dd6 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112dd6:	55                   	push   %ebp
f0112dd7:	89 e5                	mov    %esp,%ebp
f0112dd9:	57                   	push   %edi
f0112dda:	56                   	push   %esi
f0112ddb:	53                   	push   %ebx
f0112ddc:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112de2:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112de8:	bb 84 98 12 f0       	mov    $0xf0129884,%ebx
f0112ded:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112df2:	89 c7                	mov    %eax,%edi
f0112df4:	89 de                	mov    %ebx,%esi
f0112df6:	89 d1                	mov    %edx,%ecx
f0112df8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112dfa:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0112e00:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112e05:	b0 00                	mov    $0x0,%al
f0112e07:	89 d7                	mov    %edx,%edi
f0112e09:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112e0b:	6a 00                	push   $0x0
f0112e0d:	6a 0a                	push   $0xa
f0112e0f:	6a 14                	push   $0x14
f0112e11:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112e17:	50                   	push   %eax
f0112e18:	e8 45 81 ff ff       	call   f010af62 <env_create>
f0112e1d:	83 c4 10             	add    $0x10,%esp
f0112e20:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112e23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e26:	8b 40 64             	mov    0x64(%eax),%eax
f0112e29:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112e2c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e2f:	8b 40 68             	mov    0x68(%eax),%eax
f0112e32:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0112e38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112e3e:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112e41:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0112e48:	75 70 20 
f0112e4b:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112e52:	00 00 00 
f0112e55:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112e5b:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112e60:	b8 00 00 00 00       	mov    $0x0,%eax
f0112e65:	89 d7                	mov    %edx,%edi
f0112e67:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112e69:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e6c:	8b 40 10             	mov    0x10(%eax),%eax
f0112e6f:	83 ec 08             	sub    $0x8,%esp
f0112e72:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112e78:	52                   	push   %edx
f0112e79:	50                   	push   %eax
f0112e7a:	e8 43 d2 00 00       	call   f01200c2 <ltostr>
f0112e7f:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112e82:	83 ec 04             	sub    $0x4,%esp
f0112e85:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112e8b:	50                   	push   %eax
f0112e8c:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112e92:	50                   	push   %eax
f0112e93:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112e99:	50                   	push   %eax
f0112e9a:	e8 fc d2 00 00       	call   f012019b <strcconcat>
f0112e9f:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112ea2:	83 ec 0c             	sub    $0xc,%esp
f0112ea5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ea8:	e8 49 3b 00 00       	call   f01169f6 <ClearUserSpace>
f0112ead:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112eb0:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112eb7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112ebe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0112ec5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112ecc:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112ed3:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112eda:	83 ec 0c             	sub    $0xc,%esp
f0112edd:	68 b8 98 12 f0       	push   $0xf01298b8
f0112ee2:	e8 a4 e0 fe ff       	call   f0100f8b <cprintf>
f0112ee7:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112eea:	83 ec 04             	sub    $0x4,%esp
f0112eed:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112ef3:	50                   	push   %eax
f0112ef4:	68 ee 98 12 f0       	push   $0xf01298ee
f0112ef9:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112eff:	50                   	push   %eax
f0112f00:	e8 96 d2 00 00       	call   f012019b <strcconcat>
f0112f05:	83 c4 10             	add    $0x10,%esp
f0112f08:	83 ec 0c             	sub    $0xc,%esp
f0112f0b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112f11:	50                   	push   %eax
f0112f12:	e8 e4 ef fe ff       	call   f0101efb <execute_command>
f0112f17:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0112f1a:	83 ec 04             	sub    $0x4,%esp
f0112f1d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112f23:	50                   	push   %eax
f0112f24:	68 f3 98 12 f0       	push   $0xf01298f3
f0112f29:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f2f:	50                   	push   %eax
f0112f30:	e8 66 d2 00 00       	call   f012019b <strcconcat>
f0112f35:	83 c4 10             	add    $0x10,%esp
f0112f38:	83 ec 0c             	sub    $0xc,%esp
f0112f3b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112f41:	50                   	push   %eax
f0112f42:	e8 b4 ef fe ff       	call   f0101efb <execute_command>
f0112f47:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0112f4a:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112f50:	bb f9 9b 12 f0       	mov    $0xf0129bf9,%ebx
f0112f55:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f5a:	89 c7                	mov    %eax,%edi
f0112f5c:	89 de                	mov    %ebx,%esi
f0112f5e:	89 d1                	mov    %edx,%ecx
f0112f60:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f62:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112f68:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f6d:	b0 00                	mov    $0x0,%al
f0112f6f:	89 d7                	mov    %edx,%edi
f0112f71:	f3 aa                	rep stos %al,%es:(%edi)
f0112f73:	83 ec 0c             	sub    $0xc,%esp
f0112f76:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112f7c:	50                   	push   %eax
f0112f7d:	e8 79 ef fe ff       	call   f0101efb <execute_command>
f0112f82:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0112f85:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112f8b:	bb 5d 9c 12 f0       	mov    $0xf0129c5d,%ebx
f0112f90:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f95:	89 c7                	mov    %eax,%edi
f0112f97:	89 de                	mov    %ebx,%esi
f0112f99:	89 d1                	mov    %edx,%ecx
f0112f9b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f9d:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112fa3:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fa8:	b0 00                	mov    $0x0,%al
f0112faa:	89 d7                	mov    %edx,%edi
f0112fac:	f3 aa                	rep stos %al,%es:(%edi)
f0112fae:	83 ec 0c             	sub    $0xc,%esp
f0112fb1:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112fb7:	50                   	push   %eax
f0112fb8:	e8 3e ef fe ff       	call   f0101efb <execute_command>
f0112fbd:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0112fc0:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112fc6:	bb c1 9c 12 f0       	mov    $0xf0129cc1,%ebx
f0112fcb:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112fd0:	89 c7                	mov    %eax,%edi
f0112fd2:	89 de                	mov    %ebx,%esi
f0112fd4:	89 d1                	mov    %edx,%ecx
f0112fd6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112fd8:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112fde:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fe3:	b0 00                	mov    $0x0,%al
f0112fe5:	89 d7                	mov    %edx,%edi
f0112fe7:	f3 aa                	rep stos %al,%es:(%edi)
f0112fe9:	83 ec 0c             	sub    $0xc,%esp
f0112fec:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112ff2:	50                   	push   %eax
f0112ff3:	e8 03 ef fe ff       	call   f0101efb <execute_command>
f0112ff8:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0112ffb:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113001:	bb 25 9d 12 f0       	mov    $0xf0129d25,%ebx
f0113006:	ba 0f 00 00 00       	mov    $0xf,%edx
f011300b:	89 c7                	mov    %eax,%edi
f011300d:	89 de                	mov    %ebx,%esi
f011300f:	89 d1                	mov    %edx,%ecx
f0113011:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113013:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113019:	b9 55 00 00 00       	mov    $0x55,%ecx
f011301e:	b0 00                	mov    $0x0,%al
f0113020:	89 d7                	mov    %edx,%edi
f0113022:	f3 aa                	rep stos %al,%es:(%edi)
f0113024:	83 ec 0c             	sub    $0xc,%esp
f0113027:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011302d:	50                   	push   %eax
f011302e:	e8 c8 ee fe ff       	call   f0101efb <execute_command>
f0113033:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0113036:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011303c:	bb 89 9d 12 f0       	mov    $0xf0129d89,%ebx
f0113041:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113046:	89 c7                	mov    %eax,%edi
f0113048:	89 de                	mov    %ebx,%esi
f011304a:	89 d1                	mov    %edx,%ecx
f011304c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011304e:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113054:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113059:	b0 00                	mov    $0x0,%al
f011305b:	89 d7                	mov    %edx,%edi
f011305d:	f3 aa                	rep stos %al,%es:(%edi)
f011305f:	83 ec 0c             	sub    $0xc,%esp
f0113062:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113068:	50                   	push   %eax
f0113069:	e8 8d ee fe ff       	call   f0101efb <execute_command>
f011306e:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0113071:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113077:	bb ed 9d 12 f0       	mov    $0xf0129ded,%ebx
f011307c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113081:	89 c7                	mov    %eax,%edi
f0113083:	89 de                	mov    %ebx,%esi
f0113085:	89 d1                	mov    %edx,%ecx
f0113087:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113089:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011308f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113094:	b0 00                	mov    $0x0,%al
f0113096:	89 d7                	mov    %edx,%edi
f0113098:	f3 aa                	rep stos %al,%es:(%edi)
f011309a:	83 ec 0c             	sub    $0xc,%esp
f011309d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01130a3:	50                   	push   %eax
f01130a4:	e8 52 ee fe ff       	call   f0101efb <execute_command>
f01130a9:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01130ac:	83 ec 04             	sub    $0x4,%esp
f01130af:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01130b5:	50                   	push   %eax
f01130b6:	68 fb 98 12 f0       	push   $0xf01298fb
f01130bb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01130c1:	50                   	push   %eax
f01130c2:	e8 d4 d0 00 00       	call   f012019b <strcconcat>
f01130c7:	83 c4 10             	add    $0x10,%esp
f01130ca:	83 ec 0c             	sub    $0xc,%esp
f01130cd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01130d3:	50                   	push   %eax
f01130d4:	e8 22 ee fe ff       	call   f0101efb <execute_command>
f01130d9:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f01130dc:	83 ec 04             	sub    $0x4,%esp
f01130df:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01130e5:	50                   	push   %eax
f01130e6:	68 05 99 12 f0       	push   $0xf0129905
f01130eb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01130f1:	50                   	push   %eax
f01130f2:	e8 a4 d0 00 00       	call   f012019b <strcconcat>
f01130f7:	83 c4 10             	add    $0x10,%esp
f01130fa:	83 ec 0c             	sub    $0xc,%esp
f01130fd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113103:	50                   	push   %eax
f0113104:	e8 f2 ed fe ff       	call   f0101efb <execute_command>
f0113109:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f011310c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113112:	bb 51 9e 12 f0       	mov    $0xf0129e51,%ebx
f0113117:	ba 0f 00 00 00       	mov    $0xf,%edx
f011311c:	89 c7                	mov    %eax,%edi
f011311e:	89 de                	mov    %ebx,%esi
f0113120:	89 d1                	mov    %edx,%ecx
f0113122:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113124:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011312a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011312f:	b0 00                	mov    $0x0,%al
f0113131:	89 d7                	mov    %edx,%edi
f0113133:	f3 aa                	rep stos %al,%es:(%edi)
f0113135:	83 ec 0c             	sub    $0xc,%esp
f0113138:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011313e:	50                   	push   %eax
f011313f:	e8 b7 ed fe ff       	call   f0101efb <execute_command>
f0113144:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0113147:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011314d:	bb b5 9e 12 f0       	mov    $0xf0129eb5,%ebx
f0113152:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113157:	89 c7                	mov    %eax,%edi
f0113159:	89 de                	mov    %ebx,%esi
f011315b:	89 d1                	mov    %edx,%ecx
f011315d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011315f:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113165:	b9 55 00 00 00       	mov    $0x55,%ecx
f011316a:	b0 00                	mov    $0x0,%al
f011316c:	89 d7                	mov    %edx,%edi
f011316e:	f3 aa                	rep stos %al,%es:(%edi)
f0113170:	83 ec 0c             	sub    $0xc,%esp
f0113173:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113179:	50                   	push   %eax
f011317a:	e8 7c ed fe ff       	call   f0101efb <execute_command>
f011317f:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0113182:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113188:	bb 19 9f 12 f0       	mov    $0xf0129f19,%ebx
f011318d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113192:	89 c7                	mov    %eax,%edi
f0113194:	89 de                	mov    %ebx,%esi
f0113196:	89 d1                	mov    %edx,%ecx
f0113198:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011319a:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01131a0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131a5:	b0 00                	mov    $0x0,%al
f01131a7:	89 d7                	mov    %edx,%edi
f01131a9:	f3 aa                	rep stos %al,%es:(%edi)
f01131ab:	83 ec 0c             	sub    $0xc,%esp
f01131ae:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01131b4:	50                   	push   %eax
f01131b5:	e8 41 ed fe ff       	call   f0101efb <execute_command>
f01131ba:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f01131bd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01131c4:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f01131cb:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f01131d2:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f01131d9:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f01131e0:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f01131e7:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f01131ee:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f01131f5:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f01131fc:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0113203:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f011320a:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113211:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113214:	8a 00                	mov    (%eax),%al
f0113216:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f011321c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011321f:	8a 00                	mov    (%eax),%al
f0113221:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0113227:	8b 45 90             	mov    -0x70(%ebp),%eax
f011322a:	8a 00                	mov    (%eax),%al
f011322c:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113232:	e8 cb b6 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113237:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f011323a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011323d:	89 d0                	mov    %edx,%eax
f011323f:	01 c0                	add    %eax,%eax
f0113241:	01 d0                	add    %edx,%eax
f0113243:	01 c0                	add    %eax,%eax
f0113245:	50                   	push   %eax
f0113246:	68 00 00 10 00       	push   $0x100000
f011324b:	6a 00                	push   $0x0
f011324d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113250:	e8 aa 78 ff ff       	call   f010aaff <copy_paste_chunk>
f0113255:	83 c4 10             	add    $0x10,%esp
f0113258:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011325b:	e8 a2 b6 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113260:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113263:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011326a:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f011326e:	75 08                	jne    f0113278 <test_copy_paste_chunk+0x4a2>
f0113270:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113273:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113276:	74 2b                	je     f01132a3 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113278:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011327b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011327e:	83 ec 0c             	sub    $0xc,%esp
f0113281:	50                   	push   %eax
f0113282:	ff 75 88             	pushl  -0x78(%ebp)
f0113285:	68 14 99 12 f0       	push   $0xf0129914
f011328a:	68 06 03 00 00       	push   $0x306
f011328f:	68 82 91 12 f0       	push   $0xf0129182
f0113294:	e8 3d d2 fe ff       	call   f01004d6 <_warn>
f0113299:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011329c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01132a3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01132a7:	74 04                	je     f01132ad <test_copy_paste_chunk+0x4d7>
f01132a9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01132ad:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01132b4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01132b7:	8a 00                	mov    (%eax),%al
f01132b9:	3c 61                	cmp    $0x61,%al
f01132bb:	75 75                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f01132bd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01132c0:	8a 00                	mov    (%eax),%al
f01132c2:	3c 78                	cmp    $0x78,%al
f01132c4:	75 6c                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f01132c6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01132c9:	8a 00                	mov    (%eax),%al
f01132cb:	3c 62                	cmp    $0x62,%al
f01132cd:	75 63                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f01132cf:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01132d2:	8a 00                	mov    (%eax),%al
f01132d4:	3c 79                	cmp    $0x79,%al
f01132d6:	75 5a                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f01132d8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01132db:	8a 00                	mov    (%eax),%al
f01132dd:	3c 63                	cmp    $0x63,%al
f01132df:	75 51                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f01132e1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01132e4:	8a 00                	mov    (%eax),%al
f01132e6:	3c 7a                	cmp    $0x7a,%al
f01132e8:	75 48                	jne    f0113332 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f01132ea:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01132ed:	8a 00                	mov    (%eax),%al
f01132ef:	3c 64                	cmp    $0x64,%al
f01132f1:	75 3f                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f01132f3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01132f6:	8a 10                	mov    (%eax),%dl
f01132f8:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f01132fe:	38 c2                	cmp    %al,%dl
f0113300:	75 30                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f0113302:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113305:	8a 00                	mov    (%eax),%al
f0113307:	3c 65                	cmp    $0x65,%al
f0113309:	75 27                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f011330b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011330e:	8a 10                	mov    (%eax),%dl
f0113310:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0113316:	38 c2                	cmp    %al,%dl
f0113318:	75 18                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f011331a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011331d:	8a 00                	mov    (%eax),%al
f011331f:	3c 66                	cmp    $0x66,%al
f0113321:	75 0f                	jne    f0113332 <test_copy_paste_chunk+0x55c>
f0113323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113326:	8a 10                	mov    (%eax),%dl
f0113328:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011332e:	38 c2                	cmp    %al,%dl
f0113330:	74 21                	je     f0113353 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113332:	83 ec 04             	sub    $0x4,%esp
f0113335:	68 78 99 12 f0       	push   $0xf0129978
f011333a:	68 0f 03 00 00       	push   $0x30f
f011333f:	68 82 91 12 f0       	push   $0xf0129182
f0113344:	e8 8d d1 fe ff       	call   f01004d6 <_warn>
f0113349:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011334c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113353:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113357:	74 04                	je     f011335d <test_copy_paste_chunk+0x587>
f0113359:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011335d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0113364:	83 ec 0c             	sub    $0xc,%esp
f0113367:	68 b2 99 12 f0       	push   $0xf01299b2
f011336c:	e8 1a dc fe ff       	call   f0100f8b <cprintf>
f0113371:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0113374:	83 ec 0c             	sub    $0xc,%esp
f0113377:	68 c4 99 12 f0       	push   $0xf01299c4
f011337c:	e8 0a dc fe ff       	call   f0100f8b <cprintf>
f0113381:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0113384:	83 ec 04             	sub    $0x4,%esp
f0113387:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011338d:	50                   	push   %eax
f011338e:	68 fa 99 12 f0       	push   $0xf01299fa
f0113393:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113399:	50                   	push   %eax
f011339a:	e8 fc cd 00 00       	call   f012019b <strcconcat>
f011339f:	83 c4 10             	add    $0x10,%esp
f01133a2:	83 ec 0c             	sub    $0xc,%esp
f01133a5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01133ab:	50                   	push   %eax
f01133ac:	e8 4a eb fe ff       	call   f0101efb <execute_command>
f01133b1:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01133b4:	83 ec 04             	sub    $0x4,%esp
f01133b7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01133bd:	50                   	push   %eax
f01133be:	68 04 9a 12 f0       	push   $0xf0129a04
f01133c3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133c9:	50                   	push   %eax
f01133ca:	e8 cc cd 00 00       	call   f012019b <strcconcat>
f01133cf:	83 c4 10             	add    $0x10,%esp
f01133d2:	83 ec 0c             	sub    $0xc,%esp
f01133d5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01133db:	50                   	push   %eax
f01133dc:	e8 1a eb fe ff       	call   f0101efb <execute_command>
f01133e1:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f01133e4:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01133ea:	bb 7d 9f 12 f0       	mov    $0xf0129f7d,%ebx
f01133ef:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133f4:	89 c7                	mov    %eax,%edi
f01133f6:	89 de                	mov    %ebx,%esi
f01133f8:	89 d1                	mov    %edx,%ecx
f01133fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133fc:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113402:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113407:	b0 00                	mov    $0x0,%al
f0113409:	89 d7                	mov    %edx,%edi
f011340b:	f3 aa                	rep stos %al,%es:(%edi)
f011340d:	83 ec 0c             	sub    $0xc,%esp
f0113410:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113416:	50                   	push   %eax
f0113417:	e8 df ea fe ff       	call   f0101efb <execute_command>
f011341c:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f011341f:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113425:	bb e1 9f 12 f0       	mov    $0xf0129fe1,%ebx
f011342a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011342f:	89 c7                	mov    %eax,%edi
f0113431:	89 de                	mov    %ebx,%esi
f0113433:	89 d1                	mov    %edx,%ecx
f0113435:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113437:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011343d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113442:	b0 00                	mov    $0x0,%al
f0113444:	89 d7                	mov    %edx,%edi
f0113446:	f3 aa                	rep stos %al,%es:(%edi)
f0113448:	83 ec 0c             	sub    $0xc,%esp
f011344b:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113451:	50                   	push   %eax
f0113452:	e8 a4 ea fe ff       	call   f0101efb <execute_command>
f0113457:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f011345a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113460:	bb 45 a0 12 f0       	mov    $0xf012a045,%ebx
f0113465:	ba 0f 00 00 00       	mov    $0xf,%edx
f011346a:	89 c7                	mov    %eax,%edi
f011346c:	89 de                	mov    %ebx,%esi
f011346e:	89 d1                	mov    %edx,%ecx
f0113470:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113472:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113478:	b9 55 00 00 00       	mov    $0x55,%ecx
f011347d:	b0 00                	mov    $0x0,%al
f011347f:	89 d7                	mov    %edx,%edi
f0113481:	f3 aa                	rep stos %al,%es:(%edi)
f0113483:	83 ec 0c             	sub    $0xc,%esp
f0113486:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011348c:	50                   	push   %eax
f011348d:	e8 69 ea fe ff       	call   f0101efb <execute_command>
f0113492:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0113495:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011349b:	bb a9 a0 12 f0       	mov    $0xf012a0a9,%ebx
f01134a0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134a5:	89 c7                	mov    %eax,%edi
f01134a7:	89 de                	mov    %ebx,%esi
f01134a9:	89 d1                	mov    %edx,%ecx
f01134ab:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134ad:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01134b3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134b8:	b0 00                	mov    $0x0,%al
f01134ba:	89 d7                	mov    %edx,%edi
f01134bc:	f3 aa                	rep stos %al,%es:(%edi)
f01134be:	83 ec 0c             	sub    $0xc,%esp
f01134c1:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01134c7:	50                   	push   %eax
f01134c8:	e8 2e ea fe ff       	call   f0101efb <execute_command>
f01134cd:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01134d0:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01134d6:	bb 0d a1 12 f0       	mov    $0xf012a10d,%ebx
f01134db:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134e0:	89 c7                	mov    %eax,%edi
f01134e2:	89 de                	mov    %ebx,%esi
f01134e4:	89 d1                	mov    %edx,%ecx
f01134e6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134e8:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01134ee:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134f3:	b0 00                	mov    $0x0,%al
f01134f5:	89 d7                	mov    %edx,%edi
f01134f7:	f3 aa                	rep stos %al,%es:(%edi)
f01134f9:	83 ec 0c             	sub    $0xc,%esp
f01134fc:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113502:	50                   	push   %eax
f0113503:	e8 f3 e9 fe ff       	call   f0101efb <execute_command>
f0113508:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f011350b:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113511:	bb 71 a1 12 f0       	mov    $0xf012a171,%ebx
f0113516:	ba 0f 00 00 00       	mov    $0xf,%edx
f011351b:	89 c7                	mov    %eax,%edi
f011351d:	89 de                	mov    %ebx,%esi
f011351f:	89 d1                	mov    %edx,%ecx
f0113521:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113523:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113529:	b9 55 00 00 00       	mov    $0x55,%ecx
f011352e:	b0 00                	mov    $0x0,%al
f0113530:	89 d7                	mov    %edx,%edi
f0113532:	f3 aa                	rep stos %al,%es:(%edi)
f0113534:	83 ec 0c             	sub    $0xc,%esp
f0113537:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011353d:	50                   	push   %eax
f011353e:	e8 b8 e9 fe ff       	call   f0101efb <execute_command>
f0113543:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0113546:	83 ec 04             	sub    $0x4,%esp
f0113549:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011354f:	50                   	push   %eax
f0113550:	68 0e 9a 12 f0       	push   $0xf0129a0e
f0113555:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011355b:	50                   	push   %eax
f011355c:	e8 3a cc 00 00       	call   f012019b <strcconcat>
f0113561:	83 c4 10             	add    $0x10,%esp
f0113564:	83 ec 0c             	sub    $0xc,%esp
f0113567:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011356d:	50                   	push   %eax
f011356e:	e8 88 e9 fe ff       	call   f0101efb <execute_command>
f0113573:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113576:	83 ec 04             	sub    $0x4,%esp
f0113579:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011357f:	50                   	push   %eax
f0113580:	68 18 9a 12 f0       	push   $0xf0129a18
f0113585:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011358b:	50                   	push   %eax
f011358c:	e8 0a cc 00 00       	call   f012019b <strcconcat>
f0113591:	83 c4 10             	add    $0x10,%esp
f0113594:	83 ec 0c             	sub    $0xc,%esp
f0113597:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011359d:	50                   	push   %eax
f011359e:	e8 58 e9 fe ff       	call   f0101efb <execute_command>
f01135a3:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01135a6:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01135ac:	bb d5 a1 12 f0       	mov    $0xf012a1d5,%ebx
f01135b1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135b6:	89 c7                	mov    %eax,%edi
f01135b8:	89 de                	mov    %ebx,%esi
f01135ba:	89 d1                	mov    %edx,%ecx
f01135bc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135be:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01135c4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135c9:	b0 00                	mov    $0x0,%al
f01135cb:	89 d7                	mov    %edx,%edi
f01135cd:	f3 aa                	rep stos %al,%es:(%edi)
f01135cf:	83 ec 0c             	sub    $0xc,%esp
f01135d2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01135d8:	50                   	push   %eax
f01135d9:	e8 1d e9 fe ff       	call   f0101efb <execute_command>
f01135de:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01135e1:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01135e7:	bb 39 a2 12 f0       	mov    $0xf012a239,%ebx
f01135ec:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135f1:	89 c7                	mov    %eax,%edi
f01135f3:	89 de                	mov    %ebx,%esi
f01135f5:	89 d1                	mov    %edx,%ecx
f01135f7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135f9:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01135ff:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113604:	b0 00                	mov    $0x0,%al
f0113606:	89 d7                	mov    %edx,%edi
f0113608:	f3 aa                	rep stos %al,%es:(%edi)
f011360a:	83 ec 0c             	sub    $0xc,%esp
f011360d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113613:	50                   	push   %eax
f0113614:	e8 e2 e8 fe ff       	call   f0101efb <execute_command>
f0113619:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f011361c:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113622:	bb 9d a2 12 f0       	mov    $0xf012a29d,%ebx
f0113627:	ba 0f 00 00 00       	mov    $0xf,%edx
f011362c:	89 c7                	mov    %eax,%edi
f011362e:	89 de                	mov    %ebx,%esi
f0113630:	89 d1                	mov    %edx,%ecx
f0113632:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113634:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011363a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011363f:	b0 00                	mov    $0x0,%al
f0113641:	89 d7                	mov    %edx,%edi
f0113643:	f3 aa                	rep stos %al,%es:(%edi)
f0113645:	83 ec 0c             	sub    $0xc,%esp
f0113648:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011364e:	50                   	push   %eax
f011364f:	e8 a7 e8 fe ff       	call   f0101efb <execute_command>
f0113654:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113657:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f011365e:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0113665:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f011366c:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113673:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f011367a:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113681:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113688:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f011368f:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113696:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f011369d:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01136a4:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01136ab:	8b 45 90             	mov    -0x70(%ebp),%eax
f01136ae:	8a 00                	mov    (%eax),%al
f01136b0:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01136b6:	e8 47 b2 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01136bb:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f01136be:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01136c1:	89 d0                	mov    %edx,%eax
f01136c3:	01 c0                	add    %eax,%eax
f01136c5:	01 d0                	add    %edx,%eax
f01136c7:	01 c0                	add    %eax,%eax
f01136c9:	50                   	push   %eax
f01136ca:	68 00 00 40 00       	push   $0x400000
f01136cf:	68 00 00 20 00       	push   $0x200000
f01136d4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136d7:	e8 23 74 ff ff       	call   f010aaff <copy_paste_chunk>
f01136dc:	83 c4 10             	add    $0x10,%esp
f01136df:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01136e2:	e8 1b b2 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01136e7:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01136ea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01136f1:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01136f5:	75 08                	jne    f01136ff <test_copy_paste_chunk+0x929>
f01136f7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01136fa:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01136fd:	74 2b                	je     f011372a <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01136ff:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113702:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113705:	83 ec 0c             	sub    $0xc,%esp
f0113708:	50                   	push   %eax
f0113709:	ff 75 80             	pushl  -0x80(%ebp)
f011370c:	68 24 9a 12 f0       	push   $0xf0129a24
f0113711:	68 3f 03 00 00       	push   $0x33f
f0113716:	68 82 91 12 f0       	push   $0xf0129182
f011371b:	e8 b6 cd fe ff       	call   f01004d6 <_warn>
f0113720:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113723:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011372a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011372e:	74 04                	je     f0113734 <test_copy_paste_chunk+0x95e>
f0113730:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113734:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f011373b:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113742:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113745:	83 ec 08             	sub    $0x8,%esp
f0113748:	6a 01                	push   $0x1
f011374a:	6a 07                	push   $0x7
f011374c:	6a 07                	push   $0x7
f011374e:	6a 07                	push   $0x7
f0113750:	6a 07                	push   $0x7
f0113752:	6a 01                	push   $0x1
f0113754:	68 00 20 00 00       	push   $0x2000
f0113759:	68 00 00 40 00       	push   $0x400000
f011375e:	68 00 00 20 00       	push   $0x200000
f0113763:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113766:	e8 bf 32 00 00       	call   f0116a2a <CCP>
f011376b:	83 c4 30             	add    $0x30,%esp
f011376e:	83 f8 01             	cmp    $0x1,%eax
f0113771:	74 2b                	je     f011379e <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113773:	83 ec 04             	sub    $0x4,%esp
f0113776:	68 78 9a 12 f0       	push   $0xf0129a78
f011377b:	68 48 03 00 00       	push   $0x348
f0113780:	68 82 91 12 f0       	push   $0xf0129182
f0113785:	e8 4c cd fe ff       	call   f01004d6 <_warn>
f011378a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011378d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113794:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f011379b:	00 00 00 
		}
		if (correct) eval += 5 ;
f011379e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137a2:	74 04                	je     f01137a8 <test_copy_paste_chunk+0x9d2>
f01137a4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01137a8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f01137af:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01137b2:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f01137b5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01137b8:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f01137bb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01137be:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f01137c1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01137c4:	8a 00                	mov    (%eax),%al
f01137c6:	3c 61                	cmp    $0x61,%al
f01137c8:	75 69                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f01137ca:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01137cd:	8a 00                	mov    (%eax),%al
f01137cf:	3c 61                	cmp    $0x61,%al
f01137d1:	75 60                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f01137d3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01137d6:	8a 00                	mov    (%eax),%al
f01137d8:	3c 79                	cmp    $0x79,%al
f01137da:	75 57                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f01137dc:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01137df:	8a 00                	mov    (%eax),%al
f01137e1:	3c 62                	cmp    $0x62,%al
f01137e3:	75 4e                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f01137e5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01137e8:	8a 00                	mov    (%eax),%al
f01137ea:	3c 63                	cmp    $0x63,%al
f01137ec:	75 45                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f01137ee:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01137f1:	8a 00                	mov    (%eax),%al
f01137f3:	3c 7a                	cmp    $0x7a,%al
f01137f5:	75 3c                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01137f7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01137fa:	8a 00                	mov    (%eax),%al
f01137fc:	3c 77                	cmp    $0x77,%al
f01137fe:	75 33                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f0113800:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113803:	8a 00                	mov    (%eax),%al
f0113805:	3c 64                	cmp    $0x64,%al
f0113807:	75 2a                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f0113809:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011380c:	8a 00                	mov    (%eax),%al
f011380e:	3c 65                	cmp    $0x65,%al
f0113810:	75 21                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f0113812:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113815:	8a 00                	mov    (%eax),%al
f0113817:	3c 65                	cmp    $0x65,%al
f0113819:	75 18                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f011381b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011381e:	8a 00                	mov    (%eax),%al
f0113820:	3c 66                	cmp    $0x66,%al
f0113822:	75 0f                	jne    f0113833 <test_copy_paste_chunk+0xa5d>
f0113824:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113827:	8a 10                	mov    (%eax),%dl
f0113829:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011382f:	38 c2                	cmp    %al,%dl
f0113831:	74 21                	je     f0113854 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113833:	83 ec 04             	sub    $0x4,%esp
f0113836:	68 78 99 12 f0       	push   $0xf0129978
f011383b:	68 56 03 00 00       	push   $0x356
f0113840:	68 82 91 12 f0       	push   $0xf0129182
f0113845:	e8 8c cc fe ff       	call   f01004d6 <_warn>
f011384a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011384d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113854:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113858:	74 04                	je     f011385e <test_copy_paste_chunk+0xa88>
f011385a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011385e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113865:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113868:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011386b:	e8 92 b0 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113870:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113873:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113876:	89 c2                	mov    %eax,%edx
f0113878:	01 d2                	add    %edx,%edx
f011387a:	01 d0                	add    %edx,%eax
f011387c:	50                   	push   %eax
f011387d:	68 00 08 20 00       	push   $0x200800
f0113882:	68 00 08 40 00       	push   $0x400800
f0113887:	ff 75 d4             	pushl  -0x2c(%ebp)
f011388a:	e8 70 72 ff ff       	call   f010aaff <copy_paste_chunk>
f011388f:	83 c4 10             	add    $0x10,%esp
f0113892:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113895:	e8 68 b0 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011389a:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011389d:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01138a1:	75 08                	jne    f01138ab <test_copy_paste_chunk+0xad5>
f01138a3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01138a6:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01138a9:	74 2b                	je     f01138d6 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01138ab:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01138ae:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01138b1:	83 ec 0c             	sub    $0xc,%esp
f01138b4:	50                   	push   %eax
f01138b5:	ff 75 80             	pushl  -0x80(%ebp)
f01138b8:	68 24 9a 12 f0       	push   $0xf0129a24
f01138bd:	68 66 03 00 00       	push   $0x366
f01138c2:	68 82 91 12 f0       	push   $0xf0129182
f01138c7:	e8 0a cc fe ff       	call   f01004d6 <_warn>
f01138cc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01138cf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01138d6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01138da:	74 04                	je     f01138e0 <test_copy_paste_chunk+0xb0a>
f01138dc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01138e0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01138e7:	83 ec 08             	sub    $0x8,%esp
f01138ea:	6a 01                	push   $0x1
f01138ec:	6a 07                	push   $0x7
f01138ee:	6a 07                	push   $0x7
f01138f0:	6a 07                	push   $0x7
f01138f2:	6a 07                	push   $0x7
f01138f4:	6a 01                	push   $0x1
f01138f6:	68 00 20 00 00       	push   $0x2000
f01138fb:	68 00 00 20 00       	push   $0x200000
f0113900:	68 00 00 40 00       	push   $0x400000
f0113905:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113908:	e8 1d 31 00 00       	call   f0116a2a <CCP>
f011390d:	83 c4 30             	add    $0x30,%esp
f0113910:	83 f8 01             	cmp    $0x1,%eax
f0113913:	74 21                	je     f0113936 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113915:	83 ec 04             	sub    $0x4,%esp
f0113918:	68 c4 9a 12 f0       	push   $0xf0129ac4
f011391d:	68 6e 03 00 00       	push   $0x36e
f0113922:	68 82 91 12 f0       	push   $0xf0129182
f0113927:	e8 aa cb fe ff       	call   f01004d6 <_warn>
f011392c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011392f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113936:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011393a:	74 04                	je     f0113940 <test_copy_paste_chunk+0xb6a>
f011393c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113940:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113947:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011394a:	8a 00                	mov    (%eax),%al
f011394c:	3c 61                	cmp    $0x61,%al
f011394e:	75 69                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f0113950:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113953:	8a 00                	mov    (%eax),%al
f0113955:	3c 61                	cmp    $0x61,%al
f0113957:	75 60                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f0113959:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011395c:	8a 00                	mov    (%eax),%al
f011395e:	3c 79                	cmp    $0x79,%al
f0113960:	75 57                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f0113962:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113965:	8a 00                	mov    (%eax),%al
f0113967:	3c 62                	cmp    $0x62,%al
f0113969:	75 4e                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f011396b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011396e:	8a 00                	mov    (%eax),%al
f0113970:	3c 7a                	cmp    $0x7a,%al
f0113972:	75 45                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f0113974:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113977:	8a 00                	mov    (%eax),%al
f0113979:	3c 7a                	cmp    $0x7a,%al
f011397b:	75 3c                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011397d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113980:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113982:	3c 64                	cmp    $0x64,%al
f0113984:	75 33                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113986:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113989:	8a 00                	mov    (%eax),%al
f011398b:	3c 64                	cmp    $0x64,%al
f011398d:	75 2a                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f011398f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113992:	8a 00                	mov    (%eax),%al
f0113994:	3c 65                	cmp    $0x65,%al
f0113996:	75 21                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f0113998:	8b 45 98             	mov    -0x68(%ebp),%eax
f011399b:	8a 00                	mov    (%eax),%al
f011399d:	3c 78                	cmp    $0x78,%al
f011399f:	75 18                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f01139a1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01139a4:	8a 00                	mov    (%eax),%al
f01139a6:	3c 66                	cmp    $0x66,%al
f01139a8:	75 0f                	jne    f01139b9 <test_copy_paste_chunk+0xbe3>
f01139aa:	8b 45 90             	mov    -0x70(%ebp),%eax
f01139ad:	8a 10                	mov    (%eax),%dl
f01139af:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01139b5:	38 c2                	cmp    %al,%dl
f01139b7:	74 21                	je     f01139da <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01139b9:	83 ec 04             	sub    $0x4,%esp
f01139bc:	68 78 99 12 f0       	push   $0xf0129978
f01139c1:	68 77 03 00 00       	push   $0x377
f01139c6:	68 82 91 12 f0       	push   $0xf0129182
f01139cb:	e8 06 cb fe ff       	call   f01004d6 <_warn>
f01139d0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01139d3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01139da:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01139de:	74 04                	je     f01139e4 <test_copy_paste_chunk+0xc0e>
f01139e0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01139e4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f01139eb:	83 ec 0c             	sub    $0xc,%esp
f01139ee:	68 0f 9b 12 f0       	push   $0xf0129b0f
f01139f3:	e8 93 d5 fe ff       	call   f0100f8b <cprintf>
f01139f8:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01139fb:	83 ec 0c             	sub    $0xc,%esp
f01139fe:	68 20 9b 12 f0       	push   $0xf0129b20
f0113a03:	e8 83 d5 fe ff       	call   f0100f8b <cprintf>
f0113a08:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113a0b:	83 ec 04             	sub    $0x4,%esp
f0113a0e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a14:	50                   	push   %eax
f0113a15:	68 54 9b 12 f0       	push   $0xf0129b54
f0113a1a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a20:	50                   	push   %eax
f0113a21:	e8 75 c7 00 00       	call   f012019b <strcconcat>
f0113a26:	83 c4 10             	add    $0x10,%esp
f0113a29:	83 ec 0c             	sub    $0xc,%esp
f0113a2c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a32:	50                   	push   %eax
f0113a33:	e8 c3 e4 fe ff       	call   f0101efb <execute_command>
f0113a38:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113a3b:	83 ec 04             	sub    $0x4,%esp
f0113a3e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a44:	50                   	push   %eax
f0113a45:	68 5e 9b 12 f0       	push   $0xf0129b5e
f0113a4a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a50:	50                   	push   %eax
f0113a51:	e8 45 c7 00 00       	call   f012019b <strcconcat>
f0113a56:	83 c4 10             	add    $0x10,%esp
f0113a59:	83 ec 0c             	sub    $0xc,%esp
f0113a5c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a62:	50                   	push   %eax
f0113a63:	e8 93 e4 fe ff       	call   f0101efb <execute_command>
f0113a68:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113a6b:	83 ec 04             	sub    $0x4,%esp
f0113a6e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a74:	50                   	push   %eax
f0113a75:	68 68 9b 12 f0       	push   $0xf0129b68
f0113a7a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a80:	50                   	push   %eax
f0113a81:	e8 15 c7 00 00       	call   f012019b <strcconcat>
f0113a86:	83 c4 10             	add    $0x10,%esp
f0113a89:	83 ec 0c             	sub    $0xc,%esp
f0113a8c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a92:	50                   	push   %eax
f0113a93:	e8 63 e4 fe ff       	call   f0101efb <execute_command>
f0113a98:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113a9b:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113aa1:	bb 01 a3 12 f0       	mov    $0xf012a301,%ebx
f0113aa6:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113aab:	89 c7                	mov    %eax,%edi
f0113aad:	89 de                	mov    %ebx,%esi
f0113aaf:	89 d1                	mov    %edx,%ecx
f0113ab1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ab3:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113ab9:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113abe:	b0 00                	mov    $0x0,%al
f0113ac0:	89 d7                	mov    %edx,%edi
f0113ac2:	f3 aa                	rep stos %al,%es:(%edi)
f0113ac4:	83 ec 0c             	sub    $0xc,%esp
f0113ac7:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113acd:	50                   	push   %eax
f0113ace:	e8 28 e4 fe ff       	call   f0101efb <execute_command>
f0113ad3:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113ad6:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113adc:	bb 65 a3 12 f0       	mov    $0xf012a365,%ebx
f0113ae1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ae6:	89 c7                	mov    %eax,%edi
f0113ae8:	89 de                	mov    %ebx,%esi
f0113aea:	89 d1                	mov    %edx,%ecx
f0113aec:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113aee:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113af4:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113af9:	b0 00                	mov    $0x0,%al
f0113afb:	89 d7                	mov    %edx,%edi
f0113afd:	f3 aa                	rep stos %al,%es:(%edi)
f0113aff:	83 ec 0c             	sub    $0xc,%esp
f0113b02:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b08:	50                   	push   %eax
f0113b09:	e8 ed e3 fe ff       	call   f0101efb <execute_command>
f0113b0e:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113b11:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b17:	bb c9 a3 12 f0       	mov    $0xf012a3c9,%ebx
f0113b1c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b21:	89 c7                	mov    %eax,%edi
f0113b23:	89 de                	mov    %ebx,%esi
f0113b25:	89 d1                	mov    %edx,%ecx
f0113b27:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b29:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113b2f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b34:	b0 00                	mov    $0x0,%al
f0113b36:	89 d7                	mov    %edx,%edi
f0113b38:	f3 aa                	rep stos %al,%es:(%edi)
f0113b3a:	83 ec 0c             	sub    $0xc,%esp
f0113b3d:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b43:	50                   	push   %eax
f0113b44:	e8 b2 e3 fe ff       	call   f0101efb <execute_command>
f0113b49:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113b4c:	e8 b1 ad ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113b51:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113b54:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b57:	89 d0                	mov    %edx,%eax
f0113b59:	01 c0                	add    %eax,%eax
f0113b5b:	01 d0                	add    %edx,%eax
f0113b5d:	c1 e0 02             	shl    $0x2,%eax
f0113b60:	50                   	push   %eax
f0113b61:	68 00 00 90 00       	push   $0x900000
f0113b66:	68 00 00 80 00       	push   $0x800000
f0113b6b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b6e:	e8 8c 6f ff ff       	call   f010aaff <copy_paste_chunk>
f0113b73:	83 c4 10             	add    $0x10,%esp
f0113b76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b7c:	e8 81 ad ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113b81:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113b84:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113b8b:	75 0b                	jne    f0113b98 <test_copy_paste_chunk+0xdc2>
f0113b8d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b90:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b93:	83 f8 03             	cmp    $0x3,%eax
f0113b96:	74 2e                	je     f0113bc6 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113b98:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b9b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b9e:	83 ec 0c             	sub    $0xc,%esp
f0113ba1:	50                   	push   %eax
f0113ba2:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113ba8:	68 24 9a 12 f0       	push   $0xf0129a24
f0113bad:	68 95 03 00 00       	push   $0x395
f0113bb2:	68 82 91 12 f0       	push   $0xf0129182
f0113bb7:	e8 1a c9 fe ff       	call   f01004d6 <_warn>
f0113bbc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113bbf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113bc6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113bca:	74 04                	je     f0113bd0 <test_copy_paste_chunk+0xdfa>
f0113bcc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113bd0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113bd7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113bde:	83 ec 08             	sub    $0x8,%esp
f0113be1:	6a 01                	push   $0x1
f0113be3:	6a 07                	push   $0x7
f0113be5:	6a 07                	push   $0x7
f0113be7:	6a 07                	push   $0x7
f0113be9:	6a 07                	push   $0x7
f0113beb:	6a 01                	push   $0x1
f0113bed:	68 00 30 00 00       	push   $0x3000
f0113bf2:	68 00 00 90 00       	push   $0x900000
f0113bf7:	68 00 00 80 00       	push   $0x800000
f0113bfc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113bff:	e8 26 2e 00 00       	call   f0116a2a <CCP>
f0113c04:	83 c4 30             	add    $0x30,%esp
f0113c07:	83 f8 01             	cmp    $0x1,%eax
f0113c0a:	74 28                	je     f0113c34 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113c0c:	83 ec 04             	sub    $0x4,%esp
f0113c0f:	68 c4 9a 12 f0       	push   $0xf0129ac4
f0113c14:	68 9e 03 00 00       	push   $0x39e
f0113c19:	68 82 91 12 f0       	push   $0xf0129182
f0113c1e:	e8 b3 c8 fe ff       	call   f01004d6 <_warn>
f0113c23:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113c2d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113c34:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c38:	74 04                	je     f0113c3e <test_copy_paste_chunk+0xe68>
f0113c3a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c3e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113c45:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113c49:	0f 84 9e 00 00 00    	je     f0113ced <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113c4f:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113c56:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113c5d:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113c64:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113c6b:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113c72:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113c79:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c7c:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113c7f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113c82:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113c85:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c88:	8a 00                	mov    (%eax),%al
f0113c8a:	3c 61                	cmp    $0x61,%al
f0113c8c:	75 2d                	jne    f0113cbb <test_copy_paste_chunk+0xee5>
f0113c8e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113c91:	8a 00                	mov    (%eax),%al
f0113c93:	3c 61                	cmp    $0x61,%al
f0113c95:	75 24                	jne    f0113cbb <test_copy_paste_chunk+0xee5>
f0113c97:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c9a:	8a 00                	mov    (%eax),%al
f0113c9c:	3c 79                	cmp    $0x79,%al
f0113c9e:	75 1b                	jne    f0113cbb <test_copy_paste_chunk+0xee5>
f0113ca0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113ca3:	8a 00                	mov    (%eax),%al
f0113ca5:	3c 62                	cmp    $0x62,%al
f0113ca7:	75 12                	jne    f0113cbb <test_copy_paste_chunk+0xee5>
f0113ca9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113cac:	8a 00                	mov    (%eax),%al
f0113cae:	3c 63                	cmp    $0x63,%al
f0113cb0:	75 09                	jne    f0113cbb <test_copy_paste_chunk+0xee5>
f0113cb2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113cb5:	8a 00                	mov    (%eax),%al
f0113cb7:	3c 7a                	cmp    $0x7a,%al
f0113cb9:	74 21                	je     f0113cdc <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113cbb:	83 ec 04             	sub    $0x4,%esp
f0113cbe:	68 78 99 12 f0       	push   $0xf0129978
f0113cc3:	68 b0 03 00 00       	push   $0x3b0
f0113cc8:	68 82 91 12 f0       	push   $0xf0129182
f0113ccd:	e8 04 c8 fe ff       	call   f01004d6 <_warn>
f0113cd2:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113cd5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113cdc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ce0:	74 04                	je     f0113ce6 <test_copy_paste_chunk+0xf10>
f0113ce2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113ce6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ced:	e8 10 ac ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113cf2:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113cf5:	6a 00                	push   $0x0
f0113cf7:	6a 02                	push   $0x2
f0113cf9:	68 00 10 90 00       	push   $0x901000
f0113cfe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d01:	e8 b1 2b 00 00       	call   f01168b7 <SB>
f0113d06:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113d09:	6a 00                	push   $0x0
f0113d0b:	6a 02                	push   $0x2
f0113d0d:	68 00 20 90 00       	push   $0x902000
f0113d12:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d15:	e8 9d 2b 00 00       	call   f01168b7 <SB>
f0113d1a:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113d1d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113d20:	c1 e0 03             	shl    $0x3,%eax
f0113d23:	50                   	push   %eax
f0113d24:	68 00 f0 bf 00       	push   $0xbff000
f0113d29:	68 00 10 90 00       	push   $0x901000
f0113d2e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d31:	e8 c9 6d ff ff       	call   f010aaff <copy_paste_chunk>
f0113d36:	83 c4 10             	add    $0x10,%esp
f0113d39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d3f:	e8 be ab ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113d44:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113d47:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113d4e:	75 0b                	jne    f0113d5b <test_copy_paste_chunk+0xf85>
f0113d50:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113d53:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113d56:	83 f8 03             	cmp    $0x3,%eax
f0113d59:	74 2e                	je     f0113d89 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113d5b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113d5e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113d61:	83 ec 0c             	sub    $0xc,%esp
f0113d64:	50                   	push   %eax
f0113d65:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113d6b:	68 24 9a 12 f0       	push   $0xf0129a24
f0113d70:	68 c0 03 00 00       	push   $0x3c0
f0113d75:	68 82 91 12 f0       	push   $0xf0129182
f0113d7a:	e8 57 c7 fe ff       	call   f01004d6 <_warn>
f0113d7f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113d82:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113d89:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d8d:	74 04                	je     f0113d93 <test_copy_paste_chunk+0xfbd>
f0113d8f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113d93:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113d9a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113da1:	83 ec 08             	sub    $0x8,%esp
f0113da4:	6a 01                	push   $0x1
f0113da6:	6a 07                	push   $0x7
f0113da8:	6a 03                	push   $0x3
f0113daa:	6a 07                	push   $0x7
f0113dac:	6a 03                	push   $0x3
f0113dae:	6a 01                	push   $0x1
f0113db0:	68 00 20 00 00       	push   $0x2000
f0113db5:	68 00 f0 bf 00       	push   $0xbff000
f0113dba:	68 00 10 90 00       	push   $0x901000
f0113dbf:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dc2:	e8 63 2c 00 00       	call   f0116a2a <CCP>
f0113dc7:	83 c4 30             	add    $0x30,%esp
f0113dca:	83 f8 01             	cmp    $0x1,%eax
f0113dcd:	74 28                	je     f0113df7 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113dcf:	83 ec 04             	sub    $0x4,%esp
f0113dd2:	68 c4 9a 12 f0       	push   $0xf0129ac4
f0113dd7:	68 c9 03 00 00       	push   $0x3c9
f0113ddc:	68 82 91 12 f0       	push   $0xf0129182
f0113de1:	e8 f0 c6 fe ff       	call   f01004d6 <_warn>
f0113de6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113de9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113df0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0113df7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113dfb:	74 04                	je     f0113e01 <test_copy_paste_chunk+0x102b>
f0113dfd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113e01:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113e08:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113e0c:	74 72                	je     f0113e80 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0113e0e:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0113e15:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0113e1c:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0113e23:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113e2a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e2d:	8a 00                	mov    (%eax),%al
f0113e2f:	3c 62                	cmp    $0x62,%al
f0113e31:	75 1b                	jne    f0113e4e <test_copy_paste_chunk+0x1078>
f0113e33:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e36:	8a 00                	mov    (%eax),%al
f0113e38:	3c 62                	cmp    $0x62,%al
f0113e3a:	75 12                	jne    f0113e4e <test_copy_paste_chunk+0x1078>
f0113e3c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113e3f:	8a 00                	mov    (%eax),%al
f0113e41:	3c 7a                	cmp    $0x7a,%al
f0113e43:	75 09                	jne    f0113e4e <test_copy_paste_chunk+0x1078>
f0113e45:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113e48:	8a 00                	mov    (%eax),%al
f0113e4a:	3c 7a                	cmp    $0x7a,%al
f0113e4c:	74 21                	je     f0113e6f <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113e4e:	83 ec 04             	sub    $0x4,%esp
f0113e51:	68 78 99 12 f0       	push   $0xf0129978
f0113e56:	68 d5 03 00 00       	push   $0x3d5
f0113e5b:	68 82 91 12 f0       	push   $0xf0129182
f0113e60:	e8 71 c6 fe ff       	call   f01004d6 <_warn>
f0113e65:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113e68:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113e6f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e73:	74 04                	je     f0113e79 <test_copy_paste_chunk+0x10a3>
f0113e75:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113e79:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113e80:	83 ec 0c             	sub    $0xc,%esp
f0113e83:	68 72 9b 12 f0       	push   $0xf0129b72
f0113e88:	e8 fe d0 fe ff       	call   f0100f8b <cprintf>
f0113e8d:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113e90:	83 ec 08             	sub    $0x8,%esp
f0113e93:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113e96:	68 84 9b 12 f0       	push   $0xf0129b84
f0113e9b:	e8 eb d0 fe ff       	call   f0100f8b <cprintf>
f0113ea0:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113ea3:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113ea7:	75 10                	jne    f0113eb9 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113ea9:	83 ec 0c             	sub    $0xc,%esp
f0113eac:	68 b8 9b 12 f0       	push   $0xf0129bb8
f0113eb1:	e8 d5 d0 fe ff       	call   f0100f8b <cprintf>
f0113eb6:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113eb9:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f0113ebe:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113ec1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113ec4:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113ec7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113ecc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113ecf:	5b                   	pop    %ebx
f0113ed0:	5e                   	pop    %esi
f0113ed1:	5f                   	pop    %edi
f0113ed2:	5d                   	pop    %ebp
f0113ed3:	c3                   	ret    

f0113ed4 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0113ed4:	55                   	push   %ebp
f0113ed5:	89 e5                	mov    %esp,%ebp
f0113ed7:	57                   	push   %edi
f0113ed8:	56                   	push   %esi
f0113ed9:	53                   	push   %ebx
f0113eda:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113ee0:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113ee6:	bb 84 98 12 f0       	mov    $0xf0129884,%ebx
f0113eeb:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ef0:	89 c7                	mov    %eax,%edi
f0113ef2:	89 de                	mov    %ebx,%esi
f0113ef4:	89 d1                	mov    %edx,%ecx
f0113ef6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ef8:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0113efe:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113f03:	b0 00                	mov    $0x0,%al
f0113f05:	89 d7                	mov    %edx,%edi
f0113f07:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113f09:	6a 00                	push   $0x0
f0113f0b:	6a 0a                	push   $0xa
f0113f0d:	6a 14                	push   $0x14
f0113f0f:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113f15:	50                   	push   %eax
f0113f16:	e8 47 70 ff ff       	call   f010af62 <env_create>
f0113f1b:	83 c4 10             	add    $0x10,%esp
f0113f1e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113f21:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113f24:	8b 40 64             	mov    0x64(%eax),%eax
f0113f27:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113f2d:	8b 40 68             	mov    0x68(%eax),%eax
f0113f30:	89 45 80             	mov    %eax,-0x80(%ebp)
f0113f33:	8b 45 80             	mov    -0x80(%ebp),%eax
f0113f36:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113f39:	83 ec 0c             	sub    $0xc,%esp
f0113f3c:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f3f:	e8 b2 2a 00 00       	call   f01169f6 <ClearUserSpace>
f0113f44:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113f47:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113f4e:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0113f55:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113f5c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113f60:	83 ec 0c             	sub    $0xc,%esp
f0113f63:	68 30 a4 12 f0       	push   $0xf012a430
f0113f68:	e8 1e d0 fe ff       	call   f0100f8b <cprintf>
f0113f6d:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113f70:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0113f77:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113f7e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f81:	8a 00                	mov    (%eax),%al
f0113f83:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113f89:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113f8c:	8a 00                	mov    (%eax),%al
f0113f8e:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113f94:	e8 69 a9 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113f99:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113f9c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113f9f:	89 d0                	mov    %edx,%eax
f0113fa1:	01 c0                	add    %eax,%eax
f0113fa3:	01 d0                	add    %edx,%eax
f0113fa5:	01 c0                	add    %eax,%eax
f0113fa7:	83 ec 0c             	sub    $0xc,%esp
f0113faa:	6a 02                	push   $0x2
f0113fac:	50                   	push   %eax
f0113fad:	68 00 40 10 f0       	push   $0xf0104000
f0113fb2:	68 00 00 10 f0       	push   $0xf0100000
f0113fb7:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fba:	e8 5a 6b ff ff       	call   f010ab19 <share_chunk>
f0113fbf:	83 c4 20             	add    $0x20,%esp
f0113fc2:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113fc5:	e8 38 a9 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0113fca:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113fcd:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113fd1:	75 08                	jne    f0113fdb <test_share_chunk+0x107>
f0113fd3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113fd6:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113fd9:	74 28                	je     f0114003 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0113fdb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113fde:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113fe1:	83 ec 0c             	sub    $0xc,%esp
f0113fe4:	50                   	push   %eax
f0113fe5:	ff 75 b0             	pushl  -0x50(%ebp)
f0113fe8:	68 5c a4 12 f0       	push   $0xf012a45c
f0113fed:	68 11 04 00 00       	push   $0x411
f0113ff2:	68 82 91 12 f0       	push   $0xf0129182
f0113ff7:	e8 da c4 fe ff       	call   f01004d6 <_warn>
f0113ffc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113fff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114003:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114007:	74 04                	je     f011400d <test_share_chunk+0x139>
f0114009:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011400d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114011:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114014:	c1 e0 03             	shl    $0x3,%eax
f0114017:	83 ec 08             	sub    $0x8,%esp
f011401a:	68 fd 00 00 00       	push   $0xfd
f011401f:	6a 07                	push   $0x7
f0114021:	6a 03                	push   $0x3
f0114023:	6a 07                	push   $0x7
f0114025:	6a 03                	push   $0x3
f0114027:	6a 01                	push   $0x1
f0114029:	50                   	push   %eax
f011402a:	68 00 40 10 f0       	push   $0xf0104000
f011402f:	68 00 00 10 f0       	push   $0xf0100000
f0114034:	ff 75 cc             	pushl  -0x34(%ebp)
f0114037:	e8 ee 29 00 00       	call   f0116a2a <CCP>
f011403c:	83 c4 30             	add    $0x30,%esp
f011403f:	85 c0                	test   %eax,%eax
f0114041:	75 1e                	jne    f0114061 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114043:	83 ec 04             	sub    $0x4,%esp
f0114046:	68 b8 a4 12 f0       	push   $0xf012a4b8
f011404b:	68 19 04 00 00       	push   $0x419
f0114050:	68 82 91 12 f0       	push   $0xf0129182
f0114055:	e8 7c c4 fe ff       	call   f01004d6 <_warn>
f011405a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011405d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114061:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114065:	74 04                	je     f011406b <test_share_chunk+0x197>
f0114067:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f011406b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011406e:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0114071:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114074:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0114077:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011407a:	8a 00                	mov    (%eax),%al
f011407c:	3c 41                	cmp    $0x41,%al
f011407e:	75 09                	jne    f0114089 <test_share_chunk+0x1b5>
f0114080:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114083:	8a 00                	mov    (%eax),%al
f0114085:	3c 42                	cmp    $0x42,%al
f0114087:	74 1e                	je     f01140a7 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114089:	83 ec 04             	sub    $0x4,%esp
f011408c:	68 00 a5 12 f0       	push   $0xf012a500
f0114091:	68 23 04 00 00       	push   $0x423
f0114096:	68 82 91 12 f0       	push   $0xf0129182
f011409b:	e8 36 c4 fe ff       	call   f01004d6 <_warn>
f01140a0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01140a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01140a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140ab:	74 04                	je     f01140b1 <test_share_chunk+0x1dd>
f01140ad:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01140b1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01140b5:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f01140bb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140be:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f01140c0:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f01140c6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140c9:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f01140cb:	83 ec 0c             	sub    $0xc,%esp
f01140ce:	68 35 a5 12 f0       	push   $0xf012a535
f01140d3:	e8 b3 ce fe ff       	call   f0100f8b <cprintf>
f01140d8:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f01140db:	83 ec 0c             	sub    $0xc,%esp
f01140de:	68 44 a5 12 f0       	push   $0xf012a544
f01140e3:	e8 a3 ce fe ff       	call   f0100f8b <cprintf>
f01140e8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01140eb:	e8 12 a8 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01140f0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01140f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01140f6:	c1 e0 05             	shl    $0x5,%eax
f01140f9:	83 ec 0c             	sub    $0xc,%esp
f01140fc:	68 02 0e 00 00       	push   $0xe02
f0114101:	50                   	push   %eax
f0114102:	68 00 00 00 40       	push   $0x40000000
f0114107:	68 00 00 00 f0       	push   $0xf0000000
f011410c:	ff 75 cc             	pushl  -0x34(%ebp)
f011410f:	e8 05 6a ff ff       	call   f010ab19 <share_chunk>
f0114114:	83 c4 20             	add    $0x20,%esp
f0114117:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011411a:	e8 e3 a7 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011411f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0114122:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114126:	75 1f                	jne    f0114147 <test_share_chunk+0x273>
f0114128:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011412b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011412e:	89 c1                	mov    %eax,%ecx
f0114130:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114133:	c1 e0 05             	shl    $0x5,%eax
f0114136:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114139:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114140:	99                   	cltd   
f0114141:	f7 fb                	idiv   %ebx
f0114143:	39 c1                	cmp    %eax,%ecx
f0114145:	74 28                	je     f011416f <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114147:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011414a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011414d:	83 ec 0c             	sub    $0xc,%esp
f0114150:	50                   	push   %eax
f0114151:	ff 75 a8             	pushl  -0x58(%ebp)
f0114154:	68 80 a5 12 f0       	push   $0xf012a580
f0114159:	68 3b 04 00 00       	push   $0x43b
f011415e:	68 82 91 12 f0       	push   $0xf0129182
f0114163:	e8 6e c3 fe ff       	call   f01004d6 <_warn>
f0114168:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011416b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011416f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114173:	74 04                	je     f0114179 <test_share_chunk+0x2a5>
f0114175:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114179:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011417d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114184:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114187:	c1 e0 05             	shl    $0x5,%eax
f011418a:	83 ec 08             	sub    $0x8,%esp
f011418d:	6a 02                	push   $0x2
f011418f:	6a 07                	push   $0x7
f0114191:	6a 03                	push   $0x3
f0114193:	68 07 0e 00 00       	push   $0xe07
f0114198:	68 03 0e 00 00       	push   $0xe03
f011419d:	6a ff                	push   $0xffffffff
f011419f:	50                   	push   %eax
f01141a0:	68 00 00 00 40       	push   $0x40000000
f01141a5:	68 00 00 00 f0       	push   $0xf0000000
f01141aa:	ff 75 cc             	pushl  -0x34(%ebp)
f01141ad:	e8 78 28 00 00       	call   f0116a2a <CCP>
f01141b2:	83 c4 30             	add    $0x30,%esp
f01141b5:	85 c0                	test   %eax,%eax
f01141b7:	75 25                	jne    f01141de <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01141b9:	83 ec 04             	sub    $0x4,%esp
f01141bc:	68 b8 a4 12 f0       	push   $0xf012a4b8
f01141c1:	68 44 04 00 00       	push   $0x444
f01141c6:	68 82 91 12 f0       	push   $0xf0129182
f01141cb:	e8 06 c3 fe ff       	call   f01004d6 <_warn>
f01141d0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01141d3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01141d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01141de:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01141e1:	89 d0                	mov    %edx,%eax
f01141e3:	01 c0                	add    %eax,%eax
f01141e5:	01 d0                	add    %edx,%eax
f01141e7:	c1 e0 02             	shl    $0x2,%eax
f01141ea:	83 ec 08             	sub    $0x8,%esp
f01141ed:	6a 02                	push   $0x2
f01141ef:	6a 07                	push   $0x7
f01141f1:	6a 03                	push   $0x3
f01141f3:	68 07 0e 00 00       	push   $0xe07
f01141f8:	68 03 0e 00 00       	push   $0xe03
f01141fd:	6a 02                	push   $0x2
f01141ff:	50                   	push   %eax
f0114200:	68 00 00 00 40       	push   $0x40000000
f0114205:	68 00 00 00 f0       	push   $0xf0000000
f011420a:	ff 75 cc             	pushl  -0x34(%ebp)
f011420d:	e8 18 28 00 00       	call   f0116a2a <CCP>
f0114212:	83 c4 30             	add    $0x30,%esp
f0114215:	85 c0                	test   %eax,%eax
f0114217:	75 1e                	jne    f0114237 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114219:	83 ec 04             	sub    $0x4,%esp
f011421c:	68 b8 a4 12 f0       	push   $0xf012a4b8
f0114221:	68 4b 04 00 00       	push   $0x44b
f0114226:	68 82 91 12 f0       	push   $0xf0129182
f011422b:	e8 a6 c2 fe ff       	call   f01004d6 <_warn>
f0114230:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114233:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114237:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011423b:	74 04                	je     f0114241 <test_share_chunk+0x36d>
f011423d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114241:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0114245:	b8 50 60 65 f2       	mov    $0xf2656050,%eax
f011424a:	05 00 00 00 10       	add    $0x10000000,%eax
f011424f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114252:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114255:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f011425a:	83 ec 08             	sub    $0x8,%esp
f011425d:	6a 02                	push   $0x2
f011425f:	6a 07                	push   $0x7
f0114261:	6a 03                	push   $0x3
f0114263:	68 07 0e 00 00       	push   $0xe07
f0114268:	68 03 0e 00 00       	push   $0xe03
f011426d:	6a 02                	push   $0x2
f011426f:	50                   	push   %eax
f0114270:	68 00 00 0a 40       	push   $0x400a0000
f0114275:	68 00 00 0a f0       	push   $0xf00a0000
f011427a:	ff 75 cc             	pushl  -0x34(%ebp)
f011427d:	e8 a8 27 00 00       	call   f0116a2a <CCP>
f0114282:	83 c4 30             	add    $0x30,%esp
f0114285:	85 c0                	test   %eax,%eax
f0114287:	75 1e                	jne    f01142a7 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114289:	83 ec 04             	sub    $0x4,%esp
f011428c:	68 b8 a4 12 f0       	push   $0xf012a4b8
f0114291:	68 55 04 00 00       	push   $0x455
f0114296:	68 82 91 12 f0       	push   $0xf0129182
f011429b:	e8 36 c2 fe ff       	call   f01004d6 <_warn>
f01142a0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01142a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142ab:	74 04                	je     f01142b1 <test_share_chunk+0x3dd>
f01142ad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142b1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01142b5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01142b9:	0f 84 a4 00 00 00    	je     f0114363 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f01142bf:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f01142c6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142c9:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f01142cc:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f01142d3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142d6:	8a 00                	mov    (%eax),%al
f01142d8:	3c 41                	cmp    $0x41,%al
f01142da:	75 09                	jne    f01142e5 <test_share_chunk+0x411>
f01142dc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142df:	8a 00                	mov    (%eax),%al
f01142e1:	3c 41                	cmp    $0x41,%al
f01142e3:	74 1e                	je     f0114303 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01142e5:	83 ec 04             	sub    $0x4,%esp
f01142e8:	68 00 a5 12 f0       	push   $0xf012a500
f01142ed:	68 62 04 00 00       	push   $0x462
f01142f2:	68 82 91 12 f0       	push   $0xf0129182
f01142f7:	e8 da c1 fe ff       	call   f01004d6 <_warn>
f01142fc:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01142ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114303:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114307:	74 04                	je     f011430d <test_share_chunk+0x439>
f0114309:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011430d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114311:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0114318:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011431b:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f011431e:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0114325:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114328:	8a 00                	mov    (%eax),%al
f011432a:	3c 43                	cmp    $0x43,%al
f011432c:	75 09                	jne    f0114337 <test_share_chunk+0x463>
f011432e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114331:	8a 00                	mov    (%eax),%al
f0114333:	3c 43                	cmp    $0x43,%al
f0114335:	74 1e                	je     f0114355 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114337:	83 ec 04             	sub    $0x4,%esp
f011433a:	68 00 a5 12 f0       	push   $0xf012a500
f011433f:	68 6d 04 00 00       	push   $0x46d
f0114344:	68 82 91 12 f0       	push   $0xf0129182
f0114349:	e8 88 c1 fe ff       	call   f01004d6 <_warn>
f011434e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114351:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114355:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114359:	74 04                	je     f011435f <test_share_chunk+0x48b>
f011435b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011435f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114363:	83 ec 0c             	sub    $0xc,%esp
f0114366:	68 0f 9b 12 f0       	push   $0xf0129b0f
f011436b:	e8 1b cc fe ff       	call   f0100f8b <cprintf>
f0114370:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0114373:	83 ec 0c             	sub    $0xc,%esp
f0114376:	68 d0 a5 12 f0       	push   $0xf012a5d0
f011437b:	e8 0b cc fe ff       	call   f0100f8b <cprintf>
f0114380:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114383:	e8 7a a5 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114388:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f011438b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011438e:	89 d0                	mov    %edx,%eax
f0114390:	c1 e0 03             	shl    $0x3,%eax
f0114393:	01 d0                	add    %edx,%eax
f0114395:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011439c:	01 d0                	add    %edx,%eax
f011439e:	c1 e0 03             	shl    $0x3,%eax
f01143a1:	83 ec 0c             	sub    $0xc,%esp
f01143a4:	6a 06                	push   $0x6
f01143a6:	50                   	push   %eax
f01143a7:	6a 00                	push   $0x0
f01143a9:	68 00 00 00 40       	push   $0x40000000
f01143ae:	ff 75 cc             	pushl  -0x34(%ebp)
f01143b1:	e8 63 67 ff ff       	call   f010ab19 <share_chunk>
f01143b6:	83 c4 20             	add    $0x20,%esp
f01143b9:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01143bc:	e8 41 a5 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01143c1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01143c4:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f01143c8:	75 0b                	jne    f01143d5 <test_share_chunk+0x501>
f01143ca:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01143cd:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01143d0:	83 f8 01             	cmp    $0x1,%eax
f01143d3:	74 28                	je     f01143fd <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01143d5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01143d8:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01143db:	83 ec 0c             	sub    $0xc,%esp
f01143de:	50                   	push   %eax
f01143df:	ff 75 a0             	pushl  -0x60(%ebp)
f01143e2:	68 80 a5 12 f0       	push   $0xf012a580
f01143e7:	68 83 04 00 00       	push   $0x483
f01143ec:	68 82 91 12 f0       	push   $0xf0129182
f01143f1:	e8 e0 c0 fe ff       	call   f01004d6 <_warn>
f01143f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143f9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01143fd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114401:	74 04                	je     f0114407 <test_share_chunk+0x533>
f0114403:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114407:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011440b:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114412:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114415:	05 00 80 02 00       	add    $0x28000,%eax
f011441a:	c1 e0 02             	shl    $0x2,%eax
f011441d:	83 ec 08             	sub    $0x8,%esp
f0114420:	6a 02                	push   $0x2
f0114422:	6a 07                	push   $0x7
f0114424:	6a 03                	push   $0x3
f0114426:	6a 07                	push   $0x7
f0114428:	6a 07                	push   $0x7
f011442a:	6a ff                	push   $0xffffffff
f011442c:	50                   	push   %eax
f011442d:	6a 00                	push   $0x0
f011442f:	68 00 00 00 40       	push   $0x40000000
f0114434:	ff 75 cc             	pushl  -0x34(%ebp)
f0114437:	e8 ee 25 00 00       	call   f0116a2a <CCP>
f011443c:	83 c4 30             	add    $0x30,%esp
f011443f:	85 c0                	test   %eax,%eax
f0114441:	75 25                	jne    f0114468 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114443:	83 ec 04             	sub    $0x4,%esp
f0114446:	68 b8 a4 12 f0       	push   $0xf012a4b8
f011444b:	68 8c 04 00 00       	push   $0x48c
f0114450:	68 82 91 12 f0       	push   $0xf0129182
f0114455:	e8 7c c0 fe ff       	call   f01004d6 <_warn>
f011445a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011445d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114461:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114468:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011446b:	89 d0                	mov    %edx,%eax
f011446d:	01 c0                	add    %eax,%eax
f011446f:	01 d0                	add    %edx,%eax
f0114471:	c1 e0 02             	shl    $0x2,%eax
f0114474:	83 ec 08             	sub    $0x8,%esp
f0114477:	6a 02                	push   $0x2
f0114479:	6a 07                	push   $0x7
f011447b:	6a 03                	push   $0x3
f011447d:	6a 07                	push   $0x7
f011447f:	6a 07                	push   $0x7
f0114481:	6a 03                	push   $0x3
f0114483:	50                   	push   %eax
f0114484:	6a 00                	push   $0x0
f0114486:	68 00 00 00 40       	push   $0x40000000
f011448b:	ff 75 cc             	pushl  -0x34(%ebp)
f011448e:	e8 97 25 00 00       	call   f0116a2a <CCP>
f0114493:	83 c4 30             	add    $0x30,%esp
f0114496:	85 c0                	test   %eax,%eax
f0114498:	75 1e                	jne    f01144b8 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011449a:	83 ec 04             	sub    $0x4,%esp
f011449d:	68 b8 a4 12 f0       	push   $0xf012a4b8
f01144a2:	68 93 04 00 00       	push   $0x493
f01144a7:	68 82 91 12 f0       	push   $0xf0129182
f01144ac:	e8 25 c0 fe ff       	call   f01004d6 <_warn>
f01144b1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01144b8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144bc:	74 04                	je     f01144c2 <test_share_chunk+0x5ee>
f01144be:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144c2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01144c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01144c9:	89 d0                	mov    %edx,%eax
f01144cb:	01 c0                	add    %eax,%eax
f01144cd:	01 d0                	add    %edx,%eax
f01144cf:	c1 e0 02             	shl    $0x2,%eax
f01144d2:	f7 d8                	neg    %eax
f01144d4:	05 00 00 0a 00       	add    $0xa0000,%eax
f01144d9:	83 ec 08             	sub    $0x8,%esp
f01144dc:	6a 02                	push   $0x2
f01144de:	6a 07                	push   $0x7
f01144e0:	6a 03                	push   $0x3
f01144e2:	6a 07                	push   $0x7
f01144e4:	6a 07                	push   $0x7
f01144e6:	6a 02                	push   $0x2
f01144e8:	50                   	push   %eax
f01144e9:	68 00 30 00 00       	push   $0x3000
f01144ee:	68 00 30 00 40       	push   $0x40003000
f01144f3:	ff 75 cc             	pushl  -0x34(%ebp)
f01144f6:	e8 2f 25 00 00       	call   f0116a2a <CCP>
f01144fb:	83 c4 30             	add    $0x30,%esp
f01144fe:	85 c0                	test   %eax,%eax
f0114500:	75 1e                	jne    f0114520 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114502:	83 ec 04             	sub    $0x4,%esp
f0114505:	68 b8 a4 12 f0       	push   $0xf012a4b8
f011450a:	68 9b 04 00 00       	push   $0x49b
f011450f:	68 82 91 12 f0       	push   $0xf0129182
f0114514:	e8 bd bf fe ff       	call   f01004d6 <_warn>
f0114519:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011451c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114520:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114524:	74 04                	je     f011452a <test_share_chunk+0x656>
f0114526:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011452a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011452e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114531:	c1 e0 02             	shl    $0x2,%eax
f0114534:	83 ec 08             	sub    $0x8,%esp
f0114537:	6a 02                	push   $0x2
f0114539:	6a 07                	push   $0x7
f011453b:	6a 03                	push   $0x3
f011453d:	6a 07                	push   $0x7
f011453f:	6a 07                	push   $0x7
f0114541:	6a 03                	push   $0x3
f0114543:	50                   	push   %eax
f0114544:	68 00 00 0a 00       	push   $0xa0000
f0114549:	68 00 00 0a 40       	push   $0x400a0000
f011454e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114551:	e8 d4 24 00 00       	call   f0116a2a <CCP>
f0114556:	83 c4 30             	add    $0x30,%esp
f0114559:	85 c0                	test   %eax,%eax
f011455b:	75 1e                	jne    f011457b <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011455d:	83 ec 04             	sub    $0x4,%esp
f0114560:	68 b8 a4 12 f0       	push   $0xf012a4b8
f0114565:	68 a3 04 00 00       	push   $0x4a3
f011456a:	68 82 91 12 f0       	push   $0xf0129182
f011456f:	e8 62 bf fe ff       	call   f01004d6 <_warn>
f0114574:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114577:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011457b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011457f:	74 04                	je     f0114585 <test_share_chunk+0x6b1>
f0114581:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114585:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114589:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011458d:	0f 84 92 00 00 00    	je     f0114625 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114593:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f011459a:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01145a1:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01145a8:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01145af:	8b 45 98             	mov    -0x68(%ebp),%eax
f01145b2:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01145b5:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f01145bc:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01145c3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145c6:	8a 00                	mov    (%eax),%al
f01145c8:	3c 41                	cmp    $0x41,%al
f01145ca:	75 2d                	jne    f01145f9 <test_share_chunk+0x725>
f01145cc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145cf:	8a 00                	mov    (%eax),%al
f01145d1:	3c 41                	cmp    $0x41,%al
f01145d3:	75 24                	jne    f01145f9 <test_share_chunk+0x725>
f01145d5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01145d8:	8a 00                	mov    (%eax),%al
f01145da:	3c 41                	cmp    $0x41,%al
f01145dc:	75 1b                	jne    f01145f9 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01145de:	8b 45 98             	mov    -0x68(%ebp),%eax
f01145e1:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01145e3:	3c 44                	cmp    $0x44,%al
f01145e5:	75 12                	jne    f01145f9 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01145e7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01145ea:	8a 00                	mov    (%eax),%al
f01145ec:	3c 44                	cmp    $0x44,%al
f01145ee:	75 09                	jne    f01145f9 <test_share_chunk+0x725>
f01145f0:	8b 45 90             	mov    -0x70(%ebp),%eax
f01145f3:	8a 00                	mov    (%eax),%al
f01145f5:	3c 44                	cmp    $0x44,%al
f01145f7:	74 1e                	je     f0114617 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01145f9:	83 ec 04             	sub    $0x4,%esp
f01145fc:	68 00 a5 12 f0       	push   $0xf012a500
f0114601:	68 b5 04 00 00       	push   $0x4b5
f0114606:	68 82 91 12 f0       	push   $0xf0129182
f011460b:	e8 c6 be fe ff       	call   f01004d6 <_warn>
f0114610:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114613:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114617:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011461b:	74 04                	je     f0114621 <test_share_chunk+0x74d>
f011461d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114621:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114625:	83 ec 0c             	sub    $0xc,%esp
f0114628:	68 72 9b 12 f0       	push   $0xf0129b72
f011462d:	e8 59 c9 fe ff       	call   f0100f8b <cprintf>
f0114632:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0114635:	83 ec 0c             	sub    $0xc,%esp
f0114638:	68 0c a6 12 f0       	push   $0xf012a60c
f011463d:	e8 49 c9 fe ff       	call   f0100f8b <cprintf>
f0114642:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114645:	e8 b8 a2 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011464a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f011464d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114650:	89 d0                	mov    %edx,%eax
f0114652:	01 c0                	add    %eax,%eax
f0114654:	01 d0                	add    %edx,%eax
f0114656:	01 c0                	add    %eax,%eax
f0114658:	01 d0                	add    %edx,%eax
f011465a:	83 ec 0c             	sub    $0xc,%esp
f011465d:	6a 04                	push   $0x4
f011465f:	50                   	push   %eax
f0114660:	68 00 fc 3f 00       	push   $0x3ffc00
f0114665:	68 00 fc 09 00       	push   $0x9fc00
f011466a:	ff 75 cc             	pushl  -0x34(%ebp)
f011466d:	e8 a7 64 ff ff       	call   f010ab19 <share_chunk>
f0114672:	83 c4 20             	add    $0x20,%esp
f0114675:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114678:	e8 85 a2 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011467d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114680:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114684:	75 0b                	jne    f0114691 <test_share_chunk+0x7bd>
f0114686:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114689:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011468c:	83 f8 01             	cmp    $0x1,%eax
f011468f:	74 28                	je     f01146b9 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114691:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114694:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114697:	83 ec 0c             	sub    $0xc,%esp
f011469a:	50                   	push   %eax
f011469b:	ff 75 8c             	pushl  -0x74(%ebp)
f011469e:	68 80 a5 12 f0       	push   $0xf012a580
f01146a3:	68 cb 04 00 00       	push   $0x4cb
f01146a8:	68 82 91 12 f0       	push   $0xf0129182
f01146ad:	e8 24 be fe ff       	call   f01004d6 <_warn>
f01146b2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01146b5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01146b9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146bd:	74 04                	je     f01146c3 <test_share_chunk+0x7ef>
f01146bf:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01146c3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01146c7:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01146ce:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01146d1:	89 d0                	mov    %edx,%eax
f01146d3:	01 c0                	add    %eax,%eax
f01146d5:	01 d0                	add    %edx,%eax
f01146d7:	c1 e0 02             	shl    $0x2,%eax
f01146da:	83 ec 08             	sub    $0x8,%esp
f01146dd:	6a 02                	push   $0x2
f01146df:	6a 07                	push   $0x7
f01146e1:	6a 07                	push   $0x7
f01146e3:	6a 07                	push   $0x7
f01146e5:	6a 05                	push   $0x5
f01146e7:	6a ff                	push   $0xffffffff
f01146e9:	50                   	push   %eax
f01146ea:	68 00 f0 3f 00       	push   $0x3ff000
f01146ef:	68 00 f0 09 00       	push   $0x9f000
f01146f4:	ff 75 cc             	pushl  -0x34(%ebp)
f01146f7:	e8 2e 23 00 00       	call   f0116a2a <CCP>
f01146fc:	83 c4 30             	add    $0x30,%esp
f01146ff:	85 c0                	test   %eax,%eax
f0114701:	75 25                	jne    f0114728 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114703:	83 ec 04             	sub    $0x4,%esp
f0114706:	68 b8 a4 12 f0       	push   $0xf012a4b8
f011470b:	68 d4 04 00 00       	push   $0x4d4
f0114710:	68 82 91 12 f0       	push   $0xf0129182
f0114715:	e8 bc bd fe ff       	call   f01004d6 <_warn>
f011471a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011471d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114721:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0114728:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011472c:	74 04                	je     f0114732 <test_share_chunk+0x85e>
f011472e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114732:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114736:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114739:	c1 e0 02             	shl    $0x2,%eax
f011473c:	83 ec 08             	sub    $0x8,%esp
f011473f:	6a 02                	push   $0x2
f0114741:	6a 07                	push   $0x7
f0114743:	6a 07                	push   $0x7
f0114745:	6a 07                	push   $0x7
f0114747:	6a 05                	push   $0x5
f0114749:	6a 03                	push   $0x3
f011474b:	50                   	push   %eax
f011474c:	68 00 f0 3f 00       	push   $0x3ff000
f0114751:	68 00 f0 09 00       	push   $0x9f000
f0114756:	ff 75 cc             	pushl  -0x34(%ebp)
f0114759:	e8 cc 22 00 00       	call   f0116a2a <CCP>
f011475e:	83 c4 30             	add    $0x30,%esp
f0114761:	85 c0                	test   %eax,%eax
f0114763:	75 1e                	jne    f0114783 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114765:	83 ec 04             	sub    $0x4,%esp
f0114768:	68 b8 a4 12 f0       	push   $0xf012a4b8
f011476d:	68 dd 04 00 00       	push   $0x4dd
f0114772:	68 82 91 12 f0       	push   $0xf0129182
f0114777:	e8 5a bd fe ff       	call   f01004d6 <_warn>
f011477c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011477f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114783:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114787:	74 04                	je     f011478d <test_share_chunk+0x8b9>
f0114789:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011478d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114791:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114794:	c1 e0 03             	shl    $0x3,%eax
f0114797:	83 ec 08             	sub    $0x8,%esp
f011479a:	6a 02                	push   $0x2
f011479c:	6a 07                	push   $0x7
f011479e:	6a 07                	push   $0x7
f01147a0:	6a 07                	push   $0x7
f01147a2:	6a 05                	push   $0x5
f01147a4:	6a 04                	push   $0x4
f01147a6:	50                   	push   %eax
f01147a7:	68 00 00 40 00       	push   $0x400000
f01147ac:	68 00 00 0a 00       	push   $0xa0000
f01147b1:	ff 75 cc             	pushl  -0x34(%ebp)
f01147b4:	e8 71 22 00 00       	call   f0116a2a <CCP>
f01147b9:	83 c4 30             	add    $0x30,%esp
f01147bc:	85 c0                	test   %eax,%eax
f01147be:	75 1e                	jne    f01147de <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147c0:	83 ec 04             	sub    $0x4,%esp
f01147c3:	68 b8 a4 12 f0       	push   $0xf012a4b8
f01147c8:	68 e5 04 00 00       	push   $0x4e5
f01147cd:	68 82 91 12 f0       	push   $0xf0129182
f01147d2:	e8 ff bc fe ff       	call   f01004d6 <_warn>
f01147d7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147de:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147e2:	74 04                	je     f01147e8 <test_share_chunk+0x914>
f01147e4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147e8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01147ec:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01147f0:	0f 84 b2 00 00 00    	je     f01148a8 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01147f6:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01147fd:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114804:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f011480b:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114812:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114819:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114820:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114827:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f011482e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114831:	8a 00                	mov    (%eax),%al
f0114833:	3c 44                	cmp    $0x44,%al
f0114835:	75 45                	jne    f011487c <test_share_chunk+0x9a8>
f0114837:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011483a:	8a 00                	mov    (%eax),%al
f011483c:	3c 44                	cmp    $0x44,%al
f011483e:	75 3c                	jne    f011487c <test_share_chunk+0x9a8>
f0114840:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114843:	8a 00                	mov    (%eax),%al
f0114845:	3c 44                	cmp    $0x44,%al
f0114847:	75 33                	jne    f011487c <test_share_chunk+0x9a8>
f0114849:	8b 45 98             	mov    -0x68(%ebp),%eax
f011484c:	8a 00                	mov    (%eax),%al
f011484e:	3c 44                	cmp    $0x44,%al
f0114850:	75 2a                	jne    f011487c <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114852:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114855:	8a 10                	mov    (%eax),%dl
f0114857:	8b 45 90             	mov    -0x70(%ebp),%eax
f011485a:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f011485c:	38 c2                	cmp    %al,%dl
f011485e:	75 1c                	jne    f011487c <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114860:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114863:	8a 10                	mov    (%eax),%dl
f0114865:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114868:	8a 00                	mov    (%eax),%al
f011486a:	38 c2                	cmp    %al,%dl
f011486c:	75 0e                	jne    f011487c <test_share_chunk+0x9a8>
f011486e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114871:	8a 10                	mov    (%eax),%dl
f0114873:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114876:	8a 00                	mov    (%eax),%al
f0114878:	38 c2                	cmp    %al,%dl
f011487a:	74 1e                	je     f011489a <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011487c:	83 ec 04             	sub    $0x4,%esp
f011487f:	68 00 a5 12 f0       	push   $0xf012a500
f0114884:	68 fa 04 00 00       	push   $0x4fa
f0114889:	68 82 91 12 f0       	push   $0xf0129182
f011488e:	e8 43 bc fe ff       	call   f01004d6 <_warn>
f0114893:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114896:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011489a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011489e:	74 04                	je     f01148a4 <test_share_chunk+0x9d0>
f01148a0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01148a4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f01148a8:	83 ec 0c             	sub    $0xc,%esp
f01148ab:	68 44 a6 12 f0       	push   $0xf012a644
f01148b0:	e8 d6 c6 fe ff       	call   f0100f8b <cprintf>
f01148b5:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f01148b8:	83 ec 08             	sub    $0x8,%esp
f01148bb:	ff 75 e4             	pushl  -0x1c(%ebp)
f01148be:	68 54 a6 12 f0       	push   $0xf012a654
f01148c3:	e8 c3 c6 fe ff       	call   f0100f8b <cprintf>
f01148c8:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01148cb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01148cf:	75 10                	jne    f01148e1 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01148d1:	83 ec 0c             	sub    $0xc,%esp
f01148d4:	68 84 a6 12 f0       	push   $0xf012a684
f01148d9:	e8 ad c6 fe ff       	call   f0100f8b <cprintf>
f01148de:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01148e1:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f01148e6:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01148e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01148ec:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01148ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01148f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01148f7:	5b                   	pop    %ebx
f01148f8:	5e                   	pop    %esi
f01148f9:	5f                   	pop    %edi
f01148fa:	5d                   	pop    %ebp
f01148fb:	c3                   	ret    

f01148fc <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01148fc:	55                   	push   %ebp
f01148fd:	89 e5                	mov    %esp,%ebp
f01148ff:	57                   	push   %edi
f0114900:	56                   	push   %esi
f0114901:	53                   	push   %ebx
f0114902:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114908:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011490e:	bb 84 98 12 f0       	mov    $0xf0129884,%ebx
f0114913:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114918:	89 c7                	mov    %eax,%edi
f011491a:	89 de                	mov    %ebx,%esi
f011491c:	89 d1                	mov    %edx,%ecx
f011491e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114920:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114926:	b9 23 00 00 00       	mov    $0x23,%ecx
f011492b:	b0 00                	mov    $0x0,%al
f011492d:	89 d7                	mov    %edx,%edi
f011492f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114931:	6a 00                	push   $0x0
f0114933:	6a 0a                	push   $0xa
f0114935:	6a 14                	push   $0x14
f0114937:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011493d:	50                   	push   %eax
f011493e:	e8 1f 66 ff ff       	call   f010af62 <env_create>
f0114943:	83 c4 10             	add    $0x10,%esp
f0114946:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114949:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011494c:	8b 40 64             	mov    0x64(%eax),%eax
f011494f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114952:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114955:	8b 40 68             	mov    0x68(%eax),%eax
f0114958:	89 45 90             	mov    %eax,-0x70(%ebp)
f011495b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011495e:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114961:	83 ec 0c             	sub    $0xc,%esp
f0114964:	ff 75 cc             	pushl  -0x34(%ebp)
f0114967:	e8 8a 20 00 00       	call   f01169f6 <ClearUserSpace>
f011496c:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011496f:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114976:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011497d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114984:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114988:	83 ec 0c             	sub    $0xc,%esp
f011498b:	68 c0 a6 12 f0       	push   $0xf012a6c0
f0114990:	e8 f6 c5 fe ff       	call   f0100f8b <cprintf>
f0114995:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114998:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f011499f:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f01149a6:	eb 03                	jmp    f01149ab <test_allocate_chunk+0xaf>
f01149a8:	ff 4d e4             	decl   -0x1c(%ebp)
f01149ab:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01149b2:	76 09                	jbe    f01149bd <test_allocate_chunk+0xc1>
f01149b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01149b7:	8a 00                	mov    (%eax),%al
f01149b9:	84 c0                	test   %al,%al
f01149bb:	74 eb                	je     f01149a8 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f01149bd:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01149c4:	75 06                	jne    f01149cc <test_allocate_chunk+0xd0>
f01149c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01149c9:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01149cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01149cf:	8a 00                	mov    (%eax),%al
f01149d1:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01149d7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01149da:	8a 00                	mov    (%eax),%al
f01149dc:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f01149e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01149e5:	8a 00                	mov    (%eax),%al
f01149e7:	0f be c0             	movsbl %al,%eax
f01149ea:	83 ec 08             	sub    $0x8,%esp
f01149ed:	50                   	push   %eax
f01149ee:	68 ea a6 12 f0       	push   $0xf012a6ea
f01149f3:	e8 93 c5 fe ff       	call   f0100f8b <cprintf>
f01149f8:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01149fb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01149fe:	8a 00                	mov    (%eax),%al
f0114a00:	0f be c0             	movsbl %al,%eax
f0114a03:	83 ec 08             	sub    $0x8,%esp
f0114a06:	50                   	push   %eax
f0114a07:	68 f6 a6 12 f0       	push   $0xf012a6f6
f0114a0c:	e8 7a c5 fe ff       	call   f0100f8b <cprintf>
f0114a11:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114a14:	83 ec 08             	sub    $0x8,%esp
f0114a17:	68 00 f0 bf ef       	push   $0xefbff000
f0114a1c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a1f:	e8 b3 1f 00 00       	call   f01169d7 <GP>
f0114a24:	83 c4 10             	add    $0x10,%esp
f0114a27:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a2a:	e8 d3 9e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114a2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114a32:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a35:	c1 e0 02             	shl    $0x2,%eax
f0114a38:	6a 02                	push   $0x2
f0114a3a:	50                   	push   %eax
f0114a3b:	68 00 f0 bf ef       	push   $0xefbff000
f0114a40:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a43:	e8 eb 60 ff ff       	call   f010ab33 <allocate_chunk>
f0114a48:	83 c4 10             	add    $0x10,%esp
f0114a4b:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114a4e:	e8 af 9e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114a53:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114a56:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114a5a:	75 08                	jne    f0114a64 <test_allocate_chunk+0x168>
f0114a5c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a5f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114a62:	74 2a                	je     f0114a8e <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114a64:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a67:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a6a:	83 ec 08             	sub    $0x8,%esp
f0114a6d:	6a 00                	push   $0x0
f0114a6f:	50                   	push   %eax
f0114a70:	ff 75 b0             	pushl  -0x50(%ebp)
f0114a73:	68 04 a7 12 f0       	push   $0xf012a704
f0114a78:	68 3a 05 00 00       	push   $0x53a
f0114a7d:	68 82 91 12 f0       	push   $0xf0129182
f0114a82:	e8 4f ba fe ff       	call   f01004d6 <_warn>
f0114a87:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a8a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114a8e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a92:	74 04                	je     f0114a98 <test_allocate_chunk+0x19c>
f0114a94:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114a98:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a9c:	e8 61 9e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114aa1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114aa4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114aa7:	01 c0                	add    %eax,%eax
f0114aa9:	89 c1                	mov    %eax,%ecx
f0114aab:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114aae:	89 d0                	mov    %edx,%eax
f0114ab0:	c1 e0 02             	shl    $0x2,%eax
f0114ab3:	01 d0                	add    %edx,%eax
f0114ab5:	f7 d8                	neg    %eax
f0114ab7:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114abc:	6a 02                	push   $0x2
f0114abe:	51                   	push   %ecx
f0114abf:	50                   	push   %eax
f0114ac0:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ac3:	e8 6b 60 ff ff       	call   f010ab33 <allocate_chunk>
f0114ac8:	83 c4 10             	add    $0x10,%esp
f0114acb:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ace:	e8 2f 9e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114ad3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114ad6:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114ada:	75 08                	jne    f0114ae4 <test_allocate_chunk+0x1e8>
f0114adc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114adf:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114ae2:	74 2a                	je     f0114b0e <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114ae4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ae7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114aea:	83 ec 08             	sub    $0x8,%esp
f0114aed:	6a 00                	push   $0x0
f0114aef:	50                   	push   %eax
f0114af0:	ff 75 b0             	pushl  -0x50(%ebp)
f0114af3:	68 04 a7 12 f0       	push   $0xf012a704
f0114af8:	68 48 05 00 00       	push   $0x548
f0114afd:	68 82 91 12 f0       	push   $0xf0129182
f0114b02:	e8 cf b9 fe ff       	call   f01004d6 <_warn>
f0114b07:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b0a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114b0e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b12:	74 04                	je     f0114b18 <test_allocate_chunk+0x21c>
f0114b14:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114b18:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114b1c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b1f:	c1 e0 02             	shl    $0x2,%eax
f0114b22:	83 ec 08             	sub    $0x8,%esp
f0114b25:	6a 03                	push   $0x3
f0114b27:	6a 00                	push   $0x0
f0114b29:	6a 00                	push   $0x0
f0114b2b:	68 ff 0f 00 00       	push   $0xfff
f0114b30:	ff 75 b8             	pushl  -0x48(%ebp)
f0114b33:	6a 01                	push   $0x1
f0114b35:	50                   	push   %eax
f0114b36:	68 00 f0 bf ef       	push   $0xefbff000
f0114b3b:	6a 00                	push   $0x0
f0114b3d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b40:	e8 e5 1e 00 00       	call   f0116a2a <CCP>
f0114b45:	83 c4 30             	add    $0x30,%esp
f0114b48:	85 c0                	test   %eax,%eax
f0114b4a:	75 1e                	jne    f0114b6a <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114b4c:	83 ec 04             	sub    $0x4,%esp
f0114b4f:	68 6c a7 12 f0       	push   $0xf012a76c
f0114b54:	68 50 05 00 00       	push   $0x550
f0114b59:	68 82 91 12 f0       	push   $0xf0129182
f0114b5e:	e8 73 b9 fe ff       	call   f01004d6 <_warn>
f0114b63:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b66:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114b6a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b6e:	74 04                	je     f0114b74 <test_allocate_chunk+0x278>
f0114b70:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114b74:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114b78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114b7b:	8a 10                	mov    (%eax),%dl
f0114b7d:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114b83:	38 c2                	cmp    %al,%dl
f0114b85:	75 0f                	jne    f0114b96 <test_allocate_chunk+0x29a>
f0114b87:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b8a:	8a 10                	mov    (%eax),%dl
f0114b8c:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114b92:	38 c2                	cmp    %al,%dl
f0114b94:	74 1e                	je     f0114bb4 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114b96:	83 ec 04             	sub    $0x4,%esp
f0114b99:	68 b8 a7 12 f0       	push   $0xf012a7b8
f0114b9e:	68 58 05 00 00       	push   $0x558
f0114ba3:	68 82 91 12 f0       	push   $0xf0129182
f0114ba8:	e8 29 b9 fe ff       	call   f01004d6 <_warn>
f0114bad:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114bb0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114bb4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114bb8:	74 04                	je     f0114bbe <test_allocate_chunk+0x2c2>
f0114bba:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114bbe:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114bc2:	83 ec 0c             	sub    $0xc,%esp
f0114bc5:	68 35 a5 12 f0       	push   $0xf012a535
f0114bca:	e8 bc c3 fe ff       	call   f0100f8b <cprintf>
f0114bcf:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114bd2:	83 ec 0c             	sub    $0xc,%esp
f0114bd5:	68 f0 a7 12 f0       	push   $0xf012a7f0
f0114bda:	e8 ac c3 fe ff       	call   f0100f8b <cprintf>
f0114bdf:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114be2:	e8 1b 9d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114be7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114bea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bed:	c1 e0 05             	shl    $0x5,%eax
f0114bf0:	68 02 0e 00 00       	push   $0xe02
f0114bf5:	50                   	push   %eax
f0114bf6:	6a 00                	push   $0x0
f0114bf8:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bfb:	e8 33 5f ff ff       	call   f010ab33 <allocate_chunk>
f0114c00:	83 c4 10             	add    $0x10,%esp
f0114c03:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114c06:	e8 f7 9c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114c0b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0114c0e:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114c12:	75 36                	jne    f0114c4a <test_allocate_chunk+0x34e>
f0114c14:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114c17:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114c1a:	89 c1                	mov    %eax,%ecx
f0114c1c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c1f:	c1 e0 05             	shl    $0x5,%eax
f0114c22:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114c25:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114c2c:	99                   	cltd   
f0114c2d:	f7 fe                	idiv   %esi
f0114c2f:	89 c3                	mov    %eax,%ebx
f0114c31:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c34:	c1 e0 05             	shl    $0x5,%eax
f0114c37:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114c3a:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114c41:	99                   	cltd   
f0114c42:	f7 fe                	idiv   %esi
f0114c44:	01 d8                	add    %ebx,%eax
f0114c46:	39 c1                	cmp    %eax,%ecx
f0114c48:	74 54                	je     f0114c9e <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114c4a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c4d:	c1 e0 05             	shl    $0x5,%eax
f0114c50:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114c53:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114c5a:	99                   	cltd   
f0114c5b:	f7 ff                	idiv   %edi
f0114c5d:	89 c1                	mov    %eax,%ecx
f0114c5f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c62:	c1 e0 05             	shl    $0x5,%eax
f0114c65:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114c68:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114c6f:	99                   	cltd   
f0114c70:	f7 fe                	idiv   %esi
f0114c72:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114c75:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114c78:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114c7b:	83 ec 08             	sub    $0x8,%esp
f0114c7e:	52                   	push   %edx
f0114c7f:	50                   	push   %eax
f0114c80:	ff 75 a8             	pushl  -0x58(%ebp)
f0114c83:	68 30 a8 12 f0       	push   $0xf012a830
f0114c88:	68 6d 05 00 00       	push   $0x56d
f0114c8d:	68 82 91 12 f0       	push   $0xf0129182
f0114c92:	e8 3f b8 fe ff       	call   f01004d6 <_warn>
f0114c97:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c9a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114c9e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114ca2:	74 04                	je     f0114ca8 <test_allocate_chunk+0x3ac>
f0114ca4:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114ca8:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114cac:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114cb3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cb6:	c1 e0 05             	shl    $0x5,%eax
f0114cb9:	83 ec 08             	sub    $0x8,%esp
f0114cbc:	6a 03                	push   $0x3
f0114cbe:	6a 00                	push   $0x0
f0114cc0:	6a 00                	push   $0x0
f0114cc2:	68 07 0e 00 00       	push   $0xe07
f0114cc7:	68 03 0e 00 00       	push   $0xe03
f0114ccc:	6a 01                	push   $0x1
f0114cce:	50                   	push   %eax
f0114ccf:	6a 00                	push   $0x0
f0114cd1:	6a 00                	push   $0x0
f0114cd3:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cd6:	e8 4f 1d 00 00       	call   f0116a2a <CCP>
f0114cdb:	83 c4 30             	add    $0x30,%esp
f0114cde:	85 c0                	test   %eax,%eax
f0114ce0:	75 25                	jne    f0114d07 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114ce2:	83 ec 04             	sub    $0x4,%esp
f0114ce5:	68 6c a7 12 f0       	push   $0xf012a76c
f0114cea:	68 76 05 00 00       	push   $0x576
f0114cef:	68 82 91 12 f0       	push   $0xf0129182
f0114cf4:	e8 dd b7 fe ff       	call   f01004d6 <_warn>
f0114cf9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114cfc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114d00:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114d07:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d0b:	74 04                	je     f0114d11 <test_allocate_chunk+0x415>
f0114d0d:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114d11:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114d15:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114d19:	74 5a                	je     f0114d75 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114d1b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114d1e:	01 c0                	add    %eax,%eax
f0114d20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114d23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114d26:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114d29:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d2c:	01 c0                	add    %eax,%eax
f0114d2e:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114d31:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d34:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114d37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114d3a:	8a 00                	mov    (%eax),%al
f0114d3c:	3c 4b                	cmp    $0x4b,%al
f0114d3e:	75 09                	jne    f0114d49 <test_allocate_chunk+0x44d>
f0114d40:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d43:	8a 00                	mov    (%eax),%al
f0114d45:	3c 4d                	cmp    $0x4d,%al
f0114d47:	74 1e                	je     f0114d67 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114d49:	83 ec 04             	sub    $0x4,%esp
f0114d4c:	68 b8 a7 12 f0       	push   $0xf012a7b8
f0114d51:	68 84 05 00 00       	push   $0x584
f0114d56:	68 82 91 12 f0       	push   $0xf0129182
f0114d5b:	e8 76 b7 fe ff       	call   f01004d6 <_warn>
f0114d60:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114d63:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114d67:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d6b:	74 04                	je     f0114d71 <test_allocate_chunk+0x475>
f0114d6d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114d71:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114d75:	83 ec 0c             	sub    $0xc,%esp
f0114d78:	68 0f 9b 12 f0       	push   $0xf0129b0f
f0114d7d:	e8 09 c2 fe ff       	call   f0100f8b <cprintf>
f0114d82:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0114d85:	83 ec 0c             	sub    $0xc,%esp
f0114d88:	68 90 a8 12 f0       	push   $0xf012a890
f0114d8d:	e8 f9 c1 fe ff       	call   f0100f8b <cprintf>
f0114d92:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114d95:	e8 68 9b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114d9a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114d9d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114da0:	c1 e0 06             	shl    $0x6,%eax
f0114da3:	89 c2                	mov    %eax,%edx
f0114da5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114da8:	c1 e0 05             	shl    $0x5,%eax
f0114dab:	6a 00                	push   $0x0
f0114dad:	52                   	push   %edx
f0114dae:	50                   	push   %eax
f0114daf:	ff 75 cc             	pushl  -0x34(%ebp)
f0114db2:	e8 7c 5d ff ff       	call   f010ab33 <allocate_chunk>
f0114db7:	83 c4 10             	add    $0x10,%esp
f0114dba:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114dbd:	e8 40 9b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114dc2:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0114dc5:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114dc9:	75 36                	jne    f0114e01 <test_allocate_chunk+0x505>
f0114dcb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114dce:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114dd1:	89 c1                	mov    %eax,%ecx
f0114dd3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114dd6:	c1 e0 06             	shl    $0x6,%eax
f0114dd9:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114ddc:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114de3:	99                   	cltd   
f0114de4:	f7 ff                	idiv   %edi
f0114de6:	89 c3                	mov    %eax,%ebx
f0114de8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114deb:	c1 e0 06             	shl    $0x6,%eax
f0114dee:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114df1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114df8:	99                   	cltd   
f0114df9:	f7 fe                	idiv   %esi
f0114dfb:	01 d8                	add    %ebx,%eax
f0114dfd:	39 c1                	cmp    %eax,%ecx
f0114dff:	74 54                	je     f0114e55 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0114e01:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e04:	c1 e0 06             	shl    $0x6,%eax
f0114e07:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114e0a:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114e11:	99                   	cltd   
f0114e12:	f7 fb                	idiv   %ebx
f0114e14:	89 c1                	mov    %eax,%ecx
f0114e16:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e19:	c1 e0 06             	shl    $0x6,%eax
f0114e1c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114e1f:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114e26:	99                   	cltd   
f0114e27:	f7 ff                	idiv   %edi
f0114e29:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114e2c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e2f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114e32:	83 ec 08             	sub    $0x8,%esp
f0114e35:	52                   	push   %edx
f0114e36:	50                   	push   %eax
f0114e37:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114e3a:	68 30 a8 12 f0       	push   $0xf012a830
f0114e3f:	68 9a 05 00 00       	push   $0x59a
f0114e44:	68 82 91 12 f0       	push   $0xf0129182
f0114e49:	e8 88 b6 fe ff       	call   f01004d6 <_warn>
f0114e4e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e51:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114e55:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e59:	74 04                	je     f0114e5f <test_allocate_chunk+0x563>
f0114e5b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114e5f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114e63:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114e6a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e6d:	c1 e0 06             	shl    $0x6,%eax
f0114e70:	89 c2                	mov    %eax,%edx
f0114e72:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e75:	c1 e0 05             	shl    $0x5,%eax
f0114e78:	83 ec 08             	sub    $0x8,%esp
f0114e7b:	6a 03                	push   $0x3
f0114e7d:	6a 00                	push   $0x0
f0114e7f:	6a 00                	push   $0x0
f0114e81:	68 07 0e 00 00       	push   $0xe07
f0114e86:	6a 01                	push   $0x1
f0114e88:	6a 01                	push   $0x1
f0114e8a:	52                   	push   %edx
f0114e8b:	50                   	push   %eax
f0114e8c:	6a 00                	push   $0x0
f0114e8e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e91:	e8 94 1b 00 00       	call   f0116a2a <CCP>
f0114e96:	83 c4 30             	add    $0x30,%esp
f0114e99:	85 c0                	test   %eax,%eax
f0114e9b:	75 25                	jne    f0114ec2 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114e9d:	83 ec 04             	sub    $0x4,%esp
f0114ea0:	68 6c a7 12 f0       	push   $0xf012a76c
f0114ea5:	68 a3 05 00 00       	push   $0x5a3
f0114eaa:	68 82 91 12 f0       	push   $0xf0129182
f0114eaf:	e8 22 b6 fe ff       	call   f01004d6 <_warn>
f0114eb4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114eb7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114ebb:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114ec2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114ec6:	74 04                	je     f0114ecc <test_allocate_chunk+0x5d0>
f0114ec8:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ecc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114ed0:	83 ec 0c             	sub    $0xc,%esp
f0114ed3:	68 72 9b 12 f0       	push   $0xf0129b72
f0114ed8:	e8 ae c0 fe ff       	call   f0100f8b <cprintf>
f0114edd:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114ee0:	83 ec 0c             	sub    $0xc,%esp
f0114ee3:	68 d0 a8 12 f0       	push   $0xf012a8d0
f0114ee8:	e8 9e c0 fe ff       	call   f0100f8b <cprintf>
f0114eed:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114ef0:	e8 0d 9a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114ef5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0114ef8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114efb:	c1 e0 06             	shl    $0x6,%eax
f0114efe:	68 06 0e 00 00       	push   $0xe06
f0114f03:	50                   	push   %eax
f0114f04:	68 00 00 00 80       	push   $0x80000000
f0114f09:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f0c:	e8 22 5c ff ff       	call   f010ab33 <allocate_chunk>
f0114f11:	83 c4 10             	add    $0x10,%esp
f0114f14:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f17:	e8 e6 99 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0114f1c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0114f1f:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0114f23:	75 36                	jne    f0114f5b <test_allocate_chunk+0x65f>
f0114f25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f28:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f2b:	89 c1                	mov    %eax,%ecx
f0114f2d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f30:	c1 e0 06             	shl    $0x6,%eax
f0114f33:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f36:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114f3d:	99                   	cltd   
f0114f3e:	f7 fb                	idiv   %ebx
f0114f40:	89 c3                	mov    %eax,%ebx
f0114f42:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f45:	c1 e0 06             	shl    $0x6,%eax
f0114f48:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114f4b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114f52:	99                   	cltd   
f0114f53:	f7 fe                	idiv   %esi
f0114f55:	01 d8                	add    %ebx,%eax
f0114f57:	39 c1                	cmp    %eax,%ecx
f0114f59:	74 54                	je     f0114faf <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114f5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f5e:	c1 e0 06             	shl    $0x6,%eax
f0114f61:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f64:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114f6b:	99                   	cltd   
f0114f6c:	f7 ff                	idiv   %edi
f0114f6e:	89 c1                	mov    %eax,%ecx
f0114f70:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f73:	c1 e0 06             	shl    $0x6,%eax
f0114f76:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114f79:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114f80:	99                   	cltd   
f0114f81:	f7 fb                	idiv   %ebx
f0114f83:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114f86:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f89:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f8c:	83 ec 08             	sub    $0x8,%esp
f0114f8f:	52                   	push   %edx
f0114f90:	50                   	push   %eax
f0114f91:	ff 75 9c             	pushl  -0x64(%ebp)
f0114f94:	68 30 a8 12 f0       	push   $0xf012a830
f0114f99:	68 b9 05 00 00       	push   $0x5b9
f0114f9e:	68 82 91 12 f0       	push   $0xf0129182
f0114fa3:	e8 2e b5 fe ff       	call   f01004d6 <_warn>
f0114fa8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fab:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114faf:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114fb3:	74 04                	je     f0114fb9 <test_allocate_chunk+0x6bd>
f0114fb5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114fb9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114fbd:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114fc4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fc7:	c1 e0 06             	shl    $0x6,%eax
f0114fca:	83 ec 08             	sub    $0x8,%esp
f0114fcd:	6a 03                	push   $0x3
f0114fcf:	6a 00                	push   $0x0
f0114fd1:	6a 00                	push   $0x0
f0114fd3:	68 07 0e 00 00       	push   $0xe07
f0114fd8:	68 07 0e 00 00       	push   $0xe07
f0114fdd:	6a 01                	push   $0x1
f0114fdf:	50                   	push   %eax
f0114fe0:	68 00 00 00 80       	push   $0x80000000
f0114fe5:	6a 00                	push   $0x0
f0114fe7:	ff 75 cc             	pushl  -0x34(%ebp)
f0114fea:	e8 3b 1a 00 00       	call   f0116a2a <CCP>
f0114fef:	83 c4 30             	add    $0x30,%esp
f0114ff2:	85 c0                	test   %eax,%eax
f0114ff4:	75 25                	jne    f011501b <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114ff6:	83 ec 04             	sub    $0x4,%esp
f0114ff9:	68 6c a7 12 f0       	push   $0xf012a76c
f0114ffe:	68 c2 05 00 00       	push   $0x5c2
f0115003:	68 82 91 12 f0       	push   $0xf0129182
f0115008:	e8 c9 b4 fe ff       	call   f01004d6 <_warn>
f011500d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115010:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115014:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f011501b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011501f:	74 04                	je     f0115025 <test_allocate_chunk+0x729>
f0115021:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115025:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115029:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011502d:	74 6f                	je     f011509e <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f011502f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115032:	01 c0                	add    %eax,%eax
f0115034:	05 00 00 00 80       	add    $0x80000000,%eax
f0115039:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011503c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011503f:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0115042:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115045:	89 d0                	mov    %edx,%eax
f0115047:	c1 e0 02             	shl    $0x2,%eax
f011504a:	01 d0                	add    %edx,%eax
f011504c:	01 c0                	add    %eax,%eax
f011504e:	01 d0                	add    %edx,%eax
f0115050:	01 c0                	add    %eax,%eax
f0115052:	05 00 00 00 80       	add    $0x80000000,%eax
f0115057:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011505a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011505d:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0115060:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115063:	8a 00                	mov    (%eax),%al
f0115065:	3c 4b                	cmp    $0x4b,%al
f0115067:	75 09                	jne    f0115072 <test_allocate_chunk+0x776>
f0115069:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011506c:	8a 00                	mov    (%eax),%al
f011506e:	3c 4d                	cmp    $0x4d,%al
f0115070:	74 1e                	je     f0115090 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115072:	83 ec 04             	sub    $0x4,%esp
f0115075:	68 b8 a7 12 f0       	push   $0xf012a7b8
f011507a:	68 d0 05 00 00       	push   $0x5d0
f011507f:	68 82 91 12 f0       	push   $0xf0129182
f0115084:	e8 4d b4 fe ff       	call   f01004d6 <_warn>
f0115089:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011508c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0115090:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115094:	74 04                	je     f011509a <test_allocate_chunk+0x79e>
f0115096:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f011509a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f011509e:	83 ec 0c             	sub    $0xc,%esp
f01150a1:	68 44 a6 12 f0       	push   $0xf012a644
f01150a6:	e8 e0 be fe ff       	call   f0100f8b <cprintf>
f01150ab:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01150ae:	83 ec 0c             	sub    $0xc,%esp
f01150b1:	68 0c a9 12 f0       	push   $0xf012a90c
f01150b6:	e8 d0 be fe ff       	call   f0100f8b <cprintf>
f01150bb:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01150be:	e8 3f 98 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01150c3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f01150c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01150c9:	89 d0                	mov    %edx,%eax
f01150cb:	01 c0                	add    %eax,%eax
f01150cd:	01 d0                	add    %edx,%eax
f01150cf:	01 c0                	add    %eax,%eax
f01150d1:	01 d0                	add    %edx,%eax
f01150d3:	68 04 0e 00 00       	push   $0xe04
f01150d8:	50                   	push   %eax
f01150d9:	68 00 fc 3f 40       	push   $0x403ffc00
f01150de:	ff 75 cc             	pushl  -0x34(%ebp)
f01150e1:	e8 4d 5a ff ff       	call   f010ab33 <allocate_chunk>
f01150e6:	83 c4 10             	add    $0x10,%esp
f01150e9:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01150ec:	e8 11 98 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01150f1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f01150f4:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f01150f8:	75 0b                	jne    f0115105 <test_allocate_chunk+0x809>
f01150fa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01150fd:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115100:	83 f8 05             	cmp    $0x5,%eax
f0115103:	74 2a                	je     f011512f <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0115105:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115108:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011510b:	83 ec 08             	sub    $0x8,%esp
f011510e:	6a 05                	push   $0x5
f0115110:	50                   	push   %eax
f0115111:	ff 75 98             	pushl  -0x68(%ebp)
f0115114:	68 30 a8 12 f0       	push   $0xf012a830
f0115119:	68 e7 05 00 00       	push   $0x5e7
f011511e:	68 82 91 12 f0       	push   $0xf0129182
f0115123:	e8 ae b3 fe ff       	call   f01004d6 <_warn>
f0115128:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011512b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011512f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115133:	74 04                	je     f0115139 <test_allocate_chunk+0x83d>
f0115135:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115139:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011513d:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0115144:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115147:	89 d0                	mov    %edx,%eax
f0115149:	01 c0                	add    %eax,%eax
f011514b:	01 d0                	add    %edx,%eax
f011514d:	c1 e0 02             	shl    $0x2,%eax
f0115150:	83 ec 08             	sub    $0x8,%esp
f0115153:	6a 03                	push   $0x3
f0115155:	6a 00                	push   $0x0
f0115157:	6a 00                	push   $0x0
f0115159:	68 07 0e 00 00       	push   $0xe07
f011515e:	68 05 0e 00 00       	push   $0xe05
f0115163:	6a 01                	push   $0x1
f0115165:	50                   	push   %eax
f0115166:	68 00 f0 3f 40       	push   $0x403ff000
f011516b:	6a 00                	push   $0x0
f011516d:	ff 75 cc             	pushl  -0x34(%ebp)
f0115170:	e8 b5 18 00 00       	call   f0116a2a <CCP>
f0115175:	83 c4 30             	add    $0x30,%esp
f0115178:	85 c0                	test   %eax,%eax
f011517a:	75 25                	jne    f01151a1 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011517c:	83 ec 04             	sub    $0x4,%esp
f011517f:	68 6c a7 12 f0       	push   $0xf012a76c
f0115184:	68 f0 05 00 00       	push   $0x5f0
f0115189:	68 82 91 12 f0       	push   $0xf0129182
f011518e:	e8 43 b3 fe ff       	call   f01004d6 <_warn>
f0115193:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115196:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011519a:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01151a1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01151a5:	74 04                	je     f01151ab <test_allocate_chunk+0x8af>
f01151a7:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01151ab:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01151af:	83 ec 0c             	sub    $0xc,%esp
f01151b2:	68 43 a9 12 f0       	push   $0xf012a943
f01151b7:	e8 cf bd fe ff       	call   f0100f8b <cprintf>
f01151bc:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f01151bf:	83 ec 08             	sub    $0x8,%esp
f01151c2:	ff 75 e0             	pushl  -0x20(%ebp)
f01151c5:	68 54 a9 12 f0       	push   $0xf012a954
f01151ca:	e8 bc bd fe ff       	call   f0100f8b <cprintf>
f01151cf:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01151d2:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f01151d6:	75 10                	jne    f01151e8 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f01151d8:	83 ec 0c             	sub    $0xc,%esp
f01151db:	68 88 a9 12 f0       	push   $0xf012a988
f01151e0:	e8 a6 bd fe ff       	call   f0100f8b <cprintf>
f01151e5:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01151e8:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f01151ed:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01151f0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01151f3:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01151f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01151fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01151fe:	5b                   	pop    %ebx
f01151ff:	5e                   	pop    %esi
f0115200:	5f                   	pop    %edi
f0115201:	5d                   	pop    %ebp
f0115202:	c3                   	ret    

f0115203 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0115203:	55                   	push   %ebp
f0115204:	89 e5                	mov    %esp,%ebp
f0115206:	57                   	push   %edi
f0115207:	56                   	push   %esi
f0115208:	53                   	push   %ebx
f0115209:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011520f:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115212:	bb 84 98 12 f0       	mov    $0xf0129884,%ebx
f0115217:	ba 0f 00 00 00       	mov    $0xf,%edx
f011521c:	89 c7                	mov    %eax,%edi
f011521e:	89 de                	mov    %ebx,%esi
f0115220:	89 d1                	mov    %edx,%ecx
f0115222:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115224:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115227:	b9 23 00 00 00       	mov    $0x23,%ecx
f011522c:	b0 00                	mov    $0x0,%al
f011522e:	89 d7                	mov    %edx,%edi
f0115230:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115232:	6a 00                	push   $0x0
f0115234:	6a 0a                	push   $0xa
f0115236:	6a 14                	push   $0x14
f0115238:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011523b:	50                   	push   %eax
f011523c:	e8 21 5d ff ff       	call   f010af62 <env_create>
f0115241:	83 c4 10             	add    $0x10,%esp
f0115244:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115247:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011524a:	8b 40 64             	mov    0x64(%eax),%eax
f011524d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115250:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115253:	8b 40 68             	mov    0x68(%eax),%eax
f0115256:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115259:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011525c:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011525f:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115266:	75 70 20 
f0115269:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115270:	00 00 00 
f0115273:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115276:	b9 03 00 00 00       	mov    $0x3,%ecx
f011527b:	b8 00 00 00 00       	mov    $0x0,%eax
f0115280:	89 d7                	mov    %edx,%edi
f0115282:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115284:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115287:	8b 40 10             	mov    0x10(%eax),%eax
f011528a:	83 ec 08             	sub    $0x8,%esp
f011528d:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115293:	52                   	push   %edx
f0115294:	50                   	push   %eax
f0115295:	e8 28 ae 00 00       	call   f01200c2 <ltostr>
f011529a:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011529d:	83 ec 04             	sub    $0x4,%esp
f01152a0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01152a6:	50                   	push   %eax
f01152a7:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01152ad:	50                   	push   %eax
f01152ae:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01152b4:	50                   	push   %eax
f01152b5:	e8 e1 ae 00 00       	call   f012019b <strcconcat>
f01152ba:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01152bd:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01152c4:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01152cb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f01152d2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f01152d9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f01152dd:	83 ec 0c             	sub    $0xc,%esp
f01152e0:	ff 75 d8             	pushl  -0x28(%ebp)
f01152e3:	e8 0e 17 00 00       	call   f01169f6 <ClearUserSpace>
f01152e8:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01152eb:	83 ec 0c             	sub    $0xc,%esp
f01152ee:	68 c8 a9 12 f0       	push   $0xf012a9c8
f01152f3:	e8 93 bc fe ff       	call   f0100f8b <cprintf>
f01152f8:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01152fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01152fe:	c1 e0 03             	shl    $0x3,%eax
f0115301:	83 ec 04             	sub    $0x4,%esp
f0115304:	50                   	push   %eax
f0115305:	6a 00                	push   $0x0
f0115307:	ff 75 d8             	pushl  -0x28(%ebp)
f011530a:	e8 58 58 ff ff       	call   f010ab67 <calculate_required_frames>
f011530f:	83 c4 10             	add    $0x10,%esp
f0115312:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115315:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115319:	74 23                	je     f011533e <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011531b:	83 ec 0c             	sub    $0xc,%esp
f011531e:	6a 03                	push   $0x3
f0115320:	ff 75 c8             	pushl  -0x38(%ebp)
f0115323:	68 fc a9 12 f0       	push   $0xf012a9fc
f0115328:	68 29 06 00 00       	push   $0x629
f011532d:	68 82 91 12 f0       	push   $0xf0129182
f0115332:	e8 9f b1 fe ff       	call   f01004d6 <_warn>
f0115337:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011533a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011533e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115342:	74 04                	je     f0115348 <test_calculate_required_frames+0x145>
f0115344:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115348:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f011534c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011534f:	c1 e0 02             	shl    $0x2,%eax
f0115352:	83 ec 04             	sub    $0x4,%esp
f0115355:	50                   	push   %eax
f0115356:	6a 00                	push   $0x0
f0115358:	ff 75 d8             	pushl  -0x28(%ebp)
f011535b:	e8 07 58 ff ff       	call   f010ab67 <calculate_required_frames>
f0115360:	83 c4 10             	add    $0x10,%esp
f0115363:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0115366:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f011536d:	74 26                	je     f0115395 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f011536f:	83 ec 0c             	sub    $0xc,%esp
f0115372:	68 01 04 00 00       	push   $0x401
f0115377:	ff 75 c8             	pushl  -0x38(%ebp)
f011537a:	68 fc a9 12 f0       	push   $0xf012a9fc
f011537f:	68 33 06 00 00       	push   $0x633
f0115384:	68 82 91 12 f0       	push   $0xf0129182
f0115389:	e8 48 b1 fe ff       	call   f01004d6 <_warn>
f011538e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115391:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115395:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115399:	74 04                	je     f011539f <test_calculate_required_frames+0x19c>
f011539b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011539f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01153a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01153a6:	c1 e0 0a             	shl    $0xa,%eax
f01153a9:	83 ec 04             	sub    $0x4,%esp
f01153ac:	50                   	push   %eax
f01153ad:	6a 00                	push   $0x0
f01153af:	ff 75 d8             	pushl  -0x28(%ebp)
f01153b2:	e8 b0 57 ff ff       	call   f010ab67 <calculate_required_frames>
f01153b7:	83 c4 10             	add    $0x10,%esp
f01153ba:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f01153bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01153c0:	c1 e0 0a             	shl    $0xa,%eax
f01153c3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01153c6:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01153cd:	99                   	cltd   
f01153ce:	f7 fb                	idiv   %ebx
f01153d0:	89 c1                	mov    %eax,%ecx
f01153d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01153d5:	c1 e0 0a             	shl    $0xa,%eax
f01153d8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01153db:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01153e2:	99                   	cltd   
f01153e3:	f7 fe                	idiv   %esi
f01153e5:	01 c8                	add    %ecx,%eax
f01153e7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01153ea:	74 4c                	je     f0115438 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f01153ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01153ef:	c1 e0 0a             	shl    $0xa,%eax
f01153f2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01153f5:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01153fc:	99                   	cltd   
f01153fd:	f7 fb                	idiv   %ebx
f01153ff:	89 c1                	mov    %eax,%ecx
f0115401:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115404:	c1 e0 0a             	shl    $0xa,%eax
f0115407:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011540a:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115411:	99                   	cltd   
f0115412:	f7 fe                	idiv   %esi
f0115414:	01 c8                	add    %ecx,%eax
f0115416:	83 ec 0c             	sub    $0xc,%esp
f0115419:	50                   	push   %eax
f011541a:	ff 75 c8             	pushl  -0x38(%ebp)
f011541d:	68 fc a9 12 f0       	push   $0xf012a9fc
f0115422:	68 3d 06 00 00       	push   $0x63d
f0115427:	68 82 91 12 f0       	push   $0xf0129182
f011542c:	e8 a5 b0 fe ff       	call   f01004d6 <_warn>
f0115431:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115434:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115438:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011543c:	74 04                	je     f0115442 <test_calculate_required_frames+0x23f>
f011543e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115442:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0115446:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115449:	89 d0                	mov    %edx,%eax
f011544b:	01 c0                	add    %eax,%eax
f011544d:	01 d0                	add    %edx,%eax
f011544f:	01 c0                	add    %eax,%eax
f0115451:	83 ec 04             	sub    $0x4,%esp
f0115454:	50                   	push   %eax
f0115455:	68 00 10 00 00       	push   $0x1000
f011545a:	ff 75 d8             	pushl  -0x28(%ebp)
f011545d:	e8 05 57 ff ff       	call   f010ab67 <calculate_required_frames>
f0115462:	83 c4 10             	add    $0x10,%esp
f0115465:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115468:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011546c:	74 23                	je     f0115491 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011546e:	83 ec 0c             	sub    $0xc,%esp
f0115471:	6a 03                	push   $0x3
f0115473:	ff 75 c8             	pushl  -0x38(%ebp)
f0115476:	68 fc a9 12 f0       	push   $0xf012a9fc
f011547b:	68 49 06 00 00       	push   $0x649
f0115480:	68 82 91 12 f0       	push   $0xf0129182
f0115485:	e8 4c b0 fe ff       	call   f01004d6 <_warn>
f011548a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011548d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115491:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115495:	74 04                	je     f011549b <test_calculate_required_frames+0x298>
f0115497:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011549b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011549f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01154a2:	89 c2                	mov    %eax,%edx
f01154a4:	01 d2                	add    %edx,%edx
f01154a6:	01 d0                	add    %edx,%eax
f01154a8:	83 ec 04             	sub    $0x4,%esp
f01154ab:	50                   	push   %eax
f01154ac:	68 00 18 00 00       	push   $0x1800
f01154b1:	ff 75 d8             	pushl  -0x28(%ebp)
f01154b4:	e8 ae 56 ff ff       	call   f010ab67 <calculate_required_frames>
f01154b9:	83 c4 10             	add    $0x10,%esp
f01154bc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01154bf:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01154c3:	74 23                	je     f01154e8 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01154c5:	83 ec 0c             	sub    $0xc,%esp
f01154c8:	6a 03                	push   $0x3
f01154ca:	ff 75 c8             	pushl  -0x38(%ebp)
f01154cd:	68 fc a9 12 f0       	push   $0xf012a9fc
f01154d2:	68 53 06 00 00       	push   $0x653
f01154d7:	68 82 91 12 f0       	push   $0xf0129182
f01154dc:	e8 f5 af fe ff       	call   f01004d6 <_warn>
f01154e1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154e4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01154e8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154ec:	74 04                	je     f01154f2 <test_calculate_required_frames+0x2ef>
f01154ee:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154f2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01154f6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01154f9:	89 d0                	mov    %edx,%eax
f01154fb:	c1 e0 02             	shl    $0x2,%eax
f01154fe:	01 d0                	add    %edx,%eax
f0115500:	01 c0                	add    %eax,%eax
f0115502:	83 ec 04             	sub    $0x4,%esp
f0115505:	50                   	push   %eax
f0115506:	68 00 00 40 00       	push   $0x400000
f011550b:	ff 75 d8             	pushl  -0x28(%ebp)
f011550e:	e8 54 56 ff ff       	call   f010ab67 <calculate_required_frames>
f0115513:	83 c4 10             	add    $0x10,%esp
f0115516:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0115519:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115520:	74 26                	je     f0115548 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115522:	83 ec 0c             	sub    $0xc,%esp
f0115525:	68 03 0a 00 00       	push   $0xa03
f011552a:	ff 75 c8             	pushl  -0x38(%ebp)
f011552d:	68 fc a9 12 f0       	push   $0xf012a9fc
f0115532:	68 5d 06 00 00       	push   $0x65d
f0115537:	68 82 91 12 f0       	push   $0xf0129182
f011553c:	e8 95 af fe ff       	call   f01004d6 <_warn>
f0115541:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115544:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115548:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011554c:	74 04                	je     f0115552 <test_calculate_required_frames+0x34f>
f011554e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115552:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115556:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115559:	01 c0                	add    %eax,%eax
f011555b:	83 ec 04             	sub    $0x4,%esp
f011555e:	50                   	push   %eax
f011555f:	68 00 00 70 00       	push   $0x700000
f0115564:	ff 75 d8             	pushl  -0x28(%ebp)
f0115567:	e8 fb 55 ff ff       	call   f010ab67 <calculate_required_frames>
f011556c:	83 c4 10             	add    $0x10,%esp
f011556f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115572:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115579:	74 26                	je     f01155a1 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f011557b:	83 ec 0c             	sub    $0xc,%esp
f011557e:	68 02 02 00 00       	push   $0x202
f0115583:	ff 75 c8             	pushl  -0x38(%ebp)
f0115586:	68 fc a9 12 f0       	push   $0xf012a9fc
f011558b:	68 69 06 00 00       	push   $0x669
f0115590:	68 82 91 12 f0       	push   $0xf0129182
f0115595:	e8 3c af fe ff       	call   f01004d6 <_warn>
f011559a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011559d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01155a1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155a5:	74 04                	je     f01155ab <test_calculate_required_frames+0x3a8>
f01155a7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01155ab:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01155af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01155b2:	83 ec 04             	sub    $0x4,%esp
f01155b5:	50                   	push   %eax
f01155b6:	68 ff ff 3f 00       	push   $0x3fffff
f01155bb:	ff 75 d8             	pushl  -0x28(%ebp)
f01155be:	e8 a4 55 ff ff       	call   f010ab67 <calculate_required_frames>
f01155c3:	83 c4 10             	add    $0x10,%esp
f01155c6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f01155c9:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01155cd:	74 23                	je     f01155f2 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01155cf:	83 ec 0c             	sub    $0xc,%esp
f01155d2:	6a 04                	push   $0x4
f01155d4:	ff 75 c8             	pushl  -0x38(%ebp)
f01155d7:	68 fc a9 12 f0       	push   $0xf012a9fc
f01155dc:	68 73 06 00 00       	push   $0x673
f01155e1:	68 82 91 12 f0       	push   $0xf0129182
f01155e6:	e8 eb ae fe ff       	call   f01004d6 <_warn>
f01155eb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155ee:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01155f2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155f6:	74 04                	je     f01155fc <test_calculate_required_frames+0x3f9>
f01155f8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01155fc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115600:	83 ec 0c             	sub    $0xc,%esp
f0115603:	68 35 a5 12 f0       	push   $0xf012a535
f0115608:	e8 7e b9 fe ff       	call   f0100f8b <cprintf>
f011560d:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115610:	83 ec 0c             	sub    $0xc,%esp
f0115613:	68 54 aa 12 f0       	push   $0xf012aa54
f0115618:	e8 6e b9 fe ff       	call   f0100f8b <cprintf>
f011561d:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115620:	83 ec 04             	sub    $0x4,%esp
f0115623:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115629:	50                   	push   %eax
f011562a:	68 ee 98 12 f0       	push   $0xf01298ee
f011562f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115635:	50                   	push   %eax
f0115636:	e8 60 ab 00 00       	call   f012019b <strcconcat>
f011563b:	83 c4 10             	add    $0x10,%esp
f011563e:	83 ec 0c             	sub    $0xc,%esp
f0115641:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115647:	50                   	push   %eax
f0115648:	e8 ae c8 fe ff       	call   f0101efb <execute_command>
f011564d:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115650:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115653:	c1 e0 03             	shl    $0x3,%eax
f0115656:	83 ec 04             	sub    $0x4,%esp
f0115659:	50                   	push   %eax
f011565a:	6a 00                	push   $0x0
f011565c:	ff 75 d8             	pushl  -0x28(%ebp)
f011565f:	e8 03 55 ff ff       	call   f010ab67 <calculate_required_frames>
f0115664:	83 c4 10             	add    $0x10,%esp
f0115667:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011566a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115671:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115674:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115677:	74 24                	je     f011569d <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115679:	83 ec 0c             	sub    $0xc,%esp
f011567c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011567f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115682:	68 fc a9 12 f0       	push   $0xf012a9fc
f0115687:	68 87 06 00 00       	push   $0x687
f011568c:	68 82 91 12 f0       	push   $0xf0129182
f0115691:	e8 40 ae fe ff       	call   f01004d6 <_warn>
f0115696:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115699:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011569d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156a1:	74 04                	je     f01156a7 <test_calculate_required_frames+0x4a4>
f01156a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01156a7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01156ab:	83 ec 04             	sub    $0x4,%esp
f01156ae:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01156b4:	50                   	push   %eax
f01156b5:	68 fb 98 12 f0       	push   $0xf01298fb
f01156ba:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01156c0:	50                   	push   %eax
f01156c1:	e8 d5 aa 00 00       	call   f012019b <strcconcat>
f01156c6:	83 c4 10             	add    $0x10,%esp
f01156c9:	83 ec 0c             	sub    $0xc,%esp
f01156cc:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01156d2:	50                   	push   %eax
f01156d3:	e8 23 c8 fe ff       	call   f0101efb <execute_command>
f01156d8:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01156db:	83 ec 04             	sub    $0x4,%esp
f01156de:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01156e4:	50                   	push   %eax
f01156e5:	68 88 aa 12 f0       	push   $0xf012aa88
f01156ea:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01156f0:	50                   	push   %eax
f01156f1:	e8 a5 aa 00 00       	call   f012019b <strcconcat>
f01156f6:	83 c4 10             	add    $0x10,%esp
f01156f9:	83 ec 0c             	sub    $0xc,%esp
f01156fc:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115702:	50                   	push   %eax
f0115703:	e8 f3 c7 fe ff       	call   f0101efb <execute_command>
f0115708:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f011570b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011570e:	c1 e0 03             	shl    $0x3,%eax
f0115711:	83 ec 04             	sub    $0x4,%esp
f0115714:	50                   	push   %eax
f0115715:	6a 00                	push   $0x0
f0115717:	ff 75 d8             	pushl  -0x28(%ebp)
f011571a:	e8 48 54 ff ff       	call   f010ab67 <calculate_required_frames>
f011571f:	83 c4 10             	add    $0x10,%esp
f0115722:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0115725:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f011572c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011572f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115732:	74 24                	je     f0115758 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115734:	83 ec 0c             	sub    $0xc,%esp
f0115737:	ff 75 c4             	pushl  -0x3c(%ebp)
f011573a:	ff 75 c8             	pushl  -0x38(%ebp)
f011573d:	68 fc a9 12 f0       	push   $0xf012a9fc
f0115742:	68 95 06 00 00       	push   $0x695
f0115747:	68 82 91 12 f0       	push   $0xf0129182
f011574c:	e8 85 ad fe ff       	call   f01004d6 <_warn>
f0115751:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115754:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115758:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011575c:	74 04                	je     f0115762 <test_calculate_required_frames+0x55f>
f011575e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115762:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115766:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115769:	c1 e0 0a             	shl    $0xa,%eax
f011576c:	83 ec 04             	sub    $0x4,%esp
f011576f:	50                   	push   %eax
f0115770:	6a 00                	push   $0x0
f0115772:	ff 75 d8             	pushl  -0x28(%ebp)
f0115775:	e8 ed 53 ff ff       	call   f010ab67 <calculate_required_frames>
f011577a:	83 c4 10             	add    $0x10,%esp
f011577d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115780:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115783:	c1 e0 0a             	shl    $0xa,%eax
f0115786:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115789:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115790:	99                   	cltd   
f0115791:	f7 fb                	idiv   %ebx
f0115793:	89 c1                	mov    %eax,%ecx
f0115795:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115798:	c1 e0 0a             	shl    $0xa,%eax
f011579b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011579e:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01157a5:	99                   	cltd   
f01157a6:	f7 fe                	idiv   %esi
f01157a8:	01 c8                	add    %ecx,%eax
f01157aa:	83 e8 05             	sub    $0x5,%eax
f01157ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f01157b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01157b3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01157b6:	74 24                	je     f01157dc <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01157b8:	83 ec 0c             	sub    $0xc,%esp
f01157bb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01157be:	ff 75 c8             	pushl  -0x38(%ebp)
f01157c1:	68 fc a9 12 f0       	push   $0xf012a9fc
f01157c6:	68 a0 06 00 00       	push   $0x6a0
f01157cb:	68 82 91 12 f0       	push   $0xf0129182
f01157d0:	e8 01 ad fe ff       	call   f01004d6 <_warn>
f01157d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01157dc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157e0:	74 04                	je     f01157e6 <test_calculate_required_frames+0x5e3>
f01157e2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01157e6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01157ea:	83 ec 04             	sub    $0x4,%esp
f01157ed:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01157f3:	50                   	push   %eax
f01157f4:	68 94 aa 12 f0       	push   $0xf012aa94
f01157f9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01157ff:	50                   	push   %eax
f0115800:	e8 96 a9 00 00       	call   f012019b <strcconcat>
f0115805:	83 c4 10             	add    $0x10,%esp
f0115808:	83 ec 0c             	sub    $0xc,%esp
f011580b:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115811:	50                   	push   %eax
f0115812:	e8 e4 c6 fe ff       	call   f0101efb <execute_command>
f0115817:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011581a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011581d:	89 c2                	mov    %eax,%edx
f011581f:	01 d2                	add    %edx,%edx
f0115821:	01 d0                	add    %edx,%eax
f0115823:	83 ec 04             	sub    $0x4,%esp
f0115826:	50                   	push   %eax
f0115827:	68 00 18 00 00       	push   $0x1800
f011582c:	ff 75 d8             	pushl  -0x28(%ebp)
f011582f:	e8 33 53 ff ff       	call   f010ab67 <calculate_required_frames>
f0115834:	83 c4 10             	add    $0x10,%esp
f0115837:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011583a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115841:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115844:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115847:	74 24                	je     f011586d <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115849:	83 ec 0c             	sub    $0xc,%esp
f011584c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011584f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115852:	68 fc a9 12 f0       	push   $0xf012a9fc
f0115857:	68 af 06 00 00       	push   $0x6af
f011585c:	68 82 91 12 f0       	push   $0xf0129182
f0115861:	e8 70 ac fe ff       	call   f01004d6 <_warn>
f0115866:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115869:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011586d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115871:	74 04                	je     f0115877 <test_calculate_required_frames+0x674>
f0115873:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115877:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011587b:	83 ec 04             	sub    $0x4,%esp
f011587e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115884:	50                   	push   %eax
f0115885:	68 54 9b 12 f0       	push   $0xf0129b54
f011588a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115890:	50                   	push   %eax
f0115891:	e8 05 a9 00 00       	call   f012019b <strcconcat>
f0115896:	83 c4 10             	add    $0x10,%esp
f0115899:	83 ec 0c             	sub    $0xc,%esp
f011589c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01158a2:	50                   	push   %eax
f01158a3:	e8 53 c6 fe ff       	call   f0101efb <execute_command>
f01158a8:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01158ab:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01158ae:	89 d0                	mov    %edx,%eax
f01158b0:	c1 e0 02             	shl    $0x2,%eax
f01158b3:	01 d0                	add    %edx,%eax
f01158b5:	01 c0                	add    %eax,%eax
f01158b7:	83 ec 04             	sub    $0x4,%esp
f01158ba:	50                   	push   %eax
f01158bb:	68 00 00 40 00       	push   $0x400000
f01158c0:	ff 75 d8             	pushl  -0x28(%ebp)
f01158c3:	e8 9f 52 ff ff       	call   f010ab67 <calculate_required_frames>
f01158c8:	83 c4 10             	add    $0x10,%esp
f01158cb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01158ce:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01158d5:	74 26                	je     f01158fd <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01158d7:	83 ec 0c             	sub    $0xc,%esp
f01158da:	68 03 0a 00 00       	push   $0xa03
f01158df:	ff 75 c8             	pushl  -0x38(%ebp)
f01158e2:	68 fc a9 12 f0       	push   $0xf012a9fc
f01158e7:	68 bb 06 00 00       	push   $0x6bb
f01158ec:	68 82 91 12 f0       	push   $0xf0129182
f01158f1:	e8 e0 ab fe ff       	call   f01004d6 <_warn>
f01158f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158f9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158fd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115901:	74 04                	je     f0115907 <test_calculate_required_frames+0x704>
f0115903:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115907:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f011590b:	83 ec 04             	sub    $0x4,%esp
f011590e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115914:	50                   	push   %eax
f0115915:	68 5e 9b 12 f0       	push   $0xf0129b5e
f011591a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115920:	50                   	push   %eax
f0115921:	e8 75 a8 00 00       	call   f012019b <strcconcat>
f0115926:	83 c4 10             	add    $0x10,%esp
f0115929:	83 ec 0c             	sub    $0xc,%esp
f011592c:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115932:	50                   	push   %eax
f0115933:	e8 c3 c5 fe ff       	call   f0101efb <execute_command>
f0115938:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011593b:	83 ec 04             	sub    $0x4,%esp
f011593e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115944:	50                   	push   %eax
f0115945:	68 9c aa 12 f0       	push   $0xf012aa9c
f011594a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115950:	50                   	push   %eax
f0115951:	e8 45 a8 00 00       	call   f012019b <strcconcat>
f0115956:	83 c4 10             	add    $0x10,%esp
f0115959:	83 ec 0c             	sub    $0xc,%esp
f011595c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115962:	50                   	push   %eax
f0115963:	e8 93 c5 fe ff       	call   f0101efb <execute_command>
f0115968:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011596b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011596e:	01 c0                	add    %eax,%eax
f0115970:	83 ec 04             	sub    $0x4,%esp
f0115973:	50                   	push   %eax
f0115974:	68 00 00 70 00       	push   $0x700000
f0115979:	ff 75 d8             	pushl  -0x28(%ebp)
f011597c:	e8 e6 51 ff ff       	call   f010ab67 <calculate_required_frames>
f0115981:	83 c4 10             	add    $0x10,%esp
f0115984:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115987:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f011598e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115991:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115994:	74 24                	je     f01159ba <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115996:	83 ec 0c             	sub    $0xc,%esp
f0115999:	ff 75 c4             	pushl  -0x3c(%ebp)
f011599c:	ff 75 c8             	pushl  -0x38(%ebp)
f011599f:	68 fc a9 12 f0       	push   $0xf012a9fc
f01159a4:	68 cb 06 00 00       	push   $0x6cb
f01159a9:	68 82 91 12 f0       	push   $0xf0129182
f01159ae:	e8 23 ab fe ff       	call   f01004d6 <_warn>
f01159b3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159b6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01159ba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159be:	74 04                	je     f01159c4 <test_calculate_required_frames+0x7c1>
f01159c0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01159c4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01159c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01159cb:	83 ec 04             	sub    $0x4,%esp
f01159ce:	50                   	push   %eax
f01159cf:	68 ff ff 3f 00       	push   $0x3fffff
f01159d4:	ff 75 d8             	pushl  -0x28(%ebp)
f01159d7:	e8 8b 51 ff ff       	call   f010ab67 <calculate_required_frames>
f01159dc:	83 c4 10             	add    $0x10,%esp
f01159df:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f01159e2:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f01159e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01159ec:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01159ef:	74 24                	je     f0115a15 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01159f1:	83 ec 0c             	sub    $0xc,%esp
f01159f4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01159f7:	ff 75 c8             	pushl  -0x38(%ebp)
f01159fa:	68 fc a9 12 f0       	push   $0xf012a9fc
f01159ff:	68 d6 06 00 00       	push   $0x6d6
f0115a04:	68 82 91 12 f0       	push   $0xf0129182
f0115a09:	e8 c8 aa fe ff       	call   f01004d6 <_warn>
f0115a0e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a11:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a15:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a19:	74 04                	je     f0115a1f <test_calculate_required_frames+0x81c>
f0115a1b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a1f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115a23:	83 ec 0c             	sub    $0xc,%esp
f0115a26:	68 0f 9b 12 f0       	push   $0xf0129b0f
f0115a2b:	e8 5b b5 fe ff       	call   f0100f8b <cprintf>
f0115a30:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115a33:	83 ec 08             	sub    $0x8,%esp
f0115a36:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115a39:	68 a8 aa 12 f0       	push   $0xf012aaa8
f0115a3e:	e8 48 b5 fe ff       	call   f0100f8b <cprintf>
f0115a43:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115a46:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115a4a:	75 10                	jne    f0115a5c <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115a4c:	83 ec 0c             	sub    $0xc,%esp
f0115a4f:	68 e8 aa 12 f0       	push   $0xf012aae8
f0115a54:	e8 32 b5 fe ff       	call   f0100f8b <cprintf>
f0115a59:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115a5c:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f0115a61:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115a64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115a67:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115a6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115a6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115a72:	5b                   	pop    %ebx
f0115a73:	5e                   	pop    %esi
f0115a74:	5f                   	pop    %edi
f0115a75:	5d                   	pop    %ebp
f0115a76:	c3                   	ret    

f0115a77 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115a77:	55                   	push   %ebp
f0115a78:	89 e5                	mov    %esp,%ebp
f0115a7a:	57                   	push   %edi
f0115a7b:	56                   	push   %esi
f0115a7c:	53                   	push   %ebx
f0115a7d:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115a83:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115a86:	bb 84 98 12 f0       	mov    $0xf0129884,%ebx
f0115a8b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115a90:	89 c7                	mov    %eax,%edi
f0115a92:	89 de                	mov    %ebx,%esi
f0115a94:	89 d1                	mov    %edx,%ecx
f0115a96:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115a98:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115a9b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115aa0:	b0 00                	mov    $0x0,%al
f0115aa2:	89 d7                	mov    %edx,%edi
f0115aa4:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115aa6:	6a 00                	push   $0x0
f0115aa8:	6a 0a                	push   $0xa
f0115aaa:	6a 14                	push   $0x14
f0115aac:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115aaf:	50                   	push   %eax
f0115ab0:	e8 ad 54 ff ff       	call   f010af62 <env_create>
f0115ab5:	83 c4 10             	add    $0x10,%esp
f0115ab8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115abb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115abe:	8b 40 64             	mov    0x64(%eax),%eax
f0115ac1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115ac4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115ac7:	8b 40 68             	mov    0x68(%eax),%eax
f0115aca:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115acd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115ad0:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115ad3:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115ada:	75 70 20 
f0115add:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115ae4:	00 00 00 
f0115ae7:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115aea:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115aef:	b8 00 00 00 00       	mov    $0x0,%eax
f0115af4:	89 d7                	mov    %edx,%edi
f0115af6:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115af8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115afb:	8b 40 10             	mov    0x10(%eax),%eax
f0115afe:	83 ec 08             	sub    $0x8,%esp
f0115b01:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115b07:	52                   	push   %edx
f0115b08:	50                   	push   %eax
f0115b09:	e8 b4 a5 00 00       	call   f01200c2 <ltostr>
f0115b0e:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115b11:	83 ec 04             	sub    $0x4,%esp
f0115b14:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115b1a:	50                   	push   %eax
f0115b1b:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115b21:	50                   	push   %eax
f0115b22:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115b28:	50                   	push   %eax
f0115b29:	e8 6d a6 00 00       	call   f012019b <strcconcat>
f0115b2e:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115b31:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115b38:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115b3f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115b46:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115b4a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115b51:	00 00 00 
	uint32 num_tables = 0;
f0115b54:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115b5b:	00 00 00 
	ClearUserSpace(proc_directory);
f0115b5e:	83 ec 0c             	sub    $0xc,%esp
f0115b61:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b64:	e8 8d 0e 00 00       	call   f01169f6 <ClearUserSpace>
f0115b69:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115b6c:	83 ec 0c             	sub    $0xc,%esp
f0115b6f:	68 c8 a9 12 f0       	push   $0xf012a9c8
f0115b74:	e8 12 b4 fe ff       	call   f0100f8b <cprintf>
f0115b79:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115b7c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b7f:	c1 e0 03             	shl    $0x3,%eax
f0115b82:	89 c2                	mov    %eax,%edx
f0115b84:	83 ec 0c             	sub    $0xc,%esp
f0115b87:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b8d:	50                   	push   %eax
f0115b8e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b94:	50                   	push   %eax
f0115b95:	52                   	push   %edx
f0115b96:	6a 00                	push   $0x0
f0115b98:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b9b:	e8 ad 4f ff ff       	call   f010ab4d <calculate_allocated_space>
f0115ba0:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ba3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ba9:	85 c0                	test   %eax,%eax
f0115bab:	74 27                	je     f0115bd4 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115bad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115bb3:	83 ec 0c             	sub    $0xc,%esp
f0115bb6:	6a 00                	push   $0x0
f0115bb8:	50                   	push   %eax
f0115bb9:	68 34 ab 12 f0       	push   $0xf012ab34
f0115bbe:	68 0b 07 00 00       	push   $0x70b
f0115bc3:	68 82 91 12 f0       	push   $0xf0129182
f0115bc8:	e8 09 a9 fe ff       	call   f01004d6 <_warn>
f0115bcd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bd0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115bd4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115bda:	85 c0                	test   %eax,%eax
f0115bdc:	74 27                	je     f0115c05 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115bde:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115be4:	83 ec 0c             	sub    $0xc,%esp
f0115be7:	6a 00                	push   $0x0
f0115be9:	50                   	push   %eax
f0115bea:	68 94 ab 12 f0       	push   $0xf012ab94
f0115bef:	68 10 07 00 00       	push   $0x710
f0115bf4:	68 82 91 12 f0       	push   $0xf0129182
f0115bf9:	e8 d8 a8 fe ff       	call   f01004d6 <_warn>
f0115bfe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c01:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c05:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c09:	74 04                	je     f0115c0f <test_calculate_allocated_space+0x198>
f0115c0b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115c0f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0115c13:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c1a:	00 00 00 
		num_pages = 0;
f0115c1d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c24:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0115c27:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c2a:	c1 e0 02             	shl    $0x2,%eax
f0115c2d:	89 c2                	mov    %eax,%edx
f0115c2f:	83 ec 0c             	sub    $0xc,%esp
f0115c32:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c38:	50                   	push   %eax
f0115c39:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c3f:	50                   	push   %eax
f0115c40:	52                   	push   %edx
f0115c41:	6a 00                	push   $0x0
f0115c43:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c46:	e8 02 4f ff ff       	call   f010ab4d <calculate_allocated_space>
f0115c4b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115c4e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c54:	85 c0                	test   %eax,%eax
f0115c56:	74 27                	je     f0115c7f <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115c58:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c5e:	83 ec 0c             	sub    $0xc,%esp
f0115c61:	6a 00                	push   $0x0
f0115c63:	50                   	push   %eax
f0115c64:	68 34 ab 12 f0       	push   $0xf012ab34
f0115c69:	68 1c 07 00 00       	push   $0x71c
f0115c6e:	68 82 91 12 f0       	push   $0xf0129182
f0115c73:	e8 5e a8 fe ff       	call   f01004d6 <_warn>
f0115c78:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c7b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115c7f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c85:	85 c0                	test   %eax,%eax
f0115c87:	74 27                	je     f0115cb0 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115c89:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c8f:	83 ec 0c             	sub    $0xc,%esp
f0115c92:	6a 00                	push   $0x0
f0115c94:	50                   	push   %eax
f0115c95:	68 94 ab 12 f0       	push   $0xf012ab94
f0115c9a:	68 21 07 00 00       	push   $0x721
f0115c9f:	68 82 91 12 f0       	push   $0xf0129182
f0115ca4:	e8 2d a8 fe ff       	call   f01004d6 <_warn>
f0115ca9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cac:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115cb0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115cb4:	74 04                	je     f0115cba <test_calculate_allocated_space+0x243>
f0115cb6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115cba:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115cbe:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115cc5:	00 00 00 
		num_pages = 0;
f0115cc8:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115ccf:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115cd2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115cd5:	c1 e0 0a             	shl    $0xa,%eax
f0115cd8:	89 c2                	mov    %eax,%edx
f0115cda:	83 ec 0c             	sub    $0xc,%esp
f0115cdd:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ce3:	50                   	push   %eax
f0115ce4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115cea:	50                   	push   %eax
f0115ceb:	52                   	push   %edx
f0115cec:	6a 00                	push   $0x0
f0115cee:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cf1:	e8 57 4e ff ff       	call   f010ab4d <calculate_allocated_space>
f0115cf6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115cf9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cff:	85 c0                	test   %eax,%eax
f0115d01:	74 27                	je     f0115d2a <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115d03:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d09:	83 ec 0c             	sub    $0xc,%esp
f0115d0c:	6a 00                	push   $0x0
f0115d0e:	50                   	push   %eax
f0115d0f:	68 34 ab 12 f0       	push   $0xf012ab34
f0115d14:	68 2d 07 00 00       	push   $0x72d
f0115d19:	68 82 91 12 f0       	push   $0xf0129182
f0115d1e:	e8 b3 a7 fe ff       	call   f01004d6 <_warn>
f0115d23:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d26:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115d2a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d30:	85 c0                	test   %eax,%eax
f0115d32:	74 27                	je     f0115d5b <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115d34:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d3a:	83 ec 0c             	sub    $0xc,%esp
f0115d3d:	6a 00                	push   $0x0
f0115d3f:	50                   	push   %eax
f0115d40:	68 94 ab 12 f0       	push   $0xf012ab94
f0115d45:	68 32 07 00 00       	push   $0x732
f0115d4a:	68 82 91 12 f0       	push   $0xf0129182
f0115d4f:	e8 82 a7 fe ff       	call   f01004d6 <_warn>
f0115d54:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d57:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d5b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d5f:	74 04                	je     f0115d65 <test_calculate_allocated_space+0x2ee>
f0115d61:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d65:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115d69:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115d70:	00 00 00 
		num_pages = 0;
f0115d73:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d7a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115d7d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115d80:	89 d0                	mov    %edx,%eax
f0115d82:	01 c0                	add    %eax,%eax
f0115d84:	01 d0                	add    %edx,%eax
f0115d86:	01 c0                	add    %eax,%eax
f0115d88:	05 00 10 00 00       	add    $0x1000,%eax
f0115d8d:	89 c2                	mov    %eax,%edx
f0115d8f:	83 ec 0c             	sub    $0xc,%esp
f0115d92:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d98:	50                   	push   %eax
f0115d99:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115d9f:	50                   	push   %eax
f0115da0:	52                   	push   %edx
f0115da1:	68 00 10 00 00       	push   $0x1000
f0115da6:	ff 75 d8             	pushl  -0x28(%ebp)
f0115da9:	e8 9f 4d ff ff       	call   f010ab4d <calculate_allocated_space>
f0115dae:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115db1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115db7:	85 c0                	test   %eax,%eax
f0115db9:	74 27                	je     f0115de2 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115dbb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115dc1:	83 ec 0c             	sub    $0xc,%esp
f0115dc4:	6a 00                	push   $0x0
f0115dc6:	50                   	push   %eax
f0115dc7:	68 34 ab 12 f0       	push   $0xf012ab34
f0115dcc:	68 3f 07 00 00       	push   $0x73f
f0115dd1:	68 82 91 12 f0       	push   $0xf0129182
f0115dd6:	e8 fb a6 fe ff       	call   f01004d6 <_warn>
f0115ddb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115dde:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115de2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115de8:	85 c0                	test   %eax,%eax
f0115dea:	74 27                	je     f0115e13 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115dec:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115df2:	83 ec 0c             	sub    $0xc,%esp
f0115df5:	6a 00                	push   $0x0
f0115df7:	50                   	push   %eax
f0115df8:	68 94 ab 12 f0       	push   $0xf012ab94
f0115dfd:	68 44 07 00 00       	push   $0x744
f0115e02:	68 82 91 12 f0       	push   $0xf0129182
f0115e07:	e8 ca a6 fe ff       	call   f01004d6 <_warn>
f0115e0c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e0f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e13:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e17:	74 04                	je     f0115e1d <test_calculate_allocated_space+0x3a6>
f0115e19:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e1d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0115e21:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115e28:	00 00 00 
		num_pages = 0;
f0115e2b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e32:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115e35:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e38:	89 c2                	mov    %eax,%edx
f0115e3a:	01 d2                	add    %edx,%edx
f0115e3c:	01 d0                	add    %edx,%eax
f0115e3e:	05 00 18 00 00       	add    $0x1800,%eax
f0115e43:	89 c2                	mov    %eax,%edx
f0115e45:	83 ec 0c             	sub    $0xc,%esp
f0115e48:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115e4e:	50                   	push   %eax
f0115e4f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e55:	50                   	push   %eax
f0115e56:	52                   	push   %edx
f0115e57:	68 00 18 00 00       	push   $0x1800
f0115e5c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e5f:	e8 e9 4c ff ff       	call   f010ab4d <calculate_allocated_space>
f0115e64:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e67:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e6d:	85 c0                	test   %eax,%eax
f0115e6f:	74 27                	je     f0115e98 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e71:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e77:	83 ec 0c             	sub    $0xc,%esp
f0115e7a:	6a 00                	push   $0x0
f0115e7c:	50                   	push   %eax
f0115e7d:	68 34 ab 12 f0       	push   $0xf012ab34
f0115e82:	68 50 07 00 00       	push   $0x750
f0115e87:	68 82 91 12 f0       	push   $0xf0129182
f0115e8c:	e8 45 a6 fe ff       	call   f01004d6 <_warn>
f0115e91:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e94:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e98:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e9e:	85 c0                	test   %eax,%eax
f0115ea0:	74 27                	je     f0115ec9 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115ea2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ea8:	83 ec 0c             	sub    $0xc,%esp
f0115eab:	6a 00                	push   $0x0
f0115ead:	50                   	push   %eax
f0115eae:	68 94 ab 12 f0       	push   $0xf012ab94
f0115eb3:	68 55 07 00 00       	push   $0x755
f0115eb8:	68 82 91 12 f0       	push   $0xf0129182
f0115ebd:	e8 14 a6 fe ff       	call   f01004d6 <_warn>
f0115ec2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ec5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ec9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ecd:	74 04                	je     f0115ed3 <test_calculate_allocated_space+0x45c>
f0115ecf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ed3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115ed7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115ede:	00 00 00 
		num_pages = 0;
f0115ee1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115ee8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115eeb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115eee:	89 d0                	mov    %edx,%eax
f0115ef0:	c1 e0 02             	shl    $0x2,%eax
f0115ef3:	01 d0                	add    %edx,%eax
f0115ef5:	01 c0                	add    %eax,%eax
f0115ef7:	05 00 00 40 00       	add    $0x400000,%eax
f0115efc:	89 c2                	mov    %eax,%edx
f0115efe:	83 ec 0c             	sub    $0xc,%esp
f0115f01:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f07:	50                   	push   %eax
f0115f08:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f0e:	50                   	push   %eax
f0115f0f:	52                   	push   %edx
f0115f10:	68 00 00 40 00       	push   $0x400000
f0115f15:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f18:	e8 30 4c ff ff       	call   f010ab4d <calculate_allocated_space>
f0115f1d:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115f20:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f26:	85 c0                	test   %eax,%eax
f0115f28:	74 27                	je     f0115f51 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115f2a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f30:	83 ec 0c             	sub    $0xc,%esp
f0115f33:	6a 00                	push   $0x0
f0115f35:	50                   	push   %eax
f0115f36:	68 34 ab 12 f0       	push   $0xf012ab34
f0115f3b:	68 61 07 00 00       	push   $0x761
f0115f40:	68 82 91 12 f0       	push   $0xf0129182
f0115f45:	e8 8c a5 fe ff       	call   f01004d6 <_warn>
f0115f4a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f4d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115f51:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f57:	85 c0                	test   %eax,%eax
f0115f59:	74 27                	je     f0115f82 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115f5b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f61:	83 ec 0c             	sub    $0xc,%esp
f0115f64:	6a 00                	push   $0x0
f0115f66:	50                   	push   %eax
f0115f67:	68 94 ab 12 f0       	push   $0xf012ab94
f0115f6c:	68 66 07 00 00       	push   $0x766
f0115f71:	68 82 91 12 f0       	push   $0xf0129182
f0115f76:	e8 5b a5 fe ff       	call   f01004d6 <_warn>
f0115f7b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f7e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f82:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f86:	74 04                	je     f0115f8c <test_calculate_allocated_space+0x515>
f0115f88:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f8c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115f90:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f97:	00 00 00 
		num_pages = 0;
f0115f9a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115fa1:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115fa4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115fa7:	05 00 00 38 00       	add    $0x380000,%eax
f0115fac:	01 c0                	add    %eax,%eax
f0115fae:	89 c2                	mov    %eax,%edx
f0115fb0:	83 ec 0c             	sub    $0xc,%esp
f0115fb3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115fb9:	50                   	push   %eax
f0115fba:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115fc0:	50                   	push   %eax
f0115fc1:	52                   	push   %edx
f0115fc2:	68 00 00 70 00       	push   $0x700000
f0115fc7:	ff 75 d8             	pushl  -0x28(%ebp)
f0115fca:	e8 7e 4b ff ff       	call   f010ab4d <calculate_allocated_space>
f0115fcf:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115fd2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fd8:	85 c0                	test   %eax,%eax
f0115fda:	74 27                	je     f0116003 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115fdc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fe2:	83 ec 0c             	sub    $0xc,%esp
f0115fe5:	6a 00                	push   $0x0
f0115fe7:	50                   	push   %eax
f0115fe8:	68 34 ab 12 f0       	push   $0xf012ab34
f0115fed:	68 73 07 00 00       	push   $0x773
f0115ff2:	68 82 91 12 f0       	push   $0xf0129182
f0115ff7:	e8 da a4 fe ff       	call   f01004d6 <_warn>
f0115ffc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116003:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116009:	85 c0                	test   %eax,%eax
f011600b:	74 27                	je     f0116034 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011600d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116013:	83 ec 0c             	sub    $0xc,%esp
f0116016:	6a 00                	push   $0x0
f0116018:	50                   	push   %eax
f0116019:	68 94 ab 12 f0       	push   $0xf012ab94
f011601e:	68 78 07 00 00       	push   $0x778
f0116023:	68 82 91 12 f0       	push   $0xf0129182
f0116028:	e8 a9 a4 fe ff       	call   f01004d6 <_warn>
f011602d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116030:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116034:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116038:	74 04                	je     f011603e <test_calculate_allocated_space+0x5c7>
f011603a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011603e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0116042:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116049:	00 00 00 
		num_pages = 0;
f011604c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116053:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116056:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116059:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011605e:	89 c2                	mov    %eax,%edx
f0116060:	83 ec 0c             	sub    $0xc,%esp
f0116063:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116069:	50                   	push   %eax
f011606a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116070:	50                   	push   %eax
f0116071:	52                   	push   %edx
f0116072:	68 ff ff 3f 00       	push   $0x3fffff
f0116077:	ff 75 d8             	pushl  -0x28(%ebp)
f011607a:	e8 ce 4a ff ff       	call   f010ab4d <calculate_allocated_space>
f011607f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116082:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116088:	85 c0                	test   %eax,%eax
f011608a:	74 27                	je     f01160b3 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011608c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116092:	83 ec 0c             	sub    $0xc,%esp
f0116095:	6a 00                	push   $0x0
f0116097:	50                   	push   %eax
f0116098:	68 34 ab 12 f0       	push   $0xf012ab34
f011609d:	68 84 07 00 00       	push   $0x784
f01160a2:	68 82 91 12 f0       	push   $0xf0129182
f01160a7:	e8 2a a4 fe ff       	call   f01004d6 <_warn>
f01160ac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160af:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01160b3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160b9:	85 c0                	test   %eax,%eax
f01160bb:	74 27                	je     f01160e4 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01160bd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160c3:	83 ec 0c             	sub    $0xc,%esp
f01160c6:	6a 00                	push   $0x0
f01160c8:	50                   	push   %eax
f01160c9:	68 94 ab 12 f0       	push   $0xf012ab94
f01160ce:	68 89 07 00 00       	push   $0x789
f01160d3:	68 82 91 12 f0       	push   $0xf0129182
f01160d8:	e8 f9 a3 fe ff       	call   f01004d6 <_warn>
f01160dd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160e0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01160e4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160e8:	74 04                	je     f01160ee <test_calculate_allocated_space+0x677>
f01160ea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01160ee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01160f2:	83 ec 0c             	sub    $0xc,%esp
f01160f5:	68 35 a5 12 f0       	push   $0xf012a535
f01160fa:	e8 8c ae fe ff       	call   f0100f8b <cprintf>
f01160ff:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116102:	83 ec 0c             	sub    $0xc,%esp
f0116105:	68 54 aa 12 f0       	push   $0xf012aa54
f011610a:	e8 7c ae fe ff       	call   f0100f8b <cprintf>
f011610f:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0116112:	83 ec 04             	sub    $0x4,%esp
f0116115:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f011611b:	50                   	push   %eax
f011611c:	68 ee 98 12 f0       	push   $0xf01298ee
f0116121:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116127:	50                   	push   %eax
f0116128:	e8 6e a0 00 00       	call   f012019b <strcconcat>
f011612d:	83 c4 10             	add    $0x10,%esp
f0116130:	83 ec 0c             	sub    $0xc,%esp
f0116133:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116139:	50                   	push   %eax
f011613a:	e8 bc bd fe ff       	call   f0101efb <execute_command>
f011613f:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0116142:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116149:	00 00 00 
		num_pages = 0;
f011614c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116153:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0116156:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116159:	c1 e0 03             	shl    $0x3,%eax
f011615c:	89 c2                	mov    %eax,%edx
f011615e:	83 ec 0c             	sub    $0xc,%esp
f0116161:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116167:	50                   	push   %eax
f0116168:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011616e:	50                   	push   %eax
f011616f:	52                   	push   %edx
f0116170:	6a 00                	push   $0x0
f0116172:	ff 75 d8             	pushl  -0x28(%ebp)
f0116175:	e8 d3 49 ff ff       	call   f010ab4d <calculate_allocated_space>
f011617a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011617d:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0116184:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011618b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116191:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116194:	74 28                	je     f01161be <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116196:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011619c:	83 ec 0c             	sub    $0xc,%esp
f011619f:	ff 75 c8             	pushl  -0x38(%ebp)
f01161a2:	50                   	push   %eax
f01161a3:	68 34 ab 12 f0       	push   $0xf012ab34
f01161a8:	68 a0 07 00 00       	push   $0x7a0
f01161ad:	68 82 91 12 f0       	push   $0xf0129182
f01161b2:	e8 1f a3 fe ff       	call   f01004d6 <_warn>
f01161b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01161be:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161c4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01161c7:	74 28                	je     f01161f1 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01161c9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161cf:	83 ec 0c             	sub    $0xc,%esp
f01161d2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01161d5:	50                   	push   %eax
f01161d6:	68 94 ab 12 f0       	push   $0xf012ab94
f01161db:	68 a5 07 00 00       	push   $0x7a5
f01161e0:	68 82 91 12 f0       	push   $0xf0129182
f01161e5:	e8 ec a2 fe ff       	call   f01004d6 <_warn>
f01161ea:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01161f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161f5:	74 04                	je     f01161fb <test_calculate_allocated_space+0x784>
f01161f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01161fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01161ff:	83 ec 04             	sub    $0x4,%esp
f0116202:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116208:	50                   	push   %eax
f0116209:	68 fb 98 12 f0       	push   $0xf01298fb
f011620e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116214:	50                   	push   %eax
f0116215:	e8 81 9f 00 00       	call   f012019b <strcconcat>
f011621a:	83 c4 10             	add    $0x10,%esp
f011621d:	83 ec 0c             	sub    $0xc,%esp
f0116220:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116226:	50                   	push   %eax
f0116227:	e8 cf bc fe ff       	call   f0101efb <execute_command>
f011622c:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011622f:	83 ec 04             	sub    $0x4,%esp
f0116232:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116238:	50                   	push   %eax
f0116239:	68 88 aa 12 f0       	push   $0xf012aa88
f011623e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116244:	50                   	push   %eax
f0116245:	e8 51 9f 00 00       	call   f012019b <strcconcat>
f011624a:	83 c4 10             	add    $0x10,%esp
f011624d:	83 ec 0c             	sub    $0xc,%esp
f0116250:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116256:	50                   	push   %eax
f0116257:	e8 9f bc fe ff       	call   f0101efb <execute_command>
f011625c:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f011625f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116266:	00 00 00 
		num_pages = 0;
f0116269:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116270:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0116273:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116276:	c1 e0 03             	shl    $0x3,%eax
f0116279:	89 c2                	mov    %eax,%edx
f011627b:	83 ec 0c             	sub    $0xc,%esp
f011627e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116284:	50                   	push   %eax
f0116285:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011628b:	50                   	push   %eax
f011628c:	52                   	push   %edx
f011628d:	6a 00                	push   $0x0
f011628f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116292:	e8 b6 48 ff ff       	call   f010ab4d <calculate_allocated_space>
f0116297:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011629a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01162a1:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01162a8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01162ae:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01162b1:	74 28                	je     f01162db <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01162b3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01162b9:	83 ec 0c             	sub    $0xc,%esp
f01162bc:	ff 75 c8             	pushl  -0x38(%ebp)
f01162bf:	50                   	push   %eax
f01162c0:	68 34 ab 12 f0       	push   $0xf012ab34
f01162c5:	68 b6 07 00 00       	push   $0x7b6
f01162ca:	68 82 91 12 f0       	push   $0xf0129182
f01162cf:	e8 02 a2 fe ff       	call   f01004d6 <_warn>
f01162d4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162d7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01162db:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162e1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01162e4:	74 28                	je     f011630e <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01162e6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162ec:	83 ec 0c             	sub    $0xc,%esp
f01162ef:	ff 75 c4             	pushl  -0x3c(%ebp)
f01162f2:	50                   	push   %eax
f01162f3:	68 94 ab 12 f0       	push   $0xf012ab94
f01162f8:	68 bb 07 00 00       	push   $0x7bb
f01162fd:	68 82 91 12 f0       	push   $0xf0129182
f0116302:	e8 cf a1 fe ff       	call   f01004d6 <_warn>
f0116307:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011630a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011630e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116312:	74 04                	je     f0116318 <test_calculate_allocated_space+0x8a1>
f0116314:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116318:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f011631c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116323:	00 00 00 
		num_pages = 0;
f0116326:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011632d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116330:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116333:	c1 e0 0a             	shl    $0xa,%eax
f0116336:	89 c2                	mov    %eax,%edx
f0116338:	83 ec 0c             	sub    $0xc,%esp
f011633b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116341:	50                   	push   %eax
f0116342:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116348:	50                   	push   %eax
f0116349:	52                   	push   %edx
f011634a:	6a 00                	push   $0x0
f011634c:	ff 75 d8             	pushl  -0x28(%ebp)
f011634f:	e8 f9 47 ff ff       	call   f010ab4d <calculate_allocated_space>
f0116354:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0116357:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f011635e:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116365:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011636b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011636e:	74 28                	je     f0116398 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116370:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116376:	83 ec 0c             	sub    $0xc,%esp
f0116379:	ff 75 c8             	pushl  -0x38(%ebp)
f011637c:	50                   	push   %eax
f011637d:	68 34 ab 12 f0       	push   $0xf012ab34
f0116382:	68 c9 07 00 00       	push   $0x7c9
f0116387:	68 82 91 12 f0       	push   $0xf0129182
f011638c:	e8 45 a1 fe ff       	call   f01004d6 <_warn>
f0116391:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116394:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116398:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011639e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01163a1:	74 28                	je     f01163cb <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01163a3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163a9:	83 ec 0c             	sub    $0xc,%esp
f01163ac:	ff 75 c4             	pushl  -0x3c(%ebp)
f01163af:	50                   	push   %eax
f01163b0:	68 94 ab 12 f0       	push   $0xf012ab94
f01163b5:	68 ce 07 00 00       	push   $0x7ce
f01163ba:	68 82 91 12 f0       	push   $0xf0129182
f01163bf:	e8 12 a1 fe ff       	call   f01004d6 <_warn>
f01163c4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163c7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01163cb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01163cf:	74 04                	je     f01163d5 <test_calculate_allocated_space+0x95e>
f01163d1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01163d5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01163d9:	83 ec 04             	sub    $0x4,%esp
f01163dc:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01163e2:	50                   	push   %eax
f01163e3:	68 94 aa 12 f0       	push   $0xf012aa94
f01163e8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01163ee:	50                   	push   %eax
f01163ef:	e8 a7 9d 00 00       	call   f012019b <strcconcat>
f01163f4:	83 c4 10             	add    $0x10,%esp
f01163f7:	83 ec 0c             	sub    $0xc,%esp
f01163fa:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116400:	50                   	push   %eax
f0116401:	e8 f5 ba fe ff       	call   f0101efb <execute_command>
f0116406:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116409:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116410:	00 00 00 
		num_pages = 0;
f0116413:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011641a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011641d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116420:	89 c2                	mov    %eax,%edx
f0116422:	01 d2                	add    %edx,%edx
f0116424:	01 d0                	add    %edx,%eax
f0116426:	05 00 18 00 00       	add    $0x1800,%eax
f011642b:	89 c2                	mov    %eax,%edx
f011642d:	83 ec 0c             	sub    $0xc,%esp
f0116430:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116436:	50                   	push   %eax
f0116437:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011643d:	50                   	push   %eax
f011643e:	52                   	push   %edx
f011643f:	68 00 18 00 00       	push   $0x1800
f0116444:	ff 75 d8             	pushl  -0x28(%ebp)
f0116447:	e8 01 47 ff ff       	call   f010ab4d <calculate_allocated_space>
f011644c:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011644f:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116456:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011645d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116463:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116466:	74 28                	je     f0116490 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116468:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011646e:	83 ec 0c             	sub    $0xc,%esp
f0116471:	ff 75 c8             	pushl  -0x38(%ebp)
f0116474:	50                   	push   %eax
f0116475:	68 34 ab 12 f0       	push   $0xf012ab34
f011647a:	68 df 07 00 00       	push   $0x7df
f011647f:	68 82 91 12 f0       	push   $0xf0129182
f0116484:	e8 4d a0 fe ff       	call   f01004d6 <_warn>
f0116489:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011648c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116490:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116496:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116499:	74 28                	je     f01164c3 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011649b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164a1:	83 ec 0c             	sub    $0xc,%esp
f01164a4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01164a7:	50                   	push   %eax
f01164a8:	68 94 ab 12 f0       	push   $0xf012ab94
f01164ad:	68 e4 07 00 00       	push   $0x7e4
f01164b2:	68 82 91 12 f0       	push   $0xf0129182
f01164b7:	e8 1a a0 fe ff       	call   f01004d6 <_warn>
f01164bc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164bf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01164c3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164c7:	74 04                	je     f01164cd <test_calculate_allocated_space+0xa56>
f01164c9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01164cd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01164d1:	83 ec 04             	sub    $0x4,%esp
f01164d4:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01164da:	50                   	push   %eax
f01164db:	68 54 9b 12 f0       	push   $0xf0129b54
f01164e0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01164e6:	50                   	push   %eax
f01164e7:	e8 af 9c 00 00       	call   f012019b <strcconcat>
f01164ec:	83 c4 10             	add    $0x10,%esp
f01164ef:	83 ec 0c             	sub    $0xc,%esp
f01164f2:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01164f8:	50                   	push   %eax
f01164f9:	e8 fd b9 fe ff       	call   f0101efb <execute_command>
f01164fe:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116501:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116508:	00 00 00 
		num_pages = 0;
f011650b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116512:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116515:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116518:	89 d0                	mov    %edx,%eax
f011651a:	c1 e0 02             	shl    $0x2,%eax
f011651d:	01 d0                	add    %edx,%eax
f011651f:	01 c0                	add    %eax,%eax
f0116521:	05 00 00 40 00       	add    $0x400000,%eax
f0116526:	89 c2                	mov    %eax,%edx
f0116528:	83 ec 0c             	sub    $0xc,%esp
f011652b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116531:	50                   	push   %eax
f0116532:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116538:	50                   	push   %eax
f0116539:	52                   	push   %edx
f011653a:	68 00 00 40 00       	push   $0x400000
f011653f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116542:	e8 06 46 ff ff       	call   f010ab4d <calculate_allocated_space>
f0116547:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011654a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116551:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116558:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011655e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116561:	74 28                	je     f011658b <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116563:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116569:	83 ec 0c             	sub    $0xc,%esp
f011656c:	ff 75 c8             	pushl  -0x38(%ebp)
f011656f:	50                   	push   %eax
f0116570:	68 34 ab 12 f0       	push   $0xf012ab34
f0116575:	68 f4 07 00 00       	push   $0x7f4
f011657a:	68 82 91 12 f0       	push   $0xf0129182
f011657f:	e8 52 9f fe ff       	call   f01004d6 <_warn>
f0116584:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116587:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011658b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116591:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116594:	74 28                	je     f01165be <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116596:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011659c:	83 ec 0c             	sub    $0xc,%esp
f011659f:	ff 75 c4             	pushl  -0x3c(%ebp)
f01165a2:	50                   	push   %eax
f01165a3:	68 94 ab 12 f0       	push   $0xf012ab94
f01165a8:	68 f9 07 00 00       	push   $0x7f9
f01165ad:	68 82 91 12 f0       	push   $0xf0129182
f01165b2:	e8 1f 9f fe ff       	call   f01004d6 <_warn>
f01165b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01165be:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01165c2:	74 04                	je     f01165c8 <test_calculate_allocated_space+0xb51>
f01165c4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01165c8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01165cc:	83 ec 04             	sub    $0x4,%esp
f01165cf:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01165d5:	50                   	push   %eax
f01165d6:	68 5e 9b 12 f0       	push   $0xf0129b5e
f01165db:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01165e1:	50                   	push   %eax
f01165e2:	e8 b4 9b 00 00       	call   f012019b <strcconcat>
f01165e7:	83 c4 10             	add    $0x10,%esp
f01165ea:	83 ec 0c             	sub    $0xc,%esp
f01165ed:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01165f3:	50                   	push   %eax
f01165f4:	e8 02 b9 fe ff       	call   f0101efb <execute_command>
f01165f9:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01165fc:	83 ec 04             	sub    $0x4,%esp
f01165ff:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116605:	50                   	push   %eax
f0116606:	68 9c aa 12 f0       	push   $0xf012aa9c
f011660b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116611:	50                   	push   %eax
f0116612:	e8 84 9b 00 00       	call   f012019b <strcconcat>
f0116617:	83 c4 10             	add    $0x10,%esp
f011661a:	83 ec 0c             	sub    $0xc,%esp
f011661d:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116623:	50                   	push   %eax
f0116624:	e8 d2 b8 fe ff       	call   f0101efb <execute_command>
f0116629:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f011662c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116633:	00 00 00 
		num_pages = 0;
f0116636:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011663d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116640:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116643:	05 00 00 38 00       	add    $0x380000,%eax
f0116648:	01 c0                	add    %eax,%eax
f011664a:	89 c2                	mov    %eax,%edx
f011664c:	83 ec 0c             	sub    $0xc,%esp
f011664f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116655:	50                   	push   %eax
f0116656:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011665c:	50                   	push   %eax
f011665d:	52                   	push   %edx
f011665e:	68 00 00 70 00       	push   $0x700000
f0116663:	ff 75 d8             	pushl  -0x28(%ebp)
f0116666:	e8 e2 44 ff ff       	call   f010ab4d <calculate_allocated_space>
f011666b:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011666e:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116675:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011667c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116682:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116685:	74 28                	je     f01166af <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116687:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011668d:	83 ec 0c             	sub    $0xc,%esp
f0116690:	ff 75 c8             	pushl  -0x38(%ebp)
f0116693:	50                   	push   %eax
f0116694:	68 34 ab 12 f0       	push   $0xf012ab34
f0116699:	68 0b 08 00 00       	push   $0x80b
f011669e:	68 82 91 12 f0       	push   $0xf0129182
f01166a3:	e8 2e 9e fe ff       	call   f01004d6 <_warn>
f01166a8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01166ab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01166af:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01166b5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01166b8:	74 28                	je     f01166e2 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01166ba:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01166c0:	83 ec 0c             	sub    $0xc,%esp
f01166c3:	ff 75 c4             	pushl  -0x3c(%ebp)
f01166c6:	50                   	push   %eax
f01166c7:	68 94 ab 12 f0       	push   $0xf012ab94
f01166cc:	68 10 08 00 00       	push   $0x810
f01166d1:	68 82 91 12 f0       	push   $0xf0129182
f01166d6:	e8 fb 9d fe ff       	call   f01004d6 <_warn>
f01166db:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01166de:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01166e2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01166e6:	74 04                	je     f01166ec <test_calculate_allocated_space+0xc75>
f01166e8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01166ec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f01166f0:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01166f7:	00 00 00 
		num_pages = 0;
f01166fa:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116701:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116704:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116707:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011670c:	89 c2                	mov    %eax,%edx
f011670e:	83 ec 0c             	sub    $0xc,%esp
f0116711:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116717:	50                   	push   %eax
f0116718:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011671e:	50                   	push   %eax
f011671f:	52                   	push   %edx
f0116720:	68 ff ff 3f 00       	push   $0x3fffff
f0116725:	ff 75 d8             	pushl  -0x28(%ebp)
f0116728:	e8 20 44 ff ff       	call   f010ab4d <calculate_allocated_space>
f011672d:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116730:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0116737:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011673e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116744:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116747:	74 28                	je     f0116771 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116749:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011674f:	83 ec 0c             	sub    $0xc,%esp
f0116752:	ff 75 c8             	pushl  -0x38(%ebp)
f0116755:	50                   	push   %eax
f0116756:	68 34 ab 12 f0       	push   $0xf012ab34
f011675b:	68 1e 08 00 00       	push   $0x81e
f0116760:	68 82 91 12 f0       	push   $0xf0129182
f0116765:	e8 6c 9d fe ff       	call   f01004d6 <_warn>
f011676a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011676d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116771:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116777:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011677a:	74 28                	je     f01167a4 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011677c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116782:	83 ec 0c             	sub    $0xc,%esp
f0116785:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116788:	50                   	push   %eax
f0116789:	68 94 ab 12 f0       	push   $0xf012ab94
f011678e:	68 23 08 00 00       	push   $0x823
f0116793:	68 82 91 12 f0       	push   $0xf0129182
f0116798:	e8 39 9d fe ff       	call   f01004d6 <_warn>
f011679d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01167a0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01167a4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01167a8:	74 04                	je     f01167ae <test_calculate_allocated_space+0xd37>
f01167aa:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01167ae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01167b2:	83 ec 0c             	sub    $0xc,%esp
f01167b5:	68 0f 9b 12 f0       	push   $0xf0129b0f
f01167ba:	e8 cc a7 fe ff       	call   f0100f8b <cprintf>
f01167bf:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f01167c2:	83 ec 08             	sub    $0x8,%esp
f01167c5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01167c8:	68 f0 ab 12 f0       	push   $0xf012abf0
f01167cd:	e8 b9 a7 fe ff       	call   f0100f8b <cprintf>
f01167d2:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01167d5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01167d9:	75 10                	jne    f01167eb <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f01167db:	83 ec 0c             	sub    $0xc,%esp
f01167de:	68 30 ac 12 f0       	push   $0xf012ac30
f01167e3:	e8 a3 a7 fe ff       	call   f0100f8b <cprintf>
f01167e8:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01167eb:	a1 64 36 ec f0       	mov    0xf0ec3664,%eax
f01167f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01167f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01167f6:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01167f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01167fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116801:	5b                   	pop    %ebx
f0116802:	5e                   	pop    %esi
f0116803:	5f                   	pop    %edi
f0116804:	5d                   	pop    %ebp
f0116805:	c3                   	ret    

f0116806 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116806:	55                   	push   %ebp
f0116807:	89 e5                	mov    %esp,%ebp
f0116809:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f011680c:	8b 45 10             	mov    0x10(%ebp),%eax
f011680f:	ba 01 00 00 00       	mov    $0x1,%edx
f0116814:	88 c1                	mov    %al,%cl
f0116816:	d3 e2                	shl    %cl,%edx
f0116818:	89 d0                	mov    %edx,%eax
f011681a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011681d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116820:	c1 e8 16             	shr    $0x16,%eax
f0116823:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011682a:	8b 45 08             	mov    0x8(%ebp),%eax
f011682d:	01 d0                	add    %edx,%eax
f011682f:	8b 00                	mov    (%eax),%eax
f0116831:	83 e0 01             	and    $0x1,%eax
f0116834:	85 c0                	test   %eax,%eax
f0116836:	75 07                	jne    f011683f <CB+0x39>
f0116838:	b8 00 00 00 00       	mov    $0x0,%eax
f011683d:	eb 76                	jmp    f01168b5 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011683f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116842:	c1 e8 16             	shr    $0x16,%eax
f0116845:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011684c:	8b 45 08             	mov    0x8(%ebp),%eax
f011684f:	01 d0                	add    %edx,%eax
f0116851:	8b 00                	mov    (%eax),%eax
f0116853:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116858:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011685b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011685e:	c1 e8 0c             	shr    $0xc,%eax
f0116861:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116864:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0116869:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011686c:	72 17                	jb     f0116885 <CB+0x7f>
f011686e:	ff 75 f0             	pushl  -0x10(%ebp)
f0116871:	68 7c ac 12 f0       	push   $0xf012ac7c
f0116876:	68 3e 08 00 00       	push   $0x83e
f011687b:	68 82 91 12 f0       	push   $0xf0129182
f0116880:	e8 b4 9a fe ff       	call   f0100339 <_panic>
f0116885:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116888:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011688d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116890:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116893:	c1 e8 0c             	shr    $0xc,%eax
f0116896:	25 ff 03 00 00       	and    $0x3ff,%eax
f011689b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01168a5:	01 d0                	add    %edx,%eax
f01168a7:	8b 00                	mov    (%eax),%eax
f01168a9:	23 45 f4             	and    -0xc(%ebp),%eax
f01168ac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01168af:	0f 94 c0             	sete   %al
f01168b2:	0f b6 c0             	movzbl %al,%eax
}
f01168b5:	c9                   	leave  
f01168b6:	c3                   	ret    

f01168b7 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f01168b7:	55                   	push   %ebp
f01168b8:	89 e5                	mov    %esp,%ebp
f01168ba:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01168bd:	68 ab ac 12 f0       	push   $0xf012acab
f01168c2:	68 ba ac 12 f0       	push   $0xf012acba
f01168c7:	68 43 08 00 00       	push   $0x843
f01168cc:	68 82 91 12 f0       	push   $0xf0129182
f01168d1:	e8 63 9a fe ff       	call   f0100339 <_panic>

f01168d6 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f01168d6:	55                   	push   %ebp
f01168d7:	89 e5                	mov    %esp,%ebp
f01168d9:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01168dc:	68 ab ac 12 f0       	push   $0xf012acab
f01168e1:	68 ba ac 12 f0       	push   $0xf012acba
f01168e6:	68 4d 08 00 00       	push   $0x84d
f01168eb:	68 82 91 12 f0       	push   $0xf0129182
f01168f0:	e8 44 9a fe ff       	call   f0100339 <_panic>

f01168f5 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f01168f5:	55                   	push   %ebp
f01168f6:	89 e5                	mov    %esp,%ebp
f01168f8:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01168fb:	68 ab ac 12 f0       	push   $0xf012acab
f0116900:	68 ba ac 12 f0       	push   $0xf012acba
f0116905:	68 5c 08 00 00       	push   $0x85c
f011690a:	68 82 91 12 f0       	push   $0xf0129182
f011690f:	e8 25 9a fe ff       	call   f0100339 <_panic>

f0116914 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0116914:	55                   	push   %ebp
f0116915:	89 e5                	mov    %esp,%ebp
f0116917:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011691a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011691d:	c1 e8 16             	shr    $0x16,%eax
f0116920:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116927:	8b 45 08             	mov    0x8(%ebp),%eax
f011692a:	01 d0                	add    %edx,%eax
f011692c:	8b 00                	mov    (%eax),%eax
f011692e:	83 e0 01             	and    $0x1,%eax
f0116931:	85 c0                	test   %eax,%eax
f0116933:	75 07                	jne    f011693c <CE+0x28>
f0116935:	b8 00 00 00 00       	mov    $0x0,%eax
f011693a:	eb 7a                	jmp    f01169b6 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011693c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011693f:	c1 e8 16             	shr    $0x16,%eax
f0116942:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116949:	8b 45 08             	mov    0x8(%ebp),%eax
f011694c:	01 d0                	add    %edx,%eax
f011694e:	8b 00                	mov    (%eax),%eax
f0116950:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116955:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116958:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011695b:	c1 e8 0c             	shr    $0xc,%eax
f011695e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116961:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f0116966:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116969:	72 17                	jb     f0116982 <CE+0x6e>
f011696b:	ff 75 f4             	pushl  -0xc(%ebp)
f011696e:	68 7c ac 12 f0       	push   $0xf012ac7c
f0116973:	68 65 08 00 00       	push   $0x865
f0116978:	68 82 91 12 f0       	push   $0xf0129182
f011697d:	e8 b7 99 fe ff       	call   f0100339 <_panic>
f0116982:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116985:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011698a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f011698d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116990:	c1 e8 0c             	shr    $0xc,%eax
f0116993:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116998:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011699f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01169a2:	01 d0                	add    %edx,%eax
f01169a4:	8b 00                	mov    (%eax),%eax
f01169a6:	85 c0                	test   %eax,%eax
f01169a8:	74 07                	je     f01169b1 <CE+0x9d>
f01169aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01169af:	eb 05                	jmp    f01169b6 <CE+0xa2>
	return 1;
f01169b1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01169b6:	c9                   	leave  
f01169b7:	c3                   	ret    

f01169b8 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f01169b8:	55                   	push   %ebp
f01169b9:	89 e5                	mov    %esp,%ebp
f01169bb:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01169be:	68 ab ac 12 f0       	push   $0xf012acab
f01169c3:	68 ba ac 12 f0       	push   $0xf012acba
f01169c8:	68 6c 08 00 00       	push   $0x86c
f01169cd:	68 82 91 12 f0       	push   $0xf0129182
f01169d2:	e8 62 99 fe ff       	call   f0100339 <_panic>

f01169d7 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f01169d7:	55                   	push   %ebp
f01169d8:	89 e5                	mov    %esp,%ebp
f01169da:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01169dd:	68 ab ac 12 f0       	push   $0xf012acab
f01169e2:	68 ba ac 12 f0       	push   $0xf012acba
f01169e7:	68 7c 08 00 00       	push   $0x87c
f01169ec:	68 82 91 12 f0       	push   $0xf0129182
f01169f1:	e8 43 99 fe ff       	call   f0100339 <_panic>

f01169f6 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f01169f6:	55                   	push   %ebp
f01169f7:	89 e5                	mov    %esp,%ebp
f01169f9:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01169fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116a03:	eb 18                	jmp    f0116a1d <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116a05:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116a08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a0f:	8b 45 08             	mov    0x8(%ebp),%eax
f0116a12:	01 d0                	add    %edx,%eax
f0116a14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116a1a:	ff 45 fc             	incl   -0x4(%ebp)
f0116a1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116a20:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116a25:	76 de                	jbe    f0116a05 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116a27:	90                   	nop
f0116a28:	c9                   	leave  
f0116a29:	c3                   	ret    

f0116a2a <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116a2a:	55                   	push   %ebp
f0116a2b:	89 e5                	mov    %esp,%ebp
f0116a2d:	83 ec 38             	sub    $0x38,%esp
f0116a30:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116a33:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116a36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a39:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116a3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116a41:	8b 45 10             	mov    0x10(%ebp),%eax
f0116a44:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116a49:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116a4c:	e9 ea 01 00 00       	jmp    f0116c3b <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116a51:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116a55:	74 44                	je     f0116a9b <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116a57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116a5a:	83 ec 04             	sub    $0x4,%esp
f0116a5d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116a60:	52                   	push   %edx
f0116a61:	50                   	push   %eax
f0116a62:	ff 75 08             	pushl  0x8(%ebp)
f0116a65:	e8 ff 1c ff ff       	call   f0108769 <get_frame_info>
f0116a6a:	83 c4 10             	add    $0x10,%esp
f0116a6d:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116a70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116a73:	85 c0                	test   %eax,%eax
f0116a75:	75 24                	jne    f0116a9b <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116a77:	83 ec 04             	sub    $0x4,%esp
f0116a7a:	68 d0 ac 12 f0       	push   $0xf012acd0
f0116a7f:	68 99 08 00 00       	push   $0x899
f0116a84:	68 82 91 12 f0       	push   $0xf0129182
f0116a89:	e8 48 9a fe ff       	call   f01004d6 <_warn>
f0116a8e:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116a91:	b8 00 00 00 00       	mov    $0x0,%eax
f0116a96:	e9 b6 01 00 00       	jmp    f0116c51 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116a9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116a9e:	83 ec 04             	sub    $0x4,%esp
f0116aa1:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116aa4:	52                   	push   %edx
f0116aa5:	50                   	push   %eax
f0116aa6:	ff 75 08             	pushl  0x8(%ebp)
f0116aa9:	e8 bb 1c ff ff       	call   f0108769 <get_frame_info>
f0116aae:	83 c4 10             	add    $0x10,%esp
f0116ab1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116ab4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116ab7:	85 c0                	test   %eax,%eax
f0116ab9:	75 24                	jne    f0116adf <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116abb:	83 ec 04             	sub    $0x4,%esp
f0116abe:	68 fc ac 12 f0       	push   $0xf012acfc
f0116ac3:	68 a0 08 00 00       	push   $0x8a0
f0116ac8:	68 82 91 12 f0       	push   $0xf0129182
f0116acd:	e8 04 9a fe ff       	call   f01004d6 <_warn>
f0116ad2:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116ad5:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ada:	e9 72 01 00 00       	jmp    f0116c51 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116adf:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116ae3:	75 70                	jne    f0116b55 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116ae5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116ae8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116aeb:	c1 ea 0c             	shr    $0xc,%edx
f0116aee:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116af4:	c1 e2 02             	shl    $0x2,%edx
f0116af7:	01 d0                	add    %edx,%eax
f0116af9:	8b 00                	mov    (%eax),%eax
f0116afb:	c1 e8 0c             	shr    $0xc,%eax
f0116afe:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116b01:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116b04:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116b07:	c1 ea 0c             	shr    $0xc,%edx
f0116b0a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116b10:	c1 e2 02             	shl    $0x2,%edx
f0116b13:	01 d0                	add    %edx,%eax
f0116b15:	8b 00                	mov    (%eax),%eax
f0116b17:	c1 e8 0c             	shr    $0xc,%eax
f0116b1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116b1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116b20:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116b23:	74 30                	je     f0116b55 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116b25:	83 ec 04             	sub    $0x4,%esp
f0116b28:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116b2b:	ff 75 e8             	pushl  -0x18(%ebp)
f0116b2e:	ff 75 f0             	pushl  -0x10(%ebp)
f0116b31:	ff 75 f4             	pushl  -0xc(%ebp)
f0116b34:	68 28 ad 12 f0       	push   $0xf012ad28
f0116b39:	68 aa 08 00 00       	push   $0x8aa
f0116b3e:	68 82 91 12 f0       	push   $0xf0129182
f0116b43:	e8 8e 99 fe ff       	call   f01004d6 <_warn>
f0116b48:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116b4b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b50:	e9 fc 00 00 00       	jmp    f0116c51 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116b55:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116b59:	74 52                	je     f0116bad <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116b5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116b5f:	74 0e                	je     f0116b6f <CCP+0x145>
f0116b61:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b64:	8b 40 08             	mov    0x8(%eax),%eax
f0116b67:	0f b7 c0             	movzwl %ax,%eax
f0116b6a:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116b6d:	74 3e                	je     f0116bad <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116b6f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116b73:	74 0b                	je     f0116b80 <CCP+0x156>
f0116b75:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b78:	8b 40 08             	mov    0x8(%eax),%eax
f0116b7b:	0f b7 c0             	movzwl %ax,%eax
f0116b7e:	eb 05                	jmp    f0116b85 <CCP+0x15b>
f0116b80:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b85:	83 ec 0c             	sub    $0xc,%esp
f0116b88:	50                   	push   %eax
f0116b89:	ff 75 f0             	pushl  -0x10(%ebp)
f0116b8c:	68 84 ad 12 f0       	push   $0xf012ad84
f0116b91:	68 b2 08 00 00       	push   $0x8b2
f0116b96:	68 82 91 12 f0       	push   $0xf0129182
f0116b9b:	e8 36 99 fe ff       	call   f01004d6 <_warn>
f0116ba0:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116ba3:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ba8:	e9 a4 00 00 00       	jmp    f0116c51 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116bad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116bb0:	ff 75 20             	pushl  0x20(%ebp)
f0116bb3:	ff 75 1c             	pushl  0x1c(%ebp)
f0116bb6:	50                   	push   %eax
f0116bb7:	ff 75 08             	pushl  0x8(%ebp)
f0116bba:	e8 17 fd ff ff       	call   f01168d6 <CPs>
f0116bbf:	83 c4 10             	add    $0x10,%esp
f0116bc2:	85 c0                	test   %eax,%eax
f0116bc4:	7f 21                	jg     f0116be7 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116bc6:	83 ec 04             	sub    $0x4,%esp
f0116bc9:	68 f4 ad 12 f0       	push   $0xf012adf4
f0116bce:	68 b8 08 00 00       	push   $0x8b8
f0116bd3:	68 82 91 12 f0       	push   $0xf0129182
f0116bd8:	e8 f9 98 fe ff       	call   f01004d6 <_warn>
f0116bdd:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116be0:	b8 00 00 00 00       	mov    $0x0,%eax
f0116be5:	eb 6a                	jmp    f0116c51 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116be7:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116beb:	74 3a                	je     f0116c27 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116bf0:	ff 75 28             	pushl  0x28(%ebp)
f0116bf3:	ff 75 24             	pushl  0x24(%ebp)
f0116bf6:	50                   	push   %eax
f0116bf7:	ff 75 08             	pushl  0x8(%ebp)
f0116bfa:	e8 d7 fc ff ff       	call   f01168d6 <CPs>
f0116bff:	83 c4 10             	add    $0x10,%esp
f0116c02:	85 c0                	test   %eax,%eax
f0116c04:	7f 21                	jg     f0116c27 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116c06:	83 ec 04             	sub    $0x4,%esp
f0116c09:	68 3c ae 12 f0       	push   $0xf012ae3c
f0116c0e:	68 bf 08 00 00       	push   $0x8bf
f0116c13:	68 82 91 12 f0       	push   $0xf0129182
f0116c18:	e8 b9 98 fe ff       	call   f01004d6 <_warn>
f0116c1d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116c20:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c25:	eb 2a                	jmp    f0116c51 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116c27:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116c2b:	74 07                	je     f0116c34 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116c2d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116c34:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116c3b:	8b 55 10             	mov    0x10(%ebp),%edx
f0116c3e:	8b 45 14             	mov    0x14(%ebp),%eax
f0116c41:	01 d0                	add    %edx,%eax
f0116c43:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116c46:	0f 87 05 fe ff ff    	ja     f0116a51 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116c4c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116c51:	c9                   	leave  
f0116c52:	c3                   	ret    

f0116c53 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116c53:	55                   	push   %ebp
f0116c54:	89 e5                	mov    %esp,%ebp
f0116c56:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116c59:	83 ec 04             	sub    $0x4,%esp
f0116c5c:	68 7c ae 12 f0       	push   $0xf012ae7c
f0116c61:	6a 0e                	push   $0xe
f0116c63:	68 8c ae 12 f0       	push   $0xf012ae8c
f0116c68:	e8 cc 96 fe ff       	call   f0100339 <_panic>

f0116c6d <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116c6d:	55                   	push   %ebp
f0116c6e:	89 e5                	mov    %esp,%ebp
f0116c70:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116c73:	83 ec 04             	sub    $0x4,%esp
f0116c76:	68 7c ae 12 f0       	push   $0xf012ae7c
f0116c7b:	68 d7 00 00 00       	push   $0xd7
f0116c80:	68 8c ae 12 f0       	push   $0xf012ae8c
f0116c85:	e8 af 96 fe ff       	call   f0100339 <_panic>

f0116c8a <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116c8a:	55                   	push   %ebp
f0116c8b:	89 e5                	mov    %esp,%ebp
f0116c8d:	57                   	push   %edi
f0116c8e:	53                   	push   %ebx
f0116c8f:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116c95:	83 ec 0c             	sub    $0xc,%esp
f0116c98:	68 a8 ae 12 f0       	push   $0xf012aea8
f0116c9d:	e8 e9 a2 fe ff       	call   f0100f8b <cprintf>
f0116ca2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116ca5:	83 ec 0c             	sub    $0xc,%esp
f0116ca8:	68 d8 ae 12 f0       	push   $0xf012aed8
f0116cad:	e8 d9 a2 fe ff       	call   f0100f8b <cprintf>
f0116cb2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116cb5:	83 ec 0c             	sub    $0xc,%esp
f0116cb8:	68 a8 ae 12 f0       	push   $0xf012aea8
f0116cbd:	e8 c9 a2 fe ff       	call   f0100f8b <cprintf>
f0116cc2:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0116cc5:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116cc9:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116ccd:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0116cd3:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116cd9:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0116ce0:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0116ce7:	e8 16 7c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116cec:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116cef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116cf6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0116cfd:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0116d03:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116d08:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d0d:	89 d7                	mov    %edx,%edi
f0116d0f:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0116d11:	83 ec 0c             	sub    $0xc,%esp
f0116d14:	68 31 af 12 f0       	push   $0xf012af31
f0116d19:	e8 6d a2 fe ff       	call   f0100f8b <cprintf>
f0116d1e:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116d21:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0116d28:	e8 d5 7b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116d2d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116d30:	e8 70 db fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116d35:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0116d38:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0116d3f:	83 ec 0c             	sub    $0xc,%esp
f0116d42:	ff 75 cc             	pushl  -0x34(%ebp)
f0116d45:	e8 e0 27 ff ff       	call   f010952a <kmalloc>
f0116d4a:	83 c4 10             	add    $0x10,%esp
f0116d4d:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0116d53:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116d59:	85 c0                	test   %eax,%eax
f0116d5b:	74 17                	je     f0116d74 <test_kmalloc+0xea>
f0116d5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d64:	83 ec 0c             	sub    $0xc,%esp
f0116d67:	68 50 af 12 f0       	push   $0xf012af50
f0116d6c:	e8 1a a2 fe ff       	call   f0100f8b <cprintf>
f0116d71:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116d74:	e8 2c db fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116d79:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116d7c:	74 17                	je     f0116d95 <test_kmalloc+0x10b>
f0116d7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d85:	83 ec 0c             	sub    $0xc,%esp
f0116d88:	68 84 af 12 f0       	push   $0xf012af84
f0116d8d:	e8 f9 a1 fe ff       	call   f0100f8b <cprintf>
f0116d92:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116d95:	e8 68 7b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116d9a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116d9d:	74 17                	je     f0116db6 <test_kmalloc+0x12c>
f0116d9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116da6:	83 ec 0c             	sub    $0xc,%esp
f0116da9:	68 f0 af 12 f0       	push   $0xf012aff0
f0116dae:	e8 d8 a1 fe ff       	call   f0100f8b <cprintf>
f0116db3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116db6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116dba:	74 04                	je     f0116dc0 <test_kmalloc+0x136>
f0116dbc:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0116dc0:	83 ec 0c             	sub    $0xc,%esp
f0116dc3:	68 34 b0 12 f0       	push   $0xf012b034
f0116dc8:	e8 be a1 fe ff       	call   f0100f8b <cprintf>
f0116dcd:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116dd0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116dd7:	e8 26 7b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116ddc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ddf:	e8 c1 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116de4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0116de7:	83 ec 0c             	sub    $0xc,%esp
f0116dea:	68 00 fc 1f 00       	push   $0x1ffc00
f0116def:	e8 36 27 ff ff       	call   f010952a <kmalloc>
f0116df4:	83 c4 10             	add    $0x10,%esp
f0116df7:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116dfd:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116e03:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0116e08:	74 17                	je     f0116e21 <test_kmalloc+0x197>
f0116e0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e11:	83 ec 0c             	sub    $0xc,%esp
f0116e14:	68 78 b0 12 f0       	push   $0xf012b078
f0116e19:	e8 6d a1 fe ff       	call   f0100f8b <cprintf>
f0116e1e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e21:	e8 7f da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e26:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116e29:	74 17                	je     f0116e42 <test_kmalloc+0x1b8>
f0116e2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e32:	83 ec 0c             	sub    $0xc,%esp
f0116e35:	68 cc b0 12 f0       	push   $0xf012b0cc
f0116e3a:	e8 4c a1 fe ff       	call   f0100f8b <cprintf>
f0116e3f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116e42:	e8 bb 7a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116e47:	89 c2                	mov    %eax,%edx
f0116e49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116e4c:	29 d0                	sub    %edx,%eax
f0116e4e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116e53:	7f 17                	jg     f0116e6c <test_kmalloc+0x1e2>
f0116e55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e5c:	83 ec 0c             	sub    $0xc,%esp
f0116e5f:	68 38 b1 12 f0       	push   $0xf012b138
f0116e64:	e8 22 a1 fe ff       	call   f0100f8b <cprintf>
f0116e69:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e6c:	e8 91 7a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116e71:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e74:	e8 2c da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e79:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116e7c:	83 ec 0c             	sub    $0xc,%esp
f0116e7f:	68 00 fc 1f 00       	push   $0x1ffc00
f0116e84:	e8 a1 26 ff ff       	call   f010952a <kmalloc>
f0116e89:	83 c4 10             	add    $0x10,%esp
f0116e8c:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116e92:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116e98:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116e9d:	74 17                	je     f0116eb6 <test_kmalloc+0x22c>
f0116e9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ea6:	83 ec 0c             	sub    $0xc,%esp
f0116ea9:	68 7c b1 12 f0       	push   $0xf012b17c
f0116eae:	e8 d8 a0 fe ff       	call   f0100f8b <cprintf>
f0116eb3:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116eb6:	e8 ea d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116ebb:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116ebe:	74 17                	je     f0116ed7 <test_kmalloc+0x24d>
f0116ec0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ec7:	83 ec 0c             	sub    $0xc,%esp
f0116eca:	68 d0 b1 12 f0       	push   $0xf012b1d0
f0116ecf:	e8 b7 a0 fe ff       	call   f0100f8b <cprintf>
f0116ed4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116ed7:	e8 26 7a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116edc:	89 c2                	mov    %eax,%edx
f0116ede:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116ee1:	29 d0                	sub    %edx,%eax
f0116ee3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116ee8:	7f 17                	jg     f0116f01 <test_kmalloc+0x277>
f0116eea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ef1:	83 ec 0c             	sub    $0xc,%esp
f0116ef4:	68 3c b2 12 f0       	push   $0xf012b23c
f0116ef9:	e8 8d a0 fe ff       	call   f0100f8b <cprintf>
f0116efe:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0116f01:	e8 fc 79 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0116f06:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f09:	e8 97 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f0e:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0116f11:	83 ec 0c             	sub    $0xc,%esp
f0116f14:	68 ff 07 00 00       	push   $0x7ff
f0116f19:	e8 0c 26 ff ff       	call   f010952a <kmalloc>
f0116f1e:	83 c4 10             	add    $0x10,%esp
f0116f21:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0116f27:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116f2d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116f32:	76 28                	jbe    f0116f5c <test_kmalloc+0x2d2>
f0116f34:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0116f3a:	83 ec 0c             	sub    $0xc,%esp
f0116f3d:	6a 00                	push   $0x0
f0116f3f:	e8 b3 24 ff ff       	call   f01093f7 <sbrk>
f0116f44:	83 c4 10             	add    $0x10,%esp
f0116f47:	39 c3                	cmp    %eax,%ebx
f0116f49:	73 11                	jae    f0116f5c <test_kmalloc+0x2d2>
f0116f4b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116f51:	89 c2                	mov    %eax,%edx
f0116f53:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0116f58:	39 c2                	cmp    %eax,%edx
f0116f5a:	72 17                	jb     f0116f73 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116f5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f63:	83 ec 0c             	sub    $0xc,%esp
f0116f66:	68 80 b2 12 f0       	push   $0xf012b280
f0116f6b:	e8 1b a0 fe ff       	call   f0100f8b <cprintf>
f0116f70:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f73:	e8 2d d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f78:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116f7b:	74 17                	je     f0116f94 <test_kmalloc+0x30a>
f0116f7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f84:	83 ec 0c             	sub    $0xc,%esp
f0116f87:	68 0c b3 12 f0       	push   $0xf012b30c
f0116f8c:	e8 fa 9f fe ff       	call   f0100f8b <cprintf>
f0116f91:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f94:	e8 0c d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f99:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0116f9c:	83 ec 0c             	sub    $0xc,%esp
f0116f9f:	68 ff 07 00 00       	push   $0x7ff
f0116fa4:	e8 81 25 ff ff       	call   f010952a <kmalloc>
f0116fa9:	83 c4 10             	add    $0x10,%esp
f0116fac:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0116fb2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116fb8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116fbd:	76 28                	jbe    f0116fe7 <test_kmalloc+0x35d>
f0116fbf:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0116fc5:	83 ec 0c             	sub    $0xc,%esp
f0116fc8:	6a 00                	push   $0x0
f0116fca:	e8 28 24 ff ff       	call   f01093f7 <sbrk>
f0116fcf:	83 c4 10             	add    $0x10,%esp
f0116fd2:	39 c3                	cmp    %eax,%ebx
f0116fd4:	73 11                	jae    f0116fe7 <test_kmalloc+0x35d>
f0116fd6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116fdc:	89 c2                	mov    %eax,%edx
f0116fde:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0116fe3:	39 c2                	cmp    %eax,%edx
f0116fe5:	72 17                	jb     f0116ffe <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116fe7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fee:	83 ec 0c             	sub    $0xc,%esp
f0116ff1:	68 78 b3 12 f0       	push   $0xf012b378
f0116ff6:	e8 90 9f fe ff       	call   f0100f8b <cprintf>
f0116ffb:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116ffe:	e8 a2 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117003:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117006:	74 17                	je     f011701f <test_kmalloc+0x395>
f0117008:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011700f:	83 ec 0c             	sub    $0xc,%esp
f0117012:	68 04 b4 12 f0       	push   $0xf012b404
f0117017:	e8 6f 9f fe ff       	call   f0100f8b <cprintf>
f011701c:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f011701f:	e8 de 78 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117024:	89 c2                	mov    %eax,%edx
f0117026:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117029:	29 d0                	sub    %edx,%eax
f011702b:	83 f8 01             	cmp    $0x1,%eax
f011702e:	74 17                	je     f0117047 <test_kmalloc+0x3bd>
f0117030:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117037:	83 ec 0c             	sub    $0xc,%esp
f011703a:	68 70 b4 12 f0       	push   $0xf012b470
f011703f:	e8 47 9f fe ff       	call   f0100f8b <cprintf>
f0117044:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117047:	e8 b6 78 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011704c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011704f:	e8 51 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117054:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0117057:	83 ec 0c             	sub    $0xc,%esp
f011705a:	68 00 1c 00 00       	push   $0x1c00
f011705f:	e8 c6 24 ff ff       	call   f010952a <kmalloc>
f0117064:	83 c4 10             	add    $0x10,%esp
f0117067:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011706d:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117073:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117078:	74 17                	je     f0117091 <test_kmalloc+0x407>
f011707a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117081:	83 ec 0c             	sub    $0xc,%esp
f0117084:	68 90 b4 12 f0       	push   $0xf012b490
f0117089:	e8 fd 9e fe ff       	call   f0100f8b <cprintf>
f011708e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117091:	e8 0f d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117096:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117099:	74 17                	je     f01170b2 <test_kmalloc+0x428>
f011709b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170a2:	83 ec 0c             	sub    $0xc,%esp
f01170a5:	68 e4 b4 12 f0       	push   $0xf012b4e4
f01170aa:	e8 dc 9e fe ff       	call   f0100f8b <cprintf>
f01170af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01170b2:	e8 4b 78 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01170b7:	89 c2                	mov    %eax,%edx
f01170b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01170bc:	29 d0                	sub    %edx,%eax
f01170be:	83 f8 01             	cmp    $0x1,%eax
f01170c1:	7f 17                	jg     f01170da <test_kmalloc+0x450>
f01170c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170ca:	83 ec 0c             	sub    $0xc,%esp
f01170cd:	68 50 b5 12 f0       	push   $0xf012b550
f01170d2:	e8 b4 9e fe ff       	call   f0100f8b <cprintf>
f01170d7:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01170da:	e8 23 78 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01170df:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01170e2:	e8 be d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170e7:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f01170ea:	83 ec 0c             	sub    $0xc,%esp
f01170ed:	68 00 fc 2f 00       	push   $0x2ffc00
f01170f2:	e8 33 24 ff ff       	call   f010952a <kmalloc>
f01170f7:	83 c4 10             	add    $0x10,%esp
f01170fa:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117100:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0117106:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011710b:	74 17                	je     f0117124 <test_kmalloc+0x49a>
f011710d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117114:	83 ec 0c             	sub    $0xc,%esp
f0117117:	68 94 b5 12 f0       	push   $0xf012b594
f011711c:	e8 6a 9e fe ff       	call   f0100f8b <cprintf>
f0117121:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117124:	e8 7c d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117129:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011712c:	74 17                	je     f0117145 <test_kmalloc+0x4bb>
f011712e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117135:	83 ec 0c             	sub    $0xc,%esp
f0117138:	68 e8 b5 12 f0       	push   $0xf012b5e8
f011713d:	e8 49 9e fe ff       	call   f0100f8b <cprintf>
f0117142:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117145:	e8 b8 77 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011714a:	89 c2                	mov    %eax,%edx
f011714c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011714f:	29 d0                	sub    %edx,%eax
f0117151:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117156:	7f 17                	jg     f011716f <test_kmalloc+0x4e5>
f0117158:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011715f:	83 ec 0c             	sub    $0xc,%esp
f0117162:	68 54 b6 12 f0       	push   $0xf012b654
f0117167:	e8 1f 9e fe ff       	call   f0100f8b <cprintf>
f011716c:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011716f:	e8 8e 77 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117174:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117177:	e8 29 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011717c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011717f:	83 ec 0c             	sub    $0xc,%esp
f0117182:	68 00 fc 5f 00       	push   $0x5ffc00
f0117187:	e8 9e 23 ff ff       	call   f010952a <kmalloc>
f011718c:	83 c4 10             	add    $0x10,%esp
f011718f:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117195:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011719b:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01171a0:	74 17                	je     f01171b9 <test_kmalloc+0x52f>
f01171a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171a9:	83 ec 0c             	sub    $0xc,%esp
f01171ac:	68 98 b6 12 f0       	push   $0xf012b698
f01171b1:	e8 d5 9d fe ff       	call   f0100f8b <cprintf>
f01171b6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01171b9:	e8 e7 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171be:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01171c1:	74 17                	je     f01171da <test_kmalloc+0x550>
f01171c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171ca:	83 ec 0c             	sub    $0xc,%esp
f01171cd:	68 ec b6 12 f0       	push   $0xf012b6ec
f01171d2:	e8 b4 9d fe ff       	call   f0100f8b <cprintf>
f01171d7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01171da:	e8 23 77 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01171df:	89 c2                	mov    %eax,%edx
f01171e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01171e4:	29 d0                	sub    %edx,%eax
f01171e6:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01171eb:	7f 17                	jg     f0117204 <test_kmalloc+0x57a>
f01171ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171f4:	83 ec 0c             	sub    $0xc,%esp
f01171f7:	68 58 b7 12 f0       	push   $0xf012b758
f01171fc:	e8 8a 9d fe ff       	call   f0100f8b <cprintf>
f0117201:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117204:	e8 f9 76 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117209:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011720c:	e8 94 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117211:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0117214:	83 ec 0c             	sub    $0xc,%esp
f0117217:	68 00 38 00 00       	push   $0x3800
f011721c:	e8 09 23 ff ff       	call   f010952a <kmalloc>
f0117221:	83 c4 10             	add    $0x10,%esp
f0117224:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011722a:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117230:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0117235:	74 17                	je     f011724e <test_kmalloc+0x5c4>
f0117237:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011723e:	83 ec 0c             	sub    $0xc,%esp
f0117241:	68 9c b7 12 f0       	push   $0xf012b79c
f0117246:	e8 40 9d fe ff       	call   f0100f8b <cprintf>
f011724b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011724e:	e8 52 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117253:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117256:	74 17                	je     f011726f <test_kmalloc+0x5e5>
f0117258:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011725f:	83 ec 0c             	sub    $0xc,%esp
f0117262:	68 f0 b7 12 f0       	push   $0xf012b7f0
f0117267:	e8 1f 9d fe ff       	call   f0100f8b <cprintf>
f011726c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011726f:	e8 8e 76 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117274:	89 c2                	mov    %eax,%edx
f0117276:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117279:	29 d0                	sub    %edx,%eax
f011727b:	83 f8 03             	cmp    $0x3,%eax
f011727e:	7f 17                	jg     f0117297 <test_kmalloc+0x60d>
f0117280:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117287:	83 ec 0c             	sub    $0xc,%esp
f011728a:	68 5c b8 12 f0       	push   $0xf012b85c
f011728f:	e8 f7 9c fe ff       	call   f0100f8b <cprintf>
f0117294:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117297:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011729b:	74 04                	je     f01172a1 <test_kmalloc+0x617>
f011729d:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01172a1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f01172a8:	83 ec 0c             	sub    $0xc,%esp
f01172ab:	68 a0 b8 12 f0       	push   $0xf012b8a0
f01172b0:	e8 d6 9c fe ff       	call   f0100f8b <cprintf>
f01172b5:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01172b8:	e8 45 76 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01172bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172c0:	e8 e0 d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172c5:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f01172c8:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f01172cf:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01172d5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f01172d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01172db:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01172de:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f01172e0:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01172e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01172e6:	01 c2                	add    %eax,%edx
f01172e8:	8a 45 ea             	mov    -0x16(%ebp),%al
f01172eb:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f01172ed:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01172f3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f01172f6:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f01172fd:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117300:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117303:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0117306:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117309:	01 c0                	add    %eax,%eax
f011730b:	89 c2                	mov    %eax,%edx
f011730d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117310:	01 c2                	add    %eax,%edx
f0117312:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117316:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0117319:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011731f:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0117322:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0117329:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011732c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011732f:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0117331:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117334:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011733b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011733e:	01 c2                	add    %eax,%edx
f0117340:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117343:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0117345:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011734b:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f011734e:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0117355:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117358:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011735b:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f011735d:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0117360:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117363:	01 c2                	add    %eax,%edx
f0117365:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117368:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f011736a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117370:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0117373:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f011737a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011737d:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117380:	88 10                	mov    %dl,(%eax)
f0117382:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0117385:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117388:	66 89 42 02          	mov    %ax,0x2(%edx)
f011738c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011738f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117392:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0117395:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117398:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011739f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173a2:	01 c2                	add    %eax,%edx
f01173a4:	8a 45 ea             	mov    -0x16(%ebp),%al
f01173a7:	88 02                	mov    %al,(%edx)
f01173a9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01173ac:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01173b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173b6:	01 c2                	add    %eax,%edx
f01173b8:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01173bc:	66 89 42 02          	mov    %ax,0x2(%edx)
f01173c0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01173c3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01173ca:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173cd:	01 c2                	add    %eax,%edx
f01173cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01173d2:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f01173d5:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f01173dc:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01173e2:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f01173e5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01173e8:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01173eb:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f01173ed:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01173f0:	89 c2                	mov    %eax,%edx
f01173f2:	c1 ea 1f             	shr    $0x1f,%edx
f01173f5:	01 d0                	add    %edx,%eax
f01173f7:	d1 f8                	sar    %eax
f01173f9:	89 c2                	mov    %eax,%edx
f01173fb:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01173fe:	01 c2                	add    %eax,%edx
f0117400:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117403:	88 c1                	mov    %al,%cl
f0117405:	c0 e9 07             	shr    $0x7,%cl
f0117408:	01 c8                	add    %ecx,%eax
f011740a:	d0 f8                	sar    %al
f011740c:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011740e:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117411:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117414:	01 c2                	add    %eax,%edx
f0117416:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117419:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011741b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117421:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0117424:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011742b:	8b 55 98             	mov    -0x68(%ebp),%edx
f011742e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117431:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0117434:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117437:	01 c0                	add    %eax,%eax
f0117439:	89 c2                	mov    %eax,%edx
f011743b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011743e:	01 c2                	add    %eax,%edx
f0117440:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117444:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0117447:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011744a:	8a 00                	mov    (%eax),%al
f011744c:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011744f:	75 0f                	jne    f0117460 <test_kmalloc+0x7d6>
f0117451:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117454:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117457:	01 d0                	add    %edx,%eax
f0117459:	8a 00                	mov    (%eax),%al
f011745b:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011745e:	74 17                	je     f0117477 <test_kmalloc+0x7ed>
f0117460:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117467:	83 ec 0c             	sub    $0xc,%esp
f011746a:	68 d8 b8 12 f0       	push   $0xf012b8d8
f011746f:	e8 17 9b fe ff       	call   f0100f8b <cprintf>
f0117474:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0117477:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011747a:	66 8b 00             	mov    (%eax),%ax
f011747d:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117481:	75 15                	jne    f0117498 <test_kmalloc+0x80e>
f0117483:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117486:	01 c0                	add    %eax,%eax
f0117488:	89 c2                	mov    %eax,%edx
f011748a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011748d:	01 d0                	add    %edx,%eax
f011748f:	66 8b 00             	mov    (%eax),%ax
f0117492:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117496:	74 17                	je     f01174af <test_kmalloc+0x825>
f0117498:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011749f:	83 ec 0c             	sub    $0xc,%esp
f01174a2:	68 10 b9 12 f0       	push   $0xf012b910
f01174a7:	e8 df 9a fe ff       	call   f0100f8b <cprintf>
f01174ac:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f01174af:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01174b2:	8b 00                	mov    (%eax),%eax
f01174b4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01174b7:	75 16                	jne    f01174cf <test_kmalloc+0x845>
f01174b9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01174bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01174c3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01174c6:	01 d0                	add    %edx,%eax
f01174c8:	8b 00                	mov    (%eax),%eax
f01174ca:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01174cd:	74 17                	je     f01174e6 <test_kmalloc+0x85c>
f01174cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174d6:	83 ec 0c             	sub    $0xc,%esp
f01174d9:	68 4c b9 12 f0       	push   $0xf012b94c
f01174de:	e8 a8 9a fe ff       	call   f0100f8b <cprintf>
f01174e3:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f01174e6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01174e9:	8a 00                	mov    (%eax),%al
f01174eb:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01174ee:	75 0f                	jne    f01174ff <test_kmalloc+0x875>
f01174f0:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01174f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01174f6:	01 d0                	add    %edx,%eax
f01174f8:	8a 00                	mov    (%eax),%al
f01174fa:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01174fd:	74 17                	je     f0117516 <test_kmalloc+0x88c>
f01174ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117506:	83 ec 0c             	sub    $0xc,%esp
f0117509:	68 88 b9 12 f0       	push   $0xf012b988
f011750e:	e8 78 9a fe ff       	call   f0100f8b <cprintf>
f0117513:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0117516:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117519:	8a 00                	mov    (%eax),%al
f011751b:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011751e:	75 16                	jne    f0117536 <test_kmalloc+0x8ac>
f0117520:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117523:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011752a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011752d:	01 d0                	add    %edx,%eax
f011752f:	8a 00                	mov    (%eax),%al
f0117531:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117534:	74 17                	je     f011754d <test_kmalloc+0x8c3>
f0117536:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011753d:	83 ec 0c             	sub    $0xc,%esp
f0117540:	68 c4 b9 12 f0       	push   $0xf012b9c4
f0117545:	e8 41 9a fe ff       	call   f0100f8b <cprintf>
f011754a:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f011754d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117550:	66 8b 40 02          	mov    0x2(%eax),%ax
f0117554:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117558:	75 19                	jne    f0117573 <test_kmalloc+0x8e9>
f011755a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011755d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117564:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117567:	01 d0                	add    %edx,%eax
f0117569:	66 8b 40 02          	mov    0x2(%eax),%ax
f011756d:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117571:	74 17                	je     f011758a <test_kmalloc+0x900>
f0117573:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011757a:	83 ec 0c             	sub    $0xc,%esp
f011757d:	68 00 ba 12 f0       	push   $0xf012ba00
f0117582:	e8 04 9a fe ff       	call   f0100f8b <cprintf>
f0117587:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f011758a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011758d:	8b 40 04             	mov    0x4(%eax),%eax
f0117590:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0117593:	75 17                	jne    f01175ac <test_kmalloc+0x922>
f0117595:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117598:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011759f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175a2:	01 d0                	add    %edx,%eax
f01175a4:	8b 40 04             	mov    0x4(%eax),%eax
f01175a7:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01175aa:	74 17                	je     f01175c3 <test_kmalloc+0x939>
f01175ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175b3:	83 ec 0c             	sub    $0xc,%esp
f01175b6:	68 3c ba 12 f0       	push   $0xf012ba3c
f01175bb:	e8 cb 99 fe ff       	call   f0100f8b <cprintf>
f01175c0:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01175c3:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01175c6:	8a 00                	mov    (%eax),%al
f01175c8:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01175cb:	75 34                	jne    f0117601 <test_kmalloc+0x977>
f01175cd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01175d0:	89 c2                	mov    %eax,%edx
f01175d2:	c1 ea 1f             	shr    $0x1f,%edx
f01175d5:	01 d0                	add    %edx,%eax
f01175d7:	d1 f8                	sar    %eax
f01175d9:	89 c2                	mov    %eax,%edx
f01175db:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01175de:	01 d0                	add    %edx,%eax
f01175e0:	8a 10                	mov    (%eax),%dl
f01175e2:	8a 45 ea             	mov    -0x16(%ebp),%al
f01175e5:	88 c1                	mov    %al,%cl
f01175e7:	c0 e9 07             	shr    $0x7,%cl
f01175ea:	01 c8                	add    %ecx,%eax
f01175ec:	d0 f8                	sar    %al
f01175ee:	38 c2                	cmp    %al,%dl
f01175f0:	75 0f                	jne    f0117601 <test_kmalloc+0x977>
f01175f2:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01175f5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01175f8:	01 d0                	add    %edx,%eax
f01175fa:	8a 00                	mov    (%eax),%al
f01175fc:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01175ff:	74 17                	je     f0117618 <test_kmalloc+0x98e>
f0117601:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117608:	83 ec 0c             	sub    $0xc,%esp
f011760b:	68 78 ba 12 f0       	push   $0xf012ba78
f0117610:	e8 76 99 fe ff       	call   f0100f8b <cprintf>
f0117615:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f0117618:	8b 45 98             	mov    -0x68(%ebp),%eax
f011761b:	66 8b 00             	mov    (%eax),%ax
f011761e:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117622:	75 15                	jne    f0117639 <test_kmalloc+0x9af>
f0117624:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117627:	01 c0                	add    %eax,%eax
f0117629:	89 c2                	mov    %eax,%edx
f011762b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011762e:	01 d0                	add    %edx,%eax
f0117630:	66 8b 00             	mov    (%eax),%ax
f0117633:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117637:	74 17                	je     f0117650 <test_kmalloc+0x9c6>
f0117639:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117640:	83 ec 0c             	sub    $0xc,%esp
f0117643:	68 b0 ba 12 f0       	push   $0xf012bab0
f0117648:	e8 3e 99 fe ff       	call   f0100f8b <cprintf>
f011764d:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117650:	e8 ad 72 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117655:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117658:	74 17                	je     f0117671 <test_kmalloc+0x9e7>
f011765a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117661:	83 ec 0c             	sub    $0xc,%esp
f0117664:	68 ec ba 12 f0       	push   $0xf012baec
f0117669:	e8 1d 99 fe ff       	call   f0100f8b <cprintf>
f011766e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117671:	e8 2f d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117676:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117679:	74 17                	je     f0117692 <test_kmalloc+0xa08>
f011767b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117682:	83 ec 0c             	sub    $0xc,%esp
f0117685:	68 30 bb 12 f0       	push   $0xf012bb30
f011768a:	e8 fc 98 fe ff       	call   f0100f8b <cprintf>
f011768f:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0117692:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117696:	74 04                	je     f011769c <test_kmalloc+0xa12>
f0117698:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f011769c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f01176a3:	83 ec 0c             	sub    $0xc,%esp
f01176a6:	68 9c bb 12 f0       	push   $0xf012bb9c
f01176ab:	e8 db 98 fe ff       	call   f0100f8b <cprintf>
f01176b0:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01176b3:	e8 4a 72 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01176b8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176bb:	e8 e5 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176c0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f01176c3:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f01176ca:	8b 45 90             	mov    -0x70(%ebp),%eax
f01176cd:	40                   	inc    %eax
f01176ce:	83 ec 0c             	sub    $0xc,%esp
f01176d1:	50                   	push   %eax
f01176d2:	e8 53 1e ff ff       	call   f010952a <kmalloc>
f01176d7:	83 c4 10             	add    $0x10,%esp
f01176da:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f01176e0:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f01176e6:	85 c0                	test   %eax,%eax
f01176e8:	74 17                	je     f0117701 <test_kmalloc+0xa77>
f01176ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176f1:	83 ec 0c             	sub    $0xc,%esp
f01176f4:	68 c0 bb 12 f0       	push   $0xf012bbc0
f01176f9:	e8 8d 98 fe ff       	call   f0100f8b <cprintf>
f01176fe:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117701:	e8 9f d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117706:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117709:	74 17                	je     f0117722 <test_kmalloc+0xa98>
f011770b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117712:	83 ec 0c             	sub    $0xc,%esp
f0117715:	68 f8 bb 12 f0       	push   $0xf012bbf8
f011771a:	e8 6c 98 fe ff       	call   f0100f8b <cprintf>
f011771f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117722:	e8 db 71 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117727:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011772a:	74 17                	je     f0117743 <test_kmalloc+0xab9>
f011772c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117733:	83 ec 0c             	sub    $0xc,%esp
f0117736:	68 64 bc 12 f0       	push   $0xf012bc64
f011773b:	e8 4b 98 fe ff       	call   f0100f8b <cprintf>
f0117740:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117743:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117747:	74 04                	je     f011774d <test_kmalloc+0xac3>
f0117749:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011774d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0117754:	83 ec 0c             	sub    $0xc,%esp
f0117757:	68 a8 bc 12 f0       	push   $0xf012bca8
f011775c:	e8 2a 98 fe ff       	call   f0100f8b <cprintf>
f0117761:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0117764:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011776a:	05 00 40 00 00       	add    $0x4000,%eax
f011776f:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117772:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117779:	eb 6a                	jmp    f01177e5 <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f011777b:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f0117780:	83 ec 04             	sub    $0x4,%esp
f0117783:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117789:	52                   	push   %edx
f011778a:	ff 75 ec             	pushl  -0x14(%ebp)
f011778d:	50                   	push   %eax
f011778e:	e8 5c 0c ff ff       	call   f01083ef <get_page_table>
f0117793:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117796:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011779c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011779f:	c1 ea 0c             	shr    $0xc,%edx
f01177a2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01177a8:	c1 e2 02             	shl    $0x2,%edx
f01177ab:	01 d0                	add    %edx,%eax
f01177ad:	8b 00                	mov    (%eax),%eax
f01177af:	25 ff 0f 00 00       	and    $0xfff,%eax
f01177b4:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f01177b7:	8b 45 88             	mov    -0x78(%ebp),%eax
f01177ba:	83 e0 04             	and    $0x4,%eax
f01177bd:	85 c0                	test   %eax,%eax
f01177bf:	74 1d                	je     f01177de <test_kmalloc+0xb54>
			{
				if (correct)
f01177c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01177c5:	74 17                	je     f01177de <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f01177c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177ce:	83 ec 0c             	sub    $0xc,%esp
f01177d1:	68 ec bc 12 f0       	push   $0xf012bcec
f01177d6:	e8 b0 97 fe ff       	call   f0100f8b <cprintf>
f01177db:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01177de:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f01177e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01177e8:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01177eb:	72 8e                	jb     f011777b <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f01177ed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01177f1:	74 04                	je     f01177f7 <test_kmalloc+0xb6d>
f01177f3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f01177f7:	83 ec 08             	sub    $0x8,%esp
f01177fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01177fd:	68 3c bd 12 f0       	push   $0xf012bd3c
f0117802:	e8 84 97 fe ff       	call   f0100f8b <cprintf>
f0117807:	83 c4 10             	add    $0x10,%esp

	return 1;
f011780a:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011780f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117812:	5b                   	pop    %ebx
f0117813:	5f                   	pop    %edi
f0117814:	5d                   	pop    %ebp
f0117815:	c3                   	ret    

f0117816 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0117816:	55                   	push   %ebp
f0117817:	89 e5                	mov    %esp,%ebp
f0117819:	57                   	push   %edi
f011781a:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011781d:	83 ec 0c             	sub    $0xc,%esp
f0117820:	68 a8 ae 12 f0       	push   $0xf012aea8
f0117825:	e8 61 97 fe ff       	call   f0100f8b <cprintf>
f011782a:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011782d:	83 ec 0c             	sub    $0xc,%esp
f0117830:	68 d8 ae 12 f0       	push   $0xf012aed8
f0117835:	e8 51 97 fe ff       	call   f0100f8b <cprintf>
f011783a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011783d:	83 ec 0c             	sub    $0xc,%esp
f0117840:	68 a8 ae 12 f0       	push   $0xf012aea8
f0117845:	e8 41 97 fe ff       	call   f0100f8b <cprintf>
f011784a:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011784d:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117850:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117855:	b8 00 00 00 00       	mov    $0x0,%eax
f011785a:	89 d7                	mov    %edx,%edi
f011785c:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f011785e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117865:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011786c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f0117873:	83 ec 0c             	sub    $0xc,%esp
f0117876:	68 68 bd 12 f0       	push   $0xf012bd68
f011787b:	e8 0b 97 fe ff       	call   f0100f8b <cprintf>
f0117880:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117883:	e8 7a 70 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117888:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011788b:	e8 15 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117890:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0117893:	83 ec 0c             	sub    $0xc,%esp
f0117896:	68 00 fc 0f 00       	push   $0xffc00
f011789b:	e8 8a 1c ff ff       	call   f010952a <kmalloc>
f01178a0:	83 c4 10             	add    $0x10,%esp
f01178a3:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f01178a6:	8b 45 98             	mov    -0x68(%ebp),%eax
f01178a9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01178ae:	74 17                	je     f01178c7 <test_kmalloc_firstfit1+0xb1>
f01178b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178b7:	83 ec 0c             	sub    $0xc,%esp
f01178ba:	68 a8 bd 12 f0       	push   $0xf012bda8
f01178bf:	e8 c7 96 fe ff       	call   f0100f8b <cprintf>
f01178c4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01178c7:	e8 d9 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178cc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01178cf:	74 17                	je     f01178e8 <test_kmalloc_firstfit1+0xd2>
f01178d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178d8:	83 ec 0c             	sub    $0xc,%esp
f01178db:	68 cc b0 12 f0       	push   $0xf012b0cc
f01178e0:	e8 a6 96 fe ff       	call   f0100f8b <cprintf>
f01178e5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f01178e8:	e8 15 70 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01178ed:	89 c2                	mov    %eax,%edx
f01178ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01178f2:	29 d0                	sub    %edx,%eax
f01178f4:	3d ff 00 00 00       	cmp    $0xff,%eax
f01178f9:	7f 17                	jg     f0117912 <test_kmalloc_firstfit1+0xfc>
f01178fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117902:	83 ec 0c             	sub    $0xc,%esp
f0117905:	68 db bd 12 f0       	push   $0xf012bddb
f011790a:	e8 7c 96 fe ff       	call   f0100f8b <cprintf>
f011790f:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117912:	e8 eb 6f ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117917:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011791a:	e8 86 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011791f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0117922:	83 ec 0c             	sub    $0xc,%esp
f0117925:	68 00 fc 0f 00       	push   $0xffc00
f011792a:	e8 fb 1b ff ff       	call   f010952a <kmalloc>
f011792f:	83 c4 10             	add    $0x10,%esp
f0117932:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117935:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117938:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011793d:	74 17                	je     f0117956 <test_kmalloc_firstfit1+0x140>
f011793f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117946:	83 ec 0c             	sub    $0xc,%esp
f0117949:	68 f4 bd 12 f0       	push   $0xf012bdf4
f011794e:	e8 38 96 fe ff       	call   f0100f8b <cprintf>
f0117953:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117956:	e8 4a cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011795b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011795e:	74 17                	je     f0117977 <test_kmalloc_firstfit1+0x161>
f0117960:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117967:	83 ec 0c             	sub    $0xc,%esp
f011796a:	68 d0 b1 12 f0       	push   $0xf012b1d0
f011796f:	e8 17 96 fe ff       	call   f0100f8b <cprintf>
f0117974:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117977:	e8 86 6f ff ff       	call   f010e902 <sys_calculate_free_frames>
f011797c:	89 c2                	mov    %eax,%edx
f011797e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117981:	29 d0                	sub    %edx,%eax
f0117983:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117988:	7f 17                	jg     f01179a1 <test_kmalloc_firstfit1+0x18b>
f011798a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117991:	83 ec 0c             	sub    $0xc,%esp
f0117994:	68 27 be 12 f0       	push   $0xf012be27
f0117999:	e8 ed 95 fe ff       	call   f0100f8b <cprintf>
f011799e:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01179a1:	e8 5c 6f ff ff       	call   f010e902 <sys_calculate_free_frames>
f01179a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179a9:	e8 f7 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f01179b1:	83 ec 0c             	sub    $0xc,%esp
f01179b4:	68 00 fc 0f 00       	push   $0xffc00
f01179b9:	e8 6c 1b ff ff       	call   f010952a <kmalloc>
f01179be:	83 c4 10             	add    $0x10,%esp
f01179c1:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01179c4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01179c7:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01179cc:	74 17                	je     f01179e5 <test_kmalloc_firstfit1+0x1cf>
f01179ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179d5:	83 ec 0c             	sub    $0xc,%esp
f01179d8:	68 40 be 12 f0       	push   $0xf012be40
f01179dd:	e8 a9 95 fe ff       	call   f0100f8b <cprintf>
f01179e2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179e5:	e8 bb ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179ea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01179ed:	74 17                	je     f0117a06 <test_kmalloc_firstfit1+0x1f0>
f01179ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179f6:	83 ec 0c             	sub    $0xc,%esp
f01179f9:	68 0c b3 12 f0       	push   $0xf012b30c
f01179fe:	e8 88 95 fe ff       	call   f0100f8b <cprintf>
f0117a03:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117a06:	e8 f7 6e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117a0b:	89 c2                	mov    %eax,%edx
f0117a0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a10:	29 d0                	sub    %edx,%eax
f0117a12:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117a17:	7f 17                	jg     f0117a30 <test_kmalloc_firstfit1+0x21a>
f0117a19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a20:	83 ec 0c             	sub    $0xc,%esp
f0117a23:	68 73 be 12 f0       	push   $0xf012be73
f0117a28:	e8 5e 95 fe ff       	call   f0100f8b <cprintf>
f0117a2d:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a30:	e8 cd 6e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117a35:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a38:	e8 68 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a3d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0117a40:	83 ec 0c             	sub    $0xc,%esp
f0117a43:	68 00 fc 0f 00       	push   $0xffc00
f0117a48:	e8 dd 1a ff ff       	call   f010952a <kmalloc>
f0117a4d:	83 c4 10             	add    $0x10,%esp
f0117a50:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117a53:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117a56:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117a5b:	74 17                	je     f0117a74 <test_kmalloc_firstfit1+0x25e>
f0117a5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a64:	83 ec 0c             	sub    $0xc,%esp
f0117a67:	68 8c be 12 f0       	push   $0xf012be8c
f0117a6c:	e8 1a 95 fe ff       	call   f0100f8b <cprintf>
f0117a71:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a74:	e8 2c ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a7c:	74 17                	je     f0117a95 <test_kmalloc_firstfit1+0x27f>
f0117a7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a85:	83 ec 0c             	sub    $0xc,%esp
f0117a88:	68 04 b4 12 f0       	push   $0xf012b404
f0117a8d:	e8 f9 94 fe ff       	call   f0100f8b <cprintf>
f0117a92:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117a95:	e8 68 6e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117a9a:	89 c2                	mov    %eax,%edx
f0117a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a9f:	29 d0                	sub    %edx,%eax
f0117aa1:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117aa6:	7f 17                	jg     f0117abf <test_kmalloc_firstfit1+0x2a9>
f0117aa8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aaf:	83 ec 0c             	sub    $0xc,%esp
f0117ab2:	68 bf be 12 f0       	push   $0xf012bebf
f0117ab7:	e8 cf 94 fe ff       	call   f0100f8b <cprintf>
f0117abc:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117abf:	e8 3e 6e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117ac4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117ac7:	e8 d9 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117acc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117acf:	83 ec 0c             	sub    $0xc,%esp
f0117ad2:	68 00 fc 1f 00       	push   $0x1ffc00
f0117ad7:	e8 4e 1a ff ff       	call   f010952a <kmalloc>
f0117adc:	83 c4 10             	add    $0x10,%esp
f0117adf:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117ae2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117ae5:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117aea:	74 17                	je     f0117b03 <test_kmalloc_firstfit1+0x2ed>
f0117aec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117af3:	83 ec 0c             	sub    $0xc,%esp
f0117af6:	68 d8 be 12 f0       	push   $0xf012bed8
f0117afb:	e8 8b 94 fe ff       	call   f0100f8b <cprintf>
f0117b00:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b03:	e8 9d cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b08:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b0b:	74 17                	je     f0117b24 <test_kmalloc_firstfit1+0x30e>
f0117b0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b14:	83 ec 0c             	sub    $0xc,%esp
f0117b17:	68 e4 b4 12 f0       	push   $0xf012b4e4
f0117b1c:	e8 6a 94 fe ff       	call   f0100f8b <cprintf>
f0117b21:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117b24:	e8 d9 6d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117b29:	89 c2                	mov    %eax,%edx
f0117b2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b2e:	29 d0                	sub    %edx,%eax
f0117b30:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117b35:	7f 17                	jg     f0117b4e <test_kmalloc_firstfit1+0x338>
f0117b37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b3e:	83 ec 0c             	sub    $0xc,%esp
f0117b41:	68 0b bf 12 f0       	push   $0xf012bf0b
f0117b46:	e8 40 94 fe ff       	call   f0100f8b <cprintf>
f0117b4b:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b4e:	e8 af 6d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117b53:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b56:	e8 4a cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117b5e:	83 ec 0c             	sub    $0xc,%esp
f0117b61:	68 00 fc 1f 00       	push   $0x1ffc00
f0117b66:	e8 bf 19 ff ff       	call   f010952a <kmalloc>
f0117b6b:	83 c4 10             	add    $0x10,%esp
f0117b6e:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117b71:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117b74:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117b79:	74 17                	je     f0117b92 <test_kmalloc_firstfit1+0x37c>
f0117b7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b82:	83 ec 0c             	sub    $0xc,%esp
f0117b85:	68 24 bf 12 f0       	push   $0xf012bf24
f0117b8a:	e8 fc 93 fe ff       	call   f0100f8b <cprintf>
f0117b8f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b92:	e8 0e cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b97:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b9a:	74 17                	je     f0117bb3 <test_kmalloc_firstfit1+0x39d>
f0117b9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ba3:	83 ec 0c             	sub    $0xc,%esp
f0117ba6:	68 e8 b5 12 f0       	push   $0xf012b5e8
f0117bab:	e8 db 93 fe ff       	call   f0100f8b <cprintf>
f0117bb0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117bb3:	e8 4a 6d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117bb8:	89 c2                	mov    %eax,%edx
f0117bba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117bbd:	29 d0                	sub    %edx,%eax
f0117bbf:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117bc4:	7f 17                	jg     f0117bdd <test_kmalloc_firstfit1+0x3c7>
f0117bc6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bcd:	83 ec 0c             	sub    $0xc,%esp
f0117bd0:	68 57 bf 12 f0       	push   $0xf012bf57
f0117bd5:	e8 b1 93 fe ff       	call   f0100f8b <cprintf>
f0117bda:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117bdd:	e8 20 6d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117be2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117be5:	e8 bb cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bea:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117bed:	83 ec 0c             	sub    $0xc,%esp
f0117bf0:	68 00 fc 2f 00       	push   $0x2ffc00
f0117bf5:	e8 30 19 ff ff       	call   f010952a <kmalloc>
f0117bfa:	83 c4 10             	add    $0x10,%esp
f0117bfd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117c00:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117c03:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117c08:	74 17                	je     f0117c21 <test_kmalloc_firstfit1+0x40b>
f0117c0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c11:	83 ec 0c             	sub    $0xc,%esp
f0117c14:	68 70 bf 12 f0       	push   $0xf012bf70
f0117c19:	e8 6d 93 fe ff       	call   f0100f8b <cprintf>
f0117c1e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c21:	e8 7f cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c26:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c29:	74 17                	je     f0117c42 <test_kmalloc_firstfit1+0x42c>
f0117c2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c32:	83 ec 0c             	sub    $0xc,%esp
f0117c35:	68 ec b6 12 f0       	push   $0xf012b6ec
f0117c3a:	e8 4c 93 fe ff       	call   f0100f8b <cprintf>
f0117c3f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117c42:	e8 bb 6c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117c47:	89 c2                	mov    %eax,%edx
f0117c49:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c4c:	29 d0                	sub    %edx,%eax
f0117c4e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117c53:	7f 17                	jg     f0117c6c <test_kmalloc_firstfit1+0x456>
f0117c55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c5c:	83 ec 0c             	sub    $0xc,%esp
f0117c5f:	68 a3 bf 12 f0       	push   $0xf012bfa3
f0117c64:	e8 22 93 fe ff       	call   f0100f8b <cprintf>
f0117c69:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c6c:	e8 91 6c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117c71:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c74:	e8 2c cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c79:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117c7c:	83 ec 0c             	sub    $0xc,%esp
f0117c7f:	68 00 fc 2f 00       	push   $0x2ffc00
f0117c84:	e8 a1 18 ff ff       	call   f010952a <kmalloc>
f0117c89:	83 c4 10             	add    $0x10,%esp
f0117c8c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117c8f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117c92:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117c97:	74 17                	je     f0117cb0 <test_kmalloc_firstfit1+0x49a>
f0117c99:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ca0:	83 ec 0c             	sub    $0xc,%esp
f0117ca3:	68 bc bf 12 f0       	push   $0xf012bfbc
f0117ca8:	e8 de 92 fe ff       	call   f0100f8b <cprintf>
f0117cad:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117cb0:	e8 f0 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117cb5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117cb8:	74 17                	je     f0117cd1 <test_kmalloc_firstfit1+0x4bb>
f0117cba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cc1:	83 ec 0c             	sub    $0xc,%esp
f0117cc4:	68 f0 b7 12 f0       	push   $0xf012b7f0
f0117cc9:	e8 bd 92 fe ff       	call   f0100f8b <cprintf>
f0117cce:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0117cd1:	e8 2c 6c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117cd6:	89 c2                	mov    %eax,%edx
f0117cd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117cdb:	29 d0                	sub    %edx,%eax
f0117cdd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117ce2:	7f 17                	jg     f0117cfb <test_kmalloc_firstfit1+0x4e5>
f0117ce4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ceb:	83 ec 0c             	sub    $0xc,%esp
f0117cee:	68 ef bf 12 f0       	push   $0xf012bfef
f0117cf3:	e8 93 92 fe ff       	call   f0100f8b <cprintf>
f0117cf8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117cfb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117cff:	74 04                	je     f0117d05 <test_kmalloc_firstfit1+0x4ef>
f0117d01:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117d05:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0117d0c:	83 ec 0c             	sub    $0xc,%esp
f0117d0f:	68 08 c0 12 f0       	push   $0xf012c008
f0117d14:	e8 72 92 fe ff       	call   f0100f8b <cprintf>
f0117d19:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d1c:	e8 e1 6b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117d21:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d24:	e8 7c cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d29:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117d2c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117d2f:	83 ec 0c             	sub    $0xc,%esp
f0117d32:	50                   	push   %eax
f0117d33:	e8 52 1a ff ff       	call   f010978a <kfree>
f0117d38:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d3b:	e8 65 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d40:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d43:	74 17                	je     f0117d5c <test_kmalloc_firstfit1+0x546>
f0117d45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d4c:	83 ec 0c             	sub    $0xc,%esp
f0117d4f:	68 30 c0 12 f0       	push   $0xf012c030
f0117d54:	e8 32 92 fe ff       	call   f0100f8b <cprintf>
f0117d59:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117d5c:	e8 a1 6b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117d61:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117d64:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117d69:	7f 17                	jg     f0117d82 <test_kmalloc_firstfit1+0x56c>
f0117d6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d72:	83 ec 0c             	sub    $0xc,%esp
f0117d75:	68 9b c0 12 f0       	push   $0xf012c09b
f0117d7a:	e8 0c 92 fe ff       	call   f0100f8b <cprintf>
f0117d7f:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d82:	e8 7b 6b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117d87:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d8a:	e8 16 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0117d92:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117d95:	83 ec 0c             	sub    $0xc,%esp
f0117d98:	50                   	push   %eax
f0117d99:	e8 ec 19 ff ff       	call   f010978a <kfree>
f0117d9e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117da1:	e8 ff ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117da6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117da9:	74 17                	je     f0117dc2 <test_kmalloc_firstfit1+0x5ac>
f0117dab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117db2:	83 ec 0c             	sub    $0xc,%esp
f0117db5:	68 ac c0 12 f0       	push   $0xf012c0ac
f0117dba:	e8 cc 91 fe ff       	call   f0100f8b <cprintf>
f0117dbf:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0117dc2:	e8 3b 6b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117dc7:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117dca:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117dcf:	7f 17                	jg     f0117de8 <test_kmalloc_firstfit1+0x5d2>
f0117dd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dd8:	83 ec 0c             	sub    $0xc,%esp
f0117ddb:	68 18 c1 12 f0       	push   $0xf012c118
f0117de0:	e8 a6 91 fe ff       	call   f0100f8b <cprintf>
f0117de5:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117de8:	e8 15 6b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117ded:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117df0:	e8 b0 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117df5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0117df8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117dfb:	83 ec 0c             	sub    $0xc,%esp
f0117dfe:	50                   	push   %eax
f0117dff:	e8 86 19 ff ff       	call   f010978a <kfree>
f0117e04:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e07:	e8 99 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e0c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e0f:	74 17                	je     f0117e28 <test_kmalloc_firstfit1+0x612>
f0117e11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e18:	83 ec 0c             	sub    $0xc,%esp
f0117e1b:	68 2c c1 12 f0       	push   $0xf012c12c
f0117e20:	e8 66 91 fe ff       	call   f0100f8b <cprintf>
f0117e25:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0117e28:	e8 d5 6a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117e2d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117e30:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117e35:	7f 17                	jg     f0117e4e <test_kmalloc_firstfit1+0x638>
f0117e37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e3e:	83 ec 0c             	sub    $0xc,%esp
f0117e41:	68 98 c1 12 f0       	push   $0xf012c198
f0117e46:	e8 40 91 fe ff       	call   f0100f8b <cprintf>
f0117e4b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117e4e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117e52:	74 04                	je     f0117e58 <test_kmalloc_firstfit1+0x642>
f0117e54:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117e58:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0117e5f:	83 ec 0c             	sub    $0xc,%esp
f0117e62:	68 ac c1 12 f0       	push   $0xf012c1ac
f0117e67:	e8 1f 91 fe ff       	call   f0100f8b <cprintf>
f0117e6c:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e6f:	e8 8e 6a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117e74:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e77:	e8 29 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0117e7f:	83 ec 0c             	sub    $0xc,%esp
f0117e82:	68 00 fc 07 00       	push   $0x7fc00
f0117e87:	e8 9e 16 ff ff       	call   f010952a <kmalloc>
f0117e8c:	83 c4 10             	add    $0x10,%esp
f0117e8f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0117e92:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117e95:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117e9a:	74 17                	je     f0117eb3 <test_kmalloc_firstfit1+0x69d>
f0117e9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ea3:	83 ec 0c             	sub    $0xc,%esp
f0117ea6:	68 d8 c1 12 f0       	push   $0xf012c1d8
f0117eab:	e8 db 90 fe ff       	call   f0100f8b <cprintf>
f0117eb0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117eb3:	e8 ed c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117eb8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ebb:	74 17                	je     f0117ed4 <test_kmalloc_firstfit1+0x6be>
f0117ebd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ec4:	83 ec 0c             	sub    $0xc,%esp
f0117ec7:	68 0c c2 12 f0       	push   $0xf012c20c
f0117ecc:	e8 ba 90 fe ff       	call   f0100f8b <cprintf>
f0117ed1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0117ed4:	e8 29 6a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117ed9:	89 c2                	mov    %eax,%edx
f0117edb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ede:	29 d0                	sub    %edx,%eax
f0117ee0:	83 f8 7f             	cmp    $0x7f,%eax
f0117ee3:	7f 17                	jg     f0117efc <test_kmalloc_firstfit1+0x6e6>
f0117ee5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117eec:	83 ec 0c             	sub    $0xc,%esp
f0117eef:	68 78 c2 12 f0       	push   $0xf012c278
f0117ef4:	e8 92 90 fe ff       	call   f0100f8b <cprintf>
f0117ef9:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117efc:	e8 01 6a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117f01:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f04:	e8 9c c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f09:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0117f0c:	83 ec 0c             	sub    $0xc,%esp
f0117f0f:	68 00 fc 0f 00       	push   $0xffc00
f0117f14:	e8 11 16 ff ff       	call   f010952a <kmalloc>
f0117f19:	83 c4 10             	add    $0x10,%esp
f0117f1c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0117f1f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117f22:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117f27:	74 17                	je     f0117f40 <test_kmalloc_firstfit1+0x72a>
f0117f29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f30:	83 ec 0c             	sub    $0xc,%esp
f0117f33:	68 90 c2 12 f0       	push   $0xf012c290
f0117f38:	e8 4e 90 fe ff       	call   f0100f8b <cprintf>
f0117f3d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f40:	e8 60 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f45:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f48:	74 17                	je     f0117f61 <test_kmalloc_firstfit1+0x74b>
f0117f4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f51:	83 ec 0c             	sub    $0xc,%esp
f0117f54:	68 c4 c2 12 f0       	push   $0xf012c2c4
f0117f59:	e8 2d 90 fe ff       	call   f0100f8b <cprintf>
f0117f5e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0117f61:	e8 9c 69 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117f66:	89 c2                	mov    %eax,%edx
f0117f68:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f6b:	29 d0                	sub    %edx,%eax
f0117f6d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117f72:	7f 17                	jg     f0117f8b <test_kmalloc_firstfit1+0x775>
f0117f74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f7b:	83 ec 0c             	sub    $0xc,%esp
f0117f7e:	68 30 c3 12 f0       	push   $0xf012c330
f0117f83:	e8 03 90 fe ff       	call   f0100f8b <cprintf>
f0117f88:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f8b:	e8 72 69 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117f90:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f93:	e8 0d c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f98:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0117f9b:	83 ec 0c             	sub    $0xc,%esp
f0117f9e:	68 00 fc 03 00       	push   $0x3fc00
f0117fa3:	e8 82 15 ff ff       	call   f010952a <kmalloc>
f0117fa8:	83 c4 10             	add    $0x10,%esp
f0117fab:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0117fae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117fb1:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0117fb6:	74 17                	je     f0117fcf <test_kmalloc_firstfit1+0x7b9>
f0117fb8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fbf:	83 ec 0c             	sub    $0xc,%esp
f0117fc2:	68 48 c3 12 f0       	push   $0xf012c348
f0117fc7:	e8 bf 8f fe ff       	call   f0100f8b <cprintf>
f0117fcc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117fcf:	e8 d1 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fd4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fd7:	74 17                	je     f0117ff0 <test_kmalloc_firstfit1+0x7da>
f0117fd9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fe0:	83 ec 0c             	sub    $0xc,%esp
f0117fe3:	68 7c c3 12 f0       	push   $0xf012c37c
f0117fe8:	e8 9e 8f fe ff       	call   f0100f8b <cprintf>
f0117fed:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0117ff0:	e8 0d 69 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0117ff5:	89 c2                	mov    %eax,%edx
f0117ff7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ffa:	29 d0                	sub    %edx,%eax
f0117ffc:	83 f8 3f             	cmp    $0x3f,%eax
f0117fff:	7f 17                	jg     f0118018 <test_kmalloc_firstfit1+0x802>
f0118001:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118008:	83 ec 0c             	sub    $0xc,%esp
f011800b:	68 e8 c3 12 f0       	push   $0xf012c3e8
f0118010:	e8 76 8f fe ff       	call   f0100f8b <cprintf>
f0118015:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118018:	e8 e5 68 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011801d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118020:	e8 80 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118025:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0118028:	83 ec 0c             	sub    $0xc,%esp
f011802b:	68 00 00 20 00       	push   $0x200000
f0118030:	e8 f5 14 ff ff       	call   f010952a <kmalloc>
f0118035:	83 c4 10             	add    $0x10,%esp
f0118038:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f011803b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011803e:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0118043:	74 17                	je     f011805c <test_kmalloc_firstfit1+0x846>
f0118045:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011804c:	83 ec 0c             	sub    $0xc,%esp
f011804f:	68 00 c4 12 f0       	push   $0xf012c400
f0118054:	e8 32 8f fe ff       	call   f0100f8b <cprintf>
f0118059:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f011805c:	e8 a1 68 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118061:	89 c2                	mov    %eax,%edx
f0118063:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118066:	29 d0                	sub    %edx,%eax
f0118068:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011806d:	7f 17                	jg     f0118086 <test_kmalloc_firstfit1+0x870>
f011806f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118076:	83 ec 0c             	sub    $0xc,%esp
f0118079:	68 34 c4 12 f0       	push   $0xf012c434
f011807e:	e8 08 8f fe ff       	call   f0100f8b <cprintf>
f0118083:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118086:	e8 1a c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011808b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011808e:	74 17                	je     f01180a7 <test_kmalloc_firstfit1+0x891>
f0118090:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118097:	83 ec 0c             	sub    $0xc,%esp
f011809a:	68 4c c4 12 f0       	push   $0xf012c44c
f011809f:	e8 e7 8e fe ff       	call   f0100f8b <cprintf>
f01180a4:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f01180a7:	e8 56 68 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01180ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01180af:	e8 f1 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f01180b7:	83 ec 0c             	sub    $0xc,%esp
f01180ba:	68 00 fc 3f 00       	push   $0x3ffc00
f01180bf:	e8 66 14 ff ff       	call   f010952a <kmalloc>
f01180c4:	83 c4 10             	add    $0x10,%esp
f01180c7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f01180ca:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01180cd:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f01180d2:	74 17                	je     f01180eb <test_kmalloc_firstfit1+0x8d5>
f01180d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180db:	83 ec 0c             	sub    $0xc,%esp
f01180de:	68 b8 c4 12 f0       	push   $0xf012c4b8
f01180e3:	e8 a3 8e fe ff       	call   f0100f8b <cprintf>
f01180e8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180eb:	e8 b5 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180f3:	74 17                	je     f011810c <test_kmalloc_firstfit1+0x8f6>
f01180f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180fc:	83 ec 0c             	sub    $0xc,%esp
f01180ff:	68 ec c4 12 f0       	push   $0xf012c4ec
f0118104:	e8 82 8e fe ff       	call   f0100f8b <cprintf>
f0118109:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f011810c:	e8 f1 67 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118111:	89 c2                	mov    %eax,%edx
f0118113:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118116:	29 d0                	sub    %edx,%eax
f0118118:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f011811d:	7f 17                	jg     f0118136 <test_kmalloc_firstfit1+0x920>
f011811f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118126:	83 ec 0c             	sub    $0xc,%esp
f0118129:	68 58 c5 12 f0       	push   $0xf012c558
f011812e:	e8 58 8e fe ff       	call   f0100f8b <cprintf>
f0118133:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0118136:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011813a:	74 04                	je     f0118140 <test_kmalloc_firstfit1+0x92a>
f011813c:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0118140:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0118147:	83 ec 0c             	sub    $0xc,%esp
f011814a:	68 70 c5 12 f0       	push   $0xf012c570
f011814f:	e8 37 8e fe ff       	call   f0100f8b <cprintf>
f0118154:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118157:	e8 a6 67 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011815c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011815f:	e8 41 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118164:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0118167:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011816a:	83 ec 0c             	sub    $0xc,%esp
f011816d:	50                   	push   %eax
f011816e:	e8 17 16 ff ff       	call   f010978a <kfree>
f0118173:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118176:	e8 2a c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011817b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011817e:	74 17                	je     f0118197 <test_kmalloc_firstfit1+0x981>
f0118180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118187:	83 ec 0c             	sub    $0xc,%esp
f011818a:	68 30 bb 12 f0       	push   $0xf012bb30
f011818f:	e8 f7 8d fe ff       	call   f0100f8b <cprintf>
f0118194:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0118197:	e8 66 67 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011819c:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011819f:	3d ff 00 00 00       	cmp    $0xff,%eax
f01181a4:	7f 17                	jg     f01181bd <test_kmalloc_firstfit1+0x9a7>
f01181a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181ad:	83 ec 0c             	sub    $0xc,%esp
f01181b0:	68 a4 c5 12 f0       	push   $0xf012c5a4
f01181b5:	e8 d1 8d fe ff       	call   f0100f8b <cprintf>
f01181ba:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f01181bd:	e8 40 67 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01181c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181c5:	e8 db c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f01181cd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01181d0:	83 ec 0c             	sub    $0xc,%esp
f01181d3:	50                   	push   %eax
f01181d4:	e8 b1 15 ff ff       	call   f010978a <kfree>
f01181d9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181dc:	e8 c4 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181e1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181e4:	74 17                	je     f01181fd <test_kmalloc_firstfit1+0x9e7>
f01181e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181ed:	83 ec 0c             	sub    $0xc,%esp
f01181f0:	68 f8 bb 12 f0       	push   $0xf012bbf8
f01181f5:	e8 91 8d fe ff       	call   f0100f8b <cprintf>
f01181fa:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f01181fd:	e8 00 67 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118202:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118205:	3d ff 00 00 00       	cmp    $0xff,%eax
f011820a:	7f 17                	jg     f0118223 <test_kmalloc_firstfit1+0xa0d>
f011820c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118213:	83 ec 0c             	sub    $0xc,%esp
f0118216:	68 b5 c5 12 f0       	push   $0xf012c5b5
f011821b:	e8 6b 8d fe ff       	call   f0100f8b <cprintf>
f0118220:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118223:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118227:	74 04                	je     f011822d <test_kmalloc_firstfit1+0xa17>
f0118229:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011822d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0118234:	83 ec 0c             	sub    $0xc,%esp
f0118237:	68 c8 c5 12 f0       	push   $0xf012c5c8
f011823c:	e8 4a 8d fe ff       	call   f0100f8b <cprintf>
f0118241:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0118244:	e8 b9 66 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118249:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011824c:	e8 54 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118251:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0118254:	83 ec 0c             	sub    $0xc,%esp
f0118257:	68 00 00 10 00       	push   $0x100000
f011825c:	e8 c9 12 ff ff       	call   f010952a <kmalloc>
f0118261:	83 c4 10             	add    $0x10,%esp
f0118264:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118267:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011826a:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f011826f:	74 17                	je     f0118288 <test_kmalloc_firstfit1+0xa72>
f0118271:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118278:	83 ec 0c             	sub    $0xc,%esp
f011827b:	68 08 c6 12 f0       	push   $0xf012c608
f0118280:	e8 06 8d fe ff       	call   f0100f8b <cprintf>
f0118285:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118288:	e8 18 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011828d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118290:	74 17                	je     f01182a9 <test_kmalloc_firstfit1+0xa93>
f0118292:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118299:	83 ec 0c             	sub    $0xc,%esp
f011829c:	68 3c c6 12 f0       	push   $0xf012c63c
f01182a1:	e8 e5 8c fe ff       	call   f0100f8b <cprintf>
f01182a6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01182a9:	e8 54 66 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01182ae:	89 c2                	mov    %eax,%edx
f01182b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182b3:	29 d0                	sub    %edx,%eax
f01182b5:	3d ff 00 00 00       	cmp    $0xff,%eax
f01182ba:	7f 17                	jg     f01182d3 <test_kmalloc_firstfit1+0xabd>
f01182bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182c3:	83 ec 0c             	sub    $0xc,%esp
f01182c6:	68 a8 c6 12 f0       	push   $0xf012c6a8
f01182cb:	e8 bb 8c fe ff       	call   f0100f8b <cprintf>
f01182d0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f01182d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01182d7:	74 04                	je     f01182dd <test_kmalloc_firstfit1+0xac7>
f01182d9:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f01182dd:	83 ec 08             	sub    $0x8,%esp
f01182e0:	ff 75 f4             	pushl  -0xc(%ebp)
f01182e3:	68 c0 c6 12 f0       	push   $0xf012c6c0
f01182e8:	e8 9e 8c fe ff       	call   f0100f8b <cprintf>
f01182ed:	83 c4 10             	add    $0x10,%esp

	return 1;
f01182f0:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01182f5:	8b 7d fc             	mov    -0x4(%ebp),%edi
f01182f8:	c9                   	leave  
f01182f9:	c3                   	ret    

f01182fa <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f01182fa:	55                   	push   %ebp
f01182fb:	89 e5                	mov    %esp,%ebp
f01182fd:	57                   	push   %edi
f01182fe:	53                   	push   %ebx
f01182ff:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118302:	83 ec 0c             	sub    $0xc,%esp
f0118305:	68 a8 ae 12 f0       	push   $0xf012aea8
f011830a:	e8 7c 8c fe ff       	call   f0100f8b <cprintf>
f011830f:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118312:	83 ec 0c             	sub    $0xc,%esp
f0118315:	68 d8 ae 12 f0       	push   $0xf012aed8
f011831a:	e8 6c 8c fe ff       	call   f0100f8b <cprintf>
f011831f:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118322:	83 ec 0c             	sub    $0xc,%esp
f0118325:	68 a8 ae 12 f0       	push   $0xf012aea8
f011832a:	e8 5c 8c fe ff       	call   f0100f8b <cprintf>
f011832f:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118332:	8d 55 98             	lea    -0x68(%ebp),%edx
f0118335:	b9 14 00 00 00       	mov    $0x14,%ecx
f011833a:	b8 00 00 00 00       	mov    $0x0,%eax
f011833f:	89 d7                	mov    %edx,%edi
f0118341:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0118343:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011834a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0118351:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0118358:	83 ec 0c             	sub    $0xc,%esp
f011835b:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0118360:	e8 26 8c fe ff       	call   f0100f8b <cprintf>
f0118365:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0118368:	83 ec 0c             	sub    $0xc,%esp
f011836b:	68 01 e0 ff 07       	push   $0x7ffe001
f0118370:	e8 b5 11 ff ff       	call   f010952a <kmalloc>
f0118375:	83 c4 10             	add    $0x10,%esp
f0118378:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011837b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011837e:	85 c0                	test   %eax,%eax
f0118380:	74 17                	je     f0118399 <test_kmalloc_firstfit2+0x9f>
f0118382:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118389:	83 ec 0c             	sub    $0xc,%esp
f011838c:	68 2c c7 12 f0       	push   $0xf012c72c
f0118391:	e8 f5 8b fe ff       	call   f0100f8b <cprintf>
f0118396:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118399:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011839d:	74 04                	je     f01183a3 <test_kmalloc_firstfit2+0xa9>
f011839f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01183a3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f01183aa:	83 ec 0c             	sub    $0xc,%esp
f01183ad:	68 74 c7 12 f0       	push   $0xf012c774
f01183b2:	e8 d4 8b fe ff       	call   f0100f8b <cprintf>
f01183b7:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01183ba:	e8 43 65 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01183bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183c2:	e8 de c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01183c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01183ca:	83 ec 0c             	sub    $0xc,%esp
f01183cd:	68 00 fc 1f 00       	push   $0x1ffc00
f01183d2:	e8 53 11 ff ff       	call   f010952a <kmalloc>
f01183d7:	83 c4 10             	add    $0x10,%esp
f01183da:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01183dd:	8b 45 98             	mov    -0x68(%ebp),%eax
f01183e0:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01183e5:	74 17                	je     f01183fe <test_kmalloc_firstfit2+0x104>
f01183e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183ee:	83 ec 0c             	sub    $0xc,%esp
f01183f1:	68 f4 bd 12 f0       	push   $0xf012bdf4
f01183f6:	e8 90 8b fe ff       	call   f0100f8b <cprintf>
f01183fb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183fe:	e8 a2 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118403:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118406:	74 17                	je     f011841f <test_kmalloc_firstfit2+0x125>
f0118408:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011840f:	83 ec 0c             	sub    $0xc,%esp
f0118412:	68 d0 b1 12 f0       	push   $0xf012b1d0
f0118417:	e8 6f 8b fe ff       	call   f0100f8b <cprintf>
f011841c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f011841f:	e8 de 64 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118424:	89 c2                	mov    %eax,%edx
f0118426:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118429:	29 d0                	sub    %edx,%eax
f011842b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118430:	7f 17                	jg     f0118449 <test_kmalloc_firstfit2+0x14f>
f0118432:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118439:	83 ec 0c             	sub    $0xc,%esp
f011843c:	68 27 be 12 f0       	push   $0xf012be27
f0118441:	e8 45 8b fe ff       	call   f0100f8b <cprintf>
f0118446:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118449:	e8 b4 64 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011844e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118451:	e8 4f c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118456:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118459:	83 ec 0c             	sub    $0xc,%esp
f011845c:	68 00 fc 1f 00       	push   $0x1ffc00
f0118461:	e8 c4 10 ff ff       	call   f010952a <kmalloc>
f0118466:	83 c4 10             	add    $0x10,%esp
f0118469:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f011846c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011846f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118474:	74 17                	je     f011848d <test_kmalloc_firstfit2+0x193>
f0118476:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011847d:	83 ec 0c             	sub    $0xc,%esp
f0118480:	68 40 be 12 f0       	push   $0xf012be40
f0118485:	e8 01 8b fe ff       	call   f0100f8b <cprintf>
f011848a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011848d:	e8 13 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118492:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118495:	74 17                	je     f01184ae <test_kmalloc_firstfit2+0x1b4>
f0118497:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011849e:	83 ec 0c             	sub    $0xc,%esp
f01184a1:	68 0c b3 12 f0       	push   $0xf012b30c
f01184a6:	e8 e0 8a fe ff       	call   f0100f8b <cprintf>
f01184ab:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01184ae:	e8 4f 64 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01184b3:	89 c2                	mov    %eax,%edx
f01184b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01184b8:	29 d0                	sub    %edx,%eax
f01184ba:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01184bf:	7f 17                	jg     f01184d8 <test_kmalloc_firstfit2+0x1de>
f01184c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184c8:	83 ec 0c             	sub    $0xc,%esp
f01184cb:	68 73 be 12 f0       	push   $0xf012be73
f01184d0:	e8 b6 8a fe ff       	call   f0100f8b <cprintf>
f01184d5:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01184d8:	e8 25 64 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01184dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184e0:	e8 c0 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f01184e8:	83 ec 0c             	sub    $0xc,%esp
f01184eb:	68 00 1c 00 00       	push   $0x1c00
f01184f0:	e8 35 10 ff ff       	call   f010952a <kmalloc>
f01184f5:	83 c4 10             	add    $0x10,%esp
f01184f8:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01184fb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01184fe:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118503:	74 17                	je     f011851c <test_kmalloc_firstfit2+0x222>
f0118505:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011850c:	83 ec 0c             	sub    $0xc,%esp
f011850f:	68 8c be 12 f0       	push   $0xf012be8c
f0118514:	e8 72 8a fe ff       	call   f0100f8b <cprintf>
f0118519:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011851c:	e8 84 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118521:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118524:	74 17                	je     f011853d <test_kmalloc_firstfit2+0x243>
f0118526:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011852d:	83 ec 0c             	sub    $0xc,%esp
f0118530:	68 04 b4 12 f0       	push   $0xf012b404
f0118535:	e8 51 8a fe ff       	call   f0100f8b <cprintf>
f011853a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f011853d:	e8 c0 63 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118542:	89 c2                	mov    %eax,%edx
f0118544:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118547:	29 d0                	sub    %edx,%eax
f0118549:	83 f8 01             	cmp    $0x1,%eax
f011854c:	7f 17                	jg     f0118565 <test_kmalloc_firstfit2+0x26b>
f011854e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118555:	83 ec 0c             	sub    $0xc,%esp
f0118558:	68 bf be 12 f0       	push   $0xf012bebf
f011855d:	e8 29 8a fe ff       	call   f0100f8b <cprintf>
f0118562:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118565:	e8 98 63 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011856a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011856d:	e8 33 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118572:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0118575:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118578:	83 ec 0c             	sub    $0xc,%esp
f011857b:	50                   	push   %eax
f011857c:	e8 09 12 ff ff       	call   f010978a <kfree>
f0118581:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118584:	e8 1c c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118589:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011858c:	74 17                	je     f01185a5 <test_kmalloc_firstfit2+0x2ab>
f011858e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118595:	83 ec 0c             	sub    $0xc,%esp
f0118598:	68 e4 b4 12 f0       	push   $0xf012b4e4
f011859d:	e8 e9 89 fe ff       	call   f0100f8b <cprintf>
f01185a2:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f01185a5:	e8 58 63 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01185aa:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01185ad:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01185b2:	7f 17                	jg     f01185cb <test_kmalloc_firstfit2+0x2d1>
f01185b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185bb:	83 ec 0c             	sub    $0xc,%esp
f01185be:	68 ba c7 12 f0       	push   $0xf012c7ba
f01185c3:	e8 c3 89 fe ff       	call   f0100f8b <cprintf>
f01185c8:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01185cb:	e8 32 63 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01185d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185d3:	e8 cd c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01185db:	83 ec 0c             	sub    $0xc,%esp
f01185de:	68 00 fc 2f 00       	push   $0x2ffc00
f01185e3:	e8 42 0f ff ff       	call   f010952a <kmalloc>
f01185e8:	83 c4 10             	add    $0x10,%esp
f01185eb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f01185ee:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01185f1:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01185f6:	74 17                	je     f011860f <test_kmalloc_firstfit2+0x315>
f01185f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185ff:	83 ec 0c             	sub    $0xc,%esp
f0118602:	68 24 bf 12 f0       	push   $0xf012bf24
f0118607:	e8 7f 89 fe ff       	call   f0100f8b <cprintf>
f011860c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011860f:	e8 91 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118614:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118617:	74 17                	je     f0118630 <test_kmalloc_firstfit2+0x336>
f0118619:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118620:	83 ec 0c             	sub    $0xc,%esp
f0118623:	68 e8 b5 12 f0       	push   $0xf012b5e8
f0118628:	e8 5e 89 fe ff       	call   f0100f8b <cprintf>
f011862d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0118630:	e8 cd 62 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118635:	89 c2                	mov    %eax,%edx
f0118637:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011863a:	29 d0                	sub    %edx,%eax
f011863c:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118641:	7f 17                	jg     f011865a <test_kmalloc_firstfit2+0x360>
f0118643:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011864a:	83 ec 0c             	sub    $0xc,%esp
f011864d:	68 57 bf 12 f0       	push   $0xf012bf57
f0118652:	e8 34 89 fe ff       	call   f0100f8b <cprintf>
f0118657:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011865a:	e8 a3 62 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011865f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118662:	e8 3e c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118667:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f011866a:	83 ec 0c             	sub    $0xc,%esp
f011866d:	68 00 18 20 00       	push   $0x201800
f0118672:	e8 b3 0e ff ff       	call   f010952a <kmalloc>
f0118677:	83 c4 10             	add    $0x10,%esp
f011867a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f011867d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118680:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0118685:	74 17                	je     f011869e <test_kmalloc_firstfit2+0x3a4>
f0118687:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011868e:	83 ec 0c             	sub    $0xc,%esp
f0118691:	68 70 bf 12 f0       	push   $0xf012bf70
f0118696:	e8 f0 88 fe ff       	call   f0100f8b <cprintf>
f011869b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011869e:	e8 02 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186a3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01186a6:	74 17                	je     f01186bf <test_kmalloc_firstfit2+0x3c5>
f01186a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186af:	83 ec 0c             	sub    $0xc,%esp
f01186b2:	68 ec b6 12 f0       	push   $0xf012b6ec
f01186b7:	e8 cf 88 fe ff       	call   f0100f8b <cprintf>
f01186bc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01186bf:	e8 3e 62 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01186c4:	89 c2                	mov    %eax,%edx
f01186c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186c9:	29 d0                	sub    %edx,%eax
f01186cb:	3d 01 02 00 00       	cmp    $0x201,%eax
f01186d0:	7f 17                	jg     f01186e9 <test_kmalloc_firstfit2+0x3ef>
f01186d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186d9:	83 ec 0c             	sub    $0xc,%esp
f01186dc:	68 a3 bf 12 f0       	push   $0xf012bfa3
f01186e1:	e8 a5 88 fe ff       	call   f0100f8b <cprintf>
f01186e6:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01186e9:	e8 14 62 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01186ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186f1:	e8 af c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01186f9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01186fc:	83 ec 0c             	sub    $0xc,%esp
f01186ff:	50                   	push   %eax
f0118700:	e8 85 10 ff ff       	call   f010978a <kfree>
f0118705:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118708:	e8 98 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011870d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118710:	74 17                	je     f0118729 <test_kmalloc_firstfit2+0x42f>
f0118712:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118719:	83 ec 0c             	sub    $0xc,%esp
f011871c:	68 f0 b7 12 f0       	push   $0xf012b7f0
f0118721:	e8 65 88 fe ff       	call   f0100f8b <cprintf>
f0118726:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f0118729:	e8 d4 61 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011872e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118731:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118736:	7f 17                	jg     f011874f <test_kmalloc_firstfit2+0x455>
f0118738:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011873f:	83 ec 0c             	sub    $0xc,%esp
f0118742:	68 ca c7 12 f0       	push   $0xf012c7ca
f0118747:	e8 3f 88 fe ff       	call   f0100f8b <cprintf>
f011874c:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011874f:	e8 ae 61 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118754:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118757:	e8 49 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011875c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011875f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118762:	83 ec 0c             	sub    $0xc,%esp
f0118765:	50                   	push   %eax
f0118766:	e8 1f 10 ff ff       	call   f010978a <kfree>
f011876b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f011876e:	e8 8f 61 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118773:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118776:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011877b:	7f 17                	jg     f0118794 <test_kmalloc_firstfit2+0x49a>
f011877d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118784:	83 ec 0c             	sub    $0xc,%esp
f0118787:	68 9b c0 12 f0       	push   $0xf012c09b
f011878c:	e8 fa 87 fe ff       	call   f0100f8b <cprintf>
f0118791:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118794:	e8 0c c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118799:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011879c:	74 17                	je     f01187b5 <test_kmalloc_firstfit2+0x4bb>
f011879e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187a5:	83 ec 0c             	sub    $0xc,%esp
f01187a8:	68 30 c0 12 f0       	push   $0xf012c030
f01187ad:	e8 d9 87 fe ff       	call   f0100f8b <cprintf>
f01187b2:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01187b5:	e8 48 61 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01187ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187bd:	e8 e3 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f01187c5:	83 ec 0c             	sub    $0xc,%esp
f01187c8:	68 00 fc 4f 00       	push   $0x4ffc00
f01187cd:	e8 58 0d ff ff       	call   f010952a <kmalloc>
f01187d2:	83 c4 10             	add    $0x10,%esp
f01187d5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f01187d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01187db:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f01187e0:	74 17                	je     f01187f9 <test_kmalloc_firstfit2+0x4ff>
f01187e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187e9:	83 ec 0c             	sub    $0xc,%esp
f01187ec:	68 dc c7 12 f0       	push   $0xf012c7dc
f01187f1:	e8 95 87 fe ff       	call   f0100f8b <cprintf>
f01187f6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187f9:	e8 a7 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187fe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118801:	74 17                	je     f011881a <test_kmalloc_firstfit2+0x520>
f0118803:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011880a:	83 ec 0c             	sub    $0xc,%esp
f011880d:	68 ac c0 12 f0       	push   $0xf012c0ac
f0118812:	e8 74 87 fe ff       	call   f0100f8b <cprintf>
f0118817:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f011881a:	e8 e3 60 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011881f:	89 c2                	mov    %eax,%edx
f0118821:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118824:	29 d0                	sub    %edx,%eax
f0118826:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f011882b:	7f 17                	jg     f0118844 <test_kmalloc_firstfit2+0x54a>
f011882d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118834:	83 ec 0c             	sub    $0xc,%esp
f0118837:	68 10 c8 12 f0       	push   $0xf012c810
f011883c:	e8 4a 87 fe ff       	call   f0100f8b <cprintf>
f0118841:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118844:	e8 b9 60 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118849:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011884c:	e8 54 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118851:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0118854:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118857:	83 ec 0c             	sub    $0xc,%esp
f011885a:	50                   	push   %eax
f011885b:	e8 2a 0f ff ff       	call   f010978a <kfree>
f0118860:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118863:	e8 3d c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118868:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011886b:	74 17                	je     f0118884 <test_kmalloc_firstfit2+0x58a>
f011886d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118874:	83 ec 0c             	sub    $0xc,%esp
f0118877:	68 2c c1 12 f0       	push   $0xf012c12c
f011887c:	e8 0a 87 fe ff       	call   f0100f8b <cprintf>
f0118881:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118884:	e8 79 60 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118889:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011888c:	83 f8 01             	cmp    $0x1,%eax
f011888f:	7f 17                	jg     f01188a8 <test_kmalloc_firstfit2+0x5ae>
f0118891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118898:	83 ec 0c             	sub    $0xc,%esp
f011889b:	68 98 c1 12 f0       	push   $0xf012c198
f01188a0:	e8 e6 86 fe ff       	call   f0100f8b <cprintf>
f01188a5:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f01188a8:	e8 55 60 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01188ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188b0:	e8 f0 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f01188b8:	83 ec 0c             	sub    $0xc,%esp
f01188bb:	68 00 04 00 00       	push   $0x400
f01188c0:	e8 65 0c ff ff       	call   f010952a <kmalloc>
f01188c5:	83 c4 10             	add    $0x10,%esp
f01188c8:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01188cb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01188ce:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01188d3:	76 22                	jbe    f01188f7 <test_kmalloc_firstfit2+0x5fd>
f01188d5:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f01188d8:	83 ec 0c             	sub    $0xc,%esp
f01188db:	6a 00                	push   $0x0
f01188dd:	e8 15 0b ff ff       	call   f01093f7 <sbrk>
f01188e2:	83 c4 10             	add    $0x10,%esp
f01188e5:	39 c3                	cmp    %eax,%ebx
f01188e7:	73 0e                	jae    f01188f7 <test_kmalloc_firstfit2+0x5fd>
f01188e9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01188ec:	89 c2                	mov    %eax,%edx
f01188ee:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f01188f3:	39 c2                	cmp    %eax,%edx
f01188f5:	72 17                	jb     f011890e <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01188f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188fe:	83 ec 0c             	sub    $0xc,%esp
f0118901:	68 28 c8 12 f0       	push   $0xf012c828
f0118906:	e8 80 86 fe ff       	call   f0100f8b <cprintf>
f011890b:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011890e:	e8 92 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118913:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118916:	74 17                	je     f011892f <test_kmalloc_firstfit2+0x635>
f0118918:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011891f:	83 ec 0c             	sub    $0xc,%esp
f0118922:	68 0c c2 12 f0       	push   $0xf012c20c
f0118927:	e8 5f 86 fe ff       	call   f0100f8b <cprintf>
f011892c:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011892f:	e8 71 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118934:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118937:	83 ec 0c             	sub    $0xc,%esp
f011893a:	68 00 08 00 00       	push   $0x800
f011893f:	e8 e6 0b ff ff       	call   f010952a <kmalloc>
f0118944:	83 c4 10             	add    $0x10,%esp
f0118947:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011894a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011894d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118952:	76 22                	jbe    f0118976 <test_kmalloc_firstfit2+0x67c>
f0118954:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118957:	83 ec 0c             	sub    $0xc,%esp
f011895a:	6a 00                	push   $0x0
f011895c:	e8 96 0a ff ff       	call   f01093f7 <sbrk>
f0118961:	83 c4 10             	add    $0x10,%esp
f0118964:	39 c3                	cmp    %eax,%ebx
f0118966:	73 0e                	jae    f0118976 <test_kmalloc_firstfit2+0x67c>
f0118968:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011896b:	89 c2                	mov    %eax,%edx
f011896d:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0118972:	39 c2                	cmp    %eax,%edx
f0118974:	72 17                	jb     f011898d <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118976:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011897d:	83 ec 0c             	sub    $0xc,%esp
f0118980:	68 b4 c8 12 f0       	push   $0xf012c8b4
f0118985:	e8 01 86 fe ff       	call   f0100f8b <cprintf>
f011898a:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011898d:	e8 13 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118992:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118995:	74 17                	je     f01189ae <test_kmalloc_firstfit2+0x6b4>
f0118997:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011899e:	83 ec 0c             	sub    $0xc,%esp
f01189a1:	68 c4 c2 12 f0       	push   $0xf012c2c4
f01189a6:	e8 e0 85 fe ff       	call   f0100f8b <cprintf>
f01189ab:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01189ae:	e8 f2 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01189b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f01189b6:	83 ec 0c             	sub    $0xc,%esp
f01189b9:	68 00 04 00 00       	push   $0x400
f01189be:	e8 67 0b ff ff       	call   f010952a <kmalloc>
f01189c3:	83 c4 10             	add    $0x10,%esp
f01189c6:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f01189c9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01189cc:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01189d1:	76 22                	jbe    f01189f5 <test_kmalloc_firstfit2+0x6fb>
f01189d3:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f01189d6:	83 ec 0c             	sub    $0xc,%esp
f01189d9:	6a 00                	push   $0x0
f01189db:	e8 17 0a ff ff       	call   f01093f7 <sbrk>
f01189e0:	83 c4 10             	add    $0x10,%esp
f01189e3:	39 c3                	cmp    %eax,%ebx
f01189e5:	73 0e                	jae    f01189f5 <test_kmalloc_firstfit2+0x6fb>
f01189e7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01189ea:	89 c2                	mov    %eax,%edx
f01189ec:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f01189f1:	39 c2                	cmp    %eax,%edx
f01189f3:	72 17                	jb     f0118a0c <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01189f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189fc:	83 ec 0c             	sub    $0xc,%esp
f01189ff:	68 40 c9 12 f0       	push   $0xf012c940
f0118a04:	e8 82 85 fe ff       	call   f0100f8b <cprintf>
f0118a09:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a0c:	e8 94 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a11:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a14:	74 17                	je     f0118a2d <test_kmalloc_firstfit2+0x733>
f0118a16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a1d:	83 ec 0c             	sub    $0xc,%esp
f0118a20:	68 7c c3 12 f0       	push   $0xf012c37c
f0118a25:	e8 61 85 fe ff       	call   f0100f8b <cprintf>
f0118a2a:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118a2d:	e8 d0 5e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118a32:	89 c2                	mov    %eax,%edx
f0118a34:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a37:	29 d0                	sub    %edx,%eax
f0118a39:	83 f8 01             	cmp    $0x1,%eax
f0118a3c:	74 17                	je     f0118a55 <test_kmalloc_firstfit2+0x75b>
f0118a3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a45:	83 ec 0c             	sub    $0xc,%esp
f0118a48:	68 cc c9 12 f0       	push   $0xf012c9cc
f0118a4d:	e8 39 85 fe ff       	call   f0100f8b <cprintf>
f0118a52:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118a55:	e8 a8 5e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118a5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a5d:	e8 43 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a62:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118a65:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118a68:	83 ec 0c             	sub    $0xc,%esp
f0118a6b:	50                   	push   %eax
f0118a6c:	e8 19 0d ff ff       	call   f010978a <kfree>
f0118a71:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a74:	e8 2c be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a7c:	74 17                	je     f0118a95 <test_kmalloc_firstfit2+0x79b>
f0118a7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a85:	83 ec 0c             	sub    $0xc,%esp
f0118a88:	68 4c c4 12 f0       	push   $0xf012c44c
f0118a8d:	e8 f9 84 fe ff       	call   f0100f8b <cprintf>
f0118a92:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118a95:	e8 68 5e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118a9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118a9d:	74 17                	je     f0118ab6 <test_kmalloc_firstfit2+0x7bc>
f0118a9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aa6:	83 ec 0c             	sub    $0xc,%esp
f0118aa9:	68 f0 c9 12 f0       	push   $0xf012c9f0
f0118aae:	e8 d8 84 fe ff       	call   f0100f8b <cprintf>
f0118ab3:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118ab6:	e8 47 5e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118abb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118abe:	e8 e2 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ac3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118ac6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118ac9:	83 ec 0c             	sub    $0xc,%esp
f0118acc:	50                   	push   %eax
f0118acd:	e8 b8 0c ff ff       	call   f010978a <kfree>
f0118ad2:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ad5:	e8 cb bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ada:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118add:	74 17                	je     f0118af6 <test_kmalloc_firstfit2+0x7fc>
f0118adf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ae6:	83 ec 0c             	sub    $0xc,%esp
f0118ae9:	68 ec c4 12 f0       	push   $0xf012c4ec
f0118aee:	e8 98 84 fe ff       	call   f0100f8b <cprintf>
f0118af3:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118af6:	e8 07 5e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118afb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118afe:	74 17                	je     f0118b17 <test_kmalloc_firstfit2+0x81d>
f0118b00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b07:	83 ec 0c             	sub    $0xc,%esp
f0118b0a:	68 50 ca 12 f0       	push   $0xf012ca50
f0118b0f:	e8 77 84 fe ff       	call   f0100f8b <cprintf>
f0118b14:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118b17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118b1b:	74 04                	je     f0118b21 <test_kmalloc_firstfit2+0x827>
f0118b1d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118b21:	83 ec 0c             	sub    $0xc,%esp
f0118b24:	68 b0 ca 12 f0       	push   $0xf012cab0
f0118b29:	e8 5d 84 fe ff       	call   f0100f8b <cprintf>
f0118b2e:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118b31:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b38:	e8 c5 5d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118b3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b40:	e8 60 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b45:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118b48:	83 ec 0c             	sub    $0xc,%esp
f0118b4b:	68 00 08 00 00       	push   $0x800
f0118b50:	e8 d5 09 ff ff       	call   f010952a <kmalloc>
f0118b55:	83 c4 10             	add    $0x10,%esp
f0118b58:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118b5b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118b5e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b61:	39 c2                	cmp    %eax,%edx
f0118b63:	74 17                	je     f0118b7c <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118b65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b6c:	83 ec 0c             	sub    $0xc,%esp
f0118b6f:	68 e8 ca 12 f0       	push   $0xf012cae8
f0118b74:	e8 12 84 fe ff       	call   f0100f8b <cprintf>
f0118b79:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b7c:	e8 24 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b81:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b84:	74 17                	je     f0118b9d <test_kmalloc_firstfit2+0x8a3>
f0118b86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b8d:	83 ec 0c             	sub    $0xc,%esp
f0118b90:	68 30 bb 12 f0       	push   $0xf012bb30
f0118b95:	e8 f1 83 fe ff       	call   f0100f8b <cprintf>
f0118b9a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118b9d:	e8 60 5d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118ba2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118ba5:	74 17                	je     f0118bbe <test_kmalloc_firstfit2+0x8c4>
f0118ba7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bae:	83 ec 0c             	sub    $0xc,%esp
f0118bb1:	68 1c cb 12 f0       	push   $0xf012cb1c
f0118bb6:	e8 d0 83 fe ff       	call   f0100f8b <cprintf>
f0118bbb:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118bbe:	e8 3f 5d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118bc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bc6:	e8 da bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118bcb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118bce:	83 ec 0c             	sub    $0xc,%esp
f0118bd1:	68 00 04 00 00       	push   $0x400
f0118bd6:	e8 4f 09 ff ff       	call   f010952a <kmalloc>
f0118bdb:	83 c4 10             	add    $0x10,%esp
f0118bde:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118be1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118be4:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118be7:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118bed:	39 d0                	cmp    %edx,%eax
f0118bef:	74 17                	je     f0118c08 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118bf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bf8:	83 ec 0c             	sub    $0xc,%esp
f0118bfb:	68 34 cb 12 f0       	push   $0xf012cb34
f0118c00:	e8 86 83 fe ff       	call   f0100f8b <cprintf>
f0118c05:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c08:	e8 98 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c0d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c10:	74 17                	je     f0118c29 <test_kmalloc_firstfit2+0x92f>
f0118c12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c19:	83 ec 0c             	sub    $0xc,%esp
f0118c1c:	68 f8 bb 12 f0       	push   $0xf012bbf8
f0118c21:	e8 65 83 fe ff       	call   f0100f8b <cprintf>
f0118c26:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118c29:	e8 d4 5c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118c2e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118c31:	74 17                	je     f0118c4a <test_kmalloc_firstfit2+0x950>
f0118c33:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c3a:	83 ec 0c             	sub    $0xc,%esp
f0118c3d:	68 68 cb 12 f0       	push   $0xf012cb68
f0118c42:	e8 44 83 fe ff       	call   f0100f8b <cprintf>
f0118c47:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118c4a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118c4e:	74 04                	je     f0118c54 <test_kmalloc_firstfit2+0x95a>
f0118c50:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118c54:	83 ec 0c             	sub    $0xc,%esp
f0118c57:	68 80 cb 12 f0       	push   $0xf012cb80
f0118c5c:	e8 2a 83 fe ff       	call   f0100f8b <cprintf>
f0118c61:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118c64:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118c6b:	e8 92 5c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118c70:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c73:	e8 2d bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c78:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118c7b:	83 ec 0c             	sub    $0xc,%esp
f0118c7e:	68 00 04 70 00       	push   $0x700400
f0118c83:	e8 a2 08 ff ff       	call   f010952a <kmalloc>
f0118c88:	83 c4 10             	add    $0x10,%esp
f0118c8b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118c8e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118c91:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118c96:	74 17                	je     f0118caf <test_kmalloc_firstfit2+0x9b5>
f0118c98:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c9f:	83 ec 0c             	sub    $0xc,%esp
f0118ca2:	68 08 c6 12 f0       	push   $0xf012c608
f0118ca7:	e8 df 82 fe ff       	call   f0100f8b <cprintf>
f0118cac:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118caf:	e8 f1 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cb4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118cb7:	74 17                	je     f0118cd0 <test_kmalloc_firstfit2+0x9d6>
f0118cb9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cc0:	83 ec 0c             	sub    $0xc,%esp
f0118cc3:	68 3c c6 12 f0       	push   $0xf012c63c
f0118cc8:	e8 be 82 fe ff       	call   f0100f8b <cprintf>
f0118ccd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118cd0:	e8 2d 5c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118cd5:	89 c2                	mov    %eax,%edx
f0118cd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118cda:	29 d0                	sub    %edx,%eax
f0118cdc:	3d 00 07 00 00       	cmp    $0x700,%eax
f0118ce1:	7f 17                	jg     f0118cfa <test_kmalloc_firstfit2+0xa00>
f0118ce3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cea:	83 ec 0c             	sub    $0xc,%esp
f0118ced:	68 a8 c6 12 f0       	push   $0xf012c6a8
f0118cf2:	e8 94 82 fe ff       	call   f0100f8b <cprintf>
f0118cf7:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118cfa:	e8 03 5c ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118cff:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d02:	e8 9e bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d07:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0118d0a:	83 ec 0c             	sub    $0xc,%esp
f0118d0d:	68 00 0c 00 00       	push   $0xc00
f0118d12:	e8 13 08 ff ff       	call   f010952a <kmalloc>
f0118d17:	83 c4 10             	add    $0x10,%esp
f0118d1a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0118d1d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118d20:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0118d25:	74 17                	je     f0118d3e <test_kmalloc_firstfit2+0xa44>
f0118d27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d2e:	83 ec 0c             	sub    $0xc,%esp
f0118d31:	68 b4 cb 12 f0       	push   $0xf012cbb4
f0118d36:	e8 50 82 fe ff       	call   f0100f8b <cprintf>
f0118d3b:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d3e:	e8 62 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d43:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d46:	74 17                	je     f0118d5f <test_kmalloc_firstfit2+0xa65>
f0118d48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d4f:	83 ec 0c             	sub    $0xc,%esp
f0118d52:	68 e8 cb 12 f0       	push   $0xf012cbe8
f0118d57:	e8 2f 82 fe ff       	call   f0100f8b <cprintf>
f0118d5c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118d5f:	e8 9e 5b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118d64:	89 c2                	mov    %eax,%edx
f0118d66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118d69:	29 d0                	sub    %edx,%eax
f0118d6b:	85 c0                	test   %eax,%eax
f0118d6d:	7f 17                	jg     f0118d86 <test_kmalloc_firstfit2+0xa8c>
f0118d6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d76:	83 ec 0c             	sub    $0xc,%esp
f0118d79:	68 54 cc 12 f0       	push   $0xf012cc54
f0118d7e:	e8 08 82 fe ff       	call   f0100f8b <cprintf>
f0118d83:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0118d86:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118d8a:	74 04                	je     f0118d90 <test_kmalloc_firstfit2+0xa96>
f0118d8c:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0118d90:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0118d97:	83 ec 0c             	sub    $0xc,%esp
f0118d9a:	68 6c cc 12 f0       	push   $0xf012cc6c
f0118d9f:	e8 e7 81 fe ff       	call   f0100f8b <cprintf>
f0118da4:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0118da7:	83 ec 0c             	sub    $0xc,%esp
f0118daa:	68 00 e0 1f 07       	push   $0x71fe000
f0118daf:	e8 76 07 ff ff       	call   f010952a <kmalloc>
f0118db4:	83 c4 10             	add    $0x10,%esp
f0118db7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0118dba:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118dbd:	85 c0                	test   %eax,%eax
f0118dbf:	74 17                	je     f0118dd8 <test_kmalloc_firstfit2+0xade>
f0118dc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dc8:	83 ec 0c             	sub    $0xc,%esp
f0118dcb:	68 c0 cc 12 f0       	push   $0xf012ccc0
f0118dd0:	e8 b6 81 fe ff       	call   f0100f8b <cprintf>
f0118dd5:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0118dd8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118ddc:	74 04                	je     f0118de2 <test_kmalloc_firstfit2+0xae8>
f0118dde:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0118de2:	83 ec 08             	sub    $0x8,%esp
f0118de5:	ff 75 f4             	pushl  -0xc(%ebp)
f0118de8:	68 28 cd 12 f0       	push   $0xf012cd28
f0118ded:	e8 99 81 fe ff       	call   f0100f8b <cprintf>
f0118df2:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118df5:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118dfa:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0118dfd:	5b                   	pop    %ebx
f0118dfe:	5f                   	pop    %edi
f0118dff:	5d                   	pop    %ebp
f0118e00:	c3                   	ret    

f0118e01 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0118e01:	55                   	push   %ebp
f0118e02:	89 e5                	mov    %esp,%ebp
f0118e04:	53                   	push   %ebx
f0118e05:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118e08:	83 ec 0c             	sub    $0xc,%esp
f0118e0b:	68 a8 ae 12 f0       	push   $0xf012aea8
f0118e10:	e8 76 81 fe ff       	call   f0100f8b <cprintf>
f0118e15:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118e18:	83 ec 0c             	sub    $0xc,%esp
f0118e1b:	68 d8 ae 12 f0       	push   $0xf012aed8
f0118e20:	e8 66 81 fe ff       	call   f0100f8b <cprintf>
f0118e25:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118e28:	83 ec 0c             	sub    $0xc,%esp
f0118e2b:	68 a8 ae 12 f0       	push   $0xf012aea8
f0118e30:	e8 56 81 fe ff       	call   f0100f8b <cprintf>
f0118e35:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0118e38:	e8 c5 5a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118e3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0118e40:	e8 60 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e45:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0118e48:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0118e4f:	83 ec 0c             	sub    $0xc,%esp
f0118e52:	68 5d cd 12 f0       	push   $0xf012cd5d
f0118e57:	e8 2f 81 fe ff       	call   f0100f8b <cprintf>
f0118e5c:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0118e5f:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118e64:	ba 00 00 00 00       	mov    $0x0,%edx
f0118e69:	f7 75 e4             	divl   -0x1c(%ebp)
f0118e6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0118e6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118e76:	eb 1d                	jmp    f0118e95 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118e78:	83 ec 0c             	sub    $0xc,%esp
f0118e7b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118e7e:	e8 a7 06 ff ff       	call   f010952a <kmalloc>
f0118e83:	83 c4 10             	add    $0x10,%esp
f0118e86:	89 c2                	mov    %eax,%edx
f0118e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118e8b:	89 14 85 00 ac 69 f0 	mov    %edx,-0xf965400(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0118e92:	ff 45 f4             	incl   -0xc(%ebp)
f0118e95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118e98:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118e9b:	7c db                	jl     f0118e78 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0118e9d:	83 ec 0c             	sub    $0xc,%esp
f0118ea0:	68 61 cd 12 f0       	push   $0xf012cd61
f0118ea5:	e8 e1 80 fe ff       	call   f0100f8b <cprintf>
f0118eaa:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0118ead:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118eb2:	ba 00 00 00 00       	mov    $0x0,%edx
f0118eb7:	f7 75 e4             	divl   -0x1c(%ebp)
f0118eba:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0118ebd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118ec1:	74 1e                	je     f0118ee1 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0118ec3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0118ec6:	8d 43 01             	lea    0x1(%ebx),%eax
f0118ec9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118ecc:	83 ec 0c             	sub    $0xc,%esp
f0118ecf:	ff 75 e0             	pushl  -0x20(%ebp)
f0118ed2:	e8 53 06 ff ff       	call   f010952a <kmalloc>
f0118ed7:	83 c4 10             	add    $0x10,%esp
f0118eda:	89 04 9d 00 ac 69 f0 	mov    %eax,-0xf965400(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0118ee1:	83 ec 04             	sub    $0x4,%esp
f0118ee4:	ff 75 f0             	pushl  -0x10(%ebp)
f0118ee7:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118eea:	68 68 cd 12 f0       	push   $0xf012cd68
f0118eef:	e8 97 80 fe ff       	call   f0100f8b <cprintf>
f0118ef4:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118ef7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118efe:	eb 36                	jmp    f0118f36 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0118f00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f03:	8b 04 85 00 ac 69 f0 	mov    -0xf965400(,%eax,4),%eax
f0118f0a:	89 c2                	mov    %eax,%edx
f0118f0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f0f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118f13:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0118f18:	39 c2                	cmp    %eax,%edx
f0118f1a:	74 17                	je     f0118f33 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0118f1c:	83 ec 04             	sub    $0x4,%esp
f0118f1f:	68 b0 cd 12 f0       	push   $0xf012cdb0
f0118f24:	68 e3 02 00 00       	push   $0x2e3
f0118f29:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0118f2e:	e8 06 74 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118f33:	ff 45 f4             	incl   -0xc(%ebp)
f0118f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f39:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118f3c:	7c c2                	jl     f0118f00 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118f3e:	e8 62 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f43:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f46:	74 17                	je     f0118f5f <test_fastfirstfit+0x15e>
f0118f48:	83 ec 04             	sub    $0x4,%esp
f0118f4b:	68 0c ce 12 f0       	push   $0xf012ce0c
f0118f50:	68 e6 02 00 00       	push   $0x2e6
f0118f55:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0118f5a:	e8 da 73 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0118f5f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118f62:	e8 9b 59 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118f67:	29 c3                	sub    %eax,%ebx
f0118f69:	89 d8                	mov    %ebx,%eax
f0118f6b:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0118f70:	77 17                	ja     f0118f89 <test_fastfirstfit+0x188>
f0118f72:	83 ec 04             	sub    $0x4,%esp
f0118f75:	68 74 ce 12 f0       	push   $0xf012ce74
f0118f7a:	68 e7 02 00 00       	push   $0x2e7
f0118f7f:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0118f84:	e8 b0 73 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0118f89:	e8 17 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f8e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0118f91:	e8 6c 59 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0118f96:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0118f99:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0118f9d:	7f 17                	jg     f0118fb6 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0118f9f:	83 ec 04             	sub    $0x4,%esp
f0118fa2:	68 88 ce 12 f0       	push   $0xf012ce88
f0118fa7:	68 ee 02 00 00       	push   $0x2ee
f0118fac:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0118fb1:	e8 83 73 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0118fb6:	a1 00 ac 69 f0       	mov    0xf069ac00,%eax
f0118fbb:	83 ec 0c             	sub    $0xc,%esp
f0118fbe:	50                   	push   %eax
f0118fbf:	e8 c6 07 ff ff       	call   f010978a <kfree>
f0118fc4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0118fc7:	a1 08 ac 69 f0       	mov    0xf069ac08,%eax
f0118fcc:	83 ec 0c             	sub    $0xc,%esp
f0118fcf:	50                   	push   %eax
f0118fd0:	e8 b5 07 ff ff       	call   f010978a <kfree>
f0118fd5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0118fd8:	a1 0c ac 69 f0       	mov    0xf069ac0c,%eax
f0118fdd:	83 ec 0c             	sub    $0xc,%esp
f0118fe0:	50                   	push   %eax
f0118fe1:	e8 a4 07 ff ff       	call   f010978a <kfree>
f0118fe6:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0118fe9:	a1 14 ac 69 f0       	mov    0xf069ac14,%eax
f0118fee:	83 ec 0c             	sub    $0xc,%esp
f0118ff1:	50                   	push   %eax
f0118ff2:	e8 93 07 ff ff       	call   f010978a <kfree>
f0118ff7:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0118ffa:	a1 28 ac 69 f0       	mov    0xf069ac28,%eax
f0118fff:	83 ec 0c             	sub    $0xc,%esp
f0119002:	50                   	push   %eax
f0119003:	e8 82 07 ff ff       	call   f010978a <kfree>
f0119008:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f011900b:	a1 30 ac 69 f0       	mov    0xf069ac30,%eax
f0119010:	83 ec 0c             	sub    $0xc,%esp
f0119013:	50                   	push   %eax
f0119014:	e8 71 07 ff ff       	call   f010978a <kfree>
f0119019:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f011901c:	a1 2c ac 69 f0       	mov    0xf069ac2c,%eax
f0119021:	83 ec 0c             	sub    $0xc,%esp
f0119024:	50                   	push   %eax
f0119025:	e8 60 07 ff ff       	call   f010978a <kfree>
f011902a:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f011902d:	a1 50 ac 69 f0       	mov    0xf069ac50,%eax
f0119032:	83 ec 0c             	sub    $0xc,%esp
f0119035:	50                   	push   %eax
f0119036:	e8 4f 07 ff ff       	call   f010978a <kfree>
f011903b:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f011903e:	a1 64 ac 69 f0       	mov    0xf069ac64,%eax
f0119043:	83 ec 0c             	sub    $0xc,%esp
f0119046:	50                   	push   %eax
f0119047:	e8 3e 07 ff ff       	call   f010978a <kfree>
f011904c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f011904f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119052:	83 e8 02             	sub    $0x2,%eax
f0119055:	8b 04 85 00 ac 69 f0 	mov    -0xf965400(,%eax,4),%eax
f011905c:	83 ec 0c             	sub    $0xc,%esp
f011905f:	50                   	push   %eax
f0119060:	e8 25 07 ff ff       	call   f010978a <kfree>
f0119065:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0119068:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011906b:	83 e8 03             	sub    $0x3,%eax
f011906e:	8b 04 85 00 ac 69 f0 	mov    -0xf965400(,%eax,4),%eax
f0119075:	83 ec 0c             	sub    $0xc,%esp
f0119078:	50                   	push   %eax
f0119079:	e8 0c 07 ff ff       	call   f010978a <kfree>
f011907e:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119081:	e8 1f b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119086:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119089:	74 17                	je     f01190a2 <test_fastfirstfit+0x2a1>
f011908b:	83 ec 04             	sub    $0x4,%esp
f011908e:	68 0c ce 12 f0       	push   $0xf012ce0c
f0119093:	68 fb 02 00 00       	push   $0x2fb
f0119098:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011909d:	e8 97 72 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f01190a2:	e8 5b 58 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01190a7:	89 c2                	mov    %eax,%edx
f01190a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01190ac:	89 d1                	mov    %edx,%ecx
f01190ae:	29 c1                	sub    %eax,%ecx
f01190b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01190b3:	89 d0                	mov    %edx,%eax
f01190b5:	c1 e0 02             	shl    $0x2,%eax
f01190b8:	01 d0                	add    %edx,%eax
f01190ba:	01 c0                	add    %eax,%eax
f01190bc:	01 d0                	add    %edx,%eax
f01190be:	c1 e8 0c             	shr    $0xc,%eax
f01190c1:	39 c1                	cmp    %eax,%ecx
f01190c3:	74 17                	je     f01190dc <test_fastfirstfit+0x2db>
f01190c5:	83 ec 04             	sub    $0x4,%esp
f01190c8:	68 c4 ce 12 f0       	push   $0xf012cec4
f01190cd:	68 fc 02 00 00       	push   $0x2fc
f01190d2:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01190d7:	e8 5d 72 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f01190dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01190df:	01 c0                	add    %eax,%eax
f01190e1:	89 c2                	mov    %eax,%edx
f01190e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01190e6:	d1 e8                	shr    %eax
f01190e8:	01 d0                	add    %edx,%eax
f01190ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01190ed:	e8 b3 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01190f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01190f5:	e8 08 58 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01190fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01190fd:	83 ec 0c             	sub    $0xc,%esp
f0119100:	ff 75 dc             	pushl  -0x24(%ebp)
f0119103:	e8 22 04 ff ff       	call   f010952a <kmalloc>
f0119108:	83 c4 10             	add    $0x10,%esp
f011910b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f011910e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119111:	89 d0                	mov    %edx,%eax
f0119113:	c1 e0 02             	shl    $0x2,%eax
f0119116:	01 d0                	add    %edx,%eax
f0119118:	01 c0                	add    %eax,%eax
f011911a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119120:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119123:	39 c2                	cmp    %eax,%edx
f0119125:	74 17                	je     f011913e <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0119127:	83 ec 04             	sub    $0x4,%esp
f011912a:	68 04 cf 12 f0       	push   $0xf012cf04
f011912f:	68 07 03 00 00       	push   $0x307
f0119134:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119139:	e8 fb 71 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011913e:	e8 62 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119143:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119146:	74 17                	je     f011915f <test_fastfirstfit+0x35e>
f0119148:	83 ec 04             	sub    $0x4,%esp
f011914b:	68 0c ce 12 f0       	push   $0xf012ce0c
f0119150:	68 08 03 00 00       	push   $0x308
f0119155:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011915a:	e8 da 71 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011915f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119162:	e8 9b 57 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119167:	29 c3                	sub    %eax,%ebx
f0119169:	89 da                	mov    %ebx,%edx
f011916b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011916e:	c1 e8 0c             	shr    $0xc,%eax
f0119171:	39 c2                	cmp    %eax,%edx
f0119173:	73 17                	jae    f011918c <test_fastfirstfit+0x38b>
f0119175:	83 ec 04             	sub    $0x4,%esp
f0119178:	68 74 ce 12 f0       	push   $0xf012ce74
f011917d:	68 09 03 00 00       	push   $0x309
f0119182:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119187:	e8 ad 71 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f011918c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011918f:	01 c0                	add    %eax,%eax
f0119191:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119194:	e8 0c b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119199:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011919c:	e8 61 57 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01191a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01191a4:	83 ec 0c             	sub    $0xc,%esp
f01191a7:	ff 75 dc             	pushl  -0x24(%ebp)
f01191aa:	e8 7b 03 ff ff       	call   f010952a <kmalloc>
f01191af:	83 c4 10             	add    $0x10,%esp
f01191b2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f01191b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01191b8:	05 00 08 00 7c       	add    $0x7c000800,%eax
f01191bd:	01 c0                	add    %eax,%eax
f01191bf:	89 c2                	mov    %eax,%edx
f01191c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01191c4:	39 c2                	cmp    %eax,%edx
f01191c6:	74 17                	je     f01191df <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f01191c8:	83 ec 04             	sub    $0x4,%esp
f01191cb:	68 04 cf 12 f0       	push   $0xf012cf04
f01191d0:	68 13 03 00 00       	push   $0x313
f01191d5:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01191da:	e8 5a 71 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01191df:	e8 c1 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191e4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01191e7:	74 17                	je     f0119200 <test_fastfirstfit+0x3ff>
f01191e9:	83 ec 04             	sub    $0x4,%esp
f01191ec:	68 0c ce 12 f0       	push   $0xf012ce0c
f01191f1:	68 14 03 00 00       	push   $0x314
f01191f6:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01191fb:	e8 39 71 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119200:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119203:	e8 fa 56 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119208:	29 c3                	sub    %eax,%ebx
f011920a:	89 da                	mov    %ebx,%edx
f011920c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011920f:	c1 e8 0c             	shr    $0xc,%eax
f0119212:	39 c2                	cmp    %eax,%edx
f0119214:	73 17                	jae    f011922d <test_fastfirstfit+0x42c>
f0119216:	83 ec 04             	sub    $0x4,%esp
f0119219:	68 74 ce 12 f0       	push   $0xf012ce74
f011921e:	68 15 03 00 00       	push   $0x315
f0119223:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119228:	e8 0c 71 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f011922d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119230:	89 c2                	mov    %eax,%edx
f0119232:	01 d2                	add    %edx,%edx
f0119234:	01 d0                	add    %edx,%eax
f0119236:	d1 e8                	shr    %eax
f0119238:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011923b:	e8 65 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119240:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119243:	e8 ba 56 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119248:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011924b:	83 ec 0c             	sub    $0xc,%esp
f011924e:	ff 75 dc             	pushl  -0x24(%ebp)
f0119251:	e8 d4 02 ff ff       	call   f010952a <kmalloc>
f0119256:	83 c4 10             	add    $0x10,%esp
f0119259:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f011925c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011925f:	83 e8 03             	sub    $0x3,%eax
f0119262:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119266:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011926c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011926f:	39 c2                	cmp    %eax,%edx
f0119271:	74 17                	je     f011928a <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0119273:	83 ec 04             	sub    $0x4,%esp
f0119276:	68 04 cf 12 f0       	push   $0xf012cf04
f011927b:	68 1f 03 00 00       	push   $0x31f
f0119280:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119285:	e8 af 70 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011928a:	e8 16 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011928f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119292:	74 17                	je     f01192ab <test_fastfirstfit+0x4aa>
f0119294:	83 ec 04             	sub    $0x4,%esp
f0119297:	68 0c ce 12 f0       	push   $0xf012ce0c
f011929c:	68 20 03 00 00       	push   $0x320
f01192a1:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01192a6:	e8 8e 70 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01192ab:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01192ae:	e8 4f 56 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01192b3:	29 c3                	sub    %eax,%ebx
f01192b5:	89 da                	mov    %ebx,%edx
f01192b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01192ba:	c1 e8 0c             	shr    $0xc,%eax
f01192bd:	39 c2                	cmp    %eax,%edx
f01192bf:	73 17                	jae    f01192d8 <test_fastfirstfit+0x4d7>
f01192c1:	83 ec 04             	sub    $0x4,%esp
f01192c4:	68 74 ce 12 f0       	push   $0xf012ce74
f01192c9:	68 21 03 00 00       	push   $0x321
f01192ce:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01192d3:	e8 61 70 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01192d8:	e8 c8 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01192e0:	e8 1d 56 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01192e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01192e8:	83 ec 0c             	sub    $0xc,%esp
f01192eb:	ff 75 e4             	pushl  -0x1c(%ebp)
f01192ee:	e8 37 02 ff ff       	call   f010952a <kmalloc>
f01192f3:	83 c4 10             	add    $0x10,%esp
f01192f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f01192f9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01192fc:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119301:	74 17                	je     f011931a <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0119303:	83 ec 04             	sub    $0x4,%esp
f0119306:	68 04 cf 12 f0       	push   $0xf012cf04
f011930b:	68 2a 03 00 00       	push   $0x32a
f0119310:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119315:	e8 1f 70 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011931a:	e8 86 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011931f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119322:	74 17                	je     f011933b <test_fastfirstfit+0x53a>
f0119324:	83 ec 04             	sub    $0x4,%esp
f0119327:	68 0c ce 12 f0       	push   $0xf012ce0c
f011932c:	68 2b 03 00 00       	push   $0x32b
f0119331:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119336:	e8 fe 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011933b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011933e:	e8 bf 55 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119343:	29 c3                	sub    %eax,%ebx
f0119345:	89 da                	mov    %ebx,%edx
f0119347:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011934a:	c1 e8 0c             	shr    $0xc,%eax
f011934d:	39 c2                	cmp    %eax,%edx
f011934f:	73 17                	jae    f0119368 <test_fastfirstfit+0x567>
f0119351:	83 ec 04             	sub    $0x4,%esp
f0119354:	68 74 ce 12 f0       	push   $0xf012ce74
f0119359:	68 2c 03 00 00       	push   $0x32c
f011935e:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119363:	e8 d1 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119368:	e8 38 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011936d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119370:	e8 8d 55 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119375:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119378:	83 ec 0c             	sub    $0xc,%esp
f011937b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011937e:	e8 a7 01 ff ff       	call   f010952a <kmalloc>
f0119383:	83 c4 10             	add    $0x10,%esp
f0119386:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0119389:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011938c:	89 d0                	mov    %edx,%eax
f011938e:	c1 e0 02             	shl    $0x2,%eax
f0119391:	01 d0                	add    %edx,%eax
f0119393:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119399:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011939c:	39 c2                	cmp    %eax,%edx
f011939e:	74 17                	je     f01193b7 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f01193a0:	83 ec 04             	sub    $0x4,%esp
f01193a3:	68 04 cf 12 f0       	push   $0xf012cf04
f01193a8:	68 35 03 00 00       	push   $0x335
f01193ad:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01193b2:	e8 82 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01193b7:	e8 e9 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01193bc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01193bf:	74 17                	je     f01193d8 <test_fastfirstfit+0x5d7>
f01193c1:	83 ec 04             	sub    $0x4,%esp
f01193c4:	68 0c ce 12 f0       	push   $0xf012ce0c
f01193c9:	68 36 03 00 00       	push   $0x336
f01193ce:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01193d3:	e8 61 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01193d8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01193db:	e8 22 55 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01193e0:	29 c3                	sub    %eax,%ebx
f01193e2:	89 da                	mov    %ebx,%edx
f01193e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01193e7:	c1 e8 0c             	shr    $0xc,%eax
f01193ea:	39 c2                	cmp    %eax,%edx
f01193ec:	73 17                	jae    f0119405 <test_fastfirstfit+0x604>
f01193ee:	83 ec 04             	sub    $0x4,%esp
f01193f1:	68 74 ce 12 f0       	push   $0xf012ce74
f01193f6:	68 37 03 00 00       	push   $0x337
f01193fb:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119400:	e8 34 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119405:	e8 9b b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011940a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011940d:	e8 f0 54 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119412:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119415:	83 ec 0c             	sub    $0xc,%esp
f0119418:	ff 75 e4             	pushl  -0x1c(%ebp)
f011941b:	e8 0a 01 ff ff       	call   f010952a <kmalloc>
f0119420:	83 c4 10             	add    $0x10,%esp
f0119423:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0119426:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119429:	89 d0                	mov    %edx,%eax
f011942b:	c1 e0 02             	shl    $0x2,%eax
f011942e:	01 d0                	add    %edx,%eax
f0119430:	c1 e0 02             	shl    $0x2,%eax
f0119433:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119439:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011943c:	39 c2                	cmp    %eax,%edx
f011943e:	74 17                	je     f0119457 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0119440:	83 ec 04             	sub    $0x4,%esp
f0119443:	68 04 cf 12 f0       	push   $0xf012cf04
f0119448:	68 40 03 00 00       	push   $0x340
f011944d:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119452:	e8 e2 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119457:	e8 49 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011945c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011945f:	74 17                	je     f0119478 <test_fastfirstfit+0x677>
f0119461:	83 ec 04             	sub    $0x4,%esp
f0119464:	68 0c ce 12 f0       	push   $0xf012ce0c
f0119469:	68 41 03 00 00       	push   $0x341
f011946e:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119473:	e8 c1 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119478:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011947b:	e8 82 54 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119480:	29 c3                	sub    %eax,%ebx
f0119482:	89 da                	mov    %ebx,%edx
f0119484:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119487:	c1 e8 0c             	shr    $0xc,%eax
f011948a:	39 c2                	cmp    %eax,%edx
f011948c:	73 17                	jae    f01194a5 <test_fastfirstfit+0x6a4>
f011948e:	83 ec 04             	sub    $0x4,%esp
f0119491:	68 74 ce 12 f0       	push   $0xf012ce74
f0119496:	68 42 03 00 00       	push   $0x342
f011949b:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01194a0:	e8 94 6e fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01194a5:	e8 fb b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01194ad:	e8 50 54 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01194b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01194b5:	83 ec 0c             	sub    $0xc,%esp
f01194b8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01194bb:	e8 6a 00 ff ff       	call   f010952a <kmalloc>
f01194c0:	83 c4 10             	add    $0x10,%esp
f01194c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f01194c6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01194c9:	89 d0                	mov    %edx,%eax
f01194cb:	c1 e0 02             	shl    $0x2,%eax
f01194ce:	01 d0                	add    %edx,%eax
f01194d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01194d7:	01 d0                	add    %edx,%eax
f01194d9:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01194df:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01194e2:	39 c2                	cmp    %eax,%edx
f01194e4:	74 17                	je     f01194fd <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f01194e6:	83 ec 04             	sub    $0x4,%esp
f01194e9:	68 04 cf 12 f0       	push   $0xf012cf04
f01194ee:	68 4b 03 00 00       	push   $0x34b
f01194f3:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01194f8:	e8 3c 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01194fd:	e8 a3 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119502:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119505:	74 17                	je     f011951e <test_fastfirstfit+0x71d>
f0119507:	83 ec 04             	sub    $0x4,%esp
f011950a:	68 0c ce 12 f0       	push   $0xf012ce0c
f011950f:	68 4c 03 00 00       	push   $0x34c
f0119514:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119519:	e8 1b 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011951e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119521:	e8 dc 53 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119526:	29 c3                	sub    %eax,%ebx
f0119528:	89 da                	mov    %ebx,%edx
f011952a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011952d:	c1 e8 0c             	shr    $0xc,%eax
f0119530:	39 c2                	cmp    %eax,%edx
f0119532:	73 17                	jae    f011954b <test_fastfirstfit+0x74a>
f0119534:	83 ec 04             	sub    $0x4,%esp
f0119537:	68 74 ce 12 f0       	push   $0xf012ce74
f011953c:	68 4d 03 00 00       	push   $0x34d
f0119541:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119546:	e8 ee 6d fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f011954b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011954e:	d1 e8                	shr    %eax
f0119550:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119553:	e8 4d b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119558:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011955b:	e8 a2 53 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119560:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119563:	83 ec 0c             	sub    $0xc,%esp
f0119566:	ff 75 dc             	pushl  -0x24(%ebp)
f0119569:	e8 bc ff fe ff       	call   f010952a <kmalloc>
f011956e:	83 c4 10             	add    $0x10,%esp
f0119571:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0119574:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119577:	89 d0                	mov    %edx,%eax
f0119579:	c1 e0 02             	shl    $0x2,%eax
f011957c:	01 d0                	add    %edx,%eax
f011957e:	01 c0                	add    %eax,%eax
f0119580:	89 c1                	mov    %eax,%ecx
f0119582:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119585:	89 d0                	mov    %edx,%eax
f0119587:	c1 e0 02             	shl    $0x2,%eax
f011958a:	01 d0                	add    %edx,%eax
f011958c:	d1 e8                	shr    %eax
f011958e:	01 c8                	add    %ecx,%eax
f0119590:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119596:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119599:	39 c2                	cmp    %eax,%edx
f011959b:	74 17                	je     f01195b4 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f011959d:	83 ec 04             	sub    $0x4,%esp
f01195a0:	68 04 cf 12 f0       	push   $0xf012cf04
f01195a5:	68 57 03 00 00       	push   $0x357
f01195aa:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01195af:	e8 85 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01195b4:	e8 ec b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195b9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195bc:	74 17                	je     f01195d5 <test_fastfirstfit+0x7d4>
f01195be:	83 ec 04             	sub    $0x4,%esp
f01195c1:	68 0c ce 12 f0       	push   $0xf012ce0c
f01195c6:	68 58 03 00 00       	push   $0x358
f01195cb:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01195d0:	e8 64 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01195d5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01195d8:	e8 25 53 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01195dd:	29 c3                	sub    %eax,%ebx
f01195df:	89 da                	mov    %ebx,%edx
f01195e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01195e4:	c1 e8 0c             	shr    $0xc,%eax
f01195e7:	39 c2                	cmp    %eax,%edx
f01195e9:	73 17                	jae    f0119602 <test_fastfirstfit+0x801>
f01195eb:	83 ec 04             	sub    $0x4,%esp
f01195ee:	68 74 ce 12 f0       	push   $0xf012ce74
f01195f3:	68 59 03 00 00       	push   $0x359
f01195f8:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01195fd:	e8 37 6d fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119602:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119605:	d1 e8                	shr    %eax
f0119607:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011960a:	e8 96 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011960f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119612:	e8 eb 52 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119617:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011961a:	83 ec 0c             	sub    $0xc,%esp
f011961d:	ff 75 dc             	pushl  -0x24(%ebp)
f0119620:	e8 05 ff fe ff       	call   f010952a <kmalloc>
f0119625:	83 c4 10             	add    $0x10,%esp
f0119628:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f011962b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011962e:	83 e8 03             	sub    $0x3,%eax
f0119631:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119635:	89 c2                	mov    %eax,%edx
f0119637:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011963a:	89 c1                	mov    %eax,%ecx
f011963c:	01 c9                	add    %ecx,%ecx
f011963e:	01 c8                	add    %ecx,%eax
f0119640:	d1 e8                	shr    %eax
f0119642:	01 d0                	add    %edx,%eax
f0119644:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011964a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011964d:	39 c2                	cmp    %eax,%edx
f011964f:	74 17                	je     f0119668 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0119651:	83 ec 04             	sub    $0x4,%esp
f0119654:	68 04 cf 12 f0       	push   $0xf012cf04
f0119659:	68 63 03 00 00       	push   $0x363
f011965e:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119663:	e8 d1 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119668:	e8 38 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011966d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119670:	74 17                	je     f0119689 <test_fastfirstfit+0x888>
f0119672:	83 ec 04             	sub    $0x4,%esp
f0119675:	68 0c ce 12 f0       	push   $0xf012ce0c
f011967a:	68 64 03 00 00       	push   $0x364
f011967f:	68 f3 cd 12 f0       	push   $0xf012cdf3
f0119684:	e8 b0 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119689:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011968c:	e8 71 52 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119691:	29 c3                	sub    %eax,%ebx
f0119693:	89 da                	mov    %ebx,%edx
f0119695:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119698:	c1 e8 0c             	shr    $0xc,%eax
f011969b:	39 c2                	cmp    %eax,%edx
f011969d:	73 17                	jae    f01196b6 <test_fastfirstfit+0x8b5>
f011969f:	83 ec 04             	sub    $0x4,%esp
f01196a2:	68 74 ce 12 f0       	push   $0xf012ce74
f01196a7:	68 65 03 00 00       	push   $0x365
f01196ac:	68 f3 cd 12 f0       	push   $0xf012cdf3
f01196b1:	e8 83 6c fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f01196b6:	83 ec 0c             	sub    $0xc,%esp
f01196b9:	68 24 cf 12 f0       	push   $0xf012cf24
f01196be:	e8 c8 78 fe ff       	call   f0100f8b <cprintf>
f01196c3:	83 c4 10             	add    $0x10,%esp
	return 1;
f01196c6:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01196cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01196ce:	c9                   	leave  
f01196cf:	c3                   	ret    

f01196d0 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f01196d0:	55                   	push   %ebp
f01196d1:	89 e5                	mov    %esp,%ebp
f01196d3:	57                   	push   %edi
f01196d4:	53                   	push   %ebx
f01196d5:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01196db:	83 ec 0c             	sub    $0xc,%esp
f01196de:	68 a8 ae 12 f0       	push   $0xf012aea8
f01196e3:	e8 a3 78 fe ff       	call   f0100f8b <cprintf>
f01196e8:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01196eb:	83 ec 0c             	sub    $0xc,%esp
f01196ee:	68 d8 ae 12 f0       	push   $0xf012aed8
f01196f3:	e8 93 78 fe ff       	call   f0100f8b <cprintf>
f01196f8:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01196fb:	83 ec 0c             	sub    $0xc,%esp
f01196fe:	68 a8 ae 12 f0       	push   $0xf012aea8
f0119703:	e8 83 78 fe ff       	call   f0100f8b <cprintf>
f0119708:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011970b:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011970f:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0119713:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f0119719:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f011971f:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119726:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011972d:	e8 d0 51 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119732:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0119735:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f011973b:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119740:	b8 00 00 00 00       	mov    $0x0,%eax
f0119745:	89 d7                	mov    %edx,%edi
f0119747:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119749:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011974f:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119754:	b8 00 00 00 00       	mov    $0x0,%eax
f0119759:	89 d7                	mov    %edx,%edi
f011975b:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011975d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119764:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011976b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0119772:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119778:	b9 14 00 00 00       	mov    $0x14,%ecx
f011977d:	b8 00 00 00 00       	mov    $0x0,%eax
f0119782:	89 d7                	mov    %edx,%edi
f0119784:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119786:	83 ec 0c             	sub    $0xc,%esp
f0119789:	68 68 cf 12 f0       	push   $0xf012cf68
f011978e:	e8 f8 77 fe ff       	call   f0100f8b <cprintf>
f0119793:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119796:	e8 67 51 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011979b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011979e:	e8 02 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197a3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01197a6:	83 ec 0c             	sub    $0xc,%esp
f01197a9:	68 00 fc 1f 00       	push   $0x1ffc00
f01197ae:	e8 77 fd fe ff       	call   f010952a <kmalloc>
f01197b3:	83 c4 10             	add    $0x10,%esp
f01197b6:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01197bc:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f01197c2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01197c7:	74 17                	je     f01197e0 <test_kfree_bestfirstfit+0x110>
f01197c9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197d0:	83 ec 0c             	sub    $0xc,%esp
f01197d3:	68 a0 cf 12 f0       	push   $0xf012cfa0
f01197d8:	e8 ae 77 fe ff       	call   f0100f8b <cprintf>
f01197dd:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01197e0:	e8 c0 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197e5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01197e8:	74 17                	je     f0119801 <test_kfree_bestfirstfit+0x131>
f01197ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197f1:	83 ec 0c             	sub    $0xc,%esp
f01197f4:	68 f4 cf 12 f0       	push   $0xf012cff4
f01197f9:	e8 8d 77 fe ff       	call   f0100f8b <cprintf>
f01197fe:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119801:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119804:	e8 f9 50 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119809:	29 c3                	sub    %eax,%ebx
f011980b:	89 d8                	mov    %ebx,%eax
f011980d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119812:	77 17                	ja     f011982b <test_kfree_bestfirstfit+0x15b>
f0119814:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011981b:	83 ec 0c             	sub    $0xc,%esp
f011981e:	68 64 d0 12 f0       	push   $0xf012d064
f0119823:	e8 63 77 fe ff       	call   f0100f8b <cprintf>
f0119828:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011982b:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0119832:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119835:	e8 c8 50 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011983a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011983d:	e8 63 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119842:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119845:	83 ec 0c             	sub    $0xc,%esp
f0119848:	68 00 fc 1f 00       	push   $0x1ffc00
f011984d:	e8 d8 fc fe ff       	call   f010952a <kmalloc>
f0119852:	83 c4 10             	add    $0x10,%esp
f0119855:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011985b:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119861:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119866:	74 17                	je     f011987f <test_kfree_bestfirstfit+0x1af>
f0119868:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011986f:	83 ec 0c             	sub    $0xc,%esp
f0119872:	68 ac d0 12 f0       	push   $0xf012d0ac
f0119877:	e8 0f 77 fe ff       	call   f0100f8b <cprintf>
f011987c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011987f:	e8 21 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119884:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119887:	74 17                	je     f01198a0 <test_kfree_bestfirstfit+0x1d0>
f0119889:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119890:	83 ec 0c             	sub    $0xc,%esp
f0119893:	68 00 d1 12 f0       	push   $0xf012d100
f0119898:	e8 ee 76 fe ff       	call   f0100f8b <cprintf>
f011989d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01198a0:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01198a3:	e8 5a 50 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01198a8:	29 c3                	sub    %eax,%ebx
f01198aa:	89 d8                	mov    %ebx,%eax
f01198ac:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01198b1:	77 17                	ja     f01198ca <test_kfree_bestfirstfit+0x1fa>
f01198b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198ba:	83 ec 0c             	sub    $0xc,%esp
f01198bd:	68 70 d1 12 f0       	push   $0xf012d170
f01198c2:	e8 c4 76 fe ff       	call   f0100f8b <cprintf>
f01198c7:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f01198ca:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f01198d1:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f01198d4:	e8 29 50 ff ff       	call   f010e902 <sys_calculate_free_frames>
f01198d9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01198dc:	e8 c4 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198e1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f01198e4:	83 ec 0c             	sub    $0xc,%esp
f01198e7:	68 00 1c 00 00       	push   $0x1c00
f01198ec:	e8 39 fc fe ff       	call   f010952a <kmalloc>
f01198f1:	83 c4 10             	add    $0x10,%esp
f01198f4:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01198fa:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119900:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119905:	74 17                	je     f011991e <test_kfree_bestfirstfit+0x24e>
f0119907:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011990e:	83 ec 0c             	sub    $0xc,%esp
f0119911:	68 b8 d1 12 f0       	push   $0xf012d1b8
f0119916:	e8 70 76 fe ff       	call   f0100f8b <cprintf>
f011991b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011991e:	e8 82 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119923:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119926:	74 17                	je     f011993f <test_kfree_bestfirstfit+0x26f>
f0119928:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011992f:	83 ec 0c             	sub    $0xc,%esp
f0119932:	68 0c d2 12 f0       	push   $0xf012d20c
f0119937:	e8 4f 76 fe ff       	call   f0100f8b <cprintf>
f011993c:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011993f:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119942:	e8 bb 4f ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119947:	29 c3                	sub    %eax,%ebx
f0119949:	89 d8                	mov    %ebx,%eax
f011994b:	83 f8 01             	cmp    $0x1,%eax
f011994e:	77 17                	ja     f0119967 <test_kfree_bestfirstfit+0x297>
f0119950:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119957:	83 ec 0c             	sub    $0xc,%esp
f011995a:	68 7c d2 12 f0       	push   $0xf012d27c
f011995f:	e8 27 76 fe ff       	call   f0100f8b <cprintf>
f0119964:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119967:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f011996e:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0119971:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119977:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011997a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119981:	eb 0e                	jmp    f0119991 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0119983:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119986:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119989:	01 d0                	add    %edx,%eax
f011998b:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011998e:	ff 45 f4             	incl   -0xc(%ebp)
f0119991:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119997:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011999a:	7f e7                	jg     f0119983 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f011999c:	e8 61 4f ff ff       	call   f010e902 <sys_calculate_free_frames>
f01199a1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01199a4:	e8 fc ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01199a9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f01199ac:	83 ec 0c             	sub    $0xc,%esp
f01199af:	68 00 fc 2f 00       	push   $0x2ffc00
f01199b4:	e8 71 fb fe ff       	call   f010952a <kmalloc>
f01199b9:	83 c4 10             	add    $0x10,%esp
f01199bc:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01199c2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01199c8:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01199cd:	74 17                	je     f01199e6 <test_kfree_bestfirstfit+0x316>
f01199cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199d6:	83 ec 0c             	sub    $0xc,%esp
f01199d9:	68 c4 d2 12 f0       	push   $0xf012d2c4
f01199de:	e8 a8 75 fe ff       	call   f0100f8b <cprintf>
f01199e3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01199e6:	e8 ba ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01199eb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01199ee:	74 17                	je     f0119a07 <test_kfree_bestfirstfit+0x337>
f01199f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199f7:	83 ec 0c             	sub    $0xc,%esp
f01199fa:	68 18 d3 12 f0       	push   $0xf012d318
f01199ff:	e8 87 75 fe ff       	call   f0100f8b <cprintf>
f0119a04:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119a07:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119a0a:	e8 f3 4e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119a0f:	29 c3                	sub    %eax,%ebx
f0119a11:	89 d8                	mov    %ebx,%eax
f0119a13:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119a18:	77 17                	ja     f0119a31 <test_kfree_bestfirstfit+0x361>
f0119a1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a21:	83 ec 0c             	sub    $0xc,%esp
f0119a24:	68 88 d3 12 f0       	push   $0xf012d388
f0119a29:	e8 5d 75 fe ff       	call   f0100f8b <cprintf>
f0119a2e:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0119a31:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119a38:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119a3b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119a41:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119a44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a4b:	eb 0e                	jmp    f0119a5b <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119a4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a50:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a53:	01 d0                	add    %edx,%eax
f0119a55:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119a58:	ff 45 f4             	incl   -0xc(%ebp)
f0119a5b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119a61:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a64:	7f e7                	jg     f0119a4d <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119a66:	e8 97 4e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119a6b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119a6e:	e8 32 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a73:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119a76:	83 ec 0c             	sub    $0xc,%esp
f0119a79:	68 00 fc 5f 00       	push   $0x5ffc00
f0119a7e:	e8 a7 fa fe ff       	call   f010952a <kmalloc>
f0119a83:	83 c4 10             	add    $0x10,%esp
f0119a86:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a8c:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119a92:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119a97:	74 17                	je     f0119ab0 <test_kfree_bestfirstfit+0x3e0>
f0119a99:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aa0:	83 ec 0c             	sub    $0xc,%esp
f0119aa3:	68 d0 d3 12 f0       	push   $0xf012d3d0
f0119aa8:	e8 de 74 fe ff       	call   f0100f8b <cprintf>
f0119aad:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ab0:	e8 f0 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ab5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119ab8:	74 17                	je     f0119ad1 <test_kfree_bestfirstfit+0x401>
f0119aba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ac1:	83 ec 0c             	sub    $0xc,%esp
f0119ac4:	68 24 d4 12 f0       	push   $0xf012d424
f0119ac9:	e8 bd 74 fe ff       	call   f0100f8b <cprintf>
f0119ace:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119ad1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119ad4:	e8 29 4e ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119ad9:	29 c3                	sub    %eax,%ebx
f0119adb:	89 d8                	mov    %ebx,%eax
f0119add:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119ae2:	77 17                	ja     f0119afb <test_kfree_bestfirstfit+0x42b>
f0119ae4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aeb:	83 ec 0c             	sub    $0xc,%esp
f0119aee:	68 94 d4 12 f0       	push   $0xf012d494
f0119af3:	e8 93 74 fe ff       	call   f0100f8b <cprintf>
f0119af8:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119afb:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119b02:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119b05:	e8 f8 4d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119b0a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b0d:	e8 93 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b12:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119b15:	83 ec 0c             	sub    $0xc,%esp
f0119b18:	68 00 38 00 00       	push   $0x3800
f0119b1d:	e8 08 fa fe ff       	call   f010952a <kmalloc>
f0119b22:	83 c4 10             	add    $0x10,%esp
f0119b25:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b2b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119b31:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119b36:	74 17                	je     f0119b4f <test_kfree_bestfirstfit+0x47f>
f0119b38:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b3f:	83 ec 0c             	sub    $0xc,%esp
f0119b42:	68 dc d4 12 f0       	push   $0xf012d4dc
f0119b47:	e8 3f 74 fe ff       	call   f0100f8b <cprintf>
f0119b4c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b4f:	e8 51 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b54:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b57:	74 17                	je     f0119b70 <test_kfree_bestfirstfit+0x4a0>
f0119b59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b60:	83 ec 0c             	sub    $0xc,%esp
f0119b63:	68 30 d5 12 f0       	push   $0xf012d530
f0119b68:	e8 1e 74 fe ff       	call   f0100f8b <cprintf>
f0119b6d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b70:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b73:	e8 8a 4d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119b78:	29 c3                	sub    %eax,%ebx
f0119b7a:	89 d8                	mov    %ebx,%eax
f0119b7c:	83 f8 03             	cmp    $0x3,%eax
f0119b7f:	77 17                	ja     f0119b98 <test_kfree_bestfirstfit+0x4c8>
f0119b81:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b88:	83 ec 0c             	sub    $0xc,%esp
f0119b8b:	68 a0 d5 12 f0       	push   $0xf012d5a0
f0119b90:	e8 f6 73 fe ff       	call   f0100f8b <cprintf>
f0119b95:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119b98:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119b9f:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119ba5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119ba8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119baf:	eb 0e                	jmp    f0119bbf <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119bb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119bb4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119bb7:	01 d0                	add    %edx,%eax
f0119bb9:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119bbc:	ff 45 f4             	incl   -0xc(%ebp)
f0119bbf:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119bc2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119bc5:	7f ea                	jg     f0119bb1 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119bc7:	e8 36 4d ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119bcc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119bcf:	e8 d1 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bd4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119bd7:	83 ec 0c             	sub    $0xc,%esp
f0119bda:	68 00 08 00 00       	push   $0x800
f0119bdf:	e8 46 f9 fe ff       	call   f010952a <kmalloc>
f0119be4:	83 c4 10             	add    $0x10,%esp
f0119be7:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119bed:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119bf3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119bf8:	76 28                	jbe    f0119c22 <test_kfree_bestfirstfit+0x552>
f0119bfa:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0119c00:	83 ec 0c             	sub    $0xc,%esp
f0119c03:	6a 00                	push   $0x0
f0119c05:	e8 ed f7 fe ff       	call   f01093f7 <sbrk>
f0119c0a:	83 c4 10             	add    $0x10,%esp
f0119c0d:	39 c3                	cmp    %eax,%ebx
f0119c0f:	73 11                	jae    f0119c22 <test_kfree_bestfirstfit+0x552>
f0119c11:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119c17:	89 c2                	mov    %eax,%edx
f0119c19:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119c1e:	39 c2                	cmp    %eax,%edx
f0119c20:	72 17                	jb     f0119c39 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119c22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c29:	83 ec 0c             	sub    $0xc,%esp
f0119c2c:	68 e8 d5 12 f0       	push   $0xf012d5e8
f0119c31:	e8 55 73 fe ff       	call   f0100f8b <cprintf>
f0119c36:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c39:	e8 67 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c3e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c41:	74 17                	je     f0119c5a <test_kfree_bestfirstfit+0x58a>
f0119c43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c4a:	83 ec 0c             	sub    $0xc,%esp
f0119c4d:	68 74 d6 12 f0       	push   $0xf012d674
f0119c52:	e8 34 73 fe ff       	call   f0100f8b <cprintf>
f0119c57:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119c5a:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119c61:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119c64:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119c6a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119c6d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c74:	eb 0e                	jmp    f0119c84 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119c76:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c7c:	01 d0                	add    %edx,%eax
f0119c7e:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119c81:	ff 45 f4             	incl   -0xc(%ebp)
f0119c84:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119c8a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c8d:	7f e7                	jg     f0119c76 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c8f:	e8 11 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c94:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119c97:	83 ec 0c             	sub    $0xc,%esp
f0119c9a:	68 00 08 00 00       	push   $0x800
f0119c9f:	e8 86 f8 fe ff       	call   f010952a <kmalloc>
f0119ca4:	83 c4 10             	add    $0x10,%esp
f0119ca7:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119cad:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119cb3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119cb8:	76 28                	jbe    f0119ce2 <test_kfree_bestfirstfit+0x612>
f0119cba:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0119cc0:	83 ec 0c             	sub    $0xc,%esp
f0119cc3:	6a 00                	push   $0x0
f0119cc5:	e8 2d f7 fe ff       	call   f01093f7 <sbrk>
f0119cca:	83 c4 10             	add    $0x10,%esp
f0119ccd:	39 c3                	cmp    %eax,%ebx
f0119ccf:	73 11                	jae    f0119ce2 <test_kfree_bestfirstfit+0x612>
f0119cd1:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119cd7:	89 c2                	mov    %eax,%edx
f0119cd9:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119cde:	39 c2                	cmp    %eax,%edx
f0119ce0:	72 17                	jb     f0119cf9 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119ce2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ce9:	83 ec 0c             	sub    $0xc,%esp
f0119cec:	68 e4 d6 12 f0       	push   $0xf012d6e4
f0119cf1:	e8 95 72 fe ff       	call   f0100f8b <cprintf>
f0119cf6:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119cf9:	e8 a7 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119cfe:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d01:	74 17                	je     f0119d1a <test_kfree_bestfirstfit+0x64a>
f0119d03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d0a:	83 ec 0c             	sub    $0xc,%esp
f0119d0d:	68 70 d7 12 f0       	push   $0xf012d770
f0119d12:	e8 74 72 fe ff       	call   f0100f8b <cprintf>
f0119d17:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0119d1a:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0119d21:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0119d24:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119d2a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0119d2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119d34:	eb 0e                	jmp    f0119d44 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0119d36:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d39:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119d3c:	01 d0                	add    %edx,%eax
f0119d3e:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0119d41:	ff 45 f4             	incl   -0xc(%ebp)
f0119d44:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119d4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119d4d:	7f e7                	jg     f0119d36 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0119d4f:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119d52:	e8 ab 4b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119d57:	29 c3                	sub    %eax,%ebx
f0119d59:	89 d8                	mov    %ebx,%eax
f0119d5b:	83 f8 01             	cmp    $0x1,%eax
f0119d5e:	74 17                	je     f0119d77 <test_kfree_bestfirstfit+0x6a7>
f0119d60:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d67:	83 ec 0c             	sub    $0xc,%esp
f0119d6a:	68 e0 d7 12 f0       	push   $0xf012d7e0
f0119d6f:	e8 17 72 fe ff       	call   f0100f8b <cprintf>
f0119d74:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0119d77:	83 ec 0c             	sub    $0xc,%esp
f0119d7a:	68 04 d8 12 f0       	push   $0xf012d804
f0119d7f:	e8 07 72 fe ff       	call   f0100f8b <cprintf>
f0119d84:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0119d87:	e8 76 4b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119d8c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0119d8f:	e8 11 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d94:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0119d97:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119d9d:	83 ec 0c             	sub    $0xc,%esp
f0119da0:	50                   	push   %eax
f0119da1:	e8 e4 f9 fe ff       	call   f010978a <kfree>
f0119da6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119da9:	e8 f7 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119dae:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119db1:	74 17                	je     f0119dca <test_kfree_bestfirstfit+0x6fa>
f0119db3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dba:	83 ec 0c             	sub    $0xc,%esp
f0119dbd:	68 34 d8 12 f0       	push   $0xf012d834
f0119dc2:	e8 c4 71 fe ff       	call   f0100f8b <cprintf>
f0119dc7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119dca:	e8 33 4b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119dcf:	89 c2                	mov    %eax,%edx
f0119dd1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119dd4:	29 c2                	sub    %eax,%edx
f0119dd6:	89 d0                	mov    %edx,%eax
f0119dd8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119ddd:	77 17                	ja     f0119df6 <test_kfree_bestfirstfit+0x726>
f0119ddf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119de6:	83 ec 0c             	sub    $0xc,%esp
f0119de9:	68 a4 d8 12 f0       	push   $0xf012d8a4
f0119dee:	e8 98 71 fe ff       	call   f0100f8b <cprintf>
f0119df3:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f0119df6:	e8 07 4b ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119dfb:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119dfe:	e8 a2 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e03:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f0119e06:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119e0c:	83 ec 0c             	sub    $0xc,%esp
f0119e0f:	50                   	push   %eax
f0119e10:	e8 75 f9 fe ff       	call   f010978a <kfree>
f0119e15:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e18:	e8 88 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e1d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119e20:	74 17                	je     f0119e39 <test_kfree_bestfirstfit+0x769>
f0119e22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e29:	83 ec 0c             	sub    $0xc,%esp
f0119e2c:	68 e0 d8 12 f0       	push   $0xf012d8e0
f0119e31:	e8 55 71 fe ff       	call   f0100f8b <cprintf>
f0119e36:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119e39:	e8 c4 4a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119e3e:	89 c2                	mov    %eax,%edx
f0119e40:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119e43:	39 c2                	cmp    %eax,%edx
f0119e45:	74 17                	je     f0119e5e <test_kfree_bestfirstfit+0x78e>
f0119e47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e4e:	83 ec 0c             	sub    $0xc,%esp
f0119e51:	68 50 d9 12 f0       	push   $0xf012d950
f0119e56:	e8 30 71 fe ff       	call   f0100f8b <cprintf>
f0119e5b:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119e5e:	e8 9f 4a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119e63:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e66:	e8 3a aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e6b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0119e6e:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119e74:	83 ec 0c             	sub    $0xc,%esp
f0119e77:	50                   	push   %eax
f0119e78:	e8 0d f9 fe ff       	call   f010978a <kfree>
f0119e7d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e80:	e8 20 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e85:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119e88:	74 17                	je     f0119ea1 <test_kfree_bestfirstfit+0x7d1>
f0119e8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e91:	83 ec 0c             	sub    $0xc,%esp
f0119e94:	68 b0 d9 12 f0       	push   $0xf012d9b0
f0119e99:	e8 ed 70 fe ff       	call   f0100f8b <cprintf>
f0119e9e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119ea1:	e8 5c 4a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119ea6:	89 c2                	mov    %eax,%edx
f0119ea8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119eab:	29 c2                	sub    %eax,%edx
f0119ead:	89 d0                	mov    %edx,%eax
f0119eaf:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119eb4:	77 17                	ja     f0119ecd <test_kfree_bestfirstfit+0x7fd>
f0119eb6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ebd:	83 ec 0c             	sub    $0xc,%esp
f0119ec0:	68 20 da 12 f0       	push   $0xf012da20
f0119ec5:	e8 c1 70 fe ff       	call   f0100f8b <cprintf>
f0119eca:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0119ecd:	e8 30 4a ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119ed2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119ed5:	e8 cb a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119eda:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0119edd:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119ee3:	83 ec 0c             	sub    $0xc,%esp
f0119ee6:	50                   	push   %eax
f0119ee7:	e8 9e f8 fe ff       	call   f010978a <kfree>
f0119eec:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119eef:	e8 b1 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ef4:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119ef7:	74 17                	je     f0119f10 <test_kfree_bestfirstfit+0x840>
f0119ef9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f00:	83 ec 0c             	sub    $0xc,%esp
f0119f03:	68 5c da 12 f0       	push   $0xf012da5c
f0119f08:	e8 7e 70 fe ff       	call   f0100f8b <cprintf>
f0119f0d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f10:	e8 ed 49 ff ff       	call   f010e902 <sys_calculate_free_frames>
f0119f15:	89 c2                	mov    %eax,%edx
f0119f17:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119f1a:	29 c2                	sub    %eax,%edx
f0119f1c:	89 d0                	mov    %edx,%eax
f0119f1e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119f23:	77 17                	ja     f0119f3c <test_kfree_bestfirstfit+0x86c>
f0119f25:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f2c:	83 ec 0c             	sub    $0xc,%esp
f0119f2f:	68 cc da 12 f0       	push   $0xf012dacc
f0119f34:	e8 52 70 fe ff       	call   f0100f8b <cprintf>
f0119f39:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119f3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119f40:	74 04                	je     f0119f46 <test_kfree_bestfirstfit+0x876>
f0119f42:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119f46:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0119f4d:	83 ec 0c             	sub    $0xc,%esp
f0119f50:	68 08 db 12 f0       	push   $0xf012db08
f0119f55:	e8 31 70 fe ff       	call   f0100f8b <cprintf>
f0119f5a:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0119f5d:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119f63:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0119f66:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f6d:	eb 1e                	jmp    f0119f8d <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0119f6f:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119f75:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119f78:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119f7b:	01 c8                	add    %ecx,%eax
f0119f7d:	8a 00                	mov    (%eax),%al
f0119f7f:	0f be c0             	movsbl %al,%eax
f0119f82:	01 d0                	add    %edx,%eax
f0119f84:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0119f8a:	ff 45 f4             	incl   -0xc(%ebp)
f0119f8d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119f93:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119f96:	7f d7                	jg     f0119f6f <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0119f98:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119f9e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119fa4:	89 c1                	mov    %eax,%ecx
f0119fa6:	01 c9                	add    %ecx,%ecx
f0119fa8:	01 c8                	add    %ecx,%eax
f0119faa:	39 c2                	cmp    %eax,%edx
f0119fac:	74 17                	je     f0119fc5 <test_kfree_bestfirstfit+0x8f5>
f0119fae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fb5:	83 ec 0c             	sub    $0xc,%esp
f0119fb8:	68 50 db 12 f0       	push   $0xf012db50
f0119fbd:	e8 c9 6f fe ff       	call   f0100f8b <cprintf>
f0119fc2:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f0119fc5:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119fcb:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f0119fce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119fd5:	eb 1e                	jmp    f0119ff5 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f0119fd7:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f0119fdd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119fe0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fe3:	01 c8                	add    %ecx,%eax
f0119fe5:	8a 00                	mov    (%eax),%al
f0119fe7:	0f be c0             	movsbl %al,%eax
f0119fea:	01 d0                	add    %edx,%eax
f0119fec:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f0119ff2:	ff 45 f4             	incl   -0xc(%ebp)
f0119ff5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119ffb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119ffe:	7f d7                	jg     f0119fd7 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011a000:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a006:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011a00c:	c1 e2 02             	shl    $0x2,%edx
f011a00f:	39 d0                	cmp    %edx,%eax
f011a011:	74 17                	je     f011a02a <test_kfree_bestfirstfit+0x95a>
f011a013:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a01a:	83 ec 0c             	sub    $0xc,%esp
f011a01d:	68 88 db 12 f0       	push   $0xf012db88
f011a022:	e8 64 6f fe ff       	call   f0100f8b <cprintf>
f011a027:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011a02a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a030:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011a033:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a03a:	eb 1e                	jmp    f011a05a <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011a03c:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011a042:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a045:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a048:	01 c8                	add    %ecx,%eax
f011a04a:	8a 00                	mov    (%eax),%al
f011a04c:	0f be c0             	movsbl %al,%eax
f011a04f:	01 d0                	add    %edx,%eax
f011a051:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a057:	ff 45 f4             	incl   -0xc(%ebp)
f011a05a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a060:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a063:	7f d7                	jg     f011a03c <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a065:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a06b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a071:	89 d0                	mov    %edx,%eax
f011a073:	c1 e0 02             	shl    $0x2,%eax
f011a076:	01 d0                	add    %edx,%eax
f011a078:	39 c1                	cmp    %eax,%ecx
f011a07a:	74 17                	je     f011a093 <test_kfree_bestfirstfit+0x9c3>
f011a07c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a083:	83 ec 0c             	sub    $0xc,%esp
f011a086:	68 c0 db 12 f0       	push   $0xf012dbc0
f011a08b:	e8 fb 6e fe ff       	call   f0100f8b <cprintf>
f011a090:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a093:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a099:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a09c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a0a3:	eb 1e                	jmp    f011a0c3 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a0a5:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a0ab:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a0ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a0b1:	01 c8                	add    %ecx,%eax
f011a0b3:	8a 00                	mov    (%eax),%al
f011a0b5:	0f be c0             	movsbl %al,%eax
f011a0b8:	01 d0                	add    %edx,%eax
f011a0ba:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a0c0:	ff 45 f4             	incl   -0xc(%ebp)
f011a0c3:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a0c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a0c9:	7f da                	jg     f011a0a5 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a0cb:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a0d1:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a0d4:	89 d0                	mov    %edx,%eax
f011a0d6:	01 c0                	add    %eax,%eax
f011a0d8:	01 d0                	add    %edx,%eax
f011a0da:	01 c0                	add    %eax,%eax
f011a0dc:	01 d0                	add    %edx,%eax
f011a0de:	39 c1                	cmp    %eax,%ecx
f011a0e0:	74 17                	je     f011a0f9 <test_kfree_bestfirstfit+0xa29>
f011a0e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0e9:	83 ec 0c             	sub    $0xc,%esp
f011a0ec:	68 f8 db 12 f0       	push   $0xf012dbf8
f011a0f1:	e8 95 6e fe ff       	call   f0100f8b <cprintf>
f011a0f6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a0f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a0fd:	74 04                	je     f011a103 <test_kfree_bestfirstfit+0xa33>
f011a0ff:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a103:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a10a:	83 ec 0c             	sub    $0xc,%esp
f011a10d:	68 30 dc 12 f0       	push   $0xf012dc30
f011a112:	e8 74 6e fe ff       	call   f0100f8b <cprintf>
f011a117:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a11a:	e8 e3 47 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a11f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a122:	e8 7e a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a127:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a12a:	83 ec 0c             	sub    $0xc,%esp
f011a12d:	68 00 04 00 00       	push   $0x400
f011a132:	e8 f3 f3 fe ff       	call   f010952a <kmalloc>
f011a137:	83 c4 10             	add    $0x10,%esp
f011a13a:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a140:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a146:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a14c:	39 c2                	cmp    %eax,%edx
f011a14e:	74 17                	je     f011a167 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a150:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a157:	83 ec 0c             	sub    $0xc,%esp
f011a15a:	68 50 dc 12 f0       	push   $0xf012dc50
f011a15f:	e8 27 6e fe ff       	call   f0100f8b <cprintf>
f011a164:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a167:	e8 39 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a16c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a16f:	74 17                	je     f011a188 <test_kfree_bestfirstfit+0xab8>
f011a171:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a178:	83 ec 0c             	sub    $0xc,%esp
f011a17b:	68 a4 dc 12 f0       	push   $0xf012dca4
f011a180:	e8 06 6e fe ff       	call   f0100f8b <cprintf>
f011a185:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a188:	e8 75 47 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a18d:	89 c2                	mov    %eax,%edx
f011a18f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a192:	39 c2                	cmp    %eax,%edx
f011a194:	74 17                	je     f011a1ad <test_kfree_bestfirstfit+0xadd>
f011a196:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a19d:	83 ec 0c             	sub    $0xc,%esp
f011a1a0:	68 14 dd 12 f0       	push   $0xf012dd14
f011a1a5:	e8 e1 6d fe ff       	call   f0100f8b <cprintf>
f011a1aa:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a1ad:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a1b4:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a1ba:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a1bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a1c4:	eb 0e                	jmp    f011a1d4 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a1c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a1c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a1cc:	01 d0                	add    %edx,%eax
f011a1ce:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a1d1:	ff 45 f4             	incl   -0xc(%ebp)
f011a1d4:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a1d7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a1da:	7f ea                	jg     f011a1c6 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a1dc:	e8 21 47 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a1e1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1e4:	e8 bc a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a1e9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a1ec:	83 ec 0c             	sub    $0xc,%esp
f011a1ef:	68 00 00 30 00       	push   $0x300000
f011a1f4:	e8 31 f3 fe ff       	call   f010952a <kmalloc>
f011a1f9:	83 c4 10             	add    $0x10,%esp
f011a1fc:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a202:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a208:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a20d:	74 17                	je     f011a226 <test_kfree_bestfirstfit+0xb56>
f011a20f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a216:	83 ec 0c             	sub    $0xc,%esp
f011a219:	68 90 dd 12 f0       	push   $0xf012dd90
f011a21e:	e8 68 6d fe ff       	call   f0100f8b <cprintf>
f011a223:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a226:	e8 7a a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a22b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a22e:	74 17                	je     f011a247 <test_kfree_bestfirstfit+0xb77>
f011a230:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a237:	83 ec 0c             	sub    $0xc,%esp
f011a23a:	68 e4 dd 12 f0       	push   $0xf012dde4
f011a23f:	e8 47 6d fe ff       	call   f0100f8b <cprintf>
f011a244:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a247:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a24a:	e8 b3 46 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a24f:	29 c3                	sub    %eax,%ebx
f011a251:	89 d8                	mov    %ebx,%eax
f011a253:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a258:	77 17                	ja     f011a271 <test_kfree_bestfirstfit+0xba1>
f011a25a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a261:	83 ec 0c             	sub    $0xc,%esp
f011a264:	68 54 de 12 f0       	push   $0xf012de54
f011a269:	e8 1d 6d fe ff       	call   f0100f8b <cprintf>
f011a26e:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a271:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a278:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a27e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a281:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a288:	eb 0e                	jmp    f011a298 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a28a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a28d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a290:	01 d0                	add    %edx,%eax
f011a292:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a295:	ff 45 f4             	incl   -0xc(%ebp)
f011a298:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a29b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a29e:	7f ea                	jg     f011a28a <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a2a0:	e8 5d 46 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a2a5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a2a8:	e8 f8 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a2b0:	83 ec 0c             	sub    $0xc,%esp
f011a2b3:	68 00 00 10 00       	push   $0x100000
f011a2b8:	e8 6d f2 fe ff       	call   f010952a <kmalloc>
f011a2bd:	83 c4 10             	add    $0x10,%esp
f011a2c0:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a2c6:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a2cc:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a2d1:	74 17                	je     f011a2ea <test_kfree_bestfirstfit+0xc1a>
f011a2d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2da:	83 ec 0c             	sub    $0xc,%esp
f011a2dd:	68 9c de 12 f0       	push   $0xf012de9c
f011a2e2:	e8 a4 6c fe ff       	call   f0100f8b <cprintf>
f011a2e7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a2ea:	e8 b6 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2ef:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a2f2:	74 17                	je     f011a30b <test_kfree_bestfirstfit+0xc3b>
f011a2f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2fb:	83 ec 0c             	sub    $0xc,%esp
f011a2fe:	68 f0 de 12 f0       	push   $0xf012def0
f011a303:	e8 83 6c fe ff       	call   f0100f8b <cprintf>
f011a308:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a30b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a30e:	e8 ef 45 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a313:	29 c3                	sub    %eax,%ebx
f011a315:	89 d8                	mov    %ebx,%eax
f011a317:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a31c:	77 17                	ja     f011a335 <test_kfree_bestfirstfit+0xc65>
f011a31e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a325:	83 ec 0c             	sub    $0xc,%esp
f011a328:	68 60 df 12 f0       	push   $0xf012df60
f011a32d:	e8 59 6c fe ff       	call   f0100f8b <cprintf>
f011a332:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a335:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a33c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a342:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a345:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a34c:	eb 0e                	jmp    f011a35c <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a34e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a351:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a354:	01 d0                	add    %edx,%eax
f011a356:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a359:	ff 45 f4             	incl   -0xc(%ebp)
f011a35c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a35f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a362:	7f ea                	jg     f011a34e <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a364:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a368:	74 04                	je     f011a36e <test_kfree_bestfirstfit+0xc9e>
f011a36a:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a36e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a375:	83 ec 0c             	sub    $0xc,%esp
f011a378:	68 a8 df 12 f0       	push   $0xf012dfa8
f011a37d:	e8 09 6c fe ff       	call   f0100f8b <cprintf>
f011a382:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a385:	e8 78 45 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a38a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a38d:	e8 13 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a392:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a395:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a39b:	83 ec 0c             	sub    $0xc,%esp
f011a39e:	50                   	push   %eax
f011a39f:	e8 e6 f3 fe ff       	call   f010978a <kfree>
f011a3a4:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a3a7:	e8 f9 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a3ac:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3af:	74 17                	je     f011a3c8 <test_kfree_bestfirstfit+0xcf8>
f011a3b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3b8:	83 ec 0c             	sub    $0xc,%esp
f011a3bb:	68 d4 df 12 f0       	push   $0xf012dfd4
f011a3c0:	e8 c6 6b fe ff       	call   f0100f8b <cprintf>
f011a3c5:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a3c8:	e8 35 45 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a3cd:	89 c2                	mov    %eax,%edx
f011a3cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a3d2:	29 c2                	sub    %eax,%edx
f011a3d4:	89 d0                	mov    %edx,%eax
f011a3d6:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a3db:	77 17                	ja     f011a3f4 <test_kfree_bestfirstfit+0xd24>
f011a3dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3e4:	83 ec 0c             	sub    $0xc,%esp
f011a3e7:	68 44 e0 12 f0       	push   $0xf012e044
f011a3ec:	e8 9a 6b fe ff       	call   f0100f8b <cprintf>
f011a3f1:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a3f4:	e8 09 45 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a3f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a3fc:	e8 a4 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a401:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a404:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a40a:	83 ec 0c             	sub    $0xc,%esp
f011a40d:	50                   	push   %eax
f011a40e:	e8 77 f3 fe ff       	call   f010978a <kfree>
f011a413:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a416:	e8 8a a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a41b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a41e:	74 17                	je     f011a437 <test_kfree_bestfirstfit+0xd67>
f011a420:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a427:	83 ec 0c             	sub    $0xc,%esp
f011a42a:	68 80 e0 12 f0       	push   $0xf012e080
f011a42f:	e8 57 6b fe ff       	call   f0100f8b <cprintf>
f011a434:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a437:	e8 c6 44 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a43c:	89 c2                	mov    %eax,%edx
f011a43e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a441:	29 c2                	sub    %eax,%edx
f011a443:	89 d0                	mov    %edx,%eax
f011a445:	83 f8 01             	cmp    $0x1,%eax
f011a448:	77 17                	ja     f011a461 <test_kfree_bestfirstfit+0xd91>
f011a44a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a451:	83 ec 0c             	sub    $0xc,%esp
f011a454:	68 f0 e0 12 f0       	push   $0xf012e0f0
f011a459:	e8 2d 6b fe ff       	call   f0100f8b <cprintf>
f011a45e:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a461:	e8 9c 44 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a466:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a469:	e8 37 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a46e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a471:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a477:	83 ec 0c             	sub    $0xc,%esp
f011a47a:	50                   	push   %eax
f011a47b:	e8 0a f3 fe ff       	call   f010978a <kfree>
f011a480:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a483:	e8 1d a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a488:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a48b:	74 17                	je     f011a4a4 <test_kfree_bestfirstfit+0xdd4>
f011a48d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a494:	83 ec 0c             	sub    $0xc,%esp
f011a497:	68 2c e1 12 f0       	push   $0xf012e12c
f011a49c:	e8 ea 6a fe ff       	call   f0100f8b <cprintf>
f011a4a1:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a4a4:	e8 59 44 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a4a9:	89 c2                	mov    %eax,%edx
f011a4ab:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a4ae:	29 c2                	sub    %eax,%edx
f011a4b0:	89 d0                	mov    %edx,%eax
f011a4b2:	83 f8 03             	cmp    $0x3,%eax
f011a4b5:	77 17                	ja     f011a4ce <test_kfree_bestfirstfit+0xdfe>
f011a4b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4be:	83 ec 0c             	sub    $0xc,%esp
f011a4c1:	68 9c e1 12 f0       	push   $0xf012e19c
f011a4c6:	e8 c0 6a fe ff       	call   f0100f8b <cprintf>
f011a4cb:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a4ce:	e8 2f 44 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a4d3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a4d6:	e8 ca a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a4de:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a4e4:	83 ec 0c             	sub    $0xc,%esp
f011a4e7:	50                   	push   %eax
f011a4e8:	e8 9d f2 fe ff       	call   f010978a <kfree>
f011a4ed:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4f0:	e8 b0 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4f5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4f8:	74 17                	je     f011a511 <test_kfree_bestfirstfit+0xe41>
f011a4fa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a501:	83 ec 0c             	sub    $0xc,%esp
f011a504:	68 d8 e1 12 f0       	push   $0xf012e1d8
f011a509:	e8 7d 6a fe ff       	call   f0100f8b <cprintf>
f011a50e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a511:	e8 ec 43 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a516:	89 c2                	mov    %eax,%edx
f011a518:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a51b:	29 c2                	sub    %eax,%edx
f011a51d:	89 d0                	mov    %edx,%eax
f011a51f:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a524:	77 17                	ja     f011a53d <test_kfree_bestfirstfit+0xe6d>
f011a526:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a52d:	83 ec 0c             	sub    $0xc,%esp
f011a530:	68 48 e2 12 f0       	push   $0xf012e248
f011a535:	e8 51 6a fe ff       	call   f0100f8b <cprintf>
f011a53a:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a53d:	e8 c0 43 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a542:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a545:	e8 5b a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a54a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a54d:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a553:	83 ec 0c             	sub    $0xc,%esp
f011a556:	50                   	push   %eax
f011a557:	e8 2e f2 fe ff       	call   f010978a <kfree>
f011a55c:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a55f:	e8 41 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a564:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a567:	74 17                	je     f011a580 <test_kfree_bestfirstfit+0xeb0>
f011a569:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a570:	83 ec 0c             	sub    $0xc,%esp
f011a573:	68 84 e2 12 f0       	push   $0xf012e284
f011a578:	e8 0e 6a fe ff       	call   f0100f8b <cprintf>
f011a57d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a580:	e8 7d 43 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a585:	89 c2                	mov    %eax,%edx
f011a587:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a58a:	29 c2                	sub    %eax,%edx
f011a58c:	89 d0                	mov    %edx,%eax
f011a58e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a593:	77 17                	ja     f011a5ac <test_kfree_bestfirstfit+0xedc>
f011a595:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a59c:	83 ec 0c             	sub    $0xc,%esp
f011a59f:	68 f4 e2 12 f0       	push   $0xf012e2f4
f011a5a4:	e8 e2 69 fe ff       	call   f0100f8b <cprintf>
f011a5a9:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a5ac:	e8 51 43 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a5b1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a5b4:	e8 ec a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5b9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a5bc:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a5c2:	83 ec 0c             	sub    $0xc,%esp
f011a5c5:	50                   	push   %eax
f011a5c6:	e8 bf f1 fe ff       	call   f010978a <kfree>
f011a5cb:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5ce:	e8 d2 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5d3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5d6:	74 17                	je     f011a5ef <test_kfree_bestfirstfit+0xf1f>
f011a5d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5df:	83 ec 0c             	sub    $0xc,%esp
f011a5e2:	68 30 e3 12 f0       	push   $0xf012e330
f011a5e7:	e8 9f 69 fe ff       	call   f0100f8b <cprintf>
f011a5ec:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a5ef:	e8 0e 43 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a5f4:	89 c2                	mov    %eax,%edx
f011a5f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a5f9:	39 c2                	cmp    %eax,%edx
f011a5fb:	74 17                	je     f011a614 <test_kfree_bestfirstfit+0xf44>
f011a5fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a604:	83 ec 0c             	sub    $0xc,%esp
f011a607:	68 a0 e3 12 f0       	push   $0xf012e3a0
f011a60c:	e8 7a 69 fe ff       	call   f0100f8b <cprintf>
f011a611:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011a614:	e8 e9 42 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a619:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a61c:	e8 84 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a621:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a624:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a62a:	83 ec 0c             	sub    $0xc,%esp
f011a62d:	50                   	push   %eax
f011a62e:	e8 57 f1 fe ff       	call   f010978a <kfree>
f011a633:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a636:	e8 6a a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a63b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a63e:	74 17                	je     f011a657 <test_kfree_bestfirstfit+0xf87>
f011a640:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a647:	83 ec 0c             	sub    $0xc,%esp
f011a64a:	68 dc e3 12 f0       	push   $0xf012e3dc
f011a64f:	e8 37 69 fe ff       	call   f0100f8b <cprintf>
f011a654:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a657:	e8 a6 42 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a65c:	89 c2                	mov    %eax,%edx
f011a65e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a661:	39 c2                	cmp    %eax,%edx
f011a663:	74 17                	je     f011a67c <test_kfree_bestfirstfit+0xfac>
f011a665:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a66c:	83 ec 0c             	sub    $0xc,%esp
f011a66f:	68 4c e4 12 f0       	push   $0xf012e44c
f011a674:	e8 12 69 fe ff       	call   f0100f8b <cprintf>
f011a679:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a67c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a680:	74 04                	je     f011a686 <test_kfree_bestfirstfit+0xfb6>
f011a682:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a686:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a68d:	83 ec 0c             	sub    $0xc,%esp
f011a690:	68 ac e4 12 f0       	push   $0xf012e4ac
f011a695:	e8 f1 68 fe ff       	call   f0100f8b <cprintf>
f011a69a:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a69d:	83 ec 0c             	sub    $0xc,%esp
f011a6a0:	6a 03                	push   $0x3
f011a6a2:	e8 84 46 ff ff       	call   f010ed2b <sys_bypassPageFault>
f011a6a7:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a6aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a6b1:	e9 af 00 00 00       	jmp    f011a765 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a6b6:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a6ba:	0f 84 a1 00 00 00    	je     f011a761 <test_kfree_bestfirstfit+0x1091>
f011a6c0:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a6c4:	0f 84 97 00 00 00    	je     f011a761 <test_kfree_bestfirstfit+0x1091>
f011a6ca:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a6ce:	0f 84 8d 00 00 00    	je     f011a761 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a6d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a6d7:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a6de:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a6e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a6e4:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a6e7:	e8 2d 46 ff ff       	call   f010ed19 <sys_rcr2>
f011a6ec:	89 c2                	mov    %eax,%edx
f011a6ee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a6f1:	39 c2                	cmp    %eax,%edx
f011a6f3:	74 1d                	je     f011a712 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a6f5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6f9:	74 17                	je     f011a712 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a6fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a702:	83 ec 0c             	sub    $0xc,%esp
f011a705:	68 ec e4 12 f0       	push   $0xf012e4ec
f011a70a:	e8 7c 68 fe ff       	call   f0100f8b <cprintf>
f011a70f:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a712:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a715:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a71c:	89 c2                	mov    %eax,%edx
f011a71e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a721:	01 d0                	add    %edx,%eax
f011a723:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a726:	e8 ee 45 ff ff       	call   f010ed19 <sys_rcr2>
f011a72b:	89 c2                	mov    %eax,%edx
f011a72d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a730:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a737:	89 c1                	mov    %eax,%ecx
f011a739:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a73c:	01 c8                	add    %ecx,%eax
f011a73e:	39 c2                	cmp    %eax,%edx
f011a740:	74 20                	je     f011a762 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a742:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a746:	74 1a                	je     f011a762 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a748:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a74f:	83 ec 0c             	sub    $0xc,%esp
f011a752:	68 38 e5 12 f0       	push   $0xf012e538
f011a757:	e8 2f 68 fe ff       	call   f0100f8b <cprintf>
f011a75c:	83 c4 10             	add    $0x10,%esp
f011a75f:	eb 01                	jmp    f011a762 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a761:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a762:	ff 45 f4             	incl   -0xc(%ebp)
f011a765:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a769:	0f 8e 47 ff ff ff    	jle    f011a6b6 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a76f:	83 ec 0c             	sub    $0xc,%esp
f011a772:	6a 00                	push   $0x0
f011a774:	e8 b2 45 ff ff       	call   f010ed2b <sys_bypassPageFault>
f011a779:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a77c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a780:	74 04                	je     f011a786 <test_kfree_bestfirstfit+0x10b6>
f011a782:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a786:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a78d:	83 ec 0c             	sub    $0xc,%esp
f011a790:	68 84 e5 12 f0       	push   $0xf012e584
f011a795:	e8 f1 67 fe ff       	call   f0100f8b <cprintf>
f011a79a:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a79d:	e8 60 41 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a7a2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a7a5:	e8 fb a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a7aa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a7ad:	83 ec 0c             	sub    $0xc,%esp
f011a7b0:	68 00 04 00 00       	push   $0x400
f011a7b5:	e8 70 ed fe ff       	call   f010952a <kmalloc>
f011a7ba:	83 c4 10             	add    $0x10,%esp
f011a7bd:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a7c3:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a7c9:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a7cf:	39 c2                	cmp    %eax,%edx
f011a7d1:	74 17                	je     f011a7ea <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a7d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7da:	83 ec 0c             	sub    $0xc,%esp
f011a7dd:	68 a8 e5 12 f0       	push   $0xf012e5a8
f011a7e2:	e8 a4 67 fe ff       	call   f0100f8b <cprintf>
f011a7e7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7ea:	e8 b6 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a7ef:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7f2:	74 17                	je     f011a80b <test_kfree_bestfirstfit+0x113b>
f011a7f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7fb:	83 ec 0c             	sub    $0xc,%esp
f011a7fe:	68 fc e5 12 f0       	push   $0xf012e5fc
f011a803:	e8 83 67 fe ff       	call   f0100f8b <cprintf>
f011a808:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a80b:	e8 f2 40 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a810:	89 c2                	mov    %eax,%edx
f011a812:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a815:	39 c2                	cmp    %eax,%edx
f011a817:	74 17                	je     f011a830 <test_kfree_bestfirstfit+0x1160>
f011a819:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a820:	83 ec 0c             	sub    $0xc,%esp
f011a823:	68 6c e6 12 f0       	push   $0xf012e66c
f011a828:	e8 5e 67 fe ff       	call   f0100f8b <cprintf>
f011a82d:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a830:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a837:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a83d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a840:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a847:	eb 0e                	jmp    f011a857 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a849:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a84c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a84f:	01 d0                	add    %edx,%eax
f011a851:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a854:	ff 45 f4             	incl   -0xc(%ebp)
f011a857:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a85a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a85d:	7f ea                	jg     f011a849 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a85f:	e8 9e 40 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a864:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a867:	e8 39 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a86c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a86f:	83 ec 0c             	sub    $0xc,%esp
f011a872:	68 00 08 00 00       	push   $0x800
f011a877:	e8 ae ec fe ff       	call   f010952a <kmalloc>
f011a87c:	83 c4 10             	add    $0x10,%esp
f011a87f:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a885:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a88b:	05 08 04 00 00       	add    $0x408,%eax
f011a890:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a893:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a899:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a89c:	74 35                	je     f011a8d3 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a89e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a8a5:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a8ab:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a8b1:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a8b7:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a8bd:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a8c3:	50                   	push   %eax
f011a8c4:	51                   	push   %ecx
f011a8c5:	52                   	push   %edx
f011a8c6:	68 e8 e6 12 f0       	push   $0xf012e6e8
f011a8cb:	e8 bb 66 fe ff       	call   f0100f8b <cprintf>
f011a8d0:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8d3:	e8 cd 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a8d8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a8db:	74 17                	je     f011a8f4 <test_kfree_bestfirstfit+0x1224>
f011a8dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8e4:	83 ec 0c             	sub    $0xc,%esp
f011a8e7:	68 5c e7 12 f0       	push   $0xf012e75c
f011a8ec:	e8 9a 66 fe ff       	call   f0100f8b <cprintf>
f011a8f1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a8f4:	e8 09 40 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a8f9:	89 c2                	mov    %eax,%edx
f011a8fb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a8fe:	39 c2                	cmp    %eax,%edx
f011a900:	74 17                	je     f011a919 <test_kfree_bestfirstfit+0x1249>
f011a902:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a909:	83 ec 0c             	sub    $0xc,%esp
f011a90c:	68 cc e7 12 f0       	push   $0xf012e7cc
f011a911:	e8 75 66 fe ff       	call   f0100f8b <cprintf>
f011a916:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a919:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a920:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a926:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a929:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a930:	eb 0e                	jmp    f011a940 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a932:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a935:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a938:	01 d0                	add    %edx,%eax
f011a93a:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a93d:	ff 45 f4             	incl   -0xc(%ebp)
f011a940:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a943:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a946:	7f ea                	jg     f011a932 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a948:	e8 b5 3f ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a94d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a950:	e8 50 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a955:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011a958:	83 ec 0c             	sub    $0xc,%esp
f011a95b:	68 00 06 00 00       	push   $0x600
f011a960:	e8 c5 eb fe ff       	call   f010952a <kmalloc>
f011a965:	83 c4 10             	add    $0x10,%esp
f011a968:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011a96e:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a974:	05 10 0c 00 00       	add    $0xc10,%eax
f011a979:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011a97c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a982:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a985:	74 17                	je     f011a99e <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a987:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a98e:	83 ec 0c             	sub    $0xc,%esp
f011a991:	68 48 e8 12 f0       	push   $0xf012e848
f011a996:	e8 f0 65 fe ff       	call   f0100f8b <cprintf>
f011a99b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a99e:	e8 02 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a9a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a9a6:	74 17                	je     f011a9bf <test_kfree_bestfirstfit+0x12ef>
f011a9a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9af:	83 ec 0c             	sub    $0xc,%esp
f011a9b2:	68 9c e8 12 f0       	push   $0xf012e89c
f011a9b7:	e8 cf 65 fe ff       	call   f0100f8b <cprintf>
f011a9bc:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a9bf:	e8 3e 3f ff ff       	call   f010e902 <sys_calculate_free_frames>
f011a9c4:	89 c2                	mov    %eax,%edx
f011a9c6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a9c9:	39 c2                	cmp    %eax,%edx
f011a9cb:	74 17                	je     f011a9e4 <test_kfree_bestfirstfit+0x1314>
f011a9cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9d4:	83 ec 0c             	sub    $0xc,%esp
f011a9d7:	68 0c e9 12 f0       	push   $0xf012e90c
f011a9dc:	e8 aa 65 fe ff       	call   f0100f8b <cprintf>
f011a9e1:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011a9e4:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011a9eb:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a9f1:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a9f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a9fb:	eb 0e                	jmp    f011aa0b <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011a9fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aa00:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa03:	01 d0                	add    %edx,%eax
f011aa05:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011aa08:	ff 45 f4             	incl   -0xc(%ebp)
f011aa0b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aa0e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aa11:	7f ea                	jg     f011a9fd <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011aa13:	e8 ea 3e ff ff       	call   f010e902 <sys_calculate_free_frames>
f011aa18:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa1b:	e8 85 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa20:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011aa23:	83 ec 0c             	sub    $0xc,%esp
f011aa26:	68 00 00 e0 01       	push   $0x1e00000
f011aa2b:	e8 fa ea fe ff       	call   f010952a <kmalloc>
f011aa30:	83 c4 10             	add    $0x10,%esp
f011aa33:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aa39:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aa3f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011aa44:	74 17                	je     f011aa5d <test_kfree_bestfirstfit+0x138d>
f011aa46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa4d:	83 ec 0c             	sub    $0xc,%esp
f011aa50:	68 88 e9 12 f0       	push   $0xf012e988
f011aa55:	e8 31 65 fe ff       	call   f0100f8b <cprintf>
f011aa5a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa5d:	e8 43 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa62:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aa65:	74 17                	je     f011aa7e <test_kfree_bestfirstfit+0x13ae>
f011aa67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa6e:	83 ec 0c             	sub    $0xc,%esp
f011aa71:	68 dc e9 12 f0       	push   $0xf012e9dc
f011aa76:	e8 10 65 fe ff       	call   f0100f8b <cprintf>
f011aa7b:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aa7e:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011aa81:	e8 7c 3e ff ff       	call   f010e902 <sys_calculate_free_frames>
f011aa86:	29 c3                	sub    %eax,%ebx
f011aa88:	89 d8                	mov    %ebx,%eax
f011aa8a:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011aa8f:	77 17                	ja     f011aaa8 <test_kfree_bestfirstfit+0x13d8>
f011aa91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa98:	83 ec 0c             	sub    $0xc,%esp
f011aa9b:	68 4c ea 12 f0       	push   $0xf012ea4c
f011aaa0:	e8 e6 64 fe ff       	call   f0100f8b <cprintf>
f011aaa5:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011aaa8:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011aaaf:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aab5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011aab8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aabf:	eb 0e                	jmp    f011aacf <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011aac1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aac4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aac7:	01 d0                	add    %edx,%eax
f011aac9:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011aacc:	ff 45 f4             	incl   -0xc(%ebp)
f011aacf:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aad2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aad5:	7f ea                	jg     f011aac1 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011aad7:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aadd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011aae0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aae7:	eb 1e                	jmp    f011ab07 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011aae9:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011aaef:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011aaf2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aaf5:	01 c8                	add    %ecx,%eax
f011aaf7:	8a 00                	mov    (%eax),%al
f011aaf9:	0f be c0             	movsbl %al,%eax
f011aafc:	01 d0                	add    %edx,%eax
f011aafe:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ab04:	ff 45 f4             	incl   -0xc(%ebp)
f011ab07:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ab0a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab0d:	7f da                	jg     f011aae9 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011ab0f:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011ab15:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011ab18:	89 d0                	mov    %edx,%eax
f011ab1a:	c1 e0 02             	shl    $0x2,%eax
f011ab1d:	01 d0                	add    %edx,%eax
f011ab1f:	01 c0                	add    %eax,%eax
f011ab21:	39 c1                	cmp    %eax,%ecx
f011ab23:	74 17                	je     f011ab3c <test_kfree_bestfirstfit+0x146c>
f011ab25:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab2c:	83 ec 0c             	sub    $0xc,%esp
f011ab2f:	68 94 ea 12 f0       	push   $0xf012ea94
f011ab34:	e8 52 64 fe ff       	call   f0100f8b <cprintf>
f011ab39:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011ab3c:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ab42:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011ab45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab4c:	eb 1e                	jmp    f011ab6c <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011ab4e:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011ab54:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab57:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab5a:	01 c8                	add    %ecx,%eax
f011ab5c:	8a 00                	mov    (%eax),%al
f011ab5e:	0f be c0             	movsbl %al,%eax
f011ab61:	01 d0                	add    %edx,%eax
f011ab63:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011ab69:	ff 45 f4             	incl   -0xc(%ebp)
f011ab6c:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ab6f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab72:	7f da                	jg     f011ab4e <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011ab74:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011ab7a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ab7d:	89 d0                	mov    %edx,%eax
f011ab7f:	c1 e0 02             	shl    $0x2,%eax
f011ab82:	01 d0                	add    %edx,%eax
f011ab84:	01 c0                	add    %eax,%eax
f011ab86:	01 d0                	add    %edx,%eax
f011ab88:	39 c1                	cmp    %eax,%ecx
f011ab8a:	74 17                	je     f011aba3 <test_kfree_bestfirstfit+0x14d3>
f011ab8c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab93:	83 ec 0c             	sub    $0xc,%esp
f011ab96:	68 c4 ea 12 f0       	push   $0xf012eac4
f011ab9b:	e8 eb 63 fe ff       	call   f0100f8b <cprintf>
f011aba0:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011aba3:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011aba9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011abac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011abb3:	eb 1e                	jmp    f011abd3 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011abb5:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011abbb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abbe:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abc1:	01 c8                	add    %ecx,%eax
f011abc3:	8a 00                	mov    (%eax),%al
f011abc5:	0f be c0             	movsbl %al,%eax
f011abc8:	01 d0                	add    %edx,%eax
f011abca:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011abd0:	ff 45 f4             	incl   -0xc(%ebp)
f011abd3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011abd6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abd9:	7f da                	jg     f011abb5 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011abdb:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011abe1:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011abe4:	89 d0                	mov    %edx,%eax
f011abe6:	01 c0                	add    %eax,%eax
f011abe8:	01 d0                	add    %edx,%eax
f011abea:	c1 e0 02             	shl    $0x2,%eax
f011abed:	39 c1                	cmp    %eax,%ecx
f011abef:	74 17                	je     f011ac08 <test_kfree_bestfirstfit+0x1538>
f011abf1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abf8:	83 ec 0c             	sub    $0xc,%esp
f011abfb:	68 f4 ea 12 f0       	push   $0xf012eaf4
f011ac00:	e8 86 63 fe ff       	call   f0100f8b <cprintf>
f011ac05:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011ac08:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ac0e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011ac11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac18:	eb 1e                	jmp    f011ac38 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011ac1a:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011ac20:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac23:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac26:	01 c8                	add    %ecx,%eax
f011ac28:	8a 00                	mov    (%eax),%al
f011ac2a:	0f be c0             	movsbl %al,%eax
f011ac2d:	01 d0                	add    %edx,%eax
f011ac2f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011ac35:	ff 45 f4             	incl   -0xc(%ebp)
f011ac38:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ac3b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac3e:	7f da                	jg     f011ac1a <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011ac40:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011ac46:	8b 55 98             	mov    -0x68(%ebp),%edx
f011ac49:	89 d0                	mov    %edx,%eax
f011ac4b:	01 c0                	add    %eax,%eax
f011ac4d:	01 d0                	add    %edx,%eax
f011ac4f:	c1 e0 02             	shl    $0x2,%eax
f011ac52:	01 d0                	add    %edx,%eax
f011ac54:	39 c1                	cmp    %eax,%ecx
f011ac56:	74 17                	je     f011ac6f <test_kfree_bestfirstfit+0x159f>
f011ac58:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac5f:	83 ec 0c             	sub    $0xc,%esp
f011ac62:	68 24 eb 12 f0       	push   $0xf012eb24
f011ac67:	e8 1f 63 fe ff       	call   f0100f8b <cprintf>
f011ac6c:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011ac6f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ac73:	74 04                	je     f011ac79 <test_kfree_bestfirstfit+0x15a9>
f011ac75:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ac79:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011ac80:	83 ec 0c             	sub    $0xc,%esp
f011ac83:	68 51 eb 12 f0       	push   $0xf012eb51
f011ac88:	e8 fe 62 fe ff       	call   f0100f8b <cprintf>
f011ac8d:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ac90:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011ac97:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011ac9e:	eb 4e                	jmp    f011acee <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011aca0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011aca3:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011aca8:	83 ec 04             	sub    $0x4,%esp
f011acab:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011acb1:	51                   	push   %ecx
f011acb2:	52                   	push   %edx
f011acb3:	50                   	push   %eax
f011acb4:	e8 36 d7 fe ff       	call   f01083ef <get_page_table>
f011acb9:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011acbc:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011acc2:	85 c0                	test   %eax,%eax
f011acc4:	75 1d                	jne    f011ace3 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011acc6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011acca:	74 17                	je     f011ace3 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011accc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acd3:	83 ec 0c             	sub    $0xc,%esp
f011acd6:	68 70 eb 12 f0       	push   $0xf012eb70
f011acdb:	e8 ab 62 fe ff       	call   f0100f8b <cprintf>
f011ace0:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ace3:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011acea:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011acee:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011acf2:	78 ac                	js     f011aca0 <test_kfree_bestfirstfit+0x15d0>
f011acf4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011acf8:	7f 09                	jg     f011ad03 <test_kfree_bestfirstfit+0x1633>
f011acfa:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011ad01:	76 9d                	jbe    f011aca0 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011ad03:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ad07:	74 04                	je     f011ad0d <test_kfree_bestfirstfit+0x163d>
f011ad09:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011ad0d:	83 ec 08             	sub    $0x8,%esp
f011ad10:	ff 75 f0             	pushl  -0x10(%ebp)
f011ad13:	68 d8 eb 12 f0       	push   $0xf012ebd8
f011ad18:	e8 6e 62 fe ff       	call   f0100f8b <cprintf>
f011ad1d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011ad20:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011ad25:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011ad28:	5b                   	pop    %ebx
f011ad29:	5f                   	pop    %edi
f011ad2a:	5d                   	pop    %ebp
f011ad2b:	c3                   	ret    

f011ad2c <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011ad2c:	55                   	push   %ebp
f011ad2d:	89 e5                	mov    %esp,%ebp
f011ad2f:	57                   	push   %edi
f011ad30:	53                   	push   %ebx
f011ad31:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011ad37:	83 ec 0c             	sub    $0xc,%esp
f011ad3a:	68 a8 ae 12 f0       	push   $0xf012aea8
f011ad3f:	e8 47 62 fe ff       	call   f0100f8b <cprintf>
f011ad44:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011ad47:	83 ec 0c             	sub    $0xc,%esp
f011ad4a:	68 d8 ae 12 f0       	push   $0xf012aed8
f011ad4f:	e8 37 62 fe ff       	call   f0100f8b <cprintf>
f011ad54:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011ad57:	83 ec 0c             	sub    $0xc,%esp
f011ad5a:	68 a8 ae 12 f0       	push   $0xf012aea8
f011ad5f:	e8 27 62 fe ff       	call   f0100f8b <cprintf>
f011ad64:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011ad67:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011ad6b:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011ad6f:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011ad75:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011ad7b:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011ad82:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011ad89:	e8 74 3b ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ad8e:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011ad91:	83 ec 0c             	sub    $0xc,%esp
f011ad94:	68 fc eb 12 f0       	push   $0xf012ebfc
f011ad99:	e8 ed 61 fe ff       	call   f0100f8b <cprintf>
f011ad9e:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011ada1:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011ada7:	b9 14 00 00 00       	mov    $0x14,%ecx
f011adac:	b8 00 00 00 00       	mov    $0x0,%eax
f011adb1:	89 d7                	mov    %edx,%edi
f011adb3:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011adb5:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011adbb:	b9 14 00 00 00       	mov    $0x14,%ecx
f011adc0:	b8 00 00 00 00       	mov    $0x0,%eax
f011adc5:	89 d7                	mov    %edx,%edi
f011adc7:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011adc9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011add0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011add7:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011addd:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ade2:	b8 00 00 00 00       	mov    $0x0,%eax
f011ade7:	89 d7                	mov    %edx,%edi
f011ade9:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011adeb:	e8 12 3b ff ff       	call   f010e902 <sys_calculate_free_frames>
f011adf0:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011adf3:	e8 ad 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011adf8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011adfb:	83 ec 0c             	sub    $0xc,%esp
f011adfe:	68 00 fc 1f 00       	push   $0x1ffc00
f011ae03:	e8 22 e7 fe ff       	call   f010952a <kmalloc>
f011ae08:	83 c4 10             	add    $0x10,%esp
f011ae0b:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae11:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ae17:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ae1c:	74 17                	je     f011ae35 <test_kheap_phys_addr+0x109>
f011ae1e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae25:	83 ec 0c             	sub    $0xc,%esp
f011ae28:	68 a0 cf 12 f0       	push   $0xf012cfa0
f011ae2d:	e8 59 61 fe ff       	call   f0100f8b <cprintf>
f011ae32:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae35:	e8 6b 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae3a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ae3d:	74 17                	je     f011ae56 <test_kheap_phys_addr+0x12a>
f011ae3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae46:	83 ec 0c             	sub    $0xc,%esp
f011ae49:	68 f4 cf 12 f0       	push   $0xf012cff4
f011ae4e:	e8 38 61 fe ff       	call   f0100f8b <cprintf>
f011ae53:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ae56:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ae59:	e8 a4 3a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ae5e:	29 c3                	sub    %eax,%ebx
f011ae60:	89 d8                	mov    %ebx,%eax
f011ae62:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ae67:	77 17                	ja     f011ae80 <test_kheap_phys_addr+0x154>
f011ae69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae70:	83 ec 0c             	sub    $0xc,%esp
f011ae73:	68 64 d0 12 f0       	push   $0xf012d064
f011ae78:	e8 0e 61 fe ff       	call   f0100f8b <cprintf>
f011ae7d:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ae80:	e8 7d 3a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ae85:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae88:	e8 18 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae8d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011ae90:	83 ec 0c             	sub    $0xc,%esp
f011ae93:	68 00 fc 1f 00       	push   $0x1ffc00
f011ae98:	e8 8d e6 fe ff       	call   f010952a <kmalloc>
f011ae9d:	83 c4 10             	add    $0x10,%esp
f011aea0:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aea6:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011aeac:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011aeb1:	74 17                	je     f011aeca <test_kheap_phys_addr+0x19e>
f011aeb3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aeba:	83 ec 0c             	sub    $0xc,%esp
f011aebd:	68 ac d0 12 f0       	push   $0xf012d0ac
f011aec2:	e8 c4 60 fe ff       	call   f0100f8b <cprintf>
f011aec7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aeca:	e8 d6 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aecf:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aed2:	74 17                	je     f011aeeb <test_kheap_phys_addr+0x1bf>
f011aed4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aedb:	83 ec 0c             	sub    $0xc,%esp
f011aede:	68 00 d1 12 f0       	push   $0xf012d100
f011aee3:	e8 a3 60 fe ff       	call   f0100f8b <cprintf>
f011aee8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aeeb:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011aeee:	e8 0f 3a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011aef3:	29 c3                	sub    %eax,%ebx
f011aef5:	89 d8                	mov    %ebx,%eax
f011aef7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aefc:	77 17                	ja     f011af15 <test_kheap_phys_addr+0x1e9>
f011aefe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af05:	83 ec 0c             	sub    $0xc,%esp
f011af08:	68 70 d1 12 f0       	push   $0xf012d170
f011af0d:	e8 79 60 fe ff       	call   f0100f8b <cprintf>
f011af12:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011af15:	e8 e8 39 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011af1a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011af1d:	e8 83 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af22:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011af25:	83 ec 0c             	sub    $0xc,%esp
f011af28:	68 00 04 00 00       	push   $0x400
f011af2d:	e8 f8 e5 fe ff       	call   f010952a <kmalloc>
f011af32:	83 c4 10             	add    $0x10,%esp
f011af35:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011af3b:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011af41:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011af46:	76 28                	jbe    f011af70 <test_kheap_phys_addr+0x244>
f011af48:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011af4e:	83 ec 0c             	sub    $0xc,%esp
f011af51:	6a 00                	push   $0x0
f011af53:	e8 9f e4 fe ff       	call   f01093f7 <sbrk>
f011af58:	83 c4 10             	add    $0x10,%esp
f011af5b:	39 c3                	cmp    %eax,%ebx
f011af5d:	73 11                	jae    f011af70 <test_kheap_phys_addr+0x244>
f011af5f:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011af65:	89 c2                	mov    %eax,%edx
f011af67:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011af6c:	39 c2                	cmp    %eax,%edx
f011af6e:	72 17                	jb     f011af87 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011af70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af77:	83 ec 0c             	sub    $0xc,%esp
f011af7a:	68 2c ec 12 f0       	push   $0xf012ec2c
f011af7f:	e8 07 60 fe ff       	call   f0100f8b <cprintf>
f011af84:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af87:	e8 19 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af8c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011af8f:	74 17                	je     f011afa8 <test_kheap_phys_addr+0x27c>
f011af91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af98:	83 ec 0c             	sub    $0xc,%esp
f011af9b:	68 0c d2 12 f0       	push   $0xf012d20c
f011afa0:	e8 e6 5f fe ff       	call   f0100f8b <cprintf>
f011afa5:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011afa8:	e8 55 39 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011afad:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011afb0:	e8 f0 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011afb5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011afb8:	83 ec 0c             	sub    $0xc,%esp
f011afbb:	68 00 08 00 00       	push   $0x800
f011afc0:	e8 65 e5 fe ff       	call   f010952a <kmalloc>
f011afc5:	83 c4 10             	add    $0x10,%esp
f011afc8:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011afce:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011afd4:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011afd9:	76 28                	jbe    f011b003 <test_kheap_phys_addr+0x2d7>
f011afdb:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011afe1:	83 ec 0c             	sub    $0xc,%esp
f011afe4:	6a 00                	push   $0x0
f011afe6:	e8 0c e4 fe ff       	call   f01093f7 <sbrk>
f011afeb:	83 c4 10             	add    $0x10,%esp
f011afee:	39 c3                	cmp    %eax,%ebx
f011aff0:	73 11                	jae    f011b003 <test_kheap_phys_addr+0x2d7>
f011aff2:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011aff8:	89 c2                	mov    %eax,%edx
f011affa:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011afff:	39 c2                	cmp    %eax,%edx
f011b001:	72 17                	jb     f011b01a <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b003:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b00a:	83 ec 0c             	sub    $0xc,%esp
f011b00d:	68 b8 ec 12 f0       	push   $0xf012ecb8
f011b012:	e8 74 5f fe ff       	call   f0100f8b <cprintf>
f011b017:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b01a:	e8 86 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b01f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b022:	74 17                	je     f011b03b <test_kheap_phys_addr+0x30f>
f011b024:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b02b:	83 ec 0c             	sub    $0xc,%esp
f011b02e:	68 18 d3 12 f0       	push   $0xf012d318
f011b033:	e8 53 5f fe ff       	call   f0100f8b <cprintf>
f011b038:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b03b:	e8 c2 38 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b040:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b043:	e8 5d 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b048:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b04b:	83 ec 0c             	sub    $0xc,%esp
f011b04e:	68 00 06 00 00       	push   $0x600
f011b053:	e8 d2 e4 fe ff       	call   f010952a <kmalloc>
f011b058:	83 c4 10             	add    $0x10,%esp
f011b05b:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b061:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b067:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b06c:	76 28                	jbe    f011b096 <test_kheap_phys_addr+0x36a>
f011b06e:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b074:	83 ec 0c             	sub    $0xc,%esp
f011b077:	6a 00                	push   $0x0
f011b079:	e8 79 e3 fe ff       	call   f01093f7 <sbrk>
f011b07e:	83 c4 10             	add    $0x10,%esp
f011b081:	39 c3                	cmp    %eax,%ebx
f011b083:	73 11                	jae    f011b096 <test_kheap_phys_addr+0x36a>
f011b085:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b08b:	89 c2                	mov    %eax,%edx
f011b08d:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b092:	39 c2                	cmp    %eax,%edx
f011b094:	72 17                	jb     f011b0ad <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b096:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b09d:	83 ec 0c             	sub    $0xc,%esp
f011b0a0:	68 44 ed 12 f0       	push   $0xf012ed44
f011b0a5:	e8 e1 5e fe ff       	call   f0100f8b <cprintf>
f011b0aa:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b0ad:	e8 f3 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b0b2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b0b5:	74 17                	je     f011b0ce <test_kheap_phys_addr+0x3a2>
f011b0b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0be:	83 ec 0c             	sub    $0xc,%esp
f011b0c1:	68 24 d4 12 f0       	push   $0xf012d424
f011b0c6:	e8 c0 5e fe ff       	call   f0100f8b <cprintf>
f011b0cb:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b0ce:	e8 2f 38 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b0d3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b0d6:	e8 ca 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b0db:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b0de:	83 ec 0c             	sub    $0xc,%esp
f011b0e1:	68 00 1c 00 00       	push   $0x1c00
f011b0e6:	e8 3f e4 fe ff       	call   f010952a <kmalloc>
f011b0eb:	83 c4 10             	add    $0x10,%esp
f011b0ee:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b0f4:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b0fa:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b0ff:	74 17                	je     f011b118 <test_kheap_phys_addr+0x3ec>
f011b101:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b108:	83 ec 0c             	sub    $0xc,%esp
f011b10b:	68 dc d4 12 f0       	push   $0xf012d4dc
f011b110:	e8 76 5e fe ff       	call   f0100f8b <cprintf>
f011b115:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b118:	e8 88 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b11d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b120:	74 17                	je     f011b139 <test_kheap_phys_addr+0x40d>
f011b122:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b129:	83 ec 0c             	sub    $0xc,%esp
f011b12c:	68 30 d5 12 f0       	push   $0xf012d530
f011b131:	e8 55 5e fe ff       	call   f0100f8b <cprintf>
f011b136:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b139:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b13c:	e8 c1 37 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b141:	29 c3                	sub    %eax,%ebx
f011b143:	89 d8                	mov    %ebx,%eax
f011b145:	83 f8 01             	cmp    $0x1,%eax
f011b148:	77 17                	ja     f011b161 <test_kheap_phys_addr+0x435>
f011b14a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b151:	83 ec 0c             	sub    $0xc,%esp
f011b154:	68 a0 d5 12 f0       	push   $0xf012d5a0
f011b159:	e8 2d 5e fe ff       	call   f0100f8b <cprintf>
f011b15e:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b161:	e8 9c 37 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b166:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b169:	e8 37 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b16e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b171:	83 ec 0c             	sub    $0xc,%esp
f011b174:	68 00 fc 2f 00       	push   $0x2ffc00
f011b179:	e8 ac e3 fe ff       	call   f010952a <kmalloc>
f011b17e:	83 c4 10             	add    $0x10,%esp
f011b181:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b187:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b18d:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b192:	74 17                	je     f011b1ab <test_kheap_phys_addr+0x47f>
f011b194:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b19b:	83 ec 0c             	sub    $0xc,%esp
f011b19e:	68 d0 ed 12 f0       	push   $0xf012edd0
f011b1a3:	e8 e3 5d fe ff       	call   f0100f8b <cprintf>
f011b1a8:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b1ab:	e8 f5 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b1b0:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b1b3:	74 17                	je     f011b1cc <test_kheap_phys_addr+0x4a0>
f011b1b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1bc:	83 ec 0c             	sub    $0xc,%esp
f011b1bf:	68 74 d6 12 f0       	push   $0xf012d674
f011b1c4:	e8 c2 5d fe ff       	call   f0100f8b <cprintf>
f011b1c9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b1cc:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b1cf:	e8 2e 37 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b1d4:	29 c3                	sub    %eax,%ebx
f011b1d6:	89 d8                	mov    %ebx,%eax
f011b1d8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b1dd:	77 17                	ja     f011b1f6 <test_kheap_phys_addr+0x4ca>
f011b1df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1e6:	83 ec 0c             	sub    $0xc,%esp
f011b1e9:	68 24 ee 12 f0       	push   $0xf012ee24
f011b1ee:	e8 98 5d fe ff       	call   f0100f8b <cprintf>
f011b1f3:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b1f6:	e8 07 37 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b1fb:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b1fe:	e8 a2 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b203:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b206:	83 ec 0c             	sub    $0xc,%esp
f011b209:	68 00 fc 5f 00       	push   $0x5ffc00
f011b20e:	e8 17 e3 fe ff       	call   f010952a <kmalloc>
f011b213:	83 c4 10             	add    $0x10,%esp
f011b216:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b21c:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b222:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b227:	74 17                	je     f011b240 <test_kheap_phys_addr+0x514>
f011b229:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b230:	83 ec 0c             	sub    $0xc,%esp
f011b233:	68 6c ee 12 f0       	push   $0xf012ee6c
f011b238:	e8 4e 5d fe ff       	call   f0100f8b <cprintf>
f011b23d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b240:	e8 60 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b245:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b248:	74 17                	je     f011b261 <test_kheap_phys_addr+0x535>
f011b24a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b251:	83 ec 0c             	sub    $0xc,%esp
f011b254:	68 70 d7 12 f0       	push   $0xf012d770
f011b259:	e8 2d 5d fe ff       	call   f0100f8b <cprintf>
f011b25e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b261:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b264:	e8 99 36 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b269:	29 c3                	sub    %eax,%ebx
f011b26b:	89 d8                	mov    %ebx,%eax
f011b26d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b272:	77 17                	ja     f011b28b <test_kheap_phys_addr+0x55f>
f011b274:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b27b:	83 ec 0c             	sub    $0xc,%esp
f011b27e:	68 c0 ee 12 f0       	push   $0xf012eec0
f011b283:	e8 03 5d fe ff       	call   f0100f8b <cprintf>
f011b288:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b28b:	e8 72 36 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b290:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b293:	e8 0d 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b298:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b29b:	83 ec 0c             	sub    $0xc,%esp
f011b29e:	68 00 38 00 00       	push   $0x3800
f011b2a3:	e8 82 e2 fe ff       	call   f010952a <kmalloc>
f011b2a8:	83 c4 10             	add    $0x10,%esp
f011b2ab:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b2b1:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b2b7:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b2bc:	74 17                	je     f011b2d5 <test_kheap_phys_addr+0x5a9>
f011b2be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2c5:	83 ec 0c             	sub    $0xc,%esp
f011b2c8:	68 08 ef 12 f0       	push   $0xf012ef08
f011b2cd:	e8 b9 5c fe ff       	call   f0100f8b <cprintf>
f011b2d2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2d5:	e8 cb 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b2da:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b2dd:	74 17                	je     f011b2f6 <test_kheap_phys_addr+0x5ca>
f011b2df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2e6:	83 ec 0c             	sub    $0xc,%esp
f011b2e9:	68 5c ef 12 f0       	push   $0xf012ef5c
f011b2ee:	e8 98 5c fe ff       	call   f0100f8b <cprintf>
f011b2f3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b2f6:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b2f9:	e8 04 36 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b2fe:	29 c3                	sub    %eax,%ebx
f011b300:	89 d8                	mov    %ebx,%eax
f011b302:	83 f8 03             	cmp    $0x3,%eax
f011b305:	77 17                	ja     f011b31e <test_kheap_phys_addr+0x5f2>
f011b307:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b30e:	83 ec 0c             	sub    $0xc,%esp
f011b311:	68 cc ef 12 f0       	push   $0xf012efcc
f011b316:	e8 70 5c fe ff       	call   f0100f8b <cprintf>
f011b31b:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b31e:	83 ec 0c             	sub    $0xc,%esp
f011b321:	68 14 f0 12 f0       	push   $0xf012f014
f011b326:	e8 60 5c fe ff       	call   f0100f8b <cprintf>
f011b32b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b32e:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b335:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b33c:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b343:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b348:	05 00 10 00 00       	add    $0x1000,%eax
f011b34d:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b350:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b353:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b356:	eb 2e                	jmp    f011b386 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b358:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b35b:	8d 43 01             	lea    0x1(%ebx),%eax
f011b35e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b361:	83 ec 0c             	sub    $0xc,%esp
f011b364:	ff 75 e8             	pushl  -0x18(%ebp)
f011b367:	e8 04 e5 fe ff       	call   f0109870 <kheap_physical_address>
f011b36c:	83 c4 10             	add    $0x10,%esp
f011b36f:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b376:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b379:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b37c:	01 d0                	add    %edx,%eax
f011b37e:	05 00 10 00 00       	add    $0x1000,%eax
f011b383:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b386:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b389:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b38c:	72 ca                	jb     f011b358 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b38e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b391:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b394:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b39b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b39e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b3a1:	e9 ce 00 00 00       	jmp    f011b474 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b3a6:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011b3ab:	83 ec 04             	sub    $0x4,%esp
f011b3ae:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b3b4:	52                   	push   %edx
f011b3b5:	ff 75 e8             	pushl  -0x18(%ebp)
f011b3b8:	50                   	push   %eax
f011b3b9:	e8 31 d0 fe ff       	call   f01083ef <get_page_table>
f011b3be:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b3c1:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b3c7:	85 c0                	test   %eax,%eax
f011b3c9:	75 1e                	jne    f011b3e9 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b3cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3d2:	83 ec 04             	sub    $0x4,%esp
f011b3d5:	68 60 f0 12 f0       	push   $0xf012f060
f011b3da:	68 e7 05 00 00       	push   $0x5e7
f011b3df:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011b3e4:	e8 50 4f fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b3e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b3ec:	c1 e8 0c             	shr    $0xc,%eax
f011b3ef:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b3f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b3f7:	eb 62                	jmp    f011b45b <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b3f9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b3ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b402:	c1 e2 02             	shl    $0x2,%edx
f011b405:	01 d0                	add    %edx,%eax
f011b407:	8b 00                	mov    (%eax),%eax
f011b409:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b40e:	89 c2                	mov    %eax,%edx
f011b410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b413:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b418:	01 c2                	add    %eax,%edx
f011b41a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b41d:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b424:	39 c2                	cmp    %eax,%edx
f011b426:	74 1d                	je     f011b445 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b428:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b42c:	74 17                	je     f011b445 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b42e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b435:	83 ec 0c             	sub    $0xc,%esp
f011b438:	68 c0 f0 12 f0       	push   $0xf012f0c0
f011b43d:	e8 49 5b fe ff       	call   f0100f8b <cprintf>
f011b442:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b445:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b448:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b44b:	01 d0                	add    %edx,%eax
f011b44d:	05 00 10 00 00       	add    $0x1000,%eax
f011b452:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b455:	ff 45 e4             	incl   -0x1c(%ebp)
f011b458:	ff 45 f4             	incl   -0xc(%ebp)
f011b45b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b45e:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b461:	7d 11                	jge    f011b474 <test_kheap_phys_addr+0x748>
f011b463:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b46a:	7f 08                	jg     f011b474 <test_kheap_phys_addr+0x748>
f011b46c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b46f:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b472:	72 85                	jb     f011b3f9 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b474:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b477:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b47a:	0f 82 26 ff ff ff    	jb     f011b3a6 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b480:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b484:	74 04                	je     f011b48a <test_kheap_phys_addr+0x75e>
f011b486:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b48a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b491:	83 ec 0c             	sub    $0xc,%esp
f011b494:	68 e4 f0 12 f0       	push   $0xf012f0e4
f011b499:	e8 ed 5a fe ff       	call   f0100f8b <cprintf>
f011b49e:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b4a1:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b4a8:	e9 b0 00 00 00       	jmp    f011b55d <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b4ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b4b0:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b4b7:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b4ba:	83 ec 0c             	sub    $0xc,%esp
f011b4bd:	ff 75 90             	pushl  -0x70(%ebp)
f011b4c0:	e8 ab e3 fe ff       	call   f0109870 <kheap_physical_address>
f011b4c5:	83 c4 10             	add    $0x10,%esp
f011b4c8:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b4cb:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011b4d0:	83 ec 04             	sub    $0x4,%esp
f011b4d3:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b4d9:	52                   	push   %edx
f011b4da:	ff 75 90             	pushl  -0x70(%ebp)
f011b4dd:	50                   	push   %eax
f011b4de:	e8 0c cf fe ff       	call   f01083ef <get_page_table>
f011b4e3:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b4e6:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b4ec:	85 c0                	test   %eax,%eax
f011b4ee:	75 1e                	jne    f011b50e <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b4f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4f7:	83 ec 04             	sub    $0x4,%esp
f011b4fa:	68 34 f1 12 f0       	push   $0xf012f134
f011b4ff:	68 04 06 00 00       	push   $0x604
f011b504:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011b509:	e8 2b 4e fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b50e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b514:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b517:	c1 ea 0c             	shr    $0xc,%edx
f011b51a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b520:	c1 e2 02             	shl    $0x2,%edx
f011b523:	01 d0                	add    %edx,%eax
f011b525:	8b 00                	mov    (%eax),%eax
f011b527:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b52c:	89 c2                	mov    %eax,%edx
f011b52e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b531:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b536:	01 d0                	add    %edx,%eax
f011b538:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b53b:	74 1d                	je     f011b55a <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b53d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b541:	74 17                	je     f011b55a <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b543:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b54a:	83 ec 0c             	sub    $0xc,%esp
f011b54d:	68 94 f1 12 f0       	push   $0xf012f194
f011b552:	e8 34 5a fe ff       	call   f0100f8b <cprintf>
f011b557:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b55a:	ff 45 e0             	incl   -0x20(%ebp)
f011b55d:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b561:	0f 8e 46 ff ff ff    	jle    f011b4ad <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b567:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b56b:	74 04                	je     f011b571 <test_kheap_phys_addr+0x845>
f011b56d:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b571:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b578:	83 ec 0c             	sub    $0xc,%esp
f011b57b:	68 b8 f1 12 f0       	push   $0xf012f1b8
f011b580:	e8 06 5a fe ff       	call   f0100f8b <cprintf>
f011b585:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b588:	e8 75 33 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b58d:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b590:	e8 10 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b595:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b598:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b59e:	83 ec 0c             	sub    $0xc,%esp
f011b5a1:	50                   	push   %eax
f011b5a2:	e8 e3 e1 fe ff       	call   f010978a <kfree>
f011b5a7:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5aa:	e8 f6 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5af:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b5b2:	74 17                	je     f011b5cb <test_kheap_phys_addr+0x89f>
f011b5b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5bb:	83 ec 0c             	sub    $0xc,%esp
f011b5be:	68 a4 dc 12 f0       	push   $0xf012dca4
f011b5c3:	e8 c3 59 fe ff       	call   f0100f8b <cprintf>
f011b5c8:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b5cb:	e8 32 33 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b5d0:	89 c2                	mov    %eax,%edx
f011b5d2:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b5d5:	29 c2                	sub    %eax,%edx
f011b5d7:	89 d0                	mov    %edx,%eax
f011b5d9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b5de:	77 17                	ja     f011b5f7 <test_kheap_phys_addr+0x8cb>
f011b5e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5e7:	83 ec 0c             	sub    $0xc,%esp
f011b5ea:	68 e0 f1 12 f0       	push   $0xf012f1e0
f011b5ef:	e8 97 59 fe ff       	call   f0100f8b <cprintf>
f011b5f4:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b5f7:	e8 06 33 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b5fc:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b5ff:	e8 a1 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b604:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b607:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b60d:	83 ec 0c             	sub    $0xc,%esp
f011b610:	50                   	push   %eax
f011b611:	e8 74 e1 fe ff       	call   f010978a <kfree>
f011b616:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b619:	e8 87 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b61e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b621:	74 17                	je     f011b63a <test_kheap_phys_addr+0x90e>
f011b623:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b62a:	83 ec 0c             	sub    $0xc,%esp
f011b62d:	68 e4 dd 12 f0       	push   $0xf012dde4
f011b632:	e8 54 59 fe ff       	call   f0100f8b <cprintf>
f011b637:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b63a:	e8 c3 32 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b63f:	89 c2                	mov    %eax,%edx
f011b641:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b644:	29 c2                	sub    %eax,%edx
f011b646:	89 d0                	mov    %edx,%eax
f011b648:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b64d:	77 17                	ja     f011b666 <test_kheap_phys_addr+0x93a>
f011b64f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b656:	83 ec 0c             	sub    $0xc,%esp
f011b659:	68 1c f2 12 f0       	push   $0xf012f21c
f011b65e:	e8 28 59 fe ff       	call   f0100f8b <cprintf>
f011b663:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b666:	e8 97 32 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b66b:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b66e:	e8 32 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b673:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b676:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b67c:	83 ec 0c             	sub    $0xc,%esp
f011b67f:	50                   	push   %eax
f011b680:	e8 05 e1 fe ff       	call   f010978a <kfree>
f011b685:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b688:	e8 18 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b68d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b690:	74 17                	je     f011b6a9 <test_kheap_phys_addr+0x97d>
f011b692:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b699:	83 ec 0c             	sub    $0xc,%esp
f011b69c:	68 f0 de 12 f0       	push   $0xf012def0
f011b6a1:	e8 e5 58 fe ff       	call   f0100f8b <cprintf>
f011b6a6:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b6a9:	e8 54 32 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011b6ae:	89 c2                	mov    %eax,%edx
f011b6b0:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b6b3:	29 c2                	sub    %eax,%edx
f011b6b5:	89 d0                	mov    %edx,%eax
f011b6b7:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b6bc:	77 17                	ja     f011b6d5 <test_kheap_phys_addr+0x9a9>
f011b6be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6c5:	83 ec 0c             	sub    $0xc,%esp
f011b6c8:	68 58 f2 12 f0       	push   $0xf012f258
f011b6cd:	e8 b9 58 fe ff       	call   f0100f8b <cprintf>
f011b6d2:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b6d5:	83 ec 0c             	sub    $0xc,%esp
f011b6d8:	68 94 f2 12 f0       	push   $0xf012f294
f011b6dd:	e8 a9 58 fe ff       	call   f0100f8b <cprintf>
f011b6e2:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b6e5:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b6ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b6f3:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b6fa:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b6fd:	8b 15 d8 fd 17 f0    	mov    0xf017fdd8,%edx
f011b703:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b709:	01 d0                	add    %edx,%eax
f011b70b:	05 00 10 00 00       	add    $0x1000,%eax
f011b710:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b716:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b71c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b71f:	eb 25                	jmp    f011b746 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b721:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b724:	8d 43 01             	lea    0x1(%ebx),%eax
f011b727:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b72a:	83 ec 0c             	sub    $0xc,%esp
f011b72d:	ff 75 d8             	pushl  -0x28(%ebp)
f011b730:	e8 3b e1 fe ff       	call   f0109870 <kheap_physical_address>
f011b735:	83 c4 10             	add    $0x10,%esp
f011b738:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b73f:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b746:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b749:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b74c:	72 d3                	jb     f011b721 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b74e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b751:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b757:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b75e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b764:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b767:	e9 f4 00 00 00       	jmp    f011b860 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b76c:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011b771:	83 ec 04             	sub    $0x4,%esp
f011b774:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b77a:	52                   	push   %edx
f011b77b:	ff 75 d8             	pushl  -0x28(%ebp)
f011b77e:	50                   	push   %eax
f011b77f:	e8 6b cc fe ff       	call   f01083ef <get_page_table>
f011b784:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b787:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b78d:	85 c0                	test   %eax,%eax
f011b78f:	75 24                	jne    f011b7b5 <test_kheap_phys_addr+0xa89>
				if (correct)
f011b791:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b795:	74 1e                	je     f011b7b5 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b797:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b79e:	83 ec 04             	sub    $0x4,%esp
f011b7a1:	68 e4 f2 12 f0       	push   $0xf012f2e4
f011b7a6:	68 42 06 00 00       	push   $0x642
f011b7ab:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011b7b0:	e8 84 4b fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b7b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b7b8:	c1 e8 0c             	shr    $0xc,%eax
f011b7bb:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b7c0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b7c3:	eb 7b                	jmp    f011b840 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b7c5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b7cc:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b7d2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b7d5:	c1 e2 02             	shl    $0x2,%edx
f011b7d8:	01 d0                	add    %edx,%eax
f011b7da:	8b 00                	mov    (%eax),%eax
f011b7dc:	83 e0 01             	and    $0x1,%eax
f011b7df:	85 c0                	test   %eax,%eax
f011b7e1:	74 24                	je     f011b807 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b7e3:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b7e9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b7ec:	c1 e2 02             	shl    $0x2,%edx
f011b7ef:	01 d0                	add    %edx,%eax
f011b7f1:	8b 00                	mov    (%eax),%eax
f011b7f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b7f8:	89 c2                	mov    %eax,%edx
f011b7fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b7fd:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b802:	01 d0                	add    %edx,%eax
f011b804:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b807:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b80a:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b811:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b814:	74 1d                	je     f011b833 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b816:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b81a:	74 17                	je     f011b833 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b81c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b823:	83 ec 0c             	sub    $0xc,%esp
f011b826:	68 44 f3 12 f0       	push   $0xf012f344
f011b82b:	e8 5b 57 fe ff       	call   f0100f8b <cprintf>
f011b830:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b833:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b83a:	ff 45 d4             	incl   -0x2c(%ebp)
f011b83d:	ff 45 f4             	incl   -0xc(%ebp)
f011b840:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b843:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b849:	7d 15                	jge    f011b860 <test_kheap_phys_addr+0xb34>
f011b84b:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b852:	7f 0c                	jg     f011b860 <test_kheap_phys_addr+0xb34>
f011b854:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b857:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b85a:	0f 82 65 ff ff ff    	jb     f011b7c5 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b860:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b863:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b866:	0f 82 00 ff ff ff    	jb     f011b76c <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b86c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b870:	74 04                	je     f011b876 <test_kheap_phys_addr+0xb4a>
f011b872:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b876:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b87d:	83 ec 0c             	sub    $0xc,%esp
f011b880:	68 68 f3 12 f0       	push   $0xf012f368
f011b885:	e8 01 57 fe ff       	call   f0100f8b <cprintf>
f011b88a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b88d:	83 ec 0c             	sub    $0xc,%esp
f011b890:	6a 00                	push   $0x0
f011b892:	e8 60 db fe ff       	call   f01093f7 <sbrk>
f011b897:	83 c4 10             	add    $0x10,%esp
f011b89a:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b89f:	77 17                	ja     f011b8b8 <test_kheap_phys_addr+0xb8c>
f011b8a1:	83 ec 04             	sub    $0x4,%esp
f011b8a4:	68 c0 f3 12 f0       	push   $0xf012f3c0
f011b8a9:	68 5d 06 00 00       	push   $0x65d
f011b8ae:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011b8b3:	e8 81 4a fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b8b8:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b8bf:	e9 af 00 00 00       	jmp    f011b973 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b8c4:	83 ec 0c             	sub    $0xc,%esp
f011b8c7:	ff 75 d0             	pushl  -0x30(%ebp)
f011b8ca:	e8 a1 df fe ff       	call   f0109870 <kheap_physical_address>
f011b8cf:	83 c4 10             	add    $0x10,%esp
f011b8d2:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b8d8:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011b8dd:	83 ec 04             	sub    $0x4,%esp
f011b8e0:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b8e6:	52                   	push   %edx
f011b8e7:	ff 75 d0             	pushl  -0x30(%ebp)
f011b8ea:	50                   	push   %eax
f011b8eb:	e8 ff ca fe ff       	call   f01083ef <get_page_table>
f011b8f0:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b8f3:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b8f9:	85 c0                	test   %eax,%eax
f011b8fb:	75 24                	jne    f011b921 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b8fd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b901:	74 1e                	je     f011b921 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b903:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b90a:	83 ec 04             	sub    $0x4,%esp
f011b90d:	68 dc f3 12 f0       	push   $0xf012f3dc
f011b912:	68 65 06 00 00       	push   $0x665
f011b917:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011b91c:	e8 18 4a fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b921:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b927:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b92a:	c1 ea 0c             	shr    $0xc,%edx
f011b92d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b933:	c1 e2 02             	shl    $0x2,%edx
f011b936:	01 d0                	add    %edx,%eax
f011b938:	8b 00                	mov    (%eax),%eax
f011b93a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b93f:	89 c2                	mov    %eax,%edx
f011b941:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b944:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b949:	01 d0                	add    %edx,%eax
f011b94b:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b951:	74 1d                	je     f011b970 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b953:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b957:	74 17                	je     f011b970 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011b959:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b960:	83 ec 0c             	sub    $0xc,%esp
f011b963:	68 3c f4 12 f0       	push   $0xf012f43c
f011b968:	e8 1e 56 fe ff       	call   f0100f8b <cprintf>
f011b96d:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b970:	ff 45 d0             	incl   -0x30(%ebp)
f011b973:	83 ec 0c             	sub    $0xc,%esp
f011b976:	6a 00                	push   $0x0
f011b978:	e8 7a da fe ff       	call   f01093f7 <sbrk>
f011b97d:	83 c4 10             	add    $0x10,%esp
f011b980:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011b983:	0f 87 3b ff ff ff    	ja     f011b8c4 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011b989:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b98d:	74 04                	je     f011b993 <test_kheap_phys_addr+0xc67>
f011b98f:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b993:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011b99a:	83 ec 0c             	sub    $0xc,%esp
f011b99d:	68 60 f4 12 f0       	push   $0xf012f460
f011b9a2:	e8 e4 55 fe ff       	call   f0100f8b <cprintf>
f011b9a7:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011b9aa:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011b9b1:	10 00 f9 
		i = 0;
f011b9b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b9bb:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b9c1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b9c4:	eb 0a                	jmp    f011b9d0 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011b9c6:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b9c9:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011b9d0:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011b9d7:	76 ed                	jbe    f011b9c6 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011b9d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b9dc:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011b9e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b9e9:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b9ef:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011b9f2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011b9f9:	e9 cb 00 00 00       	jmp    f011bac9 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011b9fe:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011ba01:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011ba06:	83 ec 04             	sub    $0x4,%esp
f011ba09:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011ba0f:	51                   	push   %ecx
f011ba10:	52                   	push   %edx
f011ba11:	50                   	push   %eax
f011ba12:	e8 d8 c9 fe ff       	call   f01083ef <get_page_table>
f011ba17:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ba1a:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011ba20:	85 c0                	test   %eax,%eax
f011ba22:	75 24                	jne    f011ba48 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011ba24:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba28:	74 1e                	je     f011ba48 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ba2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba31:	83 ec 04             	sub    $0x4,%esp
f011ba34:	68 9c f4 12 f0       	push   $0xf012f49c
f011ba39:	68 87 06 00 00       	push   $0x687
f011ba3e:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011ba43:	e8 f1 48 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011ba48:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011ba4f:	eb 59                	jmp    f011baaa <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011ba51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba54:	c1 e0 0c             	shl    $0xc,%eax
f011ba57:	89 c2                	mov    %eax,%edx
f011ba59:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011ba5f:	01 d0                	add    %edx,%eax
f011ba61:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011ba67:	83 ec 0c             	sub    $0xc,%esp
f011ba6a:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011ba70:	e8 fb dd fe ff       	call   f0109870 <kheap_physical_address>
f011ba75:	83 c4 10             	add    $0x10,%esp
f011ba78:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011ba7e:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011ba85:	74 1d                	je     f011baa4 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011ba87:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba8b:	74 17                	je     f011baa4 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011ba8d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba94:	83 ec 0c             	sub    $0xc,%esp
f011ba97:	68 fc f4 12 f0       	push   $0xf012f4fc
f011ba9c:	e8 ea 54 fe ff       	call   f0100f8b <cprintf>
f011baa1:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011baa4:	ff 45 c8             	incl   -0x38(%ebp)
f011baa7:	ff 45 f4             	incl   -0xc(%ebp)
f011baaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011baad:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bab3:	7d 09                	jge    f011babe <test_kheap_phys_addr+0xd92>
f011bab5:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011babc:	7e 93                	jle    f011ba51 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011babe:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011bac5:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011bac9:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bacd:	0f 88 2b ff ff ff    	js     f011b9fe <test_kheap_phys_addr+0xcd2>
f011bad3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bad7:	7f 0d                	jg     f011bae6 <test_kheap_phys_addr+0xdba>
f011bad9:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011bae0:	0f 86 18 ff ff ff    	jbe    f011b9fe <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011bae6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011baea:	74 04                	je     f011baf0 <test_kheap_phys_addr+0xdc4>
f011baec:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011baf0:	83 ec 08             	sub    $0x8,%esp
f011baf3:	ff 75 f0             	pushl  -0x10(%ebp)
f011baf6:	68 20 f5 12 f0       	push   $0xf012f520
f011bafb:	e8 8b 54 fe ff       	call   f0100f8b <cprintf>
f011bb00:	83 c4 10             	add    $0x10,%esp

	return 1;
f011bb03:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011bb08:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011bb0b:	5b                   	pop    %ebx
f011bb0c:	5f                   	pop    %edi
f011bb0d:	5d                   	pop    %ebp
f011bb0e:	c3                   	ret    

f011bb0f <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011bb0f:	55                   	push   %ebp
f011bb10:	89 e5                	mov    %esp,%ebp
f011bb12:	57                   	push   %edi
f011bb13:	56                   	push   %esi
f011bb14:	53                   	push   %ebx
f011bb15:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011bb1b:	89 e0                	mov    %esp,%eax
f011bb1d:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011bb1f:	83 ec 0c             	sub    $0xc,%esp
f011bb22:	68 a8 ae 12 f0       	push   $0xf012aea8
f011bb27:	e8 5f 54 fe ff       	call   f0100f8b <cprintf>
f011bb2c:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011bb2f:	83 ec 0c             	sub    $0xc,%esp
f011bb32:	68 d8 ae 12 f0       	push   $0xf012aed8
f011bb37:	e8 4f 54 fe ff       	call   f0100f8b <cprintf>
f011bb3c:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011bb3f:	83 ec 0c             	sub    $0xc,%esp
f011bb42:	68 a8 ae 12 f0       	push   $0xf012aea8
f011bb47:	e8 3f 54 fe ff       	call   f0100f8b <cprintf>
f011bb4c:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011bb4f:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011bb53:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011bb57:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bb5d:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bb63:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011bb6a:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011bb71:	e8 8c 2d ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bb76:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011bb79:	83 ec 0c             	sub    $0xc,%esp
f011bb7c:	68 fc eb 12 f0       	push   $0xf012ebfc
f011bb81:	e8 05 54 fe ff       	call   f0100f8b <cprintf>
f011bb86:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011bb89:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011bb8f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bb94:	b8 00 00 00 00       	mov    $0x0,%eax
f011bb99:	89 d7                	mov    %edx,%edi
f011bb9b:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011bb9d:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011bba3:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bba8:	b8 00 00 00 00       	mov    $0x0,%eax
f011bbad:	89 d7                	mov    %edx,%edi
f011bbaf:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011bbb1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011bbb8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011bbbf:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bbc5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bbca:	b8 00 00 00 00       	mov    $0x0,%eax
f011bbcf:	89 d7                	mov    %edx,%edi
f011bbd1:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bbd3:	e8 2a 2d ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bbd8:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bbdb:	e8 c5 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bbe0:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011bbe3:	83 ec 0c             	sub    $0xc,%esp
f011bbe6:	68 00 fc 1f 00       	push   $0x1ffc00
f011bbeb:	e8 3a d9 fe ff       	call   f010952a <kmalloc>
f011bbf0:	83 c4 10             	add    $0x10,%esp
f011bbf3:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bbf9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bbff:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bc04:	74 17                	je     f011bc1d <test_kheap_virt_addr+0x10e>
f011bc06:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc0d:	83 ec 0c             	sub    $0xc,%esp
f011bc10:	68 a0 cf 12 f0       	push   $0xf012cfa0
f011bc15:	e8 71 53 fe ff       	call   f0100f8b <cprintf>
f011bc1a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc1d:	e8 83 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc22:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bc25:	74 17                	je     f011bc3e <test_kheap_virt_addr+0x12f>
f011bc27:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc2e:	83 ec 0c             	sub    $0xc,%esp
f011bc31:	68 f4 cf 12 f0       	push   $0xf012cff4
f011bc36:	e8 50 53 fe ff       	call   f0100f8b <cprintf>
f011bc3b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bc3e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bc41:	e8 bc 2c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bc46:	29 c3                	sub    %eax,%ebx
f011bc48:	89 d8                	mov    %ebx,%eax
f011bc4a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bc4f:	77 17                	ja     f011bc68 <test_kheap_virt_addr+0x159>
f011bc51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc58:	83 ec 0c             	sub    $0xc,%esp
f011bc5b:	68 64 d0 12 f0       	push   $0xf012d064
f011bc60:	e8 26 53 fe ff       	call   f0100f8b <cprintf>
f011bc65:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bc68:	e8 95 2c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bc6d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc70:	e8 30 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc75:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011bc78:	83 ec 0c             	sub    $0xc,%esp
f011bc7b:	68 00 fc 1f 00       	push   $0x1ffc00
f011bc80:	e8 a5 d8 fe ff       	call   f010952a <kmalloc>
f011bc85:	83 c4 10             	add    $0x10,%esp
f011bc88:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bc8e:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bc94:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011bc99:	74 17                	je     f011bcb2 <test_kheap_virt_addr+0x1a3>
f011bc9b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bca2:	83 ec 0c             	sub    $0xc,%esp
f011bca5:	68 ac d0 12 f0       	push   $0xf012d0ac
f011bcaa:	e8 dc 52 fe ff       	call   f0100f8b <cprintf>
f011bcaf:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bcb2:	e8 ee 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcb7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bcba:	74 17                	je     f011bcd3 <test_kheap_virt_addr+0x1c4>
f011bcbc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcc3:	83 ec 0c             	sub    $0xc,%esp
f011bcc6:	68 00 d1 12 f0       	push   $0xf012d100
f011bccb:	e8 bb 52 fe ff       	call   f0100f8b <cprintf>
f011bcd0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bcd3:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bcd6:	e8 27 2c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bcdb:	29 c3                	sub    %eax,%ebx
f011bcdd:	89 d8                	mov    %ebx,%eax
f011bcdf:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bce4:	77 17                	ja     f011bcfd <test_kheap_virt_addr+0x1ee>
f011bce6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bced:	83 ec 0c             	sub    $0xc,%esp
f011bcf0:	68 70 d1 12 f0       	push   $0xf012d170
f011bcf5:	e8 91 52 fe ff       	call   f0100f8b <cprintf>
f011bcfa:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011bcfd:	e8 00 2c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bd02:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bd05:	e8 9b 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd0a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011bd0d:	83 ec 0c             	sub    $0xc,%esp
f011bd10:	68 00 04 00 00       	push   $0x400
f011bd15:	e8 10 d8 fe ff       	call   f010952a <kmalloc>
f011bd1a:	83 c4 10             	add    $0x10,%esp
f011bd1d:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011bd23:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bd29:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bd2e:	76 28                	jbe    f011bd58 <test_kheap_virt_addr+0x249>
f011bd30:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011bd36:	83 ec 0c             	sub    $0xc,%esp
f011bd39:	6a 00                	push   $0x0
f011bd3b:	e8 b7 d6 fe ff       	call   f01093f7 <sbrk>
f011bd40:	83 c4 10             	add    $0x10,%esp
f011bd43:	39 c3                	cmp    %eax,%ebx
f011bd45:	73 11                	jae    f011bd58 <test_kheap_virt_addr+0x249>
f011bd47:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bd4d:	89 c2                	mov    %eax,%edx
f011bd4f:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bd54:	39 c2                	cmp    %eax,%edx
f011bd56:	72 17                	jb     f011bd6f <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bd58:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd5f:	83 ec 0c             	sub    $0xc,%esp
f011bd62:	68 2c ec 12 f0       	push   $0xf012ec2c
f011bd67:	e8 1f 52 fe ff       	call   f0100f8b <cprintf>
f011bd6c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd6f:	e8 31 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd74:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bd77:	74 17                	je     f011bd90 <test_kheap_virt_addr+0x281>
f011bd79:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd80:	83 ec 0c             	sub    $0xc,%esp
f011bd83:	68 0c d2 12 f0       	push   $0xf012d20c
f011bd88:	e8 fe 51 fe ff       	call   f0100f8b <cprintf>
f011bd8d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011bd90:	e8 6d 2b ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bd95:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bd98:	e8 08 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd9d:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011bda0:	83 ec 0c             	sub    $0xc,%esp
f011bda3:	68 00 08 00 00       	push   $0x800
f011bda8:	e8 7d d7 fe ff       	call   f010952a <kmalloc>
f011bdad:	83 c4 10             	add    $0x10,%esp
f011bdb0:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011bdb6:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011bdbc:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bdc1:	76 28                	jbe    f011bdeb <test_kheap_virt_addr+0x2dc>
f011bdc3:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011bdc9:	83 ec 0c             	sub    $0xc,%esp
f011bdcc:	6a 00                	push   $0x0
f011bdce:	e8 24 d6 fe ff       	call   f01093f7 <sbrk>
f011bdd3:	83 c4 10             	add    $0x10,%esp
f011bdd6:	39 c3                	cmp    %eax,%ebx
f011bdd8:	73 11                	jae    f011bdeb <test_kheap_virt_addr+0x2dc>
f011bdda:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011bde0:	89 c2                	mov    %eax,%edx
f011bde2:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bde7:	39 c2                	cmp    %eax,%edx
f011bde9:	72 17                	jb     f011be02 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bdeb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdf2:	83 ec 0c             	sub    $0xc,%esp
f011bdf5:	68 b8 ec 12 f0       	push   $0xf012ecb8
f011bdfa:	e8 8c 51 fe ff       	call   f0100f8b <cprintf>
f011bdff:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be02:	e8 9e 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be07:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011be0a:	74 17                	je     f011be23 <test_kheap_virt_addr+0x314>
f011be0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be13:	83 ec 0c             	sub    $0xc,%esp
f011be16:	68 18 d3 12 f0       	push   $0xf012d318
f011be1b:	e8 6b 51 fe ff       	call   f0100f8b <cprintf>
f011be20:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011be23:	e8 da 2a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011be28:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011be2b:	e8 75 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be30:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011be33:	83 ec 0c             	sub    $0xc,%esp
f011be36:	68 00 06 00 00       	push   $0x600
f011be3b:	e8 ea d6 fe ff       	call   f010952a <kmalloc>
f011be40:	83 c4 10             	add    $0x10,%esp
f011be43:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011be49:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011be4f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011be54:	76 28                	jbe    f011be7e <test_kheap_virt_addr+0x36f>
f011be56:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011be5c:	83 ec 0c             	sub    $0xc,%esp
f011be5f:	6a 00                	push   $0x0
f011be61:	e8 91 d5 fe ff       	call   f01093f7 <sbrk>
f011be66:	83 c4 10             	add    $0x10,%esp
f011be69:	39 c3                	cmp    %eax,%ebx
f011be6b:	73 11                	jae    f011be7e <test_kheap_virt_addr+0x36f>
f011be6d:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011be73:	89 c2                	mov    %eax,%edx
f011be75:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011be7a:	39 c2                	cmp    %eax,%edx
f011be7c:	72 17                	jb     f011be95 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011be7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be85:	83 ec 0c             	sub    $0xc,%esp
f011be88:	68 44 ed 12 f0       	push   $0xf012ed44
f011be8d:	e8 f9 50 fe ff       	call   f0100f8b <cprintf>
f011be92:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be95:	e8 0b 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be9a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011be9d:	74 17                	je     f011beb6 <test_kheap_virt_addr+0x3a7>
f011be9f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bea6:	83 ec 0c             	sub    $0xc,%esp
f011bea9:	68 24 d4 12 f0       	push   $0xf012d424
f011beae:	e8 d8 50 fe ff       	call   f0100f8b <cprintf>
f011beb3:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011beb6:	e8 47 2a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bebb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bebe:	e8 e2 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bec3:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bec6:	83 ec 0c             	sub    $0xc,%esp
f011bec9:	68 00 1c 00 00       	push   $0x1c00
f011bece:	e8 57 d6 fe ff       	call   f010952a <kmalloc>
f011bed3:	83 c4 10             	add    $0x10,%esp
f011bed6:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bedc:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bee2:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bee7:	74 17                	je     f011bf00 <test_kheap_virt_addr+0x3f1>
f011bee9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bef0:	83 ec 0c             	sub    $0xc,%esp
f011bef3:	68 dc d4 12 f0       	push   $0xf012d4dc
f011bef8:	e8 8e 50 fe ff       	call   f0100f8b <cprintf>
f011befd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf00:	e8 a0 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf05:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf08:	74 17                	je     f011bf21 <test_kheap_virt_addr+0x412>
f011bf0a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf11:	83 ec 0c             	sub    $0xc,%esp
f011bf14:	68 30 d5 12 f0       	push   $0xf012d530
f011bf19:	e8 6d 50 fe ff       	call   f0100f8b <cprintf>
f011bf1e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bf21:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bf24:	e8 d9 29 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bf29:	29 c3                	sub    %eax,%ebx
f011bf2b:	89 d8                	mov    %ebx,%eax
f011bf2d:	83 f8 01             	cmp    $0x1,%eax
f011bf30:	77 17                	ja     f011bf49 <test_kheap_virt_addr+0x43a>
f011bf32:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf39:	83 ec 0c             	sub    $0xc,%esp
f011bf3c:	68 a0 d5 12 f0       	push   $0xf012d5a0
f011bf41:	e8 45 50 fe ff       	call   f0100f8b <cprintf>
f011bf46:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011bf49:	e8 b4 29 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bf4e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bf51:	e8 4f 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf56:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bf59:	83 ec 0c             	sub    $0xc,%esp
f011bf5c:	68 00 fc 2f 00       	push   $0x2ffc00
f011bf61:	e8 c4 d5 fe ff       	call   f010952a <kmalloc>
f011bf66:	83 c4 10             	add    $0x10,%esp
f011bf69:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bf6f:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bf75:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bf7a:	74 17                	je     f011bf93 <test_kheap_virt_addr+0x484>
f011bf7c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf83:	83 ec 0c             	sub    $0xc,%esp
f011bf86:	68 d0 ed 12 f0       	push   $0xf012edd0
f011bf8b:	e8 fb 4f fe ff       	call   f0100f8b <cprintf>
f011bf90:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf93:	e8 0d 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf98:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf9b:	74 17                	je     f011bfb4 <test_kheap_virt_addr+0x4a5>
f011bf9d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfa4:	83 ec 0c             	sub    $0xc,%esp
f011bfa7:	68 74 d6 12 f0       	push   $0xf012d674
f011bfac:	e8 da 4f fe ff       	call   f0100f8b <cprintf>
f011bfb1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bfb4:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bfb7:	e8 46 29 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bfbc:	29 c3                	sub    %eax,%ebx
f011bfbe:	89 d8                	mov    %ebx,%eax
f011bfc0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bfc5:	77 17                	ja     f011bfde <test_kheap_virt_addr+0x4cf>
f011bfc7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfce:	83 ec 0c             	sub    $0xc,%esp
f011bfd1:	68 24 ee 12 f0       	push   $0xf012ee24
f011bfd6:	e8 b0 4f fe ff       	call   f0100f8b <cprintf>
f011bfdb:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bfde:	e8 1f 29 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011bfe3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bfe6:	e8 ba 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bfeb:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011bfee:	83 ec 0c             	sub    $0xc,%esp
f011bff1:	68 00 fc 5f 00       	push   $0x5ffc00
f011bff6:	e8 2f d5 fe ff       	call   f010952a <kmalloc>
f011bffb:	83 c4 10             	add    $0x10,%esp
f011bffe:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c004:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c00a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c00f:	74 17                	je     f011c028 <test_kheap_virt_addr+0x519>
f011c011:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c018:	83 ec 0c             	sub    $0xc,%esp
f011c01b:	68 6c ee 12 f0       	push   $0xf012ee6c
f011c020:	e8 66 4f fe ff       	call   f0100f8b <cprintf>
f011c025:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c028:	e8 78 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c02d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c030:	74 17                	je     f011c049 <test_kheap_virt_addr+0x53a>
f011c032:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c039:	83 ec 0c             	sub    $0xc,%esp
f011c03c:	68 70 d7 12 f0       	push   $0xf012d770
f011c041:	e8 45 4f fe ff       	call   f0100f8b <cprintf>
f011c046:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c049:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c04c:	e8 b1 28 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c051:	29 c3                	sub    %eax,%ebx
f011c053:	89 d8                	mov    %ebx,%eax
f011c055:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c05a:	77 17                	ja     f011c073 <test_kheap_virt_addr+0x564>
f011c05c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c063:	83 ec 0c             	sub    $0xc,%esp
f011c066:	68 c0 ee 12 f0       	push   $0xf012eec0
f011c06b:	e8 1b 4f fe ff       	call   f0100f8b <cprintf>
f011c070:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c073:	e8 8a 28 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c078:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c07b:	e8 25 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c080:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c083:	83 ec 0c             	sub    $0xc,%esp
f011c086:	68 00 38 00 00       	push   $0x3800
f011c08b:	e8 9a d4 fe ff       	call   f010952a <kmalloc>
f011c090:	83 c4 10             	add    $0x10,%esp
f011c093:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c099:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c09f:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c0a4:	74 17                	je     f011c0bd <test_kheap_virt_addr+0x5ae>
f011c0a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0ad:	83 ec 0c             	sub    $0xc,%esp
f011c0b0:	68 08 ef 12 f0       	push   $0xf012ef08
f011c0b5:	e8 d1 4e fe ff       	call   f0100f8b <cprintf>
f011c0ba:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c0bd:	e8 e3 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c0c2:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c0c5:	74 17                	je     f011c0de <test_kheap_virt_addr+0x5cf>
f011c0c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0ce:	83 ec 0c             	sub    $0xc,%esp
f011c0d1:	68 5c ef 12 f0       	push   $0xf012ef5c
f011c0d6:	e8 b0 4e fe ff       	call   f0100f8b <cprintf>
f011c0db:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c0de:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c0e1:	e8 1c 28 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c0e6:	29 c3                	sub    %eax,%ebx
f011c0e8:	89 d8                	mov    %ebx,%eax
f011c0ea:	83 f8 03             	cmp    $0x3,%eax
f011c0ed:	77 17                	ja     f011c106 <test_kheap_virt_addr+0x5f7>
f011c0ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0f6:	83 ec 0c             	sub    $0xc,%esp
f011c0f9:	68 cc ef 12 f0       	push   $0xf012efcc
f011c0fe:	e8 88 4e fe ff       	call   f0100f8b <cprintf>
f011c103:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c106:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c10d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c110:	c1 e8 0c             	shr    $0xc,%eax
f011c113:	89 c2                	mov    %eax,%edx
f011c115:	4a                   	dec    %edx
f011c116:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c119:	c1 e0 02             	shl    $0x2,%eax
f011c11c:	8d 50 03             	lea    0x3(%eax),%edx
f011c11f:	b8 10 00 00 00       	mov    $0x10,%eax
f011c124:	48                   	dec    %eax
f011c125:	01 d0                	add    %edx,%eax
f011c127:	bf 10 00 00 00       	mov    $0x10,%edi
f011c12c:	ba 00 00 00 00       	mov    $0x0,%edx
f011c131:	f7 f7                	div    %edi
f011c133:	6b c0 10             	imul   $0x10,%eax,%eax
f011c136:	29 c4                	sub    %eax,%esp
f011c138:	89 e0                	mov    %esp,%eax
f011c13a:	83 c0 03             	add    $0x3,%eax
f011c13d:	c1 e8 02             	shr    $0x2,%eax
f011c140:	c1 e0 02             	shl    $0x2,%eax
f011c143:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c146:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c149:	c1 e8 0c             	shr    $0xc,%eax
f011c14c:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c14f:	83 ec 0c             	sub    $0xc,%esp
f011c152:	68 54 f5 12 f0       	push   $0xf012f554
f011c157:	e8 2f 4e fe ff       	call   f0100f8b <cprintf>
f011c15c:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c15f:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c166:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c16b:	05 00 10 00 00       	add    $0x1000,%eax
f011c170:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c173:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c17a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c17d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c180:	e9 2d 01 00 00       	jmp    f011c2b2 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c185:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011c18a:	83 ec 04             	sub    $0x4,%esp
f011c18d:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c193:	52                   	push   %edx
f011c194:	ff 75 dc             	pushl  -0x24(%ebp)
f011c197:	50                   	push   %eax
f011c198:	e8 52 c2 fe ff       	call   f01083ef <get_page_table>
f011c19d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c1a0:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c1a6:	85 c0                	test   %eax,%eax
f011c1a8:	75 1e                	jne    f011c1c8 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c1aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1b1:	83 ec 04             	sub    $0x4,%esp
f011c1b4:	68 60 f0 12 f0       	push   $0xf012f060
f011c1b9:	68 26 07 00 00       	push   $0x726
f011c1be:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011c1c3:	e8 71 41 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c1c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c1cb:	c1 e8 0c             	shr    $0xc,%eax
f011c1ce:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c1d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c1d6:	e9 ba 00 00 00       	jmp    f011c295 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c1db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c1de:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c1e1:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c1e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c1ea:	c1 e2 02             	shl    $0x2,%edx
f011c1ed:	01 d0                	add    %edx,%eax
f011c1ef:	8b 00                	mov    (%eax),%eax
f011c1f1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c1f6:	89 c2                	mov    %eax,%edx
f011c1f8:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c1fb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c1fe:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c201:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c204:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c207:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c20a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c20d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c210:	83 ec 0c             	sub    $0xc,%esp
f011c213:	50                   	push   %eax
f011c214:	e8 b4 d6 fe ff       	call   f01098cd <kheap_virtual_address>
f011c219:	83 c4 10             	add    $0x10,%esp
f011c21c:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c21f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c222:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c225:	01 d0                	add    %edx,%eax
f011c227:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c22a:	74 5c                	je     f011c288 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c22c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c230:	74 56                	je     f011c288 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c232:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c235:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c238:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c23b:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c241:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c244:	c1 e1 02             	shl    $0x2,%ecx
f011c247:	01 ca                	add    %ecx,%edx
f011c249:	8b 12                	mov    (%edx),%edx
f011c24b:	89 d1                	mov    %edx,%ecx
f011c24d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c253:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c256:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c259:	01 da                	add    %ebx,%edx
f011c25b:	83 ec 0c             	sub    $0xc,%esp
f011c25e:	50                   	push   %eax
f011c25f:	51                   	push   %ecx
f011c260:	52                   	push   %edx
f011c261:	ff 75 8c             	pushl  -0x74(%ebp)
f011c264:	68 a0 f5 12 f0       	push   $0xf012f5a0
f011c269:	e8 1d 4d fe ff       	call   f0100f8b <cprintf>
f011c26e:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c271:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c278:	83 ec 0c             	sub    $0xc,%esp
f011c27b:	68 e4 f5 12 f0       	push   $0xf012f5e4
f011c280:	e8 06 4d fe ff       	call   f0100f8b <cprintf>
f011c285:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c288:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c28f:	ff 45 d4             	incl   -0x2c(%ebp)
f011c292:	ff 45 d8             	incl   -0x28(%ebp)
f011c295:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c298:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c29b:	7d 15                	jge    f011c2b2 <test_kheap_virt_addr+0x7a3>
f011c29d:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c2a4:	7f 0c                	jg     f011c2b2 <test_kheap_virt_addr+0x7a3>
f011c2a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c2a9:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c2ac:	0f 82 29 ff ff ff    	jb     f011c1db <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c2b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c2b5:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c2b8:	0f 82 c7 fe ff ff    	jb     f011c185 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c2be:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c2c2:	74 04                	je     f011c2c8 <test_kheap_virt_addr+0x7b9>
f011c2c4:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c2c8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c2cf:	83 ec 0c             	sub    $0xc,%esp
f011c2d2:	68 08 f6 12 f0       	push   $0xf012f608
f011c2d7:	e8 af 4c fe ff       	call   f0100f8b <cprintf>
f011c2dc:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c2df:	e8 1e 26 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c2e4:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c2e7:	e8 b9 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c2ec:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c2ef:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c2f5:	83 ec 0c             	sub    $0xc,%esp
f011c2f8:	50                   	push   %eax
f011c2f9:	e8 8c d4 fe ff       	call   f010978a <kfree>
f011c2fe:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c301:	e8 9f 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c306:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c309:	74 17                	je     f011c322 <test_kheap_virt_addr+0x813>
f011c30b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c312:	83 ec 0c             	sub    $0xc,%esp
f011c315:	68 30 f6 12 f0       	push   $0xf012f630
f011c31a:	e8 6c 4c fe ff       	call   f0100f8b <cprintf>
f011c31f:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c322:	e8 db 25 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c327:	89 c2                	mov    %eax,%edx
f011c329:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c32c:	29 c2                	sub    %eax,%edx
f011c32e:	89 d0                	mov    %edx,%eax
f011c330:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c335:	77 17                	ja     f011c34e <test_kheap_virt_addr+0x83f>
f011c337:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c33e:	83 ec 0c             	sub    $0xc,%esp
f011c341:	68 a0 f6 12 f0       	push   $0xf012f6a0
f011c346:	e8 40 4c fe ff       	call   f0100f8b <cprintf>
f011c34b:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c34e:	e8 af 25 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c353:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c356:	e8 4a 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c35b:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c35e:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c364:	83 ec 0c             	sub    $0xc,%esp
f011c367:	50                   	push   %eax
f011c368:	e8 1d d4 fe ff       	call   f010978a <kfree>
f011c36d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c370:	e8 30 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c375:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c378:	74 17                	je     f011c391 <test_kheap_virt_addr+0x882>
f011c37a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c381:	83 ec 0c             	sub    $0xc,%esp
f011c384:	68 dc f6 12 f0       	push   $0xf012f6dc
f011c389:	e8 fd 4b fe ff       	call   f0100f8b <cprintf>
f011c38e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c391:	e8 6c 25 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c396:	89 c2                	mov    %eax,%edx
f011c398:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c39b:	29 c2                	sub    %eax,%edx
f011c39d:	89 d0                	mov    %edx,%eax
f011c39f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c3a4:	77 17                	ja     f011c3bd <test_kheap_virt_addr+0x8ae>
f011c3a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3ad:	83 ec 0c             	sub    $0xc,%esp
f011c3b0:	68 4c f7 12 f0       	push   $0xf012f74c
f011c3b5:	e8 d1 4b fe ff       	call   f0100f8b <cprintf>
f011c3ba:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c3bd:	e8 40 25 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c3c2:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c3c5:	e8 db 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3ca:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c3cd:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c3d3:	83 ec 0c             	sub    $0xc,%esp
f011c3d6:	50                   	push   %eax
f011c3d7:	e8 ae d3 fe ff       	call   f010978a <kfree>
f011c3dc:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c3df:	e8 c1 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3e4:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c3e7:	74 17                	je     f011c400 <test_kheap_virt_addr+0x8f1>
f011c3e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3f0:	83 ec 0c             	sub    $0xc,%esp
f011c3f3:	68 88 f7 12 f0       	push   $0xf012f788
f011c3f8:	e8 8e 4b fe ff       	call   f0100f8b <cprintf>
f011c3fd:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c400:	e8 fd 24 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c405:	89 c2                	mov    %eax,%edx
f011c407:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c40a:	29 c2                	sub    %eax,%edx
f011c40c:	89 d0                	mov    %edx,%eax
f011c40e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c413:	77 17                	ja     f011c42c <test_kheap_virt_addr+0x91d>
f011c415:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c41c:	83 ec 0c             	sub    $0xc,%esp
f011c41f:	68 f8 f7 12 f0       	push   $0xf012f7f8
f011c424:	e8 62 4b fe ff       	call   f0100f8b <cprintf>
f011c429:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c42c:	83 ec 0c             	sub    $0xc,%esp
f011c42f:	68 34 f8 12 f0       	push   $0xf012f834
f011c434:	e8 52 4b fe ff       	call   f0100f8b <cprintf>
f011c439:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c43c:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c443:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c448:	05 00 10 00 00       	add    $0x1000,%eax
f011c44d:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c453:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c45a:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c461:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c464:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c46a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c46d:	eb 44                	jmp    f011c4b3 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c46f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c472:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c475:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c478:	83 ec 0c             	sub    $0xc,%esp
f011c47b:	50                   	push   %eax
f011c47c:	e8 4c d4 fe ff       	call   f01098cd <kheap_virtual_address>
f011c481:	83 c4 10             	add    $0x10,%esp
f011c484:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c48a:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c491:	74 1d                	je     f011c4b0 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c493:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c497:	74 17                	je     f011c4b0 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c499:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4a0:	83 ec 0c             	sub    $0xc,%esp
f011c4a3:	68 84 f8 12 f0       	push   $0xf012f884
f011c4a8:	e8 de 4a fe ff       	call   f0100f8b <cprintf>
f011c4ad:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c4b0:	ff 45 d0             	incl   -0x30(%ebp)
f011c4b3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c4b9:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c4bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4c2:	39 c2                	cmp    %eax,%edx
f011c4c4:	77 a9                	ja     f011c46f <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c4c6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c4cc:	05 00 04 00 00       	add    $0x400,%eax
f011c4d1:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c4d4:	eb 64                	jmp    f011c53a <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c4d6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4d9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c4dc:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c4df:	83 ec 0c             	sub    $0xc,%esp
f011c4e2:	50                   	push   %eax
f011c4e3:	e8 e5 d3 fe ff       	call   f01098cd <kheap_virtual_address>
f011c4e8:	83 c4 10             	add    $0x10,%esp
f011c4eb:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c4f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4f4:	c1 e0 0c             	shl    $0xc,%eax
f011c4f7:	89 c2                	mov    %eax,%edx
f011c4f9:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c4ff:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c502:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c505:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c508:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c50b:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c510:	01 c8                	add    %ecx,%eax
f011c512:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c518:	74 1d                	je     f011c537 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c51a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c51e:	74 17                	je     f011c537 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c520:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c527:	83 ec 0c             	sub    $0xc,%esp
f011c52a:	68 a8 f8 12 f0       	push   $0xf012f8a8
f011c52f:	e8 57 4a fe ff       	call   f0100f8b <cprintf>
f011c534:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c537:	ff 45 d0             	incl   -0x30(%ebp)
f011c53a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c540:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c546:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c549:	39 c2                	cmp    %eax,%edx
f011c54b:	77 89                	ja     f011c4d6 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c54d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c553:	05 02 07 00 00       	add    $0x702,%eax
f011c558:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c55b:	eb 44                	jmp    f011c5a1 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c55d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c560:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c563:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c566:	83 ec 0c             	sub    $0xc,%esp
f011c569:	50                   	push   %eax
f011c56a:	e8 5e d3 fe ff       	call   f01098cd <kheap_virtual_address>
f011c56f:	83 c4 10             	add    $0x10,%esp
f011c572:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c578:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c57f:	74 1d                	je     f011c59e <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c581:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c585:	74 17                	je     f011c59e <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c587:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c58e:	83 ec 0c             	sub    $0xc,%esp
f011c591:	68 cc f8 12 f0       	push   $0xf012f8cc
f011c596:	e8 f0 49 fe ff       	call   f0100f8b <cprintf>
f011c59b:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c59e:	ff 45 d0             	incl   -0x30(%ebp)
f011c5a1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c5a7:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c5ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5b0:	39 c2                	cmp    %eax,%edx
f011c5b2:	77 a9                	ja     f011c55d <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c5b4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c5ba:	05 02 0d 00 00       	add    $0xd02,%eax
f011c5bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c5c2:	eb 64                	jmp    f011c628 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c5c4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c5c7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c5ca:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c5cd:	83 ec 0c             	sub    $0xc,%esp
f011c5d0:	50                   	push   %eax
f011c5d1:	e8 f7 d2 fe ff       	call   f01098cd <kheap_virtual_address>
f011c5d6:	83 c4 10             	add    $0x10,%esp
f011c5d9:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c5df:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5e2:	c1 e0 0c             	shl    $0xc,%eax
f011c5e5:	89 c2                	mov    %eax,%edx
f011c5e7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c5ed:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c5f0:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c5f3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c5f6:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c5f9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c5fe:	01 c8                	add    %ecx,%eax
f011c600:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c606:	74 1d                	je     f011c625 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011c608:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c60c:	74 17                	je     f011c625 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011c60e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c615:	83 ec 0c             	sub    $0xc,%esp
f011c618:	68 f0 f8 12 f0       	push   $0xf012f8f0
f011c61d:	e8 69 49 fe ff       	call   f0100f8b <cprintf>
f011c622:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c625:	ff 45 d0             	incl   -0x30(%ebp)
f011c628:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c62e:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c634:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c637:	39 c2                	cmp    %eax,%edx
f011c639:	77 89                	ja     f011c5c4 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c63b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c63f:	74 04                	je     f011c645 <test_kheap_virt_addr+0xb36>
f011c641:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c645:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c64c:	83 ec 0c             	sub    $0xc,%esp
f011c64f:	68 14 f9 12 f0       	push   $0xf012f914
f011c654:	e8 32 49 fe ff       	call   f0100f8b <cprintf>
f011c659:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c65c:	83 ec 0c             	sub    $0xc,%esp
f011c65f:	6a 00                	push   $0x0
f011c661:	e8 91 cd fe ff       	call   f01093f7 <sbrk>
f011c666:	83 c4 10             	add    $0x10,%esp
f011c669:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c66e:	77 17                	ja     f011c687 <test_kheap_virt_addr+0xb78>
f011c670:	83 ec 04             	sub    $0x4,%esp
f011c673:	68 5b f9 12 f0       	push   $0xf012f95b
f011c678:	68 91 07 00 00       	push   $0x791
f011c67d:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011c682:	e8 b2 3c fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c687:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c68e:	e9 d1 00 00 00       	jmp    f011c764 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c693:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011c698:	83 ec 04             	sub    $0x4,%esp
f011c69b:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c6a1:	52                   	push   %edx
f011c6a2:	ff 75 cc             	pushl  -0x34(%ebp)
f011c6a5:	50                   	push   %eax
f011c6a6:	e8 44 bd fe ff       	call   f01083ef <get_page_table>
f011c6ab:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c6ae:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c6b4:	85 c0                	test   %eax,%eax
f011c6b6:	75 1e                	jne    f011c6d6 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c6b8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6bf:	83 ec 04             	sub    $0x4,%esp
f011c6c2:	68 e4 f2 12 f0       	push   $0xf012f2e4
f011c6c7:	68 97 07 00 00       	push   $0x797
f011c6cc:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011c6d1:	e8 63 3c fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c6d6:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c6dc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c6df:	c1 ea 0c             	shr    $0xc,%edx
f011c6e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c6e8:	c1 e2 02             	shl    $0x2,%edx
f011c6eb:	01 d0                	add    %edx,%eax
f011c6ed:	8b 00                	mov    (%eax),%eax
f011c6ef:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c6f4:	89 c2                	mov    %eax,%edx
f011c6f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c6f9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c6fe:	01 d0                	add    %edx,%eax
f011c700:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c706:	83 ec 0c             	sub    $0xc,%esp
f011c709:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c70f:	e8 b9 d1 fe ff       	call   f01098cd <kheap_virtual_address>
f011c714:	83 c4 10             	add    $0x10,%esp
f011c717:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c71d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c723:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c726:	74 39                	je     f011c761 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c728:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c72c:	74 33                	je     f011c761 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c72e:	ff 75 cc             	pushl  -0x34(%ebp)
f011c731:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c737:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c73d:	68 74 f9 12 f0       	push   $0xf012f974
f011c742:	e8 44 48 fe ff       	call   f0100f8b <cprintf>
f011c747:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c74a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c751:	83 ec 0c             	sub    $0xc,%esp
f011c754:	68 a0 f9 12 f0       	push   $0xf012f9a0
f011c759:	e8 2d 48 fe ff       	call   f0100f8b <cprintf>
f011c75e:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c761:	ff 45 cc             	incl   -0x34(%ebp)
f011c764:	83 ec 0c             	sub    $0xc,%esp
f011c767:	6a 00                	push   $0x0
f011c769:	e8 89 cc fe ff       	call   f01093f7 <sbrk>
f011c76e:	83 c4 10             	add    $0x10,%esp
f011c771:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c774:	0f 87 19 ff ff ff    	ja     f011c693 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c77a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c77e:	74 04                	je     f011c784 <test_kheap_virt_addr+0xc75>
f011c780:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c784:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c78b:	83 ec 0c             	sub    $0xc,%esp
f011c78e:	68 c4 f9 12 f0       	push   $0xf012f9c4
f011c793:	e8 f3 47 fe ff       	call   f0100f8b <cprintf>
f011c798:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c79b:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c7a2:	eb 5a                	jmp    f011c7fe <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c7a4:	83 ec 0c             	sub    $0xc,%esp
f011c7a7:	ff 75 c8             	pushl  -0x38(%ebp)
f011c7aa:	e8 1e d1 fe ff       	call   f01098cd <kheap_virtual_address>
f011c7af:	83 c4 10             	add    $0x10,%esp
f011c7b2:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c7b8:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c7bf:	74 36                	je     f011c7f7 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c7c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c7c5:	74 30                	je     f011c7f7 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c7c7:	83 ec 04             	sub    $0x4,%esp
f011c7ca:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c7d0:	ff 75 c8             	pushl  -0x38(%ebp)
f011c7d3:	68 03 fa 12 f0       	push   $0xf012fa03
f011c7d8:	e8 ae 47 fe ff       	call   f0100f8b <cprintf>
f011c7dd:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c7e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7e7:	83 ec 0c             	sub    $0xc,%esp
f011c7ea:	68 20 fa 12 f0       	push   $0xf012fa20
f011c7ef:	e8 97 47 fe ff       	call   f0100f8b <cprintf>
f011c7f4:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c7f7:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c7fe:	b8 50 60 65 02       	mov    $0x2656050,%eax
f011c803:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c806:	72 9c                	jb     f011c7a4 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c808:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c80c:	74 04                	je     f011c812 <test_kheap_virt_addr+0xd03>
f011c80e:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c812:	83 ec 08             	sub    $0x8,%esp
f011c815:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c818:	68 44 fa 12 f0       	push   $0xf012fa44
f011c81d:	e8 69 47 fe ff       	call   f0100f8b <cprintf>
f011c822:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c825:	b8 01 00 00 00       	mov    $0x1,%eax
f011c82a:	89 f4                	mov    %esi,%esp

}
f011c82c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c82f:	5b                   	pop    %ebx
f011c830:	5e                   	pop    %esi
f011c831:	5f                   	pop    %edi
f011c832:	5d                   	pop    %ebp
f011c833:	c3                   	ret    

f011c834 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c834:	55                   	push   %ebp
f011c835:	89 e5                	mov    %esp,%ebp
f011c837:	57                   	push   %edi
f011c838:	56                   	push   %esi
f011c839:	53                   	push   %ebx
f011c83a:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c840:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c846:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c84b:	b8 00 00 00 00       	mov    $0x0,%eax
f011c850:	89 d7                	mov    %edx,%edi
f011c852:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c854:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c85b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c862:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c869:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011c86e:	0f b6 c0             	movzbl %al,%eax
f011c871:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c874:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c87b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c87e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c881:	39 c2                	cmp    %eax,%edx
f011c883:	73 02                	jae    f011c887 <test_ksbrk+0x53>
f011c885:	89 c2                	mov    %eax,%edx
f011c887:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011c88c:	0f b6 c0             	movzbl %al,%eax
f011c88f:	c1 e0 04             	shl    $0x4,%eax
f011c892:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c895:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c89c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c89f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c8a2:	39 c8                	cmp    %ecx,%eax
f011c8a4:	73 02                	jae    f011c8a8 <test_ksbrk+0x74>
f011c8a6:	89 c8                	mov    %ecx,%eax
f011c8a8:	01 d0                	add    %edx,%eax
f011c8aa:	83 c0 10             	add    $0x10,%eax
f011c8ad:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c8b2:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c8b5:	83 ec 0c             	sub    $0xc,%esp
f011c8b8:	68 78 fa 12 f0       	push   $0xf012fa78
f011c8bd:	e8 c9 46 fe ff       	call   f0100f8b <cprintf>
f011c8c2:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c8c5:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c8cc:	e8 31 20 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c8d1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c8d4:	e8 cc 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c8d9:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c8dc:	83 ec 10             	sub    $0x10,%esp
f011c8df:	89 e0                	mov    %esp,%eax
f011c8e1:	89 c2                	mov    %eax,%edx
f011c8e3:	bb 90 2f ac f0       	mov    $0xf0ac2f90,%ebx
f011c8e8:	b8 04 00 00 00       	mov    $0x4,%eax
f011c8ed:	89 d7                	mov    %edx,%edi
f011c8ef:	89 de                	mov    %ebx,%esi
f011c8f1:	89 c1                	mov    %eax,%ecx
f011c8f3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c8f5:	e8 53 3e 00 00       	call   f012074d <print_blocks_list>
f011c8fa:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c8fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c900:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c903:	29 c2                	sub    %eax,%edx
f011c905:	89 d0                	mov    %edx,%eax
f011c907:	83 ec 0c             	sub    $0xc,%esp
f011c90a:	50                   	push   %eax
f011c90b:	e8 1a cc fe ff       	call   f010952a <kmalloc>
f011c910:	83 c4 10             	add    $0x10,%esp
f011c913:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c919:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c91c:	89 c2                	mov    %eax,%edx
f011c91e:	c1 ea 1f             	shr    $0x1f,%edx
f011c921:	01 d0                	add    %edx,%eax
f011c923:	d1 f8                	sar    %eax
f011c925:	89 c2                	mov    %eax,%edx
f011c927:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c92a:	01 d0                	add    %edx,%eax
f011c92c:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c92f:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c935:	6a 01                	push   $0x1
f011c937:	ff 75 b8             	pushl  -0x48(%ebp)
f011c93a:	ff 75 ac             	pushl  -0x54(%ebp)
f011c93d:	50                   	push   %eax
f011c93e:	e8 db 43 ff ff       	call   f0110d1e <check_block>
f011c943:	83 c4 10             	add    $0x10,%esp
f011c946:	85 c0                	test   %eax,%eax
f011c948:	75 17                	jne    f011c961 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011c94a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c951:	83 ec 0c             	sub    $0xc,%esp
f011c954:	68 c9 fa 12 f0       	push   $0xf012fac9
f011c959:	e8 2d 46 fe ff       	call   f0100f8b <cprintf>
f011c95e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c961:	e8 9c 1f ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c966:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c969:	74 17                	je     f011c982 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011c96b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c972:	83 ec 0c             	sub    $0xc,%esp
f011c975:	68 e0 fa 12 f0       	push   $0xf012fae0
f011c97a:	e8 0c 46 fe ff       	call   f0100f8b <cprintf>
f011c97f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c982:	e8 1e 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c987:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c98a:	74 17                	je     f011c9a3 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c98c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c993:	83 ec 0c             	sub    $0xc,%esp
f011c996:	68 00 fb 12 f0       	push   $0xf012fb00
f011c99b:	e8 eb 45 fe ff       	call   f0100f8b <cprintf>
f011c9a0:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011c9a3:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011c9a8:	0f b6 c0             	movzbl %al,%eax
f011c9ab:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011c9ae:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011c9b5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011c9b8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011c9bb:	39 c2                	cmp    %eax,%edx
f011c9bd:	73 02                	jae    f011c9c1 <test_ksbrk+0x18d>
f011c9bf:	89 c2                	mov    %eax,%edx
f011c9c1:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011c9c6:	0f b6 c0             	movzbl %al,%eax
f011c9c9:	c1 e0 04             	shl    $0x4,%eax
f011c9cc:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011c9cf:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011c9d6:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011c9d9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c9dc:	39 c8                	cmp    %ecx,%eax
f011c9de:	73 02                	jae    f011c9e2 <test_ksbrk+0x1ae>
f011c9e0:	89 c8                	mov    %ecx,%eax
f011c9e2:	01 d0                	add    %edx,%eax
f011c9e4:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011c9e9:	29 c2                	sub    %eax,%edx
f011c9eb:	89 d0                	mov    %edx,%eax
f011c9ed:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c9f0:	e8 0d 1f ff ff       	call   f010e902 <sys_calculate_free_frames>
f011c9f5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c9f8:	e8 a8 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c9fd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011ca00:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca03:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ca06:	29 c2                	sub    %eax,%edx
f011ca08:	89 d0                	mov    %edx,%eax
f011ca0a:	83 ec 0c             	sub    $0xc,%esp
f011ca0d:	50                   	push   %eax
f011ca0e:	e8 17 cb fe ff       	call   f010952a <kmalloc>
f011ca13:	83 c4 10             	add    $0x10,%esp
f011ca16:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011ca1c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca1f:	89 c2                	mov    %eax,%edx
f011ca21:	c1 ea 1f             	shr    $0x1f,%edx
f011ca24:	01 d0                	add    %edx,%eax
f011ca26:	d1 f8                	sar    %eax
f011ca28:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011ca2e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011ca31:	01 d0                	add    %edx,%eax
f011ca33:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011ca36:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011ca3c:	6a 01                	push   $0x1
f011ca3e:	ff 75 b8             	pushl  -0x48(%ebp)
f011ca41:	ff 75 ac             	pushl  -0x54(%ebp)
f011ca44:	50                   	push   %eax
f011ca45:	e8 d4 42 ff ff       	call   f0110d1e <check_block>
f011ca4a:	83 c4 10             	add    $0x10,%esp
f011ca4d:	85 c0                	test   %eax,%eax
f011ca4f:	75 17                	jne    f011ca68 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011ca51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca58:	83 ec 0c             	sub    $0xc,%esp
f011ca5b:	68 6e fb 12 f0       	push   $0xf012fb6e
f011ca60:	e8 26 45 fe ff       	call   f0100f8b <cprintf>
f011ca65:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ca68:	e8 95 1e ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ca6d:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ca70:	74 17                	je     f011ca89 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011ca72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca79:	83 ec 0c             	sub    $0xc,%esp
f011ca7c:	68 88 fb 12 f0       	push   $0xf012fb88
f011ca81:	e8 05 45 fe ff       	call   f0100f8b <cprintf>
f011ca86:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ca89:	e8 17 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca8e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ca91:	74 17                	je     f011caaa <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca9a:	83 ec 0c             	sub    $0xc,%esp
f011ca9d:	68 a8 fb 12 f0       	push   $0xf012fba8
f011caa2:	e8 e4 44 fe ff       	call   f0100f8b <cprintf>
f011caa7:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011caaa:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cab1:	e8 4c 1e ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cab6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cab9:	e8 e7 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cabe:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011cac1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cac4:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cac7:	29 c2                	sub    %eax,%edx
f011cac9:	89 d0                	mov    %edx,%eax
f011cacb:	83 ec 0c             	sub    $0xc,%esp
f011cace:	50                   	push   %eax
f011cacf:	e8 56 ca fe ff       	call   f010952a <kmalloc>
f011cad4:	83 c4 10             	add    $0x10,%esp
f011cad7:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cadd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cae0:	89 c2                	mov    %eax,%edx
f011cae2:	c1 ea 1f             	shr    $0x1f,%edx
f011cae5:	01 d0                	add    %edx,%eax
f011cae7:	d1 f8                	sar    %eax
f011cae9:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011caee:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011caf1:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011caf7:	6a 01                	push   $0x1
f011caf9:	ff 75 b8             	pushl  -0x48(%ebp)
f011cafc:	ff 75 ac             	pushl  -0x54(%ebp)
f011caff:	50                   	push   %eax
f011cb00:	e8 19 42 ff ff       	call   f0110d1e <check_block>
f011cb05:	83 c4 10             	add    $0x10,%esp
f011cb08:	85 c0                	test   %eax,%eax
f011cb0a:	75 17                	jne    f011cb23 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011cb0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb13:	83 ec 0c             	sub    $0xc,%esp
f011cb16:	68 16 fc 12 f0       	push   $0xf012fc16
f011cb1b:	e8 6b 44 fe ff       	call   f0100f8b <cprintf>
f011cb20:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cb23:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cb26:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011cb29:	b8 00 10 00 00       	mov    $0x1000,%eax
f011cb2e:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011cb31:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cb34:	6a 00                	push   $0x0
f011cb36:	ff 75 98             	pushl  -0x68(%ebp)
f011cb39:	ff 75 ac             	pushl  -0x54(%ebp)
f011cb3c:	ff 75 ac             	pushl  -0x54(%ebp)
f011cb3f:	e8 da 41 ff ff       	call   f0110d1e <check_block>
f011cb44:	83 c4 10             	add    $0x10,%esp
f011cb47:	85 c0                	test   %eax,%eax
f011cb49:	75 17                	jne    f011cb62 <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011cb4b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb52:	83 ec 0c             	sub    $0xc,%esp
f011cb55:	68 2d fc 12 f0       	push   $0xf012fc2d
f011cb5a:	e8 2c 44 fe ff       	call   f0100f8b <cprintf>
f011cb5f:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cb62:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cb69:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cb6c:	8b 00                	mov    (%eax),%eax
f011cb6e:	83 f8 01             	cmp    $0x1,%eax
f011cb71:	74 17                	je     f011cb8a <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011cb73:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb7a:	83 ec 0c             	sub    $0xc,%esp
f011cb7d:	68 44 fc 12 f0       	push   $0xf012fc44
f011cb82:	e8 04 44 fe ff       	call   f0100f8b <cprintf>
f011cb87:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cb8a:	83 ec 0c             	sub    $0xc,%esp
f011cb8d:	6a 00                	push   $0x0
f011cb8f:	e8 63 c8 fe ff       	call   f01093f7 <sbrk>
f011cb94:	83 c4 10             	add    $0x10,%esp
f011cb97:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011cb9a:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cba1:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cba4:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cba7:	74 1d                	je     f011cbc6 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cba9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbb0:	83 ec 04             	sub    $0x4,%esp
f011cbb3:	ff 75 90             	pushl  -0x70(%ebp)
f011cbb6:	ff 75 8c             	pushl  -0x74(%ebp)
f011cbb9:	68 70 fc 12 f0       	push   $0xf012fc70
f011cbbe:	e8 c8 43 fe ff       	call   f0100f8b <cprintf>
f011cbc3:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cbc6:	e8 37 1d ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cbcb:	89 c2                	mov    %eax,%edx
f011cbcd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cbd0:	29 d0                	sub    %edx,%eax
f011cbd2:	83 f8 01             	cmp    $0x1,%eax
f011cbd5:	74 17                	je     f011cbee <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011cbd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbde:	83 ec 0c             	sub    $0xc,%esp
f011cbe1:	68 a4 fc 12 f0       	push   $0xf012fca4
f011cbe6:	e8 a0 43 fe ff       	call   f0100f8b <cprintf>
f011cbeb:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cbee:	e8 b2 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cbf3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cbf6:	74 17                	je     f011cc0f <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cbf8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbff:	83 ec 0c             	sub    $0xc,%esp
f011cc02:	68 c4 fc 12 f0       	push   $0xf012fcc4
f011cc07:	e8 7f 43 fe ff       	call   f0100f8b <cprintf>
f011cc0c:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011cc0f:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cc16:	e8 e7 1c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cc1b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cc1e:	e8 82 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cc23:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011cc26:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc29:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cc2c:	29 c2                	sub    %eax,%edx
f011cc2e:	89 d0                	mov    %edx,%eax
f011cc30:	83 ec 0c             	sub    $0xc,%esp
f011cc33:	50                   	push   %eax
f011cc34:	e8 f1 c8 fe ff       	call   f010952a <kmalloc>
f011cc39:	83 c4 10             	add    $0x10,%esp
f011cc3c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011cc42:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011cc49:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011cc4f:	6a 01                	push   $0x1
f011cc51:	ff 75 b8             	pushl  -0x48(%ebp)
f011cc54:	ff 75 ac             	pushl  -0x54(%ebp)
f011cc57:	50                   	push   %eax
f011cc58:	e8 c1 40 ff ff       	call   f0110d1e <check_block>
f011cc5d:	83 c4 10             	add    $0x10,%esp
f011cc60:	85 c0                	test   %eax,%eax
f011cc62:	75 17                	jne    f011cc7b <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011cc64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc6b:	83 ec 0c             	sub    $0xc,%esp
f011cc6e:	68 33 fd 12 f0       	push   $0xf012fd33
f011cc73:	e8 13 43 fe ff       	call   f0100f8b <cprintf>
f011cc78:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cc7b:	e8 82 1c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cc80:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cc83:	74 17                	je     f011cc9c <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011cc85:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc8c:	83 ec 0c             	sub    $0xc,%esp
f011cc8f:	68 4c fd 12 f0       	push   $0xf012fd4c
f011cc94:	e8 f2 42 fe ff       	call   f0100f8b <cprintf>
f011cc99:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cc9c:	e8 04 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cca1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cca4:	74 17                	je     f011ccbd <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cca6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ccad:	83 ec 0c             	sub    $0xc,%esp
f011ccb0:	68 6c fd 12 f0       	push   $0xf012fd6c
f011ccb5:	e8 d1 42 fe ff       	call   f0100f8b <cprintf>
f011ccba:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011ccbd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ccc1:	74 04                	je     f011ccc7 <test_ksbrk+0x493>
		eval += 25;
f011ccc3:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011ccc7:	83 ec 0c             	sub    $0xc,%esp
f011ccca:	68 dc fd 12 f0       	push   $0xf012fddc
f011cccf:	e8 b7 42 fe ff       	call   f0100f8b <cprintf>
f011ccd4:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011ccd7:	83 ec 0c             	sub    $0xc,%esp
f011ccda:	6a 00                	push   $0x0
f011ccdc:	e8 16 c7 fe ff       	call   f01093f7 <sbrk>
f011cce1:	83 c4 10             	add    $0x10,%esp
f011cce4:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011cce7:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011ccee:	e8 0f 1c ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ccf3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ccf6:	e8 aa 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ccfb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011ccfe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd01:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cd04:	29 c2                	sub    %eax,%edx
f011cd06:	89 d0                	mov    %edx,%eax
f011cd08:	83 ec 0c             	sub    $0xc,%esp
f011cd0b:	50                   	push   %eax
f011cd0c:	e8 19 c8 fe ff       	call   f010952a <kmalloc>
f011cd11:	83 c4 10             	add    $0x10,%esp
f011cd14:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cd1a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd1d:	89 c2                	mov    %eax,%edx
f011cd1f:	c1 ea 1f             	shr    $0x1f,%edx
f011cd22:	01 d0                	add    %edx,%eax
f011cd24:	d1 f8                	sar    %eax
f011cd26:	89 c2                	mov    %eax,%edx
f011cd28:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cd2b:	01 d0                	add    %edx,%eax
f011cd2d:	83 e8 04             	sub    $0x4,%eax
f011cd30:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cd33:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cd39:	6a 01                	push   $0x1
f011cd3b:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd3e:	ff 75 ac             	pushl  -0x54(%ebp)
f011cd41:	50                   	push   %eax
f011cd42:	e8 d7 3f ff ff       	call   f0110d1e <check_block>
f011cd47:	83 c4 10             	add    $0x10,%esp
f011cd4a:	85 c0                	test   %eax,%eax
f011cd4c:	75 17                	jne    f011cd65 <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011cd4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd55:	83 ec 0c             	sub    $0xc,%esp
f011cd58:	68 3f fe 12 f0       	push   $0xf012fe3f
f011cd5d:	e8 29 42 fe ff       	call   f0100f8b <cprintf>
f011cd62:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cd65:	e8 98 1b ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cd6a:	89 c2                	mov    %eax,%edx
f011cd6c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cd6f:	29 d0                	sub    %edx,%eax
f011cd71:	83 f8 01             	cmp    $0x1,%eax
f011cd74:	74 17                	je     f011cd8d <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011cd76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd7d:	83 ec 0c             	sub    $0xc,%esp
f011cd80:	68 58 fe 12 f0       	push   $0xf012fe58
f011cd85:	e8 01 42 fe ff       	call   f0100f8b <cprintf>
f011cd8a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cd8d:	e8 13 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd92:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cd95:	74 17                	je     f011cdae <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd9e:	83 ec 0c             	sub    $0xc,%esp
f011cda1:	68 78 fe 12 f0       	push   $0xf012fe78
f011cda6:	e8 e0 41 fe ff       	call   f0100f8b <cprintf>
f011cdab:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011cdae:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cdb5:	e8 48 1b ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cdba:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cdbd:	e8 e3 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cdc2:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011cdc5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cdc8:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cdcb:	29 c2                	sub    %eax,%edx
f011cdcd:	89 d0                	mov    %edx,%eax
f011cdcf:	83 ec 0c             	sub    $0xc,%esp
f011cdd2:	50                   	push   %eax
f011cdd3:	e8 52 c7 fe ff       	call   f010952a <kmalloc>
f011cdd8:	83 c4 10             	add    $0x10,%esp
f011cddb:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011cde1:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011cde8:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011cdee:	6a 01                	push   $0x1
f011cdf0:	ff 75 b8             	pushl  -0x48(%ebp)
f011cdf3:	ff 75 ac             	pushl  -0x54(%ebp)
f011cdf6:	50                   	push   %eax
f011cdf7:	e8 22 3f ff ff       	call   f0110d1e <check_block>
f011cdfc:	83 c4 10             	add    $0x10,%esp
f011cdff:	85 c0                	test   %eax,%eax
f011ce01:	75 17                	jne    f011ce1a <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011ce03:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce0a:	83 ec 0c             	sub    $0xc,%esp
f011ce0d:	68 e6 fe 12 f0       	push   $0xf012fee6
f011ce12:	e8 74 41 fe ff       	call   f0100f8b <cprintf>
f011ce17:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ce1a:	e8 e3 1a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ce1f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ce22:	74 17                	je     f011ce3b <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011ce24:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce2b:	83 ec 0c             	sub    $0xc,%esp
f011ce2e:	68 00 ff 12 f0       	push   $0xf012ff00
f011ce33:	e8 53 41 fe ff       	call   f0100f8b <cprintf>
f011ce38:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ce3b:	e8 65 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce40:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ce43:	74 17                	je     f011ce5c <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce45:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce4c:	83 ec 0c             	sub    $0xc,%esp
f011ce4f:	68 20 ff 12 f0       	push   $0xf012ff20
f011ce54:	e8 32 41 fe ff       	call   f0100f8b <cprintf>
f011ce59:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011ce5c:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011ce63:	e8 9a 1a ff ff       	call   f010e902 <sys_calculate_free_frames>
f011ce68:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ce6b:	e8 35 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce70:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ce73:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce76:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ce79:	29 c2                	sub    %eax,%edx
f011ce7b:	89 d0                	mov    %edx,%eax
f011ce7d:	83 ec 0c             	sub    $0xc,%esp
f011ce80:	50                   	push   %eax
f011ce81:	e8 a4 c6 fe ff       	call   f010952a <kmalloc>
f011ce86:	83 c4 10             	add    $0x10,%esp
f011ce89:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011ce8f:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ce96:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ce9c:	6a 01                	push   $0x1
f011ce9e:	ff 75 b8             	pushl  -0x48(%ebp)
f011cea1:	ff 75 ac             	pushl  -0x54(%ebp)
f011cea4:	50                   	push   %eax
f011cea5:	e8 74 3e ff ff       	call   f0110d1e <check_block>
f011ceaa:	83 c4 10             	add    $0x10,%esp
f011cead:	85 c0                	test   %eax,%eax
f011ceaf:	75 17                	jne    f011cec8 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011ceb1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ceb8:	83 ec 0c             	sub    $0xc,%esp
f011cebb:	68 8e ff 12 f0       	push   $0xf012ff8e
f011cec0:	e8 c6 40 fe ff       	call   f0100f8b <cprintf>
f011cec5:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cec8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cecb:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011cece:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011ced5:	6a 00                	push   $0x0
f011ced7:	ff 75 98             	pushl  -0x68(%ebp)
f011ceda:	ff 75 ac             	pushl  -0x54(%ebp)
f011cedd:	ff 75 ac             	pushl  -0x54(%ebp)
f011cee0:	e8 39 3e ff ff       	call   f0110d1e <check_block>
f011cee5:	83 c4 10             	add    $0x10,%esp
f011cee8:	85 c0                	test   %eax,%eax
f011ceea:	75 17                	jne    f011cf03 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011ceec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cef3:	83 ec 0c             	sub    $0xc,%esp
f011cef6:	68 a5 ff 12 f0       	push   $0xf012ffa5
f011cefb:	e8 8b 40 fe ff       	call   f0100f8b <cprintf>
f011cf00:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011cf03:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cf06:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011cf0b:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cf0e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cf11:	8b 00                	mov    (%eax),%eax
f011cf13:	83 f8 01             	cmp    $0x1,%eax
f011cf16:	74 17                	je     f011cf2f <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011cf18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf1f:	83 ec 0c             	sub    $0xc,%esp
f011cf22:	68 bc ff 12 f0       	push   $0xf012ffbc
f011cf27:	e8 5f 40 fe ff       	call   f0100f8b <cprintf>
f011cf2c:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cf2f:	83 ec 0c             	sub    $0xc,%esp
f011cf32:	6a 00                	push   $0x0
f011cf34:	e8 be c4 fe ff       	call   f01093f7 <sbrk>
f011cf39:	83 c4 10             	add    $0x10,%esp
f011cf3c:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011cf3f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cf42:	05 00 20 00 00       	add    $0x2000,%eax
f011cf47:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cf4a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cf4d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cf50:	74 1d                	je     f011cf6f <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cf52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf59:	83 ec 04             	sub    $0x4,%esp
f011cf5c:	ff 75 90             	pushl  -0x70(%ebp)
f011cf5f:	ff 75 8c             	pushl  -0x74(%ebp)
f011cf62:	68 e8 ff 12 f0       	push   $0xf012ffe8
f011cf67:	e8 1f 40 fe ff       	call   f0100f8b <cprintf>
f011cf6c:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cf6f:	e8 8e 19 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011cf74:	89 c2                	mov    %eax,%edx
f011cf76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cf79:	29 d0                	sub    %edx,%eax
f011cf7b:	83 f8 01             	cmp    $0x1,%eax
f011cf7e:	74 17                	je     f011cf97 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011cf80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf87:	83 ec 0c             	sub    $0xc,%esp
f011cf8a:	68 1c 00 13 f0       	push   $0xf013001c
f011cf8f:	e8 f7 3f fe ff       	call   f0100f8b <cprintf>
f011cf94:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cf97:	e8 09 79 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cf9c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cf9f:	74 17                	je     f011cfb8 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cfa1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfa8:	83 ec 0c             	sub    $0xc,%esp
f011cfab:	68 3c 00 13 f0       	push   $0xf013003c
f011cfb0:	e8 d6 3f fe ff       	call   f0100f8b <cprintf>
f011cfb5:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011cfb8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cfbc:	74 04                	je     f011cfc2 <test_ksbrk+0x78e>
		eval += 25;
f011cfbe:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011cfc2:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011cfc9:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011cfcf:	bb 78 03 13 f0       	mov    $0xf0130378,%ebx
f011cfd4:	ba 05 00 00 00       	mov    $0x5,%edx
f011cfd9:	89 c7                	mov    %eax,%edi
f011cfdb:	89 de                	mov    %ebx,%esi
f011cfdd:	89 d1                	mov    %edx,%ecx
f011cfdf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011cfe1:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011cfe7:	bb 8c 03 13 f0       	mov    $0xf013038c,%ebx
f011cfec:	ba 05 00 00 00       	mov    $0x5,%edx
f011cff1:	89 c7                	mov    %eax,%edi
f011cff3:	89 de                	mov    %ebx,%esi
f011cff5:	89 d1                	mov    %edx,%ecx
f011cff7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011cff9:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011cfff:	bb a0 03 13 f0       	mov    $0xf01303a0,%ebx
f011d004:	ba 05 00 00 00       	mov    $0x5,%edx
f011d009:	89 c7                	mov    %eax,%edi
f011d00b:	89 de                	mov    %ebx,%esi
f011d00d:	89 d1                	mov    %edx,%ecx
f011d00f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011d011:	83 ec 04             	sub    $0x4,%esp
f011d014:	68 00 00 00 f8       	push   $0xf8000000
f011d019:	68 00 10 00 00       	push   $0x1000
f011d01e:	68 00 00 00 f6       	push   $0xf6000000
f011d023:	e8 b8 c2 fe ff       	call   f01092e0 <initialize_kheap_dynamic_allocator>
f011d028:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d02b:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011d032:	eb 1b                	jmp    f011d04f <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011d034:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011d039:	83 ec 08             	sub    $0x8,%esp
f011d03c:	ff 75 dc             	pushl  -0x24(%ebp)
f011d03f:	50                   	push   %eax
f011d040:	e8 9a b7 fe ff       	call   f01087df <unmap_frame>
f011d045:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d048:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011d04f:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d056:	76 dc                	jbe    f011d034 <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d058:	83 ec 0c             	sub    $0xc,%esp
f011d05b:	68 ac 00 13 f0       	push   $0xf01300ac
f011d060:	e8 26 3f fe ff       	call   f0100f8b <cprintf>
f011d065:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d068:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d06f:	e9 21 01 00 00       	jmp    f011d195 <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d074:	e8 89 18 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011d079:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d07c:	e8 24 78 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d081:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d084:	83 ec 0c             	sub    $0xc,%esp
f011d087:	6a 00                	push   $0x0
f011d089:	e8 69 c3 fe ff       	call   f01093f7 <sbrk>
f011d08e:	83 c4 10             	add    $0x10,%esp
f011d091:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d094:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d097:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d09e:	83 ec 0c             	sub    $0xc,%esp
f011d0a1:	50                   	push   %eax
f011d0a2:	e8 50 c3 fe ff       	call   f01093f7 <sbrk>
f011d0a7:	83 c4 10             	add    $0x10,%esp
f011d0aa:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d0ad:	83 ec 0c             	sub    $0xc,%esp
f011d0b0:	6a 00                	push   $0x0
f011d0b2:	e8 40 c3 fe ff       	call   f01093f7 <sbrk>
f011d0b7:	83 c4 10             	add    $0x10,%esp
f011d0ba:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d0bd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d0c4:	e8 dc 77 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d0c9:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d0cc:	74 1a                	je     f011d0e8 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d0ce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d0d5:	83 ec 08             	sub    $0x8,%esp
f011d0d8:	ff 75 d8             	pushl  -0x28(%ebp)
f011d0db:	68 f0 00 13 f0       	push   $0xf01300f0
f011d0e0:	e8 a6 3e fe ff       	call   f0100f8b <cprintf>
f011d0e5:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d0e8:	e8 15 18 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011d0ed:	89 c2                	mov    %eax,%edx
f011d0ef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d0f2:	29 d0                	sub    %edx,%eax
f011d0f4:	89 c2                	mov    %eax,%edx
f011d0f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d0f9:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d100:	39 c2                	cmp    %eax,%edx
f011d102:	74 1a                	je     f011d11e <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d104:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d10b:	83 ec 08             	sub    $0x8,%esp
f011d10e:	ff 75 d8             	pushl  -0x28(%ebp)
f011d111:	68 60 01 13 f0       	push   $0xf0130160
f011d116:	e8 70 3e fe ff       	call   f0100f8b <cprintf>
f011d11b:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d11e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d121:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d128:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d12b:	39 c2                	cmp    %eax,%edx
f011d12d:	74 25                	je     f011d154 <test_ksbrk+0x920>
			{
				correct = 0;
f011d12f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d136:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d139:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d140:	ff 75 80             	pushl  -0x80(%ebp)
f011d143:	50                   	push   %eax
f011d144:	ff 75 d8             	pushl  -0x28(%ebp)
f011d147:	68 80 01 13 f0       	push   $0xf0130180
f011d14c:	e8 3a 3e fe ff       	call   f0100f8b <cprintf>
f011d151:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d154:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d157:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d15e:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d161:	74 25                	je     f011d188 <test_ksbrk+0x954>
			{
				correct = 0;
f011d163:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d16a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d16d:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d174:	ff 75 90             	pushl  -0x70(%ebp)
f011d177:	50                   	push   %eax
f011d178:	ff 75 d8             	pushl  -0x28(%ebp)
f011d17b:	68 b8 01 13 f0       	push   $0xf01301b8
f011d180:	e8 06 3e fe ff       	call   f0100f8b <cprintf>
f011d185:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d188:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d18c:	74 04                	je     f011d192 <test_ksbrk+0x95e>
				eval += 10;
f011d18e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d192:	ff 45 d8             	incl   -0x28(%ebp)
f011d195:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d198:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d19b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d19e:	39 c2                	cmp    %eax,%edx
f011d1a0:	0f 87 ce fe ff ff    	ja     f011d074 <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d1a6:	83 ec 0c             	sub    $0xc,%esp
f011d1a9:	68 ec 01 13 f0       	push   $0xf01301ec
f011d1ae:	e8 d8 3d fe ff       	call   f0100f8b <cprintf>
f011d1b3:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d1b6:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d1b9:	48                   	dec    %eax
f011d1ba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d1bd:	e9 18 01 00 00       	jmp    f011d2da <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d1c2:	e8 3b 17 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011d1c7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d1ca:	e8 d6 76 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d1cf:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d1d2:	83 ec 0c             	sub    $0xc,%esp
f011d1d5:	6a 00                	push   $0x0
f011d1d7:	e8 1b c2 fe ff       	call   f01093f7 <sbrk>
f011d1dc:	83 c4 10             	add    $0x10,%esp
f011d1df:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d1e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d1e5:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d1ec:	83 ec 0c             	sub    $0xc,%esp
f011d1ef:	50                   	push   %eax
f011d1f0:	e8 02 c2 fe ff       	call   f01093f7 <sbrk>
f011d1f5:	83 c4 10             	add    $0x10,%esp
f011d1f8:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d1fe:	83 ec 0c             	sub    $0xc,%esp
f011d201:	6a 00                	push   $0x0
f011d203:	e8 ef c1 fe ff       	call   f01093f7 <sbrk>
f011d208:	83 c4 10             	add    $0x10,%esp
f011d20b:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d20e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d215:	e8 8b 76 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d21a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d21d:	74 1a                	je     f011d239 <test_ksbrk+0xa05>
			{
				correct = 0;
f011d21f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d226:	83 ec 08             	sub    $0x8,%esp
f011d229:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d22c:	68 3c 02 13 f0       	push   $0xf013023c
f011d231:	e8 55 3d fe ff       	call   f0100f8b <cprintf>
f011d236:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d239:	e8 c4 16 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011d23e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d241:	74 1a                	je     f011d25d <test_ksbrk+0xa29>
			{
				correct = 0;
f011d243:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d24a:	83 ec 08             	sub    $0x8,%esp
f011d24d:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d250:	68 ac 02 13 f0       	push   $0xf01302ac
f011d255:	e8 31 3d fe ff       	call   f0100f8b <cprintf>
f011d25a:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d25d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d260:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d267:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d26d:	39 c2                	cmp    %eax,%edx
f011d26f:	74 28                	je     f011d299 <test_ksbrk+0xa65>
			{
				correct = 0;
f011d271:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d278:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d27b:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d282:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d288:	50                   	push   %eax
f011d289:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d28c:	68 cc 02 13 f0       	push   $0xf01302cc
f011d291:	e8 f5 3c fe ff       	call   f0100f8b <cprintf>
f011d296:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d299:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d29c:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d2a3:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d2a6:	74 25                	je     f011d2cd <test_ksbrk+0xa99>
			{
				correct = 0;
f011d2a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d2af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d2b2:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d2b9:	ff 75 90             	pushl  -0x70(%ebp)
f011d2bc:	50                   	push   %eax
f011d2bd:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d2c0:	68 04 03 13 f0       	push   $0xf0130304
f011d2c5:	e8 c1 3c fe ff       	call   f0100f8b <cprintf>
f011d2ca:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d2cd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d2d1:	74 04                	je     f011d2d7 <test_ksbrk+0xaa3>
				eval += 10;
f011d2d3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d2d7:	ff 45 d4             	incl   -0x2c(%ebp)
f011d2da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d2dd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d2e0:	0f 82 dc fe ff ff    	jb     f011d1c2 <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d2e6:	83 ec 08             	sub    $0x8,%esp
f011d2e9:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d2ec:	68 38 03 13 f0       	push   $0xf0130338
f011d2f1:	e8 95 3c fe ff       	call   f0100f8b <cprintf>
f011d2f6:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d2f9:	83 ec 0c             	sub    $0xc,%esp
f011d2fc:	68 62 03 13 f0       	push   $0xf0130362
f011d301:	e8 85 3c fe ff       	call   f0100f8b <cprintf>
f011d306:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d309:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d30e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d311:	5b                   	pop    %ebx
f011d312:	5e                   	pop    %esi
f011d313:	5f                   	pop    %edi
f011d314:	5d                   	pop    %ebp
f011d315:	c3                   	ret    

f011d316 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d316:	55                   	push   %ebp
f011d317:	89 e5                	mov    %esp,%ebp
f011d319:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d31c:	83 ec 04             	sub    $0x4,%esp
f011d31f:	68 b4 03 13 f0       	push   $0xf01303b4
f011d324:	68 c2 08 00 00       	push   $0x8c2
f011d329:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d32e:	e8 06 30 fe ff       	call   f0100339 <_panic>

f011d333 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d333:	55                   	push   %ebp
f011d334:	89 e5                	mov    %esp,%ebp
f011d336:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d339:	83 ec 04             	sub    $0x4,%esp
f011d33c:	68 b4 03 13 f0       	push   $0xf01303b4
f011d341:	68 c7 08 00 00       	push   $0x8c7
f011d346:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d34b:	e8 e9 2f fe ff       	call   f0100339 <_panic>

f011d350 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d350:	55                   	push   %ebp
f011d351:	89 e5                	mov    %esp,%ebp
f011d353:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d356:	83 ec 04             	sub    $0x4,%esp
f011d359:	68 b4 03 13 f0       	push   $0xf01303b4
f011d35e:	68 cc 08 00 00       	push   $0x8cc
f011d363:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d368:	e8 cc 2f fe ff       	call   f0100339 <_panic>

f011d36d <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d36d:	55                   	push   %ebp
f011d36e:	89 e5                	mov    %esp,%ebp
f011d370:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d373:	83 ec 04             	sub    $0x4,%esp
f011d376:	68 b4 03 13 f0       	push   $0xf01303b4
f011d37b:	68 d1 08 00 00       	push   $0x8d1
f011d380:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d385:	e8 af 2f fe ff       	call   f0100339 <_panic>

f011d38a <test_kfree>:
}

int test_kfree()
{
f011d38a:	55                   	push   %ebp
f011d38b:	89 e5                	mov    %esp,%ebp
f011d38d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d390:	83 ec 04             	sub    $0x4,%esp
f011d393:	68 b4 03 13 f0       	push   $0xf01303b4
f011d398:	68 d6 08 00 00       	push   $0x8d6
f011d39d:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d3a2:	e8 92 2f fe ff       	call   f0100339 <_panic>

f011d3a7 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d3a7:	55                   	push   %ebp
f011d3a8:	89 e5                	mov    %esp,%ebp
f011d3aa:	57                   	push   %edi
f011d3ab:	56                   	push   %esi
f011d3ac:	53                   	push   %ebx
f011d3ad:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d3b3:	a0 dc fd 17 f0       	mov    0xf017fddc,%al
f011d3b8:	84 c0                	test   %al,%al
f011d3ba:	74 56                	je     f011d412 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d3bc:	c6 05 dc fd 17 f0 00 	movb   $0x0,0xf017fddc
		initFreeFrames = sys_calculate_free_frames() ;
f011d3c3:	e8 3a 15 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011d3c8:	a3 68 5d 65 f2       	mov    %eax,0xf2655d68
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d3cd:	e8 d3 74 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d3d2:	a3 64 5d 65 f2       	mov    %eax,0xf2655d64
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d3d7:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d3dd:	bb 19 05 13 f0       	mov    $0xf0130519,%ebx
f011d3e2:	ba 11 00 00 00       	mov    $0x11,%edx
f011d3e7:	89 c7                	mov    %eax,%edi
f011d3e9:	89 de                	mov    %ebx,%esi
f011d3eb:	89 d1                	mov    %edx,%ecx
f011d3ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d3ef:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d3f5:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d3fa:	b0 00                	mov    $0x0,%al
f011d3fc:	89 d7                	mov    %edx,%edi
f011d3fe:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d400:	83 ec 0c             	sub    $0xc,%esp
f011d403:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d409:	50                   	push   %eax
f011d40a:	e8 ec 4a fe ff       	call   f0101efb <execute_command>
f011d40f:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d412:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d419:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d420:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f011d425:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d428:	eb 2b                	jmp    f011d455 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d42a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d42d:	83 c0 20             	add    $0x20,%eax
f011d430:	83 ec 08             	sub    $0x8,%esp
f011d433:	68 c4 03 13 f0       	push   $0xf01303c4
f011d438:	50                   	push   %eax
f011d439:	e8 ea 28 00 00       	call   f011fd28 <strcmp>
f011d43e:	83 c4 10             	add    $0x10,%esp
f011d441:	85 c0                	test   %eax,%eax
f011d443:	75 08                	jne    f011d44d <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d445:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d448:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d44b:	eb 2f                	jmp    f011d47c <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d44d:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f011d452:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d455:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d459:	74 08                	je     f011d463 <test_three_creation_functions+0xbc>
f011d45b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d45e:	8b 40 08             	mov    0x8(%eax),%eax
f011d461:	eb 05                	jmp    f011d468 <test_three_creation_functions+0xc1>
f011d463:	b8 00 00 00 00       	mov    $0x0,%eax
f011d468:	a3 e8 2e 6c f0       	mov    %eax,0xf06c2ee8
f011d46d:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f011d472:	85 c0                	test   %eax,%eax
f011d474:	75 b4                	jne    f011d42a <test_three_creation_functions+0x83>
f011d476:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d47a:	75 ae                	jne    f011d42a <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d47c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d47f:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d485:	85 c0                	test   %eax,%eax
f011d487:	74 17                	je     f011d4a0 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d489:	83 ec 04             	sub    $0x4,%esp
f011d48c:	68 cc 03 13 f0       	push   $0xf01303cc
f011d491:	68 f7 08 00 00       	push   $0x8f7
f011d496:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d49b:	e8 99 2e fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d4a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d4a3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d4a9:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d4ac:	e8 51 14 ff ff       	call   f010e902 <sys_calculate_free_frames>
f011d4b1:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d4b4:	e8 ec 73 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d4b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d4bc:	a1 64 5d 65 f2       	mov    0xf2655d64,%eax
f011d4c1:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d4c4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d4c7:	74 17                	je     f011d4e0 <test_three_creation_functions+0x139>
f011d4c9:	83 ec 04             	sub    $0x4,%esp
f011d4cc:	68 0c ce 12 f0       	push   $0xf012ce0c
f011d4d1:	68 01 09 00 00       	push   $0x901
f011d4d6:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d4db:	e8 59 2e fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d4e0:	a1 68 5d 65 f2       	mov    0xf2655d68,%eax
f011d4e5:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d4e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d4eb:	83 c2 15             	add    $0x15,%edx
f011d4ee:	39 d0                	cmp    %edx,%eax
f011d4f0:	74 17                	je     f011d509 <test_three_creation_functions+0x162>
f011d4f2:	83 ec 04             	sub    $0x4,%esp
f011d4f5:	68 1c 04 13 f0       	push   $0xf013041c
f011d4fa:	68 03 09 00 00       	push   $0x903
f011d4ff:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d504:	e8 30 2e fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d509:	83 ec 0c             	sub    $0xc,%esp
f011d50c:	68 00 10 00 00       	push   $0x1000
f011d511:	e8 14 c0 fe ff       	call   f010952a <kmalloc>
f011d516:	83 c4 10             	add    $0x10,%esp
f011d519:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d51c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d51f:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d524:	74 17                	je     f011d53d <test_three_creation_functions+0x196>
f011d526:	83 ec 04             	sub    $0x4,%esp
f011d529:	68 5c 04 13 f0       	push   $0xf013045c
f011d52e:	68 07 09 00 00       	push   $0x907
f011d533:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d538:	e8 fc 2d fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d53d:	83 ec 0c             	sub    $0xc,%esp
f011d540:	68 cc 04 13 f0       	push   $0xf01304cc
f011d545:	e8 41 3a fe ff       	call   f0100f8b <cprintf>
f011d54a:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d54d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d552:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d555:	5b                   	pop    %ebx
f011d556:	5e                   	pop    %esi
f011d557:	5f                   	pop    %edi
f011d558:	5d                   	pop    %ebp
f011d559:	c3                   	ret    

f011d55a <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d55a:	55                   	push   %ebp
f011d55b:	89 e5                	mov    %esp,%ebp
f011d55d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d560:	83 ec 04             	sub    $0x4,%esp
f011d563:	68 b4 03 13 f0       	push   $0xf01303b4
f011d568:	68 15 09 00 00       	push   $0x915
f011d56d:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d572:	e8 c2 2d fe ff       	call   f0100339 <_panic>

f011d577 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d577:	55                   	push   %ebp
f011d578:	89 e5                	mov    %esp,%ebp
f011d57a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d57d:	83 ec 04             	sub    $0x4,%esp
f011d580:	68 b4 03 13 f0       	push   $0xf01303b4
f011d585:	68 1d 09 00 00       	push   $0x91d
f011d58a:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d58f:	e8 a5 2d fe ff       	call   f0100339 <_panic>

f011d594 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d594:	55                   	push   %ebp
f011d595:	89 e5                	mov    %esp,%ebp
f011d597:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d59a:	83 ec 04             	sub    $0x4,%esp
f011d59d:	68 b4 03 13 f0       	push   $0xf01303b4
f011d5a2:	68 24 09 00 00       	push   $0x924
f011d5a7:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d5ac:	e8 88 2d fe ff       	call   f0100339 <_panic>

f011d5b1 <test_kfreelast>:

}


int test_kfreelast()
{
f011d5b1:	55                   	push   %ebp
f011d5b2:	89 e5                	mov    %esp,%ebp
f011d5b4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5b7:	83 ec 04             	sub    $0x4,%esp
f011d5ba:	68 b4 03 13 f0       	push   $0xf01303b4
f011d5bf:	68 2b 09 00 00       	push   $0x92b
f011d5c4:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d5c9:	e8 6b 2d fe ff       	call   f0100339 <_panic>

f011d5ce <test_krealloc>:

}

int test_krealloc() {
f011d5ce:	55                   	push   %ebp
f011d5cf:	89 e5                	mov    %esp,%ebp
f011d5d1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5d4:	83 ec 04             	sub    $0x4,%esp
f011d5d7:	68 b4 03 13 f0       	push   $0xf01303b4
f011d5dc:	68 30 09 00 00       	push   $0x930
f011d5e1:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d5e6:	e8 4e 2d fe ff       	call   f0100339 <_panic>

f011d5eb <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d5eb:	55                   	push   %ebp
f011d5ec:	89 e5                	mov    %esp,%ebp
f011d5ee:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5f1:	83 ec 04             	sub    $0x4,%esp
f011d5f4:	68 b4 03 13 f0       	push   $0xf01303b4
f011d5f9:	68 35 09 00 00       	push   $0x935
f011d5fe:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d603:	e8 31 2d fe ff       	call   f0100339 <_panic>

f011d608 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011d608:	55                   	push   %ebp
f011d609:	89 e5                	mov    %esp,%ebp
f011d60b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d60e:	83 ec 04             	sub    $0x4,%esp
f011d611:	68 b4 03 13 f0       	push   $0xf01303b4
f011d616:	68 3b 09 00 00       	push   $0x93b
f011d61b:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d620:	e8 14 2d fe ff       	call   f0100339 <_panic>

f011d625 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d625:	55                   	push   %ebp
f011d626:	89 e5                	mov    %esp,%ebp
f011d628:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d62b:	83 ec 04             	sub    $0x4,%esp
f011d62e:	68 b4 03 13 f0       	push   $0xf01303b4
f011d633:	68 40 09 00 00       	push   $0x940
f011d638:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d63d:	e8 f7 2c fe ff       	call   f0100339 <_panic>

f011d642 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d642:	55                   	push   %ebp
f011d643:	89 e5                	mov    %esp,%ebp
f011d645:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d648:	83 ec 04             	sub    $0x4,%esp
f011d64b:	68 b4 03 13 f0       	push   $0xf01303b4
f011d650:	68 46 09 00 00       	push   $0x946
f011d655:	68 f3 cd 12 f0       	push   $0xf012cdf3
f011d65a:	e8 da 2c fe ff       	call   f0100339 <_panic>

f011d65f <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d65f:	55                   	push   %ebp
f011d660:	89 e5                	mov    %esp,%ebp
f011d662:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d665:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d66c:	e9 84 00 00 00       	jmp    f011d6f5 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d671:	83 ec 08             	sub    $0x8,%esp
f011d674:	ff 75 f4             	pushl  -0xc(%ebp)
f011d677:	68 80 05 13 f0       	push   $0xf0130580
f011d67c:	e8 0a 39 fe ff       	call   f0100f8b <cprintf>
f011d681:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d684:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d68b:	eb 4c                	jmp    f011d6d9 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d68d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d690:	89 d0                	mov    %edx,%eax
f011d692:	c1 e0 02             	shl    $0x2,%eax
f011d695:	01 d0                	add    %edx,%eax
f011d697:	c1 e0 03             	shl    $0x3,%eax
f011d69a:	89 c2                	mov    %eax,%edx
f011d69c:	8b 45 08             	mov    0x8(%ebp),%eax
f011d69f:	01 c2                	add    %eax,%edx
f011d6a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d6a4:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d6a7:	85 c0                	test   %eax,%eax
f011d6a9:	74 36                	je     f011d6e1 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d6ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d6ae:	89 d0                	mov    %edx,%eax
f011d6b0:	c1 e0 02             	shl    $0x2,%eax
f011d6b3:	01 d0                	add    %edx,%eax
f011d6b5:	c1 e0 03             	shl    $0x3,%eax
f011d6b8:	89 c2                	mov    %eax,%edx
f011d6ba:	8b 45 08             	mov    0x8(%ebp),%eax
f011d6bd:	01 c2                	add    %eax,%edx
f011d6bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d6c2:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d6c5:	83 ec 08             	sub    $0x8,%esp
f011d6c8:	50                   	push   %eax
f011d6c9:	68 88 05 13 f0       	push   $0xf0130588
f011d6ce:	e8 b8 38 fe ff       	call   f0100f8b <cprintf>
f011d6d3:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d6d6:	ff 45 f0             	incl   -0x10(%ebp)
f011d6d9:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d6dd:	7e ae                	jle    f011d68d <print_order+0x2e>
f011d6df:	eb 01                	jmp    f011d6e2 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d6e1:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d6e2:	83 ec 0c             	sub    $0xc,%esp
f011d6e5:	68 8d 05 13 f0       	push   $0xf013058d
f011d6ea:	e8 9c 38 fe ff       	call   f0100f8b <cprintf>
f011d6ef:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d6f2:	ff 45 f4             	incl   -0xc(%ebp)
f011d6f5:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d6f9:	0f 8e 72 ff ff ff    	jle    f011d671 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d6ff:	90                   	nop
f011d700:	c9                   	leave  
f011d701:	c3                   	ret    

f011d702 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d702:	55                   	push   %ebp
f011d703:	89 e5                	mov    %esp,%ebp
f011d705:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d708:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d70f:	83 ec 0c             	sub    $0xc,%esp
f011d712:	68 60 2e 6c f0       	push   $0xf06c2e60
f011d717:	e8 52 25 ff ff       	call   f010fc6e <acquire_spinlock>
f011d71c:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d71f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d726:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d72d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d730:	8b 45 10             	mov    0x10(%ebp),%eax
f011d733:	01 d0                	add    %edx,%eax
f011d735:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d738:	a1 ec 2e 6c f0       	mov    0xf06c2eec,%eax
f011d73d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d740:	a1 e4 2e 6c f0       	mov    0xf06c2ee4,%eax
f011d745:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d748:	ff 75 e8             	pushl  -0x18(%ebp)
f011d74b:	ff 75 0c             	pushl  0xc(%ebp)
f011d74e:	ff 75 08             	pushl  0x8(%ebp)
f011d751:	68 90 05 13 f0       	push   $0xf0130590
f011d756:	e8 30 38 fe ff       	call   f0100f8b <cprintf>
f011d75b:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d75e:	eb 34                	jmp    f011d794 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d760:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d763:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d766:	7d 05                	jge    f011d76d <find_in_range+0x6b>
			{
				i++;
f011d768:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d76b:	eb 1e                	jmp    f011d78b <find_in_range+0x89>
			}
			if (i >= end)
f011d76d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d770:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d773:	7d 29                	jge    f011d79e <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d775:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d778:	8b 40 10             	mov    0x10(%eax),%eax
f011d77b:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d77e:	75 08                	jne    f011d788 <find_in_range+0x86>
			{
				ret = i;
f011d780:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d783:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d786:	eb 17                	jmp    f011d79f <find_in_range+0x9d>
			}
			i++;
f011d788:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d78e:	8b 40 0c             	mov    0xc(%eax),%eax
f011d791:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d794:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d797:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d79a:	7c c4                	jl     f011d760 <find_in_range+0x5e>
f011d79c:	eb 01                	jmp    f011d79f <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d79e:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d79f:	83 ec 0c             	sub    $0xc,%esp
f011d7a2:	68 60 2e 6c f0       	push   $0xf06c2e60
f011d7a7:	e8 49 25 ff ff       	call   f010fcf5 <release_spinlock>
f011d7ac:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d7b2:	c9                   	leave  
f011d7b3:	c3                   	ret    

f011d7b4 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d7b4:	55                   	push   %ebp
f011d7b5:	89 e5                	mov    %esp,%ebp
f011d7b7:	57                   	push   %edi
f011d7b8:	56                   	push   %esi
f011d7b9:	53                   	push   %ebx
f011d7ba:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d7bd:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011d7c2:	84 c0                	test   %al,%al
f011d7c4:	0f 84 9b 01 00 00    	je     f011d965 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d7ca:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d7d1:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d7d4:	bb 08 07 13 f0       	mov    $0xf0130708,%ebx
f011d7d9:	ba 05 00 00 00       	mov    $0x5,%edx
f011d7de:	89 c7                	mov    %eax,%edi
f011d7e0:	89 de                	mov    %ebx,%esi
f011d7e2:	89 d1                	mov    %edx,%ecx
f011d7e4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d7e6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d7ed:	e9 44 01 00 00       	jmp    f011d936 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d7f2:	6a 00                	push   $0x0
f011d7f4:	6a 00                	push   $0x0
f011d7f6:	68 f4 01 00 00       	push   $0x1f4
f011d7fb:	68 c1 05 13 f0       	push   $0xf01305c1
f011d800:	e8 5d d7 fe ff       	call   f010af62 <env_create>
f011d805:	83 c4 10             	add    $0x10,%esp
f011d808:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d80b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d80e:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d813:	99                   	cltd   
f011d814:	f7 f9                	idiv   %ecx
f011d816:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d819:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d81c:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d820:	83 ec 08             	sub    $0x8,%esp
f011d823:	50                   	push   %eax
f011d824:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d827:	e8 5a 8e fe ff       	call   f0106686 <env_set_nice>
f011d82c:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d82f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d833:	75 14                	jne    f011d849 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d835:	83 ec 04             	sub    $0x4,%esp
f011d838:	68 c9 05 13 f0       	push   $0xf01305c9
f011d83d:	6a 53                	push   $0x53
f011d83f:	68 e2 05 13 f0       	push   $0xf01305e2
f011d844:	e8 f0 2a fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d849:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d84c:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d852:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d857:	74 14                	je     f011d86d <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d859:	83 ec 04             	sub    $0x4,%esp
f011d85c:	68 00 06 13 f0       	push   $0xf0130600
f011d861:	6a 55                	push   $0x55
f011d863:	68 e2 05 13 f0       	push   $0xf01305e2
f011d868:	e8 cc 2a fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d86d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d870:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d874:	83 c0 0a             	add    $0xa,%eax
f011d877:	83 f8 14             	cmp    $0x14,%eax
f011d87a:	0f 87 a5 00 00 00    	ja     f011d925 <test_bsd_nice_0+0x171>
f011d880:	8b 04 85 1c 07 13 f0 	mov    -0xfecf8e4(,%eax,4),%eax
f011d887:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d889:	a1 fc 2b 6c f0       	mov    0xf06c2bfc,%eax
f011d88e:	8d 50 01             	lea    0x1(%eax),%edx
f011d891:	89 15 fc 2b 6c f0    	mov    %edx,0xf06c2bfc
f011d897:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d89a:	8b 52 10             	mov    0x10(%edx),%edx
f011d89d:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011d8a4:	eb 7f                	jmp    f011d925 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d8a6:	a1 00 2c 6c f0       	mov    0xf06c2c00,%eax
f011d8ab:	8d 50 01             	lea    0x1(%eax),%edx
f011d8ae:	89 15 00 2c 6c f0    	mov    %edx,0xf06c2c00
f011d8b4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d8b7:	8b 52 10             	mov    0x10(%edx),%edx
f011d8ba:	83 c0 0a             	add    $0xa,%eax
f011d8bd:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011d8c4:	eb 5f                	jmp    f011d925 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d8c6:	a1 04 2c 6c f0       	mov    0xf06c2c04,%eax
f011d8cb:	8d 50 01             	lea    0x1(%eax),%edx
f011d8ce:	89 15 04 2c 6c f0    	mov    %edx,0xf06c2c04
f011d8d4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d8d7:	8b 52 10             	mov    0x10(%edx),%edx
f011d8da:	83 c0 14             	add    $0x14,%eax
f011d8dd:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011d8e4:	eb 3f                	jmp    f011d925 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d8e6:	a1 08 2c 6c f0       	mov    0xf06c2c08,%eax
f011d8eb:	8d 50 01             	lea    0x1(%eax),%edx
f011d8ee:	89 15 08 2c 6c f0    	mov    %edx,0xf06c2c08
f011d8f4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d8f7:	8b 52 10             	mov    0x10(%edx),%edx
f011d8fa:	83 c0 1e             	add    $0x1e,%eax
f011d8fd:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011d904:	eb 1f                	jmp    f011d925 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d906:	a1 0c 2c 6c f0       	mov    0xf06c2c0c,%eax
f011d90b:	8d 50 01             	lea    0x1(%eax),%edx
f011d90e:	89 15 0c 2c 6c f0    	mov    %edx,0xf06c2c0c
f011d914:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d917:	8b 52 10             	mov    0x10(%edx),%edx
f011d91a:	83 c0 28             	add    $0x28,%eax
f011d91d:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011d924:	90                   	nop
			}
			sched_new_env(env);
f011d925:	83 ec 0c             	sub    $0xc,%esp
f011d928:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d92b:	e8 ec 7d fe ff       	call   f010571c <sched_new_env>
f011d930:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d933:	ff 45 e4             	incl   -0x1c(%ebp)
f011d936:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d93a:	0f 8e b2 fe ff ff    	jle    f011d7f2 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d940:	83 ec 0c             	sub    $0xc,%esp
f011d943:	68 30 06 13 f0       	push   $0xf0130630
f011d948:	e8 3e 36 fe ff       	call   f0100f8b <cprintf>
f011d94d:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d950:	83 ec 0c             	sub    $0xc,%esp
f011d953:	68 7f 06 13 f0       	push   $0xf013067f
f011d958:	e8 9e 45 fe ff       	call   f0101efb <execute_command>
f011d95d:	83 c4 10             	add    $0x10,%esp
f011d960:	e9 c0 00 00 00       	jmp    f011da25 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011d965:	83 ec 0c             	sub    $0xc,%esp
f011d968:	68 86 06 13 f0       	push   $0xf0130686
f011d96d:	e8 19 36 fe ff       	call   f0100f8b <cprintf>
f011d972:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d975:	e8 da 84 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d97a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d981:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d988:	e9 87 00 00 00       	jmp    f011da14 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d98d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d994:	eb 52                	jmp    f011d9e8 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d996:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d999:	8b 14 85 fc 2b 6c f0 	mov    -0xf93d404(,%eax,4),%edx
f011d9a0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d9a3:	89 c8                	mov    %ecx,%eax
f011d9a5:	c1 e0 02             	shl    $0x2,%eax
f011d9a8:	01 c8                	add    %ecx,%eax
f011d9aa:	01 c0                	add    %eax,%eax
f011d9ac:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d9af:	01 c8                	add    %ecx,%eax
f011d9b1:	8b 04 85 80 5d 65 f2 	mov    -0xd9aa280(,%eax,4),%eax
f011d9b8:	83 ec 04             	sub    $0x4,%esp
f011d9bb:	52                   	push   %edx
f011d9bc:	ff 75 e0             	pushl  -0x20(%ebp)
f011d9bf:	50                   	push   %eax
f011d9c0:	e8 3d fd ff ff       	call   f011d702 <find_in_range>
f011d9c5:	83 c4 10             	add    $0x10,%esp
f011d9c8:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d9cb:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d9cf:	75 14                	jne    f011d9e5 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011d9d1:	83 ec 04             	sub    $0x4,%esp
f011d9d4:	68 98 06 13 f0       	push   $0xf0130698
f011d9d9:	6a 7b                	push   $0x7b
f011d9db:	68 e2 05 13 f0       	push   $0xf01305e2
f011d9e0:	e8 54 29 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d9e5:	ff 45 d8             	incl   -0x28(%ebp)
f011d9e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d9eb:	89 d0                	mov    %edx,%eax
f011d9ed:	c1 e0 02             	shl    $0x2,%eax
f011d9f0:	01 d0                	add    %edx,%eax
f011d9f2:	01 c0                	add    %eax,%eax
f011d9f4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d9f7:	01 d0                	add    %edx,%eax
f011d9f9:	8b 04 85 80 5d 65 f2 	mov    -0xd9aa280(,%eax,4),%eax
f011da00:	85 c0                	test   %eax,%eax
f011da02:	75 92                	jne    f011d996 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011da04:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011da07:	8b 04 85 fc 2b 6c f0 	mov    -0xf93d404(,%eax,4),%eax
f011da0e:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011da11:	ff 45 dc             	incl   -0x24(%ebp)
f011da14:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011da18:	0f 8e 6f ff ff ff    	jle    f011d98d <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011da1e:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011da25:	83 ec 0c             	sub    $0xc,%esp
f011da28:	68 cc 06 13 f0       	push   $0xf01306cc
f011da2d:	e8 59 35 fe ff       	call   f0100f8b <cprintf>
f011da32:	83 c4 10             	add    $0x10,%esp
}
f011da35:	90                   	nop
f011da36:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011da39:	5b                   	pop    %ebx
f011da3a:	5e                   	pop    %esi
f011da3b:	5f                   	pop    %edi
f011da3c:	5d                   	pop    %ebp
f011da3d:	c3                   	ret    

f011da3e <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011da3e:	55                   	push   %ebp
f011da3f:	89 e5                	mov    %esp,%ebp
f011da41:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011da44:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011da49:	84 c0                	test   %al,%al
f011da4b:	0f 84 50 01 00 00    	je     f011dba1 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011da51:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011da58:	6a 00                	push   $0x0
f011da5a:	6a 00                	push   $0x0
f011da5c:	68 f4 01 00 00       	push   $0x1f4
f011da61:	68 c1 05 13 f0       	push   $0xf01305c1
f011da66:	e8 f7 d4 fe ff       	call   f010af62 <env_create>
f011da6b:	83 c4 10             	add    $0x10,%esp
f011da6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011da71:	6a 00                	push   $0x0
f011da73:	6a 00                	push   $0x0
f011da75:	68 f4 01 00 00       	push   $0x1f4
f011da7a:	68 70 07 13 f0       	push   $0xf0130770
f011da7f:	e8 de d4 fe ff       	call   f010af62 <env_create>
f011da84:	83 c4 10             	add    $0x10,%esp
f011da87:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011da8a:	6a 00                	push   $0x0
f011da8c:	6a 00                	push   $0x0
f011da8e:	68 f4 01 00 00       	push   $0x1f4
f011da93:	68 7d 07 13 f0       	push   $0xf013077d
f011da98:	e8 c5 d4 fe ff       	call   f010af62 <env_create>
f011da9d:	83 c4 10             	add    $0x10,%esp
f011daa0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011daa3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011daa7:	74 0c                	je     f011dab5 <test_bsd_nice_1+0x77>
f011daa9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011daad:	74 06                	je     f011dab5 <test_bsd_nice_1+0x77>
f011daaf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011dab3:	75 17                	jne    f011dacc <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011dab5:	83 ec 04             	sub    $0x4,%esp
f011dab8:	68 c9 05 13 f0       	push   $0xf01305c9
f011dabd:	68 8e 00 00 00       	push   $0x8e
f011dac2:	68 e2 05 13 f0       	push   $0xf01305e2
f011dac7:	e8 6d 28 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011dacc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dacf:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dad5:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dada:	75 20                	jne    f011dafc <test_bsd_nice_1+0xbe>
f011dadc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dadf:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dae5:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011daea:	75 10                	jne    f011dafc <test_bsd_nice_1+0xbe>
f011daec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011daef:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011daf5:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dafa:	74 35                	je     f011db31 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011dafc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011daff:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011db05:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011db08:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011db0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db11:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db17:	83 ec 08             	sub    $0x8,%esp
f011db1a:	51                   	push   %ecx
f011db1b:	52                   	push   %edx
f011db1c:	50                   	push   %eax
f011db1d:	68 8c 07 13 f0       	push   $0xf013078c
f011db22:	68 90 00 00 00       	push   $0x90
f011db27:	68 e2 05 13 f0       	push   $0xf01305e2
f011db2c:	e8 08 28 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011db31:	83 ec 0c             	sub    $0xc,%esp
f011db34:	ff 75 ec             	pushl  -0x14(%ebp)
f011db37:	e8 e0 7b fe ff       	call   f010571c <sched_new_env>
f011db3c:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011db3f:	83 ec 0c             	sub    $0xc,%esp
f011db42:	ff 75 e8             	pushl  -0x18(%ebp)
f011db45:	e8 d2 7b fe ff       	call   f010571c <sched_new_env>
f011db4a:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011db4d:	83 ec 0c             	sub    $0xc,%esp
f011db50:	ff 75 e4             	pushl  -0x1c(%ebp)
f011db53:	e8 c4 7b fe ff       	call   f010571c <sched_new_env>
f011db58:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011db5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011db5e:	8b 40 10             	mov    0x10(%eax),%eax
f011db61:	a3 80 5d 65 f2       	mov    %eax,0xf2655d80
		prog_orders[1][0] = fibEnv->env_id;
f011db66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db69:	8b 40 10             	mov    0x10(%eax),%eax
f011db6c:	a3 a8 5d 65 f2       	mov    %eax,0xf2655da8
		prog_orders[2][0] = fibposnEnv->env_id;
f011db71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011db74:	8b 40 10             	mov    0x10(%eax),%eax
f011db77:	a3 d0 5d 65 f2       	mov    %eax,0xf2655dd0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011db7c:	83 ec 0c             	sub    $0xc,%esp
f011db7f:	68 30 06 13 f0       	push   $0xf0130630
f011db84:	e8 02 34 fe ff       	call   f0100f8b <cprintf>
f011db89:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011db8c:	83 ec 0c             	sub    $0xc,%esp
f011db8f:	68 7f 06 13 f0       	push   $0xf013067f
f011db94:	e8 62 43 fe ff       	call   f0101efb <execute_command>
f011db99:	83 c4 10             	add    $0x10,%esp
f011db9c:	e9 9e 00 00 00       	jmp    f011dc3f <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011dba1:	83 ec 0c             	sub    $0xc,%esp
f011dba4:	68 86 06 13 f0       	push   $0xf0130686
f011dba9:	e8 dd 33 fe ff       	call   f0100f8b <cprintf>
f011dbae:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dbb1:	e8 9e 82 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011dbb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011dbbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011dbc4:	83 ec 0c             	sub    $0xc,%esp
f011dbc7:	68 60 2e 6c f0       	push   $0xf06c2e60
f011dbcc:	e8 9d 20 ff ff       	call   f010fc6e <acquire_spinlock>
f011dbd1:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dbd4:	a1 ec 2e 6c f0       	mov    0xf06c2eec,%eax
f011dbd9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011dbdc:	a1 e4 2e 6c f0       	mov    0xf06c2ee4,%eax
f011dbe1:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dbe4:	eb 41                	jmp    f011dc27 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011dbe6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dbe9:	89 d0                	mov    %edx,%eax
f011dbeb:	c1 e0 02             	shl    $0x2,%eax
f011dbee:	01 d0                	add    %edx,%eax
f011dbf0:	c1 e0 03             	shl    $0x3,%eax
f011dbf3:	05 80 5d 65 f2       	add    $0xf2655d80,%eax
f011dbf8:	8b 10                	mov    (%eax),%edx
f011dbfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dbfd:	8b 40 10             	mov    0x10(%eax),%eax
f011dc00:	39 c2                	cmp    %eax,%edx
f011dc02:	74 17                	je     f011dc1b <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011dc04:	83 ec 04             	sub    $0x4,%esp
f011dc07:	68 98 06 13 f0       	push   $0xf0130698
f011dc0c:	68 ab 00 00 00       	push   $0xab
f011dc11:	68 e2 05 13 f0       	push   $0xf01305e2
f011dc16:	e8 1e 27 fe ff       	call   f0100339 <_panic>
				i++;
f011dc1b:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dc1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dc21:	8b 40 0c             	mov    0xc(%eax),%eax
f011dc24:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011dc27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dc2a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dc2d:	7c b7                	jl     f011dbe6 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011dc2f:	83 ec 0c             	sub    $0xc,%esp
f011dc32:	68 60 2e 6c f0       	push   $0xf06c2e60
f011dc37:	e8 b9 20 ff ff       	call   f010fcf5 <release_spinlock>
f011dc3c:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011dc3f:	83 ec 0c             	sub    $0xc,%esp
f011dc42:	68 f8 07 13 f0       	push   $0xf01307f8
f011dc47:	e8 3f 33 fe ff       	call   f0100f8b <cprintf>
f011dc4c:	83 c4 10             	add    $0x10,%esp
}
f011dc4f:	90                   	nop
f011dc50:	c9                   	leave  
f011dc51:	c3                   	ret    

f011dc52 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011dc52:	55                   	push   %ebp
f011dc53:	89 e5                	mov    %esp,%ebp
f011dc55:	57                   	push   %edi
f011dc56:	56                   	push   %esi
f011dc57:	53                   	push   %ebx
f011dc58:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011dc5b:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011dc60:	84 c0                	test   %al,%al
f011dc62:	0f 84 ae 01 00 00    	je     f011de16 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011dc68:	83 ec 0c             	sub    $0xc,%esp
f011dc6b:	6a 01                	push   $0x1
f011dc6d:	e8 fe 10 00 00       	call   f011ed70 <chksch>
f011dc72:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011dc75:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011dc7c:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dc7f:	bb 7c 08 13 f0       	mov    $0xf013087c,%ebx
f011dc84:	ba 05 00 00 00       	mov    $0x5,%edx
f011dc89:	89 c7                	mov    %eax,%edi
f011dc8b:	89 de                	mov    %ebx,%esi
f011dc8d:	89 d1                	mov    %edx,%ecx
f011dc8f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dc91:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011dc98:	e9 4a 01 00 00       	jmp    f011dde7 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011dc9d:	6a 00                	push   $0x0
f011dc9f:	6a 00                	push   $0x0
f011dca1:	68 10 27 00 00       	push   $0x2710
f011dca6:	68 34 08 13 f0       	push   $0xf0130834
f011dcab:	e8 b2 d2 fe ff       	call   f010af62 <env_create>
f011dcb0:	83 c4 10             	add    $0x10,%esp
f011dcb3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011dcb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dcb9:	b9 05 00 00 00       	mov    $0x5,%ecx
f011dcbe:	99                   	cltd   
f011dcbf:	f7 f9                	idiv   %ecx
f011dcc1:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011dcc4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dcc7:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dccb:	83 ec 08             	sub    $0x8,%esp
f011dcce:	50                   	push   %eax
f011dccf:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dcd2:	e8 af 89 fe ff       	call   f0106686 <env_set_nice>
f011dcd7:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011dcda:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011dcde:	75 17                	jne    f011dcf7 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011dce0:	83 ec 04             	sub    $0x4,%esp
f011dce3:	68 c9 05 13 f0       	push   $0xf01305c9
f011dce8:	68 c1 00 00 00       	push   $0xc1
f011dced:	68 e2 05 13 f0       	push   $0xf01305e2
f011dcf2:	e8 42 26 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011dcf7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dcfa:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dd00:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011dd05:	74 17                	je     f011dd1e <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011dd07:	83 ec 04             	sub    $0x4,%esp
f011dd0a:	68 00 06 13 f0       	push   $0xf0130600
f011dd0f:	68 c3 00 00 00       	push   $0xc3
f011dd14:	68 e2 05 13 f0       	push   $0xf01305e2
f011dd19:	e8 1b 26 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dd1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dd21:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dd25:	83 c0 0f             	add    $0xf,%eax
f011dd28:	83 f8 1e             	cmp    $0x1e,%eax
f011dd2b:	0f 87 a5 00 00 00    	ja     f011ddd6 <test_bsd_nice_2+0x184>
f011dd31:	8b 04 85 90 08 13 f0 	mov    -0xfecf770(,%eax,4),%eax
f011dd38:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011dd3a:	a1 fc 2b 6c f0       	mov    0xf06c2bfc,%eax
f011dd3f:	8d 50 01             	lea    0x1(%eax),%edx
f011dd42:	89 15 fc 2b 6c f0    	mov    %edx,0xf06c2bfc
f011dd48:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd4b:	8b 52 10             	mov    0x10(%edx),%edx
f011dd4e:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011dd55:	eb 7f                	jmp    f011ddd6 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011dd57:	a1 00 2c 6c f0       	mov    0xf06c2c00,%eax
f011dd5c:	8d 50 01             	lea    0x1(%eax),%edx
f011dd5f:	89 15 00 2c 6c f0    	mov    %edx,0xf06c2c00
f011dd65:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd68:	8b 52 10             	mov    0x10(%edx),%edx
f011dd6b:	83 c0 0a             	add    $0xa,%eax
f011dd6e:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011dd75:	eb 5f                	jmp    f011ddd6 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011dd77:	a1 04 2c 6c f0       	mov    0xf06c2c04,%eax
f011dd7c:	8d 50 01             	lea    0x1(%eax),%edx
f011dd7f:	89 15 04 2c 6c f0    	mov    %edx,0xf06c2c04
f011dd85:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd88:	8b 52 10             	mov    0x10(%edx),%edx
f011dd8b:	83 c0 14             	add    $0x14,%eax
f011dd8e:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011dd95:	eb 3f                	jmp    f011ddd6 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011dd97:	a1 08 2c 6c f0       	mov    0xf06c2c08,%eax
f011dd9c:	8d 50 01             	lea    0x1(%eax),%edx
f011dd9f:	89 15 08 2c 6c f0    	mov    %edx,0xf06c2c08
f011dda5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dda8:	8b 52 10             	mov    0x10(%edx),%edx
f011ddab:	83 c0 1e             	add    $0x1e,%eax
f011ddae:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011ddb5:	eb 1f                	jmp    f011ddd6 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011ddb7:	a1 0c 2c 6c f0       	mov    0xf06c2c0c,%eax
f011ddbc:	8d 50 01             	lea    0x1(%eax),%edx
f011ddbf:	89 15 0c 2c 6c f0    	mov    %edx,0xf06c2c0c
f011ddc5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ddc8:	8b 52 10             	mov    0x10(%edx),%edx
f011ddcb:	83 c0 28             	add    $0x28,%eax
f011ddce:	89 14 85 80 5d 65 f2 	mov    %edx,-0xd9aa280(,%eax,4)
				break;
f011ddd5:	90                   	nop
			}
			sched_new_env(env);
f011ddd6:	83 ec 0c             	sub    $0xc,%esp
f011ddd9:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dddc:	e8 3b 79 fe ff       	call   f010571c <sched_new_env>
f011dde1:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dde4:	ff 45 e4             	incl   -0x1c(%ebp)
f011dde7:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011ddeb:	0f 8e ac fe ff ff    	jle    f011dc9d <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011ddf1:	83 ec 0c             	sub    $0xc,%esp
f011ddf4:	68 30 06 13 f0       	push   $0xf0130630
f011ddf9:	e8 8d 31 fe ff       	call   f0100f8b <cprintf>
f011ddfe:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011de01:	83 ec 0c             	sub    $0xc,%esp
f011de04:	68 7f 06 13 f0       	push   $0xf013067f
f011de09:	e8 ed 40 fe ff       	call   f0101efb <execute_command>
f011de0e:	83 c4 10             	add    $0x10,%esp
f011de11:	e9 d0 00 00 00       	jmp    f011dee6 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011de16:	83 ec 0c             	sub    $0xc,%esp
f011de19:	6a 00                	push   $0x0
f011de1b:	e8 50 0f 00 00       	call   f011ed70 <chksch>
f011de20:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011de23:	83 ec 0c             	sub    $0xc,%esp
f011de26:	68 86 06 13 f0       	push   $0xf0130686
f011de2b:	e8 5b 31 fe ff       	call   f0100f8b <cprintf>
f011de30:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011de33:	e8 1c 80 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011de38:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011de3f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011de46:	e9 8a 00 00 00       	jmp    f011ded5 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011de4b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011de52:	eb 55                	jmp    f011dea9 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011de54:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de57:	8b 14 85 fc 2b 6c f0 	mov    -0xf93d404(,%eax,4),%edx
f011de5e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011de61:	89 c8                	mov    %ecx,%eax
f011de63:	c1 e0 02             	shl    $0x2,%eax
f011de66:	01 c8                	add    %ecx,%eax
f011de68:	01 c0                	add    %eax,%eax
f011de6a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011de6d:	01 c8                	add    %ecx,%eax
f011de6f:	8b 04 85 80 5d 65 f2 	mov    -0xd9aa280(,%eax,4),%eax
f011de76:	83 ec 04             	sub    $0x4,%esp
f011de79:	52                   	push   %edx
f011de7a:	ff 75 e0             	pushl  -0x20(%ebp)
f011de7d:	50                   	push   %eax
f011de7e:	e8 7f f8 ff ff       	call   f011d702 <find_in_range>
f011de83:	83 c4 10             	add    $0x10,%esp
f011de86:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011de89:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011de8d:	75 17                	jne    f011dea6 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011de8f:	83 ec 04             	sub    $0x4,%esp
f011de92:	68 98 06 13 f0       	push   $0xf0130698
f011de97:	68 ea 00 00 00       	push   $0xea
f011de9c:	68 e2 05 13 f0       	push   $0xf01305e2
f011dea1:	e8 93 24 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dea6:	ff 45 d8             	incl   -0x28(%ebp)
f011dea9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011deac:	89 d0                	mov    %edx,%eax
f011deae:	c1 e0 02             	shl    $0x2,%eax
f011deb1:	01 d0                	add    %edx,%eax
f011deb3:	01 c0                	add    %eax,%eax
f011deb5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011deb8:	01 d0                	add    %edx,%eax
f011deba:	8b 04 85 80 5d 65 f2 	mov    -0xd9aa280(,%eax,4),%eax
f011dec1:	85 c0                	test   %eax,%eax
f011dec3:	75 8f                	jne    f011de54 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011dec5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dec8:	8b 04 85 fc 2b 6c f0 	mov    -0xf93d404(,%eax,4),%eax
f011decf:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ded2:	ff 45 dc             	incl   -0x24(%ebp)
f011ded5:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011ded9:	0f 8e 6c ff ff ff    	jle    f011de4b <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011dedf:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011dee6:	83 ec 0c             	sub    $0xc,%esp
f011dee9:	68 40 08 13 f0       	push   $0xf0130840
f011deee:	e8 98 30 fe ff       	call   f0100f8b <cprintf>
f011def3:	83 c4 10             	add    $0x10,%esp
}
f011def6:	90                   	nop
f011def7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011defa:	5b                   	pop    %ebx
f011defb:	5e                   	pop    %esi
f011defc:	5f                   	pop    %edi
f011defd:	5d                   	pop    %ebp
f011defe:	c3                   	ret    

f011deff <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011deff:	55                   	push   %ebp
f011df00:	89 e5                	mov    %esp,%ebp
f011df02:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011df05:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df08:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011df0b:	8b 45 08             	mov    0x8(%ebp),%eax
f011df0e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011df11:	89 10                	mov    %edx,(%eax)
}
f011df13:	8b 45 08             	mov    0x8(%ebp),%eax
f011df16:	c9                   	leave  
f011df17:	c2 04 00             	ret    $0x4

f011df1a <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011df1a:	55                   	push   %ebp
f011df1b:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011df1d:	8b 45 08             	mov    0x8(%ebp),%eax
f011df20:	85 c0                	test   %eax,%eax
f011df22:	78 16                	js     f011df3a <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011df24:	8b 45 08             	mov    0x8(%ebp),%eax
f011df27:	05 00 20 00 00       	add    $0x2000,%eax
f011df2c:	85 c0                	test   %eax,%eax
f011df2e:	79 05                	jns    f011df35 <fix_round+0x1b>
f011df30:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011df35:	c1 f8 0e             	sar    $0xe,%eax
f011df38:	eb 14                	jmp    f011df4e <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011df3a:	8b 45 08             	mov    0x8(%ebp),%eax
f011df3d:	2d 00 20 00 00       	sub    $0x2000,%eax
f011df42:	85 c0                	test   %eax,%eax
f011df44:	79 05                	jns    f011df4b <fix_round+0x31>
f011df46:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011df4b:	c1 f8 0e             	sar    $0xe,%eax
}
f011df4e:	5d                   	pop    %ebp
f011df4f:	c3                   	ret    

f011df50 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011df50:	55                   	push   %ebp
f011df51:	89 e5                	mov    %esp,%ebp
f011df53:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011df56:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011df5a:	79 16                	jns    f011df72 <fix_scale+0x22>
f011df5c:	68 0c 09 13 f0       	push   $0xf013090c
f011df61:	68 13 09 13 f0       	push   $0xf0130913
f011df66:	6a 5a                	push   $0x5a
f011df68:	68 28 09 13 f0       	push   $0xf0130928
f011df6d:	e8 c7 23 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011df72:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df75:	0f af 45 10          	imul   0x10(%ebp),%eax
f011df79:	89 c2                	mov    %eax,%edx
f011df7b:	8b 45 08             	mov    0x8(%ebp),%eax
f011df7e:	83 ec 08             	sub    $0x8,%esp
f011df81:	52                   	push   %edx
f011df82:	50                   	push   %eax
f011df83:	e8 77 ff ff ff       	call   f011deff <__mk_fix>
f011df88:	83 c4 0c             	add    $0xc,%esp
}
f011df8b:	8b 45 08             	mov    0x8(%ebp),%eax
f011df8e:	c9                   	leave  
f011df8f:	c2 04 00             	ret    $0x4

f011df92 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011df92:	55                   	push   %ebp
f011df93:	89 e5                	mov    %esp,%ebp
f011df95:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011df98:	83 ec 08             	sub    $0x8,%esp
f011df9b:	68 3c 09 13 f0       	push   $0xf013093c
f011dfa0:	68 80 36 ec f0       	push   $0xf0ec3680
f011dfa5:	e8 93 1c ff ff       	call   f010fc3d <init_spinlock>
f011dfaa:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011dfad:	83 ec 0c             	sub    $0xc,%esp
f011dfb0:	68 80 36 ec f0       	push   $0xf0ec3680
f011dfb5:	e8 b4 1c ff ff       	call   f010fc6e <acquire_spinlock>
f011dfba:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011dfbd:	c7 05 48 2d 6c f0 00 	movl   $0x0,0xf06c2d48
f011dfc4:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011dfc7:	83 ec 0c             	sub    $0xc,%esp
f011dfca:	68 80 36 ec f0       	push   $0xf0ec3680
f011dfcf:	e8 21 1d ff ff       	call   f010fcf5 <release_spinlock>
f011dfd4:	83 c4 10             	add    $0x10,%esp
}
f011dfd7:	90                   	nop
f011dfd8:	c9                   	leave  
f011dfd9:	c3                   	ret    

f011dfda <inctst>:
void inctst()
{
f011dfda:	55                   	push   %ebp
f011dfdb:	89 e5                	mov    %esp,%ebp
f011dfdd:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011dfe0:	83 ec 0c             	sub    $0xc,%esp
f011dfe3:	68 80 36 ec f0       	push   $0xf0ec3680
f011dfe8:	e8 81 1c ff ff       	call   f010fc6e <acquire_spinlock>
f011dfed:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011dff0:	a1 48 2d 6c f0       	mov    0xf06c2d48,%eax
f011dff5:	40                   	inc    %eax
f011dff6:	a3 48 2d 6c f0       	mov    %eax,0xf06c2d48
	}
	release_spinlock(&tstcntlock);
f011dffb:	83 ec 0c             	sub    $0xc,%esp
f011dffe:	68 80 36 ec f0       	push   $0xf0ec3680
f011e003:	e8 ed 1c ff ff       	call   f010fcf5 <release_spinlock>
f011e008:	83 c4 10             	add    $0x10,%esp
}
f011e00b:	90                   	nop
f011e00c:	c9                   	leave  
f011e00d:	c3                   	ret    

f011e00e <gettst>:
uint32 gettst()
{
f011e00e:	55                   	push   %ebp
f011e00f:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011e011:	a1 48 2d 6c f0       	mov    0xf06c2d48,%eax
}
f011e016:	5d                   	pop    %ebp
f011e017:	c3                   	ret    

f011e018 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011e018:	55                   	push   %ebp
f011e019:	89 e5                	mov    %esp,%ebp
f011e01b:	83 ec 28             	sub    $0x28,%esp
f011e01e:	8b 45 14             	mov    0x14(%ebp),%eax
f011e021:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011e024:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011e02b:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011e02f:	83 f8 65             	cmp    $0x65,%eax
f011e032:	74 5d                	je     f011e091 <tst+0x79>
f011e034:	83 f8 65             	cmp    $0x65,%eax
f011e037:	7f 0a                	jg     f011e043 <tst+0x2b>
f011e039:	83 f8 62             	cmp    $0x62,%eax
f011e03c:	74 73                	je     f011e0b1 <tst+0x99>
f011e03e:	e9 91 00 00 00       	jmp    f011e0d4 <tst+0xbc>
f011e043:	83 f8 67             	cmp    $0x67,%eax
f011e046:	74 29                	je     f011e071 <tst+0x59>
f011e048:	83 f8 6c             	cmp    $0x6c,%eax
f011e04b:	0f 85 83 00 00 00    	jne    f011e0d4 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011e051:	8b 45 08             	mov    0x8(%ebp),%eax
f011e054:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e057:	73 09                	jae    f011e062 <tst+0x4a>
			chk = 1;
f011e059:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e060:	eb 68                	jmp    f011e0ca <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e062:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e066:	74 62                	je     f011e0ca <tst+0xb2>
			chk = 1;
f011e068:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e06f:	eb 59                	jmp    f011e0ca <tst+0xb2>
	case 'g':
		if (n > v1)
f011e071:	8b 45 08             	mov    0x8(%ebp),%eax
f011e074:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e077:	76 09                	jbe    f011e082 <tst+0x6a>
			chk = 1;
f011e079:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e080:	eb 4b                	jmp    f011e0cd <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e082:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e086:	74 45                	je     f011e0cd <tst+0xb5>
			chk = 1;
f011e088:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e08f:	eb 3c                	jmp    f011e0cd <tst+0xb5>
	case 'e':
		if (n == v1)
f011e091:	8b 45 08             	mov    0x8(%ebp),%eax
f011e094:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e097:	75 09                	jne    f011e0a2 <tst+0x8a>
			chk = 1;
f011e099:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e0a0:	eb 2e                	jmp    f011e0d0 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e0a2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e0a6:	74 28                	je     f011e0d0 <tst+0xb8>
			chk = 1;
f011e0a8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e0af:	eb 1f                	jmp    f011e0d0 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e0b1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0b4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e0b7:	72 1a                	jb     f011e0d3 <tst+0xbb>
f011e0b9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0bc:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e0bf:	77 12                	ja     f011e0d3 <tst+0xbb>
			chk = 1;
f011e0c1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e0c8:	eb 09                	jmp    f011e0d3 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e0ca:	90                   	nop
f011e0cb:	eb 07                	jmp    f011e0d4 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e0cd:	90                   	nop
f011e0ce:	eb 04                	jmp    f011e0d4 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e0d0:	90                   	nop
f011e0d1:	eb 01                	jmp    f011e0d4 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e0d3:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e0d4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e0d8:	75 14                	jne    f011e0ee <tst+0xd6>
f011e0da:	83 ec 04             	sub    $0x4,%esp
f011e0dd:	68 48 09 13 f0       	push   $0xf0130948
f011e0e2:	6a 48                	push   $0x48
f011e0e4:	68 5b 09 13 f0       	push   $0xf013095b
f011e0e9:	e8 4b 22 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e0ee:	83 ec 0c             	sub    $0xc,%esp
f011e0f1:	68 80 36 ec f0       	push   $0xf0ec3680
f011e0f6:	e8 73 1b ff ff       	call   f010fc6e <acquire_spinlock>
f011e0fb:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e0fe:	a1 48 2d 6c f0       	mov    0xf06c2d48,%eax
f011e103:	40                   	inc    %eax
f011e104:	a3 48 2d 6c f0       	mov    %eax,0xf06c2d48
	}
	release_spinlock(&tstcntlock);
f011e109:	83 ec 0c             	sub    $0xc,%esp
f011e10c:	68 80 36 ec f0       	push   $0xf0ec3680
f011e111:	e8 df 1b ff ff       	call   f010fcf5 <release_spinlock>
f011e116:	83 c4 10             	add    $0x10,%esp

	return;
f011e119:	90                   	nop
}
f011e11a:	c9                   	leave  
f011e11b:	c3                   	ret    

f011e11c <chktst>:

void chktst(uint32 n)
{
f011e11c:	55                   	push   %ebp
f011e11d:	89 e5                	mov    %esp,%ebp
f011e11f:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e122:	83 ec 0c             	sub    $0xc,%esp
f011e125:	68 80 36 ec f0       	push   $0xf0ec3680
f011e12a:	e8 3f 1b ff ff       	call   f010fc6e <acquire_spinlock>
f011e12f:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e132:	a1 48 2d 6c f0       	mov    0xf06c2d48,%eax
f011e137:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e13a:	83 ec 0c             	sub    $0xc,%esp
f011e13d:	68 80 36 ec f0       	push   $0xf0ec3680
f011e142:	e8 ae 1b ff ff       	call   f010fcf5 <release_spinlock>
f011e147:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e14a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e14d:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e150:	75 12                	jne    f011e164 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e152:	83 ec 0c             	sub    $0xc,%esp
f011e155:	68 74 09 13 f0       	push   $0xf0130974
f011e15a:	e8 2c 2e fe ff       	call   f0100f8b <cprintf>
f011e15f:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e162:	eb 14                	jmp    f011e178 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e164:	83 ec 04             	sub    $0x4,%esp
f011e167:	68 a0 09 13 f0       	push   $0xf01309a0
f011e16c:	6a 5e                	push   $0x5e
f011e16e:	68 5b 09 13 f0       	push   $0xf013095b
f011e173:	e8 c1 21 fe ff       	call   f0100339 <_panic>
}
f011e178:	c9                   	leave  
f011e179:	c3                   	ret    

f011e17a <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e17a:	55                   	push   %ebp
f011e17b:	89 e5                	mov    %esp,%ebp
f011e17d:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e180:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e184:	77 07                	ja     f011e18d <nearest_pow2_ceil+0x13>
f011e186:	b8 01 00 00 00       	mov    $0x1,%eax
f011e18b:	eb 20                	jmp    f011e1ad <nearest_pow2_ceil+0x33>
	int power = 2;
f011e18d:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e194:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e197:	eb 08                	jmp    f011e1a1 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e199:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e19c:	01 c0                	add    %eax,%eax
f011e19e:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e1a1:	d1 6d 08             	shrl   0x8(%ebp)
f011e1a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e1a8:	75 ef                	jne    f011e199 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e1aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e1ad:	c9                   	leave  
f011e1ae:	c3                   	ret    

f011e1af <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e1af:	55                   	push   %ebp
f011e1b0:	89 e5                	mov    %esp,%ebp
f011e1b2:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e1b5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e1b9:	77 07                	ja     f011e1c2 <log2_ceil+0x13>
f011e1bb:	b8 01 00 00 00       	mov    $0x1,%eax
f011e1c0:	eb 1b                	jmp    f011e1dd <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e1c2:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e1c9:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e1cc:	eb 03                	jmp    f011e1d1 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e1ce:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e1d1:	d1 6d 08             	shrl   0x8(%ebp)
f011e1d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e1d8:	75 f4                	jne    f011e1ce <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e1da:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e1dd:	c9                   	leave  
f011e1de:	c3                   	ret    

f011e1df <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e1df:	55                   	push   %ebp
f011e1e0:	89 e5                	mov    %esp,%ebp
f011e1e2:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e1e5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e1ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e1f3:	eb 12                	jmp    f011e207 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e1f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1f8:	89 d0                	mov    %edx,%eax
f011e1fa:	c1 e0 02             	shl    $0x2,%eax
f011e1fd:	01 d0                	add    %edx,%eax
f011e1ff:	01 c0                	add    %eax,%eax
f011e201:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e204:	ff 45 f0             	incl   -0x10(%ebp)
f011e207:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e20a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e20d:	7c e6                	jl     f011e1f5 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e20f:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e212:	83 ec 04             	sub    $0x4,%esp
f011e215:	ff 75 f4             	pushl  -0xc(%ebp)
f011e218:	ff 75 08             	pushl  0x8(%ebp)
f011e21b:	50                   	push   %eax
f011e21c:	e8 2f fd ff ff       	call   f011df50 <fix_scale>
f011e221:	83 c4 0c             	add    $0xc,%esp
f011e224:	83 ec 0c             	sub    $0xc,%esp
f011e227:	ff 75 dc             	pushl  -0x24(%ebp)
f011e22a:	e8 eb fc ff ff       	call   f011df1a <fix_round>
f011e22f:	83 c4 10             	add    $0x10,%esp
f011e232:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e235:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e238:	99                   	cltd   
f011e239:	f7 7d f4             	idivl  -0xc(%ebp)
f011e23c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e23f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e242:	99                   	cltd   
f011e243:	f7 7d f4             	idivl  -0xc(%ebp)
f011e246:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e249:	83 ec 08             	sub    $0x8,%esp
f011e24c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e24f:	50                   	push   %eax
f011e250:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e253:	e8 6a 1e 00 00       	call   f01200c2 <ltostr>
f011e258:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e25b:	83 ec 08             	sub    $0x8,%esp
f011e25e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e261:	50                   	push   %eax
f011e262:	ff 75 e0             	pushl  -0x20(%ebp)
f011e265:	e8 58 1e 00 00       	call   f01200c2 <ltostr>
f011e26a:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e26d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e270:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e275:	f7 e9                	imul   %ecx
f011e277:	c1 fa 02             	sar    $0x2,%edx
f011e27a:	89 c8                	mov    %ecx,%eax
f011e27c:	c1 f8 1f             	sar    $0x1f,%eax
f011e27f:	29 c2                	sub    %eax,%edx
f011e281:	89 d0                	mov    %edx,%eax
f011e283:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e286:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e28d:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e294:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e29a:	eb 31                	jmp    f011e2cd <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e29c:	83 ec 04             	sub    $0x4,%esp
f011e29f:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e2a2:	50                   	push   %eax
f011e2a3:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e2a6:	50                   	push   %eax
f011e2a7:	68 bc 09 13 f0       	push   $0xf01309bc
f011e2ac:	e8 ea 1e 00 00       	call   f012019b <strcconcat>
f011e2b1:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e2b4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e2b7:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e2bc:	f7 e9                	imul   %ecx
f011e2be:	c1 fa 02             	sar    $0x2,%edx
f011e2c1:	89 c8                	mov    %ecx,%eax
f011e2c3:	c1 f8 1f             	sar    $0x1f,%eax
f011e2c6:	29 c2                	sub    %eax,%edx
f011e2c8:	89 d0                	mov    %edx,%eax
f011e2ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e2cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e2d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e2d3:	7c c7                	jl     f011e29c <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e2d5:	83 ec 04             	sub    $0x4,%esp
f011e2d8:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e2db:	50                   	push   %eax
f011e2dc:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e2df:	50                   	push   %eax
f011e2e0:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e2e3:	50                   	push   %eax
f011e2e4:	e8 b2 1e 00 00       	call   f012019b <strcconcat>
f011e2e9:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e2ec:	83 ec 04             	sub    $0x4,%esp
f011e2ef:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e2f2:	50                   	push   %eax
f011e2f3:	68 be 09 13 f0       	push   $0xf01309be
f011e2f8:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e2fb:	50                   	push   %eax
f011e2fc:	e8 9a 1e 00 00       	call   f012019b <strcconcat>
f011e301:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e304:	83 ec 04             	sub    $0x4,%esp
f011e307:	ff 75 10             	pushl  0x10(%ebp)
f011e30a:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e30d:	50                   	push   %eax
f011e30e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e311:	50                   	push   %eax
f011e312:	e8 84 1e 00 00       	call   f012019b <strcconcat>
f011e317:	83 c4 10             	add    $0x10,%esp

}
f011e31a:	90                   	nop
f011e31b:	c9                   	leave  
f011e31c:	c3                   	ret    

f011e31d <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e31d:	55                   	push   %ebp
f011e31e:	89 e5                	mov    %esp,%ebp
f011e320:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e326:	83 ec 0c             	sub    $0xc,%esp
f011e329:	68 c0 09 13 f0       	push   $0xf01309c0
f011e32e:	e8 e9 18 00 00       	call   f011fc1c <strlen>
f011e333:	83 c4 10             	add    $0x10,%esp
f011e336:	83 ec 04             	sub    $0x4,%esp
f011e339:	50                   	push   %eax
f011e33a:	68 c0 09 13 f0       	push   $0xf01309c0
f011e33f:	ff 75 08             	pushl  0x8(%ebp)
f011e342:	e8 19 1a 00 00       	call   f011fd60 <strncmp>
f011e347:	83 c4 10             	add    $0x10,%esp
f011e34a:	85 c0                	test   %eax,%eax
f011e34c:	0f 85 8a 00 00 00    	jne    f011e3dc <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e352:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e355:	50                   	push   %eax
f011e356:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e35c:	50                   	push   %eax
f011e35d:	68 ce 09 13 f0       	push   $0xf01309ce
f011e362:	ff 75 08             	pushl  0x8(%ebp)
f011e365:	e8 c7 1e 00 00       	call   f0120231 <strsplit>
f011e36a:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e36d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e373:	83 ec 04             	sub    $0x4,%esp
f011e376:	6a 0a                	push   $0xa
f011e378:	6a 00                	push   $0x0
f011e37a:	50                   	push   %eax
f011e37b:	e8 fc 1b 00 00       	call   f011ff7c <strtol>
f011e380:	83 c4 10             	add    $0x10,%esp
f011e383:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e386:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e38d:	83 ec 04             	sub    $0x4,%esp
f011e390:	6a 00                	push   $0x0
f011e392:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e395:	50                   	push   %eax
f011e396:	ff 75 e0             	pushl  -0x20(%ebp)
f011e399:	e8 92 d6 fe ff       	call   f010ba30 <envid2env>
f011e39e:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e3a1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e3a4:	8b 40 10             	mov    0x10(%eax),%eax
f011e3a7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e3aa:	74 19                	je     f011e3c5 <sys_utilities+0xa8>
f011e3ac:	68 d0 09 13 f0       	push   $0xf01309d0
f011e3b1:	68 13 09 13 f0       	push   $0xf0130913
f011e3b6:	68 a4 00 00 00       	push   $0xa4
f011e3bb:	68 5b 09 13 f0       	push   $0xf013095b
f011e3c0:	e8 74 1f fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e3c5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e3c8:	83 ec 08             	sub    $0x8,%esp
f011e3cb:	ff 75 0c             	pushl  0xc(%ebp)
f011e3ce:	50                   	push   %eax
f011e3cf:	e8 b2 82 fe ff       	call   f0106686 <env_set_nice>
f011e3d4:	83 c4 10             	add    $0x10,%esp
f011e3d7:	e9 12 04 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e3dc:	83 ec 0c             	sub    $0xc,%esp
f011e3df:	68 e5 09 13 f0       	push   $0xf01309e5
f011e3e4:	e8 33 18 00 00       	call   f011fc1c <strlen>
f011e3e9:	83 c4 10             	add    $0x10,%esp
f011e3ec:	83 ec 04             	sub    $0x4,%esp
f011e3ef:	50                   	push   %eax
f011e3f0:	68 e5 09 13 f0       	push   $0xf01309e5
f011e3f5:	ff 75 08             	pushl  0x8(%ebp)
f011e3f8:	e8 63 19 00 00       	call   f011fd60 <strncmp>
f011e3fd:	83 c4 10             	add    $0x10,%esp
f011e400:	85 c0                	test   %eax,%eax
f011e402:	0f 85 a6 01 00 00    	jne    f011e5ae <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e408:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e40b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e40e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e411:	50                   	push   %eax
f011e412:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e418:	50                   	push   %eax
f011e419:	68 ce 09 13 f0       	push   $0xf01309ce
f011e41e:	ff 75 08             	pushl  0x8(%ebp)
f011e421:	e8 0b 1e 00 00       	call   f0120231 <strsplit>
f011e426:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e429:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e42f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e432:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e439:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e440:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e447:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e44a:	8b 00                	mov    (%eax),%eax
f011e44c:	85 c0                	test   %eax,%eax
f011e44e:	79 1c                	jns    f011e46c <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e450:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e457:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e45a:	8b 00                	mov    (%eax),%eax
f011e45c:	f7 d8                	neg    %eax
f011e45e:	89 c2                	mov    %eax,%edx
f011e460:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e463:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e465:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e46c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e473:	83 ec 0c             	sub    $0xc,%esp
f011e476:	68 60 2e 6c f0       	push   $0xf06c2e60
f011e47b:	e8 ee 17 ff ff       	call   f010fc6e <acquire_spinlock>
f011e480:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e483:	a1 ec 2e 6c f0       	mov    0xf06c2eec,%eax
f011e488:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e48b:	a1 e4 2e 6c f0       	mov    0xf06c2ee4,%eax
f011e490:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e493:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e496:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e499:	eb 6c                	jmp    f011e507 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e49b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e49e:	83 c0 20             	add    $0x20,%eax
f011e4a1:	83 ec 08             	sub    $0x8,%esp
f011e4a4:	ff 75 d8             	pushl  -0x28(%ebp)
f011e4a7:	50                   	push   %eax
f011e4a8:	e8 7b 18 00 00       	call   f011fd28 <strcmp>
f011e4ad:	83 c4 10             	add    $0x10,%esp
f011e4b0:	85 c0                	test   %eax,%eax
f011e4b2:	75 46                	jne    f011e4fa <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e4b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4b7:	8b 00                	mov    (%eax),%eax
f011e4b9:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e4bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4bf:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e4c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e4c5:	74 14                	je     f011e4db <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e4c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e4ca:	8b 40 10             	mov    0x10(%eax),%eax
f011e4cd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e4d0:	7d 1d                	jge    f011e4ef <sys_utilities+0x1d2>
					{
						success = 0;
f011e4d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e4d9:	eb 32                	jmp    f011e50d <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e4db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e4de:	8b 40 10             	mov    0x10(%eax),%eax
f011e4e1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e4e4:	7e 09                	jle    f011e4ef <sys_utilities+0x1d2>
					{
						success = 0;
f011e4e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e4ed:	eb 1e                	jmp    f011e50d <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e4ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e4f2:	8b 40 10             	mov    0x10(%eax),%eax
f011e4f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e4f8:	eb 01                	jmp    f011e4fb <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e4fa:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e4fb:	ff 4d e4             	decl   -0x1c(%ebp)
f011e4fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e501:	8b 40 0c             	mov    0xc(%eax),%eax
f011e504:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e507:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e50b:	7f 8e                	jg     f011e49b <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e50d:	83 ec 0c             	sub    $0xc,%esp
f011e510:	68 60 2e 6c f0       	push   $0xf06c2e60
f011e515:	e8 db 17 ff ff       	call   f010fcf5 <release_spinlock>
f011e51a:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e51d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e520:	8b 00                	mov    (%eax),%eax
f011e522:	85 c0                	test   %eax,%eax
f011e524:	75 06                	jne    f011e52c <sys_utilities+0x20f>
f011e526:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e52a:	75 41                	jne    f011e56d <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e52c:	83 ec 0c             	sub    $0xc,%esp
f011e52f:	68 f8 09 13 f0       	push   $0xf01309f8
f011e534:	e8 52 2a fe ff       	call   f0100f8b <cprintf>
f011e539:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e53c:	83 ec 08             	sub    $0x8,%esp
f011e53f:	ff 75 d8             	pushl  -0x28(%ebp)
f011e542:	68 28 0a 13 f0       	push   $0xf0130a28
f011e547:	e8 3f 2a fe ff       	call   f0100f8b <cprintf>
f011e54c:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e54f:	83 ec 0c             	sub    $0xc,%esp
f011e552:	68 f8 09 13 f0       	push   $0xf01309f8
f011e557:	e8 2f 2a fe ff       	call   f0100f8b <cprintf>
f011e55c:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e55f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e562:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e568:	e9 81 02 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e56d:	83 ec 0c             	sub    $0xc,%esp
f011e570:	68 48 0a 13 f0       	push   $0xf0130a48
f011e575:	e8 11 2a fe ff       	call   f0100f8b <cprintf>
f011e57a:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e57d:	83 ec 08             	sub    $0x8,%esp
f011e580:	ff 75 d8             	pushl  -0x28(%ebp)
f011e583:	68 80 0a 13 f0       	push   $0xf0130a80
f011e588:	e8 fe 29 fe ff       	call   f0100f8b <cprintf>
f011e58d:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e590:	83 ec 0c             	sub    $0xc,%esp
f011e593:	68 48 0a 13 f0       	push   $0xf0130a48
f011e598:	e8 ee 29 fe ff       	call   f0100f8b <cprintf>
f011e59d:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e5a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e5a3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e5a9:	e9 40 02 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e5ae:	83 ec 08             	sub    $0x8,%esp
f011e5b1:	68 a3 0a 13 f0       	push   $0xf0130aa3
f011e5b6:	ff 75 08             	pushl  0x8(%ebp)
f011e5b9:	e8 6a 17 00 00       	call   f011fd28 <strcmp>
f011e5be:	83 c4 10             	add    $0x10,%esp
f011e5c1:	85 c0                	test   %eax,%eax
f011e5c3:	75 77                	jne    f011e63c <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e5c5:	a1 e0 fd 17 f0       	mov    0xf017fde0,%eax
f011e5ca:	85 c0                	test   %eax,%eax
f011e5cc:	74 34                	je     f011e602 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e5ce:	c7 05 e0 fd 17 f0 00 	movl   $0x0,0xf017fde0
f011e5d5:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e5d8:	83 ec 08             	sub    $0x8,%esp
f011e5db:	68 ad 0a 13 f0       	push   $0xf0130aad
f011e5e0:	68 60 5e 65 f2       	push   $0xf2655e60
f011e5e5:	e8 44 1a ff ff       	call   f011002e <init_channel>
f011e5ea:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e5ed:	83 ec 08             	sub    $0x8,%esp
f011e5f0:	68 ba 0a 13 f0       	push   $0xf0130aba
f011e5f5:	68 e0 5f 65 f2       	push   $0xf2655fe0
f011e5fa:	e8 3e 16 ff ff       	call   f010fc3d <init_spinlock>
f011e5ff:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011e602:	83 ec 0c             	sub    $0xc,%esp
f011e605:	68 e0 5f 65 f2       	push   $0xf2655fe0
f011e60a:	e8 5f 16 ff ff       	call   f010fc6e <acquire_spinlock>
f011e60f:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011e612:	83 ec 08             	sub    $0x8,%esp
f011e615:	68 e0 5f 65 f2       	push   $0xf2655fe0
f011e61a:	68 60 5e 65 f2       	push   $0xf2655e60
f011e61f:	e8 37 1a ff ff       	call   f011005b <sleep>
f011e624:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e627:	83 ec 0c             	sub    $0xc,%esp
f011e62a:	68 e0 5f 65 f2       	push   $0xf2655fe0
f011e62f:	e8 c1 16 ff ff       	call   f010fcf5 <release_spinlock>
f011e634:	83 c4 10             	add    $0x10,%esp
f011e637:	e9 b2 01 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e63c:	83 ec 08             	sub    $0x8,%esp
f011e63f:	68 cc 0a 13 f0       	push   $0xf0130acc
f011e644:	ff 75 08             	pushl  0x8(%ebp)
f011e647:	e8 dc 16 00 00       	call   f011fd28 <strcmp>
f011e64c:	83 c4 10             	add    $0x10,%esp
f011e64f:	85 c0                	test   %eax,%eax
f011e651:	75 15                	jne    f011e668 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e653:	83 ec 0c             	sub    $0xc,%esp
f011e656:	68 60 5e 65 f2       	push   $0xf2655e60
f011e65b:	e8 68 1a ff ff       	call   f01100c8 <wakeup_one>
f011e660:	83 c4 10             	add    $0x10,%esp
f011e663:	e9 86 01 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e668:	83 ec 08             	sub    $0x8,%esp
f011e66b:	68 da 0a 13 f0       	push   $0xf0130ada
f011e670:	ff 75 08             	pushl  0x8(%ebp)
f011e673:	e8 b0 16 00 00       	call   f011fd28 <strcmp>
f011e678:	83 c4 10             	add    $0x10,%esp
f011e67b:	85 c0                	test   %eax,%eax
f011e67d:	75 15                	jne    f011e694 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e67f:	83 ec 0c             	sub    $0xc,%esp
f011e682:	68 60 5e 65 f2       	push   $0xf2655e60
f011e687:	e8 c0 1a ff ff       	call   f011014c <wakeup_all>
f011e68c:	83 c4 10             	add    $0x10,%esp
f011e68f:	e9 5a 01 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e694:	83 ec 08             	sub    $0x8,%esp
f011e697:	68 e8 0a 13 f0       	push   $0xf0130ae8
f011e69c:	ff 75 08             	pushl  0x8(%ebp)
f011e69f:	e8 84 16 00 00       	call   f011fd28 <strcmp>
f011e6a4:	83 c4 10             	add    $0x10,%esp
f011e6a7:	85 c0                	test   %eax,%eax
f011e6a9:	75 17                	jne    f011e6c2 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e6ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e6ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e6b1:	a1 6c 5e 65 f2       	mov    0xf2655e6c,%eax
f011e6b6:	89 c2                	mov    %eax,%edx
f011e6b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e6bb:	89 10                	mov    %edx,(%eax)
f011e6bd:	e9 2c 01 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e6c2:	83 ec 08             	sub    $0x8,%esp
f011e6c5:	68 fd 0a 13 f0       	push   $0xf0130afd
f011e6ca:	ff 75 08             	pushl  0x8(%ebp)
f011e6cd:	e8 56 16 00 00       	call   f011fd28 <strcmp>
f011e6d2:	83 c4 10             	add    $0x10,%esp
f011e6d5:	85 c0                	test   %eax,%eax
f011e6d7:	75 1a                	jne    f011e6f3 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e6d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e6dc:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e6df:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011e6e4:	8b 40 0c             	mov    0xc(%eax),%eax
f011e6e7:	89 c2                	mov    %eax,%edx
f011e6e9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e6ec:	89 10                	mov    %edx,(%eax)
f011e6ee:	e9 fb 00 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e6f3:	83 ec 08             	sub    $0x8,%esp
f011e6f6:	68 13 0b 13 f0       	push   $0xf0130b13
f011e6fb:	ff 75 08             	pushl  0x8(%ebp)
f011e6fe:	e8 25 16 00 00       	call   f011fd28 <strcmp>
f011e703:	83 c4 10             	add    $0x10,%esp
f011e706:	85 c0                	test   %eax,%eax
f011e708:	75 3d                	jne    f011e747 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e70a:	a1 e4 fd 17 f0       	mov    0xf017fde4,%eax
f011e70f:	85 c0                	test   %eax,%eax
f011e711:	74 1f                	je     f011e732 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e713:	c7 05 e4 fd 17 f0 00 	movl   $0x0,0xf017fde4
f011e71a:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e71d:	83 ec 08             	sub    $0x8,%esp
f011e720:	68 28 0b 13 f0       	push   $0xf0130b28
f011e725:	68 c0 5e 65 f2       	push   $0xf2655ec0
f011e72a:	e8 99 17 ff ff       	call   f010fec8 <init_sleeplock>
f011e72f:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e732:	83 ec 0c             	sub    $0xc,%esp
f011e735:	68 c0 5e 65 f2       	push   $0xf2655ec0
f011e73a:	e8 4d 18 ff ff       	call   f010ff8c <acquire_sleeplock>
f011e73f:	83 c4 10             	add    $0x10,%esp
f011e742:	e9 a7 00 00 00       	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e747:	83 ec 08             	sub    $0x8,%esp
f011e74a:	68 38 0b 13 f0       	push   $0xf0130b38
f011e74f:	ff 75 08             	pushl  0x8(%ebp)
f011e752:	e8 d1 15 00 00       	call   f011fd28 <strcmp>
f011e757:	83 c4 10             	add    $0x10,%esp
f011e75a:	85 c0                	test   %eax,%eax
f011e75c:	75 12                	jne    f011e770 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e75e:	83 ec 0c             	sub    $0xc,%esp
f011e761:	68 c0 5e 65 f2       	push   $0xf2655ec0
f011e766:	e8 7b 18 ff ff       	call   f010ffe6 <release_sleeplock>
f011e76b:	83 c4 10             	add    $0x10,%esp
f011e76e:	eb 7e                	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e770:	83 ec 08             	sub    $0x8,%esp
f011e773:	68 4d 0b 13 f0       	push   $0xf0130b4d
f011e778:	ff 75 08             	pushl  0x8(%ebp)
f011e77b:	e8 a8 15 00 00       	call   f011fd28 <strcmp>
f011e780:	83 c4 10             	add    $0x10,%esp
f011e783:	85 c0                	test   %eax,%eax
f011e785:	75 14                	jne    f011e79b <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e787:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e78a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e78d:	a1 40 5f 65 f2       	mov    0xf2655f40,%eax
f011e792:	89 c2                	mov    %eax,%edx
f011e794:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e797:	89 10                	mov    %edx,(%eax)
f011e799:	eb 53                	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e79b:	83 ec 08             	sub    $0x8,%esp
f011e79e:	68 62 0b 13 f0       	push   $0xf0130b62
f011e7a3:	ff 75 08             	pushl  0x8(%ebp)
f011e7a6:	e8 7d 15 00 00       	call   f011fd28 <strcmp>
f011e7ab:	83 c4 10             	add    $0x10,%esp
f011e7ae:	85 c0                	test   %eax,%eax
f011e7b0:	75 13                	jne    f011e7c5 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e7b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e7b5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e7b8:	8b 15 c0 5e 65 f2    	mov    0xf2655ec0,%edx
f011e7be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e7c1:	89 10                	mov    %edx,(%eax)
f011e7c3:	eb 29                	jmp    f011e7ee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e7c5:	83 ec 08             	sub    $0x8,%esp
f011e7c8:	68 73 0b 13 f0       	push   $0xf0130b73
f011e7cd:	ff 75 08             	pushl  0x8(%ebp)
f011e7d0:	e8 53 15 00 00       	call   f011fd28 <strcmp>
f011e7d5:	83 c4 10             	add    $0x10,%esp
f011e7d8:	85 c0                	test   %eax,%eax
f011e7da:	75 12                	jne    f011e7ee <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e7dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e7df:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e7e2:	a1 c4 5f 65 f2       	mov    0xf2655fc4,%eax
f011e7e7:	89 c2                	mov    %eax,%edx
f011e7e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e7ec:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e7ee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e7f2:	79 5b                	jns    f011e84f <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e7f4:	83 ec 08             	sub    $0x8,%esp
f011e7f7:	68 84 0b 13 f0       	push   $0xf0130b84
f011e7fc:	ff 75 08             	pushl  0x8(%ebp)
f011e7ff:	e8 24 15 00 00       	call   f011fd28 <strcmp>
f011e804:	83 c4 10             	add    $0x10,%esp
f011e807:	85 c0                	test   %eax,%eax
f011e809:	75 44                	jne    f011e84f <sys_utilities+0x532>
		{
			switch (value)
f011e80b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e80e:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e811:	74 07                	je     f011e81a <sys_utilities+0x4fd>
f011e813:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e816:	74 19                	je     f011e831 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e818:	eb 35                	jmp    f011e84f <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e81a:	83 ec 0c             	sub    $0xc,%esp
f011e81d:	68 94 0b 13 f0       	push   $0xf0130b94
f011e822:	e8 64 27 fe ff       	call   f0100f8b <cprintf>
f011e827:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e82a:	e8 a4 0d ff ff       	call   f010f5d3 <setPageReplacmentAlgorithmFIFO>
				break;
f011e82f:	eb 1e                	jmp    f011e84f <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e831:	83 ec 0c             	sub    $0xc,%esp
f011e834:	68 04 0c 13 f0       	push   $0xf0130c04
f011e839:	e8 4d 27 fe ff       	call   f0100f8b <cprintf>
f011e83e:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e841:	83 ec 0c             	sub    $0xc,%esp
f011e844:	6a 02                	push   $0x2
f011e846:	e8 45 0d ff ff       	call   f010f590 <setPageReplacmentAlgorithmLRU>
f011e84b:	83 c4 10             	add    $0x10,%esp
				break;
f011e84e:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e84f:	90                   	nop
f011e850:	c9                   	leave  
f011e851:	c3                   	ret    

f011e852 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e852:	55                   	push   %ebp
f011e853:	89 e5                	mov    %esp,%ebp
f011e855:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e858:	8b 45 08             	mov    0x8(%ebp),%eax
f011e85b:	8b 00                	mov    (%eax),%eax
f011e85d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e860:	8b 45 08             	mov    0x8(%ebp),%eax
f011e863:	8b 00                	mov    (%eax),%eax
f011e865:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e868:	eb 52                	jmp    f011e8bc <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e86a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e86d:	8b 00                	mov    (%eax),%eax
f011e86f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e872:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e875:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e878:	75 12                	jne    f011e88c <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e87a:	83 ec 0c             	sub    $0xc,%esp
f011e87d:	68 78 0c 13 f0       	push   $0xf0130c78
f011e882:	e8 04 27 fe ff       	call   f0100f8b <cprintf>
f011e887:	83 c4 10             	add    $0x10,%esp
			break;
f011e88a:	eb 3f                	jmp    f011e8cb <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e88c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e890:	74 38                	je     f011e8ca <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e892:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e895:	8b 00                	mov    (%eax),%eax
f011e897:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e89a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e89d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e8a0:	75 12                	jne    f011e8b4 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e8a2:	83 ec 0c             	sub    $0xc,%esp
f011e8a5:	68 94 0c 13 f0       	push   $0xf0130c94
f011e8aa:	e8 dc 26 fe ff       	call   f0100f8b <cprintf>
f011e8af:	83 c4 10             	add    $0x10,%esp
			break;
f011e8b2:	eb 17                	jmp    f011e8cb <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e8b7:	8b 00                	mov    (%eax),%eax
f011e8b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e8bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e8c0:	74 09                	je     f011e8cb <detect_loop_in_FrameInfo_list+0x79>
f011e8c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e8c6:	75 a2                	jne    f011e86a <detect_loop_in_FrameInfo_list+0x18>
f011e8c8:	eb 01                	jmp    f011e8cb <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e8ca:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e8cb:	83 ec 0c             	sub    $0xc,%esp
f011e8ce:	68 ab 0c 13 f0       	push   $0xf0130cab
f011e8d3:	e8 b3 26 fe ff       	call   f0100f8b <cprintf>
f011e8d8:	83 c4 10             	add    $0x10,%esp
}
f011e8db:	90                   	nop
f011e8dc:	c9                   	leave  
f011e8dd:	c3                   	ret    

f011e8de <scarce_memory>:

void scarce_memory()
{
f011e8de:	55                   	push   %ebp
f011e8df:	89 e5                	mov    %esp,%ebp
f011e8e1:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e8e4:	a1 30 30 ac f0       	mov    0xf0ac3030,%eax
f011e8e9:	ba 64 00 00 00       	mov    $0x64,%edx
f011e8ee:	29 c2                	sub    %eax,%edx
f011e8f0:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f011e8f5:	0f af c2             	imul   %edx,%eax
f011e8f8:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e8fd:	f7 e2                	mul    %edx
f011e8ff:	89 d0                	mov    %edx,%eax
f011e901:	c1 e8 05             	shr    $0x5,%eax
f011e904:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e907:	a1 30 30 ac f0       	mov    0xf0ac3030,%eax
f011e90c:	ba 64 00 00 00       	mov    $0x64,%edx
f011e911:	29 c2                	sub    %eax,%edx
f011e913:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f011e918:	89 d1                	mov    %edx,%ecx
f011e91a:	0f af c8             	imul   %eax,%ecx
f011e91d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e922:	f7 e1                	mul    %ecx
f011e924:	c1 ea 05             	shr    $0x5,%edx
f011e927:	89 d0                	mov    %edx,%eax
f011e929:	c1 e0 02             	shl    $0x2,%eax
f011e92c:	01 d0                	add    %edx,%eax
f011e92e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e935:	01 d0                	add    %edx,%eax
f011e937:	c1 e0 02             	shl    $0x2,%eax
f011e93a:	29 c1                	sub    %eax,%ecx
f011e93c:	89 ca                	mov    %ecx,%edx
f011e93e:	85 d2                	test   %edx,%edx
f011e940:	74 03                	je     f011e945 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e942:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e945:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011e94c:	83 ec 0c             	sub    $0xc,%esp
f011e94f:	68 20 2f ac f0       	push   $0xf0ac2f20
f011e954:	e8 15 13 ff ff       	call   f010fc6e <acquire_spinlock>
f011e959:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011e95c:	a1 0c 2f ac f0       	mov    0xf0ac2f0c,%eax
f011e961:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011e964:	8b 15 f8 30 ac f0    	mov    0xf0ac30f8,%edx
f011e96a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e96d:	29 c2                	sub    %eax,%edx
f011e96f:	89 d0                	mov    %edx,%eax
f011e971:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011e974:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e977:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011e97a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011e97d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e984:	eb 12                	jmp    f011e998 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011e986:	83 ec 0c             	sub    $0xc,%esp
f011e989:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011e98c:	50                   	push   %eax
f011e98d:	e8 20 98 fe ff       	call   f01081b2 <allocate_frame>
f011e992:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e995:	ff 45 f0             	incl   -0x10(%ebp)
f011e998:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e99b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e99e:	76 e6                	jbe    f011e986 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011e9a0:	83 ec 0c             	sub    $0xc,%esp
f011e9a3:	68 20 2f ac f0       	push   $0xf0ac2f20
f011e9a8:	e8 48 13 ff ff       	call   f010fcf5 <release_spinlock>
f011e9ad:	83 c4 10             	add    $0x10,%esp

}
f011e9b0:	90                   	nop
f011e9b1:	c9                   	leave  
f011e9b2:	c3                   	ret    

f011e9b3 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011e9b3:	55                   	push   %ebp
f011e9b4:	89 e5                	mov    %esp,%ebp
f011e9b6:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011e9b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011e9c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011e9c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011e9ce:	e8 0d d0 fe ff       	call   f010b9e0 <get_cpu_proc>
f011e9d3:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011e9d6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e9da:	75 19                	jne    f011e9f5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011e9dc:	68 c5 0c 13 f0       	push   $0xf0130cc5
f011e9e1:	68 13 09 13 f0       	push   $0xf0130913
f011e9e6:	68 79 01 00 00       	push   $0x179
f011e9eb:	68 5b 09 13 f0       	push   $0xf013095b
f011e9f0:	e8 44 19 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011e9f5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e9f9:	0f 85 d6 01 00 00    	jne    f011ebd5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011e9ff:	83 ec 0c             	sub    $0xc,%esp
f011ea02:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ea07:	e8 62 12 ff ff       	call   f010fc6e <acquire_spinlock>
f011ea0c:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ea0f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011ea16:	e9 d2 00 00 00       	jmp    f011eaed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011ea1b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ea22:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011ea27:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ea2a:	c1 e2 04             	shl    $0x4,%edx
f011ea2d:	01 d0                	add    %edx,%eax
f011ea2f:	8b 00                	mov    (%eax),%eax
f011ea31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ea34:	eb 7c                	jmp    f011eab2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011ea36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea39:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ea3f:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ea42:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ea45:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ea4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ea4e:	0f af c2             	imul   %edx,%eax
f011ea51:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ea56:	f7 e2                	mul    %edx
f011ea58:	89 d0                	mov    %edx,%eax
f011ea5a:	c1 e8 05             	shr    $0x5,%eax
f011ea5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ea60:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ea63:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ea69:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ea6c:	89 d1                	mov    %edx,%ecx
f011ea6e:	0f af c8             	imul   %eax,%ecx
f011ea71:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ea76:	f7 e1                	mul    %ecx
f011ea78:	c1 ea 05             	shr    $0x5,%edx
f011ea7b:	89 d0                	mov    %edx,%eax
f011ea7d:	c1 e0 02             	shl    $0x2,%eax
f011ea80:	01 d0                	add    %edx,%eax
f011ea82:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ea89:	01 d0                	add    %edx,%eax
f011ea8b:	c1 e0 02             	shl    $0x2,%eax
f011ea8e:	29 c1                	sub    %eax,%ecx
f011ea90:	89 ca                	mov    %ecx,%edx
f011ea92:	85 d2                	test   %edx,%edx
f011ea94:	74 03                	je     f011ea99 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011ea96:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011ea99:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ea9c:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ea9f:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011eaa4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eaa7:	c1 e2 04             	shl    $0x4,%edx
f011eaaa:	01 d0                	add    %edx,%eax
f011eaac:	8b 40 08             	mov    0x8(%eax),%eax
f011eaaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eab2:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011eab7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eaba:	c1 e2 04             	shl    $0x4,%edx
f011eabd:	01 d0                	add    %edx,%eax
f011eabf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eac3:	74 08                	je     f011eacd <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011eac5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011eac8:	8b 52 08             	mov    0x8(%edx),%edx
f011eacb:	eb 05                	jmp    f011ead2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011eacd:	ba 00 00 00 00       	mov    $0x0,%edx
f011ead2:	89 50 08             	mov    %edx,0x8(%eax)
f011ead5:	8b 40 08             	mov    0x8(%eax),%eax
f011ead8:	85 c0                	test   %eax,%eax
f011eada:	0f 85 56 ff ff ff    	jne    f011ea36 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011eae0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eae4:	0f 85 4c ff ff ff    	jne    f011ea36 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011eaea:	ff 45 e8             	incl   -0x18(%ebp)
f011eaed:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011eaf2:	0f b6 c0             	movzbl %al,%eax
f011eaf5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011eaf8:	0f 8f 1d ff ff ff    	jg     f011ea1b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011eafe:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011eb05:	a1 e0 2e 6c f0       	mov    0xf06c2ee0,%eax
f011eb0a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011eb0d:	eb 1a                	jmp    f011eb29 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011eb0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eb12:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eb18:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011eb1b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011eb1e:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011eb21:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f011eb26:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011eb29:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011eb2d:	74 08                	je     f011eb37 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011eb2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eb32:	8b 40 08             	mov    0x8(%eax),%eax
f011eb35:	eb 05                	jmp    f011eb3c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011eb37:	b8 00 00 00 00       	mov    $0x0,%eax
f011eb3c:	a3 e8 2e 6c f0       	mov    %eax,0xf06c2ee8
f011eb41:	a1 e8 2e 6c f0       	mov    0xf06c2ee8,%eax
f011eb46:	85 c0                	test   %eax,%eax
f011eb48:	75 c5                	jne    f011eb0f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011eb4a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011eb4e:	75 bf                	jne    f011eb0f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011eb50:	83 ec 0c             	sub    $0xc,%esp
f011eb53:	68 60 2e 6c f0       	push   $0xf06c2e60
f011eb58:	e8 98 11 ff ff       	call   f010fcf5 <release_spinlock>
f011eb5d:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011eb60:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011eb64:	0f 84 d4 00 00 00    	je     f011ec3e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011eb6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb6d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eb73:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011eb76:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb79:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb7f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eb82:	0f af c2             	imul   %edx,%eax
f011eb85:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eb8a:	f7 e2                	mul    %edx
f011eb8c:	89 d0                	mov    %edx,%eax
f011eb8e:	c1 e8 05             	shr    $0x5,%eax
f011eb91:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011eb94:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb97:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb9d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eba0:	89 d1                	mov    %edx,%ecx
f011eba2:	0f af c8             	imul   %eax,%ecx
f011eba5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ebaa:	f7 e1                	mul    %ecx
f011ebac:	c1 ea 05             	shr    $0x5,%edx
f011ebaf:	89 d0                	mov    %edx,%eax
f011ebb1:	c1 e0 02             	shl    $0x2,%eax
f011ebb4:	01 d0                	add    %edx,%eax
f011ebb6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ebbd:	01 d0                	add    %edx,%eax
f011ebbf:	c1 e0 02             	shl    $0x2,%eax
f011ebc2:	29 c1                	sub    %eax,%ecx
f011ebc4:	89 ca                	mov    %ecx,%edx
f011ebc6:	85 d2                	test   %edx,%edx
f011ebc8:	74 03                	je     f011ebcd <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011ebca:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ebcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ebd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ebd3:	eb 69                	jmp    f011ec3e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ebd5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ebd8:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ebde:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ebe1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ebe4:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ebea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ebed:	0f af c2             	imul   %edx,%eax
f011ebf0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ebf5:	f7 e2                	mul    %edx
f011ebf7:	89 d0                	mov    %edx,%eax
f011ebf9:	c1 e8 05             	shr    $0x5,%eax
f011ebfc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ebff:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec02:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ec08:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ec0b:	89 d1                	mov    %edx,%ecx
f011ec0d:	0f af c8             	imul   %eax,%ecx
f011ec10:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ec15:	f7 e1                	mul    %ecx
f011ec17:	c1 ea 05             	shr    $0x5,%edx
f011ec1a:	89 d0                	mov    %edx,%eax
f011ec1c:	c1 e0 02             	shl    $0x2,%eax
f011ec1f:	01 d0                	add    %edx,%eax
f011ec21:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec28:	01 d0                	add    %edx,%eax
f011ec2a:	c1 e0 02             	shl    $0x2,%eax
f011ec2d:	29 c1                	sub    %eax,%ecx
f011ec2f:	89 ca                	mov    %ecx,%edx
f011ec31:	85 d2                	test   %edx,%edx
f011ec33:	74 03                	je     f011ec38 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011ec35:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ec38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ec3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011ec3e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ec41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec44:	01 c2                	add    %eax,%edx
f011ec46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec49:	01 d0                	add    %edx,%eax
}
f011ec4b:	c9                   	leave  
f011ec4c:	c3                   	ret    

f011ec4d <schenv>:


void schenv()
{
f011ec4d:	55                   	push   %ebp
f011ec4e:	89 e5                	mov    %esp,%ebp
f011ec50:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011ec53:	c6 05 60 36 ec f0 00 	movb   $0x0,0xf0ec3660
	__ne = NULL;
f011ec5a:	c7 05 4c 33 ac f0 00 	movl   $0x0,0xf0ac334c
f011ec61:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011ec64:	83 ec 0c             	sub    $0xc,%esp
f011ec67:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ec6c:	e8 fd 0f ff ff       	call   f010fc6e <acquire_spinlock>
f011ec71:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ec74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ec7b:	eb 3f                	jmp    f011ecbc <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011ec7d:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011ec82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec85:	c1 e2 04             	shl    $0x4,%edx
f011ec88:	01 d0                	add    %edx,%eax
f011ec8a:	83 ec 0c             	sub    $0xc,%esp
f011ec8d:	50                   	push   %eax
f011ec8e:	e8 ff 62 fe ff       	call   f0104f92 <queue_size>
f011ec93:	83 c4 10             	add    $0x10,%esp
f011ec96:	85 c0                	test   %eax,%eax
f011ec98:	74 1f                	je     f011ecb9 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011ec9a:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011ec9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eca2:	c1 e2 04             	shl    $0x4,%edx
f011eca5:	01 d0                	add    %edx,%eax
f011eca7:	8b 40 04             	mov    0x4(%eax),%eax
f011ecaa:	a3 4c 33 ac f0       	mov    %eax,0xf0ac334c
				__nl = i;
f011ecaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecb2:	a2 60 36 ec f0       	mov    %al,0xf0ec3660
				break;
f011ecb7:	eb 10                	jmp    f011ecc9 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ecb9:	ff 45 f4             	incl   -0xc(%ebp)
f011ecbc:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011ecc1:	0f b6 c0             	movzbl %al,%eax
f011ecc4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ecc7:	7f b4                	jg     f011ec7d <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011ecc9:	83 ec 0c             	sub    $0xc,%esp
f011eccc:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ecd1:	e8 1f 10 ff ff       	call   f010fcf5 <release_spinlock>
f011ecd6:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011ecd9:	e8 02 cd fe ff       	call   f010b9e0 <get_cpu_proc>
f011ecde:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011ece1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ece5:	0f 84 82 00 00 00    	je     f011ed6d <schenv+0x120>
	{
		if (__ne != NULL)
f011eceb:	a1 4c 33 ac f0       	mov    0xf0ac334c,%eax
f011ecf0:	85 c0                	test   %eax,%eax
f011ecf2:	74 49                	je     f011ed3d <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011ecf4:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ecf9:	0f b6 c0             	movzbl %al,%eax
f011ecfc:	8d 50 01             	lea    0x1(%eax),%edx
f011ecff:	a0 60 36 ec f0       	mov    0xf0ec3660,%al
f011ed04:	0f b6 c0             	movzbl %al,%eax
f011ed07:	39 c2                	cmp    %eax,%edx
f011ed09:	7d 62                	jge    f011ed6d <schenv+0x120>
			{
				__ne = cur_env;
f011ed0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed0e:	a3 4c 33 ac f0       	mov    %eax,0xf0ac334c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011ed13:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ed18:	0f b6 c0             	movzbl %al,%eax
f011ed1b:	8a 15 c4 35 ec f0    	mov    0xf0ec35c4,%dl
f011ed21:	0f b6 d2             	movzbl %dl,%edx
f011ed24:	4a                   	dec    %edx
f011ed25:	39 d0                	cmp    %edx,%eax
f011ed27:	7d 08                	jge    f011ed31 <schenv+0xe4>
f011ed29:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ed2e:	40                   	inc    %eax
f011ed2f:	eb 05                	jmp    f011ed36 <schenv+0xe9>
f011ed31:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ed36:	a2 60 36 ec f0       	mov    %al,0xf0ec3660
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011ed3b:	eb 30                	jmp    f011ed6d <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011ed3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed40:	a3 4c 33 ac f0       	mov    %eax,0xf0ac334c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011ed45:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ed4a:	0f b6 c0             	movzbl %al,%eax
f011ed4d:	8a 15 c4 35 ec f0    	mov    0xf0ec35c4,%dl
f011ed53:	0f b6 d2             	movzbl %dl,%edx
f011ed56:	4a                   	dec    %edx
f011ed57:	39 d0                	cmp    %edx,%eax
f011ed59:	7d 08                	jge    f011ed63 <schenv+0x116>
f011ed5b:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ed60:	40                   	inc    %eax
f011ed61:	eb 05                	jmp    f011ed68 <schenv+0x11b>
f011ed63:	a0 41 2e 6c f0       	mov    0xf06c2e41,%al
f011ed68:	a2 60 36 ec f0       	mov    %al,0xf0ec3660
		}
	}
}
f011ed6d:	90                   	nop
f011ed6e:	c9                   	leave  
f011ed6f:	c3                   	ret    

f011ed70 <chksch>:

void chksch(uint8 onoff)
{
f011ed70:	55                   	push   %ebp
f011ed71:	89 e5                	mov    %esp,%ebp
f011ed73:	83 ec 18             	sub    $0x18,%esp
f011ed76:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed79:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ed7c:	e8 91 79 fe ff       	call   f0106712 <isSchedMethodBSD>
f011ed81:	85 c0                	test   %eax,%eax
f011ed83:	74 48                	je     f011edcd <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011ed85:	e8 36 79 fe ff       	call   f01066c0 <get_load_average>
f011ed8a:	a3 e8 35 ec f0       	mov    %eax,0xf0ec35e8
f011ed8f:	a1 e8 35 ec f0       	mov    0xf0ec35e8,%eax
f011ed94:	a3 fc 30 ac f0       	mov    %eax,0xf0ac30fc
		acquire_spinlock(&ProcessQueues.qlock);
f011ed99:	83 ec 0c             	sub    $0xc,%esp
f011ed9c:	68 60 2e 6c f0       	push   $0xf06c2e60
f011eda1:	e8 c8 0e ff ff       	call   f010fc6e <acquire_spinlock>
f011eda6:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011eda9:	a1 ec 2e 6c f0       	mov    0xf06c2eec,%eax
f011edae:	a3 a0 2f ac f0       	mov    %eax,0xf0ac2fa0
		}
		release_spinlock(&ProcessQueues.qlock);
f011edb3:	83 ec 0c             	sub    $0xc,%esp
f011edb6:	68 60 2e 6c f0       	push   $0xf06c2e60
f011edbb:	e8 35 0f ff ff       	call   f010fcf5 <release_spinlock>
f011edc0:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011edc3:	c7 05 5c 33 ac f0 01 	movl   $0x1,0xf0ac335c
f011edca:	00 00 00 
	}
	__chkstatus = onoff;
f011edcd:	8a 45 f4             	mov    -0xc(%ebp),%al
f011edd0:	a2 48 33 ac f0       	mov    %al,0xf0ac3348
}
f011edd5:	90                   	nop
f011edd6:	c9                   	leave  
f011edd7:	c3                   	ret    

f011edd8 <chk1>:
void chk1()
{
f011edd8:	55                   	push   %ebp
f011edd9:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011eddb:	90                   	nop
f011eddc:	5d                   	pop    %ebp
f011eddd:	c3                   	ret    

f011edde <chk2>:
void chk2(struct Env* __se)
{
f011edde:	55                   	push   %ebp
f011eddf:	89 e5                	mov    %esp,%ebp
f011ede1:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011ede4:	a0 48 33 ac f0       	mov    0xf0ac3348,%al
f011ede9:	84 c0                	test   %al,%al
f011edeb:	0f 84 59 03 00 00    	je     f011f14a <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011edf1:	e8 1c 79 fe ff       	call   f0106712 <isSchedMethodBSD>
f011edf6:	85 c0                	test   %eax,%eax
f011edf8:	0f 84 4d 03 00 00    	je     f011f14b <chk2+0x36d>
	{
		__nla = get_load_average();
f011edfe:	e8 bd 78 fe ff       	call   f01066c0 <get_load_average>
f011ee03:	a3 34 30 ac f0       	mov    %eax,0xf0ac3034
		acquire_spinlock(&ProcessQueues.qlock);
f011ee08:	83 ec 0c             	sub    $0xc,%esp
f011ee0b:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ee10:	e8 59 0e ff ff       	call   f010fc6e <acquire_spinlock>
f011ee15:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011ee18:	a1 ec 2e 6c f0       	mov    0xf06c2eec,%eax
f011ee1d:	a3 50 33 ac f0       	mov    %eax,0xf0ac3350
		}
		release_spinlock(&ProcessQueues.qlock);
f011ee22:	83 ec 0c             	sub    $0xc,%esp
f011ee25:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ee2a:	e8 c6 0e ff ff       	call   f010fcf5 <release_spinlock>
f011ee2f:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011ee32:	a1 5c 33 ac f0       	mov    0xf0ac335c,%eax
f011ee37:	85 c0                	test   %eax,%eax
f011ee39:	74 72                	je     f011eead <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011ee3b:	83 ec 0c             	sub    $0xc,%esp
f011ee3e:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ee43:	e8 26 0e ff ff       	call   f010fc6e <acquire_spinlock>
f011ee48:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011ee4b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ee4f:	0f 95 c0             	setne  %al
f011ee52:	0f b6 c0             	movzbl %al,%eax
f011ee55:	a3 14 35 ac f0       	mov    %eax,0xf0ac3514
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ee5a:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011ee5f:	0f b6 c0             	movzbl %al,%eax
f011ee62:	48                   	dec    %eax
f011ee63:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ee66:	eb 20                	jmp    f011ee88 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011ee68:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011ee6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ee70:	c1 e2 04             	shl    $0x4,%edx
f011ee73:	01 d0                	add    %edx,%eax
f011ee75:	8b 40 0c             	mov    0xc(%eax),%eax
f011ee78:	8b 15 14 35 ac f0    	mov    0xf0ac3514,%edx
f011ee7e:	01 d0                	add    %edx,%eax
f011ee80:	a3 14 35 ac f0       	mov    %eax,0xf0ac3514
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ee85:	ff 4d f4             	decl   -0xc(%ebp)
f011ee88:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ee8c:	79 da                	jns    f011ee68 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011ee8e:	c7 05 5c 33 ac f0 00 	movl   $0x0,0xf0ac335c
f011ee95:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011ee98:	83 ec 0c             	sub    $0xc,%esp
f011ee9b:	68 60 2e 6c f0       	push   $0xf06c2e60
f011eea0:	e8 50 0e ff ff       	call   f010fcf5 <release_spinlock>
f011eea5:	83 c4 10             	add    $0x10,%esp
f011eea8:	e9 91 02 00 00       	jmp    f011f13e <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011eead:	8b 15 a0 2f ac f0    	mov    0xf0ac2fa0,%edx
f011eeb3:	a1 50 33 ac f0       	mov    0xf0ac3350,%eax
f011eeb8:	39 c2                	cmp    %eax,%edx
f011eeba:	74 63                	je     f011ef1f <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011eebc:	83 ec 0c             	sub    $0xc,%esp
f011eebf:	68 60 2e 6c f0       	push   $0xf06c2e60
f011eec4:	e8 a5 0d ff ff       	call   f010fc6e <acquire_spinlock>
f011eec9:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011eecc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011eed0:	0f 95 c0             	setne  %al
f011eed3:	0f b6 c0             	movzbl %al,%eax
f011eed6:	a3 14 35 ac f0       	mov    %eax,0xf0ac3514
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011eedb:	a0 c4 35 ec f0       	mov    0xf0ec35c4,%al
f011eee0:	0f b6 c0             	movzbl %al,%eax
f011eee3:	48                   	dec    %eax
f011eee4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011eee7:	eb 20                	jmp    f011ef09 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011eee9:	a1 f0 2e 6c f0       	mov    0xf06c2ef0,%eax
f011eeee:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011eef1:	c1 e2 04             	shl    $0x4,%edx
f011eef4:	01 d0                	add    %edx,%eax
f011eef6:	8b 40 0c             	mov    0xc(%eax),%eax
f011eef9:	8b 15 14 35 ac f0    	mov    0xf0ac3514,%edx
f011eeff:	01 d0                	add    %edx,%eax
f011ef01:	a3 14 35 ac f0       	mov    %eax,0xf0ac3514
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ef06:	ff 4d f0             	decl   -0x10(%ebp)
f011ef09:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ef0d:	79 da                	jns    f011eee9 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011ef0f:	83 ec 0c             	sub    $0xc,%esp
f011ef12:	68 60 2e 6c f0       	push   $0xf06c2e60
f011ef17:	e8 d9 0d ff ff       	call   f010fcf5 <release_spinlock>
f011ef1c:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011ef1f:	e8 35 77 fe ff       	call   f0106659 <timer_ticks>
f011ef24:	6a 00                	push   $0x0
f011ef26:	68 e8 03 00 00       	push   $0x3e8
f011ef2b:	52                   	push   %edx
f011ef2c:	50                   	push   %eax
f011ef2d:	e8 ee 31 00 00       	call   f0122120 <__moddi3>
f011ef32:	83 c4 10             	add    $0x10,%esp
f011ef35:	09 d0                	or     %edx,%eax
f011ef37:	85 c0                	test   %eax,%eax
f011ef39:	75 32                	jne    f011ef6d <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011ef3b:	8b 15 fc 30 ac f0    	mov    0xf0ac30fc,%edx
f011ef41:	a1 34 30 ac f0       	mov    0xf0ac3034,%eax
f011ef46:	39 c2                	cmp    %eax,%edx
f011ef48:	75 19                	jne    f011ef63 <chk2+0x185>
f011ef4a:	68 d5 0c 13 f0       	push   $0xf0130cd5
f011ef4f:	68 13 09 13 f0       	push   $0xf0130913
f011ef54:	68 35 02 00 00       	push   $0x235
f011ef59:	68 5b 09 13 f0       	push   $0xf013095b
f011ef5e:	e8 66 14 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011ef63:	a1 34 30 ac f0       	mov    0xf0ac3034,%eax
f011ef68:	a3 fc 30 ac f0       	mov    %eax,0xf0ac30fc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011ef6d:	e8 e7 76 fe ff       	call   f0106659 <timer_ticks>
f011ef72:	6a 00                	push   $0x0
f011ef74:	6a 64                	push   $0x64
f011ef76:	52                   	push   %edx
f011ef77:	50                   	push   %eax
f011ef78:	e8 a3 31 00 00       	call   f0122120 <__moddi3>
f011ef7d:	83 c4 10             	add    $0x10,%esp
f011ef80:	09 d0                	or     %edx,%eax
f011ef82:	85 c0                	test   %eax,%eax
f011ef84:	0f 85 b4 01 00 00    	jne    f011f13e <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011ef8a:	8b 0d e8 35 ec f0    	mov    0xf0ec35e8,%ecx
f011ef90:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ef95:	f7 e9                	imul   %ecx
f011ef97:	c1 fa 05             	sar    $0x5,%edx
f011ef9a:	89 c8                	mov    %ecx,%eax
f011ef9c:	c1 f8 1f             	sar    $0x1f,%eax
f011ef9f:	29 c2                	sub    %eax,%edx
f011efa1:	89 d0                	mov    %edx,%eax
f011efa3:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011efa6:	8b 0d e8 35 ec f0    	mov    0xf0ec35e8,%ecx
f011efac:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011efb1:	f7 e9                	imul   %ecx
f011efb3:	c1 fa 05             	sar    $0x5,%edx
f011efb6:	89 c8                	mov    %ecx,%eax
f011efb8:	c1 f8 1f             	sar    $0x1f,%eax
f011efbb:	29 c2                	sub    %eax,%edx
f011efbd:	89 d0                	mov    %edx,%eax
f011efbf:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011efc2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011efc5:	89 d0                	mov    %edx,%eax
f011efc7:	c1 e0 02             	shl    $0x2,%eax
f011efca:	01 d0                	add    %edx,%eax
f011efcc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011efd3:	01 d0                	add    %edx,%eax
f011efd5:	c1 e0 02             	shl    $0x2,%eax
f011efd8:	29 c1                	sub    %eax,%ecx
f011efda:	89 c8                	mov    %ecx,%eax
f011efdc:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011efdf:	8b 0d 34 30 ac f0    	mov    0xf0ac3034,%ecx
f011efe5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011efea:	f7 e9                	imul   %ecx
f011efec:	c1 fa 05             	sar    $0x5,%edx
f011efef:	89 c8                	mov    %ecx,%eax
f011eff1:	c1 f8 1f             	sar    $0x1f,%eax
f011eff4:	29 c2                	sub    %eax,%edx
f011eff6:	89 d0                	mov    %edx,%eax
f011eff8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011effb:	8b 0d 34 30 ac f0    	mov    0xf0ac3034,%ecx
f011f001:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f006:	f7 e9                	imul   %ecx
f011f008:	c1 fa 05             	sar    $0x5,%edx
f011f00b:	89 c8                	mov    %ecx,%eax
f011f00d:	c1 f8 1f             	sar    $0x1f,%eax
f011f010:	29 c2                	sub    %eax,%edx
f011f012:	89 d0                	mov    %edx,%eax
f011f014:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f017:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f01a:	89 d0                	mov    %edx,%eax
f011f01c:	c1 e0 02             	shl    $0x2,%eax
f011f01f:	01 d0                	add    %edx,%eax
f011f021:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f028:	01 d0                	add    %edx,%eax
f011f02a:	c1 e0 02             	shl    $0x2,%eax
f011f02d:	29 c1                	sub    %eax,%ecx
f011f02f:	89 c8                	mov    %ecx,%eax
f011f031:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f034:	8b 15 50 33 ac f0    	mov    0xf0ac3350,%edx
f011f03a:	a1 a0 2f ac f0       	mov    0xf0ac2fa0,%eax
f011f03f:	39 c2                	cmp    %eax,%edx
f011f041:	0f 85 ed 00 00 00    	jne    f011f134 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f047:	a1 14 35 ac f0       	mov    0xf0ac3514,%eax
f011f04c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f04f:	7e 5b                	jle    f011f0ac <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f051:	a1 14 35 ac f0       	mov    0xf0ac3514,%eax
f011f056:	83 ec 08             	sub    $0x8,%esp
f011f059:	ff 75 e0             	pushl  -0x20(%ebp)
f011f05c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f05f:	ff 75 e8             	pushl  -0x18(%ebp)
f011f062:	ff 75 ec             	pushl  -0x14(%ebp)
f011f065:	50                   	push   %eax
f011f066:	68 e8 0c 13 f0       	push   $0xf0130ce8
f011f06b:	e8 1b 1f fe ff       	call   f0100f8b <cprintf>
f011f070:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f073:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f076:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f079:	0f 8f b5 00 00 00    	jg     f011f134 <chk2+0x356>
f011f07f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f082:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f085:	75 0c                	jne    f011f093 <chk2+0x2b5>
f011f087:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f08a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f08d:	0f 8d a1 00 00 00    	jge    f011f134 <chk2+0x356>
f011f093:	68 30 0d 13 f0       	push   $0xf0130d30
f011f098:	68 13 09 13 f0       	push   $0xf0130913
f011f09d:	68 4a 02 00 00       	push   $0x24a
f011f0a2:	68 5b 09 13 f0       	push   $0xf013095b
f011f0a7:	e8 1d 13 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f0ac:	a1 14 35 ac f0       	mov    0xf0ac3514,%eax
f011f0b1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0b4:	7d 53                	jge    f011f109 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f0b6:	a1 14 35 ac f0       	mov    0xf0ac3514,%eax
f011f0bb:	83 ec 08             	sub    $0x8,%esp
f011f0be:	ff 75 e0             	pushl  -0x20(%ebp)
f011f0c1:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f0c4:	ff 75 e8             	pushl  -0x18(%ebp)
f011f0c7:	ff 75 ec             	pushl  -0x14(%ebp)
f011f0ca:	50                   	push   %eax
f011f0cb:	68 70 0d 13 f0       	push   $0xf0130d70
f011f0d0:	e8 b6 1e fe ff       	call   f0100f8b <cprintf>
f011f0d5:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f0d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f0db:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0de:	7c 54                	jl     f011f134 <chk2+0x356>
f011f0e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f0e3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0e6:	75 08                	jne    f011f0f0 <chk2+0x312>
f011f0e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f0eb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f0ee:	7e 44                	jle    f011f134 <chk2+0x356>
f011f0f0:	68 b8 0d 13 f0       	push   $0xf0130db8
f011f0f5:	68 13 09 13 f0       	push   $0xf0130913
f011f0fa:	68 50 02 00 00       	push   $0x250
f011f0ff:	68 5b 09 13 f0       	push   $0xf013095b
f011f104:	e8 c0 12 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f109:	a1 14 35 ac f0       	mov    0xf0ac3514,%eax
f011f10e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f111:	75 21                	jne    f011f134 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f113:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f116:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f119:	74 19                	je     f011f134 <chk2+0x356>
f011f11b:	68 f8 0d 13 f0       	push   $0xf0130df8
f011f120:	68 13 09 13 f0       	push   $0xf0130913
f011f125:	68 54 02 00 00       	push   $0x254
f011f12a:	68 5b 09 13 f0       	push   $0xf013095b
f011f12f:	e8 95 12 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f134:	a1 34 30 ac f0       	mov    0xf0ac3034,%eax
f011f139:	a3 e8 35 ec f0       	mov    %eax,0xf0ec35e8
			}
		}
		__pnexit = __nnexit;
f011f13e:	a1 50 33 ac f0       	mov    0xf0ac3350,%eax
f011f143:	a3 a0 2f ac f0       	mov    %eax,0xf0ac2fa0
f011f148:	eb 01                	jmp    f011f14b <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f14a:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f14b:	c9                   	leave  
f011f14c:	c3                   	ret    

f011f14d <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f14d:	55                   	push   %ebp
f011f14e:	89 e5                	mov    %esp,%ebp
f011f150:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f153:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f15a:	eb 40                	jmp    f011f19c <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f15c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f15f:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f165:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011f16a:	83 ec 08             	sub    $0x8,%esp
f011f16d:	52                   	push   %edx
f011f16e:	50                   	push   %eax
f011f16f:	e8 af 01 00 00       	call   f011f323 <check_va2pa>
f011f174:	83 c4 10             	add    $0x10,%esp
f011f177:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f17a:	74 19                	je     f011f195 <check_boot_pgdir+0x48>
f011f17c:	68 0c 0e 13 f0       	push   $0xf0130e0c
f011f181:	68 13 09 13 f0       	push   $0xf0130913
f011f186:	68 9b 02 00 00       	push   $0x29b
f011f18b:	68 5b 09 13 f0       	push   $0xf013095b
f011f190:	e8 a4 11 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f195:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f19c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f19f:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f1a5:	a1 20 35 ec f0       	mov    0xf0ec3520,%eax
f011f1aa:	39 c2                	cmp    %eax,%edx
f011f1ac:	72 ae                	jb     f011f15c <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f1ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f1b5:	e9 81 00 00 00       	jmp    f011f23b <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f1ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f1bd:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f1c2:	85 c0                	test   %eax,%eax
f011f1c4:	74 6d                	je     f011f233 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f1c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f1c9:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f1cf:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011f1d4:	83 ec 08             	sub    $0x8,%esp
f011f1d7:	52                   	push   %edx
f011f1d8:	50                   	push   %eax
f011f1d9:	e8 45 01 00 00       	call   f011f323 <check_va2pa>
f011f1de:	83 c4 10             	add    $0x10,%esp
f011f1e1:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f011f1e8:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f1ef:	77 17                	ja     f011f208 <check_boot_pgdir+0xbb>
f011f1f1:	ff 75 f0             	pushl  -0x10(%ebp)
f011f1f4:	68 44 0e 13 f0       	push   $0xf0130e44
f011f1f9:	68 a9 02 00 00       	push   $0x2a9
f011f1fe:	68 5b 09 13 f0       	push   $0xf013095b
f011f203:	e8 31 11 fe ff       	call   f0100339 <_panic>
f011f208:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f20b:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f211:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f214:	01 ca                	add    %ecx,%edx
f011f216:	39 d0                	cmp    %edx,%eax
f011f218:	74 1a                	je     f011f234 <check_boot_pgdir+0xe7>
f011f21a:	68 78 0e 13 f0       	push   $0xf0130e78
f011f21f:	68 13 09 13 f0       	push   $0xf0130913
f011f224:	68 a9 02 00 00       	push   $0x2a9
f011f229:	68 5b 09 13 f0       	push   $0xf013095b
f011f22e:	e8 06 11 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f233:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f234:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f23b:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f242:	0f 86 72 ff ff ff    	jbe    f011f1ba <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f248:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f24f:	e9 af 00 00 00       	jmp    f011f303 <check_boot_pgdir+0x1b6>
		switch (i) {
f011f254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f257:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f25c:	74 11                	je     f011f26f <check_boot_pgdir+0x122>
f011f25e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f263:	72 36                	jb     f011f29b <check_boot_pgdir+0x14e>
f011f265:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f26a:	83 f8 02             	cmp    $0x2,%eax
f011f26d:	77 2c                	ja     f011f29b <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f26f:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011f274:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f277:	c1 e2 02             	shl    $0x2,%edx
f011f27a:	01 d0                	add    %edx,%eax
f011f27c:	8b 00                	mov    (%eax),%eax
f011f27e:	85 c0                	test   %eax,%eax
f011f280:	75 7a                	jne    f011f2fc <check_boot_pgdir+0x1af>
f011f282:	68 fe 0e 13 f0       	push   $0xf0130efe
f011f287:	68 13 09 13 f0       	push   $0xf0130913
f011f28c:	68 b4 02 00 00       	push   $0x2b4
f011f291:	68 5b 09 13 f0       	push   $0xf013095b
f011f296:	e8 9e 10 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f29b:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f2a2:	76 2c                	jbe    f011f2d0 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f2a4:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011f2a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f2ac:	c1 e2 02             	shl    $0x2,%edx
f011f2af:	01 d0                	add    %edx,%eax
f011f2b1:	8b 00                	mov    (%eax),%eax
f011f2b3:	85 c0                	test   %eax,%eax
f011f2b5:	75 48                	jne    f011f2ff <check_boot_pgdir+0x1b2>
f011f2b7:	68 fe 0e 13 f0       	push   $0xf0130efe
f011f2bc:	68 13 09 13 f0       	push   $0xf0130913
f011f2c1:	68 b8 02 00 00       	push   $0x2b8
f011f2c6:	68 5b 09 13 f0       	push   $0xf013095b
f011f2cb:	e8 69 10 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f2d0:	a1 24 35 ec f0       	mov    0xf0ec3524,%eax
f011f2d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f2d8:	c1 e2 02             	shl    $0x2,%edx
f011f2db:	01 d0                	add    %edx,%eax
f011f2dd:	8b 00                	mov    (%eax),%eax
f011f2df:	85 c0                	test   %eax,%eax
f011f2e1:	74 1c                	je     f011f2ff <check_boot_pgdir+0x1b2>
f011f2e3:	68 14 0f 13 f0       	push   $0xf0130f14
f011f2e8:	68 13 09 13 f0       	push   $0xf0130913
f011f2ed:	68 ba 02 00 00       	push   $0x2ba
f011f2f2:	68 5b 09 13 f0       	push   $0xf013095b
f011f2f7:	e8 3d 10 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f2fc:	90                   	nop
f011f2fd:	eb 01                	jmp    f011f300 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f2ff:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f300:	ff 45 f4             	incl   -0xc(%ebp)
f011f303:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f30a:	0f 86 44 ff ff ff    	jbe    f011f254 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f310:	83 ec 0c             	sub    $0xc,%esp
f011f313:	68 30 0f 13 f0       	push   $0xf0130f30
f011f318:	e8 6e 1c fe ff       	call   f0100f8b <cprintf>
f011f31d:	83 c4 10             	add    $0x10,%esp
}
f011f320:	90                   	nop
f011f321:	c9                   	leave  
f011f322:	c3                   	ret    

f011f323 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f323:	55                   	push   %ebp
f011f324:	89 e5                	mov    %esp,%ebp
f011f326:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f329:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f32c:	c1 e8 16             	shr    $0x16,%eax
f011f32f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f336:	8b 45 08             	mov    0x8(%ebp),%eax
f011f339:	01 d0                	add    %edx,%eax
f011f33b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f33e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f341:	8b 00                	mov    (%eax),%eax
f011f343:	83 e0 01             	and    $0x1,%eax
f011f346:	85 c0                	test   %eax,%eax
f011f348:	75 0a                	jne    f011f354 <check_va2pa+0x31>
		return ~0;
f011f34a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f34f:	e9 87 00 00 00       	jmp    f011f3db <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f354:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f357:	8b 00                	mov    (%eax),%eax
f011f359:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f35e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f364:	c1 e8 0c             	shr    $0xc,%eax
f011f367:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f36a:	a1 f8 30 ac f0       	mov    0xf0ac30f8,%eax
f011f36f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f372:	72 17                	jb     f011f38b <check_va2pa+0x68>
f011f374:	ff 75 f0             	pushl  -0x10(%ebp)
f011f377:	68 54 0f 13 f0       	push   $0xf0130f54
f011f37c:	68 d0 02 00 00       	push   $0x2d0
f011f381:	68 5b 09 13 f0       	push   $0xf013095b
f011f386:	e8 ae 0f fe ff       	call   f0100339 <_panic>
f011f38b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f38e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f393:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f396:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f399:	c1 e8 0c             	shr    $0xc,%eax
f011f39c:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f3a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f3a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f3ab:	01 d0                	add    %edx,%eax
f011f3ad:	8b 00                	mov    (%eax),%eax
f011f3af:	83 e0 01             	and    $0x1,%eax
f011f3b2:	85 c0                	test   %eax,%eax
f011f3b4:	75 07                	jne    f011f3bd <check_va2pa+0x9a>
		return ~0;
f011f3b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f3bb:	eb 1e                	jmp    f011f3db <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f3bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f3c0:	c1 e8 0c             	shr    $0xc,%eax
f011f3c3:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f3c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f3cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f3d2:	01 d0                	add    %edx,%eax
f011f3d4:	8b 00                	mov    (%eax),%eax
f011f3d6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f3db:	c9                   	leave  
f011f3dc:	c3                   	ret    

f011f3dd <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f3dd:	55                   	push   %ebp
f011f3de:	89 e5                	mov    %esp,%ebp
f011f3e0:	53                   	push   %ebx
f011f3e1:	83 ec 14             	sub    $0x14,%esp
f011f3e4:	8b 45 10             	mov    0x10(%ebp),%eax
f011f3e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f3ea:	8b 45 14             	mov    0x14(%ebp),%eax
f011f3ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f3f0:	8b 45 18             	mov    0x18(%ebp),%eax
f011f3f3:	ba 00 00 00 00       	mov    $0x0,%edx
f011f3f8:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f3fb:	77 55                	ja     f011f452 <printnum+0x75>
f011f3fd:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f400:	72 05                	jb     f011f407 <printnum+0x2a>
f011f402:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f405:	77 4b                	ja     f011f452 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f407:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f40a:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f40d:	8b 45 18             	mov    0x18(%ebp),%eax
f011f410:	ba 00 00 00 00       	mov    $0x0,%edx
f011f415:	52                   	push   %edx
f011f416:	50                   	push   %eax
f011f417:	ff 75 f4             	pushl  -0xc(%ebp)
f011f41a:	ff 75 f0             	pushl  -0x10(%ebp)
f011f41d:	e8 96 2e 00 00       	call   f01222b8 <__udivdi3>
f011f422:	83 c4 10             	add    $0x10,%esp
f011f425:	83 ec 04             	sub    $0x4,%esp
f011f428:	ff 75 20             	pushl  0x20(%ebp)
f011f42b:	53                   	push   %ebx
f011f42c:	ff 75 18             	pushl  0x18(%ebp)
f011f42f:	52                   	push   %edx
f011f430:	50                   	push   %eax
f011f431:	ff 75 0c             	pushl  0xc(%ebp)
f011f434:	ff 75 08             	pushl  0x8(%ebp)
f011f437:	e8 a1 ff ff ff       	call   f011f3dd <printnum>
f011f43c:	83 c4 20             	add    $0x20,%esp
f011f43f:	eb 1a                	jmp    f011f45b <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f441:	83 ec 08             	sub    $0x8,%esp
f011f444:	ff 75 0c             	pushl  0xc(%ebp)
f011f447:	ff 75 20             	pushl  0x20(%ebp)
f011f44a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f44d:	ff d0                	call   *%eax
f011f44f:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f452:	ff 4d 1c             	decl   0x1c(%ebp)
f011f455:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f459:	7f e6                	jg     f011f441 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f45b:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f45e:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f463:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f466:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f469:	53                   	push   %ebx
f011f46a:	51                   	push   %ecx
f011f46b:	52                   	push   %edx
f011f46c:	50                   	push   %eax
f011f46d:	e8 56 2f 00 00       	call   f01223c8 <__umoddi3>
f011f472:	83 c4 10             	add    $0x10,%esp
f011f475:	05 b4 11 13 f0       	add    $0xf01311b4,%eax
f011f47a:	8a 00                	mov    (%eax),%al
f011f47c:	0f be c0             	movsbl %al,%eax
f011f47f:	83 ec 08             	sub    $0x8,%esp
f011f482:	ff 75 0c             	pushl  0xc(%ebp)
f011f485:	50                   	push   %eax
f011f486:	8b 45 08             	mov    0x8(%ebp),%eax
f011f489:	ff d0                	call   *%eax
f011f48b:	83 c4 10             	add    $0x10,%esp
}
f011f48e:	90                   	nop
f011f48f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f492:	c9                   	leave  
f011f493:	c3                   	ret    

f011f494 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f494:	55                   	push   %ebp
f011f495:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f497:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f49b:	7e 1c                	jle    f011f4b9 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f49d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4a0:	8b 00                	mov    (%eax),%eax
f011f4a2:	8d 50 08             	lea    0x8(%eax),%edx
f011f4a5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4a8:	89 10                	mov    %edx,(%eax)
f011f4aa:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4ad:	8b 00                	mov    (%eax),%eax
f011f4af:	83 e8 08             	sub    $0x8,%eax
f011f4b2:	8b 50 04             	mov    0x4(%eax),%edx
f011f4b5:	8b 00                	mov    (%eax),%eax
f011f4b7:	eb 40                	jmp    f011f4f9 <getuint+0x65>
	else if (lflag)
f011f4b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f4bd:	74 1e                	je     f011f4dd <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f4bf:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4c2:	8b 00                	mov    (%eax),%eax
f011f4c4:	8d 50 04             	lea    0x4(%eax),%edx
f011f4c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4ca:	89 10                	mov    %edx,(%eax)
f011f4cc:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4cf:	8b 00                	mov    (%eax),%eax
f011f4d1:	83 e8 04             	sub    $0x4,%eax
f011f4d4:	8b 00                	mov    (%eax),%eax
f011f4d6:	ba 00 00 00 00       	mov    $0x0,%edx
f011f4db:	eb 1c                	jmp    f011f4f9 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f4dd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4e0:	8b 00                	mov    (%eax),%eax
f011f4e2:	8d 50 04             	lea    0x4(%eax),%edx
f011f4e5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4e8:	89 10                	mov    %edx,(%eax)
f011f4ea:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4ed:	8b 00                	mov    (%eax),%eax
f011f4ef:	83 e8 04             	sub    $0x4,%eax
f011f4f2:	8b 00                	mov    (%eax),%eax
f011f4f4:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f4f9:	5d                   	pop    %ebp
f011f4fa:	c3                   	ret    

f011f4fb <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f4fb:	55                   	push   %ebp
f011f4fc:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f4fe:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f502:	7e 1c                	jle    f011f520 <getint+0x25>
		return va_arg(*ap, long long);
f011f504:	8b 45 08             	mov    0x8(%ebp),%eax
f011f507:	8b 00                	mov    (%eax),%eax
f011f509:	8d 50 08             	lea    0x8(%eax),%edx
f011f50c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f50f:	89 10                	mov    %edx,(%eax)
f011f511:	8b 45 08             	mov    0x8(%ebp),%eax
f011f514:	8b 00                	mov    (%eax),%eax
f011f516:	83 e8 08             	sub    $0x8,%eax
f011f519:	8b 50 04             	mov    0x4(%eax),%edx
f011f51c:	8b 00                	mov    (%eax),%eax
f011f51e:	eb 38                	jmp    f011f558 <getint+0x5d>
	else if (lflag)
f011f520:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f524:	74 1a                	je     f011f540 <getint+0x45>
		return va_arg(*ap, long);
f011f526:	8b 45 08             	mov    0x8(%ebp),%eax
f011f529:	8b 00                	mov    (%eax),%eax
f011f52b:	8d 50 04             	lea    0x4(%eax),%edx
f011f52e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f531:	89 10                	mov    %edx,(%eax)
f011f533:	8b 45 08             	mov    0x8(%ebp),%eax
f011f536:	8b 00                	mov    (%eax),%eax
f011f538:	83 e8 04             	sub    $0x4,%eax
f011f53b:	8b 00                	mov    (%eax),%eax
f011f53d:	99                   	cltd   
f011f53e:	eb 18                	jmp    f011f558 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f540:	8b 45 08             	mov    0x8(%ebp),%eax
f011f543:	8b 00                	mov    (%eax),%eax
f011f545:	8d 50 04             	lea    0x4(%eax),%edx
f011f548:	8b 45 08             	mov    0x8(%ebp),%eax
f011f54b:	89 10                	mov    %edx,(%eax)
f011f54d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f550:	8b 00                	mov    (%eax),%eax
f011f552:	83 e8 04             	sub    $0x4,%eax
f011f555:	8b 00                	mov    (%eax),%eax
f011f557:	99                   	cltd   
}
f011f558:	5d                   	pop    %ebp
f011f559:	c3                   	ret    

f011f55a <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f55a:	55                   	push   %ebp
f011f55b:	89 e5                	mov    %esp,%ebp
f011f55d:	56                   	push   %esi
f011f55e:	53                   	push   %ebx
f011f55f:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f562:	eb 17                	jmp    f011f57b <vprintfmt+0x21>
			if (ch == '\0')
f011f564:	85 db                	test   %ebx,%ebx
f011f566:	0f 84 c1 03 00 00    	je     f011f92d <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f56c:	83 ec 08             	sub    $0x8,%esp
f011f56f:	ff 75 0c             	pushl  0xc(%ebp)
f011f572:	53                   	push   %ebx
f011f573:	8b 45 08             	mov    0x8(%ebp),%eax
f011f576:	ff d0                	call   *%eax
f011f578:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f57b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f57e:	8d 50 01             	lea    0x1(%eax),%edx
f011f581:	89 55 10             	mov    %edx,0x10(%ebp)
f011f584:	8a 00                	mov    (%eax),%al
f011f586:	0f b6 d8             	movzbl %al,%ebx
f011f589:	83 fb 25             	cmp    $0x25,%ebx
f011f58c:	75 d6                	jne    f011f564 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f58e:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f592:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f599:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f5a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f5a7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f5ae:	8b 45 10             	mov    0x10(%ebp),%eax
f011f5b1:	8d 50 01             	lea    0x1(%eax),%edx
f011f5b4:	89 55 10             	mov    %edx,0x10(%ebp)
f011f5b7:	8a 00                	mov    (%eax),%al
f011f5b9:	0f b6 d8             	movzbl %al,%ebx
f011f5bc:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f5bf:	83 f8 5b             	cmp    $0x5b,%eax
f011f5c2:	0f 87 3d 03 00 00    	ja     f011f905 <vprintfmt+0x3ab>
f011f5c8:	8b 04 85 d8 11 13 f0 	mov    -0xfecee28(,%eax,4),%eax
f011f5cf:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f5d1:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f5d5:	eb d7                	jmp    f011f5ae <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f5d7:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f5db:	eb d1                	jmp    f011f5ae <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f5dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f5e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f5e7:	89 d0                	mov    %edx,%eax
f011f5e9:	c1 e0 02             	shl    $0x2,%eax
f011f5ec:	01 d0                	add    %edx,%eax
f011f5ee:	01 c0                	add    %eax,%eax
f011f5f0:	01 d8                	add    %ebx,%eax
f011f5f2:	83 e8 30             	sub    $0x30,%eax
f011f5f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f5f8:	8b 45 10             	mov    0x10(%ebp),%eax
f011f5fb:	8a 00                	mov    (%eax),%al
f011f5fd:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011f600:	83 fb 2f             	cmp    $0x2f,%ebx
f011f603:	7e 3e                	jle    f011f643 <vprintfmt+0xe9>
f011f605:	83 fb 39             	cmp    $0x39,%ebx
f011f608:	7f 39                	jg     f011f643 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f60a:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011f60d:	eb d5                	jmp    f011f5e4 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011f60f:	8b 45 14             	mov    0x14(%ebp),%eax
f011f612:	83 c0 04             	add    $0x4,%eax
f011f615:	89 45 14             	mov    %eax,0x14(%ebp)
f011f618:	8b 45 14             	mov    0x14(%ebp),%eax
f011f61b:	83 e8 04             	sub    $0x4,%eax
f011f61e:	8b 00                	mov    (%eax),%eax
f011f620:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f623:	eb 1f                	jmp    f011f644 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f625:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f629:	79 83                	jns    f011f5ae <vprintfmt+0x54>
				width = 0;
f011f62b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f632:	e9 77 ff ff ff       	jmp    f011f5ae <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f637:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f63e:	e9 6b ff ff ff       	jmp    f011f5ae <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f643:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f644:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f648:	0f 89 60 ff ff ff    	jns    f011f5ae <vprintfmt+0x54>
				width = precision, precision = -1;
f011f64e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f651:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f654:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f65b:	e9 4e ff ff ff       	jmp    f011f5ae <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f660:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f663:	e9 46 ff ff ff       	jmp    f011f5ae <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f668:	8b 45 14             	mov    0x14(%ebp),%eax
f011f66b:	83 c0 04             	add    $0x4,%eax
f011f66e:	89 45 14             	mov    %eax,0x14(%ebp)
f011f671:	8b 45 14             	mov    0x14(%ebp),%eax
f011f674:	83 e8 04             	sub    $0x4,%eax
f011f677:	8b 00                	mov    (%eax),%eax
f011f679:	83 ec 08             	sub    $0x8,%esp
f011f67c:	ff 75 0c             	pushl  0xc(%ebp)
f011f67f:	50                   	push   %eax
f011f680:	8b 45 08             	mov    0x8(%ebp),%eax
f011f683:	ff d0                	call   *%eax
f011f685:	83 c4 10             	add    $0x10,%esp
			break;
f011f688:	e9 9b 02 00 00       	jmp    f011f928 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f68d:	8b 45 14             	mov    0x14(%ebp),%eax
f011f690:	83 c0 04             	add    $0x4,%eax
f011f693:	89 45 14             	mov    %eax,0x14(%ebp)
f011f696:	8b 45 14             	mov    0x14(%ebp),%eax
f011f699:	83 e8 04             	sub    $0x4,%eax
f011f69c:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f69e:	85 db                	test   %ebx,%ebx
f011f6a0:	79 02                	jns    f011f6a4 <vprintfmt+0x14a>
				err = -err;
f011f6a2:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f6a4:	83 fb 64             	cmp    $0x64,%ebx
f011f6a7:	7f 0b                	jg     f011f6b4 <vprintfmt+0x15a>
f011f6a9:	8b 34 9d 20 10 13 f0 	mov    -0xfecefe0(,%ebx,4),%esi
f011f6b0:	85 f6                	test   %esi,%esi
f011f6b2:	75 19                	jne    f011f6cd <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f6b4:	53                   	push   %ebx
f011f6b5:	68 c5 11 13 f0       	push   $0xf01311c5
f011f6ba:	ff 75 0c             	pushl  0xc(%ebp)
f011f6bd:	ff 75 08             	pushl  0x8(%ebp)
f011f6c0:	e8 70 02 00 00       	call   f011f935 <printfmt>
f011f6c5:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f6c8:	e9 5b 02 00 00       	jmp    f011f928 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f6cd:	56                   	push   %esi
f011f6ce:	68 ce 11 13 f0       	push   $0xf01311ce
f011f6d3:	ff 75 0c             	pushl  0xc(%ebp)
f011f6d6:	ff 75 08             	pushl  0x8(%ebp)
f011f6d9:	e8 57 02 00 00       	call   f011f935 <printfmt>
f011f6de:	83 c4 10             	add    $0x10,%esp
			break;
f011f6e1:	e9 42 02 00 00       	jmp    f011f928 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f6e6:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6e9:	83 c0 04             	add    $0x4,%eax
f011f6ec:	89 45 14             	mov    %eax,0x14(%ebp)
f011f6ef:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6f2:	83 e8 04             	sub    $0x4,%eax
f011f6f5:	8b 30                	mov    (%eax),%esi
f011f6f7:	85 f6                	test   %esi,%esi
f011f6f9:	75 05                	jne    f011f700 <vprintfmt+0x1a6>
				p = "(null)";
f011f6fb:	be d1 11 13 f0       	mov    $0xf01311d1,%esi
			if (width > 0 && padc != '-')
f011f700:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f704:	7e 6d                	jle    f011f773 <vprintfmt+0x219>
f011f706:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f70a:	74 67                	je     f011f773 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f70c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f70f:	83 ec 08             	sub    $0x8,%esp
f011f712:	50                   	push   %eax
f011f713:	56                   	push   %esi
f011f714:	e8 26 05 00 00       	call   f011fc3f <strnlen>
f011f719:	83 c4 10             	add    $0x10,%esp
f011f71c:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f71f:	eb 16                	jmp    f011f737 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f721:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f725:	83 ec 08             	sub    $0x8,%esp
f011f728:	ff 75 0c             	pushl  0xc(%ebp)
f011f72b:	50                   	push   %eax
f011f72c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f72f:	ff d0                	call   *%eax
f011f731:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f734:	ff 4d e4             	decl   -0x1c(%ebp)
f011f737:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f73b:	7f e4                	jg     f011f721 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f73d:	eb 34                	jmp    f011f773 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f73f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f743:	74 1c                	je     f011f761 <vprintfmt+0x207>
f011f745:	83 fb 1f             	cmp    $0x1f,%ebx
f011f748:	7e 05                	jle    f011f74f <vprintfmt+0x1f5>
f011f74a:	83 fb 7e             	cmp    $0x7e,%ebx
f011f74d:	7e 12                	jle    f011f761 <vprintfmt+0x207>
					putch('?', putdat);
f011f74f:	83 ec 08             	sub    $0x8,%esp
f011f752:	ff 75 0c             	pushl  0xc(%ebp)
f011f755:	6a 3f                	push   $0x3f
f011f757:	8b 45 08             	mov    0x8(%ebp),%eax
f011f75a:	ff d0                	call   *%eax
f011f75c:	83 c4 10             	add    $0x10,%esp
f011f75f:	eb 0f                	jmp    f011f770 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f761:	83 ec 08             	sub    $0x8,%esp
f011f764:	ff 75 0c             	pushl  0xc(%ebp)
f011f767:	53                   	push   %ebx
f011f768:	8b 45 08             	mov    0x8(%ebp),%eax
f011f76b:	ff d0                	call   *%eax
f011f76d:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f770:	ff 4d e4             	decl   -0x1c(%ebp)
f011f773:	89 f0                	mov    %esi,%eax
f011f775:	8d 70 01             	lea    0x1(%eax),%esi
f011f778:	8a 00                	mov    (%eax),%al
f011f77a:	0f be d8             	movsbl %al,%ebx
f011f77d:	85 db                	test   %ebx,%ebx
f011f77f:	74 24                	je     f011f7a5 <vprintfmt+0x24b>
f011f781:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f785:	78 b8                	js     f011f73f <vprintfmt+0x1e5>
f011f787:	ff 4d e0             	decl   -0x20(%ebp)
f011f78a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f78e:	79 af                	jns    f011f73f <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f790:	eb 13                	jmp    f011f7a5 <vprintfmt+0x24b>
				putch(' ', putdat);
f011f792:	83 ec 08             	sub    $0x8,%esp
f011f795:	ff 75 0c             	pushl  0xc(%ebp)
f011f798:	6a 20                	push   $0x20
f011f79a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f79d:	ff d0                	call   *%eax
f011f79f:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f7a2:	ff 4d e4             	decl   -0x1c(%ebp)
f011f7a5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f7a9:	7f e7                	jg     f011f792 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f7ab:	e9 78 01 00 00       	jmp    f011f928 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f7b0:	83 ec 08             	sub    $0x8,%esp
f011f7b3:	ff 75 e8             	pushl  -0x18(%ebp)
f011f7b6:	8d 45 14             	lea    0x14(%ebp),%eax
f011f7b9:	50                   	push   %eax
f011f7ba:	e8 3c fd ff ff       	call   f011f4fb <getint>
f011f7bf:	83 c4 10             	add    $0x10,%esp
f011f7c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f7c5:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f7c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f7cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f7ce:	85 d2                	test   %edx,%edx
f011f7d0:	79 23                	jns    f011f7f5 <vprintfmt+0x29b>
				putch('-', putdat);
f011f7d2:	83 ec 08             	sub    $0x8,%esp
f011f7d5:	ff 75 0c             	pushl  0xc(%ebp)
f011f7d8:	6a 2d                	push   $0x2d
f011f7da:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7dd:	ff d0                	call   *%eax
f011f7df:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f7e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f7e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f7e8:	f7 d8                	neg    %eax
f011f7ea:	83 d2 00             	adc    $0x0,%edx
f011f7ed:	f7 da                	neg    %edx
f011f7ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f7f2:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f7f5:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f7fc:	e9 bc 00 00 00       	jmp    f011f8bd <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f801:	83 ec 08             	sub    $0x8,%esp
f011f804:	ff 75 e8             	pushl  -0x18(%ebp)
f011f807:	8d 45 14             	lea    0x14(%ebp),%eax
f011f80a:	50                   	push   %eax
f011f80b:	e8 84 fc ff ff       	call   f011f494 <getuint>
f011f810:	83 c4 10             	add    $0x10,%esp
f011f813:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f816:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f819:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f820:	e9 98 00 00 00       	jmp    f011f8bd <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f825:	83 ec 08             	sub    $0x8,%esp
f011f828:	ff 75 0c             	pushl  0xc(%ebp)
f011f82b:	6a 58                	push   $0x58
f011f82d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f830:	ff d0                	call   *%eax
f011f832:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f835:	83 ec 08             	sub    $0x8,%esp
f011f838:	ff 75 0c             	pushl  0xc(%ebp)
f011f83b:	6a 58                	push   $0x58
f011f83d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f840:	ff d0                	call   *%eax
f011f842:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f845:	83 ec 08             	sub    $0x8,%esp
f011f848:	ff 75 0c             	pushl  0xc(%ebp)
f011f84b:	6a 58                	push   $0x58
f011f84d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f850:	ff d0                	call   *%eax
f011f852:	83 c4 10             	add    $0x10,%esp
			break;
f011f855:	e9 ce 00 00 00       	jmp    f011f928 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f85a:	83 ec 08             	sub    $0x8,%esp
f011f85d:	ff 75 0c             	pushl  0xc(%ebp)
f011f860:	6a 30                	push   $0x30
f011f862:	8b 45 08             	mov    0x8(%ebp),%eax
f011f865:	ff d0                	call   *%eax
f011f867:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f86a:	83 ec 08             	sub    $0x8,%esp
f011f86d:	ff 75 0c             	pushl  0xc(%ebp)
f011f870:	6a 78                	push   $0x78
f011f872:	8b 45 08             	mov    0x8(%ebp),%eax
f011f875:	ff d0                	call   *%eax
f011f877:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f87a:	8b 45 14             	mov    0x14(%ebp),%eax
f011f87d:	83 c0 04             	add    $0x4,%eax
f011f880:	89 45 14             	mov    %eax,0x14(%ebp)
f011f883:	8b 45 14             	mov    0x14(%ebp),%eax
f011f886:	83 e8 04             	sub    $0x4,%eax
f011f889:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f88b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f88e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f895:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f89c:	eb 1f                	jmp    f011f8bd <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f89e:	83 ec 08             	sub    $0x8,%esp
f011f8a1:	ff 75 e8             	pushl  -0x18(%ebp)
f011f8a4:	8d 45 14             	lea    0x14(%ebp),%eax
f011f8a7:	50                   	push   %eax
f011f8a8:	e8 e7 fb ff ff       	call   f011f494 <getuint>
f011f8ad:	83 c4 10             	add    $0x10,%esp
f011f8b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f8b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f8b6:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f8bd:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f8c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f8c4:	83 ec 04             	sub    $0x4,%esp
f011f8c7:	52                   	push   %edx
f011f8c8:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f8cb:	50                   	push   %eax
f011f8cc:	ff 75 f4             	pushl  -0xc(%ebp)
f011f8cf:	ff 75 f0             	pushl  -0x10(%ebp)
f011f8d2:	ff 75 0c             	pushl  0xc(%ebp)
f011f8d5:	ff 75 08             	pushl  0x8(%ebp)
f011f8d8:	e8 00 fb ff ff       	call   f011f3dd <printnum>
f011f8dd:	83 c4 20             	add    $0x20,%esp
			break;
f011f8e0:	eb 46                	jmp    f011f928 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f8e2:	83 ec 08             	sub    $0x8,%esp
f011f8e5:	ff 75 0c             	pushl  0xc(%ebp)
f011f8e8:	53                   	push   %ebx
f011f8e9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ec:	ff d0                	call   *%eax
f011f8ee:	83 c4 10             	add    $0x10,%esp
			break;
f011f8f1:	eb 35                	jmp    f011f928 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f8f3:	c6 05 40 2e 6c f0 00 	movb   $0x0,0xf06c2e40
			break;
f011f8fa:	eb 2c                	jmp    f011f928 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f8fc:	c6 05 40 2e 6c f0 01 	movb   $0x1,0xf06c2e40
			break;
f011f903:	eb 23                	jmp    f011f928 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f905:	83 ec 08             	sub    $0x8,%esp
f011f908:	ff 75 0c             	pushl  0xc(%ebp)
f011f90b:	6a 25                	push   $0x25
f011f90d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f910:	ff d0                	call   *%eax
f011f912:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f915:	ff 4d 10             	decl   0x10(%ebp)
f011f918:	eb 03                	jmp    f011f91d <vprintfmt+0x3c3>
f011f91a:	ff 4d 10             	decl   0x10(%ebp)
f011f91d:	8b 45 10             	mov    0x10(%ebp),%eax
f011f920:	48                   	dec    %eax
f011f921:	8a 00                	mov    (%eax),%al
f011f923:	3c 25                	cmp    $0x25,%al
f011f925:	75 f3                	jne    f011f91a <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f927:	90                   	nop
		}
	}
f011f928:	e9 35 fc ff ff       	jmp    f011f562 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f92d:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f92e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f931:	5b                   	pop    %ebx
f011f932:	5e                   	pop    %esi
f011f933:	5d                   	pop    %ebp
f011f934:	c3                   	ret    

f011f935 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f935:	55                   	push   %ebp
f011f936:	89 e5                	mov    %esp,%ebp
f011f938:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f93b:	8d 45 10             	lea    0x10(%ebp),%eax
f011f93e:	83 c0 04             	add    $0x4,%eax
f011f941:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f944:	8b 45 10             	mov    0x10(%ebp),%eax
f011f947:	ff 75 f4             	pushl  -0xc(%ebp)
f011f94a:	50                   	push   %eax
f011f94b:	ff 75 0c             	pushl  0xc(%ebp)
f011f94e:	ff 75 08             	pushl  0x8(%ebp)
f011f951:	e8 04 fc ff ff       	call   f011f55a <vprintfmt>
f011f956:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011f959:	90                   	nop
f011f95a:	c9                   	leave  
f011f95b:	c3                   	ret    

f011f95c <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011f95c:	55                   	push   %ebp
f011f95d:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011f95f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f962:	8b 40 08             	mov    0x8(%eax),%eax
f011f965:	8d 50 01             	lea    0x1(%eax),%edx
f011f968:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f96b:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011f96e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f971:	8b 10                	mov    (%eax),%edx
f011f973:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f976:	8b 40 04             	mov    0x4(%eax),%eax
f011f979:	39 c2                	cmp    %eax,%edx
f011f97b:	73 12                	jae    f011f98f <sprintputch+0x33>
		*b->buf++ = ch;
f011f97d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f980:	8b 00                	mov    (%eax),%eax
f011f982:	8d 48 01             	lea    0x1(%eax),%ecx
f011f985:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f988:	89 0a                	mov    %ecx,(%edx)
f011f98a:	8b 55 08             	mov    0x8(%ebp),%edx
f011f98d:	88 10                	mov    %dl,(%eax)
}
f011f98f:	90                   	nop
f011f990:	5d                   	pop    %ebp
f011f991:	c3                   	ret    

f011f992 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011f992:	55                   	push   %ebp
f011f993:	89 e5                	mov    %esp,%ebp
f011f995:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011f998:	8b 45 08             	mov    0x8(%ebp),%eax
f011f99b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f99e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9a1:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f9a4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9a7:	01 d0                	add    %edx,%eax
f011f9a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f9ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011f9b3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f9b7:	74 06                	je     f011f9bf <vsnprintf+0x2d>
f011f9b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f9bd:	7f 07                	jg     f011f9c6 <vsnprintf+0x34>
		return -E_INVAL;
f011f9bf:	b8 03 00 00 00       	mov    $0x3,%eax
f011f9c4:	eb 20                	jmp    f011f9e6 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011f9c6:	ff 75 14             	pushl  0x14(%ebp)
f011f9c9:	ff 75 10             	pushl  0x10(%ebp)
f011f9cc:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011f9cf:	50                   	push   %eax
f011f9d0:	68 5c f9 11 f0       	push   $0xf011f95c
f011f9d5:	e8 80 fb ff ff       	call   f011f55a <vprintfmt>
f011f9da:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011f9dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f9e0:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011f9e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f9e6:	c9                   	leave  
f011f9e7:	c3                   	ret    

f011f9e8 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011f9e8:	55                   	push   %ebp
f011f9e9:	89 e5                	mov    %esp,%ebp
f011f9eb:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011f9ee:	8d 45 10             	lea    0x10(%ebp),%eax
f011f9f1:	83 c0 04             	add    $0x4,%eax
f011f9f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011f9f7:	8b 45 10             	mov    0x10(%ebp),%eax
f011f9fa:	ff 75 f4             	pushl  -0xc(%ebp)
f011f9fd:	50                   	push   %eax
f011f9fe:	ff 75 0c             	pushl  0xc(%ebp)
f011fa01:	ff 75 08             	pushl  0x8(%ebp)
f011fa04:	e8 89 ff ff ff       	call   f011f992 <vsnprintf>
f011fa09:	83 c4 10             	add    $0x10,%esp
f011fa0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011fa0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011fa12:	c9                   	leave  
f011fa13:	c3                   	ret    

f011fa14 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011fa14:	55                   	push   %ebp
f011fa15:	89 e5                	mov    %esp,%ebp
f011fa17:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011fa1a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fa1e:	74 13                	je     f011fa33 <readline+0x1f>
		cprintf("%s", prompt);
f011fa20:	83 ec 08             	sub    $0x8,%esp
f011fa23:	ff 75 08             	pushl  0x8(%ebp)
f011fa26:	68 48 13 13 f0       	push   $0xf0131348
f011fa2b:	e8 5b 15 fe ff       	call   f0100f8b <cprintf>
f011fa30:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011fa33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011fa3a:	83 ec 0c             	sub    $0xc,%esp
f011fa3d:	6a 00                	push   $0x0
f011fa3f:	e8 54 14 fe ff       	call   f0100e98 <iscons>
f011fa44:	83 c4 10             	add    $0x10,%esp
f011fa47:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011fa4a:	e8 30 14 fe ff       	call   f0100e7f <getchar>
f011fa4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011fa52:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fa56:	79 22                	jns    f011fa7a <readline+0x66>
			if (c != -E_EOF)
f011fa58:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fa5c:	0f 84 ad 00 00 00    	je     f011fb0f <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fa62:	83 ec 08             	sub    $0x8,%esp
f011fa65:	ff 75 ec             	pushl  -0x14(%ebp)
f011fa68:	68 4b 13 13 f0       	push   $0xf013134b
f011fa6d:	e8 19 15 fe ff       	call   f0100f8b <cprintf>
f011fa72:	83 c4 10             	add    $0x10,%esp
			break;
f011fa75:	e9 95 00 00 00       	jmp    f011fb0f <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fa7a:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fa7e:	7e 34                	jle    f011fab4 <readline+0xa0>
f011fa80:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fa87:	7f 2b                	jg     f011fab4 <readline+0xa0>
			if (echoing)
f011fa89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fa8d:	74 0e                	je     f011fa9d <readline+0x89>
				cputchar(c);
f011fa8f:	83 ec 0c             	sub    $0xc,%esp
f011fa92:	ff 75 ec             	pushl  -0x14(%ebp)
f011fa95:	e8 ce 13 fe ff       	call   f0100e68 <cputchar>
f011fa9a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fa9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011faa0:	8d 50 01             	lea    0x1(%eax),%edx
f011faa3:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011faa6:	89 c2                	mov    %eax,%edx
f011faa8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011faab:	01 d0                	add    %edx,%eax
f011faad:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fab0:	88 10                	mov    %dl,(%eax)
f011fab2:	eb 56                	jmp    f011fb0a <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011fab4:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fab8:	75 1f                	jne    f011fad9 <readline+0xc5>
f011faba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fabe:	7e 19                	jle    f011fad9 <readline+0xc5>
			if (echoing)
f011fac0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fac4:	74 0e                	je     f011fad4 <readline+0xc0>
				cputchar(c);
f011fac6:	83 ec 0c             	sub    $0xc,%esp
f011fac9:	ff 75 ec             	pushl  -0x14(%ebp)
f011facc:	e8 97 13 fe ff       	call   f0100e68 <cputchar>
f011fad1:	83 c4 10             	add    $0x10,%esp

			i--;
f011fad4:	ff 4d f4             	decl   -0xc(%ebp)
f011fad7:	eb 31                	jmp    f011fb0a <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fad9:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fadd:	74 0a                	je     f011fae9 <readline+0xd5>
f011fadf:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fae3:	0f 85 61 ff ff ff    	jne    f011fa4a <readline+0x36>
			if (echoing)
f011fae9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011faed:	74 0e                	je     f011fafd <readline+0xe9>
				cputchar(c);
f011faef:	83 ec 0c             	sub    $0xc,%esp
f011faf2:	ff 75 ec             	pushl  -0x14(%ebp)
f011faf5:	e8 6e 13 fe ff       	call   f0100e68 <cputchar>
f011fafa:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011fafd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb00:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb03:	01 d0                	add    %edx,%eax
f011fb05:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011fb08:	eb 06                	jmp    f011fb10 <readline+0xfc>
		}
	}
f011fb0a:	e9 3b ff ff ff       	jmp    f011fa4a <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011fb0f:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011fb10:	90                   	nop
f011fb11:	c9                   	leave  
f011fb12:	c3                   	ret    

f011fb13 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011fb13:	55                   	push   %ebp
f011fb14:	89 e5                	mov    %esp,%ebp
f011fb16:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011fb19:	e8 53 ec fe ff       	call   f010e771 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011fb1e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fb22:	74 13                	je     f011fb37 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011fb24:	83 ec 08             	sub    $0x8,%esp
f011fb27:	ff 75 08             	pushl  0x8(%ebp)
f011fb2a:	68 48 13 13 f0       	push   $0xf0131348
f011fb2f:	e8 57 14 fe ff       	call   f0100f8b <cprintf>
f011fb34:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011fb37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011fb3e:	83 ec 0c             	sub    $0xc,%esp
f011fb41:	6a 00                	push   $0x0
f011fb43:	e8 50 13 fe ff       	call   f0100e98 <iscons>
f011fb48:	83 c4 10             	add    $0x10,%esp
f011fb4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011fb4e:	e8 2c 13 fe ff       	call   f0100e7f <getchar>
f011fb53:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011fb56:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fb5a:	79 22                	jns    f011fb7e <atomic_readline+0x6b>
				if (c != -E_EOF)
f011fb5c:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fb60:	0f 84 ad 00 00 00    	je     f011fc13 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011fb66:	83 ec 08             	sub    $0x8,%esp
f011fb69:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb6c:	68 4b 13 13 f0       	push   $0xf013134b
f011fb71:	e8 15 14 fe ff       	call   f0100f8b <cprintf>
f011fb76:	83 c4 10             	add    $0x10,%esp
				break;
f011fb79:	e9 95 00 00 00       	jmp    f011fc13 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011fb7e:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fb82:	7e 34                	jle    f011fbb8 <atomic_readline+0xa5>
f011fb84:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fb8b:	7f 2b                	jg     f011fbb8 <atomic_readline+0xa5>
				if (echoing)
f011fb8d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb91:	74 0e                	je     f011fba1 <atomic_readline+0x8e>
					cputchar(c);
f011fb93:	83 ec 0c             	sub    $0xc,%esp
f011fb96:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb99:	e8 ca 12 fe ff       	call   f0100e68 <cputchar>
f011fb9e:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011fba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fba4:	8d 50 01             	lea    0x1(%eax),%edx
f011fba7:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fbaa:	89 c2                	mov    %eax,%edx
f011fbac:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbaf:	01 d0                	add    %edx,%eax
f011fbb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fbb4:	88 10                	mov    %dl,(%eax)
f011fbb6:	eb 56                	jmp    f011fc0e <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011fbb8:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fbbc:	75 1f                	jne    f011fbdd <atomic_readline+0xca>
f011fbbe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fbc2:	7e 19                	jle    f011fbdd <atomic_readline+0xca>
				if (echoing)
f011fbc4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fbc8:	74 0e                	je     f011fbd8 <atomic_readline+0xc5>
					cputchar(c);
f011fbca:	83 ec 0c             	sub    $0xc,%esp
f011fbcd:	ff 75 ec             	pushl  -0x14(%ebp)
f011fbd0:	e8 93 12 fe ff       	call   f0100e68 <cputchar>
f011fbd5:	83 c4 10             	add    $0x10,%esp
				i--;
f011fbd8:	ff 4d f4             	decl   -0xc(%ebp)
f011fbdb:	eb 31                	jmp    f011fc0e <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011fbdd:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fbe1:	74 0a                	je     f011fbed <atomic_readline+0xda>
f011fbe3:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fbe7:	0f 85 61 ff ff ff    	jne    f011fb4e <atomic_readline+0x3b>
				if (echoing)
f011fbed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fbf1:	74 0e                	je     f011fc01 <atomic_readline+0xee>
					cputchar(c);
f011fbf3:	83 ec 0c             	sub    $0xc,%esp
f011fbf6:	ff 75 ec             	pushl  -0x14(%ebp)
f011fbf9:	e8 6a 12 fe ff       	call   f0100e68 <cputchar>
f011fbfe:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011fc01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc04:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc07:	01 d0                	add    %edx,%eax
f011fc09:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011fc0c:	eb 06                	jmp    f011fc14 <atomic_readline+0x101>
			}
		}
f011fc0e:	e9 3b ff ff ff       	jmp    f011fb4e <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011fc13:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011fc14:	e8 66 eb fe ff       	call   f010e77f <sys_unlock_cons>
}
f011fc19:	90                   	nop
f011fc1a:	c9                   	leave  
f011fc1b:	c3                   	ret    

f011fc1c <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011fc1c:	55                   	push   %ebp
f011fc1d:	89 e5                	mov    %esp,%ebp
f011fc1f:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011fc22:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fc29:	eb 06                	jmp    f011fc31 <strlen+0x15>
		n++;
f011fc2b:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011fc2e:	ff 45 08             	incl   0x8(%ebp)
f011fc31:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc34:	8a 00                	mov    (%eax),%al
f011fc36:	84 c0                	test   %al,%al
f011fc38:	75 f1                	jne    f011fc2b <strlen+0xf>
		n++;
	return n;
f011fc3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fc3d:	c9                   	leave  
f011fc3e:	c3                   	ret    

f011fc3f <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011fc3f:	55                   	push   %ebp
f011fc40:	89 e5                	mov    %esp,%ebp
f011fc42:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fc45:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fc4c:	eb 09                	jmp    f011fc57 <strnlen+0x18>
		n++;
f011fc4e:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fc51:	ff 45 08             	incl   0x8(%ebp)
f011fc54:	ff 4d 0c             	decl   0xc(%ebp)
f011fc57:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fc5b:	74 09                	je     f011fc66 <strnlen+0x27>
f011fc5d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc60:	8a 00                	mov    (%eax),%al
f011fc62:	84 c0                	test   %al,%al
f011fc64:	75 e8                	jne    f011fc4e <strnlen+0xf>
		n++;
	return n;
f011fc66:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fc69:	c9                   	leave  
f011fc6a:	c3                   	ret    

f011fc6b <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011fc6b:	55                   	push   %ebp
f011fc6c:	89 e5                	mov    %esp,%ebp
f011fc6e:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011fc71:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc74:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011fc77:	90                   	nop
f011fc78:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc7b:	8d 50 01             	lea    0x1(%eax),%edx
f011fc7e:	89 55 08             	mov    %edx,0x8(%ebp)
f011fc81:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fc84:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fc87:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fc8a:	8a 12                	mov    (%edx),%dl
f011fc8c:	88 10                	mov    %dl,(%eax)
f011fc8e:	8a 00                	mov    (%eax),%al
f011fc90:	84 c0                	test   %al,%al
f011fc92:	75 e4                	jne    f011fc78 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011fc94:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fc97:	c9                   	leave  
f011fc98:	c3                   	ret    

f011fc99 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011fc99:	55                   	push   %ebp
f011fc9a:	89 e5                	mov    %esp,%ebp
f011fc9c:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011fc9f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fca2:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011fca5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fcac:	eb 1f                	jmp    f011fccd <strncpy+0x34>
		*dst++ = *src;
f011fcae:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcb1:	8d 50 01             	lea    0x1(%eax),%edx
f011fcb4:	89 55 08             	mov    %edx,0x8(%ebp)
f011fcb7:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fcba:	8a 12                	mov    (%edx),%dl
f011fcbc:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011fcbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcc1:	8a 00                	mov    (%eax),%al
f011fcc3:	84 c0                	test   %al,%al
f011fcc5:	74 03                	je     f011fcca <strncpy+0x31>
			src++;
f011fcc7:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011fcca:	ff 45 fc             	incl   -0x4(%ebp)
f011fccd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fcd0:	3b 45 10             	cmp    0x10(%ebp),%eax
f011fcd3:	72 d9                	jb     f011fcae <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011fcd5:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011fcd8:	c9                   	leave  
f011fcd9:	c3                   	ret    

f011fcda <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011fcda:	55                   	push   %ebp
f011fcdb:	89 e5                	mov    %esp,%ebp
f011fcdd:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011fce0:	8b 45 08             	mov    0x8(%ebp),%eax
f011fce3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011fce6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fcea:	74 30                	je     f011fd1c <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011fcec:	eb 16                	jmp    f011fd04 <strlcpy+0x2a>
			*dst++ = *src++;
f011fcee:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcf1:	8d 50 01             	lea    0x1(%eax),%edx
f011fcf4:	89 55 08             	mov    %edx,0x8(%ebp)
f011fcf7:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fcfa:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fcfd:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fd00:	8a 12                	mov    (%edx),%dl
f011fd02:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011fd04:	ff 4d 10             	decl   0x10(%ebp)
f011fd07:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd0b:	74 09                	je     f011fd16 <strlcpy+0x3c>
f011fd0d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd10:	8a 00                	mov    (%eax),%al
f011fd12:	84 c0                	test   %al,%al
f011fd14:	75 d8                	jne    f011fcee <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011fd16:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd19:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011fd1c:	8b 55 08             	mov    0x8(%ebp),%edx
f011fd1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fd22:	29 c2                	sub    %eax,%edx
f011fd24:	89 d0                	mov    %edx,%eax
}
f011fd26:	c9                   	leave  
f011fd27:	c3                   	ret    

f011fd28 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011fd28:	55                   	push   %ebp
f011fd29:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011fd2b:	eb 06                	jmp    f011fd33 <strcmp+0xb>
		p++, q++;
f011fd2d:	ff 45 08             	incl   0x8(%ebp)
f011fd30:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011fd33:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd36:	8a 00                	mov    (%eax),%al
f011fd38:	84 c0                	test   %al,%al
f011fd3a:	74 0e                	je     f011fd4a <strcmp+0x22>
f011fd3c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd3f:	8a 10                	mov    (%eax),%dl
f011fd41:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd44:	8a 00                	mov    (%eax),%al
f011fd46:	38 c2                	cmp    %al,%dl
f011fd48:	74 e3                	je     f011fd2d <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011fd4a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd4d:	8a 00                	mov    (%eax),%al
f011fd4f:	0f b6 d0             	movzbl %al,%edx
f011fd52:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd55:	8a 00                	mov    (%eax),%al
f011fd57:	0f b6 c0             	movzbl %al,%eax
f011fd5a:	29 c2                	sub    %eax,%edx
f011fd5c:	89 d0                	mov    %edx,%eax
}
f011fd5e:	5d                   	pop    %ebp
f011fd5f:	c3                   	ret    

f011fd60 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011fd60:	55                   	push   %ebp
f011fd61:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011fd63:	eb 09                	jmp    f011fd6e <strncmp+0xe>
		n--, p++, q++;
f011fd65:	ff 4d 10             	decl   0x10(%ebp)
f011fd68:	ff 45 08             	incl   0x8(%ebp)
f011fd6b:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011fd6e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd72:	74 17                	je     f011fd8b <strncmp+0x2b>
f011fd74:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd77:	8a 00                	mov    (%eax),%al
f011fd79:	84 c0                	test   %al,%al
f011fd7b:	74 0e                	je     f011fd8b <strncmp+0x2b>
f011fd7d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd80:	8a 10                	mov    (%eax),%dl
f011fd82:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd85:	8a 00                	mov    (%eax),%al
f011fd87:	38 c2                	cmp    %al,%dl
f011fd89:	74 da                	je     f011fd65 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011fd8b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd8f:	75 07                	jne    f011fd98 <strncmp+0x38>
		return 0;
f011fd91:	b8 00 00 00 00       	mov    $0x0,%eax
f011fd96:	eb 14                	jmp    f011fdac <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011fd98:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd9b:	8a 00                	mov    (%eax),%al
f011fd9d:	0f b6 d0             	movzbl %al,%edx
f011fda0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fda3:	8a 00                	mov    (%eax),%al
f011fda5:	0f b6 c0             	movzbl %al,%eax
f011fda8:	29 c2                	sub    %eax,%edx
f011fdaa:	89 d0                	mov    %edx,%eax
}
f011fdac:	5d                   	pop    %ebp
f011fdad:	c3                   	ret    

f011fdae <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011fdae:	55                   	push   %ebp
f011fdaf:	89 e5                	mov    %esp,%ebp
f011fdb1:	83 ec 04             	sub    $0x4,%esp
f011fdb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdb7:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fdba:	eb 12                	jmp    f011fdce <strchr+0x20>
		if (*s == c)
f011fdbc:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdbf:	8a 00                	mov    (%eax),%al
f011fdc1:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fdc4:	75 05                	jne    f011fdcb <strchr+0x1d>
			return (char *) s;
f011fdc6:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdc9:	eb 11                	jmp    f011fddc <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011fdcb:	ff 45 08             	incl   0x8(%ebp)
f011fdce:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdd1:	8a 00                	mov    (%eax),%al
f011fdd3:	84 c0                	test   %al,%al
f011fdd5:	75 e5                	jne    f011fdbc <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011fdd7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fddc:	c9                   	leave  
f011fddd:	c3                   	ret    

f011fdde <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011fdde:	55                   	push   %ebp
f011fddf:	89 e5                	mov    %esp,%ebp
f011fde1:	83 ec 04             	sub    $0x4,%esp
f011fde4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fde7:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fdea:	eb 0d                	jmp    f011fdf9 <strfind+0x1b>
		if (*s == c)
f011fdec:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdef:	8a 00                	mov    (%eax),%al
f011fdf1:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fdf4:	74 0e                	je     f011fe04 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011fdf6:	ff 45 08             	incl   0x8(%ebp)
f011fdf9:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdfc:	8a 00                	mov    (%eax),%al
f011fdfe:	84 c0                	test   %al,%al
f011fe00:	75 ea                	jne    f011fdec <strfind+0xe>
f011fe02:	eb 01                	jmp    f011fe05 <strfind+0x27>
		if (*s == c)
			break;
f011fe04:	90                   	nop
	return (char *) s;
f011fe05:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe08:	c9                   	leave  
f011fe09:	c3                   	ret    

f011fe0a <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011fe0a:	55                   	push   %ebp
f011fe0b:	89 e5                	mov    %esp,%ebp
f011fe0d:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011fe10:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe13:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011fe16:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe19:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011fe1c:	eb 0e                	jmp    f011fe2c <memset+0x22>
		*p++ = c;
f011fe1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fe21:	8d 50 01             	lea    0x1(%eax),%edx
f011fe24:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fe27:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fe2a:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011fe2c:	ff 4d f8             	decl   -0x8(%ebp)
f011fe2f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011fe33:	79 e9                	jns    f011fe1e <memset+0x14>
		*p++ = c;

	return v;
f011fe35:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe38:	c9                   	leave  
f011fe39:	c3                   	ret    

f011fe3a <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011fe3a:	55                   	push   %ebp
f011fe3b:	89 e5                	mov    %esp,%ebp
f011fe3d:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fe40:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe43:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011fe46:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe49:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011fe4c:	eb 16                	jmp    f011fe64 <memcpy+0x2a>
		*d++ = *s++;
f011fe4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fe51:	8d 50 01             	lea    0x1(%eax),%edx
f011fe54:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011fe57:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fe5a:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fe5d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011fe60:	8a 12                	mov    (%edx),%dl
f011fe62:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011fe64:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe67:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fe6a:	89 55 10             	mov    %edx,0x10(%ebp)
f011fe6d:	85 c0                	test   %eax,%eax
f011fe6f:	75 dd                	jne    f011fe4e <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011fe71:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe74:	c9                   	leave  
f011fe75:	c3                   	ret    

f011fe76 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011fe76:	55                   	push   %ebp
f011fe77:	89 e5                	mov    %esp,%ebp
f011fe79:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fe7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe7f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011fe82:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe85:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011fe88:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fe8b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011fe8e:	73 50                	jae    f011fee0 <memmove+0x6a>
f011fe90:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fe93:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe96:	01 d0                	add    %edx,%eax
f011fe98:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011fe9b:	76 43                	jbe    f011fee0 <memmove+0x6a>
		s += n;
f011fe9d:	8b 45 10             	mov    0x10(%ebp),%eax
f011fea0:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011fea3:	8b 45 10             	mov    0x10(%ebp),%eax
f011fea6:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011fea9:	eb 10                	jmp    f011febb <memmove+0x45>
			*--d = *--s;
f011feab:	ff 4d f8             	decl   -0x8(%ebp)
f011feae:	ff 4d fc             	decl   -0x4(%ebp)
f011feb1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011feb4:	8a 10                	mov    (%eax),%dl
f011feb6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011feb9:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011febb:	8b 45 10             	mov    0x10(%ebp),%eax
f011febe:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fec1:	89 55 10             	mov    %edx,0x10(%ebp)
f011fec4:	85 c0                	test   %eax,%eax
f011fec6:	75 e3                	jne    f011feab <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011fec8:	eb 23                	jmp    f011feed <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011feca:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fecd:	8d 50 01             	lea    0x1(%eax),%edx
f011fed0:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011fed3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fed6:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fed9:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011fedc:	8a 12                	mov    (%edx),%dl
f011fede:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011fee0:	8b 45 10             	mov    0x10(%ebp),%eax
f011fee3:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fee6:	89 55 10             	mov    %edx,0x10(%ebp)
f011fee9:	85 c0                	test   %eax,%eax
f011feeb:	75 dd                	jne    f011feca <memmove+0x54>
			*d++ = *s++;

	return dst;
f011feed:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fef0:	c9                   	leave  
f011fef1:	c3                   	ret    

f011fef2 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011fef2:	55                   	push   %ebp
f011fef3:	89 e5                	mov    %esp,%ebp
f011fef5:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011fef8:	8b 45 08             	mov    0x8(%ebp),%eax
f011fefb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011fefe:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff01:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ff04:	eb 2a                	jmp    f011ff30 <memcmp+0x3e>
		if (*s1 != *s2)
f011ff06:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff09:	8a 10                	mov    (%eax),%dl
f011ff0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff0e:	8a 00                	mov    (%eax),%al
f011ff10:	38 c2                	cmp    %al,%dl
f011ff12:	74 16                	je     f011ff2a <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011ff14:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff17:	8a 00                	mov    (%eax),%al
f011ff19:	0f b6 d0             	movzbl %al,%edx
f011ff1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff1f:	8a 00                	mov    (%eax),%al
f011ff21:	0f b6 c0             	movzbl %al,%eax
f011ff24:	29 c2                	sub    %eax,%edx
f011ff26:	89 d0                	mov    %edx,%eax
f011ff28:	eb 18                	jmp    f011ff42 <memcmp+0x50>
		s1++, s2++;
f011ff2a:	ff 45 fc             	incl   -0x4(%ebp)
f011ff2d:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011ff30:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff33:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ff36:	89 55 10             	mov    %edx,0x10(%ebp)
f011ff39:	85 c0                	test   %eax,%eax
f011ff3b:	75 c9                	jne    f011ff06 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011ff3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ff42:	c9                   	leave  
f011ff43:	c3                   	ret    

f011ff44 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011ff44:	55                   	push   %ebp
f011ff45:	89 e5                	mov    %esp,%ebp
f011ff47:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011ff4a:	8b 55 08             	mov    0x8(%ebp),%edx
f011ff4d:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff50:	01 d0                	add    %edx,%eax
f011ff52:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ff55:	eb 15                	jmp    f011ff6c <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ff57:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff5a:	8a 00                	mov    (%eax),%al
f011ff5c:	0f b6 d0             	movzbl %al,%edx
f011ff5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff62:	0f b6 c0             	movzbl %al,%eax
f011ff65:	39 c2                	cmp    %eax,%edx
f011ff67:	74 0d                	je     f011ff76 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ff69:	ff 45 08             	incl   0x8(%ebp)
f011ff6c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff6f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011ff72:	72 e3                	jb     f011ff57 <memfind+0x13>
f011ff74:	eb 01                	jmp    f011ff77 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011ff76:	90                   	nop
	return (void *) s;
f011ff77:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ff7a:	c9                   	leave  
f011ff7b:	c3                   	ret    

f011ff7c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011ff7c:	55                   	push   %ebp
f011ff7d:	89 e5                	mov    %esp,%ebp
f011ff7f:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011ff82:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011ff89:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ff90:	eb 03                	jmp    f011ff95 <strtol+0x19>
		s++;
f011ff92:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ff95:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff98:	8a 00                	mov    (%eax),%al
f011ff9a:	3c 20                	cmp    $0x20,%al
f011ff9c:	74 f4                	je     f011ff92 <strtol+0x16>
f011ff9e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffa1:	8a 00                	mov    (%eax),%al
f011ffa3:	3c 09                	cmp    $0x9,%al
f011ffa5:	74 eb                	je     f011ff92 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011ffa7:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffaa:	8a 00                	mov    (%eax),%al
f011ffac:	3c 2b                	cmp    $0x2b,%al
f011ffae:	75 05                	jne    f011ffb5 <strtol+0x39>
		s++;
f011ffb0:	ff 45 08             	incl   0x8(%ebp)
f011ffb3:	eb 13                	jmp    f011ffc8 <strtol+0x4c>
	else if (*s == '-')
f011ffb5:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffb8:	8a 00                	mov    (%eax),%al
f011ffba:	3c 2d                	cmp    $0x2d,%al
f011ffbc:	75 0a                	jne    f011ffc8 <strtol+0x4c>
		s++, neg = 1;
f011ffbe:	ff 45 08             	incl   0x8(%ebp)
f011ffc1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011ffc8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ffcc:	74 06                	je     f011ffd4 <strtol+0x58>
f011ffce:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011ffd2:	75 20                	jne    f011fff4 <strtol+0x78>
f011ffd4:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffd7:	8a 00                	mov    (%eax),%al
f011ffd9:	3c 30                	cmp    $0x30,%al
f011ffdb:	75 17                	jne    f011fff4 <strtol+0x78>
f011ffdd:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffe0:	40                   	inc    %eax
f011ffe1:	8a 00                	mov    (%eax),%al
f011ffe3:	3c 78                	cmp    $0x78,%al
f011ffe5:	75 0d                	jne    f011fff4 <strtol+0x78>
		s += 2, base = 16;
f011ffe7:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011ffeb:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011fff2:	eb 28                	jmp    f012001c <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011fff4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fff8:	75 15                	jne    f012000f <strtol+0x93>
f011fffa:	8b 45 08             	mov    0x8(%ebp),%eax
f011fffd:	8a 00                	mov    (%eax),%al
f011ffff:	3c 30                	cmp    $0x30,%al
f0120001:	75 0c                	jne    f012000f <strtol+0x93>
		s++, base = 8;
f0120003:	ff 45 08             	incl   0x8(%ebp)
f0120006:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f012000d:	eb 0d                	jmp    f012001c <strtol+0xa0>
	else if (base == 0)
f012000f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120013:	75 07                	jne    f012001c <strtol+0xa0>
		base = 10;
f0120015:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f012001c:	8b 45 08             	mov    0x8(%ebp),%eax
f012001f:	8a 00                	mov    (%eax),%al
f0120021:	3c 2f                	cmp    $0x2f,%al
f0120023:	7e 19                	jle    f012003e <strtol+0xc2>
f0120025:	8b 45 08             	mov    0x8(%ebp),%eax
f0120028:	8a 00                	mov    (%eax),%al
f012002a:	3c 39                	cmp    $0x39,%al
f012002c:	7f 10                	jg     f012003e <strtol+0xc2>
			dig = *s - '0';
f012002e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120031:	8a 00                	mov    (%eax),%al
f0120033:	0f be c0             	movsbl %al,%eax
f0120036:	83 e8 30             	sub    $0x30,%eax
f0120039:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012003c:	eb 42                	jmp    f0120080 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f012003e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120041:	8a 00                	mov    (%eax),%al
f0120043:	3c 60                	cmp    $0x60,%al
f0120045:	7e 19                	jle    f0120060 <strtol+0xe4>
f0120047:	8b 45 08             	mov    0x8(%ebp),%eax
f012004a:	8a 00                	mov    (%eax),%al
f012004c:	3c 7a                	cmp    $0x7a,%al
f012004e:	7f 10                	jg     f0120060 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0120050:	8b 45 08             	mov    0x8(%ebp),%eax
f0120053:	8a 00                	mov    (%eax),%al
f0120055:	0f be c0             	movsbl %al,%eax
f0120058:	83 e8 57             	sub    $0x57,%eax
f012005b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012005e:	eb 20                	jmp    f0120080 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0120060:	8b 45 08             	mov    0x8(%ebp),%eax
f0120063:	8a 00                	mov    (%eax),%al
f0120065:	3c 40                	cmp    $0x40,%al
f0120067:	7e 39                	jle    f01200a2 <strtol+0x126>
f0120069:	8b 45 08             	mov    0x8(%ebp),%eax
f012006c:	8a 00                	mov    (%eax),%al
f012006e:	3c 5a                	cmp    $0x5a,%al
f0120070:	7f 30                	jg     f01200a2 <strtol+0x126>
			dig = *s - 'A' + 10;
f0120072:	8b 45 08             	mov    0x8(%ebp),%eax
f0120075:	8a 00                	mov    (%eax),%al
f0120077:	0f be c0             	movsbl %al,%eax
f012007a:	83 e8 37             	sub    $0x37,%eax
f012007d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0120080:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120083:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120086:	7d 19                	jge    f01200a1 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0120088:	ff 45 08             	incl   0x8(%ebp)
f012008b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012008e:	0f af 45 10          	imul   0x10(%ebp),%eax
f0120092:	89 c2                	mov    %eax,%edx
f0120094:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120097:	01 d0                	add    %edx,%eax
f0120099:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f012009c:	e9 7b ff ff ff       	jmp    f012001c <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f01200a1:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f01200a2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01200a6:	74 08                	je     f01200b0 <strtol+0x134>
		*endptr = (char *) s;
f01200a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200ab:	8b 55 08             	mov    0x8(%ebp),%edx
f01200ae:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01200b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01200b4:	74 07                	je     f01200bd <strtol+0x141>
f01200b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01200b9:	f7 d8                	neg    %eax
f01200bb:	eb 03                	jmp    f01200c0 <strtol+0x144>
f01200bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01200c0:	c9                   	leave  
f01200c1:	c3                   	ret    

f01200c2 <ltostr>:

void
ltostr(long value, char *str)
{
f01200c2:	55                   	push   %ebp
f01200c3:	89 e5                	mov    %esp,%ebp
f01200c5:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f01200c8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f01200cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f01200d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01200da:	79 13                	jns    f01200ef <ltostr+0x2d>
	{
		neg = 1;
f01200dc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f01200e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200e6:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f01200e9:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f01200ec:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f01200ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01200f2:	b9 0a 00 00 00       	mov    $0xa,%ecx
f01200f7:	99                   	cltd   
f01200f8:	f7 f9                	idiv   %ecx
f01200fa:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f01200fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120100:	8d 50 01             	lea    0x1(%eax),%edx
f0120103:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120106:	89 c2                	mov    %eax,%edx
f0120108:	8b 45 0c             	mov    0xc(%ebp),%eax
f012010b:	01 d0                	add    %edx,%eax
f012010d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120110:	83 c2 30             	add    $0x30,%edx
f0120113:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0120115:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0120118:	b8 67 66 66 66       	mov    $0x66666667,%eax
f012011d:	f7 e9                	imul   %ecx
f012011f:	c1 fa 02             	sar    $0x2,%edx
f0120122:	89 c8                	mov    %ecx,%eax
f0120124:	c1 f8 1f             	sar    $0x1f,%eax
f0120127:	29 c2                	sub    %eax,%edx
f0120129:	89 d0                	mov    %edx,%eax
f012012b:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f012012e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120132:	75 bb                	jne    f01200ef <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0120134:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f012013b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012013e:	48                   	dec    %eax
f012013f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0120142:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120146:	74 3d                	je     f0120185 <ltostr+0xc3>
		start = 1 ;
f0120148:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f012014f:	eb 34                	jmp    f0120185 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0120151:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120157:	01 d0                	add    %edx,%eax
f0120159:	8a 00                	mov    (%eax),%al
f012015b:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f012015e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120161:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120164:	01 c2                	add    %eax,%edx
f0120166:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0120169:	8b 45 0c             	mov    0xc(%ebp),%eax
f012016c:	01 c8                	add    %ecx,%eax
f012016e:	8a 00                	mov    (%eax),%al
f0120170:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0120172:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120175:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120178:	01 c2                	add    %eax,%edx
f012017a:	8a 45 eb             	mov    -0x15(%ebp),%al
f012017d:	88 02                	mov    %al,(%edx)
		start++ ;
f012017f:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0120182:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0120185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120188:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f012018b:	7c c4                	jl     f0120151 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f012018d:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0120190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120193:	01 d0                	add    %edx,%eax
f0120195:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120198:	90                   	nop
f0120199:	c9                   	leave  
f012019a:	c3                   	ret    

f012019b <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f012019b:	55                   	push   %ebp
f012019c:	89 e5                	mov    %esp,%ebp
f012019e:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f01201a1:	ff 75 08             	pushl  0x8(%ebp)
f01201a4:	e8 73 fa ff ff       	call   f011fc1c <strlen>
f01201a9:	83 c4 04             	add    $0x4,%esp
f01201ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f01201af:	ff 75 0c             	pushl  0xc(%ebp)
f01201b2:	e8 65 fa ff ff       	call   f011fc1c <strlen>
f01201b7:	83 c4 04             	add    $0x4,%esp
f01201ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f01201bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f01201c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01201cb:	eb 17                	jmp    f01201e4 <strcconcat+0x49>
		final[s] = str1[s] ;
f01201cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01201d0:	8b 45 10             	mov    0x10(%ebp),%eax
f01201d3:	01 c2                	add    %eax,%edx
f01201d5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f01201d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01201db:	01 c8                	add    %ecx,%eax
f01201dd:	8a 00                	mov    (%eax),%al
f01201df:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f01201e1:	ff 45 fc             	incl   -0x4(%ebp)
f01201e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01201e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01201ea:	7c e1                	jl     f01201cd <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f01201ec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f01201f3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f01201fa:	eb 1f                	jmp    f012021b <strcconcat+0x80>
		final[s++] = str2[i] ;
f01201fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01201ff:	8d 50 01             	lea    0x1(%eax),%edx
f0120202:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0120205:	89 c2                	mov    %eax,%edx
f0120207:	8b 45 10             	mov    0x10(%ebp),%eax
f012020a:	01 c2                	add    %eax,%edx
f012020c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f012020f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120212:	01 c8                	add    %ecx,%eax
f0120214:	8a 00                	mov    (%eax),%al
f0120216:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0120218:	ff 45 f8             	incl   -0x8(%ebp)
f012021b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012021e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120221:	7c d9                	jl     f01201fc <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0120223:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120226:	8b 45 10             	mov    0x10(%ebp),%eax
f0120229:	01 d0                	add    %edx,%eax
f012022b:	c6 00 00             	movb   $0x0,(%eax)
}
f012022e:	90                   	nop
f012022f:	c9                   	leave  
f0120230:	c3                   	ret    

f0120231 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0120231:	55                   	push   %ebp
f0120232:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0120234:	8b 45 14             	mov    0x14(%ebp),%eax
f0120237:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f012023d:	8b 45 14             	mov    0x14(%ebp),%eax
f0120240:	8b 00                	mov    (%eax),%eax
f0120242:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120249:	8b 45 10             	mov    0x10(%ebp),%eax
f012024c:	01 d0                	add    %edx,%eax
f012024e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120254:	eb 0c                	jmp    f0120262 <strsplit+0x31>
			*string++ = 0;
f0120256:	8b 45 08             	mov    0x8(%ebp),%eax
f0120259:	8d 50 01             	lea    0x1(%eax),%edx
f012025c:	89 55 08             	mov    %edx,0x8(%ebp)
f012025f:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120262:	8b 45 08             	mov    0x8(%ebp),%eax
f0120265:	8a 00                	mov    (%eax),%al
f0120267:	84 c0                	test   %al,%al
f0120269:	74 18                	je     f0120283 <strsplit+0x52>
f012026b:	8b 45 08             	mov    0x8(%ebp),%eax
f012026e:	8a 00                	mov    (%eax),%al
f0120270:	0f be c0             	movsbl %al,%eax
f0120273:	50                   	push   %eax
f0120274:	ff 75 0c             	pushl  0xc(%ebp)
f0120277:	e8 32 fb ff ff       	call   f011fdae <strchr>
f012027c:	83 c4 08             	add    $0x8,%esp
f012027f:	85 c0                	test   %eax,%eax
f0120281:	75 d3                	jne    f0120256 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0120283:	8b 45 08             	mov    0x8(%ebp),%eax
f0120286:	8a 00                	mov    (%eax),%al
f0120288:	84 c0                	test   %al,%al
f012028a:	74 5a                	je     f01202e6 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f012028c:	8b 45 14             	mov    0x14(%ebp),%eax
f012028f:	8b 00                	mov    (%eax),%eax
f0120291:	83 f8 0f             	cmp    $0xf,%eax
f0120294:	75 07                	jne    f012029d <strsplit+0x6c>
		{
			return 0;
f0120296:	b8 00 00 00 00       	mov    $0x0,%eax
f012029b:	eb 66                	jmp    f0120303 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f012029d:	8b 45 14             	mov    0x14(%ebp),%eax
f01202a0:	8b 00                	mov    (%eax),%eax
f01202a2:	8d 48 01             	lea    0x1(%eax),%ecx
f01202a5:	8b 55 14             	mov    0x14(%ebp),%edx
f01202a8:	89 0a                	mov    %ecx,(%edx)
f01202aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01202b1:	8b 45 10             	mov    0x10(%ebp),%eax
f01202b4:	01 c2                	add    %eax,%edx
f01202b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01202b9:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f01202bb:	eb 03                	jmp    f01202c0 <strsplit+0x8f>
			string++;
f01202bd:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f01202c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01202c3:	8a 00                	mov    (%eax),%al
f01202c5:	84 c0                	test   %al,%al
f01202c7:	74 8b                	je     f0120254 <strsplit+0x23>
f01202c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01202cc:	8a 00                	mov    (%eax),%al
f01202ce:	0f be c0             	movsbl %al,%eax
f01202d1:	50                   	push   %eax
f01202d2:	ff 75 0c             	pushl  0xc(%ebp)
f01202d5:	e8 d4 fa ff ff       	call   f011fdae <strchr>
f01202da:	83 c4 08             	add    $0x8,%esp
f01202dd:	85 c0                	test   %eax,%eax
f01202df:	74 dc                	je     f01202bd <strsplit+0x8c>
			string++;
	}
f01202e1:	e9 6e ff ff ff       	jmp    f0120254 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f01202e6:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f01202e7:	8b 45 14             	mov    0x14(%ebp),%eax
f01202ea:	8b 00                	mov    (%eax),%eax
f01202ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01202f3:	8b 45 10             	mov    0x10(%ebp),%eax
f01202f6:	01 d0                	add    %edx,%eax
f01202f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f01202fe:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120303:	c9                   	leave  
f0120304:	c3                   	ret    

f0120305 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0120305:	55                   	push   %ebp
f0120306:	89 e5                	mov    %esp,%ebp
f0120308:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f012030b:	83 ec 04             	sub    $0x4,%esp
f012030e:	68 5c 13 13 f0       	push   $0xf013135c
f0120313:	68 3f 01 00 00       	push   $0x13f
f0120318:	68 7e 13 13 f0       	push   $0xf013137e
f012031d:	e8 17 00 fe ff       	call   f0100339 <_panic>

f0120322 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0120322:	55                   	push   %ebp
f0120323:	89 e5                	mov    %esp,%ebp
f0120325:	83 ec 18             	sub    $0x18,%esp
f0120328:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f012032f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120332:	89 c2                	mov    %eax,%edx
f0120334:	ec                   	in     (%dx),%al
f0120335:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120338:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f012033b:	0f b6 c0             	movzbl %al,%eax
f012033e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120341:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120344:	25 c0 00 00 00       	and    $0xc0,%eax
f0120349:	83 f8 40             	cmp    $0x40,%eax
f012034c:	75 10                	jne    f012035e <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f012034e:	83 ec 0c             	sub    $0xc,%esp
f0120351:	68 60 2d 6c f0       	push   $0xf06c2d60
f0120356:	e8 6d fd fe ff       	call   f01100c8 <wakeup_one>
f012035b:	83 c4 10             	add    $0x10,%esp
	}

}
f012035e:	90                   	nop
f012035f:	c9                   	leave  
f0120360:	c3                   	ret    

f0120361 <ide_init>:

void ide_init()
{
f0120361:	55                   	push   %ebp
f0120362:	89 e5                	mov    %esp,%ebp
f0120364:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0120367:	83 ec 08             	sub    $0x8,%esp
f012036a:	68 22 03 12 f0       	push   $0xf0120322
f012036f:	6a 0e                	push   $0xe
f0120371:	e8 03 df fe ff       	call   f010e279 <irq_install_handler>
f0120376:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120379:	83 ec 08             	sub    $0x8,%esp
f012037c:	68 8c 13 13 f0       	push   $0xf013138c
f0120381:	68 60 2d 6c f0       	push   $0xf06c2d60
f0120386:	e8 a3 fc fe ff       	call   f011002e <init_channel>
f012038b:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f012038e:	83 ec 08             	sub    $0x8,%esp
f0120391:	68 99 13 13 f0       	push   $0xf0131399
f0120396:	68 80 33 ac f0       	push   $0xf0ac3380
f012039b:	e8 9d f8 fe ff       	call   f010fc3d <init_spinlock>
f01203a0:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f01203a3:	90                   	nop
f01203a4:	c9                   	leave  
f01203a5:	c3                   	ret    

f01203a6 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f01203a6:	55                   	push   %ebp
f01203a7:	89 e5                	mov    %esp,%ebp
f01203a9:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01203ac:	90                   	nop
f01203ad:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01203b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01203b7:	89 c2                	mov    %eax,%edx
f01203b9:	ec                   	in     (%dx),%al
f01203ba:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f01203bd:	8a 45 ef             	mov    -0x11(%ebp),%al
f01203c0:	0f b6 c0             	movzbl %al,%eax
f01203c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01203c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203c9:	25 c0 00 00 00       	and    $0xc0,%eax
f01203ce:	83 f8 40             	cmp    $0x40,%eax
f01203d1:	75 da                	jne    f01203ad <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f01203d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01203d7:	74 24                	je     f01203fd <ide_wait_ready+0x57>
f01203d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203dc:	83 e0 21             	and    $0x21,%eax
f01203df:	85 c0                	test   %eax,%eax
f01203e1:	74 1a                	je     f01203fd <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f01203e3:	83 ec 0c             	sub    $0xc,%esp
f01203e6:	ff 75 f4             	pushl  -0xc(%ebp)
f01203e9:	ff 75 f4             	pushl  -0xc(%ebp)
f01203ec:	68 ac 13 13 f0       	push   $0xf01313ac
f01203f1:	6a 5d                	push   $0x5d
f01203f3:	68 cf 13 13 f0       	push   $0xf01313cf
f01203f8:	e8 3c ff fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f01203fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120402:	c9                   	leave  
f0120403:	c3                   	ret    

f0120404 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0120404:	55                   	push   %ebp
f0120405:	89 e5                	mov    %esp,%ebp
f0120407:	57                   	push   %edi
f0120408:	53                   	push   %ebx
f0120409:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f012040c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120413:	76 16                	jbe    f012042b <ide_read+0x27>
f0120415:	68 da 13 13 f0       	push   $0xf01313da
f012041a:	68 e7 13 13 f0       	push   $0xf01313e7
f012041f:	6a 68                	push   $0x68
f0120421:	68 cf 13 13 f0       	push   $0xf01313cf
f0120426:	e8 0e ff fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f012042b:	83 ec 0c             	sub    $0xc,%esp
f012042e:	6a 00                	push   $0x0
f0120430:	e8 71 ff ff ff       	call   f01203a6 <ide_wait_ready>
f0120435:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0120438:	8b 45 10             	mov    0x10(%ebp),%eax
f012043b:	0f b6 c0             	movzbl %al,%eax
f012043e:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120445:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120448:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012044b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012044e:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f012044f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120452:	0f b6 c0             	movzbl %al,%eax
f0120455:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012045c:	88 45 d3             	mov    %al,-0x2d(%ebp)
f012045f:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120462:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120465:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120466:	8b 45 08             	mov    0x8(%ebp),%eax
f0120469:	c1 e8 08             	shr    $0x8,%eax
f012046c:	0f b6 c0             	movzbl %al,%eax
f012046f:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120476:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120479:	8a 45 d4             	mov    -0x2c(%ebp),%al
f012047c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012047f:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120480:	8b 45 08             	mov    0x8(%ebp),%eax
f0120483:	c1 e8 10             	shr    $0x10,%eax
f0120486:	0f b6 c0             	movzbl %al,%eax
f0120489:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120490:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120493:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120496:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120499:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f012049a:	a1 10 2c 6c f0       	mov    0xf06c2c10,%eax
f012049f:	83 e0 01             	and    $0x1,%eax
f01204a2:	c1 e0 04             	shl    $0x4,%eax
f01204a5:	88 c2                	mov    %al,%dl
f01204a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01204aa:	c1 e8 18             	shr    $0x18,%eax
f01204ad:	83 e0 0f             	and    $0xf,%eax
f01204b0:	09 d0                	or     %edx,%eax
f01204b2:	83 c8 e0             	or     $0xffffffe0,%eax
f01204b5:	0f b6 c0             	movzbl %al,%eax
f01204b8:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f01204bf:	88 45 d6             	mov    %al,-0x2a(%ebp)
f01204c2:	8a 45 d6             	mov    -0x2a(%ebp),%al
f01204c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01204c8:	ee                   	out    %al,(%dx)
f01204c9:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f01204d0:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f01204d4:	8a 45 d7             	mov    -0x29(%ebp),%al
f01204d7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01204da:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01204db:	eb 55                	jmp    f0120532 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f01204dd:	83 ec 0c             	sub    $0xc,%esp
f01204e0:	6a 01                	push   $0x1
f01204e2:	e8 bf fe ff ff       	call   f01203a6 <ide_wait_ready>
f01204e7:	83 c4 10             	add    $0x10,%esp
f01204ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01204ed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01204f1:	79 05                	jns    f01204f8 <ide_read+0xf4>
			return r;
f01204f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01204f6:	eb 45                	jmp    f012053d <ide_read+0x139>
f01204f8:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01204ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120502:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120505:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f012050c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012050f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120512:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120515:	89 cb                	mov    %ecx,%ebx
f0120517:	89 df                	mov    %ebx,%edi
f0120519:	89 c1                	mov    %eax,%ecx
f012051b:	fc                   	cld    
f012051c:	f2 6d                	repnz insl (%dx),%es:(%edi)
f012051e:	89 c8                	mov    %ecx,%eax
f0120520:	89 fb                	mov    %edi,%ebx
f0120522:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120525:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120528:	ff 4d 10             	decl   0x10(%ebp)
f012052b:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120532:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120536:	75 a5                	jne    f01204dd <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0120538:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012053d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120540:	5b                   	pop    %ebx
f0120541:	5f                   	pop    %edi
f0120542:	5d                   	pop    %ebp
f0120543:	c3                   	ret    

f0120544 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0120544:	55                   	push   %ebp
f0120545:	89 e5                	mov    %esp,%ebp
f0120547:	56                   	push   %esi
f0120548:	53                   	push   %ebx
f0120549:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f012054c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120553:	76 19                	jbe    f012056e <ide_write+0x2a>
f0120555:	68 da 13 13 f0       	push   $0xf01313da
f012055a:	68 e7 13 13 f0       	push   $0xf01313e7
f012055f:	68 82 00 00 00       	push   $0x82
f0120564:	68 cf 13 13 f0       	push   $0xf01313cf
f0120569:	e8 cb fd fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f012056e:	83 ec 0c             	sub    $0xc,%esp
f0120571:	6a 00                	push   $0x0
f0120573:	e8 2e fe ff ff       	call   f01203a6 <ide_wait_ready>
f0120578:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f012057b:	8b 45 10             	mov    0x10(%ebp),%eax
f012057e:	0f b6 c0             	movzbl %al,%eax
f0120581:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120588:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f012058b:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012058e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120591:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120592:	8b 45 08             	mov    0x8(%ebp),%eax
f0120595:	0f b6 c0             	movzbl %al,%eax
f0120598:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012059f:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01205a2:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01205a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01205a8:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01205a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01205ac:	c1 e8 08             	shr    $0x8,%eax
f01205af:	0f b6 c0             	movzbl %al,%eax
f01205b2:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f01205b9:	88 45 d4             	mov    %al,-0x2c(%ebp)
f01205bc:	8a 45 d4             	mov    -0x2c(%ebp),%al
f01205bf:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01205c2:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f01205c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01205c6:	c1 e8 10             	shr    $0x10,%eax
f01205c9:	0f b6 c0             	movzbl %al,%eax
f01205cc:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f01205d3:	88 45 d5             	mov    %al,-0x2b(%ebp)
f01205d6:	8a 45 d5             	mov    -0x2b(%ebp),%al
f01205d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01205dc:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f01205dd:	a1 10 2c 6c f0       	mov    0xf06c2c10,%eax
f01205e2:	83 e0 01             	and    $0x1,%eax
f01205e5:	c1 e0 04             	shl    $0x4,%eax
f01205e8:	88 c2                	mov    %al,%dl
f01205ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01205ed:	c1 e8 18             	shr    $0x18,%eax
f01205f0:	83 e0 0f             	and    $0xf,%eax
f01205f3:	09 d0                	or     %edx,%eax
f01205f5:	83 c8 e0             	or     $0xffffffe0,%eax
f01205f8:	0f b6 c0             	movzbl %al,%eax
f01205fb:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120602:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120605:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120608:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012060b:	ee                   	out    %al,(%dx)
f012060c:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120613:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0120617:	8a 45 d7             	mov    -0x29(%ebp),%al
f012061a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012061d:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f012061e:	eb 55                	jmp    f0120675 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0120620:	83 ec 0c             	sub    $0xc,%esp
f0120623:	6a 01                	push   $0x1
f0120625:	e8 7c fd ff ff       	call   f01203a6 <ide_wait_ready>
f012062a:	83 c4 10             	add    $0x10,%esp
f012062d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120630:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120634:	79 05                	jns    f012063b <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0120636:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120639:	eb 45                	jmp    f0120680 <ide_write+0x13c>
f012063b:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120642:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120645:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120648:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f012064f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120652:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120655:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120658:	89 cb                	mov    %ecx,%ebx
f012065a:	89 de                	mov    %ebx,%esi
f012065c:	89 c1                	mov    %eax,%ecx
f012065e:	fc                   	cld    
f012065f:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0120661:	89 c8                	mov    %ecx,%eax
f0120663:	89 f3                	mov    %esi,%ebx
f0120665:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120668:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f012066b:	ff 4d 10             	decl   0x10(%ebp)
f012066e:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120675:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120679:	75 a5                	jne    f0120620 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f012067b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120680:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120683:	5b                   	pop    %ebx
f0120684:	5e                   	pop    %esi
f0120685:	5d                   	pop    %ebp
f0120686:	c3                   	ret    

f0120687 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120687:	55                   	push   %ebp
f0120688:	89 e5                	mov    %esp,%ebp
f012068a:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f012068d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120690:	83 e8 04             	sub    $0x4,%eax
f0120693:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120696:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120699:	8b 00                	mov    (%eax),%eax
f012069b:	83 e0 fe             	and    $0xfffffffe,%eax
}
f012069e:	c9                   	leave  
f012069f:	c3                   	ret    

f01206a0 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f01206a0:	55                   	push   %ebp
f01206a1:	89 e5                	mov    %esp,%ebp
f01206a3:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f01206a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01206a9:	83 e8 04             	sub    $0x4,%eax
f01206ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f01206af:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01206b2:	8b 00                	mov    (%eax),%eax
f01206b4:	83 e0 01             	and    $0x1,%eax
f01206b7:	85 c0                	test   %eax,%eax
f01206b9:	0f 94 c0             	sete   %al
}
f01206bc:	c9                   	leave  
f01206bd:	c3                   	ret    

f01206be <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f01206be:	55                   	push   %ebp
f01206bf:	89 e5                	mov    %esp,%ebp
f01206c1:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f01206c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f01206cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ce:	83 f8 02             	cmp    $0x2,%eax
f01206d1:	74 2b                	je     f01206fe <alloc_block+0x40>
f01206d3:	83 f8 02             	cmp    $0x2,%eax
f01206d6:	7f 07                	jg     f01206df <alloc_block+0x21>
f01206d8:	83 f8 01             	cmp    $0x1,%eax
f01206db:	74 0e                	je     f01206eb <alloc_block+0x2d>
f01206dd:	eb 58                	jmp    f0120737 <alloc_block+0x79>
f01206df:	83 f8 03             	cmp    $0x3,%eax
f01206e2:	74 2d                	je     f0120711 <alloc_block+0x53>
f01206e4:	83 f8 04             	cmp    $0x4,%eax
f01206e7:	74 3b                	je     f0120724 <alloc_block+0x66>
f01206e9:	eb 4c                	jmp    f0120737 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f01206eb:	83 ec 0c             	sub    $0xc,%esp
f01206ee:	ff 75 08             	pushl  0x8(%ebp)
f01206f1:	e8 11 03 00 00       	call   f0120a07 <alloc_block_FF>
f01206f6:	83 c4 10             	add    $0x10,%esp
f01206f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01206fc:	eb 4a                	jmp    f0120748 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f01206fe:	83 ec 0c             	sub    $0xc,%esp
f0120701:	ff 75 08             	pushl  0x8(%ebp)
f0120704:	e8 fa 19 00 00       	call   f0122103 <alloc_block_NF>
f0120709:	83 c4 10             	add    $0x10,%esp
f012070c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012070f:	eb 37                	jmp    f0120748 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0120711:	83 ec 0c             	sub    $0xc,%esp
f0120714:	ff 75 08             	pushl  0x8(%ebp)
f0120717:	e8 a7 07 00 00       	call   f0120ec3 <alloc_block_BF>
f012071c:	83 c4 10             	add    $0x10,%esp
f012071f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120722:	eb 24                	jmp    f0120748 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f0120724:	83 ec 0c             	sub    $0xc,%esp
f0120727:	ff 75 08             	pushl  0x8(%ebp)
f012072a:	e8 b7 19 00 00       	call   f01220e6 <alloc_block_WF>
f012072f:	83 c4 10             	add    $0x10,%esp
f0120732:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120735:	eb 11                	jmp    f0120748 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f0120737:	83 ec 0c             	sub    $0xc,%esp
f012073a:	68 fc 13 13 f0       	push   $0xf01313fc
f012073f:	e8 47 08 fe ff       	call   f0100f8b <cprintf>
f0120744:	83 c4 10             	add    $0x10,%esp
		break;
f0120747:	90                   	nop
	}
	return va;
f0120748:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f012074b:	c9                   	leave  
f012074c:	c3                   	ret    

f012074d <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f012074d:	55                   	push   %ebp
f012074e:	89 e5                	mov    %esp,%ebp
f0120750:	53                   	push   %ebx
f0120751:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0120754:	83 ec 0c             	sub    $0xc,%esp
f0120757:	68 1c 14 13 f0       	push   $0xf013141c
f012075c:	e8 2a 08 fe ff       	call   f0100f8b <cprintf>
f0120761:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0120764:	83 ec 0c             	sub    $0xc,%esp
f0120767:	68 47 14 13 f0       	push   $0xf0131447
f012076c:	e8 1a 08 fe ff       	call   f0100f8b <cprintf>
f0120771:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0120774:	8b 45 08             	mov    0x8(%ebp),%eax
f0120777:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012077a:	eb 37                	jmp    f01207b3 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f012077c:	83 ec 0c             	sub    $0xc,%esp
f012077f:	ff 75 f4             	pushl  -0xc(%ebp)
f0120782:	e8 19 ff ff ff       	call   f01206a0 <is_free_block>
f0120787:	83 c4 10             	add    $0x10,%esp
f012078a:	0f be d8             	movsbl %al,%ebx
f012078d:	83 ec 0c             	sub    $0xc,%esp
f0120790:	ff 75 f4             	pushl  -0xc(%ebp)
f0120793:	e8 ef fe ff ff       	call   f0120687 <get_block_size>
f0120798:	83 c4 10             	add    $0x10,%esp
f012079b:	83 ec 04             	sub    $0x4,%esp
f012079e:	53                   	push   %ebx
f012079f:	50                   	push   %eax
f01207a0:	68 5f 14 13 f0       	push   $0xf013145f
f01207a5:	e8 e1 07 fe ff       	call   f0100f8b <cprintf>
f01207aa:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f01207ad:	8b 45 10             	mov    0x10(%ebp),%eax
f01207b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01207b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01207b7:	74 07                	je     f01207c0 <print_blocks_list+0x73>
f01207b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207bc:	8b 00                	mov    (%eax),%eax
f01207be:	eb 05                	jmp    f01207c5 <print_blocks_list+0x78>
f01207c0:	b8 00 00 00 00       	mov    $0x0,%eax
f01207c5:	89 45 10             	mov    %eax,0x10(%ebp)
f01207c8:	8b 45 10             	mov    0x10(%ebp),%eax
f01207cb:	85 c0                	test   %eax,%eax
f01207cd:	75 ad                	jne    f012077c <print_blocks_list+0x2f>
f01207cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01207d3:	75 a7                	jne    f012077c <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f01207d5:	83 ec 0c             	sub    $0xc,%esp
f01207d8:	68 1c 14 13 f0       	push   $0xf013141c
f01207dd:	e8 a9 07 fe ff       	call   f0100f8b <cprintf>
f01207e2:	83 c4 10             	add    $0x10,%esp

}
f01207e5:	90                   	nop
f01207e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01207e9:	c9                   	leave  
f01207ea:	c3                   	ret    

f01207eb <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f01207eb:	55                   	push   %ebp
f01207ec:	89 e5                	mov    %esp,%ebp
f01207ee:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f01207f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01207f4:	83 e0 01             	and    $0x1,%eax
f01207f7:	85 c0                	test   %eax,%eax
f01207f9:	74 03                	je     f01207fe <initialize_dynamic_allocator+0x13>
f01207fb:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01207fe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120802:	0f 84 c7 01 00 00    	je     f01209cf <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f0120808:	c7 05 14 2c 6c f0 01 	movl   $0x1,0xf06c2c14
f012080f:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f0120812:	8b 55 08             	mov    0x8(%ebp),%edx
f0120815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120818:	01 d0                	add    %edx,%eax
f012081a:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f012081f:	0f 87 ad 01 00 00    	ja     f01209d2 <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f0120825:	8b 45 08             	mov    0x8(%ebp),%eax
f0120828:	85 c0                	test   %eax,%eax
f012082a:	0f 89 a5 01 00 00    	jns    f01209d5 <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f0120830:	8b 55 08             	mov    0x8(%ebp),%edx
f0120833:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120836:	01 d0                	add    %edx,%eax
f0120838:	83 e8 04             	sub    $0x4,%eax
f012083b:	a3 d4 35 ec f0       	mov    %eax,0xf0ec35d4
     struct BlockElement * element = NULL;
f0120840:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120847:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f012084c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012084f:	e9 87 00 00 00       	jmp    f01208db <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0120854:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120858:	75 14                	jne    f012086e <initialize_dynamic_allocator+0x83>
f012085a:	83 ec 04             	sub    $0x4,%esp
f012085d:	68 77 14 13 f0       	push   $0xf0131477
f0120862:	6a 79                	push   $0x79
f0120864:	68 95 14 13 f0       	push   $0xf0131495
f0120869:	e8 cb fa fd ff       	call   f0100339 <_panic>
f012086e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120871:	8b 00                	mov    (%eax),%eax
f0120873:	85 c0                	test   %eax,%eax
f0120875:	74 10                	je     f0120887 <initialize_dynamic_allocator+0x9c>
f0120877:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012087a:	8b 00                	mov    (%eax),%eax
f012087c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012087f:	8b 52 04             	mov    0x4(%edx),%edx
f0120882:	89 50 04             	mov    %edx,0x4(%eax)
f0120885:	eb 0b                	jmp    f0120892 <initialize_dynamic_allocator+0xa7>
f0120887:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012088a:	8b 40 04             	mov    0x4(%eax),%eax
f012088d:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0120892:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120895:	8b 40 04             	mov    0x4(%eax),%eax
f0120898:	85 c0                	test   %eax,%eax
f012089a:	74 0f                	je     f01208ab <initialize_dynamic_allocator+0xc0>
f012089c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012089f:	8b 40 04             	mov    0x4(%eax),%eax
f01208a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01208a5:	8b 12                	mov    (%edx),%edx
f01208a7:	89 10                	mov    %edx,(%eax)
f01208a9:	eb 0a                	jmp    f01208b5 <initialize_dynamic_allocator+0xca>
f01208ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208ae:	8b 00                	mov    (%eax),%eax
f01208b0:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01208b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01208be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208c1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01208c8:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01208cd:	48                   	dec    %eax
f01208ce:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f01208d3:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f01208d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01208db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208df:	74 07                	je     f01208e8 <initialize_dynamic_allocator+0xfd>
f01208e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208e4:	8b 00                	mov    (%eax),%eax
f01208e6:	eb 05                	jmp    f01208ed <initialize_dynamic_allocator+0x102>
f01208e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01208ed:	a3 98 2f ac f0       	mov    %eax,0xf0ac2f98
f01208f2:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f01208f7:	85 c0                	test   %eax,%eax
f01208f9:	0f 85 55 ff ff ff    	jne    f0120854 <initialize_dynamic_allocator+0x69>
f01208ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120903:	0f 85 4b ff ff ff    	jne    f0120854 <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f0120909:	8b 45 08             	mov    0x8(%ebp),%eax
f012090c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f012090f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120912:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f0120918:	a1 d4 35 ec f0       	mov    0xf0ec35d4,%eax
f012091d:	a3 f0 33 ac f0       	mov    %eax,0xf0ac33f0
    end_block->info = 1;
f0120922:	a1 f0 33 ac f0       	mov    0xf0ac33f0,%eax
f0120927:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f012092d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120930:	83 c0 08             	add    $0x8,%eax
f0120933:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120936:	8b 45 08             	mov    0x8(%ebp),%eax
f0120939:	83 c0 04             	add    $0x4,%eax
f012093c:	8b 55 0c             	mov    0xc(%ebp),%edx
f012093f:	83 ea 08             	sub    $0x8,%edx
f0120942:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120944:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120947:	8b 45 08             	mov    0x8(%ebp),%eax
f012094a:	01 d0                	add    %edx,%eax
f012094c:	83 e8 08             	sub    $0x8,%eax
f012094f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120952:	83 ea 08             	sub    $0x8,%edx
f0120955:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120957:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012095a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0120960:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120963:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f012096a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012096e:	75 17                	jne    f0120987 <initialize_dynamic_allocator+0x19c>
f0120970:	83 ec 04             	sub    $0x4,%esp
f0120973:	68 b0 14 13 f0       	push   $0xf01314b0
f0120978:	68 90 00 00 00       	push   $0x90
f012097d:	68 95 14 13 f0       	push   $0xf0131495
f0120982:	e8 b2 f9 fd ff       	call   f0100339 <_panic>
f0120987:	8b 15 90 2f ac f0    	mov    0xf0ac2f90,%edx
f012098d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120990:	89 10                	mov    %edx,(%eax)
f0120992:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120995:	8b 00                	mov    (%eax),%eax
f0120997:	85 c0                	test   %eax,%eax
f0120999:	74 0d                	je     f01209a8 <initialize_dynamic_allocator+0x1bd>
f012099b:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f01209a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01209a3:	89 50 04             	mov    %edx,0x4(%eax)
f01209a6:	eb 08                	jmp    f01209b0 <initialize_dynamic_allocator+0x1c5>
f01209a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209ab:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f01209b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209b3:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01209b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209bb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01209c2:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01209c7:	40                   	inc    %eax
f01209c8:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f01209cd:	eb 07                	jmp    f01209d6 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f01209cf:	90                   	nop
f01209d0:	eb 04                	jmp    f01209d6 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f01209d2:	90                   	nop
f01209d3:	eb 01                	jmp    f01209d6 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f01209d5:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f01209d6:	c9                   	leave  
f01209d7:	c3                   	ret    

f01209d8 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f01209d8:	55                   	push   %ebp
f01209d9:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f01209db:	8b 45 10             	mov    0x10(%ebp),%eax
f01209de:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f01209e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01209e4:	8d 50 fc             	lea    -0x4(%eax),%edx
f01209e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209ea:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f01209ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01209ef:	83 e8 04             	sub    $0x4,%eax
f01209f2:	8b 00                	mov    (%eax),%eax
f01209f4:	83 e0 fe             	and    $0xfffffffe,%eax
f01209f7:	8d 50 f8             	lea    -0x8(%eax),%edx
f01209fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01209fd:	01 c2                	add    %eax,%edx
f01209ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a02:	89 02                	mov    %eax,(%edx)
}
f0120a04:	90                   	nop
f0120a05:	5d                   	pop    %ebp
f0120a06:	c3                   	ret    

f0120a07 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f0120a07:	55                   	push   %ebp
f0120a08:	89 e5                	mov    %esp,%ebp
f0120a0a:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120a0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a10:	83 e0 01             	and    $0x1,%eax
f0120a13:	85 c0                	test   %eax,%eax
f0120a15:	74 03                	je     f0120a1a <alloc_block_FF+0x13>
f0120a17:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120a1a:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120a1e:	77 07                	ja     f0120a27 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120a20:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120a27:	a1 14 2c 6c f0       	mov    0xf06c2c14,%eax
f0120a2c:	85 c0                	test   %eax,%eax
f0120a2e:	75 73                	jne    f0120aa3 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120a30:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a33:	83 c0 10             	add    $0x10,%eax
f0120a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120a39:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0120a40:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120a43:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a46:	01 d0                	add    %edx,%eax
f0120a48:	48                   	dec    %eax
f0120a49:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120a4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120a4f:	ba 00 00 00 00       	mov    $0x0,%edx
f0120a54:	f7 75 ec             	divl   -0x14(%ebp)
f0120a57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120a5a:	29 d0                	sub    %edx,%eax
f0120a5c:	c1 e8 0c             	shr    $0xc,%eax
f0120a5f:	83 ec 0c             	sub    $0xc,%esp
f0120a62:	50                   	push   %eax
f0120a63:	e8 8f 89 fe ff       	call   f01093f7 <sbrk>
f0120a68:	83 c4 10             	add    $0x10,%esp
f0120a6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120a6e:	83 ec 0c             	sub    $0xc,%esp
f0120a71:	6a 00                	push   $0x0
f0120a73:	e8 7f 89 fe ff       	call   f01093f7 <sbrk>
f0120a78:	83 c4 10             	add    $0x10,%esp
f0120a7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120a7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120a81:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120a84:	83 ec 08             	sub    $0x8,%esp
f0120a87:	50                   	push   %eax
f0120a88:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120a8b:	e8 5b fd ff ff       	call   f01207eb <initialize_dynamic_allocator>
f0120a90:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120a93:	83 ec 0c             	sub    $0xc,%esp
f0120a96:	68 d3 14 13 f0       	push   $0xf01314d3
f0120a9b:	e8 eb 04 fe ff       	call   f0100f8b <cprintf>
f0120aa0:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120aa3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120aa7:	75 0a                	jne    f0120ab3 <alloc_block_FF+0xac>
	        return NULL;
f0120aa9:	b8 00 00 00 00       	mov    $0x0,%eax
f0120aae:	e9 0e 04 00 00       	jmp    f0120ec1 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120ab3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120aba:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0120abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120ac2:	e9 f3 02 00 00       	jmp    f0120dba <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120aca:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120acd:	83 ec 0c             	sub    $0xc,%esp
f0120ad0:	ff 75 bc             	pushl  -0x44(%ebp)
f0120ad3:	e8 af fb ff ff       	call   f0120687 <get_block_size>
f0120ad8:	83 c4 10             	add    $0x10,%esp
f0120adb:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120ade:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ae1:	83 c0 08             	add    $0x8,%eax
f0120ae4:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120ae7:	0f 87 c5 02 00 00    	ja     f0120db2 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120aed:	8b 45 08             	mov    0x8(%ebp),%eax
f0120af0:	83 c0 18             	add    $0x18,%eax
f0120af3:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120af6:	0f 87 19 02 00 00    	ja     f0120d15 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120afc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120aff:	2b 45 08             	sub    0x8(%ebp),%eax
f0120b02:	83 e8 08             	sub    $0x8,%eax
f0120b05:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120b08:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b0b:	8d 50 08             	lea    0x8(%eax),%edx
f0120b0e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120b11:	01 d0                	add    %edx,%eax
f0120b13:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120b16:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b19:	83 c0 08             	add    $0x8,%eax
f0120b1c:	83 ec 04             	sub    $0x4,%esp
f0120b1f:	6a 01                	push   $0x1
f0120b21:	50                   	push   %eax
f0120b22:	ff 75 bc             	pushl  -0x44(%ebp)
f0120b25:	e8 ae fe ff ff       	call   f01209d8 <set_block_data>
f0120b2a:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b30:	8b 40 04             	mov    0x4(%eax),%eax
f0120b33:	85 c0                	test   %eax,%eax
f0120b35:	75 68                	jne    f0120b9f <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120b37:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120b3b:	75 17                	jne    f0120b54 <alloc_block_FF+0x14d>
f0120b3d:	83 ec 04             	sub    $0x4,%esp
f0120b40:	68 b0 14 13 f0       	push   $0xf01314b0
f0120b45:	68 d7 00 00 00       	push   $0xd7
f0120b4a:	68 95 14 13 f0       	push   $0xf0131495
f0120b4f:	e8 e5 f7 fd ff       	call   f0100339 <_panic>
f0120b54:	8b 15 90 2f ac f0    	mov    0xf0ac2f90,%edx
f0120b5a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b5d:	89 10                	mov    %edx,(%eax)
f0120b5f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b62:	8b 00                	mov    (%eax),%eax
f0120b64:	85 c0                	test   %eax,%eax
f0120b66:	74 0d                	je     f0120b75 <alloc_block_FF+0x16e>
f0120b68:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0120b6d:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120b70:	89 50 04             	mov    %edx,0x4(%eax)
f0120b73:	eb 08                	jmp    f0120b7d <alloc_block_FF+0x176>
f0120b75:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b78:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0120b7d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b80:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0120b85:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b88:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b8f:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0120b94:	40                   	inc    %eax
f0120b95:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0120b9a:	e9 dc 00 00 00       	jmp    f0120c7b <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120b9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ba2:	8b 00                	mov    (%eax),%eax
f0120ba4:	85 c0                	test   %eax,%eax
f0120ba6:	75 65                	jne    f0120c0d <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120ba8:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120bac:	75 17                	jne    f0120bc5 <alloc_block_FF+0x1be>
f0120bae:	83 ec 04             	sub    $0x4,%esp
f0120bb1:	68 e4 14 13 f0       	push   $0xf01314e4
f0120bb6:	68 db 00 00 00       	push   $0xdb
f0120bbb:	68 95 14 13 f0       	push   $0xf0131495
f0120bc0:	e8 74 f7 fd ff       	call   f0100339 <_panic>
f0120bc5:	8b 15 94 2f ac f0    	mov    0xf0ac2f94,%edx
f0120bcb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bce:	89 50 04             	mov    %edx,0x4(%eax)
f0120bd1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bd4:	8b 40 04             	mov    0x4(%eax),%eax
f0120bd7:	85 c0                	test   %eax,%eax
f0120bd9:	74 0c                	je     f0120be7 <alloc_block_FF+0x1e0>
f0120bdb:	a1 94 2f ac f0       	mov    0xf0ac2f94,%eax
f0120be0:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120be3:	89 10                	mov    %edx,(%eax)
f0120be5:	eb 08                	jmp    f0120bef <alloc_block_FF+0x1e8>
f0120be7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bea:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0120bef:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bf2:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0120bf7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bfa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120c00:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0120c05:	40                   	inc    %eax
f0120c06:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0120c0b:	eb 6e                	jmp    f0120c7b <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f0120c0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c11:	74 06                	je     f0120c19 <alloc_block_FF+0x212>
f0120c13:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120c17:	75 17                	jne    f0120c30 <alloc_block_FF+0x229>
f0120c19:	83 ec 04             	sub    $0x4,%esp
f0120c1c:	68 08 15 13 f0       	push   $0xf0131508
f0120c21:	68 df 00 00 00       	push   $0xdf
f0120c26:	68 95 14 13 f0       	push   $0xf0131495
f0120c2b:	e8 09 f7 fd ff       	call   f0100339 <_panic>
f0120c30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c33:	8b 10                	mov    (%eax),%edx
f0120c35:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c38:	89 10                	mov    %edx,(%eax)
f0120c3a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c3d:	8b 00                	mov    (%eax),%eax
f0120c3f:	85 c0                	test   %eax,%eax
f0120c41:	74 0b                	je     f0120c4e <alloc_block_FF+0x247>
f0120c43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c46:	8b 00                	mov    (%eax),%eax
f0120c48:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120c4b:	89 50 04             	mov    %edx,0x4(%eax)
f0120c4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c51:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120c54:	89 10                	mov    %edx,(%eax)
f0120c56:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c59:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120c5c:	89 50 04             	mov    %edx,0x4(%eax)
f0120c5f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c62:	8b 00                	mov    (%eax),%eax
f0120c64:	85 c0                	test   %eax,%eax
f0120c66:	75 08                	jne    f0120c70 <alloc_block_FF+0x269>
f0120c68:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c6b:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0120c70:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0120c75:	40                   	inc    %eax
f0120c76:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120c7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c7f:	75 17                	jne    f0120c98 <alloc_block_FF+0x291>
f0120c81:	83 ec 04             	sub    $0x4,%esp
f0120c84:	68 77 14 13 f0       	push   $0xf0131477
f0120c89:	68 e1 00 00 00       	push   $0xe1
f0120c8e:	68 95 14 13 f0       	push   $0xf0131495
f0120c93:	e8 a1 f6 fd ff       	call   f0100339 <_panic>
f0120c98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c9b:	8b 00                	mov    (%eax),%eax
f0120c9d:	85 c0                	test   %eax,%eax
f0120c9f:	74 10                	je     f0120cb1 <alloc_block_FF+0x2aa>
f0120ca1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ca4:	8b 00                	mov    (%eax),%eax
f0120ca6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120ca9:	8b 52 04             	mov    0x4(%edx),%edx
f0120cac:	89 50 04             	mov    %edx,0x4(%eax)
f0120caf:	eb 0b                	jmp    f0120cbc <alloc_block_FF+0x2b5>
f0120cb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cb4:	8b 40 04             	mov    0x4(%eax),%eax
f0120cb7:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0120cbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cbf:	8b 40 04             	mov    0x4(%eax),%eax
f0120cc2:	85 c0                	test   %eax,%eax
f0120cc4:	74 0f                	je     f0120cd5 <alloc_block_FF+0x2ce>
f0120cc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cc9:	8b 40 04             	mov    0x4(%eax),%eax
f0120ccc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120ccf:	8b 12                	mov    (%edx),%edx
f0120cd1:	89 10                	mov    %edx,(%eax)
f0120cd3:	eb 0a                	jmp    f0120cdf <alloc_block_FF+0x2d8>
f0120cd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cd8:	8b 00                	mov    (%eax),%eax
f0120cda:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0120cdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ce2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120ce8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ceb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120cf2:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0120cf7:	48                   	dec    %eax
f0120cf8:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
				set_block_data(new_block_va, remaining_size, 0);
f0120cfd:	83 ec 04             	sub    $0x4,%esp
f0120d00:	6a 00                	push   $0x0
f0120d02:	ff 75 b4             	pushl  -0x4c(%ebp)
f0120d05:	ff 75 b0             	pushl  -0x50(%ebp)
f0120d08:	e8 cb fc ff ff       	call   f01209d8 <set_block_data>
f0120d0d:	83 c4 10             	add    $0x10,%esp
f0120d10:	e9 95 00 00 00       	jmp    f0120daa <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f0120d15:	83 ec 04             	sub    $0x4,%esp
f0120d18:	6a 01                	push   $0x1
f0120d1a:	ff 75 b8             	pushl  -0x48(%ebp)
f0120d1d:	ff 75 bc             	pushl  -0x44(%ebp)
f0120d20:	e8 b3 fc ff ff       	call   f01209d8 <set_block_data>
f0120d25:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0120d28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d2c:	75 17                	jne    f0120d45 <alloc_block_FF+0x33e>
f0120d2e:	83 ec 04             	sub    $0x4,%esp
f0120d31:	68 77 14 13 f0       	push   $0xf0131477
f0120d36:	68 e8 00 00 00       	push   $0xe8
f0120d3b:	68 95 14 13 f0       	push   $0xf0131495
f0120d40:	e8 f4 f5 fd ff       	call   f0100339 <_panic>
f0120d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d48:	8b 00                	mov    (%eax),%eax
f0120d4a:	85 c0                	test   %eax,%eax
f0120d4c:	74 10                	je     f0120d5e <alloc_block_FF+0x357>
f0120d4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d51:	8b 00                	mov    (%eax),%eax
f0120d53:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d56:	8b 52 04             	mov    0x4(%edx),%edx
f0120d59:	89 50 04             	mov    %edx,0x4(%eax)
f0120d5c:	eb 0b                	jmp    f0120d69 <alloc_block_FF+0x362>
f0120d5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d61:	8b 40 04             	mov    0x4(%eax),%eax
f0120d64:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0120d69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d6c:	8b 40 04             	mov    0x4(%eax),%eax
f0120d6f:	85 c0                	test   %eax,%eax
f0120d71:	74 0f                	je     f0120d82 <alloc_block_FF+0x37b>
f0120d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d76:	8b 40 04             	mov    0x4(%eax),%eax
f0120d79:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d7c:	8b 12                	mov    (%edx),%edx
f0120d7e:	89 10                	mov    %edx,(%eax)
f0120d80:	eb 0a                	jmp    f0120d8c <alloc_block_FF+0x385>
f0120d82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d85:	8b 00                	mov    (%eax),%eax
f0120d87:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0120d8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d8f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120d95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d98:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120d9f:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0120da4:	48                   	dec    %eax
f0120da5:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
	            }
	            return va;
f0120daa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120dad:	e9 0f 01 00 00       	jmp    f0120ec1 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120db2:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f0120db7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120dba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120dbe:	74 07                	je     f0120dc7 <alloc_block_FF+0x3c0>
f0120dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dc3:	8b 00                	mov    (%eax),%eax
f0120dc5:	eb 05                	jmp    f0120dcc <alloc_block_FF+0x3c5>
f0120dc7:	b8 00 00 00 00       	mov    $0x0,%eax
f0120dcc:	a3 98 2f ac f0       	mov    %eax,0xf0ac2f98
f0120dd1:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f0120dd6:	85 c0                	test   %eax,%eax
f0120dd8:	0f 85 e9 fc ff ff    	jne    f0120ac7 <alloc_block_FF+0xc0>
f0120dde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120de2:	0f 85 df fc ff ff    	jne    f0120ac7 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f0120de8:	8b 45 08             	mov    0x8(%ebp),%eax
f0120deb:	83 c0 08             	add    $0x8,%eax
f0120dee:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120df1:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0120df8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120dfb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120dfe:	01 d0                	add    %edx,%eax
f0120e00:	48                   	dec    %eax
f0120e01:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0120e04:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120e07:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e0c:	f7 75 d8             	divl   -0x28(%ebp)
f0120e0f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120e12:	29 d0                	sub    %edx,%eax
f0120e14:	c1 e8 0c             	shr    $0xc,%eax
f0120e17:	83 ec 0c             	sub    $0xc,%esp
f0120e1a:	50                   	push   %eax
f0120e1b:	e8 d7 85 fe ff       	call   f01093f7 <sbrk>
f0120e20:	83 c4 10             	add    $0x10,%esp
f0120e23:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f0120e26:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0120e2a:	75 0a                	jne    f0120e36 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f0120e2c:	b8 00 00 00 00       	mov    $0x0,%eax
f0120e31:	e9 8b 00 00 00       	jmp    f0120ec1 <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120e36:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0120e3d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120e40:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120e43:	01 d0                	add    %edx,%eax
f0120e45:	48                   	dec    %eax
f0120e46:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0120e49:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120e4c:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e51:	f7 75 cc             	divl   -0x34(%ebp)
f0120e54:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120e57:	29 d0                	sub    %edx,%eax
f0120e59:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120e5c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120e5f:	01 d0                	add    %edx,%eax
f0120e61:	a3 f0 33 ac f0       	mov    %eax,0xf0ac33f0
			end_block->info = 1;
f0120e66:	a1 f0 33 ac f0       	mov    0xf0ac33f0,%eax
f0120e6b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120e71:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120e78:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120e7b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120e7e:	01 d0                	add    %edx,%eax
f0120e80:	48                   	dec    %eax
f0120e81:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120e84:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120e87:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e8c:	f7 75 c4             	divl   -0x3c(%ebp)
f0120e8f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120e92:	29 d0                	sub    %edx,%eax
f0120e94:	83 ec 04             	sub    $0x4,%esp
f0120e97:	6a 01                	push   $0x1
f0120e99:	50                   	push   %eax
f0120e9a:	ff 75 d0             	pushl  -0x30(%ebp)
f0120e9d:	e8 36 fb ff ff       	call   f01209d8 <set_block_data>
f0120ea2:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f0120ea5:	83 ec 0c             	sub    $0xc,%esp
f0120ea8:	ff 75 d0             	pushl  -0x30(%ebp)
f0120eab:	e8 1b 0a 00 00       	call   f01218cb <free_block>
f0120eb0:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f0120eb3:	83 ec 0c             	sub    $0xc,%esp
f0120eb6:	ff 75 08             	pushl  0x8(%ebp)
f0120eb9:	e8 49 fb ff ff       	call   f0120a07 <alloc_block_FF>
f0120ebe:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0120ec1:	c9                   	leave  
f0120ec2:	c3                   	ret    

f0120ec3 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0120ec3:	55                   	push   %ebp
f0120ec4:	89 e5                	mov    %esp,%ebp
f0120ec6:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ecc:	83 e0 01             	and    $0x1,%eax
f0120ecf:	85 c0                	test   %eax,%eax
f0120ed1:	74 03                	je     f0120ed6 <alloc_block_BF+0x13>
f0120ed3:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120ed6:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120eda:	77 07                	ja     f0120ee3 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120edc:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120ee3:	a1 14 2c 6c f0       	mov    0xf06c2c14,%eax
f0120ee8:	85 c0                	test   %eax,%eax
f0120eea:	75 73                	jne    f0120f5f <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120eec:	8b 45 08             	mov    0x8(%ebp),%eax
f0120eef:	83 c0 10             	add    $0x10,%eax
f0120ef2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120ef5:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0120efc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120eff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120f02:	01 d0                	add    %edx,%eax
f0120f04:	48                   	dec    %eax
f0120f05:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120f08:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f0b:	ba 00 00 00 00       	mov    $0x0,%edx
f0120f10:	f7 75 e0             	divl   -0x20(%ebp)
f0120f13:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f16:	29 d0                	sub    %edx,%eax
f0120f18:	c1 e8 0c             	shr    $0xc,%eax
f0120f1b:	83 ec 0c             	sub    $0xc,%esp
f0120f1e:	50                   	push   %eax
f0120f1f:	e8 d3 84 fe ff       	call   f01093f7 <sbrk>
f0120f24:	83 c4 10             	add    $0x10,%esp
f0120f27:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120f2a:	83 ec 0c             	sub    $0xc,%esp
f0120f2d:	6a 00                	push   $0x0
f0120f2f:	e8 c3 84 fe ff       	call   f01093f7 <sbrk>
f0120f34:	83 c4 10             	add    $0x10,%esp
f0120f37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120f3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120f3d:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0120f40:	83 ec 08             	sub    $0x8,%esp
f0120f43:	50                   	push   %eax
f0120f44:	ff 75 d8             	pushl  -0x28(%ebp)
f0120f47:	e8 9f f8 ff ff       	call   f01207eb <initialize_dynamic_allocator>
f0120f4c:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120f4f:	83 ec 0c             	sub    $0xc,%esp
f0120f52:	68 d3 14 13 f0       	push   $0xf01314d3
f0120f57:	e8 2f 00 fe ff       	call   f0100f8b <cprintf>
f0120f5c:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f0120f5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0120f66:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f0120f6d:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f0120f74:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0120f7b:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0120f80:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120f83:	e9 1d 01 00 00       	jmp    f01210a5 <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0120f88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f8b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f0120f8e:	83 ec 0c             	sub    $0xc,%esp
f0120f91:	ff 75 a8             	pushl  -0x58(%ebp)
f0120f94:	e8 ee f6 ff ff       	call   f0120687 <get_block_size>
f0120f99:	83 c4 10             	add    $0x10,%esp
f0120f9c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f0120f9f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fa2:	83 c0 08             	add    $0x8,%eax
f0120fa5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120fa8:	0f 87 ef 00 00 00    	ja     f012109d <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120fae:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fb1:	83 c0 18             	add    $0x18,%eax
f0120fb4:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120fb7:	77 1d                	ja     f0120fd6 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f0120fb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120fbc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120fbf:	0f 86 d8 00 00 00    	jbe    f012109d <alloc_block_BF+0x1da>
				{
					best_va = va;
f0120fc5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120fc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0120fcb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0120fce:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120fd1:	e9 c7 00 00 00       	jmp    f012109d <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f0120fd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fd9:	83 c0 08             	add    $0x8,%eax
f0120fdc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120fdf:	0f 85 9d 00 00 00    	jne    f0121082 <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f0120fe5:	83 ec 04             	sub    $0x4,%esp
f0120fe8:	6a 01                	push   $0x1
f0120fea:	ff 75 a4             	pushl  -0x5c(%ebp)
f0120fed:	ff 75 a8             	pushl  -0x58(%ebp)
f0120ff0:	e8 e3 f9 ff ff       	call   f01209d8 <set_block_data>
f0120ff5:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f0120ff8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ffc:	75 17                	jne    f0121015 <alloc_block_BF+0x152>
f0120ffe:	83 ec 04             	sub    $0x4,%esp
f0121001:	68 77 14 13 f0       	push   $0xf0131477
f0121006:	68 2c 01 00 00       	push   $0x12c
f012100b:	68 95 14 13 f0       	push   $0xf0131495
f0121010:	e8 24 f3 fd ff       	call   f0100339 <_panic>
f0121015:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121018:	8b 00                	mov    (%eax),%eax
f012101a:	85 c0                	test   %eax,%eax
f012101c:	74 10                	je     f012102e <alloc_block_BF+0x16b>
f012101e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121021:	8b 00                	mov    (%eax),%eax
f0121023:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121026:	8b 52 04             	mov    0x4(%edx),%edx
f0121029:	89 50 04             	mov    %edx,0x4(%eax)
f012102c:	eb 0b                	jmp    f0121039 <alloc_block_BF+0x176>
f012102e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121031:	8b 40 04             	mov    0x4(%eax),%eax
f0121034:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121039:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012103c:	8b 40 04             	mov    0x4(%eax),%eax
f012103f:	85 c0                	test   %eax,%eax
f0121041:	74 0f                	je     f0121052 <alloc_block_BF+0x18f>
f0121043:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121046:	8b 40 04             	mov    0x4(%eax),%eax
f0121049:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012104c:	8b 12                	mov    (%edx),%edx
f012104e:	89 10                	mov    %edx,(%eax)
f0121050:	eb 0a                	jmp    f012105c <alloc_block_BF+0x199>
f0121052:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121055:	8b 00                	mov    (%eax),%eax
f0121057:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f012105c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012105f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121065:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121068:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012106f:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121074:	48                   	dec    %eax
f0121075:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
					return va;
f012107a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012107d:	e9 24 04 00 00       	jmp    f01214a6 <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f0121082:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121085:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121088:	76 13                	jbe    f012109d <alloc_block_BF+0x1da>
					{
						internal = 1;
f012108a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f0121091:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121094:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0121097:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f012109a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f012109d:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f01210a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01210a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01210a9:	74 07                	je     f01210b2 <alloc_block_BF+0x1ef>
f01210ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210ae:	8b 00                	mov    (%eax),%eax
f01210b0:	eb 05                	jmp    f01210b7 <alloc_block_BF+0x1f4>
f01210b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01210b7:	a3 98 2f ac f0       	mov    %eax,0xf0ac2f98
f01210bc:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f01210c1:	85 c0                	test   %eax,%eax
f01210c3:	0f 85 bf fe ff ff    	jne    f0120f88 <alloc_block_BF+0xc5>
f01210c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01210cd:	0f 85 b5 fe ff ff    	jne    f0120f88 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f01210d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01210d7:	0f 84 26 02 00 00    	je     f0121303 <alloc_block_BF+0x440>
f01210dd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01210e1:	0f 85 1c 02 00 00    	jne    f0121303 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f01210e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01210ea:	2b 45 08             	sub    0x8(%ebp),%eax
f01210ed:	83 e8 08             	sub    $0x8,%eax
f01210f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f01210f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01210f6:	8d 50 08             	lea    0x8(%eax),%edx
f01210f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01210fc:	01 d0                	add    %edx,%eax
f01210fe:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0121101:	8b 45 08             	mov    0x8(%ebp),%eax
f0121104:	83 c0 08             	add    $0x8,%eax
f0121107:	83 ec 04             	sub    $0x4,%esp
f012110a:	6a 01                	push   $0x1
f012110c:	50                   	push   %eax
f012110d:	ff 75 f0             	pushl  -0x10(%ebp)
f0121110:	e8 c3 f8 ff ff       	call   f01209d8 <set_block_data>
f0121115:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f0121118:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012111b:	8b 40 04             	mov    0x4(%eax),%eax
f012111e:	85 c0                	test   %eax,%eax
f0121120:	75 68                	jne    f012118a <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121122:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121126:	75 17                	jne    f012113f <alloc_block_BF+0x27c>
f0121128:	83 ec 04             	sub    $0x4,%esp
f012112b:	68 b0 14 13 f0       	push   $0xf01314b0
f0121130:	68 45 01 00 00       	push   $0x145
f0121135:	68 95 14 13 f0       	push   $0xf0131495
f012113a:	e8 fa f1 fd ff       	call   f0100339 <_panic>
f012113f:	8b 15 90 2f ac f0    	mov    0xf0ac2f90,%edx
f0121145:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121148:	89 10                	mov    %edx,(%eax)
f012114a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012114d:	8b 00                	mov    (%eax),%eax
f012114f:	85 c0                	test   %eax,%eax
f0121151:	74 0d                	je     f0121160 <alloc_block_BF+0x29d>
f0121153:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121158:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012115b:	89 50 04             	mov    %edx,0x4(%eax)
f012115e:	eb 08                	jmp    f0121168 <alloc_block_BF+0x2a5>
f0121160:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121163:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121168:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012116b:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121170:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121173:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012117a:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f012117f:	40                   	inc    %eax
f0121180:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0121185:	e9 dc 00 00 00       	jmp    f0121266 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f012118a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012118d:	8b 00                	mov    (%eax),%eax
f012118f:	85 c0                	test   %eax,%eax
f0121191:	75 65                	jne    f01211f8 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121193:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121197:	75 17                	jne    f01211b0 <alloc_block_BF+0x2ed>
f0121199:	83 ec 04             	sub    $0x4,%esp
f012119c:	68 e4 14 13 f0       	push   $0xf01314e4
f01211a1:	68 4a 01 00 00       	push   $0x14a
f01211a6:	68 95 14 13 f0       	push   $0xf0131495
f01211ab:	e8 89 f1 fd ff       	call   f0100339 <_panic>
f01211b0:	8b 15 94 2f ac f0    	mov    0xf0ac2f94,%edx
f01211b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211b9:	89 50 04             	mov    %edx,0x4(%eax)
f01211bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211bf:	8b 40 04             	mov    0x4(%eax),%eax
f01211c2:	85 c0                	test   %eax,%eax
f01211c4:	74 0c                	je     f01211d2 <alloc_block_BF+0x30f>
f01211c6:	a1 94 2f ac f0       	mov    0xf0ac2f94,%eax
f01211cb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01211ce:	89 10                	mov    %edx,(%eax)
f01211d0:	eb 08                	jmp    f01211da <alloc_block_BF+0x317>
f01211d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211d5:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01211da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211dd:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f01211e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01211eb:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01211f0:	40                   	inc    %eax
f01211f1:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f01211f6:	eb 6e                	jmp    f0121266 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f01211f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01211fc:	74 06                	je     f0121204 <alloc_block_BF+0x341>
f01211fe:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121202:	75 17                	jne    f012121b <alloc_block_BF+0x358>
f0121204:	83 ec 04             	sub    $0x4,%esp
f0121207:	68 08 15 13 f0       	push   $0xf0131508
f012120c:	68 4f 01 00 00       	push   $0x14f
f0121211:	68 95 14 13 f0       	push   $0xf0131495
f0121216:	e8 1e f1 fd ff       	call   f0100339 <_panic>
f012121b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012121e:	8b 10                	mov    (%eax),%edx
f0121220:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121223:	89 10                	mov    %edx,(%eax)
f0121225:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121228:	8b 00                	mov    (%eax),%eax
f012122a:	85 c0                	test   %eax,%eax
f012122c:	74 0b                	je     f0121239 <alloc_block_BF+0x376>
f012122e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121231:	8b 00                	mov    (%eax),%eax
f0121233:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121236:	89 50 04             	mov    %edx,0x4(%eax)
f0121239:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012123c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012123f:	89 10                	mov    %edx,(%eax)
f0121241:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121244:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121247:	89 50 04             	mov    %edx,0x4(%eax)
f012124a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012124d:	8b 00                	mov    (%eax),%eax
f012124f:	85 c0                	test   %eax,%eax
f0121251:	75 08                	jne    f012125b <alloc_block_BF+0x398>
f0121253:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121256:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f012125b:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121260:	40                   	inc    %eax
f0121261:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0121266:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012126a:	75 17                	jne    f0121283 <alloc_block_BF+0x3c0>
f012126c:	83 ec 04             	sub    $0x4,%esp
f012126f:	68 77 14 13 f0       	push   $0xf0131477
f0121274:	68 51 01 00 00       	push   $0x151
f0121279:	68 95 14 13 f0       	push   $0xf0131495
f012127e:	e8 b6 f0 fd ff       	call   f0100339 <_panic>
f0121283:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121286:	8b 00                	mov    (%eax),%eax
f0121288:	85 c0                	test   %eax,%eax
f012128a:	74 10                	je     f012129c <alloc_block_BF+0x3d9>
f012128c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012128f:	8b 00                	mov    (%eax),%eax
f0121291:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121294:	8b 52 04             	mov    0x4(%edx),%edx
f0121297:	89 50 04             	mov    %edx,0x4(%eax)
f012129a:	eb 0b                	jmp    f01212a7 <alloc_block_BF+0x3e4>
f012129c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012129f:	8b 40 04             	mov    0x4(%eax),%eax
f01212a2:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f01212a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212aa:	8b 40 04             	mov    0x4(%eax),%eax
f01212ad:	85 c0                	test   %eax,%eax
f01212af:	74 0f                	je     f01212c0 <alloc_block_BF+0x3fd>
f01212b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212b4:	8b 40 04             	mov    0x4(%eax),%eax
f01212b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01212ba:	8b 12                	mov    (%edx),%edx
f01212bc:	89 10                	mov    %edx,(%eax)
f01212be:	eb 0a                	jmp    f01212ca <alloc_block_BF+0x407>
f01212c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212c3:	8b 00                	mov    (%eax),%eax
f01212c5:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01212ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01212d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212d6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01212dd:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01212e2:	48                   	dec    %eax
f01212e3:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
			set_block_data(new_block_va, remaining_size, 0);
f01212e8:	83 ec 04             	sub    $0x4,%esp
f01212eb:	6a 00                	push   $0x0
f01212ed:	ff 75 d0             	pushl  -0x30(%ebp)
f01212f0:	ff 75 cc             	pushl  -0x34(%ebp)
f01212f3:	e8 e0 f6 ff ff       	call   f01209d8 <set_block_data>
f01212f8:	83 c4 10             	add    $0x10,%esp
			return best_va;
f01212fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212fe:	e9 a3 01 00 00       	jmp    f01214a6 <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f0121303:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0121307:	0f 85 9d 00 00 00    	jne    f01213aa <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f012130d:	83 ec 04             	sub    $0x4,%esp
f0121310:	6a 01                	push   $0x1
f0121312:	ff 75 ec             	pushl  -0x14(%ebp)
f0121315:	ff 75 f0             	pushl  -0x10(%ebp)
f0121318:	e8 bb f6 ff ff       	call   f01209d8 <set_block_data>
f012131d:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0121320:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121324:	75 17                	jne    f012133d <alloc_block_BF+0x47a>
f0121326:	83 ec 04             	sub    $0x4,%esp
f0121329:	68 77 14 13 f0       	push   $0xf0131477
f012132e:	68 58 01 00 00       	push   $0x158
f0121333:	68 95 14 13 f0       	push   $0xf0131495
f0121338:	e8 fc ef fd ff       	call   f0100339 <_panic>
f012133d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121340:	8b 00                	mov    (%eax),%eax
f0121342:	85 c0                	test   %eax,%eax
f0121344:	74 10                	je     f0121356 <alloc_block_BF+0x493>
f0121346:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121349:	8b 00                	mov    (%eax),%eax
f012134b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012134e:	8b 52 04             	mov    0x4(%edx),%edx
f0121351:	89 50 04             	mov    %edx,0x4(%eax)
f0121354:	eb 0b                	jmp    f0121361 <alloc_block_BF+0x49e>
f0121356:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121359:	8b 40 04             	mov    0x4(%eax),%eax
f012135c:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121364:	8b 40 04             	mov    0x4(%eax),%eax
f0121367:	85 c0                	test   %eax,%eax
f0121369:	74 0f                	je     f012137a <alloc_block_BF+0x4b7>
f012136b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012136e:	8b 40 04             	mov    0x4(%eax),%eax
f0121371:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121374:	8b 12                	mov    (%edx),%edx
f0121376:	89 10                	mov    %edx,(%eax)
f0121378:	eb 0a                	jmp    f0121384 <alloc_block_BF+0x4c1>
f012137a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012137d:	8b 00                	mov    (%eax),%eax
f012137f:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121384:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121387:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012138d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121390:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121397:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f012139c:	48                   	dec    %eax
f012139d:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
		return best_va;
f01213a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213a5:	e9 fc 00 00 00       	jmp    f01214a6 <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f01213aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01213ad:	83 c0 08             	add    $0x8,%eax
f01213b0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01213b3:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f01213ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01213bd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01213c0:	01 d0                	add    %edx,%eax
f01213c2:	48                   	dec    %eax
f01213c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01213c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01213c9:	ba 00 00 00 00       	mov    $0x0,%edx
f01213ce:	f7 75 c4             	divl   -0x3c(%ebp)
f01213d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01213d4:	29 d0                	sub    %edx,%eax
f01213d6:	c1 e8 0c             	shr    $0xc,%eax
f01213d9:	83 ec 0c             	sub    $0xc,%esp
f01213dc:	50                   	push   %eax
f01213dd:	e8 15 80 fe ff       	call   f01093f7 <sbrk>
f01213e2:	83 c4 10             	add    $0x10,%esp
f01213e5:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f01213e8:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f01213ec:	75 0a                	jne    f01213f8 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f01213ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01213f3:	e9 ae 00 00 00       	jmp    f01214a6 <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01213f8:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f01213ff:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121402:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121405:	01 d0                	add    %edx,%eax
f0121407:	48                   	dec    %eax
f0121408:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f012140b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f012140e:	ba 00 00 00 00       	mov    $0x0,%edx
f0121413:	f7 75 b8             	divl   -0x48(%ebp)
f0121416:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0121419:	29 d0                	sub    %edx,%eax
f012141b:	8d 50 fc             	lea    -0x4(%eax),%edx
f012141e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0121421:	01 d0                	add    %edx,%eax
f0121423:	a3 f0 33 ac f0       	mov    %eax,0xf0ac33f0
				end_block->info = 1;
f0121428:	a1 f0 33 ac f0       	mov    0xf0ac33f0,%eax
f012142d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f0121433:	83 ec 0c             	sub    $0xc,%esp
f0121436:	68 3c 15 13 f0       	push   $0xf013153c
f012143b:	e8 4b fb fd ff       	call   f0100f8b <cprintf>
f0121440:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f0121443:	83 ec 08             	sub    $0x8,%esp
f0121446:	ff 75 bc             	pushl  -0x44(%ebp)
f0121449:	68 41 15 13 f0       	push   $0xf0131541
f012144e:	e8 38 fb fd ff       	call   f0100f8b <cprintf>
f0121453:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121456:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f012145d:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121460:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0121463:	01 d0                	add    %edx,%eax
f0121465:	48                   	dec    %eax
f0121466:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0121469:	8b 45 ac             	mov    -0x54(%ebp),%eax
f012146c:	ba 00 00 00 00       	mov    $0x0,%edx
f0121471:	f7 75 b0             	divl   -0x50(%ebp)
f0121474:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121477:	29 d0                	sub    %edx,%eax
f0121479:	83 ec 04             	sub    $0x4,%esp
f012147c:	6a 01                	push   $0x1
f012147e:	50                   	push   %eax
f012147f:	ff 75 bc             	pushl  -0x44(%ebp)
f0121482:	e8 51 f5 ff ff       	call   f01209d8 <set_block_data>
f0121487:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f012148a:	83 ec 0c             	sub    $0xc,%esp
f012148d:	ff 75 bc             	pushl  -0x44(%ebp)
f0121490:	e8 36 04 00 00       	call   f01218cb <free_block>
f0121495:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0121498:	83 ec 0c             	sub    $0xc,%esp
f012149b:	ff 75 08             	pushl  0x8(%ebp)
f012149e:	e8 20 fa ff ff       	call   f0120ec3 <alloc_block_BF>
f01214a3:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f01214a6:	c9                   	leave  
f01214a7:	c3                   	ret    

f01214a8 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f01214a8:	55                   	push   %ebp
f01214a9:	89 e5                	mov    %esp,%ebp
f01214ab:	53                   	push   %ebx
f01214ac:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f01214af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01214b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f01214bd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01214c1:	74 1e                	je     f01214e1 <merging+0x39>
f01214c3:	ff 75 08             	pushl  0x8(%ebp)
f01214c6:	e8 bc f1 ff ff       	call   f0120687 <get_block_size>
f01214cb:	83 c4 04             	add    $0x4,%esp
f01214ce:	89 c2                	mov    %eax,%edx
f01214d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01214d3:	01 d0                	add    %edx,%eax
f01214d5:	3b 45 10             	cmp    0x10(%ebp),%eax
f01214d8:	75 07                	jne    f01214e1 <merging+0x39>
		prev_is_free = 1;
f01214da:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f01214e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01214e5:	74 1e                	je     f0121505 <merging+0x5d>
f01214e7:	ff 75 10             	pushl  0x10(%ebp)
f01214ea:	e8 98 f1 ff ff       	call   f0120687 <get_block_size>
f01214ef:	83 c4 04             	add    $0x4,%esp
f01214f2:	89 c2                	mov    %eax,%edx
f01214f4:	8b 45 10             	mov    0x10(%ebp),%eax
f01214f7:	01 d0                	add    %edx,%eax
f01214f9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01214fc:	75 07                	jne    f0121505 <merging+0x5d>
		next_is_free = 1;
f01214fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0121505:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121509:	0f 84 cc 00 00 00    	je     f01215db <merging+0x133>
f012150f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121513:	0f 84 c2 00 00 00    	je     f01215db <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0121519:	ff 75 08             	pushl  0x8(%ebp)
f012151c:	e8 66 f1 ff ff       	call   f0120687 <get_block_size>
f0121521:	83 c4 04             	add    $0x4,%esp
f0121524:	89 c3                	mov    %eax,%ebx
f0121526:	ff 75 10             	pushl  0x10(%ebp)
f0121529:	e8 59 f1 ff ff       	call   f0120687 <get_block_size>
f012152e:	83 c4 04             	add    $0x4,%esp
f0121531:	01 c3                	add    %eax,%ebx
f0121533:	ff 75 0c             	pushl  0xc(%ebp)
f0121536:	e8 4c f1 ff ff       	call   f0120687 <get_block_size>
f012153b:	83 c4 04             	add    $0x4,%esp
f012153e:	01 d8                	add    %ebx,%eax
f0121540:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0121543:	6a 00                	push   $0x0
f0121545:	ff 75 ec             	pushl  -0x14(%ebp)
f0121548:	ff 75 08             	pushl  0x8(%ebp)
f012154b:	e8 88 f4 ff ff       	call   f01209d8 <set_block_data>
f0121550:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f0121553:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121557:	75 17                	jne    f0121570 <merging+0xc8>
f0121559:	83 ec 04             	sub    $0x4,%esp
f012155c:	68 77 14 13 f0       	push   $0xf0131477
f0121561:	68 7d 01 00 00       	push   $0x17d
f0121566:	68 95 14 13 f0       	push   $0xf0131495
f012156b:	e8 c9 ed fd ff       	call   f0100339 <_panic>
f0121570:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121573:	8b 00                	mov    (%eax),%eax
f0121575:	85 c0                	test   %eax,%eax
f0121577:	74 10                	je     f0121589 <merging+0xe1>
f0121579:	8b 45 0c             	mov    0xc(%ebp),%eax
f012157c:	8b 00                	mov    (%eax),%eax
f012157e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121581:	8b 52 04             	mov    0x4(%edx),%edx
f0121584:	89 50 04             	mov    %edx,0x4(%eax)
f0121587:	eb 0b                	jmp    f0121594 <merging+0xec>
f0121589:	8b 45 0c             	mov    0xc(%ebp),%eax
f012158c:	8b 40 04             	mov    0x4(%eax),%eax
f012158f:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121594:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121597:	8b 40 04             	mov    0x4(%eax),%eax
f012159a:	85 c0                	test   %eax,%eax
f012159c:	74 0f                	je     f01215ad <merging+0x105>
f012159e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215a1:	8b 40 04             	mov    0x4(%eax),%eax
f01215a4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01215a7:	8b 12                	mov    (%edx),%edx
f01215a9:	89 10                	mov    %edx,(%eax)
f01215ab:	eb 0a                	jmp    f01215b7 <merging+0x10f>
f01215ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215b0:	8b 00                	mov    (%eax),%eax
f01215b2:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01215b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01215c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215c3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01215ca:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01215cf:	48                   	dec    %eax
f01215d0:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f01215d5:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01215d6:	e9 ea 02 00 00       	jmp    f01218c5 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f01215db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01215df:	74 3b                	je     f012161c <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f01215e1:	83 ec 0c             	sub    $0xc,%esp
f01215e4:	ff 75 08             	pushl  0x8(%ebp)
f01215e7:	e8 9b f0 ff ff       	call   f0120687 <get_block_size>
f01215ec:	83 c4 10             	add    $0x10,%esp
f01215ef:	89 c3                	mov    %eax,%ebx
f01215f1:	83 ec 0c             	sub    $0xc,%esp
f01215f4:	ff 75 10             	pushl  0x10(%ebp)
f01215f7:	e8 8b f0 ff ff       	call   f0120687 <get_block_size>
f01215fc:	83 c4 10             	add    $0x10,%esp
f01215ff:	01 d8                	add    %ebx,%eax
f0121601:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0121604:	83 ec 04             	sub    $0x4,%esp
f0121607:	6a 00                	push   $0x0
f0121609:	ff 75 e8             	pushl  -0x18(%ebp)
f012160c:	ff 75 08             	pushl  0x8(%ebp)
f012160f:	e8 c4 f3 ff ff       	call   f01209d8 <set_block_data>
f0121614:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121617:	e9 a9 02 00 00       	jmp    f01218c5 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f012161c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121620:	0f 84 2d 01 00 00    	je     f0121753 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0121626:	83 ec 0c             	sub    $0xc,%esp
f0121629:	ff 75 10             	pushl  0x10(%ebp)
f012162c:	e8 56 f0 ff ff       	call   f0120687 <get_block_size>
f0121631:	83 c4 10             	add    $0x10,%esp
f0121634:	89 c3                	mov    %eax,%ebx
f0121636:	83 ec 0c             	sub    $0xc,%esp
f0121639:	ff 75 0c             	pushl  0xc(%ebp)
f012163c:	e8 46 f0 ff ff       	call   f0120687 <get_block_size>
f0121641:	83 c4 10             	add    $0x10,%esp
f0121644:	01 d8                	add    %ebx,%eax
f0121646:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0121649:	83 ec 04             	sub    $0x4,%esp
f012164c:	6a 00                	push   $0x0
f012164e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121651:	ff 75 10             	pushl  0x10(%ebp)
f0121654:	e8 7f f3 ff ff       	call   f01209d8 <set_block_data>
f0121659:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f012165c:	8b 45 10             	mov    0x10(%ebp),%eax
f012165f:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f0121662:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121666:	74 06                	je     f012166e <merging+0x1c6>
f0121668:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f012166c:	75 17                	jne    f0121685 <merging+0x1dd>
f012166e:	83 ec 04             	sub    $0x4,%esp
f0121671:	68 50 15 13 f0       	push   $0xf0131550
f0121676:	68 8d 01 00 00       	push   $0x18d
f012167b:	68 95 14 13 f0       	push   $0xf0131495
f0121680:	e8 b4 ec fd ff       	call   f0100339 <_panic>
f0121685:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121688:	8b 50 04             	mov    0x4(%eax),%edx
f012168b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012168e:	89 50 04             	mov    %edx,0x4(%eax)
f0121691:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121694:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121697:	89 10                	mov    %edx,(%eax)
f0121699:	8b 45 0c             	mov    0xc(%ebp),%eax
f012169c:	8b 40 04             	mov    0x4(%eax),%eax
f012169f:	85 c0                	test   %eax,%eax
f01216a1:	74 0d                	je     f01216b0 <merging+0x208>
f01216a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216a6:	8b 40 04             	mov    0x4(%eax),%eax
f01216a9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01216ac:	89 10                	mov    %edx,(%eax)
f01216ae:	eb 08                	jmp    f01216b8 <merging+0x210>
f01216b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01216b3:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01216b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216bb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01216be:	89 50 04             	mov    %edx,0x4(%eax)
f01216c1:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01216c6:	40                   	inc    %eax
f01216c7:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
		LIST_REMOVE(&freeBlocksList, next_block);
f01216cc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01216d0:	75 17                	jne    f01216e9 <merging+0x241>
f01216d2:	83 ec 04             	sub    $0x4,%esp
f01216d5:	68 77 14 13 f0       	push   $0xf0131477
f01216da:	68 8e 01 00 00       	push   $0x18e
f01216df:	68 95 14 13 f0       	push   $0xf0131495
f01216e4:	e8 50 ec fd ff       	call   f0100339 <_panic>
f01216e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216ec:	8b 00                	mov    (%eax),%eax
f01216ee:	85 c0                	test   %eax,%eax
f01216f0:	74 10                	je     f0121702 <merging+0x25a>
f01216f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216f5:	8b 00                	mov    (%eax),%eax
f01216f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01216fa:	8b 52 04             	mov    0x4(%edx),%edx
f01216fd:	89 50 04             	mov    %edx,0x4(%eax)
f0121700:	eb 0b                	jmp    f012170d <merging+0x265>
f0121702:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121705:	8b 40 04             	mov    0x4(%eax),%eax
f0121708:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f012170d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121710:	8b 40 04             	mov    0x4(%eax),%eax
f0121713:	85 c0                	test   %eax,%eax
f0121715:	74 0f                	je     f0121726 <merging+0x27e>
f0121717:	8b 45 0c             	mov    0xc(%ebp),%eax
f012171a:	8b 40 04             	mov    0x4(%eax),%eax
f012171d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121720:	8b 12                	mov    (%edx),%edx
f0121722:	89 10                	mov    %edx,(%eax)
f0121724:	eb 0a                	jmp    f0121730 <merging+0x288>
f0121726:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121729:	8b 00                	mov    (%eax),%eax
f012172b:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121730:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121733:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121739:	8b 45 0c             	mov    0xc(%ebp),%eax
f012173c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121743:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121748:	48                   	dec    %eax
f0121749:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f012174e:	e9 72 01 00 00       	jmp    f01218c5 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f0121753:	8b 45 10             	mov    0x10(%ebp),%eax
f0121756:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121759:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012175d:	74 79                	je     f01217d8 <merging+0x330>
f012175f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121763:	74 73                	je     f01217d8 <merging+0x330>
f0121765:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121769:	74 06                	je     f0121771 <merging+0x2c9>
f012176b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012176f:	75 17                	jne    f0121788 <merging+0x2e0>
f0121771:	83 ec 04             	sub    $0x4,%esp
f0121774:	68 08 15 13 f0       	push   $0xf0131508
f0121779:	68 94 01 00 00       	push   $0x194
f012177e:	68 95 14 13 f0       	push   $0xf0131495
f0121783:	e8 b1 eb fd ff       	call   f0100339 <_panic>
f0121788:	8b 45 08             	mov    0x8(%ebp),%eax
f012178b:	8b 10                	mov    (%eax),%edx
f012178d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121790:	89 10                	mov    %edx,(%eax)
f0121792:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121795:	8b 00                	mov    (%eax),%eax
f0121797:	85 c0                	test   %eax,%eax
f0121799:	74 0b                	je     f01217a6 <merging+0x2fe>
f012179b:	8b 45 08             	mov    0x8(%ebp),%eax
f012179e:	8b 00                	mov    (%eax),%eax
f01217a0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01217a3:	89 50 04             	mov    %edx,0x4(%eax)
f01217a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01217a9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01217ac:	89 10                	mov    %edx,(%eax)
f01217ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217b1:	8b 55 08             	mov    0x8(%ebp),%edx
f01217b4:	89 50 04             	mov    %edx,0x4(%eax)
f01217b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217ba:	8b 00                	mov    (%eax),%eax
f01217bc:	85 c0                	test   %eax,%eax
f01217be:	75 08                	jne    f01217c8 <merging+0x320>
f01217c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217c3:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f01217c8:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01217cd:	40                   	inc    %eax
f01217ce:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f01217d3:	e9 ce 00 00 00       	jmp    f01218a6 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f01217d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01217dc:	74 65                	je     f0121843 <merging+0x39b>
f01217de:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01217e2:	75 17                	jne    f01217fb <merging+0x353>
f01217e4:	83 ec 04             	sub    $0x4,%esp
f01217e7:	68 e4 14 13 f0       	push   $0xf01314e4
f01217ec:	68 95 01 00 00       	push   $0x195
f01217f1:	68 95 14 13 f0       	push   $0xf0131495
f01217f6:	e8 3e eb fd ff       	call   f0100339 <_panic>
f01217fb:	8b 15 94 2f ac f0    	mov    0xf0ac2f94,%edx
f0121801:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121804:	89 50 04             	mov    %edx,0x4(%eax)
f0121807:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012180a:	8b 40 04             	mov    0x4(%eax),%eax
f012180d:	85 c0                	test   %eax,%eax
f012180f:	74 0c                	je     f012181d <merging+0x375>
f0121811:	a1 94 2f ac f0       	mov    0xf0ac2f94,%eax
f0121816:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121819:	89 10                	mov    %edx,(%eax)
f012181b:	eb 08                	jmp    f0121825 <merging+0x37d>
f012181d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121820:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121825:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121828:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f012182d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121830:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121836:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f012183b:	40                   	inc    %eax
f012183c:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0121841:	eb 63                	jmp    f01218a6 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0121843:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121847:	75 17                	jne    f0121860 <merging+0x3b8>
f0121849:	83 ec 04             	sub    $0x4,%esp
f012184c:	68 b0 14 13 f0       	push   $0xf01314b0
f0121851:	68 98 01 00 00       	push   $0x198
f0121856:	68 95 14 13 f0       	push   $0xf0131495
f012185b:	e8 d9 ea fd ff       	call   f0100339 <_panic>
f0121860:	8b 15 90 2f ac f0    	mov    0xf0ac2f90,%edx
f0121866:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121869:	89 10                	mov    %edx,(%eax)
f012186b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012186e:	8b 00                	mov    (%eax),%eax
f0121870:	85 c0                	test   %eax,%eax
f0121872:	74 0d                	je     f0121881 <merging+0x3d9>
f0121874:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121879:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012187c:	89 50 04             	mov    %edx,0x4(%eax)
f012187f:	eb 08                	jmp    f0121889 <merging+0x3e1>
f0121881:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121884:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121889:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012188c:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121891:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121894:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012189b:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01218a0:	40                   	inc    %eax
f01218a1:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
		}
		set_block_data(va, get_block_size(va), 0);
f01218a6:	83 ec 0c             	sub    $0xc,%esp
f01218a9:	ff 75 10             	pushl  0x10(%ebp)
f01218ac:	e8 d6 ed ff ff       	call   f0120687 <get_block_size>
f01218b1:	83 c4 10             	add    $0x10,%esp
f01218b4:	83 ec 04             	sub    $0x4,%esp
f01218b7:	6a 00                	push   $0x0
f01218b9:	50                   	push   %eax
f01218ba:	ff 75 10             	pushl  0x10(%ebp)
f01218bd:	e8 16 f1 ff ff       	call   f01209d8 <set_block_data>
f01218c2:	83 c4 10             	add    $0x10,%esp
	}
}
f01218c5:	90                   	nop
f01218c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01218c9:	c9                   	leave  
f01218ca:	c3                   	ret    

f01218cb <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f01218cb:	55                   	push   %ebp
f01218cc:	89 e5                	mov    %esp,%ebp
f01218ce:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f01218d1:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f01218d6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f01218d9:	a1 94 2f ac f0       	mov    0xf0ac2f94,%eax
f01218de:	3b 45 08             	cmp    0x8(%ebp),%eax
f01218e1:	73 1b                	jae    f01218fe <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f01218e3:	a1 94 2f ac f0       	mov    0xf0ac2f94,%eax
f01218e8:	83 ec 04             	sub    $0x4,%esp
f01218eb:	ff 75 08             	pushl  0x8(%ebp)
f01218ee:	6a 00                	push   $0x0
f01218f0:	50                   	push   %eax
f01218f1:	e8 b2 fb ff ff       	call   f01214a8 <merging>
f01218f6:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01218f9:	e9 8b 00 00 00       	jmp    f0121989 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01218fe:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121903:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121906:	76 18                	jbe    f0121920 <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f0121908:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f012190d:	83 ec 04             	sub    $0x4,%esp
f0121910:	ff 75 08             	pushl  0x8(%ebp)
f0121913:	50                   	push   %eax
f0121914:	6a 00                	push   $0x0
f0121916:	e8 8d fb ff ff       	call   f01214a8 <merging>
f012191b:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f012191e:	eb 69                	jmp    f0121989 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121920:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121925:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121928:	eb 39                	jmp    f0121963 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f012192a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012192d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121930:	73 29                	jae    f012195b <free_block+0x90>
f0121932:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121935:	8b 00                	mov    (%eax),%eax
f0121937:	3b 45 08             	cmp    0x8(%ebp),%eax
f012193a:	76 1f                	jbe    f012195b <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f012193c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012193f:	8b 00                	mov    (%eax),%eax
f0121941:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f0121944:	83 ec 04             	sub    $0x4,%esp
f0121947:	ff 75 08             	pushl  0x8(%ebp)
f012194a:	ff 75 f0             	pushl  -0x10(%ebp)
f012194d:	ff 75 f4             	pushl  -0xc(%ebp)
f0121950:	e8 53 fb ff ff       	call   f01214a8 <merging>
f0121955:	83 c4 10             	add    $0x10,%esp
			break;
f0121958:	90                   	nop
		}
	}
}
f0121959:	eb 2e                	jmp    f0121989 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f012195b:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f0121960:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121963:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121967:	74 07                	je     f0121970 <free_block+0xa5>
f0121969:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012196c:	8b 00                	mov    (%eax),%eax
f012196e:	eb 05                	jmp    f0121975 <free_block+0xaa>
f0121970:	b8 00 00 00 00       	mov    $0x0,%eax
f0121975:	a3 98 2f ac f0       	mov    %eax,0xf0ac2f98
f012197a:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f012197f:	85 c0                	test   %eax,%eax
f0121981:	75 a7                	jne    f012192a <free_block+0x5f>
f0121983:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121987:	75 a1                	jne    f012192a <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121989:	90                   	nop
f012198a:	c9                   	leave  
f012198b:	c3                   	ret    

f012198c <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f012198c:	55                   	push   %ebp
f012198d:	89 e5                	mov    %esp,%ebp
f012198f:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f0121992:	ff 75 08             	pushl  0x8(%ebp)
f0121995:	e8 ed ec ff ff       	call   f0120687 <get_block_size>
f012199a:	83 c4 04             	add    $0x4,%esp
f012199d:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f01219a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01219a7:	eb 17                	jmp    f01219c0 <copy_data+0x34>
f01219a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01219ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219af:	01 c2                	add    %eax,%edx
f01219b1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f01219b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01219b7:	01 c8                	add    %ecx,%eax
f01219b9:	8a 00                	mov    (%eax),%al
f01219bb:	88 02                	mov    %al,(%edx)
f01219bd:	ff 45 fc             	incl   -0x4(%ebp)
f01219c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01219c3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01219c6:	72 e1                	jb     f01219a9 <copy_data+0x1d>
}
f01219c8:	90                   	nop
f01219c9:	c9                   	leave  
f01219ca:	c3                   	ret    

f01219cb <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f01219cb:	55                   	push   %ebp
f01219cc:	89 e5                	mov    %esp,%ebp
f01219ce:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f01219d1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01219d5:	75 23                	jne    f01219fa <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f01219d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01219db:	74 13                	je     f01219f0 <realloc_block_FF+0x25>
f01219dd:	83 ec 0c             	sub    $0xc,%esp
f01219e0:	ff 75 0c             	pushl  0xc(%ebp)
f01219e3:	e8 1f f0 ff ff       	call   f0120a07 <alloc_block_FF>
f01219e8:	83 c4 10             	add    $0x10,%esp
f01219eb:	e9 f4 06 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>
		return NULL;
f01219f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01219f5:	e9 ea 06 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f01219fa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01219fe:	75 18                	jne    f0121a18 <realloc_block_FF+0x4d>
	{
		free_block(va);
f0121a00:	83 ec 0c             	sub    $0xc,%esp
f0121a03:	ff 75 08             	pushl  0x8(%ebp)
f0121a06:	e8 c0 fe ff ff       	call   f01218cb <free_block>
f0121a0b:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0121a0e:	b8 00 00 00 00       	mov    $0x0,%eax
f0121a13:	e9 cc 06 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f0121a18:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121a1c:	77 07                	ja     f0121a25 <realloc_block_FF+0x5a>
f0121a1e:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0121a25:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a28:	83 e0 01             	and    $0x1,%eax
f0121a2b:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a31:	83 c0 08             	add    $0x8,%eax
f0121a34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121a37:	83 ec 0c             	sub    $0xc,%esp
f0121a3a:	ff 75 08             	pushl  0x8(%ebp)
f0121a3d:	e8 45 ec ff ff       	call   f0120687 <get_block_size>
f0121a42:	83 c4 10             	add    $0x10,%esp
f0121a45:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121a48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121a4b:	83 e8 08             	sub    $0x8,%eax
f0121a4e:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f0121a51:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a54:	83 e8 04             	sub    $0x4,%eax
f0121a57:	8b 00                	mov    (%eax),%eax
f0121a59:	83 e0 fe             	and    $0xfffffffe,%eax
f0121a5c:	89 c2                	mov    %eax,%edx
f0121a5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a61:	01 d0                	add    %edx,%eax
f0121a63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121a66:	83 ec 0c             	sub    $0xc,%esp
f0121a69:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121a6c:	e8 16 ec ff ff       	call   f0120687 <get_block_size>
f0121a71:	83 c4 10             	add    $0x10,%esp
f0121a74:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121a77:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a7a:	83 e8 08             	sub    $0x8,%eax
f0121a7d:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121a80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a83:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121a86:	75 08                	jne    f0121a90 <realloc_block_FF+0xc5>
	{
		 return va;
f0121a88:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a8b:	e9 54 06 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f0121a90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a93:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121a96:	0f 83 e5 03 00 00    	jae    f0121e81 <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121a9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121a9f:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121aa2:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121aa5:	83 ec 0c             	sub    $0xc,%esp
f0121aa8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121aab:	e8 f0 eb ff ff       	call   f01206a0 <is_free_block>
f0121ab0:	83 c4 10             	add    $0x10,%esp
f0121ab3:	84 c0                	test   %al,%al
f0121ab5:	0f 84 3b 01 00 00    	je     f0121bf6 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121abb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121abe:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121ac1:	01 d0                	add    %edx,%eax
f0121ac3:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121ac6:	83 ec 04             	sub    $0x4,%esp
f0121ac9:	6a 01                	push   $0x1
f0121acb:	ff 75 f0             	pushl  -0x10(%ebp)
f0121ace:	ff 75 08             	pushl  0x8(%ebp)
f0121ad1:	e8 02 ef ff ff       	call   f01209d8 <set_block_data>
f0121ad6:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121ad9:	8b 45 08             	mov    0x8(%ebp),%eax
f0121adc:	83 e8 04             	sub    $0x4,%eax
f0121adf:	8b 00                	mov    (%eax),%eax
f0121ae1:	83 e0 fe             	and    $0xfffffffe,%eax
f0121ae4:	89 c2                	mov    %eax,%edx
f0121ae6:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ae9:	01 d0                	add    %edx,%eax
f0121aeb:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121aee:	83 ec 04             	sub    $0x4,%esp
f0121af1:	6a 00                	push   $0x0
f0121af3:	ff 75 cc             	pushl  -0x34(%ebp)
f0121af6:	ff 75 c8             	pushl  -0x38(%ebp)
f0121af9:	e8 da ee ff ff       	call   f01209d8 <set_block_data>
f0121afe:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121b01:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121b05:	74 06                	je     f0121b0d <realloc_block_FF+0x142>
f0121b07:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121b0b:	75 17                	jne    f0121b24 <realloc_block_FF+0x159>
f0121b0d:	83 ec 04             	sub    $0x4,%esp
f0121b10:	68 08 15 13 f0       	push   $0xf0131508
f0121b15:	68 f6 01 00 00       	push   $0x1f6
f0121b1a:	68 95 14 13 f0       	push   $0xf0131495
f0121b1f:	e8 15 e8 fd ff       	call   f0100339 <_panic>
f0121b24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b27:	8b 10                	mov    (%eax),%edx
f0121b29:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b2c:	89 10                	mov    %edx,(%eax)
f0121b2e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b31:	8b 00                	mov    (%eax),%eax
f0121b33:	85 c0                	test   %eax,%eax
f0121b35:	74 0b                	je     f0121b42 <realloc_block_FF+0x177>
f0121b37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b3a:	8b 00                	mov    (%eax),%eax
f0121b3c:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121b3f:	89 50 04             	mov    %edx,0x4(%eax)
f0121b42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b45:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121b48:	89 10                	mov    %edx,(%eax)
f0121b4a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b4d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121b50:	89 50 04             	mov    %edx,0x4(%eax)
f0121b53:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b56:	8b 00                	mov    (%eax),%eax
f0121b58:	85 c0                	test   %eax,%eax
f0121b5a:	75 08                	jne    f0121b64 <realloc_block_FF+0x199>
f0121b5c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b5f:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121b64:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121b69:	40                   	inc    %eax
f0121b6a:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121b6f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121b73:	75 17                	jne    f0121b8c <realloc_block_FF+0x1c1>
f0121b75:	83 ec 04             	sub    $0x4,%esp
f0121b78:	68 77 14 13 f0       	push   $0xf0131477
f0121b7d:	68 f7 01 00 00       	push   $0x1f7
f0121b82:	68 95 14 13 f0       	push   $0xf0131495
f0121b87:	e8 ad e7 fd ff       	call   f0100339 <_panic>
f0121b8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b8f:	8b 00                	mov    (%eax),%eax
f0121b91:	85 c0                	test   %eax,%eax
f0121b93:	74 10                	je     f0121ba5 <realloc_block_FF+0x1da>
f0121b95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b98:	8b 00                	mov    (%eax),%eax
f0121b9a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121b9d:	8b 52 04             	mov    0x4(%edx),%edx
f0121ba0:	89 50 04             	mov    %edx,0x4(%eax)
f0121ba3:	eb 0b                	jmp    f0121bb0 <realloc_block_FF+0x1e5>
f0121ba5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ba8:	8b 40 04             	mov    0x4(%eax),%eax
f0121bab:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121bb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bb3:	8b 40 04             	mov    0x4(%eax),%eax
f0121bb6:	85 c0                	test   %eax,%eax
f0121bb8:	74 0f                	je     f0121bc9 <realloc_block_FF+0x1fe>
f0121bba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bbd:	8b 40 04             	mov    0x4(%eax),%eax
f0121bc0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121bc3:	8b 12                	mov    (%edx),%edx
f0121bc5:	89 10                	mov    %edx,(%eax)
f0121bc7:	eb 0a                	jmp    f0121bd3 <realloc_block_FF+0x208>
f0121bc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bcc:	8b 00                	mov    (%eax),%eax
f0121bce:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121bd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bd6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121bdc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bdf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121be6:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121beb:	48                   	dec    %eax
f0121bec:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0121bf1:	e9 83 02 00 00       	jmp    f0121e79 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f0121bf6:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121bfa:	0f 86 69 02 00 00    	jbe    f0121e69 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121c00:	83 ec 04             	sub    $0x4,%esp
f0121c03:	6a 01                	push   $0x1
f0121c05:	ff 75 f0             	pushl  -0x10(%ebp)
f0121c08:	ff 75 08             	pushl  0x8(%ebp)
f0121c0b:	e8 c8 ed ff ff       	call   f01209d8 <set_block_data>
f0121c10:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121c13:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c16:	83 e8 04             	sub    $0x4,%eax
f0121c19:	8b 00                	mov    (%eax),%eax
f0121c1b:	83 e0 fe             	and    $0xfffffffe,%eax
f0121c1e:	89 c2                	mov    %eax,%edx
f0121c20:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c23:	01 d0                	add    %edx,%eax
f0121c25:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121c28:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121c2d:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0121c30:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121c34:	75 68                	jne    f0121c9e <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121c36:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121c3a:	75 17                	jne    f0121c53 <realloc_block_FF+0x288>
f0121c3c:	83 ec 04             	sub    $0x4,%esp
f0121c3f:	68 b0 14 13 f0       	push   $0xf01314b0
f0121c44:	68 06 02 00 00       	push   $0x206
f0121c49:	68 95 14 13 f0       	push   $0xf0131495
f0121c4e:	e8 e6 e6 fd ff       	call   f0100339 <_panic>
f0121c53:	8b 15 90 2f ac f0    	mov    0xf0ac2f90,%edx
f0121c59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c5c:	89 10                	mov    %edx,(%eax)
f0121c5e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c61:	8b 00                	mov    (%eax),%eax
f0121c63:	85 c0                	test   %eax,%eax
f0121c65:	74 0d                	je     f0121c74 <realloc_block_FF+0x2a9>
f0121c67:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121c6c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121c6f:	89 50 04             	mov    %edx,0x4(%eax)
f0121c72:	eb 08                	jmp    f0121c7c <realloc_block_FF+0x2b1>
f0121c74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c77:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121c7c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c7f:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121c84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c87:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121c8e:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121c93:	40                   	inc    %eax
f0121c94:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0121c99:	e9 b0 01 00 00       	jmp    f0121e4e <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121c9e:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121ca3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121ca6:	76 68                	jbe    f0121d10 <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121ca8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121cac:	75 17                	jne    f0121cc5 <realloc_block_FF+0x2fa>
f0121cae:	83 ec 04             	sub    $0x4,%esp
f0121cb1:	68 b0 14 13 f0       	push   $0xf01314b0
f0121cb6:	68 0b 02 00 00       	push   $0x20b
f0121cbb:	68 95 14 13 f0       	push   $0xf0131495
f0121cc0:	e8 74 e6 fd ff       	call   f0100339 <_panic>
f0121cc5:	8b 15 90 2f ac f0    	mov    0xf0ac2f90,%edx
f0121ccb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cce:	89 10                	mov    %edx,(%eax)
f0121cd0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cd3:	8b 00                	mov    (%eax),%eax
f0121cd5:	85 c0                	test   %eax,%eax
f0121cd7:	74 0d                	je     f0121ce6 <realloc_block_FF+0x31b>
f0121cd9:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121cde:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121ce1:	89 50 04             	mov    %edx,0x4(%eax)
f0121ce4:	eb 08                	jmp    f0121cee <realloc_block_FF+0x323>
f0121ce6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ce9:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121cee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cf1:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121cf6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cf9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121d00:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121d05:	40                   	inc    %eax
f0121d06:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0121d0b:	e9 3e 01 00 00       	jmp    f0121e4e <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0121d10:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121d15:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d18:	73 68                	jae    f0121d82 <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121d1a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121d1e:	75 17                	jne    f0121d37 <realloc_block_FF+0x36c>
f0121d20:	83 ec 04             	sub    $0x4,%esp
f0121d23:	68 e4 14 13 f0       	push   $0xf01314e4
f0121d28:	68 10 02 00 00       	push   $0x210
f0121d2d:	68 95 14 13 f0       	push   $0xf0131495
f0121d32:	e8 02 e6 fd ff       	call   f0100339 <_panic>
f0121d37:	8b 15 94 2f ac f0    	mov    0xf0ac2f94,%edx
f0121d3d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d40:	89 50 04             	mov    %edx,0x4(%eax)
f0121d43:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d46:	8b 40 04             	mov    0x4(%eax),%eax
f0121d49:	85 c0                	test   %eax,%eax
f0121d4b:	74 0c                	je     f0121d59 <realloc_block_FF+0x38e>
f0121d4d:	a1 94 2f ac f0       	mov    0xf0ac2f94,%eax
f0121d52:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d55:	89 10                	mov    %edx,(%eax)
f0121d57:	eb 08                	jmp    f0121d61 <realloc_block_FF+0x396>
f0121d59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d5c:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121d61:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d64:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121d69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121d72:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121d77:	40                   	inc    %eax
f0121d78:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
f0121d7d:	e9 cc 00 00 00       	jmp    f0121e4e <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f0121d82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121d89:	a1 90 2f ac f0       	mov    0xf0ac2f90,%eax
f0121d8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121d91:	e9 8a 00 00 00       	jmp    f0121e20 <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0121d96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d99:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d9c:	73 7a                	jae    f0121e18 <realloc_block_FF+0x44d>
f0121d9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121da1:	8b 00                	mov    (%eax),%eax
f0121da3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121da6:	73 70                	jae    f0121e18 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121da8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121dac:	74 06                	je     f0121db4 <realloc_block_FF+0x3e9>
f0121dae:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121db2:	75 17                	jne    f0121dcb <realloc_block_FF+0x400>
f0121db4:	83 ec 04             	sub    $0x4,%esp
f0121db7:	68 08 15 13 f0       	push   $0xf0131508
f0121dbc:	68 1a 02 00 00       	push   $0x21a
f0121dc1:	68 95 14 13 f0       	push   $0xf0131495
f0121dc6:	e8 6e e5 fd ff       	call   f0100339 <_panic>
f0121dcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121dce:	8b 10                	mov    (%eax),%edx
f0121dd0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dd3:	89 10                	mov    %edx,(%eax)
f0121dd5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dd8:	8b 00                	mov    (%eax),%eax
f0121dda:	85 c0                	test   %eax,%eax
f0121ddc:	74 0b                	je     f0121de9 <realloc_block_FF+0x41e>
f0121dde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121de1:	8b 00                	mov    (%eax),%eax
f0121de3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121de6:	89 50 04             	mov    %edx,0x4(%eax)
f0121de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121dec:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121def:	89 10                	mov    %edx,(%eax)
f0121df1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121df4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121df7:	89 50 04             	mov    %edx,0x4(%eax)
f0121dfa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dfd:	8b 00                	mov    (%eax),%eax
f0121dff:	85 c0                	test   %eax,%eax
f0121e01:	75 08                	jne    f0121e0b <realloc_block_FF+0x440>
f0121e03:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e06:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121e0b:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121e10:	40                   	inc    %eax
f0121e11:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
							break;
f0121e16:	eb 36                	jmp    f0121e4e <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0121e18:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f0121e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121e20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121e24:	74 07                	je     f0121e2d <realloc_block_FF+0x462>
f0121e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e29:	8b 00                	mov    (%eax),%eax
f0121e2b:	eb 05                	jmp    f0121e32 <realloc_block_FF+0x467>
f0121e2d:	b8 00 00 00 00       	mov    $0x0,%eax
f0121e32:	a3 98 2f ac f0       	mov    %eax,0xf0ac2f98
f0121e37:	a1 98 2f ac f0       	mov    0xf0ac2f98,%eax
f0121e3c:	85 c0                	test   %eax,%eax
f0121e3e:	0f 85 52 ff ff ff    	jne    f0121d96 <realloc_block_FF+0x3cb>
f0121e44:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121e48:	0f 85 48 ff ff ff    	jne    f0121d96 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0121e4e:	83 ec 04             	sub    $0x4,%esp
f0121e51:	6a 00                	push   $0x0
f0121e53:	ff 75 d8             	pushl  -0x28(%ebp)
f0121e56:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121e59:	e8 7a eb ff ff       	call   f01209d8 <set_block_data>
f0121e5e:	83 c4 10             	add    $0x10,%esp
				return va;
f0121e61:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e64:	e9 7b 02 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121e69:	83 ec 0c             	sub    $0xc,%esp
f0121e6c:	68 85 15 13 f0       	push   $0xf0131585
f0121e71:	e8 15 f1 fd ff       	call   f0100f8b <cprintf>
f0121e76:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121e79:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e7c:	e9 63 02 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f0121e81:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e84:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121e87:	0f 86 4d 02 00 00    	jbe    f01220da <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0121e8d:	83 ec 0c             	sub    $0xc,%esp
f0121e90:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121e93:	e8 08 e8 ff ff       	call   f01206a0 <is_free_block>
f0121e98:	83 c4 10             	add    $0x10,%esp
f0121e9b:	84 c0                	test   %al,%al
f0121e9d:	0f 84 37 02 00 00    	je     f01220da <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0121ea3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ea6:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121ea9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121eac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121eaf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0121eb2:	76 38                	jbe    f0121eec <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0121eb4:	83 ec 0c             	sub    $0xc,%esp
f0121eb7:	ff 75 08             	pushl  0x8(%ebp)
f0121eba:	e8 0c fa ff ff       	call   f01218cb <free_block>
f0121ebf:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f0121ec2:	83 ec 0c             	sub    $0xc,%esp
f0121ec5:	ff 75 0c             	pushl  0xc(%ebp)
f0121ec8:	e8 3a eb ff ff       	call   f0120a07 <alloc_block_FF>
f0121ecd:	83 c4 10             	add    $0x10,%esp
f0121ed0:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0121ed3:	83 ec 08             	sub    $0x8,%esp
f0121ed6:	ff 75 c0             	pushl  -0x40(%ebp)
f0121ed9:	ff 75 08             	pushl  0x8(%ebp)
f0121edc:	e8 ab fa ff ff       	call   f012198c <copy_data>
f0121ee1:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0121ee4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121ee7:	e9 f8 01 00 00       	jmp    f01220e4 <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0121eec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121eef:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f0121ef2:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0121ef5:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f0121ef9:	0f 87 a0 00 00 00    	ja     f0121f9f <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f0121eff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121f03:	75 17                	jne    f0121f1c <realloc_block_FF+0x551>
f0121f05:	83 ec 04             	sub    $0x4,%esp
f0121f08:	68 77 14 13 f0       	push   $0xf0131477
f0121f0d:	68 38 02 00 00       	push   $0x238
f0121f12:	68 95 14 13 f0       	push   $0xf0131495
f0121f17:	e8 1d e4 fd ff       	call   f0100339 <_panic>
f0121f1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f1f:	8b 00                	mov    (%eax),%eax
f0121f21:	85 c0                	test   %eax,%eax
f0121f23:	74 10                	je     f0121f35 <realloc_block_FF+0x56a>
f0121f25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f28:	8b 00                	mov    (%eax),%eax
f0121f2a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121f2d:	8b 52 04             	mov    0x4(%edx),%edx
f0121f30:	89 50 04             	mov    %edx,0x4(%eax)
f0121f33:	eb 0b                	jmp    f0121f40 <realloc_block_FF+0x575>
f0121f35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f38:	8b 40 04             	mov    0x4(%eax),%eax
f0121f3b:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0121f40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f43:	8b 40 04             	mov    0x4(%eax),%eax
f0121f46:	85 c0                	test   %eax,%eax
f0121f48:	74 0f                	je     f0121f59 <realloc_block_FF+0x58e>
f0121f4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f4d:	8b 40 04             	mov    0x4(%eax),%eax
f0121f50:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121f53:	8b 12                	mov    (%edx),%edx
f0121f55:	89 10                	mov    %edx,(%eax)
f0121f57:	eb 0a                	jmp    f0121f63 <realloc_block_FF+0x598>
f0121f59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f5c:	8b 00                	mov    (%eax),%eax
f0121f5e:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f0121f63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f66:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121f6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f6f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121f76:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f0121f7b:	48                   	dec    %eax
f0121f7c:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0121f81:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121f84:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121f87:	01 d0                	add    %edx,%eax
f0121f89:	83 ec 04             	sub    $0x4,%esp
f0121f8c:	6a 01                	push   $0x1
f0121f8e:	50                   	push   %eax
f0121f8f:	ff 75 08             	pushl  0x8(%ebp)
f0121f92:	e8 41 ea ff ff       	call   f01209d8 <set_block_data>
f0121f97:	83 c4 10             	add    $0x10,%esp
f0121f9a:	e9 36 01 00 00       	jmp    f01220d5 <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0121f9f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121fa2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121fa5:	01 d0                	add    %edx,%eax
f0121fa7:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0121faa:	83 ec 04             	sub    $0x4,%esp
f0121fad:	6a 01                	push   $0x1
f0121faf:	ff 75 f0             	pushl  -0x10(%ebp)
f0121fb2:	ff 75 08             	pushl  0x8(%ebp)
f0121fb5:	e8 1e ea ff ff       	call   f01209d8 <set_block_data>
f0121fba:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121fbd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121fc0:	83 e8 04             	sub    $0x4,%eax
f0121fc3:	8b 00                	mov    (%eax),%eax
f0121fc5:	83 e0 fe             	and    $0xfffffffe,%eax
f0121fc8:	89 c2                	mov    %eax,%edx
f0121fca:	8b 45 08             	mov    0x8(%ebp),%eax
f0121fcd:	01 d0                	add    %edx,%eax
f0121fcf:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121fd2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121fd6:	74 06                	je     f0121fde <realloc_block_FF+0x613>
f0121fd8:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0121fdc:	75 17                	jne    f0121ff5 <realloc_block_FF+0x62a>
f0121fde:	83 ec 04             	sub    $0x4,%esp
f0121fe1:	68 08 15 13 f0       	push   $0xf0131508
f0121fe6:	68 44 02 00 00       	push   $0x244
f0121feb:	68 95 14 13 f0       	push   $0xf0131495
f0121ff0:	e8 44 e3 fd ff       	call   f0100339 <_panic>
f0121ff5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ff8:	8b 10                	mov    (%eax),%edx
f0121ffa:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121ffd:	89 10                	mov    %edx,(%eax)
f0121fff:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122002:	8b 00                	mov    (%eax),%eax
f0122004:	85 c0                	test   %eax,%eax
f0122006:	74 0b                	je     f0122013 <realloc_block_FF+0x648>
f0122008:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012200b:	8b 00                	mov    (%eax),%eax
f012200d:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0122010:	89 50 04             	mov    %edx,0x4(%eax)
f0122013:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122016:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0122019:	89 10                	mov    %edx,(%eax)
f012201b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012201e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122021:	89 50 04             	mov    %edx,0x4(%eax)
f0122024:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122027:	8b 00                	mov    (%eax),%eax
f0122029:	85 c0                	test   %eax,%eax
f012202b:	75 08                	jne    f0122035 <realloc_block_FF+0x66a>
f012202d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122030:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0122035:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f012203a:	40                   	inc    %eax
f012203b:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0122040:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122044:	75 17                	jne    f012205d <realloc_block_FF+0x692>
f0122046:	83 ec 04             	sub    $0x4,%esp
f0122049:	68 77 14 13 f0       	push   $0xf0131477
f012204e:	68 45 02 00 00       	push   $0x245
f0122053:	68 95 14 13 f0       	push   $0xf0131495
f0122058:	e8 dc e2 fd ff       	call   f0100339 <_panic>
f012205d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122060:	8b 00                	mov    (%eax),%eax
f0122062:	85 c0                	test   %eax,%eax
f0122064:	74 10                	je     f0122076 <realloc_block_FF+0x6ab>
f0122066:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122069:	8b 00                	mov    (%eax),%eax
f012206b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012206e:	8b 52 04             	mov    0x4(%edx),%edx
f0122071:	89 50 04             	mov    %edx,0x4(%eax)
f0122074:	eb 0b                	jmp    f0122081 <realloc_block_FF+0x6b6>
f0122076:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122079:	8b 40 04             	mov    0x4(%eax),%eax
f012207c:	a3 94 2f ac f0       	mov    %eax,0xf0ac2f94
f0122081:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122084:	8b 40 04             	mov    0x4(%eax),%eax
f0122087:	85 c0                	test   %eax,%eax
f0122089:	74 0f                	je     f012209a <realloc_block_FF+0x6cf>
f012208b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012208e:	8b 40 04             	mov    0x4(%eax),%eax
f0122091:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122094:	8b 12                	mov    (%edx),%edx
f0122096:	89 10                	mov    %edx,(%eax)
f0122098:	eb 0a                	jmp    f01220a4 <realloc_block_FF+0x6d9>
f012209a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012209d:	8b 00                	mov    (%eax),%eax
f012209f:	a3 90 2f ac f0       	mov    %eax,0xf0ac2f90
f01220a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01220ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220b0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01220b7:	a1 9c 2f ac f0       	mov    0xf0ac2f9c,%eax
f01220bc:	48                   	dec    %eax
f01220bd:	a3 9c 2f ac f0       	mov    %eax,0xf0ac2f9c
				set_block_data(next_new_va, remaining_size, 0);
f01220c2:	83 ec 04             	sub    $0x4,%esp
f01220c5:	6a 00                	push   $0x0
f01220c7:	ff 75 bc             	pushl  -0x44(%ebp)
f01220ca:	ff 75 b8             	pushl  -0x48(%ebp)
f01220cd:	e8 06 e9 ff ff       	call   f01209d8 <set_block_data>
f01220d2:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f01220d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01220d8:	eb 0a                	jmp    f01220e4 <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f01220da:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f01220e1:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01220e4:	c9                   	leave  
f01220e5:	c3                   	ret    

f01220e6 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f01220e6:	55                   	push   %ebp
f01220e7:	89 e5                	mov    %esp,%ebp
f01220e9:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f01220ec:	83 ec 04             	sub    $0x4,%esp
f01220ef:	68 8c 15 13 f0       	push   $0xf013158c
f01220f4:	68 58 02 00 00       	push   $0x258
f01220f9:	68 95 14 13 f0       	push   $0xf0131495
f01220fe:	e8 36 e2 fd ff       	call   f0100339 <_panic>

f0122103 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0122103:	55                   	push   %ebp
f0122104:	89 e5                	mov    %esp,%ebp
f0122106:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0122109:	83 ec 04             	sub    $0x4,%esp
f012210c:	68 b4 15 13 f0       	push   $0xf01315b4
f0122111:	68 61 02 00 00       	push   $0x261
f0122116:	68 95 14 13 f0       	push   $0xf0131495
f012211b:	e8 19 e2 fd ff       	call   f0100339 <_panic>

f0122120 <__moddi3>:
f0122120:	55                   	push   %ebp
f0122121:	57                   	push   %edi
f0122122:	56                   	push   %esi
f0122123:	53                   	push   %ebx
f0122124:	83 ec 2c             	sub    $0x2c,%esp
f0122127:	8b 74 24 40          	mov    0x40(%esp),%esi
f012212b:	8b 7c 24 44          	mov    0x44(%esp),%edi
f012212f:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0122133:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0122137:	89 d8                	mov    %ebx,%eax
f0122139:	85 ff                	test   %edi,%edi
f012213b:	0f 88 d3 00 00 00    	js     f0122214 <__moddi3+0xf4>
f0122141:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0122148:	00 
f0122149:	85 c0                	test   %eax,%eax
f012214b:	0f 88 ab 00 00 00    	js     f01221fc <__moddi3+0xdc>
f0122151:	89 0c 24             	mov    %ecx,(%esp)
f0122154:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0122158:	89 74 24 10          	mov    %esi,0x10(%esp)
f012215c:	89 fb                	mov    %edi,%ebx
f012215e:	8b 14 24             	mov    (%esp),%edx
f0122161:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0122165:	89 d0                	mov    %edx,%eax
f0122167:	89 54 24 18          	mov    %edx,0x18(%esp)
f012216b:	89 ca                	mov    %ecx,%edx
f012216d:	8b 0c 24             	mov    (%esp),%ecx
f0122170:	89 34 24             	mov    %esi,(%esp)
f0122173:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0122177:	85 d2                	test   %edx,%edx
f0122179:	75 15                	jne    f0122190 <__moddi3+0x70>
f012217b:	89 c7                	mov    %eax,%edi
f012217d:	39 d8                	cmp    %ebx,%eax
f012217f:	76 5b                	jbe    f01221dc <__moddi3+0xbc>
f0122181:	89 f0                	mov    %esi,%eax
f0122183:	89 da                	mov    %ebx,%edx
f0122185:	f7 f7                	div    %edi
f0122187:	89 d3                	mov    %edx,%ebx
f0122189:	89 d8                	mov    %ebx,%eax
f012218b:	31 d2                	xor    %edx,%edx
f012218d:	eb 09                	jmp    f0122198 <__moddi3+0x78>
f012218f:	90                   	nop
f0122190:	39 fa                	cmp    %edi,%edx
f0122192:	76 1c                	jbe    f01221b0 <__moddi3+0x90>
f0122194:	89 f0                	mov    %esi,%eax
f0122196:	89 fa                	mov    %edi,%edx
f0122198:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f012219c:	85 c9                	test   %ecx,%ecx
f012219e:	74 07                	je     f01221a7 <__moddi3+0x87>
f01221a0:	f7 d8                	neg    %eax
f01221a2:	83 d2 00             	adc    $0x0,%edx
f01221a5:	f7 da                	neg    %edx
f01221a7:	83 c4 2c             	add    $0x2c,%esp
f01221aa:	5b                   	pop    %ebx
f01221ab:	5e                   	pop    %esi
f01221ac:	5f                   	pop    %edi
f01221ad:	5d                   	pop    %ebp
f01221ae:	c3                   	ret    
f01221af:	90                   	nop
f01221b0:	0f bd c2             	bsr    %edx,%eax
f01221b3:	83 f0 1f             	xor    $0x1f,%eax
f01221b6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f01221ba:	75 6c                	jne    f0122228 <__moddi3+0x108>
f01221bc:	39 fa                	cmp    %edi,%edx
f01221be:	72 05                	jb     f01221c5 <__moddi3+0xa5>
f01221c0:	3b 0c 24             	cmp    (%esp),%ecx
f01221c3:	77 0e                	ja     f01221d3 <__moddi3+0xb3>
f01221c5:	8b 34 24             	mov    (%esp),%esi
f01221c8:	29 ce                	sub    %ecx,%esi
f01221ca:	19 d3                	sbb    %edx,%ebx
f01221cc:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f01221d0:	89 34 24             	mov    %esi,(%esp)
f01221d3:	8b 04 24             	mov    (%esp),%eax
f01221d6:	8b 54 24 14          	mov    0x14(%esp),%edx
f01221da:	eb bc                	jmp    f0122198 <__moddi3+0x78>
f01221dc:	85 c9                	test   %ecx,%ecx
f01221de:	75 0b                	jne    f01221eb <__moddi3+0xcb>
f01221e0:	b8 01 00 00 00       	mov    $0x1,%eax
f01221e5:	31 d2                	xor    %edx,%edx
f01221e7:	f7 f1                	div    %ecx
f01221e9:	89 c1                	mov    %eax,%ecx
f01221eb:	89 d8                	mov    %ebx,%eax
f01221ed:	31 d2                	xor    %edx,%edx
f01221ef:	f7 f1                	div    %ecx
f01221f1:	8b 04 24             	mov    (%esp),%eax
f01221f4:	f7 f1                	div    %ecx
f01221f6:	89 d3                	mov    %edx,%ebx
f01221f8:	eb 8f                	jmp    f0122189 <__moddi3+0x69>
f01221fa:	66 90                	xchg   %ax,%ax
f01221fc:	89 c8                	mov    %ecx,%eax
f01221fe:	89 da                	mov    %ebx,%edx
f0122200:	f7 d8                	neg    %eax
f0122202:	83 d2 00             	adc    $0x0,%edx
f0122205:	f7 da                	neg    %edx
f0122207:	89 04 24             	mov    %eax,(%esp)
f012220a:	89 54 24 04          	mov    %edx,0x4(%esp)
f012220e:	e9 45 ff ff ff       	jmp    f0122158 <__moddi3+0x38>
f0122213:	90                   	nop
f0122214:	f7 de                	neg    %esi
f0122216:	83 d7 00             	adc    $0x0,%edi
f0122219:	f7 df                	neg    %edi
f012221b:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0122222:	ff 
f0122223:	e9 21 ff ff ff       	jmp    f0122149 <__moddi3+0x29>
f0122228:	b8 20 00 00 00       	mov    $0x20,%eax
f012222d:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0122231:	29 f8                	sub    %edi,%eax
f0122233:	89 c6                	mov    %eax,%esi
f0122235:	89 44 24 14          	mov    %eax,0x14(%esp)
f0122239:	89 f9                	mov    %edi,%ecx
f012223b:	d3 e2                	shl    %cl,%edx
f012223d:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0122241:	89 e8                	mov    %ebp,%eax
f0122243:	89 f1                	mov    %esi,%ecx
f0122245:	d3 e8                	shr    %cl,%eax
f0122247:	09 d0                	or     %edx,%eax
f0122249:	89 04 24             	mov    %eax,(%esp)
f012224c:	89 ea                	mov    %ebp,%edx
f012224e:	89 f9                	mov    %edi,%ecx
f0122250:	d3 e2                	shl    %cl,%edx
f0122252:	89 d7                	mov    %edx,%edi
f0122254:	89 da                	mov    %ebx,%edx
f0122256:	d3 e2                	shl    %cl,%edx
f0122258:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f012225c:	d3 e5                	shl    %cl,%ebp
f012225e:	8b 44 24 10          	mov    0x10(%esp),%eax
f0122262:	89 f1                	mov    %esi,%ecx
f0122264:	d3 e8                	shr    %cl,%eax
f0122266:	09 d0                	or     %edx,%eax
f0122268:	d3 eb                	shr    %cl,%ebx
f012226a:	89 da                	mov    %ebx,%edx
f012226c:	f7 34 24             	divl   (%esp)
f012226f:	89 d3                	mov    %edx,%ebx
f0122271:	f7 e7                	mul    %edi
f0122273:	89 c6                	mov    %eax,%esi
f0122275:	89 d1                	mov    %edx,%ecx
f0122277:	39 d3                	cmp    %edx,%ebx
f0122279:	72 29                	jb     f01222a4 <__moddi3+0x184>
f012227b:	74 33                	je     f01222b0 <__moddi3+0x190>
f012227d:	89 e8                	mov    %ebp,%eax
f012227f:	29 f0                	sub    %esi,%eax
f0122281:	19 cb                	sbb    %ecx,%ebx
f0122283:	89 de                	mov    %ebx,%esi
f0122285:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0122289:	d3 e6                	shl    %cl,%esi
f012228b:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f012228f:	89 f9                	mov    %edi,%ecx
f0122291:	d3 e8                	shr    %cl,%eax
f0122293:	09 c6                	or     %eax,%esi
f0122295:	89 f0                	mov    %esi,%eax
f0122297:	89 f9                	mov    %edi,%ecx
f0122299:	d3 eb                	shr    %cl,%ebx
f012229b:	89 da                	mov    %ebx,%edx
f012229d:	e9 f6 fe ff ff       	jmp    f0122198 <__moddi3+0x78>
f01222a2:	66 90                	xchg   %ax,%ax
f01222a4:	29 f8                	sub    %edi,%eax
f01222a6:	1b 14 24             	sbb    (%esp),%edx
f01222a9:	89 d1                	mov    %edx,%ecx
f01222ab:	89 c6                	mov    %eax,%esi
f01222ad:	eb ce                	jmp    f012227d <__moddi3+0x15d>
f01222af:	90                   	nop
f01222b0:	39 c5                	cmp    %eax,%ebp
f01222b2:	72 f0                	jb     f01222a4 <__moddi3+0x184>
f01222b4:	89 d9                	mov    %ebx,%ecx
f01222b6:	eb c5                	jmp    f012227d <__moddi3+0x15d>

f01222b8 <__udivdi3>:
f01222b8:	55                   	push   %ebp
f01222b9:	57                   	push   %edi
f01222ba:	56                   	push   %esi
f01222bb:	53                   	push   %ebx
f01222bc:	83 ec 1c             	sub    $0x1c,%esp
f01222bf:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f01222c3:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f01222c7:	8b 7c 24 38          	mov    0x38(%esp),%edi
f01222cb:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f01222cf:	89 ca                	mov    %ecx,%edx
f01222d1:	89 f8                	mov    %edi,%eax
f01222d3:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f01222d7:	85 f6                	test   %esi,%esi
f01222d9:	75 2d                	jne    f0122308 <__udivdi3+0x50>
f01222db:	39 cf                	cmp    %ecx,%edi
f01222dd:	77 65                	ja     f0122344 <__udivdi3+0x8c>
f01222df:	89 fd                	mov    %edi,%ebp
f01222e1:	85 ff                	test   %edi,%edi
f01222e3:	75 0b                	jne    f01222f0 <__udivdi3+0x38>
f01222e5:	b8 01 00 00 00       	mov    $0x1,%eax
f01222ea:	31 d2                	xor    %edx,%edx
f01222ec:	f7 f7                	div    %edi
f01222ee:	89 c5                	mov    %eax,%ebp
f01222f0:	31 d2                	xor    %edx,%edx
f01222f2:	89 c8                	mov    %ecx,%eax
f01222f4:	f7 f5                	div    %ebp
f01222f6:	89 c1                	mov    %eax,%ecx
f01222f8:	89 d8                	mov    %ebx,%eax
f01222fa:	f7 f5                	div    %ebp
f01222fc:	89 cf                	mov    %ecx,%edi
f01222fe:	89 fa                	mov    %edi,%edx
f0122300:	83 c4 1c             	add    $0x1c,%esp
f0122303:	5b                   	pop    %ebx
f0122304:	5e                   	pop    %esi
f0122305:	5f                   	pop    %edi
f0122306:	5d                   	pop    %ebp
f0122307:	c3                   	ret    
f0122308:	39 ce                	cmp    %ecx,%esi
f012230a:	77 28                	ja     f0122334 <__udivdi3+0x7c>
f012230c:	0f bd fe             	bsr    %esi,%edi
f012230f:	83 f7 1f             	xor    $0x1f,%edi
f0122312:	75 40                	jne    f0122354 <__udivdi3+0x9c>
f0122314:	39 ce                	cmp    %ecx,%esi
f0122316:	72 0a                	jb     f0122322 <__udivdi3+0x6a>
f0122318:	3b 44 24 08          	cmp    0x8(%esp),%eax
f012231c:	0f 87 9e 00 00 00    	ja     f01223c0 <__udivdi3+0x108>
f0122322:	b8 01 00 00 00       	mov    $0x1,%eax
f0122327:	89 fa                	mov    %edi,%edx
f0122329:	83 c4 1c             	add    $0x1c,%esp
f012232c:	5b                   	pop    %ebx
f012232d:	5e                   	pop    %esi
f012232e:	5f                   	pop    %edi
f012232f:	5d                   	pop    %ebp
f0122330:	c3                   	ret    
f0122331:	8d 76 00             	lea    0x0(%esi),%esi
f0122334:	31 ff                	xor    %edi,%edi
f0122336:	31 c0                	xor    %eax,%eax
f0122338:	89 fa                	mov    %edi,%edx
f012233a:	83 c4 1c             	add    $0x1c,%esp
f012233d:	5b                   	pop    %ebx
f012233e:	5e                   	pop    %esi
f012233f:	5f                   	pop    %edi
f0122340:	5d                   	pop    %ebp
f0122341:	c3                   	ret    
f0122342:	66 90                	xchg   %ax,%ax
f0122344:	89 d8                	mov    %ebx,%eax
f0122346:	f7 f7                	div    %edi
f0122348:	31 ff                	xor    %edi,%edi
f012234a:	89 fa                	mov    %edi,%edx
f012234c:	83 c4 1c             	add    $0x1c,%esp
f012234f:	5b                   	pop    %ebx
f0122350:	5e                   	pop    %esi
f0122351:	5f                   	pop    %edi
f0122352:	5d                   	pop    %ebp
f0122353:	c3                   	ret    
f0122354:	bd 20 00 00 00       	mov    $0x20,%ebp
f0122359:	89 eb                	mov    %ebp,%ebx
f012235b:	29 fb                	sub    %edi,%ebx
f012235d:	89 f9                	mov    %edi,%ecx
f012235f:	d3 e6                	shl    %cl,%esi
f0122361:	89 c5                	mov    %eax,%ebp
f0122363:	88 d9                	mov    %bl,%cl
f0122365:	d3 ed                	shr    %cl,%ebp
f0122367:	89 e9                	mov    %ebp,%ecx
f0122369:	09 f1                	or     %esi,%ecx
f012236b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f012236f:	89 f9                	mov    %edi,%ecx
f0122371:	d3 e0                	shl    %cl,%eax
f0122373:	89 c5                	mov    %eax,%ebp
f0122375:	89 d6                	mov    %edx,%esi
f0122377:	88 d9                	mov    %bl,%cl
f0122379:	d3 ee                	shr    %cl,%esi
f012237b:	89 f9                	mov    %edi,%ecx
f012237d:	d3 e2                	shl    %cl,%edx
f012237f:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122383:	88 d9                	mov    %bl,%cl
f0122385:	d3 e8                	shr    %cl,%eax
f0122387:	09 c2                	or     %eax,%edx
f0122389:	89 d0                	mov    %edx,%eax
f012238b:	89 f2                	mov    %esi,%edx
f012238d:	f7 74 24 0c          	divl   0xc(%esp)
f0122391:	89 d6                	mov    %edx,%esi
f0122393:	89 c3                	mov    %eax,%ebx
f0122395:	f7 e5                	mul    %ebp
f0122397:	39 d6                	cmp    %edx,%esi
f0122399:	72 19                	jb     f01223b4 <__udivdi3+0xfc>
f012239b:	74 0b                	je     f01223a8 <__udivdi3+0xf0>
f012239d:	89 d8                	mov    %ebx,%eax
f012239f:	31 ff                	xor    %edi,%edi
f01223a1:	e9 58 ff ff ff       	jmp    f01222fe <__udivdi3+0x46>
f01223a6:	66 90                	xchg   %ax,%ax
f01223a8:	8b 54 24 08          	mov    0x8(%esp),%edx
f01223ac:	89 f9                	mov    %edi,%ecx
f01223ae:	d3 e2                	shl    %cl,%edx
f01223b0:	39 c2                	cmp    %eax,%edx
f01223b2:	73 e9                	jae    f012239d <__udivdi3+0xe5>
f01223b4:	8d 43 ff             	lea    -0x1(%ebx),%eax
f01223b7:	31 ff                	xor    %edi,%edi
f01223b9:	e9 40 ff ff ff       	jmp    f01222fe <__udivdi3+0x46>
f01223be:	66 90                	xchg   %ax,%ax
f01223c0:	31 c0                	xor    %eax,%eax
f01223c2:	e9 37 ff ff ff       	jmp    f01222fe <__udivdi3+0x46>
f01223c7:	90                   	nop

f01223c8 <__umoddi3>:
f01223c8:	55                   	push   %ebp
f01223c9:	57                   	push   %edi
f01223ca:	56                   	push   %esi
f01223cb:	53                   	push   %ebx
f01223cc:	83 ec 1c             	sub    $0x1c,%esp
f01223cf:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f01223d3:	8b 74 24 34          	mov    0x34(%esp),%esi
f01223d7:	8b 7c 24 38          	mov    0x38(%esp),%edi
f01223db:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f01223df:	89 44 24 0c          	mov    %eax,0xc(%esp)
f01223e3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f01223e7:	89 f3                	mov    %esi,%ebx
f01223e9:	89 fa                	mov    %edi,%edx
f01223eb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01223ef:	89 34 24             	mov    %esi,(%esp)
f01223f2:	85 c0                	test   %eax,%eax
f01223f4:	75 1a                	jne    f0122410 <__umoddi3+0x48>
f01223f6:	39 f7                	cmp    %esi,%edi
f01223f8:	0f 86 a2 00 00 00    	jbe    f01224a0 <__umoddi3+0xd8>
f01223fe:	89 c8                	mov    %ecx,%eax
f0122400:	89 f2                	mov    %esi,%edx
f0122402:	f7 f7                	div    %edi
f0122404:	89 d0                	mov    %edx,%eax
f0122406:	31 d2                	xor    %edx,%edx
f0122408:	83 c4 1c             	add    $0x1c,%esp
f012240b:	5b                   	pop    %ebx
f012240c:	5e                   	pop    %esi
f012240d:	5f                   	pop    %edi
f012240e:	5d                   	pop    %ebp
f012240f:	c3                   	ret    
f0122410:	39 f0                	cmp    %esi,%eax
f0122412:	0f 87 ac 00 00 00    	ja     f01224c4 <__umoddi3+0xfc>
f0122418:	0f bd e8             	bsr    %eax,%ebp
f012241b:	83 f5 1f             	xor    $0x1f,%ebp
f012241e:	0f 84 ac 00 00 00    	je     f01224d0 <__umoddi3+0x108>
f0122424:	bf 20 00 00 00       	mov    $0x20,%edi
f0122429:	29 ef                	sub    %ebp,%edi
f012242b:	89 fe                	mov    %edi,%esi
f012242d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0122431:	89 e9                	mov    %ebp,%ecx
f0122433:	d3 e0                	shl    %cl,%eax
f0122435:	89 d7                	mov    %edx,%edi
f0122437:	89 f1                	mov    %esi,%ecx
f0122439:	d3 ef                	shr    %cl,%edi
f012243b:	09 c7                	or     %eax,%edi
f012243d:	89 e9                	mov    %ebp,%ecx
f012243f:	d3 e2                	shl    %cl,%edx
f0122441:	89 14 24             	mov    %edx,(%esp)
f0122444:	89 d8                	mov    %ebx,%eax
f0122446:	d3 e0                	shl    %cl,%eax
f0122448:	89 c2                	mov    %eax,%edx
f012244a:	8b 44 24 08          	mov    0x8(%esp),%eax
f012244e:	d3 e0                	shl    %cl,%eax
f0122450:	89 44 24 04          	mov    %eax,0x4(%esp)
f0122454:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122458:	89 f1                	mov    %esi,%ecx
f012245a:	d3 e8                	shr    %cl,%eax
f012245c:	09 d0                	or     %edx,%eax
f012245e:	d3 eb                	shr    %cl,%ebx
f0122460:	89 da                	mov    %ebx,%edx
f0122462:	f7 f7                	div    %edi
f0122464:	89 d3                	mov    %edx,%ebx
f0122466:	f7 24 24             	mull   (%esp)
f0122469:	89 c6                	mov    %eax,%esi
f012246b:	89 d1                	mov    %edx,%ecx
f012246d:	39 d3                	cmp    %edx,%ebx
f012246f:	0f 82 87 00 00 00    	jb     f01224fc <__umoddi3+0x134>
f0122475:	0f 84 91 00 00 00    	je     f012250c <__umoddi3+0x144>
f012247b:	8b 54 24 04          	mov    0x4(%esp),%edx
f012247f:	29 f2                	sub    %esi,%edx
f0122481:	19 cb                	sbb    %ecx,%ebx
f0122483:	89 d8                	mov    %ebx,%eax
f0122485:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0122489:	d3 e0                	shl    %cl,%eax
f012248b:	89 e9                	mov    %ebp,%ecx
f012248d:	d3 ea                	shr    %cl,%edx
f012248f:	09 d0                	or     %edx,%eax
f0122491:	89 e9                	mov    %ebp,%ecx
f0122493:	d3 eb                	shr    %cl,%ebx
f0122495:	89 da                	mov    %ebx,%edx
f0122497:	83 c4 1c             	add    $0x1c,%esp
f012249a:	5b                   	pop    %ebx
f012249b:	5e                   	pop    %esi
f012249c:	5f                   	pop    %edi
f012249d:	5d                   	pop    %ebp
f012249e:	c3                   	ret    
f012249f:	90                   	nop
f01224a0:	89 fd                	mov    %edi,%ebp
f01224a2:	85 ff                	test   %edi,%edi
f01224a4:	75 0b                	jne    f01224b1 <__umoddi3+0xe9>
f01224a6:	b8 01 00 00 00       	mov    $0x1,%eax
f01224ab:	31 d2                	xor    %edx,%edx
f01224ad:	f7 f7                	div    %edi
f01224af:	89 c5                	mov    %eax,%ebp
f01224b1:	89 f0                	mov    %esi,%eax
f01224b3:	31 d2                	xor    %edx,%edx
f01224b5:	f7 f5                	div    %ebp
f01224b7:	89 c8                	mov    %ecx,%eax
f01224b9:	f7 f5                	div    %ebp
f01224bb:	89 d0                	mov    %edx,%eax
f01224bd:	e9 44 ff ff ff       	jmp    f0122406 <__umoddi3+0x3e>
f01224c2:	66 90                	xchg   %ax,%ax
f01224c4:	89 c8                	mov    %ecx,%eax
f01224c6:	89 f2                	mov    %esi,%edx
f01224c8:	83 c4 1c             	add    $0x1c,%esp
f01224cb:	5b                   	pop    %ebx
f01224cc:	5e                   	pop    %esi
f01224cd:	5f                   	pop    %edi
f01224ce:	5d                   	pop    %ebp
f01224cf:	c3                   	ret    
f01224d0:	3b 04 24             	cmp    (%esp),%eax
f01224d3:	72 06                	jb     f01224db <__umoddi3+0x113>
f01224d5:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f01224d9:	77 0f                	ja     f01224ea <__umoddi3+0x122>
f01224db:	89 f2                	mov    %esi,%edx
f01224dd:	29 f9                	sub    %edi,%ecx
f01224df:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f01224e3:	89 14 24             	mov    %edx,(%esp)
f01224e6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01224ea:	8b 44 24 04          	mov    0x4(%esp),%eax
f01224ee:	8b 14 24             	mov    (%esp),%edx
f01224f1:	83 c4 1c             	add    $0x1c,%esp
f01224f4:	5b                   	pop    %ebx
f01224f5:	5e                   	pop    %esi
f01224f6:	5f                   	pop    %edi
f01224f7:	5d                   	pop    %ebp
f01224f8:	c3                   	ret    
f01224f9:	8d 76 00             	lea    0x0(%esi),%esi
f01224fc:	2b 04 24             	sub    (%esp),%eax
f01224ff:	19 fa                	sbb    %edi,%edx
f0122501:	89 d1                	mov    %edx,%ecx
f0122503:	89 c6                	mov    %eax,%esi
f0122505:	e9 71 ff ff ff       	jmp    f012247b <__umoddi3+0xb3>
f012250a:	66 90                	xchg   %ax,%ax
f012250c:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0122510:	72 ea                	jb     f01224fc <__umoddi3+0x134>
f0122512:	89 d9                	mov    %ebx,%ecx
f0122514:	e9 62 ff ff ff       	jmp    f012247b <__umoddi3+0xb3>
