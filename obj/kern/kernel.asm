
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 50 39 5a f0 01 	movl   $0x1,0xf05a3950
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 a4 38 5a f0 01 	movl   $0x1,0xf05a38a4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 30 64 5c f0       	mov    $0xf05c6430,%edx
f010006a:	b8 50 01 5a f0       	mov    $0xf05a0150,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 50 01 5a f0       	push   $0xf05a0150
f010007e:	e8 40 27 02 00       	call   f01227c3 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 8d 0d 00 00       	call   f0100e18 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 11 02 00 00       	call   f01002a1 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 c0 40 12 f0       	push   $0xf01240c0
f0100098:	e8 cf 0e 00 00       	call   f0100f6c <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 07 41 12 f0       	push   $0xf0124107
f01000a8:	e8 bf 0e 00 00       	call   f0100f6c <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 1b 41 12 f0       	push   $0xf012411b
f01000b8:	e8 af 0e 00 00       	call   f0100f6c <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 2f 41 12 f0       	push   $0xf012412f
f01000c8:	e8 9f 0e 00 00       	call   f0100f6c <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 2d 70 00 00       	call   f0107107 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 3b 41 12 f0       	push   $0xf012413b
f01000e5:	e8 82 0e 00 00       	call   f0100f6c <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 43 41 12 f0       	push   $0xf0124143
f01000f5:	e8 72 0e 00 00       	call   f0100f6c <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 65 79 00 00       	call   f0107a67 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 13 75 00 00       	call   f010761a <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 e0 7c 00 00       	call   f0107dec <initialize_paging>
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010010c:	e8 b7 e5 00 00       	call   f010e6c8 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100111:	e8 39 ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100116:	e8 24 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010011b:	83 ec 0c             	sub    $0xc,%esp
f010011e:	6a 00                	push   $0x0
f0100120:	e8 a0 e6 00 00       	call   f010e7c5 <enableBuffering>
f0100125:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100128:	83 ec 0c             	sub    $0xc,%esp
f010012b:	6a 00                	push   $0x0
f010012d:	e8 7b e6 00 00       	call   f010e7ad <enableModifiedBuffer>
f0100132:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100135:	83 ec 0c             	sub    $0xc,%esp
f0100138:	68 e8 03 00 00       	push   $0x3e8
f010013d:	e8 9b e6 00 00       	call   f010e7dd <setModifiedBufferLength>
f0100142:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100145:	e8 d0 2b 02 00       	call   f0122d1a <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f010014a:	83 ec 0c             	sub    $0xc,%esp
f010014d:	68 51 41 12 f0       	push   $0xf0124151
f0100152:	e8 15 0e 00 00       	call   f0100f6c <cprintf>
f0100157:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f010015a:	e8 c3 96 00 00       	call   f0109822 <env_init>
		ts_init();
f010015f:	e8 30 bf 00 00       	call   f010c094 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100164:	83 ec 0c             	sub    $0xc,%esp
f0100167:	68 3b 41 12 f0       	push   $0xf012413b
f010016c:	e8 fb 0d 00 00       	call   f0100f6c <cprintf>
f0100171:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100174:	83 ec 0c             	sub    $0xc,%esp
f0100177:	68 64 41 12 f0       	push   $0xf0124164
f010017c:	e8 eb 0d 00 00       	call   f0100f6c <cprintf>
f0100181:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f0100184:	e8 6a 6c 00 00       	call   f0106df3 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100189:	83 ec 0c             	sub    $0xc,%esp
f010018c:	68 8d 41 12 f0       	push   $0xf012418d
f0100191:	e8 d6 0d 00 00       	call   f0100f6c <cprintf>
f0100196:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100199:	83 ec 0c             	sub    $0xc,%esp
f010019c:	6a 00                	push   $0x0
f010019e:	e8 42 6e 00 00       	call   f0106fe5 <irq_clear_mask>
f01001a3:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001a6:	83 ec 0c             	sub    $0xc,%esp
f01001a9:	68 a3 41 12 f0       	push   $0xf01241a3
f01001ae:	e8 b9 0d 00 00       	call   f0100f6c <cprintf>
f01001b3:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001b6:	83 ec 0c             	sub    $0xc,%esp
f01001b9:	6a 01                	push   $0x1
f01001bb:	e8 25 6e 00 00       	call   f0106fe5 <irq_clear_mask>
f01001c0:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001c3:	83 ec 0c             	sub    $0xc,%esp
f01001c6:	68 c0 41 12 f0       	push   $0xf01241c0
f01001cb:	e8 9c 0d 00 00       	call   f0100f6c <cprintf>
f01001d0:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001d3:	83 ec 0c             	sub    $0xc,%esp
f01001d6:	6a 04                	push   $0x4
f01001d8:	e8 08 6e 00 00       	call   f0106fe5 <irq_clear_mask>
f01001dd:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001e0:	83 ec 0c             	sub    $0xc,%esp
f01001e3:	68 df 41 12 f0       	push   $0xf01241df
f01001e8:	e8 7f 0d 00 00       	call   f0100f6c <cprintf>
f01001ed:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f01001f0:	83 ec 0c             	sub    $0xc,%esp
f01001f3:	68 fc 41 12 f0       	push   $0xf01241fc
f01001f8:	e8 6f 0d 00 00       	call   f0100f6c <cprintf>
f01001fd:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f0100200:	e8 c1 49 00 00       	call   f0104bc6 <kclock_init>
		sched_init() ;
f0100205:	e8 44 65 00 00       	call   f010674e <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f010020a:	83 ec 0c             	sub    $0xc,%esp
f010020d:	68 20 42 12 f0       	push   $0xf0124220
f0100212:	e8 55 0d 00 00       	call   f0100f6c <cprintf>
f0100217:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010021a:	89 e0                	mov    %esp,%eax
f010021c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010021f:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100222:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100225:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f010022a:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010022d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100230:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100235:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100238:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010023b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010023e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100241:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100244:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100246:	89 e0                	mov    %esp,%eax
f0100248:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010024b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010024e:	83 ec 04             	sub    $0x4,%esp
f0100251:	50                   	push   %eax
f0100252:	ff 75 f4             	pushl  -0xc(%ebp)
f0100255:	68 40 42 12 f0       	push   $0xf0124240
f010025a:	e8 0d 0d 00 00       	call   f0100f6c <cprintf>
f010025f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100262:	83 ec 0c             	sub    $0xc,%esp
f0100265:	68 64 42 12 f0       	push   $0xf0124264
f010026a:	e8 fd 0c 00 00       	call   f0100f6c <cprintf>
f010026f:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100272:	c7 05 7c 3b 5a f0 00 	movl   $0x0,0xf05a3b7c
f0100279:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010027c:	83 ec 0c             	sub    $0xc,%esp
f010027f:	68 ac 42 12 f0       	push   $0xf01242ac
f0100284:	e8 e3 0c 00 00       	call   f0100f6c <cprintf>
f0100289:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f010028c:	83 ec 0c             	sub    $0xc,%esp
f010028f:	68 d8 42 12 f0       	push   $0xf01242d8
f0100294:	e8 d3 0c 00 00       	call   f0100f6c <cprintf>
f0100299:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f010029c:	e8 02 1b 00 00       	call   f0101da3 <get_into_prompt>

f01002a1 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002a1:	55                   	push   %ebp
f01002a2:	89 e5                	mov    %esp,%ebp
f01002a4:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002a7:	83 ec 0c             	sub    $0xc,%esp
f01002aa:	68 fd 42 12 f0       	push   $0xf01242fd
f01002af:	e8 b8 0c 00 00       	call   f0100f6c <cprintf>
f01002b4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002b7:	83 ec 0c             	sub    $0xc,%esp
f01002ba:	68 04 43 12 f0       	push   $0xf0124304
f01002bf:	e8 a8 0c 00 00       	call   f0100f6c <cprintf>
f01002c4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002c7:	83 ec 0c             	sub    $0xc,%esp
f01002ca:	68 4c 43 12 f0       	push   $0xf012434c
f01002cf:	e8 98 0c 00 00       	call   f0100f6c <cprintf>
f01002d4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002d7:	83 ec 0c             	sub    $0xc,%esp
f01002da:	68 94 43 12 f0       	push   $0xf0124394
f01002df:	e8 88 0c 00 00       	call   f0100f6c <cprintf>
f01002e4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e7:	83 ec 0c             	sub    $0xc,%esp
f01002ea:	68 4c 43 12 f0       	push   $0xf012434c
f01002ef:	e8 78 0c 00 00       	call   f0100f6c <cprintf>
f01002f4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002f7:	83 ec 0c             	sub    $0xc,%esp
f01002fa:	68 04 43 12 f0       	push   $0xf0124304
f01002ff:	e8 68 0c 00 00       	call   f0100f6c <cprintf>
f0100304:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100307:	83 ec 0c             	sub    $0xc,%esp
f010030a:	68 d9 43 12 f0       	push   $0xf01243d9
f010030f:	e8 58 0c 00 00       	call   f0100f6c <cprintf>
f0100314:	83 c4 10             	add    $0x10,%esp
}
f0100317:	90                   	nop
f0100318:	c9                   	leave  
f0100319:	c3                   	ret    

f010031a <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f010031a:	55                   	push   %ebp
f010031b:	89 e5                	mov    %esp,%ebp
f010031d:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100320:	e8 4b a4 00 00       	call   f010a770 <get_cpu_proc>
f0100325:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100328:	8b 45 10             	mov    0x10(%ebp),%eax
f010032b:	a3 60 01 5a f0       	mov    %eax,0xf05a0160

	va_start(ap, fmt);
f0100330:	8d 45 10             	lea    0x10(%ebp),%eax
f0100333:	83 c0 04             	add    $0x4,%eax
f0100336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100339:	83 ec 04             	sub    $0x4,%esp
f010033c:	ff 75 0c             	pushl  0xc(%ebp)
f010033f:	ff 75 08             	pushl  0x8(%ebp)
f0100342:	68 e0 43 12 f0       	push   $0xf01243e0
f0100347:	e8 20 0c 00 00       	call   f0100f6c <cprintf>
f010034c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010034f:	8b 45 10             	mov    0x10(%ebp),%eax
f0100352:	83 ec 08             	sub    $0x8,%esp
f0100355:	ff 75 f0             	pushl  -0x10(%ebp)
f0100358:	50                   	push   %eax
f0100359:	e8 e5 0b 00 00       	call   f0100f43 <vcprintf>
f010035e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100361:	83 ec 0c             	sub    $0xc,%esp
f0100364:	68 05 44 12 f0       	push   $0xf0124405
f0100369:	e8 fe 0b 00 00       	call   f0100f6c <cprintf>
f010036e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100371:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100375:	74 10                	je     f0100387 <_panic+0x6d>
f0100377:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010037a:	8b 40 18             	mov    0x18(%eax),%eax
f010037d:	83 f8 02             	cmp    $0x2,%eax
f0100380:	75 05                	jne    f0100387 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100382:	e8 a7 a3 00 00       	call   f010a72e <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100387:	89 e0                	mov    %esp,%eax
f0100389:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010038c:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f010038f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100392:	83 ec 08             	sub    $0x8,%esp
f0100395:	ff 75 ec             	pushl  -0x14(%ebp)
f0100398:	68 07 44 12 f0       	push   $0xf0124407
f010039d:	e8 ca 0b 00 00       	call   f0100f6c <cprintf>
f01003a2:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003a5:	e8 f9 19 00 00       	call   f0101da3 <get_into_prompt>

f01003aa <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003aa:	55                   	push   %ebp
f01003ab:	89 e5                	mov    %esp,%ebp
f01003ad:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01003b3:	a3 60 01 5a f0       	mov    %eax,0xf05a0160

	va_start(ap, fmt);
f01003b8:	8d 45 10             	lea    0x10(%ebp),%eax
f01003bb:	83 c0 04             	add    $0x4,%eax
f01003be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003c1:	83 ec 04             	sub    $0x4,%esp
f01003c4:	ff 75 0c             	pushl  0xc(%ebp)
f01003c7:	ff 75 08             	pushl  0x8(%ebp)
f01003ca:	68 11 44 12 f0       	push   $0xf0124411
f01003cf:	e8 98 0b 00 00       	call   f0100f6c <cprintf>
f01003d4:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003d7:	8b 45 10             	mov    0x10(%ebp),%eax
f01003da:	83 ec 08             	sub    $0x8,%esp
f01003dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01003e0:	50                   	push   %eax
f01003e1:	e8 5d 0b 00 00       	call   f0100f43 <vcprintf>
f01003e6:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01003e9:	83 ec 0c             	sub    $0xc,%esp
f01003ec:	68 05 44 12 f0       	push   $0xf0124405
f01003f1:	e8 76 0b 00 00       	call   f0100f6c <cprintf>
f01003f6:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f01003f9:	e8 c2 6d 00 00       	call   f01071c0 <pushcli>
	struct cpu *c = mycpu();
f01003fe:	e8 fa 6c 00 00       	call   f01070fd <mycpu>
f0100403:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100406:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100409:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010040f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100412:	e8 fb 6d 00 00       	call   f0107212 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100417:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010041b:	74 23                	je     f0100440 <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010041d:	e8 b2 60 00 00       	call   f01064d4 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100422:	e8 49 a3 00 00       	call   f010a770 <get_cpu_proc>
f0100427:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010042a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010042e:	74 10                	je     f0100440 <_panic_all+0x96>
f0100430:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100433:	8b 40 18             	mov    0x18(%eax),%eax
f0100436:	83 f8 02             	cmp    $0x2,%eax
f0100439:	75 05                	jne    f0100440 <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010043b:	e8 ee a2 00 00       	call   f010a72e <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f0100440:	e8 5e 19 00 00       	call   f0101da3 <get_into_prompt>

f0100445 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100445:	55                   	push   %ebp
f0100446:	89 e5                	mov    %esp,%ebp
f0100448:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010044b:	8b 45 10             	mov    0x10(%ebp),%eax
f010044e:	a3 60 01 5a f0       	mov    %eax,0xf05a0160

	va_start(ap, fmt);
f0100453:	8d 45 10             	lea    0x10(%ebp),%eax
f0100456:	83 c0 04             	add    $0x4,%eax
f0100459:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010045c:	83 ec 04             	sub    $0x4,%esp
f010045f:	ff 75 0c             	pushl  0xc(%ebp)
f0100462:	ff 75 08             	pushl  0x8(%ebp)
f0100465:	68 11 44 12 f0       	push   $0xf0124411
f010046a:	e8 fd 0a 00 00       	call   f0100f6c <cprintf>
f010046f:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100472:	8b 45 10             	mov    0x10(%ebp),%eax
f0100475:	83 ec 08             	sub    $0x8,%esp
f0100478:	ff 75 f4             	pushl  -0xc(%ebp)
f010047b:	50                   	push   %eax
f010047c:	e8 c2 0a 00 00       	call   f0100f43 <vcprintf>
f0100481:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100484:	83 ec 0c             	sub    $0xc,%esp
f0100487:	68 05 44 12 f0       	push   $0xf0124405
f010048c:	e8 db 0a 00 00       	call   f0100f6c <cprintf>
f0100491:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0100494:	e8 d7 a2 00 00       	call   f010a770 <get_cpu_proc>
f0100499:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010049c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004a0:	74 10                	je     f01004b2 <_panic_into_prompt+0x6d>
f01004a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004a5:	8b 40 18             	mov    0x18(%eax),%eax
f01004a8:	83 f8 02             	cmp    $0x2,%eax
f01004ab:	75 05                	jne    f01004b2 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004ad:	e8 7c a2 00 00       	call   f010a72e <env_exit>
	}

	get_into_prompt();
f01004b2:	e8 ec 18 00 00       	call   f0101da3 <get_into_prompt>

f01004b7 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004b7:	55                   	push   %ebp
f01004b8:	89 e5                	mov    %esp,%ebp
f01004ba:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004bd:	8d 45 10             	lea    0x10(%ebp),%eax
f01004c0:	83 c0 04             	add    $0x4,%eax
f01004c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004c6:	83 ec 04             	sub    $0x4,%esp
f01004c9:	ff 75 0c             	pushl  0xc(%ebp)
f01004cc:	ff 75 08             	pushl  0x8(%ebp)
f01004cf:	68 2a 44 12 f0       	push   $0xf012442a
f01004d4:	e8 93 0a 00 00       	call   f0100f6c <cprintf>
f01004d9:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004dc:	8b 45 10             	mov    0x10(%ebp),%eax
f01004df:	83 ec 08             	sub    $0x8,%esp
f01004e2:	ff 75 f4             	pushl  -0xc(%ebp)
f01004e5:	50                   	push   %eax
f01004e6:	e8 58 0a 00 00       	call   f0100f43 <vcprintf>
f01004eb:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004ee:	83 ec 0c             	sub    $0xc,%esp
f01004f1:	68 05 44 12 f0       	push   $0xf0124405
f01004f6:	e8 71 0a 00 00       	call   f0100f6c <cprintf>
f01004fb:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f01004fe:	90                   	nop
f01004ff:	c9                   	leave  
f0100500:	c3                   	ret    

f0100501 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100501:	55                   	push   %ebp
f0100502:	89 e5                	mov    %esp,%ebp
f0100504:	83 ec 10             	sub    $0x10,%esp
f0100507:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010050e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100511:	89 c2                	mov    %eax,%edx
f0100513:	ec                   	in     (%dx),%al
f0100514:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100517:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f010051a:	0f b6 c0             	movzbl %al,%eax
f010051d:	83 e0 01             	and    $0x1,%eax
f0100520:	85 c0                	test   %eax,%eax
f0100522:	75 07                	jne    f010052b <serial_proc_data+0x2a>
		return -1;
f0100524:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100529:	eb 16                	jmp    f0100541 <serial_proc_data+0x40>
f010052b:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100532:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100535:	89 c2                	mov    %eax,%edx
f0100537:	ec                   	in     (%dx),%al
f0100538:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010053b:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010053e:	0f b6 c0             	movzbl %al,%eax
}
f0100541:	c9                   	leave  
f0100542:	c3                   	ret    

f0100543 <serial_intr>:

void
serial_intr(void)
{
f0100543:	55                   	push   %ebp
f0100544:	89 e5                	mov    %esp,%ebp
f0100546:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100549:	a1 84 01 5a f0       	mov    0xf05a0184,%eax
f010054e:	85 c0                	test   %eax,%eax
f0100550:	74 10                	je     f0100562 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100552:	83 ec 0c             	sub    $0xc,%esp
f0100555:	68 01 05 10 f0       	push   $0xf0100501
f010055a:	e8 9d 07 00 00       	call   f0100cfc <cons_intr>
f010055f:	83 c4 10             	add    $0x10,%esp
}
f0100562:	90                   	nop
f0100563:	c9                   	leave  
f0100564:	c3                   	ret    

f0100565 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100565:	55                   	push   %ebp
f0100566:	89 e5                	mov    %esp,%ebp
f0100568:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010056b:	83 ec 0c             	sub    $0xc,%esp
f010056e:	68 48 44 12 f0       	push   $0xf0124448
f0100573:	e8 f4 09 00 00       	call   f0100f6c <cprintf>
f0100578:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010057b:	e8 c3 ff ff ff       	call   f0100543 <serial_intr>
}
f0100580:	90                   	nop
f0100581:	c9                   	leave  
f0100582:	c3                   	ret    

f0100583 <serial_init>:

void
serial_init(void)
{
f0100583:	55                   	push   %ebp
f0100584:	89 e5                	mov    %esp,%ebp
f0100586:	83 ec 48             	sub    $0x48,%esp
f0100589:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f0100590:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100594:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0100597:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010059a:	ee                   	out    %al,(%dx)
f010059b:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005a2:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005a6:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005ac:	ee                   	out    %al,(%dx)
f01005ad:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005b4:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005b8:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005be:	ee                   	out    %al,(%dx)
f01005bf:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005c6:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005ca:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005d0:	ee                   	out    %al,(%dx)
f01005d1:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005d8:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005dc:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01005e2:	ee                   	out    %al,(%dx)
f01005e3:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f01005ea:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f01005ee:	8a 45 cb             	mov    -0x35(%ebp),%al
f01005f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01005f4:	ee                   	out    %al,(%dx)
f01005f5:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f01005fc:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f0100600:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100603:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100606:	ee                   	out    %al,(%dx)
f0100607:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010060e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100611:	89 c2                	mov    %eax,%edx
f0100613:	ec                   	in     (%dx),%al
f0100614:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100617:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f010061a:	3c ff                	cmp    $0xff,%al
f010061c:	0f 95 c0             	setne  %al
f010061f:	0f b6 c0             	movzbl %al,%eax
f0100622:	a3 84 01 5a f0       	mov    %eax,0xf05a0184
f0100627:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100631:	89 c2                	mov    %eax,%edx
f0100633:	ec                   	in     (%dx),%al
f0100634:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100637:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010063e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100641:	89 c2                	mov    %eax,%edx
f0100643:	ec                   	in     (%dx),%al
f0100644:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100647:	83 ec 08             	sub    $0x8,%esp
f010064a:	68 65 05 10 f0       	push   $0xf0100565
f010064f:	6a 04                	push   $0x4
f0100651:	e8 42 cd 00 00       	call   f010d398 <irq_install_handler>
f0100656:	83 c4 10             	add    $0x10,%esp

}
f0100659:	90                   	nop
f010065a:	c9                   	leave  
f010065b:	c3                   	ret    

f010065c <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010065c:	55                   	push   %ebp
f010065d:	89 e5                	mov    %esp,%ebp
f010065f:	83 ec 20             	sub    $0x20,%esp
f0100662:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100669:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010066c:	89 c2                	mov    %eax,%edx
f010066e:	ec                   	in     (%dx),%al
f010066f:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100672:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100679:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010067c:	89 c2                	mov    %eax,%edx
f010067e:	ec                   	in     (%dx),%al
f010067f:	88 45 ed             	mov    %al,-0x13(%ebp)
f0100682:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0100689:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010068c:	89 c2                	mov    %eax,%edx
f010068e:	ec                   	in     (%dx),%al
f010068f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0100692:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0100699:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010069c:	89 c2                	mov    %eax,%edx
f010069e:	ec                   	in     (%dx),%al
f010069f:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006a2:	90                   	nop
f01006a3:	c9                   	leave  
f01006a4:	c3                   	ret    

f01006a5 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006a5:	55                   	push   %ebp
f01006a6:	89 e5                	mov    %esp,%ebp
f01006a8:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006b2:	eb 08                	jmp    f01006bc <lpt_putc+0x17>
		delay();
f01006b4:	e8 a3 ff ff ff       	call   f010065c <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006b9:	ff 45 fc             	incl   -0x4(%ebp)
f01006bc:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006c6:	89 c2                	mov    %eax,%edx
f01006c8:	ec                   	in     (%dx),%al
f01006c9:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006cc:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006cf:	84 c0                	test   %al,%al
f01006d1:	78 09                	js     f01006dc <lpt_putc+0x37>
f01006d3:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006da:	7e d8                	jle    f01006b4 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01006df:	0f b6 c0             	movzbl %al,%eax
f01006e2:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f01006e9:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01006ec:	8a 45 e8             	mov    -0x18(%ebp),%al
f01006ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01006f2:	ee                   	out    %al,(%dx)
f01006f3:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f01006fa:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f01006fe:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100701:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100704:	ee                   	out    %al,(%dx)
f0100705:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010070c:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f0100710:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100713:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100716:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100717:	90                   	nop
f0100718:	c9                   	leave  
f0100719:	c3                   	ret    

f010071a <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f010071a:	55                   	push   %ebp
f010071b:	89 e5                	mov    %esp,%ebp
f010071d:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f0100720:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100727:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010072a:	66 8b 00             	mov    (%eax),%ax
f010072d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100731:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100734:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100739:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010073c:	66 8b 00             	mov    (%eax),%ax
f010073f:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100743:	74 13                	je     f0100758 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100745:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010074c:	c7 05 88 01 5a f0 b4 	movl   $0x3b4,0xf05a0188
f0100753:	03 00 00 
f0100756:	eb 14                	jmp    f010076c <cga_init+0x52>
	} else {
		*cp = was;
f0100758:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010075b:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010075f:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100762:	c7 05 88 01 5a f0 d4 	movl   $0x3d4,0xf05a0188
f0100769:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010076c:	a1 88 01 5a f0       	mov    0xf05a0188,%eax
f0100771:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100774:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100778:	8a 45 e0             	mov    -0x20(%ebp),%al
f010077b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010077e:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010077f:	a1 88 01 5a f0       	mov    0xf05a0188,%eax
f0100784:	40                   	inc    %eax
f0100785:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100788:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010078b:	89 c2                	mov    %eax,%edx
f010078d:	ec                   	in     (%dx),%al
f010078e:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f0100791:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100794:	0f b6 c0             	movzbl %al,%eax
f0100797:	c1 e0 08             	shl    $0x8,%eax
f010079a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f010079d:	a1 88 01 5a f0       	mov    0xf05a0188,%eax
f01007a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007a5:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007a9:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007af:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007b0:	a1 88 01 5a f0       	mov    0xf05a0188,%eax
f01007b5:	40                   	inc    %eax
f01007b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007bc:	89 c2                	mov    %eax,%edx
f01007be:	ec                   	in     (%dx),%al
f01007bf:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007c2:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007c5:	0f b6 c0             	movzbl %al,%eax
f01007c8:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ce:	a3 8c 01 5a f0       	mov    %eax,0xf05a018c
	crt_pos = pos;
f01007d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007d6:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
}
f01007dc:	90                   	nop
f01007dd:	c9                   	leave  
f01007de:	c3                   	ret    

f01007df <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007df:	55                   	push   %ebp
f01007e0:	89 e5                	mov    %esp,%ebp
f01007e2:	53                   	push   %ebx
f01007e3:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f01007e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007e9:	b0 00                	mov    $0x0,%al
f01007eb:	85 c0                	test   %eax,%eax
f01007ed:	75 07                	jne    f01007f6 <cga_putc+0x17>
		c |= 0x0700;
f01007ef:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f01007f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007f9:	0f b6 c0             	movzbl %al,%eax
f01007fc:	83 f8 0a             	cmp    $0xa,%eax
f01007ff:	74 77                	je     f0100878 <cga_putc+0x99>
f0100801:	83 f8 0a             	cmp    $0xa,%eax
f0100804:	7f 13                	jg     f0100819 <cga_putc+0x3a>
f0100806:	83 f8 08             	cmp    $0x8,%eax
f0100809:	74 2e                	je     f0100839 <cga_putc+0x5a>
f010080b:	83 f8 09             	cmp    $0x9,%eax
f010080e:	0f 84 a8 00 00 00    	je     f01008bc <cga_putc+0xdd>
f0100814:	e9 22 01 00 00       	jmp    f010093b <cga_putc+0x15c>
f0100819:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010081e:	0f 84 de 00 00 00    	je     f0100902 <cga_putc+0x123>
f0100824:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100829:	0f 84 f1 00 00 00    	je     f0100920 <cga_putc+0x141>
f010082f:	83 f8 0d             	cmp    $0xd,%eax
f0100832:	74 5d                	je     f0100891 <cga_putc+0xb2>
f0100834:	e9 02 01 00 00       	jmp    f010093b <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100839:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f010083f:	66 85 c0             	test   %ax,%ax
f0100842:	0f 84 4f 01 00 00    	je     f0100997 <cga_putc+0x1b8>
			crt_pos--;
f0100848:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f010084e:	48                   	dec    %eax
f010084f:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100855:	8b 15 8c 01 5a f0    	mov    0xf05a018c,%edx
f010085b:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100861:	0f b7 c0             	movzwl %ax,%eax
f0100864:	01 c0                	add    %eax,%eax
f0100866:	01 c2                	add    %eax,%edx
f0100868:	8b 45 08             	mov    0x8(%ebp),%eax
f010086b:	b0 00                	mov    $0x0,%al
f010086d:	83 c8 20             	or     $0x20,%eax
f0100870:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100873:	e9 1f 01 00 00       	jmp    f0100997 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100878:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f010087e:	83 c0 50             	add    $0x50,%eax
f0100881:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
		text_length = 0;
f0100887:	c7 05 80 01 5a f0 00 	movl   $0x0,0xf05a0180
f010088e:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f0100891:	66 8b 0d 90 01 5a f0 	mov    0xf05a0190,%cx
f0100898:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f010089e:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008a3:	ba 00 00 00 00       	mov    $0x0,%edx
f01008a8:	66 f7 f3             	div    %bx
f01008ab:	89 d0                	mov    %edx,%eax
f01008ad:	29 c1                	sub    %eax,%ecx
f01008af:	89 c8                	mov    %ecx,%eax
f01008b1:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
		break;
f01008b7:	e9 e5 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008bc:	83 ec 0c             	sub    $0xc,%esp
f01008bf:	6a 20                	push   $0x20
f01008c1:	e8 30 05 00 00       	call   f0100df6 <cons_putc>
f01008c6:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008c9:	83 ec 0c             	sub    $0xc,%esp
f01008cc:	6a 20                	push   $0x20
f01008ce:	e8 23 05 00 00       	call   f0100df6 <cons_putc>
f01008d3:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008d6:	83 ec 0c             	sub    $0xc,%esp
f01008d9:	6a 20                	push   $0x20
f01008db:	e8 16 05 00 00       	call   f0100df6 <cons_putc>
f01008e0:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e3:	83 ec 0c             	sub    $0xc,%esp
f01008e6:	6a 20                	push   $0x20
f01008e8:	e8 09 05 00 00       	call   f0100df6 <cons_putc>
f01008ed:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f0:	83 ec 0c             	sub    $0xc,%esp
f01008f3:	6a 20                	push   $0x20
f01008f5:	e8 fc 04 00 00       	call   f0100df6 <cons_putc>
f01008fa:	83 c4 10             	add    $0x10,%esp
		break;
f01008fd:	e9 9f 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100902:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100908:	66 85 c0             	test   %ax,%ax
f010090b:	0f 84 89 00 00 00    	je     f010099a <cga_putc+0x1bb>
			crt_pos--;
f0100911:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100917:	48                   	dec    %eax
f0100918:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
		break;
f010091e:	eb 7a                	jmp    f010099a <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f0100920:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100926:	66 3d cf 07          	cmp    $0x7cf,%ax
f010092a:	77 71                	ja     f010099d <cga_putc+0x1be>
			crt_pos++;
f010092c:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100932:	40                   	inc    %eax
f0100933:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
		break;
f0100939:	eb 62                	jmp    f010099d <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010093b:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100942:	74 5c                	je     f01009a0 <cga_putc+0x1c1>
f0100944:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010094b:	74 53                	je     f01009a0 <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010094d:	8b 0d 8c 01 5a f0    	mov    0xf05a018c,%ecx
f0100953:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100959:	8d 50 01             	lea    0x1(%eax),%edx
f010095c:	66 89 15 90 01 5a f0 	mov    %dx,0xf05a0190
f0100963:	0f b7 c0             	movzwl %ax,%eax
f0100966:	01 c0                	add    %eax,%eax
f0100968:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010096b:	8b 45 08             	mov    0x8(%ebp),%eax
f010096e:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100971:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100977:	0f b7 c0             	movzwl %ax,%eax
f010097a:	8b 15 80 01 5a f0    	mov    0xf05a0180,%edx
f0100980:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100986:	39 d0                	cmp    %edx,%eax
f0100988:	7e 16                	jle    f01009a0 <cga_putc+0x1c1>
				text_length++;
f010098a:	a1 80 01 5a f0       	mov    0xf05a0180,%eax
f010098f:	40                   	inc    %eax
f0100990:	a3 80 01 5a f0       	mov    %eax,0xf05a0180
		}
		break;
f0100995:	eb 09                	jmp    f01009a0 <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0100997:	90                   	nop
f0100998:	eb 07                	jmp    f01009a1 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f010099a:	90                   	nop
f010099b:	eb 04                	jmp    f01009a1 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010099d:	90                   	nop
f010099e:	eb 01                	jmp    f01009a1 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009a0:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009a1:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f01009a7:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ab:	76 58                	jbe    f0100a05 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009ad:	a1 8c 01 5a f0       	mov    0xf05a018c,%eax
f01009b2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009b8:	a1 8c 01 5a f0       	mov    0xf05a018c,%eax
f01009bd:	83 ec 04             	sub    $0x4,%esp
f01009c0:	68 00 0f 00 00       	push   $0xf00
f01009c5:	52                   	push   %edx
f01009c6:	50                   	push   %eax
f01009c7:	e8 27 1e 02 00       	call   f01227f3 <memcpy>
f01009cc:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009cf:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009d6:	eb 15                	jmp    f01009ed <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009d8:	8b 15 8c 01 5a f0    	mov    0xf05a018c,%edx
f01009de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01009e1:	01 c0                	add    %eax,%eax
f01009e3:	01 d0                	add    %edx,%eax
f01009e5:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ea:	ff 45 f4             	incl   -0xc(%ebp)
f01009ed:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01009f4:	7e e2                	jle    f01009d8 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01009f6:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f01009fc:	83 e8 50             	sub    $0x50,%eax
f01009ff:	66 a3 90 01 5a f0    	mov    %ax,0xf05a0190
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a05:	a1 88 01 5a f0       	mov    0xf05a0188,%eax
f0100a0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a0d:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a11:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a14:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a17:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a18:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100a1e:	66 c1 e8 08          	shr    $0x8,%ax
f0100a22:	0f b6 c0             	movzbl %al,%eax
f0100a25:	8b 15 88 01 5a f0    	mov    0xf05a0188,%edx
f0100a2b:	42                   	inc    %edx
f0100a2c:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a2f:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a32:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a38:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a39:	a1 88 01 5a f0       	mov    0xf05a0188,%eax
f0100a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a41:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a45:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a48:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a4b:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a4c:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100a52:	0f b6 c0             	movzbl %al,%eax
f0100a55:	8b 15 88 01 5a f0    	mov    0xf05a0188,%edx
f0100a5b:	42                   	inc    %edx
f0100a5c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a5f:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a62:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a68:	ee                   	out    %al,(%dx)
}
f0100a69:	90                   	nop
f0100a6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a6d:	c9                   	leave  
f0100a6e:	c3                   	ret    

f0100a6f <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a6f:	55                   	push   %ebp
f0100a70:	89 e5                	mov    %esp,%ebp
f0100a72:	83 ec 28             	sub    $0x28,%esp
f0100a75:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a7f:	89 c2                	mov    %eax,%edx
f0100a81:	ec                   	in     (%dx),%al
f0100a82:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100a85:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100a88:	0f b6 c0             	movzbl %al,%eax
f0100a8b:	83 e0 01             	and    $0x1,%eax
f0100a8e:	85 c0                	test   %eax,%eax
f0100a90:	75 0a                	jne    f0100a9c <kbd_proc_data+0x2d>
		return -1;
f0100a92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100a97:	e9 2a 02 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
f0100a9c:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100aa3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100aa6:	89 c2                	mov    %eax,%edx
f0100aa8:	ec                   	in     (%dx),%al
f0100aa9:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100aac:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100aaf:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ab2:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ab6:	75 17                	jne    f0100acf <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ab8:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100abd:	83 c8 40             	or     $0x40,%eax
f0100ac0:	a3 a8 03 5a f0       	mov    %eax,0xf05a03a8
		return 0;
f0100ac5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100aca:	e9 f7 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100acf:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ad2:	84 c0                	test   %al,%al
f0100ad4:	79 44                	jns    f0100b1a <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100ad6:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100adb:	83 e0 40             	and    $0x40,%eax
f0100ade:	85 c0                	test   %eax,%eax
f0100ae0:	75 08                	jne    f0100aea <kbd_proc_data+0x7b>
f0100ae2:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ae5:	83 e0 7f             	and    $0x7f,%eax
f0100ae8:	eb 03                	jmp    f0100aed <kbd_proc_data+0x7e>
f0100aea:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100aed:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100af0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100af4:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100afa:	83 c8 40             	or     $0x40,%eax
f0100afd:	0f b6 c0             	movzbl %al,%eax
f0100b00:	f7 d0                	not    %eax
f0100b02:	89 c2                	mov    %eax,%edx
f0100b04:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100b09:	21 d0                	and    %edx,%eax
f0100b0b:	a3 a8 03 5a f0       	mov    %eax,0xf05a03a8
		return 0;
f0100b10:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b15:	e9 ac 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b1a:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100b1f:	83 e0 40             	and    $0x40,%eax
f0100b22:	85 c0                	test   %eax,%eax
f0100b24:	74 11                	je     f0100b37 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b26:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b2a:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100b2f:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b32:	a3 a8 03 5a f0       	mov    %eax,0xf05a03a8
	}

	shift |= shiftcode[data];
f0100b37:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b3b:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b41:	0f b6 d0             	movzbl %al,%edx
f0100b44:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100b49:	09 d0                	or     %edx,%eax
f0100b4b:	a3 a8 03 5a f0       	mov    %eax,0xf05a03a8
	shift ^= togglecode[data];
f0100b50:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b54:	8a 80 20 f1 17 f0    	mov    -0xfe80ee0(%eax),%al
f0100b5a:	0f b6 d0             	movzbl %al,%edx
f0100b5d:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100b62:	31 d0                	xor    %edx,%eax
f0100b64:	a3 a8 03 5a f0       	mov    %eax,0xf05a03a8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b69:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100b6e:	83 e0 03             	and    $0x3,%eax
f0100b71:	8b 14 85 20 f5 17 f0 	mov    -0xfe80ae0(,%eax,4),%edx
f0100b78:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b7c:	01 d0                	add    %edx,%eax
f0100b7e:	8a 00                	mov    (%eax),%al
f0100b80:	0f b6 c0             	movzbl %al,%eax
f0100b83:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100b86:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100b8d:	0f 85 9c 00 00 00    	jne    f0100c2f <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100b93:	a1 80 01 5a f0       	mov    0xf05a0180,%eax
f0100b98:	85 c0                	test   %eax,%eax
f0100b9a:	0f 8e 85 00 00 00    	jle    f0100c25 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100ba0:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100ba6:	0f b7 c0             	movzwl %ax,%eax
f0100ba9:	8b 15 80 01 5a f0    	mov    0xf05a0180,%edx
f0100baf:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bb5:	39 d0                	cmp    %edx,%eax
f0100bb7:	75 0a                	jne    f0100bc3 <kbd_proc_data+0x154>
				return 0;
f0100bb9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bbe:	e9 03 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100bc3:	a1 80 01 5a f0       	mov    0xf05a0180,%eax
f0100bc8:	48                   	dec    %eax
f0100bc9:	a3 80 01 5a f0       	mov    %eax,0xf05a0180
				int crt_pos_Length = crt_pos - 1925;
f0100bce:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100bd4:	0f b7 c0             	movzwl %ax,%eax
f0100bd7:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bdc:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bdf:	66 a1 90 01 5a f0    	mov    0xf05a0190,%ax
f0100be5:	0f b7 c0             	movzwl %ax,%eax
f0100be8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100beb:	eb 26                	jmp    f0100c13 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100bed:	8b 15 8c 01 5a f0    	mov    0xf05a018c,%edx
f0100bf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100bf6:	01 c0                	add    %eax,%eax
f0100bf8:	01 c2                	add    %eax,%edx
f0100bfa:	a1 8c 01 5a f0       	mov    0xf05a018c,%eax
f0100bff:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c02:	41                   	inc    %ecx
f0100c03:	01 c9                	add    %ecx,%ecx
f0100c05:	01 c8                	add    %ecx,%eax
f0100c07:	66 8b 00             	mov    (%eax),%ax
f0100c0a:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c0d:	ff 45 e8             	incl   -0x18(%ebp)
f0100c10:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c13:	a1 80 01 5a f0       	mov    0xf05a0180,%eax
f0100c18:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c1b:	7e d0                	jle    f0100bed <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c20:	e9 a1 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c25:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c2a:	e9 97 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c2f:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100c34:	83 e0 08             	and    $0x8,%eax
f0100c37:	85 c0                	test   %eax,%eax
f0100c39:	74 22                	je     f0100c5d <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c3b:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c3f:	7e 0c                	jle    f0100c4d <kbd_proc_data+0x1de>
f0100c41:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c45:	7f 06                	jg     f0100c4d <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c47:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c4b:	eb 10                	jmp    f0100c5d <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c4d:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c51:	7e 0a                	jle    f0100c5d <kbd_proc_data+0x1ee>
f0100c53:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c57:	7f 04                	jg     f0100c5d <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c59:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c5d:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100c62:	83 f8 10             	cmp    $0x10,%eax
f0100c65:	75 13                	jne    f0100c7a <kbd_proc_data+0x20b>
f0100c67:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c6b:	7e 0d                	jle    f0100c7a <kbd_proc_data+0x20b>
f0100c6d:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c71:	7f 07                	jg     f0100c7a <kbd_proc_data+0x20b>
		return 0;
f0100c73:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c78:	eb 4c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	if (c == 255)
f0100c7a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100c81:	75 07                	jne    f0100c8a <kbd_proc_data+0x21b>
		return 0;
f0100c83:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c88:	eb 3c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100c8a:	a1 a8 03 5a f0       	mov    0xf05a03a8,%eax
f0100c8f:	f7 d0                	not    %eax
f0100c91:	83 e0 06             	and    $0x6,%eax
f0100c94:	85 c0                	test   %eax,%eax
f0100c96:	75 2b                	jne    f0100cc3 <kbd_proc_data+0x254>
f0100c98:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100c9f:	75 22                	jne    f0100cc3 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100ca1:	83 ec 0c             	sub    $0xc,%esp
f0100ca4:	68 5b 44 12 f0       	push   $0xf012445b
f0100ca9:	e8 be 02 00 00       	call   f0100f6c <cprintf>
f0100cae:	83 c4 10             	add    $0x10,%esp
f0100cb1:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cb8:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cbc:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cbf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100cc2:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100cc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100cc6:	c9                   	leave  
f0100cc7:	c3                   	ret    

f0100cc8 <kbd_intr>:

void
kbd_intr(void)
{
f0100cc8:	55                   	push   %ebp
f0100cc9:	89 e5                	mov    %esp,%ebp
f0100ccb:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100cce:	83 ec 0c             	sub    $0xc,%esp
f0100cd1:	68 6f 0a 10 f0       	push   $0xf0100a6f
f0100cd6:	e8 21 00 00 00       	call   f0100cfc <cons_intr>
f0100cdb:	83 c4 10             	add    $0x10,%esp
}
f0100cde:	90                   	nop
f0100cdf:	c9                   	leave  
f0100ce0:	c3                   	ret    

f0100ce1 <kbd_init>:

void
kbd_init(void)
{
f0100ce1:	55                   	push   %ebp
f0100ce2:	89 e5                	mov    %esp,%ebp
f0100ce4:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100ce7:	83 ec 08             	sub    $0x8,%esp
f0100cea:	68 83 0e 10 f0       	push   $0xf0100e83
f0100cef:	6a 01                	push   $0x1
f0100cf1:	e8 a2 c6 00 00       	call   f010d398 <irq_install_handler>
f0100cf6:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100cf9:	90                   	nop
f0100cfa:	c9                   	leave  
f0100cfb:	c3                   	ret    

f0100cfc <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100cfc:	55                   	push   %ebp
f0100cfd:	89 e5                	mov    %esp,%ebp
f0100cff:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d02:	eb 35                	jmp    f0100d39 <cons_intr+0x3d>
		if (c == 0)
f0100d04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d08:	75 02                	jne    f0100d0c <cons_intr+0x10>
			continue;
f0100d0a:	eb 2d                	jmp    f0100d39 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d0c:	a1 a4 03 5a f0       	mov    0xf05a03a4,%eax
f0100d11:	8d 50 01             	lea    0x1(%eax),%edx
f0100d14:	89 15 a4 03 5a f0    	mov    %edx,0xf05a03a4
f0100d1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d1d:	88 90 a0 01 5a f0    	mov    %dl,-0xfa5fe60(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d23:	a1 a4 03 5a f0       	mov    0xf05a03a4,%eax
f0100d28:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d2d:	75 0a                	jne    f0100d39 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d2f:	c7 05 a4 03 5a f0 00 	movl   $0x0,0xf05a03a4
f0100d36:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d3c:	ff d0                	call   *%eax
f0100d3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d41:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d45:	75 bd                	jne    f0100d04 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d47:	90                   	nop
f0100d48:	c9                   	leave  
f0100d49:	c3                   	ret    

f0100d4a <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d4a:	55                   	push   %ebp
f0100d4b:	89 e5                	mov    %esp,%ebp
f0100d4d:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d50:	e8 ee f7 ff ff       	call   f0100543 <serial_intr>
	kbd_intr();
f0100d55:	e8 6e ff ff ff       	call   f0100cc8 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d5a:	8b 15 a0 03 5a f0    	mov    0xf05a03a0,%edx
f0100d60:	a1 a4 03 5a f0       	mov    0xf05a03a4,%eax
f0100d65:	39 c2                	cmp    %eax,%edx
f0100d67:	74 35                	je     f0100d9e <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d69:	a1 a0 03 5a f0       	mov    0xf05a03a0,%eax
f0100d6e:	8d 50 01             	lea    0x1(%eax),%edx
f0100d71:	89 15 a0 03 5a f0    	mov    %edx,0xf05a03a0
f0100d77:	8a 80 a0 01 5a f0    	mov    -0xfa5fe60(%eax),%al
f0100d7d:	0f b6 c0             	movzbl %al,%eax
f0100d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100d83:	a1 a0 03 5a f0       	mov    0xf05a03a0,%eax
f0100d88:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d8d:	75 0a                	jne    f0100d99 <cons_getc+0x4f>
			cons.rpos = 0;
f0100d8f:	c7 05 a0 03 5a f0 00 	movl   $0x0,0xf05a03a0
f0100d96:	00 00 00 
		return c;
f0100d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100d9c:	eb 05                	jmp    f0100da3 <cons_getc+0x59>
	}
	return 0;
f0100d9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100da3:	c9                   	leave  
f0100da4:	c3                   	ret    

f0100da5 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100da5:	55                   	push   %ebp
f0100da6:	89 e5                	mov    %esp,%ebp
f0100da8:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dab:	8b 15 a0 03 5a f0    	mov    0xf05a03a0,%edx
f0100db1:	a1 a4 03 5a f0       	mov    0xf05a03a4,%eax
f0100db6:	39 c2                	cmp    %eax,%edx
f0100db8:	74 35                	je     f0100def <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dba:	a1 a0 03 5a f0       	mov    0xf05a03a0,%eax
f0100dbf:	8d 50 01             	lea    0x1(%eax),%edx
f0100dc2:	89 15 a0 03 5a f0    	mov    %edx,0xf05a03a0
f0100dc8:	8a 80 a0 01 5a f0    	mov    -0xfa5fe60(%eax),%al
f0100dce:	0f b6 c0             	movzbl %al,%eax
f0100dd1:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100dd4:	a1 a0 03 5a f0       	mov    0xf05a03a0,%eax
f0100dd9:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dde:	75 0a                	jne    f0100dea <cons_getc2+0x45>
			cons.rpos = 0;
f0100de0:	c7 05 a0 03 5a f0 00 	movl   $0x0,0xf05a03a0
f0100de7:	00 00 00 
		return c;
f0100dea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100ded:	eb 05                	jmp    f0100df4 <cons_getc2+0x4f>
	}
	return 0;
f0100def:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100df4:	c9                   	leave  
f0100df5:	c3                   	ret    

f0100df6 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100df6:	55                   	push   %ebp
f0100df7:	89 e5                	mov    %esp,%ebp
f0100df9:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100dfc:	ff 75 08             	pushl  0x8(%ebp)
f0100dff:	e8 a1 f8 ff ff       	call   f01006a5 <lpt_putc>
f0100e04:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e07:	83 ec 0c             	sub    $0xc,%esp
f0100e0a:	ff 75 08             	pushl  0x8(%ebp)
f0100e0d:	e8 cd f9 ff ff       	call   f01007df <cga_putc>
f0100e12:	83 c4 10             	add    $0x10,%esp
}
f0100e15:	90                   	nop
f0100e16:	c9                   	leave  
f0100e17:	c3                   	ret    

f0100e18 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e18:	55                   	push   %ebp
f0100e19:	89 e5                	mov    %esp,%ebp
f0100e1b:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e1e:	e8 f7 f8 ff ff       	call   f010071a <cga_init>
	kbd_init();
f0100e23:	e8 b9 fe ff ff       	call   f0100ce1 <kbd_init>
	serial_init();
f0100e28:	e8 56 f7 ff ff       	call   f0100583 <serial_init>

	if (!serial_exists)
f0100e2d:	a1 84 01 5a f0       	mov    0xf05a0184,%eax
f0100e32:	85 c0                	test   %eax,%eax
f0100e34:	75 10                	jne    f0100e46 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e36:	83 ec 0c             	sub    $0xc,%esp
f0100e39:	68 67 44 12 f0       	push   $0xf0124467
f0100e3e:	e8 29 01 00 00       	call   f0100f6c <cprintf>
f0100e43:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e46:	90                   	nop
f0100e47:	c9                   	leave  
f0100e48:	c3                   	ret    

f0100e49 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e49:	55                   	push   %ebp
f0100e4a:	89 e5                	mov    %esp,%ebp
f0100e4c:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e4f:	83 ec 0c             	sub    $0xc,%esp
f0100e52:	ff 75 08             	pushl  0x8(%ebp)
f0100e55:	e8 9c ff ff ff       	call   f0100df6 <cons_putc>
f0100e5a:	83 c4 10             	add    $0x10,%esp
}
f0100e5d:	90                   	nop
f0100e5e:	c9                   	leave  
f0100e5f:	c3                   	ret    

f0100e60 <getchar>:

int
getchar(void)
{
f0100e60:	55                   	push   %ebp
f0100e61:	89 e5                	mov    %esp,%ebp
f0100e63:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e66:	e8 df fe ff ff       	call   f0100d4a <cons_getc>
f0100e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e72:	74 f2                	je     f0100e66 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e77:	c9                   	leave  
f0100e78:	c3                   	ret    

f0100e79 <iscons>:

int
iscons(int fdnum)
{
f0100e79:	55                   	push   %ebp
f0100e7a:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e7c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100e81:	5d                   	pop    %ebp
f0100e82:	c3                   	ret    

f0100e83 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100e83:	55                   	push   %ebp
f0100e84:	89 e5                	mov    %esp,%ebp
f0100e86:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100e89:	e8 3a fe ff ff       	call   f0100cc8 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100e8e:	90                   	nop
f0100e8f:	c9                   	leave  
f0100e90:	c3                   	ret    

f0100e91 <cons_lock>:

void cons_lock(void)
{
f0100e91:	55                   	push   %ebp
f0100e92:	89 e5                	mov    %esp,%ebp
f0100e94:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100e97:	e8 ec 3d 00 00       	call   f0104c88 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100e9c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100e9d:	e8 ce 98 00 00       	call   f010a770 <get_cpu_proc>
f0100ea2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ea5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ea9:	75 17                	jne    f0100ec2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eab:	83 ec 04             	sub    $0x4,%esp
f0100eae:	68 84 44 12 f0       	push   $0xf0124484
f0100eb3:	68 2d 02 00 00       	push   $0x22d
f0100eb8:	68 ab 44 12 f0       	push   $0xf01244ab
f0100ebd:	e8 58 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ec5:	8b 00                	mov    (%eax),%eax
f0100ec7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100eca:	8b 12                	mov    (%edx),%edx
f0100ecc:	8b 52 38             	mov    0x38(%edx),%edx
f0100ecf:	80 e6 fd             	and    $0xfd,%dh
f0100ed2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ed5:	90                   	nop
f0100ed6:	c9                   	leave  
f0100ed7:	c3                   	ret    

f0100ed8 <cons_unlock>:

void cons_unlock(void)
{
f0100ed8:	55                   	push   %ebp
f0100ed9:	89 e5                	mov    %esp,%ebp
f0100edb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100ede:	e8 a5 3d 00 00       	call   f0104c88 <kclock_stop>
f0100ee3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ee4:	e8 87 98 00 00       	call   f010a770 <get_cpu_proc>
f0100ee9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100eec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ef0:	75 17                	jne    f0100f09 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100ef2:	83 ec 04             	sub    $0x4,%esp
f0100ef5:	68 c0 44 12 f0       	push   $0xf01244c0
f0100efa:	68 46 02 00 00       	push   $0x246
f0100eff:	68 ab 44 12 f0       	push   $0xf01244ab
f0100f04:	e8 11 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0c:	8b 00                	mov    (%eax),%eax
f0100f0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f11:	8b 12                	mov    (%edx),%edx
f0100f13:	8b 52 38             	mov    0x38(%edx),%edx
f0100f16:	80 ce 02             	or     $0x2,%dh
f0100f19:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f1c:	90                   	nop
f0100f1d:	c9                   	leave  
f0100f1e:	c3                   	ret    

f0100f1f <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f1f:	55                   	push   %ebp
f0100f20:	89 e5                	mov    %esp,%ebp
f0100f22:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f25:	83 ec 0c             	sub    $0xc,%esp
f0100f28:	ff 75 08             	pushl  0x8(%ebp)
f0100f2b:	e8 19 ff ff ff       	call   f0100e49 <cputchar>
f0100f30:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f36:	8b 00                	mov    (%eax),%eax
f0100f38:	8d 50 01             	lea    0x1(%eax),%edx
f0100f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f3e:	89 10                	mov    %edx,(%eax)
}
f0100f40:	90                   	nop
f0100f41:	c9                   	leave  
f0100f42:	c3                   	ret    

f0100f43 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f43:	55                   	push   %ebp
f0100f44:	89 e5                	mov    %esp,%ebp
f0100f46:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f50:	ff 75 0c             	pushl  0xc(%ebp)
f0100f53:	ff 75 08             	pushl  0x8(%ebp)
f0100f56:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f59:	50                   	push   %eax
f0100f5a:	68 1f 0f 10 f0       	push   $0xf0100f1f
f0100f5f:	e8 af 0f 02 00       	call   f0121f13 <vprintfmt>
f0100f64:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f6a:	c9                   	leave  
f0100f6b:	c3                   	ret    

f0100f6c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f6c:	55                   	push   %ebp
f0100f6d:	89 e5                	mov    %esp,%ebp
f0100f6f:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f72:	e8 49 62 00 00       	call   f01071c0 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f77:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f80:	83 ec 08             	sub    $0x8,%esp
f0100f83:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f86:	50                   	push   %eax
f0100f87:	e8 b7 ff ff ff       	call   f0100f43 <vcprintf>
f0100f8c:	83 c4 10             	add    $0x10,%esp
f0100f8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100f92:	e8 7b 62 00 00       	call   f0107212 <popcli>

	return cnt;
f0100f97:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100f9a:	c9                   	leave  
f0100f9b:	c3                   	ret    

f0100f9c <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100f9c:	55                   	push   %ebp
f0100f9d:	89 e5                	mov    %esp,%ebp
f0100f9f:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fa9:	eb 10                	jmp    f0100fbb <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fab:	83 ec 0c             	sub    $0xc,%esp
f0100fae:	6a 08                	push   $0x8
f0100fb0:	e8 94 fe ff ff       	call   f0100e49 <cputchar>
f0100fb5:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fb8:	ff 45 f4             	incl   -0xc(%ebp)
f0100fbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fbe:	8b 00                	mov    (%eax),%eax
f0100fc0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fc3:	7f e6                	jg     f0100fab <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fc8:	c1 e0 0a             	shl    $0xa,%eax
f0100fcb:	05 40 cc 5b f0       	add    $0xf05bcc40,%eax
f0100fd0:	83 ec 0c             	sub    $0xc,%esp
f0100fd3:	50                   	push   %eax
f0100fd4:	e8 fc 15 02 00       	call   f01225d5 <strlen>
f0100fd9:	83 c4 10             	add    $0x10,%esp
f0100fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100fdf:	83 ec 04             	sub    $0x4,%esp
f0100fe2:	68 00 04 00 00       	push   $0x400
f0100fe7:	68 60 1c 5c f0       	push   $0xf05c1c60
f0100fec:	ff 75 10             	pushl  0x10(%ebp)
f0100fef:	e8 ff 17 02 00       	call   f01227f3 <memcpy>
f0100ff4:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0100ff7:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ffa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0101000:	eb 52                	jmp    f0101054 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101002:	8b 45 08             	mov    0x8(%ebp),%eax
f0101005:	8b 00                	mov    (%eax),%eax
f0101007:	8b 55 0c             	mov    0xc(%ebp),%edx
f010100a:	c1 e2 0a             	shl    $0xa,%edx
f010100d:	01 d0                	add    %edx,%eax
f010100f:	05 40 cc 5b f0       	add    $0xf05bcc40,%eax
f0101014:	8a 00                	mov    (%eax),%al
f0101016:	0f be c0             	movsbl %al,%eax
f0101019:	83 ec 0c             	sub    $0xc,%esp
f010101c:	50                   	push   %eax
f010101d:	e8 27 fe ff ff       	call   f0100e49 <cputchar>
f0101022:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101025:	8b 45 08             	mov    0x8(%ebp),%eax
f0101028:	8b 00                	mov    (%eax),%eax
f010102a:	89 c2                	mov    %eax,%edx
f010102c:	8b 45 10             	mov    0x10(%ebp),%eax
f010102f:	01 c2                	add    %eax,%edx
f0101031:	8b 45 08             	mov    0x8(%ebp),%eax
f0101034:	8b 00                	mov    (%eax),%eax
f0101036:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101039:	c1 e1 0a             	shl    $0xa,%ecx
f010103c:	01 c8                	add    %ecx,%eax
f010103e:	05 40 cc 5b f0       	add    $0xf05bcc40,%eax
f0101043:	8a 00                	mov    (%eax),%al
f0101045:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101047:	8b 45 08             	mov    0x8(%ebp),%eax
f010104a:	8b 00                	mov    (%eax),%eax
f010104c:	8d 50 01             	lea    0x1(%eax),%edx
f010104f:	8b 45 08             	mov    0x8(%ebp),%eax
f0101052:	89 10                	mov    %edx,(%eax)
f0101054:	8b 45 08             	mov    0x8(%ebp),%eax
f0101057:	8b 00                	mov    (%eax),%eax
f0101059:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010105c:	7c a4                	jl     f0101002 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010105e:	8b 45 14             	mov    0x14(%ebp),%eax
f0101061:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101064:	89 10                	mov    %edx,(%eax)
}
f0101066:	90                   	nop
f0101067:	c9                   	leave  
f0101068:	c3                   	ret    

f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101069:	55                   	push   %ebp
f010106a:	89 e5                	mov    %esp,%ebp
f010106c:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010106f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101076:	eb 10                	jmp    f0101088 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101078:	83 ec 0c             	sub    $0xc,%esp
f010107b:	6a 08                	push   $0x8
f010107d:	e8 c7 fd ff ff       	call   f0100e49 <cputchar>
f0101082:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f0101085:	ff 45 f4             	incl   -0xc(%ebp)
f0101088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010108b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010108e:	7c e8                	jl     f0101078 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0101090:	83 ec 0c             	sub    $0xc,%esp
f0101093:	ff 75 0c             	pushl  0xc(%ebp)
f0101096:	e8 3a 15 02 00       	call   f01225d5 <strlen>
f010109b:	83 c4 10             	add    $0x10,%esp
f010109e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010a1:	83 ec 04             	sub    $0x4,%esp
f01010a4:	68 00 04 00 00       	push   $0x400
f01010a9:	68 60 1c 5c f0       	push   $0xf05c1c60
f01010ae:	ff 75 10             	pushl  0x10(%ebp)
f01010b1:	e8 3d 17 02 00       	call   f01227f3 <memcpy>
f01010b6:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010b9:	8b 45 14             	mov    0x14(%ebp),%eax
f01010bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010c2:	eb 46                	jmp    f010110a <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010c4:	8b 45 14             	mov    0x14(%ebp),%eax
f01010c7:	8b 00                	mov    (%eax),%eax
f01010c9:	89 c2                	mov    %eax,%edx
f01010cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ce:	01 d0                	add    %edx,%eax
f01010d0:	8a 00                	mov    (%eax),%al
f01010d2:	0f be c0             	movsbl %al,%eax
f01010d5:	83 ec 0c             	sub    $0xc,%esp
f01010d8:	50                   	push   %eax
f01010d9:	e8 6b fd ff ff       	call   f0100e49 <cputchar>
f01010de:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f01010e1:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e4:	8b 00                	mov    (%eax),%eax
f01010e6:	89 c2                	mov    %eax,%edx
f01010e8:	8b 45 10             	mov    0x10(%ebp),%eax
f01010eb:	01 c2                	add    %eax,%edx
f01010ed:	8b 45 14             	mov    0x14(%ebp),%eax
f01010f0:	8b 00                	mov    (%eax),%eax
f01010f2:	89 c1                	mov    %eax,%ecx
f01010f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010f7:	01 c8                	add    %ecx,%eax
f01010f9:	8a 00                	mov    (%eax),%al
f01010fb:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01010fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0101100:	8b 00                	mov    (%eax),%eax
f0101102:	8d 50 01             	lea    0x1(%eax),%edx
f0101105:	8b 45 14             	mov    0x14(%ebp),%eax
f0101108:	89 10                	mov    %edx,(%eax)
f010110a:	8b 45 14             	mov    0x14(%ebp),%eax
f010110d:	8b 00                	mov    (%eax),%eax
f010110f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101112:	7c b0                	jl     f01010c4 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101114:	8b 45 18             	mov    0x18(%ebp),%eax
f0101117:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010111a:	89 10                	mov    %edx,(%eax)
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010112c:	eb 21                	jmp    f010114f <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010112e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101131:	c1 e0 0a             	shl    $0xa,%eax
f0101134:	05 40 3c 5a f0       	add    $0xf05a3c40,%eax
f0101139:	83 ec 04             	sub    $0x4,%esp
f010113c:	68 00 04 00 00       	push   $0x400
f0101141:	6a 00                	push   $0x0
f0101143:	50                   	push   %eax
f0101144:	e8 7a 16 02 00       	call   f01227c3 <memset>
f0101149:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010114c:	ff 45 f4             	incl   -0xc(%ebp)
f010114f:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101153:	7e d9                	jle    f010112e <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101155:	90                   	nop
f0101156:	c9                   	leave  
f0101157:	c3                   	ret    

f0101158 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101158:	55                   	push   %ebp
f0101159:	89 e5                	mov    %esp,%ebp
f010115b:	57                   	push   %edi
f010115c:	53                   	push   %ebx
f010115d:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101163:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101167:	74 13                	je     f010117c <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101169:	83 ec 08             	sub    $0x8,%esp
f010116c:	ff 75 08             	pushl  0x8(%ebp)
f010116f:	68 ec 44 12 f0       	push   $0xf01244ec
f0101174:	e8 f3 fd ff ff       	call   f0100f6c <cprintf>
f0101179:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010117c:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101181:	40                   	inc    %eax
f0101182:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f0101185:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010118c:	00 00 00 
f010118f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101195:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010119b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011a4:	83 ec 0c             	sub    $0xc,%esp
f01011a7:	6a 00                	push   $0x0
f01011a9:	e8 cb fc ff ff       	call   f0100e79 <iscons>
f01011ae:	83 c4 10             	add    $0x10,%esp
f01011b1:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011c2:	e8 99 fc ff ff       	call   f0100e60 <getchar>
f01011c7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011ca:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011d0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011d6:	39 c2                	cmp    %eax,%edx
f01011d8:	7e 0c                	jle    f01011e6 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011da:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011e0:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f01011e6:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f01011ea:	79 22                	jns    f010120e <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f01011ec:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f01011f0:	0f 84 94 0a 00 00    	je     f0101c8a <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f01011f6:	83 ec 08             	sub    $0x8,%esp
f01011f9:	ff 75 94             	pushl  -0x6c(%ebp)
f01011fc:	68 ef 44 12 f0       	push   $0xf01244ef
f0101201:	e8 66 fd ff ff       	call   f0100f6c <cprintf>
f0101206:	83 c4 10             	add    $0x10,%esp
			return;
f0101209:	e9 7c 0a 00 00       	jmp    f0101c8a <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010120e:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101215:	75 2a                	jne    f0101241 <command_prompt_readline+0xe9>
			if (commandidx)
f0101217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010121b:	74 03                	je     f0101220 <command_prompt_readline+0xc8>
				commandidx--;
f010121d:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101220:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101226:	50                   	push   %eax
f0101227:	ff 75 0c             	pushl  0xc(%ebp)
f010122a:	ff 75 f4             	pushl  -0xc(%ebp)
f010122d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101233:	50                   	push   %eax
f0101234:	e8 63 fd ff ff       	call   f0100f9c <clearandwritecommand>
f0101239:	83 c4 10             	add    $0x10,%esp
f010123c:	e9 32 0a 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101241:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101248:	75 3b                	jne    f0101285 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f010124a:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010124f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101252:	7d 03                	jge    f0101257 <command_prompt_readline+0xff>
				commandidx++;
f0101254:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101257:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010125c:	85 c0                	test   %eax,%eax
f010125e:	0f 88 0f 0a 00 00    	js     f0101c73 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101264:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f010126a:	50                   	push   %eax
f010126b:	ff 75 0c             	pushl  0xc(%ebp)
f010126e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101271:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101277:	50                   	push   %eax
f0101278:	e8 1f fd ff ff       	call   f0100f9c <clearandwritecommand>
f010127d:	83 c4 10             	add    $0x10,%esp
f0101280:	e9 ee 09 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f0101285:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0101289:	0f 85 6d 07 00 00    	jne    f01019fc <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f010128f:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f0101293:	0f 84 fc 06 00 00    	je     f0101995 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0101299:	83 ec 08             	sub    $0x8,%esp
f010129c:	6a 64                	push   $0x64
f010129e:	68 40 3c 5a f0       	push   $0xf05a3c40
f01012a3:	e8 77 fe ff ff       	call   f010111f <clear_prefix_list>
f01012a8:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ab:	83 ec 0c             	sub    $0xc,%esp
f01012ae:	ff 75 0c             	pushl  0xc(%ebp)
f01012b1:	e8 1f 13 02 00       	call   f01225d5 <strlen>
f01012b6:	83 c4 10             	add    $0x10,%esp
f01012b9:	85 c0                	test   %eax,%eax
f01012bb:	0f 84 bd 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
f01012c1:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012c8:	0f 84 b0 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012d8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012de:	83 ec 08             	sub    $0x8,%esp
f01012e1:	ff 75 0c             	pushl  0xc(%ebp)
f01012e4:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01012ea:	50                   	push   %eax
f01012eb:	e8 34 13 02 00       	call   f0122624 <strcpy>
f01012f0:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f01012f3:	83 ec 0c             	sub    $0xc,%esp
f01012f6:	ff 75 0c             	pushl  0xc(%ebp)
f01012f9:	e8 d7 12 02 00       	call   f01225d5 <strlen>
f01012fe:	83 c4 10             	add    $0x10,%esp
f0101301:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101304:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101307:	8d 50 ff             	lea    -0x1(%eax),%edx
f010130a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010130d:	01 d0                	add    %edx,%eax
f010130f:	8a 00                	mov    (%eax),%al
f0101311:	3c 20                	cmp    $0x20,%al
f0101313:	0f 84 6b 09 00 00    	je     f0101c84 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101319:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010131f:	50                   	push   %eax
f0101320:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101326:	50                   	push   %eax
f0101327:	68 ff 44 12 f0       	push   $0xf01244ff
f010132c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101332:	50                   	push   %eax
f0101333:	e8 b2 18 02 00       	call   f0122bea <strsplit>
f0101338:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010133b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101342:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101348:	83 f8 01             	cmp    $0x1,%eax
f010134b:	0f 8e 28 01 00 00    	jle    f0101479 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101351:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101357:	83 ec 08             	sub    $0x8,%esp
f010135a:	68 04 45 12 f0       	push   $0xf0124504
f010135f:	50                   	push   %eax
f0101360:	e8 7c 13 02 00       	call   f01226e1 <strcmp>
f0101365:	83 c4 10             	add    $0x10,%esp
f0101368:	85 c0                	test   %eax,%eax
f010136a:	74 3c                	je     f01013a8 <command_prompt_readline+0x250>
f010136c:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101372:	83 ec 08             	sub    $0x8,%esp
f0101375:	68 08 45 12 f0       	push   $0xf0124508
f010137a:	50                   	push   %eax
f010137b:	e8 61 13 02 00       	call   f01226e1 <strcmp>
f0101380:	83 c4 10             	add    $0x10,%esp
f0101383:	85 c0                	test   %eax,%eax
f0101385:	74 21                	je     f01013a8 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f0101387:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f010138d:	83 ec 08             	sub    $0x8,%esp
f0101390:	68 0d 45 12 f0       	push   $0xf012450d
f0101395:	50                   	push   %eax
f0101396:	e8 46 13 02 00       	call   f01226e1 <strcmp>
f010139b:	83 c4 10             	add    $0x10,%esp
f010139e:	85 c0                	test   %eax,%eax
f01013a0:	74 06                	je     f01013a8 <command_prompt_readline+0x250>
						continue;
f01013a2:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013a3:	e9 d6 08 00 00       	jmp    f0101c7e <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013a8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ae:	83 ec 08             	sub    $0x8,%esp
f01013b1:	68 0d 45 12 f0       	push   $0xf012450d
f01013b6:	50                   	push   %eax
f01013b7:	e8 25 13 02 00       	call   f01226e1 <strcmp>
f01013bc:	83 c4 10             	add    $0x10,%esp
f01013bf:	85 c0                	test   %eax,%eax
f01013c1:	75 09                	jne    f01013cc <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013ca:	eb 07                	jmp    f01013d3 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013cc:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013d3:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013da:	00 00 00 
f01013dd:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01013e3:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01013e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01013ed:	89 d7                	mov    %edx,%edi
f01013ef:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f01013f1:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01013f7:	48                   	dec    %eax
f01013f8:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01013ff:	83 ec 0c             	sub    $0xc,%esp
f0101402:	50                   	push   %eax
f0101403:	e8 cd 11 02 00       	call   f01225d5 <strlen>
f0101408:	83 c4 10             	add    $0x10,%esp
f010140b:	8b 55 90             	mov    -0x70(%ebp),%edx
f010140e:	29 c2                	sub    %eax,%edx
f0101410:	89 d0                	mov    %edx,%eax
f0101412:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101415:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010141c:	eb 1d                	jmp    f010143b <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010141e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101421:	8d 50 01             	lea    0x1(%eax),%edx
f0101424:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101427:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f010142a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010142d:	01 ca                	add    %ecx,%edx
f010142f:	8a 12                	mov    (%edx),%dl
f0101431:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101438:	ff 45 d8             	incl   -0x28(%ebp)
f010143b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010143e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101441:	7c db                	jl     f010141e <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101443:	83 ec 08             	sub    $0x8,%esp
f0101446:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010144c:	50                   	push   %eax
f010144d:	ff 75 0c             	pushl  0xc(%ebp)
f0101450:	e8 cf 11 02 00       	call   f0122624 <strcpy>
f0101455:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101458:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010145e:	48                   	dec    %eax
f010145f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101466:	83 ec 08             	sub    $0x8,%esp
f0101469:	50                   	push   %eax
f010146a:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101470:	50                   	push   %eax
f0101471:	e8 ae 11 02 00       	call   f0122624 <strcpy>
f0101476:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101479:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0101480:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101486:	83 f8 01             	cmp    $0x1,%eax
f0101489:	0f 85 30 01 00 00    	jne    f01015bf <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010148f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0101496:	e9 0f 01 00 00       	jmp    f01015aa <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f010149b:	83 ec 0c             	sub    $0xc,%esp
f010149e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014a4:	50                   	push   %eax
f01014a5:	e8 2b 11 02 00       	call   f01225d5 <strlen>
f01014aa:	83 c4 10             	add    $0x10,%esp
f01014ad:	89 c1                	mov    %eax,%ecx
f01014af:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014b2:	89 d0                	mov    %edx,%eax
f01014b4:	01 c0                	add    %eax,%eax
f01014b6:	01 d0                	add    %edx,%eax
f01014b8:	c1 e0 03             	shl    $0x3,%eax
f01014bb:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01014c0:	8b 00                	mov    (%eax),%eax
f01014c2:	83 ec 04             	sub    $0x4,%esp
f01014c5:	51                   	push   %ecx
f01014c6:	50                   	push   %eax
f01014c7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014cd:	50                   	push   %eax
f01014ce:	e8 46 12 02 00       	call   f0122719 <strncmp>
f01014d3:	83 c4 10             	add    $0x10,%esp
f01014d6:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014d9:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014dd:	0f 85 c4 00 00 00    	jne    f01015a7 <command_prompt_readline+0x44f>
							it_str = -1;
f01014e3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f01014ea:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01014f1:	00 00 00 
f01014f4:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01014fa:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01014ff:	b8 00 00 00 00       	mov    $0x0,%eax
f0101504:	89 d7                	mov    %edx,%edi
f0101506:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101508:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010150f:	eb 2d                	jmp    f010153e <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101511:	ff 45 dc             	incl   -0x24(%ebp)
f0101514:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101517:	89 d0                	mov    %edx,%eax
f0101519:	01 c0                	add    %eax,%eax
f010151b:	01 d0                	add    %edx,%eax
f010151d:	c1 e0 03             	shl    $0x3,%eax
f0101520:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0101525:	8b 10                	mov    (%eax),%edx
f0101527:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010152a:	01 d0                	add    %edx,%eax
f010152c:	8a 00                	mov    (%eax),%al
f010152e:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101534:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101537:	01 ca                	add    %ecx,%edx
f0101539:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010153b:	ff 45 cc             	incl   -0x34(%ebp)
f010153e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101541:	89 d0                	mov    %edx,%eax
f0101543:	01 c0                	add    %eax,%eax
f0101545:	01 d0                	add    %edx,%eax
f0101547:	c1 e0 03             	shl    $0x3,%eax
f010154a:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010154f:	8b 00                	mov    (%eax),%eax
f0101551:	83 ec 0c             	sub    $0xc,%esp
f0101554:	50                   	push   %eax
f0101555:	e8 7b 10 02 00       	call   f01225d5 <strlen>
f010155a:	83 c4 10             	add    $0x10,%esp
f010155d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0101560:	7f af                	jg     f0101511 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101562:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101565:	c1 e0 0a             	shl    $0xa,%eax
f0101568:	05 40 3c 5a f0       	add    $0xf05a3c40,%eax
f010156d:	83 ec 04             	sub    $0x4,%esp
f0101570:	68 00 04 00 00       	push   $0x400
f0101575:	6a 00                	push   $0x0
f0101577:	50                   	push   %eax
f0101578:	e8 46 12 02 00       	call   f01227c3 <memset>
f010157d:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101580:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101583:	40                   	inc    %eax
f0101584:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0101587:	c1 e2 0a             	shl    $0xa,%edx
f010158a:	81 c2 40 3c 5a f0    	add    $0xf05a3c40,%edx
f0101590:	83 ec 04             	sub    $0x4,%esp
f0101593:	50                   	push   %eax
f0101594:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010159a:	50                   	push   %eax
f010159b:	52                   	push   %edx
f010159c:	e8 b1 10 02 00       	call   f0122652 <strncpy>
f01015a1:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015a4:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015a7:	ff 45 d0             	incl   -0x30(%ebp)
f01015aa:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015ad:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01015b2:	39 c2                	cmp    %eax,%edx
f01015b4:	0f 82 e1 fe ff ff    	jb     f010149b <command_prompt_readline+0x343>
f01015ba:	e9 fe 02 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015bf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015c3:	0f 84 7b 01 00 00    	je     f0101744 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015c9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015d0:	e9 5c 01 00 00       	jmp    f0101731 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015d5:	83 ec 0c             	sub    $0xc,%esp
f01015d8:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015de:	50                   	push   %eax
f01015df:	e8 f1 0f 02 00       	call   f01225d5 <strlen>
f01015e4:	83 c4 10             	add    $0x10,%esp
f01015e7:	89 c1                	mov    %eax,%ecx
f01015e9:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f01015ef:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01015f2:	89 d0                	mov    %edx,%eax
f01015f4:	01 c0                	add    %eax,%eax
f01015f6:	01 d0                	add    %edx,%eax
f01015f8:	c1 e0 02             	shl    $0x2,%eax
f01015fb:	01 d8                	add    %ebx,%eax
f01015fd:	8b 00                	mov    (%eax),%eax
f01015ff:	83 ec 04             	sub    $0x4,%esp
f0101602:	51                   	push   %ecx
f0101603:	50                   	push   %eax
f0101604:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010160a:	50                   	push   %eax
f010160b:	e8 09 11 02 00       	call   f0122719 <strncmp>
f0101610:	83 c4 10             	add    $0x10,%esp
f0101613:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101616:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f010161a:	0f 85 0e 01 00 00    	jne    f010172e <command_prompt_readline+0x5d6>
								it_str = -1;
f0101620:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101627:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010162e:	00 00 00 
f0101631:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101637:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010163c:	b8 00 00 00 00       	mov    $0x0,%eax
f0101641:	89 d7                	mov    %edx,%edi
f0101643:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101645:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010164b:	83 f8 01             	cmp    $0x1,%eax
f010164e:	7e 39                	jle    f0101689 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101650:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101657:	eb 1d                	jmp    f0101676 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101659:	ff 45 dc             	incl   -0x24(%ebp)
f010165c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010165f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101662:	01 d0                	add    %edx,%eax
f0101664:	8a 00                	mov    (%eax),%al
f0101666:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010166c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010166f:	01 ca                	add    %ecx,%edx
f0101671:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101673:	ff 45 c4             	incl   -0x3c(%ebp)
f0101676:	83 ec 0c             	sub    $0xc,%esp
f0101679:	ff 75 0c             	pushl  0xc(%ebp)
f010167c:	e8 54 0f 02 00       	call   f01225d5 <strlen>
f0101681:	83 c4 10             	add    $0x10,%esp
f0101684:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0101687:	7f d0                	jg     f0101659 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0101689:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0101690:	eb 30                	jmp    f01016c2 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0101692:	ff 45 dc             	incl   -0x24(%ebp)
f0101695:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f010169b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f010169e:	89 d0                	mov    %edx,%eax
f01016a0:	01 c0                	add    %eax,%eax
f01016a2:	01 d0                	add    %edx,%eax
f01016a4:	c1 e0 02             	shl    $0x2,%eax
f01016a7:	01 c8                	add    %ecx,%eax
f01016a9:	8b 10                	mov    (%eax),%edx
f01016ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016ae:	01 d0                	add    %edx,%eax
f01016b0:	8a 00                	mov    (%eax),%al
f01016b2:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016bb:	01 ca                	add    %ecx,%edx
f01016bd:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016bf:	ff 45 c0             	incl   -0x40(%ebp)
f01016c2:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016c8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016cb:	89 d0                	mov    %edx,%eax
f01016cd:	01 c0                	add    %eax,%eax
f01016cf:	01 d0                	add    %edx,%eax
f01016d1:	c1 e0 02             	shl    $0x2,%eax
f01016d4:	01 c8                	add    %ecx,%eax
f01016d6:	8b 00                	mov    (%eax),%eax
f01016d8:	83 ec 0c             	sub    $0xc,%esp
f01016db:	50                   	push   %eax
f01016dc:	e8 f4 0e 02 00       	call   f01225d5 <strlen>
f01016e1:	83 c4 10             	add    $0x10,%esp
f01016e4:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f01016e7:	7f a9                	jg     f0101692 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f01016e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01016ec:	c1 e0 0a             	shl    $0xa,%eax
f01016ef:	05 40 3c 5a f0       	add    $0xf05a3c40,%eax
f01016f4:	83 ec 04             	sub    $0x4,%esp
f01016f7:	68 00 04 00 00       	push   $0x400
f01016fc:	6a 00                	push   $0x0
f01016fe:	50                   	push   %eax
f01016ff:	e8 bf 10 02 00       	call   f01227c3 <memset>
f0101704:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101707:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010170a:	40                   	inc    %eax
f010170b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010170e:	c1 e2 0a             	shl    $0xa,%edx
f0101711:	81 c2 40 3c 5a f0    	add    $0xf05a3c40,%edx
f0101717:	83 ec 04             	sub    $0x4,%esp
f010171a:	50                   	push   %eax
f010171b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101721:	50                   	push   %eax
f0101722:	52                   	push   %edx
f0101723:	e8 2a 0f 02 00       	call   f0122652 <strncpy>
f0101728:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010172b:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010172e:	ff 45 c8             	incl   -0x38(%ebp)
f0101731:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0101736:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101739:	0f 8c 96 fe ff ff    	jl     f01015d5 <command_prompt_readline+0x47d>
f010173f:	e9 79 01 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101744:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101748:	0f 84 6f 01 00 00    	je     f01018bd <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010174e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101755:	e9 53 01 00 00       	jmp    f01018ad <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f010175a:	83 ec 0c             	sub    $0xc,%esp
f010175d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101763:	50                   	push   %eax
f0101764:	e8 6c 0e 02 00       	call   f01225d5 <strlen>
f0101769:	83 c4 10             	add    $0x10,%esp
f010176c:	89 c1                	mov    %eax,%ecx
f010176e:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101771:	89 d0                	mov    %edx,%eax
f0101773:	01 c0                	add    %eax,%eax
f0101775:	01 d0                	add    %edx,%eax
f0101777:	c1 e0 02             	shl    $0x2,%eax
f010177a:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f010177f:	8b 00                	mov    (%eax),%eax
f0101781:	83 ec 04             	sub    $0x4,%esp
f0101784:	51                   	push   %ecx
f0101785:	50                   	push   %eax
f0101786:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010178c:	50                   	push   %eax
f010178d:	e8 87 0f 02 00       	call   f0122719 <strncmp>
f0101792:	83 c4 10             	add    $0x10,%esp
f0101795:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f0101798:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f010179c:	0f 85 08 01 00 00    	jne    f01018aa <command_prompt_readline+0x752>
								it_str = -1;
f01017a2:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017a9:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017b0:	00 00 00 
f01017b3:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017b9:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017be:	b8 00 00 00 00       	mov    $0x0,%eax
f01017c3:	89 d7                	mov    %edx,%edi
f01017c5:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017c7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017cd:	83 f8 01             	cmp    $0x1,%eax
f01017d0:	7e 39                	jle    f010180b <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017d2:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017d9:	eb 1d                	jmp    f01017f8 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017db:	ff 45 dc             	incl   -0x24(%ebp)
f01017de:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01017e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01017e4:	01 d0                	add    %edx,%eax
f01017e6:	8a 00                	mov    (%eax),%al
f01017e8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01017ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01017f1:	01 ca                	add    %ecx,%edx
f01017f3:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f5:	ff 45 b8             	incl   -0x48(%ebp)
f01017f8:	83 ec 0c             	sub    $0xc,%esp
f01017fb:	ff 75 0c             	pushl  0xc(%ebp)
f01017fe:	e8 d2 0d 02 00       	call   f01225d5 <strlen>
f0101803:	83 c4 10             	add    $0x10,%esp
f0101806:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101809:	7f d0                	jg     f01017db <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010180b:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101812:	eb 2d                	jmp    f0101841 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101814:	ff 45 dc             	incl   -0x24(%ebp)
f0101817:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010181a:	89 d0                	mov    %edx,%eax
f010181c:	01 c0                	add    %eax,%eax
f010181e:	01 d0                	add    %edx,%eax
f0101820:	c1 e0 02             	shl    $0x2,%eax
f0101823:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101828:	8b 10                	mov    (%eax),%edx
f010182a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010182d:	01 d0                	add    %edx,%eax
f010182f:	8a 00                	mov    (%eax),%al
f0101831:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101837:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010183a:	01 ca                	add    %ecx,%edx
f010183c:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010183e:	ff 45 b4             	incl   -0x4c(%ebp)
f0101841:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101844:	89 d0                	mov    %edx,%eax
f0101846:	01 c0                	add    %eax,%eax
f0101848:	01 d0                	add    %edx,%eax
f010184a:	c1 e0 02             	shl    $0x2,%eax
f010184d:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101852:	8b 00                	mov    (%eax),%eax
f0101854:	83 ec 0c             	sub    $0xc,%esp
f0101857:	50                   	push   %eax
f0101858:	e8 78 0d 02 00       	call   f01225d5 <strlen>
f010185d:	83 c4 10             	add    $0x10,%esp
f0101860:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101863:	7f af                	jg     f0101814 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101865:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101868:	c1 e0 0a             	shl    $0xa,%eax
f010186b:	05 40 3c 5a f0       	add    $0xf05a3c40,%eax
f0101870:	83 ec 04             	sub    $0x4,%esp
f0101873:	68 00 04 00 00       	push   $0x400
f0101878:	6a 00                	push   $0x0
f010187a:	50                   	push   %eax
f010187b:	e8 43 0f 02 00       	call   f01227c3 <memset>
f0101880:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101886:	40                   	inc    %eax
f0101887:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010188a:	c1 e2 0a             	shl    $0xa,%edx
f010188d:	81 c2 40 3c 5a f0    	add    $0xf05a3c40,%edx
f0101893:	83 ec 04             	sub    $0x4,%esp
f0101896:	50                   	push   %eax
f0101897:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010189d:	50                   	push   %eax
f010189e:	52                   	push   %edx
f010189f:	e8 ae 0d 02 00       	call   f0122652 <strncpy>
f01018a4:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018a7:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018aa:	ff 45 bc             	incl   -0x44(%ebp)
f01018ad:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018b0:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f01018b5:	39 c2                	cmp    %eax,%edx
f01018b7:	0f 82 9d fe ff ff    	jb     f010175a <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018c7:	0f 84 a6 03 00 00    	je     f0101c73 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018da:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f01018e1:	eb 1f                	jmp    f0101902 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f01018e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018e6:	8d 50 01             	lea    0x1(%eax),%edx
f01018e9:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01018ec:	89 c2                	mov    %eax,%edx
f01018ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01018f1:	01 c2                	add    %eax,%edx
f01018f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01018f6:	05 40 3c 5a f0       	add    $0xf05a3c40,%eax
f01018fb:	8a 00                	mov    (%eax),%al
f01018fd:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018ff:	ff 45 b0             	incl   -0x50(%ebp)
f0101902:	83 ec 0c             	sub    $0xc,%esp
f0101905:	68 40 3c 5a f0       	push   $0xf05a3c40
f010190a:	e8 c6 0c 02 00       	call   f01225d5 <strlen>
f010190f:	83 c4 10             	add    $0x10,%esp
f0101912:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101915:	7f cc                	jg     f01018e3 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101917:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010191e:	eb 10                	jmp    f0101930 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0101920:	83 ec 0c             	sub    $0xc,%esp
f0101923:	6a 08                	push   $0x8
f0101925:	e8 1f f5 ff ff       	call   f0100e49 <cputchar>
f010192a:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010192d:	ff 45 ac             	incl   -0x54(%ebp)
f0101930:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101933:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101936:	7c e8                	jl     f0101920 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101938:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010193f:	eb 1c                	jmp    f010195d <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101941:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101944:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101947:	01 d0                	add    %edx,%eax
f0101949:	8a 00                	mov    (%eax),%al
f010194b:	0f be c0             	movsbl %al,%eax
f010194e:	83 ec 0c             	sub    $0xc,%esp
f0101951:	50                   	push   %eax
f0101952:	e8 f2 f4 ff ff       	call   f0100e49 <cputchar>
f0101957:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f010195a:	ff 45 a8             	incl   -0x58(%ebp)
f010195d:	83 ec 0c             	sub    $0xc,%esp
f0101960:	ff 75 0c             	pushl  0xc(%ebp)
f0101963:	e8 6d 0c 02 00       	call   f01225d5 <strlen>
f0101968:	83 c4 10             	add    $0x10,%esp
f010196b:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010196e:	7f d1                	jg     f0101941 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0101970:	83 ec 0c             	sub    $0xc,%esp
f0101973:	ff 75 0c             	pushl  0xc(%ebp)
f0101976:	e8 5a 0c 02 00       	call   f01225d5 <strlen>
f010197b:	83 c4 10             	add    $0x10,%esp
f010197e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101984:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010198a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101990:	e9 de 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0101995:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0101999:	0f 8e d4 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
f010199f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019a2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ab:	40                   	inc    %eax
f01019ac:	99                   	cltd   
f01019ad:	f7 7d ec             	idivl  -0x14(%ebp)
f01019b0:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019b6:	c1 e0 0a             	shl    $0xa,%eax
f01019b9:	8d 98 40 3c 5a f0    	lea    -0xfa5c3c0(%eax),%ebx
f01019bf:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019c5:	c1 e0 0a             	shl    $0xa,%eax
f01019c8:	05 40 3c 5a f0       	add    $0xf05a3c40,%eax
f01019cd:	83 ec 0c             	sub    $0xc,%esp
f01019d0:	50                   	push   %eax
f01019d1:	e8 ff 0b 02 00       	call   f01225d5 <strlen>
f01019d6:	83 c4 10             	add    $0x10,%esp
f01019d9:	83 ec 0c             	sub    $0xc,%esp
f01019dc:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f01019e2:	52                   	push   %edx
f01019e3:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f01019e9:	52                   	push   %edx
f01019ea:	ff 75 0c             	pushl  0xc(%ebp)
f01019ed:	53                   	push   %ebx
f01019ee:	50                   	push   %eax
f01019ef:	e8 75 f6 ff ff       	call   f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>
f01019f4:	83 c4 20             	add    $0x20,%esp
f01019f7:	e9 77 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f01019fc:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a03:	75 2e                	jne    f0101a33 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a05:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a0b:	85 c0                	test   %eax,%eax
f0101a0d:	0f 8e 60 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
				i--;
f0101a13:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a19:	48                   	dec    %eax
f0101a1a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a20:	83 ec 0c             	sub    $0xc,%esp
f0101a23:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a26:	e8 1e f4 ff ff       	call   f0100e49 <cputchar>
f0101a2b:	83 c4 10             	add    $0x10,%esp
f0101a2e:	e9 40 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a33:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a3a:	75 34                	jne    f0101a70 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a3c:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a42:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a48:	39 c2                	cmp    %eax,%edx
f0101a4a:	0f 8d 23 02 00 00    	jge    f0101c73 <command_prompt_readline+0xb1b>
				i++;
f0101a50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a56:	40                   	inc    %eax
f0101a57:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a5d:	83 ec 0c             	sub    $0xc,%esp
f0101a60:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a63:	e8 e1 f3 ff ff       	call   f0100e49 <cputchar>
f0101a68:	83 c4 10             	add    $0x10,%esp
f0101a6b:	e9 03 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a70:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a77:	75 4c                	jne    f0101ac5 <command_prompt_readline+0x96d>
f0101a79:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	7e 42                	jle    f0101ac5 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101a83:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a89:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101a8c:	eb 1a                	jmp    f0101aa8 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101a8e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101a91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a94:	01 c2                	add    %eax,%edx
f0101a96:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101a99:	8d 48 01             	lea    0x1(%eax),%ecx
f0101a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a9f:	01 c8                	add    %ecx,%eax
f0101aa1:	8a 00                	mov    (%eax),%al
f0101aa3:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101aa5:	ff 45 a4             	incl   -0x5c(%ebp)
f0101aa8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101aae:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ab1:	7e db                	jle    f0101a8e <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ab3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ab9:	48                   	dec    %eax
f0101aba:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101ac0:	e9 ae 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ac5:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ac9:	7e 60                	jle    f0101b2b <command_prompt_readline+0x9d3>
f0101acb:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ad1:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101ad6:	7f 53                	jg     f0101b2b <command_prompt_readline+0x9d3>
f0101ad8:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101adf:	74 4a                	je     f0101b2b <command_prompt_readline+0x9d3>
f0101ae1:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101ae8:	74 41                	je     f0101b2b <command_prompt_readline+0x9d3>
			if (echoing)
f0101aea:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101aee:	74 0e                	je     f0101afe <command_prompt_readline+0x9a6>
				cputchar(c);
f0101af0:	83 ec 0c             	sub    $0xc,%esp
f0101af3:	ff 75 94             	pushl  -0x6c(%ebp)
f0101af6:	e8 4e f3 ff ff       	call   f0100e49 <cputchar>
f0101afb:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101afe:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b04:	8d 50 01             	lea    0x1(%eax),%edx
f0101b07:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b0d:	89 c2                	mov    %eax,%edx
f0101b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b12:	01 d0                	add    %edx,%eax
f0101b14:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b17:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b19:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b1f:	40                   	inc    %eax
f0101b20:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b26:	e9 48 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b2b:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b2f:	75 60                	jne    f0101b91 <command_prompt_readline+0xa39>
f0101b31:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b37:	85 c0                	test   %eax,%eax
f0101b39:	7e 56                	jle    f0101b91 <command_prompt_readline+0xa39>

			if (echoing)
f0101b3b:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b3f:	74 0e                	je     f0101b4f <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b41:	83 ec 0c             	sub    $0xc,%esp
f0101b44:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b47:	e8 fd f2 ff ff       	call   f0100e49 <cputchar>
f0101b4c:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b4f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b55:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b58:	eb 1a                	jmp    f0101b74 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b5a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b5d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b63:	01 c2                	add    %eax,%edx
f0101b65:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b6b:	01 c8                	add    %ecx,%eax
f0101b6d:	8a 00                	mov    (%eax),%al
f0101b6f:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b71:	ff 45 a0             	incl   -0x60(%ebp)
f0101b74:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b7a:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b7d:	7e db                	jle    f0101b5a <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b7f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b85:	48                   	dec    %eax
f0101b86:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101b8c:	e9 e2 00 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101b91:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101b95:	74 0a                	je     f0101ba1 <command_prompt_readline+0xa49>
f0101b97:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101b9b:	0f 85 d2 00 00 00    	jne    f0101c73 <command_prompt_readline+0xb1b>

			if (echoing)
f0101ba1:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101ba5:	74 0e                	je     f0101bb5 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101ba7:	83 ec 0c             	sub    $0xc,%esp
f0101baa:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bad:	e8 97 f2 ff ff       	call   f0100e49 <cputchar>
f0101bb2:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bb5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bbb:	89 c2                	mov    %eax,%edx
f0101bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bc0:	01 d0                	add    %edx,%eax
f0101bc2:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101bc5:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101bca:	83 f8 13             	cmp    $0x13,%eax
f0101bcd:	75 56                	jne    f0101c25 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bcf:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bd6:	eb 2d                	jmp    f0101c05 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bd8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bdb:	40                   	inc    %eax
f0101bdc:	c1 e0 0a             	shl    $0xa,%eax
f0101bdf:	8d 90 40 cc 5b f0    	lea    -0xfa433c0(%eax),%edx
f0101be5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101be8:	c1 e0 0a             	shl    $0xa,%eax
f0101beb:	05 40 cc 5b f0       	add    $0xf05bcc40,%eax
f0101bf0:	83 ec 04             	sub    $0x4,%esp
f0101bf3:	68 00 04 00 00       	push   $0x400
f0101bf8:	52                   	push   %edx
f0101bf9:	50                   	push   %eax
f0101bfa:	e8 f4 0b 02 00       	call   f01227f3 <memcpy>
f0101bff:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c02:	ff 45 9c             	incl   -0x64(%ebp)
f0101c05:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c09:	7e cd                	jle    f0101bd8 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c0b:	83 ec 04             	sub    $0x4,%esp
f0101c0e:	68 00 04 00 00       	push   $0x400
f0101c13:	ff 75 0c             	pushl  0xc(%ebp)
f0101c16:	68 40 18 5c f0       	push   $0xf05c1840
f0101c1b:	e8 d3 0b 02 00       	call   f01227f3 <memcpy>
f0101c20:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c23:	eb 68                	jmp    f0101c8d <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c25:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c2a:	c1 e0 0a             	shl    $0xa,%eax
f0101c2d:	05 40 cc 5b f0       	add    $0xf05bcc40,%eax
f0101c32:	83 ec 08             	sub    $0x8,%esp
f0101c35:	ff 75 0c             	pushl  0xc(%ebp)
f0101c38:	50                   	push   %eax
f0101c39:	e8 a3 0a 02 00       	call   f01226e1 <strcmp>
f0101c3e:	83 c4 10             	add    $0x10,%esp
f0101c41:	85 c0                	test   %eax,%eax
f0101c43:	74 48                	je     f0101c8d <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c45:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c4a:	40                   	inc    %eax
f0101c4b:	a3 30 f5 17 f0       	mov    %eax,0xf017f530
f0101c50:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c55:	c1 e0 0a             	shl    $0xa,%eax
f0101c58:	05 40 cc 5b f0       	add    $0xf05bcc40,%eax
f0101c5d:	83 ec 04             	sub    $0x4,%esp
f0101c60:	68 00 04 00 00       	push   $0x400
f0101c65:	ff 75 0c             	pushl  0xc(%ebp)
f0101c68:	50                   	push   %eax
f0101c69:	e8 85 0b 02 00       	call   f01227f3 <memcpy>
f0101c6e:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c71:	eb 1a                	jmp    f0101c8d <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c73:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c76:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c79:	e9 44 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c7e:	90                   	nop
f0101c7f:	e9 3e f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101c84:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101c85:	e9 38 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101c8a:	90                   	nop
f0101c8b:	eb 01                	jmp    f0101c8e <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c8d:	90                   	nop

		}
		last_c = c;
	}
}
f0101c8e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c91:	5b                   	pop    %ebx
f0101c92:	5f                   	pop    %edi
f0101c93:	5d                   	pop    %ebp
f0101c94:	c3                   	ret    

f0101c95 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101c95:	55                   	push   %ebp
f0101c96:	89 e5                	mov    %esp,%ebp
f0101c98:	57                   	push   %edi
f0101c99:	56                   	push   %esi
f0101c9a:	53                   	push   %ebx
f0101c9b:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101ca1:	a1 7c 3b 5a f0       	mov    0xf05a3b7c,%eax
f0101ca6:	85 c0                	test   %eax,%eax
f0101ca8:	0f 84 85 00 00 00    	je     f0101d33 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101cae:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cb4:	bb 17 45 12 f0       	mov    $0xf0124517,%ebx
f0101cb9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cbe:	89 c7                	mov    %eax,%edi
f0101cc0:	89 de                	mov    %ebx,%esi
f0101cc2:	89 d1                	mov    %edx,%ecx
f0101cc4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cc6:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ccc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cd1:	b0 00                	mov    $0x0,%al
f0101cd3:	89 d7                	mov    %edx,%edi
f0101cd5:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cd7:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cdd:	bb 17 49 12 f0       	mov    $0xf0124917,%ebx
f0101ce2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101ce7:	89 c7                	mov    %eax,%edi
f0101ce9:	89 de                	mov    %ebx,%esi
f0101ceb:	89 d1                	mov    %edx,%ecx
f0101ced:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cef:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101cf5:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cfa:	b0 00                	mov    $0x0,%al
f0101cfc:	89 d7                	mov    %edx,%edi
f0101cfe:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d00:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d06:	bb 17 4d 12 f0       	mov    $0xf0124d17,%ebx
f0101d0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d10:	89 c7                	mov    %eax,%edi
f0101d12:	89 de                	mov    %ebx,%esi
f0101d14:	89 d1                	mov    %edx,%ecx
f0101d16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d18:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d1e:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d23:	b0 00                	mov    $0x0,%al
f0101d25:	89 d7                	mov    %edx,%edi
f0101d27:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d29:	c7 05 7c 3b 5a f0 00 	movl   $0x0,0xf05a3b7c
f0101d30:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d33:	c7 05 0c 3b 5a f0 00 	movl   $0x0,0xf05a3b0c
f0101d3a:	00 00 00 
f0101d3d:	c7 05 10 3b 5a f0 00 	movl   $0x0,0xf05a3b10
f0101d44:	00 00 00 
f0101d47:	c7 05 18 3b 5a f0 00 	movl   $0x0,0xf05a3b18
f0101d4e:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d51:	83 ec 04             	sub    $0x4,%esp
f0101d54:	68 00 04 00 00       	push   $0x400
f0101d59:	6a 00                	push   $0x0
f0101d5b:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d61:	50                   	push   %eax
f0101d62:	e8 5c 0a 02 00       	call   f01227c3 <memset>
f0101d67:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d6a:	83 ec 08             	sub    $0x8,%esp
f0101d6d:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d73:	50                   	push   %eax
f0101d74:	68 11 45 12 f0       	push   $0xf0124511
f0101d79:	e8 da f3 ff ff       	call   f0101158 <command_prompt_readline>
f0101d7e:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101d81:	83 ec 0c             	sub    $0xc,%esp
f0101d84:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d8a:	50                   	push   %eax
f0101d8b:	e8 4c 01 00 00       	call   f0101edc <execute_command>
f0101d90:	83 c4 10             	add    $0x10,%esp
f0101d93:	85 c0                	test   %eax,%eax
f0101d95:	78 02                	js     f0101d99 <run_command_prompt+0x104>
				break;
	}
f0101d97:	eb b8                	jmp    f0101d51 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101d99:	90                   	nop
	}
}
f0101d9a:	90                   	nop
f0101d9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101d9e:	5b                   	pop    %ebx
f0101d9f:	5e                   	pop    %esi
f0101da0:	5f                   	pop    %edi
f0101da1:	5d                   	pop    %ebp
f0101da2:	c3                   	ret    

f0101da3 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101da3:	55                   	push   %ebp
f0101da4:	89 e5                	mov    %esp,%ebp
f0101da6:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101da9:	9c                   	pushf  
f0101daa:	58                   	pop    %eax
f0101dab:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dae:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101db1:	25 00 02 00 00       	and    $0x200,%eax
f0101db6:	85 c0                	test   %eax,%eax
f0101db8:	74 01                	je     f0101dbb <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dba:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dbb:	e8 49 8c 00 00       	call   f010aa09 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101dc0:	e8 38 53 00 00       	call   f01070fd <mycpu>
f0101dc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101dc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dcb:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101dd2:	00 00 00 
		c->intena = 0;
f0101dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dd8:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101ddf:	00 00 00 
		c->scheduler = NULL;
f0101de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101de5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101def:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101df6:	00 00 00 
		c->proc = NULL;
f0101df9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dfc:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e03:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e06:	89 e0                	mov    %esp,%eax
f0101e08:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e0b:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e0e:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e11:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e14:	8b 40 08             	mov    0x8(%eax),%eax
f0101e17:	05 00 80 00 00       	add    $0x8000,%eax
f0101e1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e22:	8b 40 08             	mov    0x8(%eax),%eax
f0101e25:	05 00 10 00 00       	add    $0x1000,%eax
f0101e2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e36:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e38:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e3b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e3e:	73 44                	jae    f0101e84 <get_into_prompt+0xe1>
f0101e40:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e43:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e46:	72 3c                	jb     f0101e84 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e48:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e4b:	a3 20 3c 5a f0       	mov    %eax,0xf05a3c20
			m = cpuStackTop - cur_esp;
f0101e50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e53:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e56:	a3 40 1c 5c f0       	mov    %eax,0xf05c1c40
			while (--m >= 0)
f0101e5b:	eb 11                	jmp    f0101e6e <get_into_prompt+0xcb>
				*p++ = 0;
f0101e5d:	a1 20 3c 5a f0       	mov    0xf05a3c20,%eax
f0101e62:	8d 50 01             	lea    0x1(%eax),%edx
f0101e65:	89 15 20 3c 5a f0    	mov    %edx,0xf05a3c20
f0101e6b:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e6e:	a1 40 1c 5c f0       	mov    0xf05c1c40,%eax
f0101e73:	48                   	dec    %eax
f0101e74:	a3 40 1c 5c f0       	mov    %eax,0xf05c1c40
f0101e79:	a1 40 1c 5c f0       	mov    0xf05c1c40,%eax
f0101e7e:	85 c0                	test   %eax,%eax
f0101e80:	79 db                	jns    f0101e5d <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e82:	eb 3a                	jmp    f0101ebe <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101e84:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101e87:	a3 20 3c 5a f0       	mov    %eax,0xf05a3c20
			m = cpuStackTop - cpuStackBottom;
f0101e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e8f:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101e92:	a3 40 1c 5c f0       	mov    %eax,0xf05c1c40
			while (--m >= 0)
f0101e97:	eb 11                	jmp    f0101eaa <get_into_prompt+0x107>
				*p++ = 0;
f0101e99:	a1 20 3c 5a f0       	mov    0xf05a3c20,%eax
f0101e9e:	8d 50 01             	lea    0x1(%eax),%edx
f0101ea1:	89 15 20 3c 5a f0    	mov    %edx,0xf05a3c20
f0101ea7:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101eaa:	a1 40 1c 5c f0       	mov    0xf05c1c40,%eax
f0101eaf:	48                   	dec    %eax
f0101eb0:	a3 40 1c 5c f0       	mov    %eax,0xf05c1c40
f0101eb5:	a1 40 1c 5c f0       	mov    0xf05c1c40,%eax
f0101eba:	85 c0                	test   %eax,%eax
f0101ebc:	79 db                	jns    f0101e99 <get_into_prompt+0xf6>
f0101ebe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ec5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ec8:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101eca:	83 ec 0c             	sub    $0xc,%esp
f0101ecd:	6a 00                	push   $0x0
f0101ecf:	e8 c1 fd ff ff       	call   f0101c95 <run_command_prompt>
f0101ed4:	83 c4 10             	add    $0x10,%esp
	}
f0101ed7:	e9 cd fe ff ff       	jmp    f0101da9 <get_into_prompt+0x6>

f0101edc <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101edc:	55                   	push   %ebp
f0101edd:	89 e5                	mov    %esp,%ebp
f0101edf:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101ee2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101ee5:	50                   	push   %eax
f0101ee6:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101ee9:	50                   	push   %eax
f0101eea:	68 ff 44 12 f0       	push   $0xf01244ff
f0101eef:	ff 75 08             	pushl  0x8(%ebp)
f0101ef2:	e8 f3 0c 02 00       	call   f0122bea <strsplit>
f0101ef7:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101efa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101efd:	85 c0                	test   %eax,%eax
f0101eff:	75 0a                	jne    f0101f0b <execute_command+0x2f>
		return 0;
f0101f01:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f06:	e9 a4 02 00 00       	jmp    f01021af <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f0e:	83 ec 08             	sub    $0x8,%esp
f0101f11:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f14:	52                   	push   %edx
f0101f15:	50                   	push   %eax
f0101f16:	e8 96 02 00 00       	call   f01021b1 <process_command>
f0101f1b:	83 c4 10             	add    $0x10,%esp
f0101f1e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f21:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f25:	75 19                	jne    f0101f40 <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f27:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f2a:	83 ec 08             	sub    $0x8,%esp
f0101f2d:	50                   	push   %eax
f0101f2e:	68 17 51 12 f0       	push   $0xf0125117
f0101f33:	e8 34 f0 ff ff       	call   f0100f6c <cprintf>
f0101f38:	83 c4 10             	add    $0x10,%esp
f0101f3b:	e9 6a 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f40:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f44:	75 4f                	jne    f0101f95 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f46:	a1 18 3b 5a f0       	mov    0xf05a3b18,%eax
f0101f4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f4e:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f52:	74 17                	je     f0101f6b <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f54:	83 ec 04             	sub    $0x4,%esp
f0101f57:	68 30 51 12 f0       	push   $0xf0125130
f0101f5c:	68 8b 01 00 00       	push   $0x18b
f0101f61:	68 81 51 12 f0       	push   $0xf0125181
f0101f66:	e8 af e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f6b:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f0101f70:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f76:	8b 50 04             	mov    0x4(%eax),%edx
f0101f79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f7c:	8b 00                	mov    (%eax),%eax
f0101f7e:	83 ec 04             	sub    $0x4,%esp
f0101f81:	52                   	push   %edx
f0101f82:	50                   	push   %eax
f0101f83:	68 9c 51 12 f0       	push   $0xf012519c
f0101f88:	e8 df ef ff ff       	call   f0100f6c <cprintf>
f0101f8d:	83 c4 10             	add    $0x10,%esp
f0101f90:	e9 15 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101f95:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101f99:	0f 85 e6 01 00 00    	jne    f0102185 <execute_command+0x2a9>
	{
		int i = 1;
f0101f9f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fa6:	a1 18 3b 5a f0       	mov    0xf05a3b18,%eax
f0101fab:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fae:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fb2:	75 17                	jne    f0101fcb <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fb4:	83 ec 04             	sub    $0x4,%esp
f0101fb7:	68 cc 51 12 f0       	push   $0xf01251cc
f0101fbc:	68 96 01 00 00       	push   $0x196
f0101fc1:	68 81 51 12 f0       	push   $0xf0125181
f0101fc6:	e8 4f e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = NULL;
f0101fcb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101fd2:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f0101fd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101fda:	eb 28                	jmp    f0102004 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101fdf:	8b 10                	mov    (%eax),%edx
f0101fe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101fe4:	8d 48 01             	lea    0x1(%eax),%ecx
f0101fe7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101fea:	83 ec 04             	sub    $0x4,%esp
f0101fed:	52                   	push   %edx
f0101fee:	50                   	push   %eax
f0101fef:	68 f6 51 12 f0       	push   $0xf01251f6
f0101ff4:	e8 73 ef ff ff       	call   f0100f6c <cprintf>
f0101ff9:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101ffc:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0102001:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102004:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102008:	74 08                	je     f0102012 <execute_command+0x136>
f010200a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010200d:	8b 40 10             	mov    0x10(%eax),%eax
f0102010:	eb 05                	jmp    f0102017 <execute_command+0x13b>
f0102012:	b8 00 00 00 00       	mov    $0x0,%eax
f0102017:	a3 14 3b 5a f0       	mov    %eax,0xf05a3b14
f010201c:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0102021:	85 c0                	test   %eax,%eax
f0102023:	75 b7                	jne    f0101fdc <execute_command+0x100>
f0102025:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102029:	75 b1                	jne    f0101fdc <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010202b:	83 ec 08             	sub    $0x8,%esp
f010202e:	ff 75 dc             	pushl  -0x24(%ebp)
f0102031:	68 00 52 12 f0       	push   $0xf0125200
f0102036:	e8 31 ef ff ff       	call   f0100f6c <cprintf>
f010203b:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010203e:	e8 1d ee ff ff       	call   f0100e60 <getchar>
f0102043:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102046:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f010204a:	83 ec 0c             	sub    $0xc,%esp
f010204d:	50                   	push   %eax
f010204e:	e8 f6 ed ff ff       	call   f0100e49 <cputchar>
f0102053:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102056:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010205d:	eb 40                	jmp    f010209f <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010205f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102062:	89 d0                	mov    %edx,%eax
f0102064:	c1 e0 02             	shl    $0x2,%eax
f0102067:	01 d0                	add    %edx,%eax
f0102069:	01 c0                	add    %eax,%eax
f010206b:	89 c2                	mov    %eax,%edx
f010206d:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102071:	83 e8 30             	sub    $0x30,%eax
f0102074:	01 d0                	add    %edx,%eax
f0102076:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102079:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010207d:	7e 2c                	jle    f01020ab <execute_command+0x1cf>
f010207f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102082:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102085:	7f 24                	jg     f01020ab <execute_command+0x1cf>
				break;

			Chose = getchar();
f0102087:	e8 d4 ed ff ff       	call   f0100e60 <getchar>
f010208c:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f010208f:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102093:	83 ec 0c             	sub    $0xc,%esp
f0102096:	50                   	push   %eax
f0102097:	e8 ad ed ff ff       	call   f0100e49 <cputchar>
f010209c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f010209f:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020a3:	7e 06                	jle    f01020ab <execute_command+0x1cf>
f01020a5:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020a9:	7e b4                	jle    f010205f <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ab:	83 ec 0c             	sub    $0xc,%esp
f01020ae:	6a 0a                	push   $0xa
f01020b0:	e8 94 ed ff ff       	call   f0100e49 <cputchar>
f01020b5:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020bc:	0f 8e e8 00 00 00    	jle    f01021aa <execute_command+0x2ce>
f01020c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020c5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020c8:	0f 8f dc 00 00 00    	jg     f01021aa <execute_command+0x2ce>
		{
			int c = 1;
f01020ce:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020d5:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f01020da:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020dd:	eb 75                	jmp    f0102154 <execute_command+0x278>
			{
				if (c++ == selection)
f01020df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01020e2:	8d 50 01             	lea    0x1(%eax),%edx
f01020e5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01020e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01020eb:	75 5f                	jne    f010214c <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f01020ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01020f3:	85 c0                	test   %eax,%eax
f01020f5:	75 31                	jne    f0102128 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f01020f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020fa:	8b 00                	mov    (%eax),%eax
f01020fc:	83 ec 08             	sub    $0x8,%esp
f01020ff:	50                   	push   %eax
f0102100:	68 63 52 12 f0       	push   $0xf0125263
f0102105:	e8 62 ee ff ff       	call   f0100f6c <cprintf>
f010210a:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010210d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102110:	8b 40 08             	mov    0x8(%eax),%eax
f0102113:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102116:	83 ec 08             	sub    $0x8,%esp
f0102119:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010211c:	51                   	push   %ecx
f010211d:	52                   	push   %edx
f010211e:	ff d0                	call   *%eax
f0102120:	83 c4 10             	add    $0x10,%esp
f0102123:	e9 87 00 00 00       	jmp    f01021af <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102128:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212b:	8b 50 04             	mov    0x4(%eax),%edx
f010212e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102131:	8b 00                	mov    (%eax),%eax
f0102133:	83 ec 04             	sub    $0x4,%esp
f0102136:	52                   	push   %edx
f0102137:	50                   	push   %eax
f0102138:	68 6c 52 12 f0       	push   $0xf012526c
f010213d:	e8 2a ee ff ff       	call   f0100f6c <cprintf>
f0102142:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102145:	b8 00 00 00 00       	mov    $0x0,%eax
f010214a:	eb 63                	jmp    f01021af <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010214c:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0102151:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102154:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102158:	74 08                	je     f0102162 <execute_command+0x286>
f010215a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010215d:	8b 40 10             	mov    0x10(%eax),%eax
f0102160:	eb 05                	jmp    f0102167 <execute_command+0x28b>
f0102162:	b8 00 00 00 00       	mov    $0x0,%eax
f0102167:	a3 14 3b 5a f0       	mov    %eax,0xf05a3b14
f010216c:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0102171:	85 c0                	test   %eax,%eax
f0102173:	0f 85 66 ff ff ff    	jne    f01020df <execute_command+0x203>
f0102179:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010217d:	0f 85 5c ff ff ff    	jne    f01020df <execute_command+0x203>
f0102183:	eb 25                	jmp    f01021aa <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f0102185:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102188:	89 d0                	mov    %edx,%eax
f010218a:	01 c0                	add    %eax,%eax
f010218c:	01 d0                	add    %edx,%eax
f010218e:	c1 e0 03             	shl    $0x3,%eax
f0102191:	05 48 f5 17 f0       	add    $0xf017f548,%eax
f0102196:	8b 00                	mov    (%eax),%eax
f0102198:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010219b:	83 ec 08             	sub    $0x8,%esp
f010219e:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021a1:	51                   	push   %ecx
f01021a2:	52                   	push   %edx
f01021a3:	ff d0                	call   *%eax
f01021a5:	83 c4 10             	add    $0x10,%esp
f01021a8:	eb 05                	jmp    f01021af <execute_command+0x2d3>
	}
	return 0;
f01021aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021af:	c9                   	leave  
f01021b0:	c3                   	ret    

f01021b1 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021b1:	55                   	push   %ebp
f01021b2:	89 e5                	mov    %esp,%ebp
f01021b4:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021be:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f01021c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021c6:	e9 90 00 00 00       	jmp    f010225b <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021cf:	75 17                	jne    f01021e8 <process_command+0x37>
f01021d1:	83 ec 04             	sub    $0x4,%esp
f01021d4:	68 74 52 12 f0       	push   $0xf0125274
f01021d9:	68 cd 01 00 00       	push   $0x1cd
f01021de:	68 81 51 12 f0       	push   $0xf0125181
f01021e3:	e8 32 e1 ff ff       	call   f010031a <_panic>
f01021e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01021eb:	8b 40 10             	mov    0x10(%eax),%eax
f01021ee:	85 c0                	test   %eax,%eax
f01021f0:	74 11                	je     f0102203 <process_command+0x52>
f01021f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01021f5:	8b 40 10             	mov    0x10(%eax),%eax
f01021f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01021fb:	8b 52 14             	mov    0x14(%edx),%edx
f01021fe:	89 50 14             	mov    %edx,0x14(%eax)
f0102201:	eb 0b                	jmp    f010220e <process_command+0x5d>
f0102203:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102206:	8b 40 14             	mov    0x14(%eax),%eax
f0102209:	a3 10 3b 5a f0       	mov    %eax,0xf05a3b10
f010220e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102211:	8b 40 14             	mov    0x14(%eax),%eax
f0102214:	85 c0                	test   %eax,%eax
f0102216:	74 11                	je     f0102229 <process_command+0x78>
f0102218:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010221b:	8b 40 14             	mov    0x14(%eax),%eax
f010221e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102221:	8b 52 10             	mov    0x10(%edx),%edx
f0102224:	89 50 10             	mov    %edx,0x10(%eax)
f0102227:	eb 0b                	jmp    f0102234 <process_command+0x83>
f0102229:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010222c:	8b 40 10             	mov    0x10(%eax),%eax
f010222f:	a3 0c 3b 5a f0       	mov    %eax,0xf05a3b0c
f0102234:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102237:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010223e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102241:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102248:	a1 18 3b 5a f0       	mov    0xf05a3b18,%eax
f010224d:	48                   	dec    %eax
f010224e:	a3 18 3b 5a f0       	mov    %eax,0xf05a3b18

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102253:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0102258:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010225b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010225f:	74 08                	je     f0102269 <process_command+0xb8>
f0102261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102264:	8b 40 10             	mov    0x10(%eax),%eax
f0102267:	eb 05                	jmp    f010226e <process_command+0xbd>
f0102269:	b8 00 00 00 00       	mov    $0x0,%eax
f010226e:	a3 14 3b 5a f0       	mov    %eax,0xf05a3b14
f0102273:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0102278:	85 c0                	test   %eax,%eax
f010227a:	0f 85 4b ff ff ff    	jne    f01021cb <process_command+0x1a>
f0102280:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102284:	0f 85 41 ff ff ff    	jne    f01021cb <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f010228a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f0102291:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0102298:	e9 42 02 00 00       	jmp    f01024df <process_command+0x32e>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f010229d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022a0:	89 d0                	mov    %edx,%eax
f01022a2:	01 c0                	add    %eax,%eax
f01022a4:	01 d0                	add    %edx,%eax
f01022a6:	c1 e0 03             	shl    $0x3,%eax
f01022a9:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01022ae:	8b 10                	mov    (%eax),%edx
f01022b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022b3:	8b 00                	mov    (%eax),%eax
f01022b5:	83 ec 08             	sub    $0x8,%esp
f01022b8:	52                   	push   %edx
f01022b9:	50                   	push   %eax
f01022ba:	e8 22 04 02 00       	call   f01226e1 <strcmp>
f01022bf:	83 c4 10             	add    $0x10,%esp
f01022c2:	85 c0                	test   %eax,%eax
f01022c4:	0f 85 1e 01 00 00    	jne    f01023e8 <process_command+0x237>
        {
            cprintf("%d %d \n",commands[i].num_of_args,number_of_arguments-1);
f01022ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01022cd:	8d 48 ff             	lea    -0x1(%eax),%ecx
f01022d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022d3:	89 d0                	mov    %edx,%eax
f01022d5:	01 c0                	add    %eax,%eax
f01022d7:	01 d0                	add    %edx,%eax
f01022d9:	c1 e0 03             	shl    $0x3,%eax
f01022dc:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f01022e1:	8b 00                	mov    (%eax),%eax
f01022e3:	83 ec 04             	sub    $0x4,%esp
f01022e6:	51                   	push   %ecx
f01022e7:	50                   	push   %eax
f01022e8:	68 92 52 12 f0       	push   $0xf0125292
f01022ed:	e8 7a ec ff ff       	call   f0100f6c <cprintf>
f01022f2:	83 c4 10             	add    $0x10,%esp
            if(commands[i].num_of_args != number_of_arguments-1)
f01022f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022f8:	89 d0                	mov    %edx,%eax
f01022fa:	01 c0                	add    %eax,%eax
f01022fc:	01 d0                	add    %edx,%eax
f01022fe:	c1 e0 03             	shl    $0x3,%eax
f0102301:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f0102306:	8b 00                	mov    (%eax),%eax
f0102308:	8b 55 08             	mov    0x8(%ebp),%edx
f010230b:	4a                   	dec    %edx
f010230c:	39 d0                	cmp    %edx,%eax
f010230e:	0f 84 cc 00 00 00    	je     f01023e0 <process_command+0x22f>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102314:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102317:	89 d0                	mov    %edx,%eax
f0102319:	01 c0                	add    %eax,%eax
f010231b:	01 d0                	add    %edx,%eax
f010231d:	c1 e0 03             	shl    $0x3,%eax
f0102320:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f0102325:	8b 00                	mov    (%eax),%eax
f0102327:	83 f8 ff             	cmp    $0xffffffff,%eax
f010232a:	75 10                	jne    f010233c <process_command+0x18b>
f010232c:	8b 45 08             	mov    0x8(%ebp),%eax
f010232f:	48                   	dec    %eax
f0102330:	85 c0                	test   %eax,%eax
f0102332:	7e 08                	jle    f010233c <process_command+0x18b>
                {
                    return i;
f0102334:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102337:	e9 c5 01 00 00       	jmp    f0102501 <process_command+0x350>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010233c:	8b 15 0c 3b 5a f0    	mov    0xf05a3b0c,%edx
f0102342:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102345:	89 c8                	mov    %ecx,%eax
f0102347:	01 c0                	add    %eax,%eax
f0102349:	01 c8                	add    %ecx,%eax
f010234b:	c1 e0 03             	shl    $0x3,%eax
f010234e:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102353:	89 10                	mov    %edx,(%eax)
f0102355:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102358:	89 d0                	mov    %edx,%eax
f010235a:	01 c0                	add    %eax,%eax
f010235c:	01 d0                	add    %edx,%eax
f010235e:	c1 e0 03             	shl    $0x3,%eax
f0102361:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102366:	8b 00                	mov    (%eax),%eax
f0102368:	85 c0                	test   %eax,%eax
f010236a:	74 1c                	je     f0102388 <process_command+0x1d7>
f010236c:	8b 15 0c 3b 5a f0    	mov    0xf05a3b0c,%edx
f0102372:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102375:	89 c8                	mov    %ecx,%eax
f0102377:	01 c0                	add    %eax,%eax
f0102379:	01 c8                	add    %ecx,%eax
f010237b:	c1 e0 03             	shl    $0x3,%eax
f010237e:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102383:	89 42 14             	mov    %eax,0x14(%edx)
f0102386:	eb 16                	jmp    f010239e <process_command+0x1ed>
f0102388:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010238b:	89 d0                	mov    %edx,%eax
f010238d:	01 c0                	add    %eax,%eax
f010238f:	01 d0                	add    %edx,%eax
f0102391:	c1 e0 03             	shl    $0x3,%eax
f0102394:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102399:	a3 10 3b 5a f0       	mov    %eax,0xf05a3b10
f010239e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023a1:	89 d0                	mov    %edx,%eax
f01023a3:	01 c0                	add    %eax,%eax
f01023a5:	01 d0                	add    %edx,%eax
f01023a7:	c1 e0 03             	shl    $0x3,%eax
f01023aa:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023af:	a3 0c 3b 5a f0       	mov    %eax,0xf05a3b0c
f01023b4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023b7:	89 d0                	mov    %edx,%eax
f01023b9:	01 c0                	add    %eax,%eax
f01023bb:	01 d0                	add    %edx,%eax
f01023bd:	c1 e0 03             	shl    $0x3,%eax
f01023c0:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01023c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023cb:	a1 18 3b 5a f0       	mov    0xf05a3b18,%eax
f01023d0:	40                   	inc    %eax
f01023d1:	a3 18 3b 5a f0       	mov    %eax,0xf05a3b18
                return CMD_INV_NUM_ARGS;
f01023d6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023db:	e9 21 01 00 00       	jmp    f0102501 <process_command+0x350>
                }
            }
            else
            {
            return i;
f01023e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023e3:	e9 19 01 00 00       	jmp    f0102501 <process_command+0x350>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023eb:	8b 00                	mov    (%eax),%eax
f01023ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023f0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023f3:	89 d0                	mov    %edx,%eax
f01023f5:	01 c0                	add    %eax,%eax
f01023f7:	01 d0                	add    %edx,%eax
f01023f9:	c1 e0 03             	shl    $0x3,%eax
f01023fc:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102401:	8b 00                	mov    (%eax),%eax
f0102403:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102406:	eb 14                	jmp    f010241c <process_command+0x26b>
            {
                if (*ptr1 == *ptr2)
f0102408:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010240b:	8a 10                	mov    (%eax),%dl
f010240d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102410:	8a 00                	mov    (%eax),%al
f0102412:	38 c2                	cmp    %al,%dl
f0102414:	75 03                	jne    f0102419 <process_command+0x268>
                {
                    ptr1++;
f0102416:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f0102419:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f010241c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010241f:	8a 00                	mov    (%eax),%al
f0102421:	84 c0                	test   %al,%al
f0102423:	74 09                	je     f010242e <process_command+0x27d>
f0102425:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102428:	8a 00                	mov    (%eax),%al
f010242a:	84 c0                	test   %al,%al
f010242c:	75 da                	jne    f0102408 <process_command+0x257>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f010242e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102431:	8a 00                	mov    (%eax),%al
f0102433:	84 c0                	test   %al,%al
f0102435:	0f 85 a1 00 00 00    	jne    f01024dc <process_command+0x32b>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010243b:	8b 15 0c 3b 5a f0    	mov    0xf05a3b0c,%edx
f0102441:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102444:	89 c8                	mov    %ecx,%eax
f0102446:	01 c0                	add    %eax,%eax
f0102448:	01 c8                	add    %ecx,%eax
f010244a:	c1 e0 03             	shl    $0x3,%eax
f010244d:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102452:	89 10                	mov    %edx,(%eax)
f0102454:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102457:	89 d0                	mov    %edx,%eax
f0102459:	01 c0                	add    %eax,%eax
f010245b:	01 d0                	add    %edx,%eax
f010245d:	c1 e0 03             	shl    $0x3,%eax
f0102460:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102465:	8b 00                	mov    (%eax),%eax
f0102467:	85 c0                	test   %eax,%eax
f0102469:	74 1c                	je     f0102487 <process_command+0x2d6>
f010246b:	8b 15 0c 3b 5a f0    	mov    0xf05a3b0c,%edx
f0102471:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102474:	89 c8                	mov    %ecx,%eax
f0102476:	01 c0                	add    %eax,%eax
f0102478:	01 c8                	add    %ecx,%eax
f010247a:	c1 e0 03             	shl    $0x3,%eax
f010247d:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102482:	89 42 14             	mov    %eax,0x14(%edx)
f0102485:	eb 16                	jmp    f010249d <process_command+0x2ec>
f0102487:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010248a:	89 d0                	mov    %edx,%eax
f010248c:	01 c0                	add    %eax,%eax
f010248e:	01 d0                	add    %edx,%eax
f0102490:	c1 e0 03             	shl    $0x3,%eax
f0102493:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102498:	a3 10 3b 5a f0       	mov    %eax,0xf05a3b10
f010249d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024a0:	89 d0                	mov    %edx,%eax
f01024a2:	01 c0                	add    %eax,%eax
f01024a4:	01 d0                	add    %edx,%eax
f01024a6:	c1 e0 03             	shl    $0x3,%eax
f01024a9:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01024ae:	a3 0c 3b 5a f0       	mov    %eax,0xf05a3b0c
f01024b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024b6:	89 d0                	mov    %edx,%eax
f01024b8:	01 c0                	add    %eax,%eax
f01024ba:	01 d0                	add    %edx,%eax
f01024bc:	c1 e0 03             	shl    $0x3,%eax
f01024bf:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01024c4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024ca:	a1 18 3b 5a f0       	mov    0xf05a3b18,%eax
f01024cf:	40                   	inc    %eax
f01024d0:	a3 18 3b 5a f0       	mov    %eax,0xf05a3b18
                x=1;
f01024d5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024dc:	ff 45 ec             	incl   -0x14(%ebp)
f01024df:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024e2:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01024e7:	39 c2                	cmp    %eax,%edx
f01024e9:	0f 82 ae fd ff ff    	jb     f010229d <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024ef:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024f3:	75 07                	jne    f01024fc <process_command+0x34b>
    {
        return CMD_MATCHED;
f01024f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024fa:	eb 05                	jmp    f0102501 <process_command+0x350>
    }
    return CMD_INVALID;
f01024fc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102501:	c9                   	leave  
f0102502:	c3                   	ret    

f0102503 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f0102503:	55                   	push   %ebp
f0102504:	89 e5                	mov    %esp,%ebp
f0102506:	c7 05 50 39 5a f0 00 	movl   $0x0,0xf05a3950
f010250d:	00 00 00 
f0102510:	90                   	nop
f0102511:	5d                   	pop    %ebp
f0102512:	c3                   	ret    

f0102513 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102513:	55                   	push   %ebp
f0102514:	89 e5                	mov    %esp,%ebp
f0102516:	c7 05 50 39 5a f0 01 	movl   $0x1,0xf05a3950
f010251d:	00 00 00 
f0102520:	90                   	nop
f0102521:	5d                   	pop    %ebp
f0102522:	c3                   	ret    

f0102523 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102523:	55                   	push   %ebp
f0102524:	89 e5                	mov    %esp,%ebp
f0102526:	c7 05 50 39 5a f0 02 	movl   $0x2,0xf05a3950
f010252d:	00 00 00 
f0102530:	90                   	nop
f0102531:	5d                   	pop    %ebp
f0102532:	c3                   	ret    

f0102533 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102533:	55                   	push   %ebp
f0102534:	89 e5                	mov    %esp,%ebp
f0102536:	c7 05 50 39 5a f0 03 	movl   $0x3,0xf05a3950
f010253d:	00 00 00 
f0102540:	90                   	nop
f0102541:	5d                   	pop    %ebp
f0102542:	c3                   	ret    

f0102543 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102543:	55                   	push   %ebp
f0102544:	89 e5                	mov    %esp,%ebp
f0102546:	c7 05 50 39 5a f0 04 	movl   $0x4,0xf05a3950
f010254d:	00 00 00 
f0102550:	90                   	nop
f0102551:	5d                   	pop    %ebp
f0102552:	c3                   	ret    

f0102553 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102553:	55                   	push   %ebp
f0102554:	89 e5                	mov    %esp,%ebp
f0102556:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f010255b:	85 c0                	test   %eax,%eax
f010255d:	75 04                	jne    f0102563 <isKHeapPlacementStrategyCONTALLOC+0x10>
f010255f:	b0 01                	mov    $0x1,%al
f0102561:	eb 02                	jmp    f0102565 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102563:	b0 00                	mov    $0x0,%al
f0102565:	5d                   	pop    %ebp
f0102566:	c3                   	ret    

f0102567 <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0102567:	55                   	push   %ebp
f0102568:	89 e5                	mov    %esp,%ebp
f010256a:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f010256f:	83 f8 01             	cmp    $0x1,%eax
f0102572:	75 04                	jne    f0102578 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102574:	b0 01                	mov    $0x1,%al
f0102576:	eb 02                	jmp    f010257a <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0102578:	b0 00                	mov    $0x0,%al
f010257a:	5d                   	pop    %ebp
f010257b:	c3                   	ret    

f010257c <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010257c:	55                   	push   %ebp
f010257d:	89 e5                	mov    %esp,%ebp
f010257f:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f0102584:	83 f8 02             	cmp    $0x2,%eax
f0102587:	75 04                	jne    f010258d <isKHeapPlacementStrategyBESTFIT+0x11>
f0102589:	b0 01                	mov    $0x1,%al
f010258b:	eb 02                	jmp    f010258f <isKHeapPlacementStrategyBESTFIT+0x13>
f010258d:	b0 00                	mov    $0x0,%al
f010258f:	5d                   	pop    %ebp
f0102590:	c3                   	ret    

f0102591 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102591:	55                   	push   %ebp
f0102592:	89 e5                	mov    %esp,%ebp
f0102594:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f0102599:	83 f8 03             	cmp    $0x3,%eax
f010259c:	75 04                	jne    f01025a2 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010259e:	b0 01                	mov    $0x1,%al
f01025a0:	eb 02                	jmp    f01025a4 <isKHeapPlacementStrategyNEXTFIT+0x13>
f01025a2:	b0 00                	mov    $0x0,%al
f01025a4:	5d                   	pop    %ebp
f01025a5:	c3                   	ret    

f01025a6 <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f01025a6:	55                   	push   %ebp
f01025a7:	89 e5                	mov    %esp,%ebp
f01025a9:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f01025ae:	83 f8 04             	cmp    $0x4,%eax
f01025b1:	75 04                	jne    f01025b7 <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025b3:	b0 01                	mov    $0x1,%al
f01025b5:	eb 02                	jmp    f01025b9 <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025b7:	b0 00                	mov    $0x0,%al
f01025b9:	5d                   	pop    %ebp
f01025ba:	c3                   	ret    

f01025bb <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025bb:	55                   	push   %ebp
f01025bc:	89 e5                	mov    %esp,%ebp
f01025be:	c7 05 a4 38 5a f0 01 	movl   $0x1,0xf05a38a4
f01025c5:	00 00 00 
f01025c8:	90                   	nop
f01025c9:	5d                   	pop    %ebp
f01025ca:	c3                   	ret    

f01025cb <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025cb:	55                   	push   %ebp
f01025cc:	89 e5                	mov    %esp,%ebp
f01025ce:	c7 05 a4 38 5a f0 02 	movl   $0x2,0xf05a38a4
f01025d5:	00 00 00 
f01025d8:	90                   	nop
f01025d9:	5d                   	pop    %ebp
f01025da:	c3                   	ret    

f01025db <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025db:	55                   	push   %ebp
f01025dc:	89 e5                	mov    %esp,%ebp
f01025de:	c7 05 a4 38 5a f0 03 	movl   $0x3,0xf05a38a4
f01025e5:	00 00 00 
f01025e8:	90                   	nop
f01025e9:	5d                   	pop    %ebp
f01025ea:	c3                   	ret    

f01025eb <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025eb:	55                   	push   %ebp
f01025ec:	89 e5                	mov    %esp,%ebp
f01025ee:	c7 05 a4 38 5a f0 04 	movl   $0x4,0xf05a38a4
f01025f5:	00 00 00 
f01025f8:	90                   	nop
f01025f9:	5d                   	pop    %ebp
f01025fa:	c3                   	ret    

f01025fb <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025fb:	55                   	push   %ebp
f01025fc:	89 e5                	mov    %esp,%ebp
f01025fe:	a1 a4 38 5a f0       	mov    0xf05a38a4,%eax
f0102603:	83 f8 01             	cmp    $0x1,%eax
f0102606:	75 04                	jne    f010260c <isUHeapPlacementStrategyFIRSTFIT+0x11>
f0102608:	b0 01                	mov    $0x1,%al
f010260a:	eb 02                	jmp    f010260e <isUHeapPlacementStrategyFIRSTFIT+0x13>
f010260c:	b0 00                	mov    $0x0,%al
f010260e:	5d                   	pop    %ebp
f010260f:	c3                   	ret    

f0102610 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102610:	55                   	push   %ebp
f0102611:	89 e5                	mov    %esp,%ebp
f0102613:	a1 a4 38 5a f0       	mov    0xf05a38a4,%eax
f0102618:	83 f8 02             	cmp    $0x2,%eax
f010261b:	75 04                	jne    f0102621 <isUHeapPlacementStrategyBESTFIT+0x11>
f010261d:	b0 01                	mov    $0x1,%al
f010261f:	eb 02                	jmp    f0102623 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102621:	b0 00                	mov    $0x0,%al
f0102623:	5d                   	pop    %ebp
f0102624:	c3                   	ret    

f0102625 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102625:	55                   	push   %ebp
f0102626:	89 e5                	mov    %esp,%ebp
f0102628:	a1 a4 38 5a f0       	mov    0xf05a38a4,%eax
f010262d:	83 f8 03             	cmp    $0x3,%eax
f0102630:	75 04                	jne    f0102636 <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102632:	b0 01                	mov    $0x1,%al
f0102634:	eb 02                	jmp    f0102638 <isUHeapPlacementStrategyNEXTFIT+0x13>
f0102636:	b0 00                	mov    $0x0,%al
f0102638:	5d                   	pop    %ebp
f0102639:	c3                   	ret    

f010263a <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010263a:	55                   	push   %ebp
f010263b:	89 e5                	mov    %esp,%ebp
f010263d:	a1 a4 38 5a f0       	mov    0xf05a38a4,%eax
f0102642:	83 f8 04             	cmp    $0x4,%eax
f0102645:	75 04                	jne    f010264b <isUHeapPlacementStrategyWORSTFIT+0x11>
f0102647:	b0 01                	mov    $0x1,%al
f0102649:	eb 02                	jmp    f010264d <isUHeapPlacementStrategyWORSTFIT+0x13>
f010264b:	b0 00                	mov    $0x0,%al
f010264d:	5d                   	pop    %ebp
f010264e:	c3                   	ret    

f010264f <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010264f:	55                   	push   %ebp
f0102650:	89 e5                	mov    %esp,%ebp
f0102652:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102655:	8b 45 08             	mov    0x8(%ebp),%eax
f0102658:	c1 e8 0c             	shr    $0xc,%eax
f010265b:	89 c2                	mov    %eax,%edx
f010265d:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0102662:	39 c2                	cmp    %eax,%edx
f0102664:	72 14                	jb     f010267a <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0102666:	83 ec 04             	sub    $0x4,%esp
f0102669:	68 9c 52 12 f0       	push   $0xf012529c
f010266e:	6a 55                	push   $0x55
f0102670:	68 c4 52 12 f0       	push   $0xf01252c4
f0102675:	e8 a0 dc ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f010267a:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f0102680:	8b 45 08             	mov    0x8(%ebp),%eax
f0102683:	c1 e8 0c             	shr    $0xc,%eax
f0102686:	89 c1                	mov    %eax,%ecx
f0102688:	89 c8                	mov    %ecx,%eax
f010268a:	01 c0                	add    %eax,%eax
f010268c:	01 c8                	add    %ecx,%eax
f010268e:	c1 e0 03             	shl    $0x3,%eax
f0102691:	01 d0                	add    %edx,%eax
}
f0102693:	c9                   	leave  
f0102694:	c3                   	ret    

f0102695 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102695:	55                   	push   %ebp
f0102696:	89 e5                	mov    %esp,%ebp
f0102698:	53                   	push   %ebx
f0102699:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f010269c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026a3:	eb 3b                	jmp    f01026e0 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f01026a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026a8:	89 d0                	mov    %edx,%eax
f01026aa:	01 c0                	add    %eax,%eax
f01026ac:	01 d0                	add    %edx,%eax
f01026ae:	c1 e0 03             	shl    $0x3,%eax
f01026b1:	05 44 f5 17 f0       	add    $0xf017f544,%eax
f01026b6:	8b 10                	mov    (%eax),%edx
f01026b8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026bb:	89 c8                	mov    %ecx,%eax
f01026bd:	01 c0                	add    %eax,%eax
f01026bf:	01 c8                	add    %ecx,%eax
f01026c1:	c1 e0 03             	shl    $0x3,%eax
f01026c4:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01026c9:	8b 00                	mov    (%eax),%eax
f01026cb:	83 ec 04             	sub    $0x4,%esp
f01026ce:	52                   	push   %edx
f01026cf:	50                   	push   %eax
f01026d0:	68 47 5b 12 f0       	push   $0xf0125b47
f01026d5:	e8 92 e8 ff ff       	call   f0100f6c <cprintf>
f01026da:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026dd:	ff 45 f4             	incl   -0xc(%ebp)
f01026e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026e3:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01026e8:	39 c2                	cmp    %eax,%edx
f01026ea:	72 b9                	jb     f01026a5 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026ec:	83 ec 0c             	sub    $0xc,%esp
f01026ef:	68 50 5b 12 f0       	push   $0xf0125b50
f01026f4:	e8 73 e8 ff ff       	call   f0100f6c <cprintf>
f01026f9:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102703:	eb 42                	jmp    f0102747 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102705:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f010270b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010270e:	89 d0                	mov    %edx,%eax
f0102710:	01 c0                	add    %eax,%eax
f0102712:	01 d0                	add    %edx,%eax
f0102714:	c1 e0 02             	shl    $0x2,%eax
f0102717:	01 c8                	add    %ecx,%eax
f0102719:	8b 50 04             	mov    0x4(%eax),%edx
f010271c:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f0102722:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102725:	89 c8                	mov    %ecx,%eax
f0102727:	01 c0                	add    %eax,%eax
f0102729:	01 c8                	add    %ecx,%eax
f010272b:	c1 e0 02             	shl    $0x2,%eax
f010272e:	01 d8                	add    %ebx,%eax
f0102730:	8b 00                	mov    (%eax),%eax
f0102732:	83 ec 04             	sub    $0x4,%esp
f0102735:	52                   	push   %edx
f0102736:	50                   	push   %eax
f0102737:	68 65 5b 12 f0       	push   $0xf0125b65
f010273c:	e8 2b e8 ff ff       	call   f0100f6c <cprintf>
f0102741:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102744:	ff 45 f4             	incl   -0xc(%ebp)
f0102747:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010274c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010274f:	7c b4                	jl     f0102705 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102751:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102756:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102759:	c9                   	leave  
f010275a:	c3                   	ret    

f010275b <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010275b:	55                   	push   %ebp
f010275c:	89 e5                	mov    %esp,%ebp
f010275e:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102761:	83 ec 0c             	sub    $0xc,%esp
f0102764:	68 81 5b 12 f0       	push   $0xf0125b81
f0102769:	e8 fe e7 ff ff       	call   f0100f6c <cprintf>
f010276e:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102771:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0102776:	83 ec 04             	sub    $0x4,%esp
f0102779:	50                   	push   %eax
f010277a:	68 0c 00 10 f0       	push   $0xf010000c
f010277f:	68 9c 5b 12 f0       	push   $0xf0125b9c
f0102784:	e8 e3 e7 ff ff       	call   f0100f6c <cprintf>
f0102789:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f010278c:	b8 a1 40 12 00       	mov    $0x1240a1,%eax
f0102791:	83 ec 04             	sub    $0x4,%esp
f0102794:	50                   	push   %eax
f0102795:	68 a1 40 12 f0       	push   $0xf01240a1
f010279a:	68 d8 5b 12 f0       	push   $0xf0125bd8
f010279f:	e8 c8 e7 ff ff       	call   f0100f6c <cprintf>
f01027a4:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f01027a7:	b8 50 01 5a 00       	mov    $0x5a0150,%eax
f01027ac:	83 ec 04             	sub    $0x4,%esp
f01027af:	50                   	push   %eax
f01027b0:	68 50 01 5a f0       	push   $0xf05a0150
f01027b5:	68 14 5c 12 f0       	push   $0xf0125c14
f01027ba:	e8 ad e7 ff ff       	call   f0100f6c <cprintf>
f01027bf:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027c2:	b8 30 64 5c 00       	mov    $0x5c6430,%eax
f01027c7:	83 ec 04             	sub    $0x4,%esp
f01027ca:	50                   	push   %eax
f01027cb:	68 30 64 5c f0       	push   $0xf05c6430
f01027d0:	68 5c 5c 12 f0       	push   $0xf0125c5c
f01027d5:	e8 92 e7 ff ff       	call   f0100f6c <cprintf>
f01027da:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027dd:	b8 30 64 5c f0       	mov    $0xf05c6430,%eax
f01027e2:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027e8:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027ed:	29 c2                	sub    %eax,%edx
f01027ef:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027f1:	85 c0                	test   %eax,%eax
f01027f3:	79 05                	jns    f01027fa <command_kernel_info+0x9f>
f01027f5:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027fa:	c1 f8 0a             	sar    $0xa,%eax
f01027fd:	83 ec 08             	sub    $0x8,%esp
f0102800:	50                   	push   %eax
f0102801:	68 98 5c 12 f0       	push   $0xf0125c98
f0102806:	e8 61 e7 ff ff       	call   f0100f6c <cprintf>
f010280b:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010280e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102813:	c9                   	leave  
f0102814:	c3                   	ret    

f0102815 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102815:	55                   	push   %ebp
f0102816:	89 e5                	mov    %esp,%ebp
f0102818:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010281b:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010281f:	75 37                	jne    f0102858 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102821:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102824:	83 c0 04             	add    $0x4,%eax
f0102827:	8b 00                	mov    (%eax),%eax
f0102829:	83 ec 04             	sub    $0x4,%esp
f010282c:	6a 10                	push   $0x10
f010282e:	6a 00                	push   $0x0
f0102830:	50                   	push   %eax
f0102831:	e8 ff 00 02 00       	call   f0122935 <strtol>
f0102836:	83 c4 10             	add    $0x10,%esp
f0102839:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010283c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010283f:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102842:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102845:	83 c0 08             	add    $0x8,%eax
f0102848:	8b 00                	mov    (%eax),%eax
f010284a:	8a 00                	mov    (%eax),%al
f010284c:	88 c2                	mov    %al,%dl
f010284e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102851:	88 10                	mov    %dl,(%eax)
f0102853:	e9 b9 00 00 00       	jmp    f0102911 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0102858:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010285c:	0f 85 9f 00 00 00    	jne    f0102901 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102862:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102865:	83 c0 04             	add    $0x4,%eax
f0102868:	8b 00                	mov    (%eax),%eax
f010286a:	83 ec 04             	sub    $0x4,%esp
f010286d:	6a 0a                	push   $0xa
f010286f:	6a 00                	push   $0x0
f0102871:	50                   	push   %eax
f0102872:	e8 be 00 02 00       	call   f0122935 <strtol>
f0102877:	83 c4 10             	add    $0x10,%esp
f010287a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f010287d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102884:	83 ec 04             	sub    $0x4,%esp
f0102887:	6a 00                	push   $0x0
f0102889:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010288c:	50                   	push   %eax
f010288d:	ff 75 f4             	pushl  -0xc(%ebp)
f0102890:	e8 2b 7f 00 00       	call   f010a7c0 <envid2env>
f0102895:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102898:	8b 45 0c             	mov    0xc(%ebp),%eax
f010289b:	83 c0 08             	add    $0x8,%eax
f010289e:	8b 00                	mov    (%eax),%eax
f01028a0:	83 ec 04             	sub    $0x4,%esp
f01028a3:	6a 10                	push   $0x10
f01028a5:	6a 00                	push   $0x0
f01028a7:	50                   	push   %eax
f01028a8:	e8 88 00 02 00       	call   f0122935 <strtol>
f01028ad:	83 c4 10             	add    $0x10,%esp
f01028b0:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028b3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028b6:	85 c0                	test   %eax,%eax
f01028b8:	75 07                	jne    f01028c1 <command_writeusermem+0xac>
f01028ba:	b8 00 00 00 00       	mov    $0x0,%eax
f01028bf:	eb 55                	jmp    f0102916 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028c1:	0f 20 d8             	mov    %cr3,%eax
f01028c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028c7:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028d0:	8b 40 68             	mov    0x68(%eax),%eax
f01028d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028d9:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028df:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028e5:	83 c0 0c             	add    $0xc,%eax
f01028e8:	8b 00                	mov    (%eax),%eax
f01028ea:	8a 00                	mov    (%eax),%al
f01028ec:	88 c2                	mov    %al,%dl
f01028ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028f1:	88 10                	mov    %dl,(%eax)
f01028f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028f6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028fc:	0f 22 d8             	mov    %eax,%cr3
f01028ff:	eb 10                	jmp    f0102911 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f0102901:	83 ec 0c             	sub    $0xc,%esp
f0102904:	68 c4 5c 12 f0       	push   $0xf0125cc4
f0102909:	e8 5e e6 ff ff       	call   f0100f6c <cprintf>
f010290e:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102911:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102916:	c9                   	leave  
f0102917:	c3                   	ret    

f0102918 <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f0102918:	55                   	push   %ebp
f0102919:	89 e5                	mov    %esp,%ebp
f010291b:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f010291e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102921:	83 c0 04             	add    $0x4,%eax
f0102924:	8b 00                	mov    (%eax),%eax
f0102926:	83 ec 04             	sub    $0x4,%esp
f0102929:	6a 10                	push   $0x10
f010292b:	6a 00                	push   $0x0
f010292d:	50                   	push   %eax
f010292e:	e8 02 00 02 00       	call   f0122935 <strtol>
f0102933:	83 c4 10             	add    $0x10,%esp
f0102936:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010293b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f010293e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102945:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102948:	83 c0 08             	add    $0x8,%eax
f010294b:	8b 00                	mov    (%eax),%eax
f010294d:	83 ec 0c             	sub    $0xc,%esp
f0102950:	50                   	push   %eax
f0102951:	e8 7f fc 01 00       	call   f01225d5 <strlen>
f0102956:	83 c4 10             	add    $0x10,%esp
f0102959:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f010295c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102963:	eb 1c                	jmp    f0102981 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102965:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102968:	83 c0 08             	add    $0x8,%eax
f010296b:	8b 10                	mov    (%eax),%edx
f010296d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102970:	01 d0                	add    %edx,%eax
f0102972:	8a 00                	mov    (%eax),%al
f0102974:	88 c2                	mov    %al,%dl
f0102976:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102979:	88 10                	mov    %dl,(%eax)
		address++;
f010297b:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f010297e:	ff 45 f0             	incl   -0x10(%ebp)
f0102981:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102984:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0102987:	7c dc                	jl     f0102965 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f0102989:	b8 00 00 00 00       	mov    $0x0,%eax


}
f010298e:	c9                   	leave  
f010298f:	c3                   	ret    

f0102990 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102990:	55                   	push   %ebp
f0102991:	89 e5                	mov    %esp,%ebp
f0102993:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f0102996:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010299a:	75 42                	jne    f01029de <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010299c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010299f:	83 c0 04             	add    $0x4,%eax
f01029a2:	8b 00                	mov    (%eax),%eax
f01029a4:	83 ec 04             	sub    $0x4,%esp
f01029a7:	6a 10                	push   $0x10
f01029a9:	6a 00                	push   $0x0
f01029ab:	50                   	push   %eax
f01029ac:	e8 84 ff 01 00       	call   f0122935 <strtol>
f01029b1:	83 c4 10             	add    $0x10,%esp
f01029b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ba:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029bd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029c0:	8a 00                	mov    (%eax),%al
f01029c2:	0f b6 c0             	movzbl %al,%eax
f01029c5:	83 ec 04             	sub    $0x4,%esp
f01029c8:	50                   	push   %eax
f01029c9:	ff 75 d8             	pushl  -0x28(%ebp)
f01029cc:	68 ee 5c 12 f0       	push   $0xf0125cee
f01029d1:	e8 96 e5 ff ff       	call   f0100f6c <cprintf>
f01029d6:	83 c4 10             	add    $0x10,%esp
f01029d9:	e9 c4 00 00 00       	jmp    f0102aa2 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029de:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029e2:	0f 85 aa 00 00 00    	jne    f0102a92 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029eb:	83 c0 04             	add    $0x4,%eax
f01029ee:	8b 00                	mov    (%eax),%eax
f01029f0:	83 ec 04             	sub    $0x4,%esp
f01029f3:	6a 0a                	push   $0xa
f01029f5:	6a 00                	push   $0x0
f01029f7:	50                   	push   %eax
f01029f8:	e8 38 ff 01 00       	call   f0122935 <strtol>
f01029fd:	83 c4 10             	add    $0x10,%esp
f0102a00:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102a03:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102a0a:	83 ec 04             	sub    $0x4,%esp
f0102a0d:	6a 00                	push   $0x0
f0102a0f:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a12:	50                   	push   %eax
f0102a13:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a16:	e8 a5 7d 00 00       	call   f010a7c0 <envid2env>
f0102a1b:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a21:	83 c0 08             	add    $0x8,%eax
f0102a24:	8b 00                	mov    (%eax),%eax
f0102a26:	83 ec 04             	sub    $0x4,%esp
f0102a29:	6a 10                	push   $0x10
f0102a2b:	6a 00                	push   $0x0
f0102a2d:	50                   	push   %eax
f0102a2e:	e8 02 ff 01 00       	call   f0122935 <strtol>
f0102a33:	83 c4 10             	add    $0x10,%esp
f0102a36:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a39:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a3c:	85 c0                	test   %eax,%eax
f0102a3e:	75 07                	jne    f0102a47 <command_readusermem+0xb7>
f0102a40:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a45:	eb 60                	jmp    f0102aa7 <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a47:	0f 20 d8             	mov    %cr3,%eax
f0102a4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a4d:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a50:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a53:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a56:	8b 40 68             	mov    0x68(%eax),%eax
f0102a59:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a5f:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a62:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a65:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a6b:	8a 00                	mov    (%eax),%al
f0102a6d:	0f b6 c0             	movzbl %al,%eax
f0102a70:	83 ec 04             	sub    $0x4,%esp
f0102a73:	50                   	push   %eax
f0102a74:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a77:	68 ee 5c 12 f0       	push   $0xf0125cee
f0102a7c:	e8 eb e4 ff ff       	call   f0100f6c <cprintf>
f0102a81:	83 c4 10             	add    $0x10,%esp
f0102a84:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a87:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a8d:	0f 22 d8             	mov    %eax,%cr3
f0102a90:	eb 10                	jmp    f0102aa2 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a92:	83 ec 0c             	sub    $0xc,%esp
f0102a95:	68 08 5d 12 f0       	push   $0xf0125d08
f0102a9a:	e8 cd e4 ff ff       	call   f0100f6c <cprintf>
f0102a9f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102aa2:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102aa7:	c9                   	leave  
f0102aa8:	c3                   	ret    

f0102aa9 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102aa9:	55                   	push   %ebp
f0102aaa:	89 e5                	mov    %esp,%ebp
f0102aac:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aaf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ab2:	83 c0 04             	add    $0x4,%eax
f0102ab5:	8b 00                	mov    (%eax),%eax
f0102ab7:	83 ec 04             	sub    $0x4,%esp
f0102aba:	6a 10                	push   $0x10
f0102abc:	6a 00                	push   $0x0
f0102abe:	50                   	push   %eax
f0102abf:	e8 71 fe 01 00       	call   f0122935 <strtol>
f0102ac4:	83 c4 10             	add    $0x10,%esp
f0102ac7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102acc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102acf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102ad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ad9:	8a 00                	mov    (%eax),%al
f0102adb:	0f b6 c0             	movzbl %al,%eax
f0102ade:	83 ec 08             	sub    $0x8,%esp
f0102ae1:	50                   	push   %eax
f0102ae2:	68 32 5d 12 f0       	push   $0xf0125d32
f0102ae7:	e8 80 e4 ff ff       	call   f0100f6c <cprintf>
f0102aec:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102aef:	83 ec 0c             	sub    $0xc,%esp
f0102af2:	68 35 5d 12 f0       	push   $0xf0125d35
f0102af7:	e8 70 e4 ff ff       	call   f0100f6c <cprintf>
f0102afc:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102aff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102b04:	c9                   	leave  
f0102b05:	c3                   	ret    

f0102b06 <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102b06:	55                   	push   %ebp
f0102b07:	89 e5                	mov    %esp,%ebp
f0102b09:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b0f:	83 c0 04             	add    $0x4,%eax
f0102b12:	8b 00                	mov    (%eax),%eax
f0102b14:	83 ec 04             	sub    $0x4,%esp
f0102b17:	6a 0a                	push   $0xa
f0102b19:	6a 00                	push   $0x0
f0102b1b:	50                   	push   %eax
f0102b1c:	e8 14 fe 01 00       	call   f0122935 <strtol>
f0102b21:	83 c4 10             	add    $0x10,%esp
f0102b24:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b27:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b2e:	83 ec 04             	sub    $0x4,%esp
f0102b31:	6a 00                	push   $0x0
f0102b33:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b36:	50                   	push   %eax
f0102b37:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b3a:	e8 81 7c 00 00       	call   f010a7c0 <envid2env>
f0102b3f:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b45:	83 c0 08             	add    $0x8,%eax
f0102b48:	8b 00                	mov    (%eax),%eax
f0102b4a:	83 ec 04             	sub    $0x4,%esp
f0102b4d:	6a 10                	push   $0x10
f0102b4f:	6a 00                	push   $0x0
f0102b51:	50                   	push   %eax
f0102b52:	e8 de fd 01 00       	call   f0122935 <strtol>
f0102b57:	83 c4 10             	add    $0x10,%esp
f0102b5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b5d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b60:	83 c0 0c             	add    $0xc,%eax
f0102b63:	8b 00                	mov    (%eax),%eax
f0102b65:	83 ec 04             	sub    $0x4,%esp
f0102b68:	6a 0a                	push   $0xa
f0102b6a:	6a 00                	push   $0x0
f0102b6c:	50                   	push   %eax
f0102b6d:	e8 c3 fd 01 00       	call   f0122935 <strtol>
f0102b72:	83 c4 10             	add    $0x10,%esp
f0102b75:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b78:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b7e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b81:	85 c0                	test   %eax,%eax
f0102b83:	75 07                	jne    f0102b8c <command_readuserblock+0x86>
f0102b85:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b8a:	eb 65                	jmp    f0102bf1 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b8c:	0f 20 d8             	mov    %cr3,%eax
f0102b8f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b92:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b95:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b98:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b9b:	8b 40 68             	mov    0x68(%eax),%eax
f0102b9e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102ba1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102ba4:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102ba7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102bae:	eb 28                	jmp    f0102bd8 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102bb3:	8a 00                	mov    (%eax),%al
f0102bb5:	0f b6 d0             	movzbl %al,%edx
f0102bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102bbb:	8a 00                	mov    (%eax),%al
f0102bbd:	0f b6 c0             	movzbl %al,%eax
f0102bc0:	52                   	push   %edx
f0102bc1:	50                   	push   %eax
f0102bc2:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bc5:	68 37 5d 12 f0       	push   $0xf0125d37
f0102bca:	e8 9d e3 ff ff       	call   f0100f6c <cprintf>
f0102bcf:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bd2:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bd5:	ff 45 f0             	incl   -0x10(%ebp)
f0102bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bdb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bde:	7c d0                	jl     f0102bb0 <command_readuserblock+0xaa>
f0102be0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102be3:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102be6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102be9:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102bec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102bf1:	c9                   	leave  
f0102bf2:	c3                   	ret    

f0102bf3 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102bf3:	55                   	push   %ebp
f0102bf4:	89 e5                	mov    %esp,%ebp
f0102bf6:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bf9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bfc:	83 c0 04             	add    $0x4,%eax
f0102bff:	8b 00                	mov    (%eax),%eax
f0102c01:	83 ec 04             	sub    $0x4,%esp
f0102c04:	6a 0a                	push   $0xa
f0102c06:	6a 00                	push   $0x0
f0102c08:	50                   	push   %eax
f0102c09:	e8 27 fd 01 00       	call   f0122935 <strtol>
f0102c0e:	83 c4 10             	add    $0x10,%esp
f0102c11:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c14:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c1b:	83 ec 04             	sub    $0x4,%esp
f0102c1e:	6a 00                	push   $0x0
f0102c20:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c23:	50                   	push   %eax
f0102c24:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c27:	e8 94 7b 00 00       	call   f010a7c0 <envid2env>
f0102c2c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c2f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c32:	85 c0                	test   %eax,%eax
f0102c34:	75 0a                	jne    f0102c40 <command_remove_table+0x4d>
f0102c36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c3b:	e9 a1 00 00 00       	jmp    f0102ce1 <command_remove_table+0xee>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c43:	83 c0 08             	add    $0x8,%eax
f0102c46:	8b 00                	mov    (%eax),%eax
f0102c48:	83 ec 04             	sub    $0x4,%esp
f0102c4b:	6a 10                	push   $0x10
f0102c4d:	6a 00                	push   $0x0
f0102c4f:	50                   	push   %eax
f0102c50:	e8 e0 fc 01 00       	call   f0122935 <strtol>
f0102c55:	83 c4 10             	add    $0x10,%esp
f0102c58:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c61:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c64:	8b 40 64             	mov    0x64(%eax),%eax
f0102c67:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c6a:	c1 ea 16             	shr    $0x16,%edx
f0102c6d:	c1 e2 02             	shl    $0x2,%edx
f0102c70:	01 d0                	add    %edx,%eax
f0102c72:	8b 00                	mov    (%eax),%eax
f0102c74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c79:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree((void*)kheap_virtual_address(table_pa));
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c7c:	83 ec 0c             	sub    $0xc,%esp
f0102c7f:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c82:	e8 c8 f9 ff ff       	call   f010264f <to_frame_info>
f0102c87:	83 c4 10             	add    $0x10,%esp
f0102c8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102c8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102c90:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102c9c:	e8 83 56 00 00       	call   f0108324 <free_frame>
f0102ca1:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102ca4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102ca7:	c1 e8 16             	shr    $0x16,%eax
f0102caa:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cad:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cb0:	8b 40 64             	mov    0x64(%eax),%eax
f0102cb3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cb6:	c1 e2 02             	shl    $0x2,%edx
f0102cb9:	01 c2                	add    %eax,%edx
f0102cbb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cbe:	8b 40 64             	mov    0x64(%eax),%eax
f0102cc1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cc4:	c1 e1 02             	shl    $0x2,%ecx
f0102cc7:	01 c8                	add    %ecx,%eax
f0102cc9:	8b 00                	mov    (%eax),%eax
f0102ccb:	83 e0 fe             	and    $0xfffffffe,%eax
f0102cce:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cd0:	0f 20 d8             	mov    %cr3,%eax
f0102cd3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cd9:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cdc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ce1:	c9                   	leave  
f0102ce2:	c3                   	ret    

f0102ce3 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102ce3:	55                   	push   %ebp
f0102ce4:	89 e5                	mov    %esp,%ebp
f0102ce6:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102ce9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102ced:	7e 06                	jle    f0102cf5 <command_allocuserpage+0x12>
f0102cef:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102cf3:	7e 1a                	jle    f0102d0f <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102cf5:	83 ec 0c             	sub    $0xc,%esp
f0102cf8:	68 48 5d 12 f0       	push   $0xf0125d48
f0102cfd:	e8 6a e2 ff ff       	call   f0100f6c <cprintf>
f0102d02:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d05:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d0a:	e9 46 01 00 00       	jmp    f0102e55 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d12:	83 c0 04             	add    $0x4,%eax
f0102d15:	8b 00                	mov    (%eax),%eax
f0102d17:	83 ec 04             	sub    $0x4,%esp
f0102d1a:	6a 0a                	push   $0xa
f0102d1c:	6a 00                	push   $0x0
f0102d1e:	50                   	push   %eax
f0102d1f:	e8 11 fc 01 00       	call   f0122935 <strtol>
f0102d24:	83 c4 10             	add    $0x10,%esp
f0102d27:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d2a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 00                	push   $0x0
f0102d36:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d39:	50                   	push   %eax
f0102d3a:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d3d:	e8 7e 7a 00 00       	call   f010a7c0 <envid2env>
f0102d42:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d48:	85 c0                	test   %eax,%eax
f0102d4a:	75 0a                	jne    f0102d56 <command_allocuserpage+0x73>
f0102d4c:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d51:	e9 ff 00 00 00       	jmp    f0102e55 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d56:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d59:	83 c0 08             	add    $0x8,%eax
f0102d5c:	8b 00                	mov    (%eax),%eax
f0102d5e:	83 ec 04             	sub    $0x4,%esp
f0102d61:	6a 10                	push   $0x10
f0102d63:	6a 00                	push   $0x0
f0102d65:	50                   	push   %eax
f0102d66:	e8 ca fb 01 00       	call   f0122935 <strtol>
f0102d6b:	83 c4 10             	add    $0x10,%esp
f0102d6e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d71:	83 ec 0c             	sub    $0xc,%esp
f0102d74:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d77:	50                   	push   %eax
f0102d78:	e8 53 54 00 00       	call   f01081d0 <allocate_frame>
f0102d7d:	83 c4 10             	add    $0x10,%esp
f0102d80:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d83:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102d87:	75 1a                	jne    f0102da3 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102d89:	83 ec 0c             	sub    $0xc,%esp
f0102d8c:	68 72 5d 12 f0       	push   $0xf0125d72
f0102d91:	e8 d6 e1 ff ff       	call   f0100f6c <cprintf>
f0102d96:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d99:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d9e:	e9 b2 00 00 00       	jmp    f0102e55 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102da3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102da7:	75 1d                	jne    f0102dc6 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102da9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102daf:	8b 40 64             	mov    0x64(%eax),%eax
f0102db2:	6a 06                	push   $0x6
f0102db4:	ff 75 ec             	pushl  -0x14(%ebp)
f0102db7:	52                   	push   %edx
f0102db8:	50                   	push   %eax
f0102db9:	e8 28 58 00 00       	call   f01085e6 <map_frame>
f0102dbe:	83 c4 10             	add    $0x10,%esp
f0102dc1:	e9 8a 00 00 00       	jmp    f0102e50 <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102dc6:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102dca:	0f 85 80 00 00 00    	jne    f0102e50 <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dd0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dd3:	83 c0 0c             	add    $0xc,%eax
f0102dd6:	8b 00                	mov    (%eax),%eax
f0102dd8:	8a 00                	mov    (%eax),%al
f0102dda:	3c 72                	cmp    $0x72,%al
f0102ddc:	74 0e                	je     f0102dec <command_allocuserpage+0x109>
f0102dde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102de1:	83 c0 0c             	add    $0xc,%eax
f0102de4:	8b 00                	mov    (%eax),%eax
f0102de6:	8a 00                	mov    (%eax),%al
f0102de8:	3c 52                	cmp    $0x52,%al
f0102dea:	75 09                	jne    f0102df5 <command_allocuserpage+0x112>
			rw = 0 ;
f0102dec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102df3:	eb 3c                	jmp    f0102e31 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102df5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102df8:	83 c0 0c             	add    $0xc,%eax
f0102dfb:	8b 00                	mov    (%eax),%eax
f0102dfd:	8a 00                	mov    (%eax),%al
f0102dff:	3c 77                	cmp    $0x77,%al
f0102e01:	74 0e                	je     f0102e11 <command_allocuserpage+0x12e>
f0102e03:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e06:	83 c0 0c             	add    $0xc,%eax
f0102e09:	8b 00                	mov    (%eax),%eax
f0102e0b:	8a 00                	mov    (%eax),%al
f0102e0d:	3c 57                	cmp    $0x57,%al
f0102e0f:	75 09                	jne    f0102e1a <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e11:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e18:	eb 17                	jmp    f0102e31 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e1a:	83 ec 0c             	sub    $0xc,%esp
f0102e1d:	68 8c 5d 12 f0       	push   $0xf0125d8c
f0102e22:	e8 45 e1 ff ff       	call   f0100f6c <cprintf>
f0102e27:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e2a:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e34:	83 c8 04             	or     $0x4,%eax
f0102e37:	89 c1                	mov    %eax,%ecx
f0102e39:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e3f:	8b 40 64             	mov    0x64(%eax),%eax
f0102e42:	51                   	push   %ecx
f0102e43:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e46:	52                   	push   %edx
f0102e47:	50                   	push   %eax
f0102e48:	e8 99 57 00 00       	call   f01085e6 <map_frame>
f0102e4d:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e50:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e55:	c9                   	leave  
f0102e56:	c3                   	ret    

f0102e57 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e57:	55                   	push   %ebp
f0102e58:	89 e5                	mov    %esp,%ebp
f0102e5a:	56                   	push   %esi
f0102e5b:	53                   	push   %ebx
f0102e5c:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e5f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e62:	83 ec 0c             	sub    $0xc,%esp
f0102e65:	50                   	push   %eax
f0102e66:	e8 33 5a 00 00       	call   f010889e <calculate_available_frames>
f0102e6b:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e6e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e71:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e74:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e77:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e7a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e7d:	01 de                	add    %ebx,%esi
f0102e7f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e82:	01 f3                	add    %esi,%ebx
f0102e84:	83 ec 0c             	sub    $0xc,%esp
f0102e87:	51                   	push   %ecx
f0102e88:	52                   	push   %edx
f0102e89:	50                   	push   %eax
f0102e8a:	53                   	push   %ebx
f0102e8b:	68 d0 5d 12 f0       	push   $0xf0125dd0
f0102e90:	e8 d7 e0 ff ff       	call   f0100f6c <cprintf>
f0102e95:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102e98:	a1 70 3a 5a f0       	mov    0xf05a3a70,%eax
f0102e9d:	83 ec 08             	sub    $0x8,%esp
f0102ea0:	50                   	push   %eax
f0102ea1:	68 28 5e 12 f0       	push   $0xf0125e28
f0102ea6:	e8 c1 e0 ff ff       	call   f0100f6c <cprintf>
f0102eab:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102eae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102eb3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102eb6:	5b                   	pop    %ebx
f0102eb7:	5e                   	pop    %esi
f0102eb8:	5d                   	pop    %ebp
f0102eb9:	c3                   	ret    

f0102eba <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102eba:	55                   	push   %ebp
f0102ebb:	89 e5                	mov    %esp,%ebp
f0102ebd:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102ec0:	c7 45 ec 88 13 00 00 	movl   $0x1388,-0x14(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ec7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ece:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102ed5:	c7 45 e8 9c ff ff ff 	movl   $0xffffff9c,-0x18(%ebp)
//			assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
//		}
	}
#else
	{
		switch (number_of_arguments)
f0102edc:	8b 45 08             	mov    0x8(%ebp),%eax
f0102edf:	83 f8 02             	cmp    $0x2,%eax
f0102ee2:	74 3c                	je     f0102f20 <CreateEnv+0x66>
f0102ee4:	83 f8 03             	cmp    $0x3,%eax
f0102ee7:	75 1d                	jne    f0102f06 <CreateEnv+0x4c>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
f0102ee9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102eec:	83 c0 08             	add    $0x8,%eax
f0102eef:	8b 00                	mov    (%eax),%eax
f0102ef1:	83 ec 04             	sub    $0x4,%esp
f0102ef4:	6a 0a                	push   $0xa
f0102ef6:	6a 00                	push   $0x0
f0102ef8:	50                   	push   %eax
f0102ef9:	e8 37 fa 01 00       	call   f0122935 <strtol>
f0102efe:	83 c4 10             	add    $0x10,%esp
f0102f01:	89 45 f0             	mov    %eax,-0x10(%ebp)
			break;
f0102f04:	eb 1b                	jmp    f0102f21 <CreateEnv+0x67>
		case 2:
			break;
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0102f06:	83 ec 0c             	sub    $0xc,%esp
f0102f09:	68 64 5e 12 f0       	push   $0xf0125e64
f0102f0e:	e8 59 e0 ff ff       	call   f0100f6c <cprintf>
f0102f13:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0102f16:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f1b:	e9 a7 00 00 00       	jmp    f0102fc7 <CreateEnv+0x10d>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
			break;
		case 2:
			break;
f0102f20:	90                   	nop
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
			return NULL;

			break;
		}
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f21:	83 ec 0c             	sub    $0xc,%esp
f0102f24:	6a 02                	push   $0x2
f0102f26:	e8 e5 b7 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f0102f2b:	83 c4 10             	add    $0x10,%esp
f0102f2e:	85 c0                	test   %eax,%eax
f0102f30:	74 07                	je     f0102f39 <CreateEnv+0x7f>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
f0102f32:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%ebp)
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0102f39:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
f0102f3d:	76 19                	jbe    f0102f58 <CreateEnv+0x9e>
f0102f3f:	68 d4 5e 12 f0       	push   $0xf0125ed4
f0102f44:	68 19 5f 12 f0       	push   $0xf0125f19
f0102f49:	68 c0 01 00 00       	push   $0x1c0
f0102f4e:	68 2e 5f 12 f0       	push   $0xf0125f2e
f0102f53:	e8 c2 d3 ff ff       	call   f010031a <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0102f58:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5b:	83 c0 04             	add    $0x4,%eax
f0102f5e:	8b 00                	mov    (%eax),%eax
f0102f60:	ff 75 f0             	pushl  -0x10(%ebp)
f0102f63:	ff 75 f4             	pushl  -0xc(%ebp)
f0102f66:	ff 75 ec             	pushl  -0x14(%ebp)
f0102f69:	50                   	push   %eax
f0102f6a:	e8 01 6b 00 00       	call   f0109a70 <env_create>
f0102f6f:	83 c4 10             	add    $0x10,%esp
f0102f72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f0102f75:	83 7d e8 9c          	cmpl   $0xffffff9c,-0x18(%ebp)
f0102f79:	74 49                	je     f0102fc4 <CreateEnv+0x10a>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0102f7b:	83 ec 08             	sub    $0x8,%esp
f0102f7e:	ff 75 e8             	pushl  -0x18(%ebp)
f0102f81:	68 42 5f 12 f0       	push   $0xf0125f42
f0102f86:	e8 e1 df ff ff       	call   f0100f6c <cprintf>
f0102f8b:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0102f8e:	83 7d e8 ec          	cmpl   $0xffffffec,-0x18(%ebp)
f0102f92:	7c 06                	jl     f0102f9a <CreateEnv+0xe0>
f0102f94:	83 7d e8 14          	cmpl   $0x14,-0x18(%ebp)
f0102f98:	7e 19                	jle    f0102fb3 <CreateEnv+0xf9>
f0102f9a:	68 54 5f 12 f0       	push   $0xf0125f54
f0102f9f:	68 19 5f 12 f0       	push   $0xf0125f19
f0102fa4:	68 c5 01 00 00       	push   $0x1c5
f0102fa9:	68 2e 5f 12 f0       	push   $0xf0125f2e
f0102fae:	e8 67 d3 ff ff       	call   f010031a <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0102fb3:	83 ec 08             	sub    $0x8,%esp
f0102fb6:	ff 75 e8             	pushl  -0x18(%ebp)
f0102fb9:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102fbc:	e8 e6 36 00 00       	call   f01066a7 <env_set_nice>
f0102fc1:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f0102fc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0102fc7:	c9                   	leave  
f0102fc8:	c3                   	ret    

f0102fc9 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0102fc9:	55                   	push   %ebp
f0102fca:	89 e5                	mov    %esp,%ebp
f0102fcc:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0102fcf:	83 ec 08             	sub    $0x8,%esp
f0102fd2:	ff 75 0c             	pushl  0xc(%ebp)
f0102fd5:	ff 75 08             	pushl  0x8(%ebp)
f0102fd8:	e8 dd fe ff ff       	call   f0102eba <CreateEnv>
f0102fdd:	83 c4 10             	add    $0x10,%esp
f0102fe0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0102fe3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102fe7:	75 07                	jne    f0102ff0 <command_run_program+0x27>
f0102fe9:	b8 00 00 00 00       	mov    $0x0,%eax
f0102fee:	eb 46                	jmp    f0103036 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0102ff0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ff3:	8b 40 10             	mov    0x10(%eax),%eax
f0102ff6:	83 ec 08             	sub    $0x8,%esp
f0102ff9:	50                   	push   %eax
f0102ffa:	68 84 5f 12 f0       	push   $0xf0125f84
f0102fff:	e8 68 df ff ff       	call   f0100f6c <cprintf>
f0103004:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103007:	83 ec 0c             	sub    $0xc,%esp
f010300a:	ff 75 f4             	pushl  -0xc(%ebp)
f010300d:	e8 93 26 00 00       	call   f01056a5 <sched_new_env>
f0103012:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103015:	c7 05 70 3a 5a f0 00 	movl   $0x0,0xf05a3a70
f010301c:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f010301f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103022:	8b 40 10             	mov    0x10(%eax),%eax
f0103025:	83 ec 0c             	sub    $0xc,%esp
f0103028:	50                   	push   %eax
f0103029:	e8 cd 26 00 00       	call   f01056fb <sched_run_env>
f010302e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103031:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103036:	c9                   	leave  
f0103037:	c3                   	ret    

f0103038 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103038:	55                   	push   %ebp
f0103039:	89 e5                	mov    %esp,%ebp
f010303b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010303e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103041:	83 c0 04             	add    $0x4,%eax
f0103044:	8b 00                	mov    (%eax),%eax
f0103046:	83 ec 04             	sub    $0x4,%esp
f0103049:	6a 0a                	push   $0xa
f010304b:	6a 00                	push   $0x0
f010304d:	50                   	push   %eax
f010304e:	e8 e2 f8 01 00       	call   f0122935 <strtol>
f0103053:	83 c4 10             	add    $0x10,%esp
f0103056:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103059:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010305c:	83 ec 0c             	sub    $0xc,%esp
f010305f:	50                   	push   %eax
f0103060:	e8 fe 29 00 00       	call   f0105a63 <sched_kill_env>
f0103065:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103068:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010306d:	c9                   	leave  
f010306e:	c3                   	ret    

f010306f <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f010306f:	55                   	push   %ebp
f0103070:	89 e5                	mov    %esp,%ebp
f0103072:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103075:	83 ec 08             	sub    $0x8,%esp
f0103078:	ff 75 0c             	pushl  0xc(%ebp)
f010307b:	ff 75 08             	pushl  0x8(%ebp)
f010307e:	e8 37 fe ff ff       	call   f0102eba <CreateEnv>
f0103083:	83 c4 10             	add    $0x10,%esp
f0103086:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103089:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010308d:	75 07                	jne    f0103096 <commnad_load_env+0x27>
		return 0 ;
f010308f:	b8 00 00 00 00       	mov    $0x0,%eax
f0103094:	eb 2a                	jmp    f01030c0 <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103096:	83 ec 0c             	sub    $0xc,%esp
f0103099:	ff 75 f4             	pushl  -0xc(%ebp)
f010309c:	e8 04 26 00 00       	call   f01056a5 <sched_new_env>
f01030a1:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f01030a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030a7:	8b 40 10             	mov    0x10(%eax),%eax
f01030aa:	83 ec 08             	sub    $0x8,%esp
f01030ad:	50                   	push   %eax
f01030ae:	68 84 5f 12 f0       	push   $0xf0125f84
f01030b3:	e8 b4 de ff ff       	call   f0100f6c <cprintf>
f01030b8:	83 c4 10             	add    $0x10,%esp
	return 0;
f01030bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030c0:	c9                   	leave  
f01030c1:	c3                   	ret    

f01030c2 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f01030c2:	55                   	push   %ebp
f01030c3:	89 e5                	mov    %esp,%ebp
f01030c5:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f01030c8:	c7 05 70 3a 5a f0 00 	movl   $0x0,0xf05a3a70
f01030cf:	00 00 00 
	sched_run_all();
f01030d2:	e8 7b 2f 00 00       	call   f0106052 <sched_run_all>

	return 0 ;
f01030d7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030dc:	c9                   	leave  
f01030dd:	c3                   	ret    

f01030de <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01030de:	55                   	push   %ebp
f01030df:	89 e5                	mov    %esp,%ebp
f01030e1:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01030e4:	e8 38 2d 00 00       	call   f0105e21 <sched_print_all>

	return 0 ;
f01030e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030ee:	c9                   	leave  
f01030ef:	c3                   	ret    

f01030f0 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01030f0:	55                   	push   %ebp
f01030f1:	89 e5                	mov    %esp,%ebp
f01030f3:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01030f6:	e8 ec 2f 00 00       	call   f01060e7 <sched_kill_all>

	return 0 ;
f01030fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103100:	c9                   	leave  
f0103101:	c3                   	ret    

f0103102 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0103102:	55                   	push   %ebp
f0103103:	89 e5                	mov    %esp,%ebp
f0103105:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103108:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010310c:	7f 1a                	jg     f0103128 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010310e:	83 ec 0c             	sub    $0xc,%esp
f0103111:	68 9c 5f 12 f0       	push   $0xf0125f9c
f0103116:	e8 51 de ff ff       	call   f0100f6c <cprintf>
f010311b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010311e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103123:	e9 83 00 00 00       	jmp    f01031ab <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103128:	8b 45 0c             	mov    0xc(%ebp),%eax
f010312b:	83 c0 04             	add    $0x4,%eax
f010312e:	8b 00                	mov    (%eax),%eax
f0103130:	83 ec 04             	sub    $0x4,%esp
f0103133:	6a 0a                	push   $0xa
f0103135:	6a 00                	push   $0x0
f0103137:	50                   	push   %eax
f0103138:	e8 f8 f7 01 00       	call   f0122935 <strtol>
f010313d:	83 c4 10             	add    $0x10,%esp
f0103140:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0103143:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103147:	75 20                	jne    f0103169 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103149:	83 ec 0c             	sub    $0xc,%esp
f010314c:	ff 75 f4             	pushl  -0xc(%ebp)
f010314f:	e8 31 b5 00 00       	call   f010e685 <setPageReplacmentAlgorithmLRU>
f0103154:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103157:	83 ec 0c             	sub    $0xc,%esp
f010315a:	68 fc 5f 12 f0       	push   $0xf0125ffc
f010315f:	e8 08 de ff ff       	call   f0100f6c <cprintf>
f0103164:	83 c4 10             	add    $0x10,%esp
f0103167:	eb 3d                	jmp    f01031a6 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103169:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010316d:	75 20                	jne    f010318f <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010316f:	83 ec 0c             	sub    $0xc,%esp
f0103172:	ff 75 f4             	pushl  -0xc(%ebp)
f0103175:	e8 0b b5 00 00       	call   f010e685 <setPageReplacmentAlgorithmLRU>
f010317a:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f010317d:	83 ec 0c             	sub    $0xc,%esp
f0103180:	68 40 60 12 f0       	push   $0xf0126040
f0103185:	e8 e2 dd ff ff       	call   f0100f6c <cprintf>
f010318a:	83 c4 10             	add    $0x10,%esp
f010318d:	eb 17                	jmp    f01031a6 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010318f:	83 ec 0c             	sub    $0xc,%esp
f0103192:	68 80 60 12 f0       	push   $0xf0126080
f0103197:	e8 d0 dd ff ff       	call   f0100f6c <cprintf>
f010319c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010319f:	b8 00 00 00 00       	mov    $0x0,%eax
f01031a4:	eb 05                	jmp    f01031ab <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f01031a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ab:	c9                   	leave  
f01031ac:	c3                   	ret    

f01031ad <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f01031ad:	55                   	push   %ebp
f01031ae:	89 e5                	mov    %esp,%ebp
f01031b0:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f01031b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b6:	83 c0 04             	add    $0x4,%eax
f01031b9:	8b 00                	mov    (%eax),%eax
f01031bb:	83 ec 04             	sub    $0x4,%esp
f01031be:	6a 0a                	push   $0xa
f01031c0:	6a 00                	push   $0x0
f01031c2:	50                   	push   %eax
f01031c3:	e8 6d f7 01 00       	call   f0122935 <strtol>
f01031c8:	83 c4 10             	add    $0x10,%esp
f01031cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f01031ce:	83 ec 0c             	sub    $0xc,%esp
f01031d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01031d4:	e8 1f b5 00 00       	call   f010e6f8 <setPageReplacmentAlgorithmNchanceCLOCK>
f01031d9:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f01031dc:	83 ec 0c             	sub    $0xc,%esp
f01031df:	68 d4 60 12 f0       	push   $0xf01260d4
f01031e4:	e8 83 dd ff ff       	call   f0100f6c <cprintf>
f01031e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031f1:	c9                   	leave  
f01031f2:	c3                   	ret    

f01031f3 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f01031f3:	55                   	push   %ebp
f01031f4:	89 e5                	mov    %esp,%ebp
f01031f6:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f01031f9:	e8 ba b4 00 00       	call   f010e6b8 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f01031fe:	83 ec 0c             	sub    $0xc,%esp
f0103201:	68 08 61 12 f0       	push   $0xf0126108
f0103206:	e8 61 dd ff ff       	call   f0100f6c <cprintf>
f010320b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010320e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103213:	c9                   	leave  
f0103214:	c3                   	ret    

f0103215 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f0103215:	55                   	push   %ebp
f0103216:	89 e5                	mov    %esp,%ebp
f0103218:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f010321b:	e8 a8 b4 00 00       	call   f010e6c8 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103220:	83 ec 0c             	sub    $0xc,%esp
f0103223:	68 34 61 12 f0       	push   $0xf0126134
f0103228:	e8 3f dd ff ff       	call   f0100f6c <cprintf>
f010322d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103230:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103235:	c9                   	leave  
f0103236:	c3                   	ret    

f0103237 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0103237:	55                   	push   %ebp
f0103238:	89 e5                	mov    %esp,%ebp
f010323a:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f010323d:	e8 96 b4 00 00       	call   f010e6d8 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f0103242:	83 ec 0c             	sub    $0xc,%esp
f0103245:	68 5c 61 12 f0       	push   $0xf012615c
f010324a:	e8 1d dd ff ff       	call   f0100f6c <cprintf>
f010324f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103252:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103257:	c9                   	leave  
f0103258:	c3                   	ret    

f0103259 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f0103259:	55                   	push   %ebp
f010325a:	89 e5                	mov    %esp,%ebp
f010325c:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f010325f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103262:	83 c0 04             	add    $0x4,%eax
f0103265:	8b 00                	mov    (%eax),%eax
f0103267:	83 ec 04             	sub    $0x4,%esp
f010326a:	6a 0a                	push   $0xa
f010326c:	6a 00                	push   $0x0
f010326e:	50                   	push   %eax
f010326f:	e8 c1 f6 01 00       	call   f0122935 <strtol>
f0103274:	83 c4 10             	add    $0x10,%esp
f0103277:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f010327a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010327e:	83 ec 0c             	sub    $0xc,%esp
f0103281:	50                   	push   %eax
f0103282:	e8 4e 37 00 00       	call   f01069d5 <sched_init_RR>
f0103287:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f010328a:	a0 84 37 5a f0       	mov    0xf05a3784,%al
f010328f:	0f b6 c0             	movzbl %al,%eax
f0103292:	83 ec 08             	sub    $0x8,%esp
f0103295:	50                   	push   %eax
f0103296:	68 90 61 12 f0       	push   $0xf0126190
f010329b:	e8 cc dc ff ff       	call   f0100f6c <cprintf>
f01032a0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01032a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032a8:	c9                   	leave  
f01032a9:	c3                   	ret    

f01032aa <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f01032aa:	55                   	push   %ebp
f01032ab:	89 e5                	mov    %esp,%ebp
f01032ad:	53                   	push   %ebx
f01032ae:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01032b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032b4:	83 c0 04             	add    $0x4,%eax
f01032b7:	8b 00                	mov    (%eax),%eax
f01032b9:	83 ec 04             	sub    $0x4,%esp
f01032bc:	6a 0a                	push   $0xa
f01032be:	6a 00                	push   $0x0
f01032c0:	50                   	push   %eax
f01032c1:	e8 6f f6 01 00       	call   f0122935 <strtol>
f01032c6:	83 c4 10             	add    $0x10,%esp
f01032c9:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01032cc:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f01032d3:	eb 2e                	jmp    f0103303 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f01032d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032d8:	8d 58 fe             	lea    -0x2(%eax),%ebx
f01032db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01032e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032e8:	01 d0                	add    %edx,%eax
f01032ea:	8b 00                	mov    (%eax),%eax
f01032ec:	83 ec 04             	sub    $0x4,%esp
f01032ef:	6a 0a                	push   $0xa
f01032f1:	6a 00                	push   $0x0
f01032f3:	50                   	push   %eax
f01032f4:	e8 3c f6 01 00       	call   f0122935 <strtol>
f01032f9:	83 c4 10             	add    $0x10,%esp
f01032fc:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103300:	ff 45 f4             	incl   -0xc(%ebp)
f0103303:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103306:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103309:	7c ca                	jl     f01032d5 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f010330b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f010330f:	83 ec 08             	sub    $0x8,%esp
f0103312:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103315:	52                   	push   %edx
f0103316:	50                   	push   %eax
f0103317:	e8 32 37 00 00       	call   f0106a4e <sched_init_MLFQ>
f010331c:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f010331f:	83 ec 0c             	sub    $0xc,%esp
f0103322:	68 c8 61 12 f0       	push   $0xf01261c8
f0103327:	e8 40 dc ff ff       	call   f0100f6c <cprintf>
f010332c:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010332f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103336:	eb 21                	jmp    f0103359 <command_sch_MLFQ+0xaf>
	{
		cprintf("%d   ", quantums[i]) ;
f0103338:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010333b:	05 84 37 5a f0       	add    $0xf05a3784,%eax
f0103340:	8a 00                	mov    (%eax),%al
f0103342:	0f b6 c0             	movzbl %al,%eax
f0103345:	83 ec 08             	sub    $0x8,%esp
f0103348:	50                   	push   %eax
f0103349:	68 f5 61 12 f0       	push   $0xf01261f5
f010334e:	e8 19 dc ff ff       	call   f0100f6c <cprintf>
f0103353:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f0103356:	ff 45 f0             	incl   -0x10(%ebp)
f0103359:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f010335e:	0f b6 c0             	movzbl %al,%eax
f0103361:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103364:	7f d2                	jg     f0103338 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f0103366:	83 ec 0c             	sub    $0xc,%esp
f0103369:	68 35 5d 12 f0       	push   $0xf0125d35
f010336e:	e8 f9 db ff ff       	call   f0100f6c <cprintf>
f0103373:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103376:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010337b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010337e:	c9                   	leave  
f010337f:	c3                   	ret    

f0103380 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0103380:	55                   	push   %ebp
f0103381:	89 e5                	mov    %esp,%ebp
f0103383:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103386:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103389:	83 c0 04             	add    $0x4,%eax
f010338c:	8b 00                	mov    (%eax),%eax
f010338e:	83 ec 04             	sub    $0x4,%esp
f0103391:	6a 0a                	push   $0xa
f0103393:	6a 00                	push   $0x0
f0103395:	50                   	push   %eax
f0103396:	e8 9a f5 01 00       	call   f0122935 <strtol>
f010339b:	83 c4 10             	add    $0x10,%esp
f010339e:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01033a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033a4:	83 c0 08             	add    $0x8,%eax
f01033a7:	8b 00                	mov    (%eax),%eax
f01033a9:	83 ec 04             	sub    $0x4,%esp
f01033ac:	6a 0a                	push   $0xa
f01033ae:	6a 00                	push   $0x0
f01033b0:	50                   	push   %eax
f01033b1:	e8 7f f5 01 00       	call   f0122935 <strtol>
f01033b6:	83 c4 10             	add    $0x10,%esp
f01033b9:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f01033bc:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01033c0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033c4:	83 ec 08             	sub    $0x8,%esp
f01033c7:	52                   	push   %edx
f01033c8:	50                   	push   %eax
f01033c9:	e8 a8 36 00 00       	call   f0106a76 <sched_init_BSD>
f01033ce:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f01033d1:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01033d5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033d9:	83 ec 04             	sub    $0x4,%esp
f01033dc:	52                   	push   %edx
f01033dd:	50                   	push   %eax
f01033de:	68 fc 61 12 f0       	push   $0xf01261fc
f01033e3:	e8 84 db ff ff       	call   f0100f6c <cprintf>
f01033e8:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01033eb:	83 ec 0c             	sub    $0xc,%esp
f01033ee:	68 35 5d 12 f0       	push   $0xf0125d35
f01033f3:	e8 74 db ff ff       	call   f0100f6c <cprintf>
f01033f8:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103400:	c9                   	leave  
f0103401:	c3                   	ret    

f0103402 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f0103402:	55                   	push   %ebp
f0103403:	89 e5                	mov    %esp,%ebp
f0103405:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103408:	e8 0b 33 00 00       	call   f0106718 <isSchedMethodMLFQ>
f010340d:	85 c0                	test   %eax,%eax
f010340f:	74 59                	je     f010346a <command_print_sch_method+0x68>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f0103411:	83 ec 0c             	sub    $0xc,%esp
f0103414:	68 38 62 12 f0       	push   $0xf0126238
f0103419:	e8 4e db ff ff       	call   f0100f6c <cprintf>
f010341e:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103421:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103428:	eb 21                	jmp    f010344b <command_print_sch_method+0x49>
		{
			cprintf("%d   ", quantums[i]) ;
f010342a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010342d:	05 84 37 5a f0       	add    $0xf05a3784,%eax
f0103432:	8a 00                	mov    (%eax),%al
f0103434:	0f b6 c0             	movzbl %al,%eax
f0103437:	83 ec 08             	sub    $0x8,%esp
f010343a:	50                   	push   %eax
f010343b:	68 f5 61 12 f0       	push   $0xf01261f5
f0103440:	e8 27 db ff ff       	call   f0100f6c <cprintf>
f0103445:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103448:	ff 45 f4             	incl   -0xc(%ebp)
f010344b:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f0103450:	0f b6 c0             	movzbl %al,%eax
f0103453:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103456:	7f d2                	jg     f010342a <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103458:	83 ec 0c             	sub    $0xc,%esp
f010345b:	68 35 5d 12 f0       	push   $0xf0125d35
f0103460:	e8 07 db ff ff       	call   f0100f6c <cprintf>
f0103465:	83 c4 10             	add    $0x10,%esp
f0103468:	eb 61                	jmp    f01034cb <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodRR())
f010346a:	e8 8f 32 00 00       	call   f01066fe <isSchedMethodRR>
f010346f:	85 c0                	test   %eax,%eax
f0103471:	74 1b                	je     f010348e <command_print_sch_method+0x8c>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103473:	a0 84 37 5a f0       	mov    0xf05a3784,%al
f0103478:	0f b6 c0             	movzbl %al,%eax
f010347b:	83 ec 08             	sub    $0x8,%esp
f010347e:	50                   	push   %eax
f010347f:	68 6c 62 12 f0       	push   $0xf012626c
f0103484:	e8 e3 da ff ff       	call   f0100f6c <cprintf>
f0103489:	83 c4 10             	add    $0x10,%esp
f010348c:	eb 3d                	jmp    f01034cb <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodBSD())
f010348e:	e8 a0 32 00 00       	call   f0106733 <isSchedMethodBSD>
f0103493:	85 c0                	test   %eax,%eax
f0103495:	74 24                	je     f01034bb <command_print_sch_method+0xb9>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103497:	a0 84 37 5a f0       	mov    0xf05a3784,%al
f010349c:	0f b6 d0             	movzbl %al,%edx
f010349f:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f01034a4:	0f b6 c0             	movzbl %al,%eax
f01034a7:	83 ec 04             	sub    $0x4,%esp
f01034aa:	52                   	push   %edx
f01034ab:	50                   	push   %eax
f01034ac:	68 fc 61 12 f0       	push   $0xf01261fc
f01034b1:	e8 b6 da ff ff       	call   f0100f6c <cprintf>
f01034b6:	83 c4 10             	add    $0x10,%esp
f01034b9:	eb 10                	jmp    f01034cb <command_print_sch_method+0xc9>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01034bb:	83 ec 0c             	sub    $0xc,%esp
f01034be:	68 a8 62 12 f0       	push   $0xf01262a8
f01034c3:	e8 a4 da ff ff       	call   f0100f6c <cprintf>
f01034c8:	83 c4 10             	add    $0x10,%esp

	return 0;
f01034cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034d0:	c9                   	leave  
f01034d1:	c3                   	ret    

f01034d2 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01034d2:	55                   	push   %ebp
f01034d3:	89 e5                	mov    %esp,%ebp
f01034d5:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01034d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034db:	83 c0 04             	add    $0x4,%eax
f01034de:	8b 00                	mov    (%eax),%eax
f01034e0:	83 ec 04             	sub    $0x4,%esp
f01034e3:	6a 0a                	push   $0xa
f01034e5:	6a 00                	push   $0x0
f01034e7:	50                   	push   %eax
f01034e8:	e8 48 f4 01 00       	call   f0122935 <strtol>
f01034ed:	83 c4 10             	add    $0x10,%esp
f01034f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f01034f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01034f6:	0f b6 c0             	movzbl %al,%eax
f01034f9:	83 ec 0c             	sub    $0xc,%esp
f01034fc:	50                   	push   %eax
f01034fd:	e8 30 e2 01 00       	call   f0121732 <chksch>
f0103502:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103505:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103509:	75 12                	jne    f010351d <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010350b:	83 ec 0c             	sub    $0xc,%esp
f010350e:	68 d0 62 12 f0       	push   $0xf01262d0
f0103513:	e8 54 da ff ff       	call   f0100f6c <cprintf>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	eb 16                	jmp    f0103533 <command_sch_test+0x61>
	else if (status == 1)
f010351d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103521:	75 10                	jne    f0103533 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103523:	83 ec 0c             	sub    $0xc,%esp
f0103526:	68 f8 62 12 f0       	push   $0xf01262f8
f010352b:	e8 3c da ff ff       	call   f0100f6c <cprintf>
f0103530:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103533:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103538:	c9                   	leave  
f0103539:	c3                   	ret    

f010353a <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010353a:	55                   	push   %ebp
f010353b:	89 e5                	mov    %esp,%ebp
f010353d:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103540:	e8 e1 b1 00 00       	call   f010e726 <isPageReplacmentAlgorithmCLOCK>
f0103545:	85 c0                	test   %eax,%eax
f0103547:	74 15                	je     f010355e <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f0103549:	83 ec 0c             	sub    $0xc,%esp
f010354c:	68 1c 63 12 f0       	push   $0xf012631c
f0103551:	e8 16 da ff ff       	call   f0100f6c <cprintf>
f0103556:	83 c4 10             	add    $0x10,%esp
f0103559:	e9 8c 00 00 00       	jmp    f01035ea <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010355e:	83 ec 0c             	sub    $0xc,%esp
f0103561:	6a 01                	push   $0x1
f0103563:	e8 a8 b1 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f0103568:	83 c4 10             	add    $0x10,%esp
f010356b:	85 c0                	test   %eax,%eax
f010356d:	74 12                	je     f0103581 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f010356f:	83 ec 0c             	sub    $0xc,%esp
f0103572:	68 44 63 12 f0       	push   $0xf0126344
f0103577:	e8 f0 d9 ff ff       	call   f0100f6c <cprintf>
f010357c:	83 c4 10             	add    $0x10,%esp
f010357f:	eb 69                	jmp    f01035ea <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103581:	83 ec 0c             	sub    $0xc,%esp
f0103584:	6a 02                	push   $0x2
f0103586:	e8 85 b1 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f010358b:	83 c4 10             	add    $0x10,%esp
f010358e:	85 c0                	test   %eax,%eax
f0103590:	74 12                	je     f01035a4 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103592:	83 ec 0c             	sub    $0xc,%esp
f0103595:	68 84 63 12 f0       	push   $0xf0126384
f010359a:	e8 cd d9 ff ff       	call   f0100f6c <cprintf>
f010359f:	83 c4 10             	add    $0x10,%esp
f01035a2:	eb 46                	jmp    f01035ea <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f01035a4:	e8 98 b1 00 00       	call   f010e741 <isPageReplacmentAlgorithmFIFO>
f01035a9:	85 c0                	test   %eax,%eax
f01035ab:	74 12                	je     f01035bf <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f01035ad:	83 ec 0c             	sub    $0xc,%esp
f01035b0:	68 c0 63 12 f0       	push   $0xf01263c0
f01035b5:	e8 b2 d9 ff ff       	call   f0100f6c <cprintf>
f01035ba:	83 c4 10             	add    $0x10,%esp
f01035bd:	eb 2b                	jmp    f01035ea <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01035bf:	e8 98 b1 00 00       	call   f010e75c <isPageReplacmentAlgorithmModifiedCLOCK>
f01035c4:	85 c0                	test   %eax,%eax
f01035c6:	74 12                	je     f01035da <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01035c8:	83 ec 0c             	sub    $0xc,%esp
f01035cb:	68 e4 63 12 f0       	push   $0xf01263e4
f01035d0:	e8 97 d9 ff ff       	call   f0100f6c <cprintf>
f01035d5:	83 c4 10             	add    $0x10,%esp
f01035d8:	eb 10                	jmp    f01035ea <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f01035da:	83 ec 0c             	sub    $0xc,%esp
f01035dd:	68 14 64 12 f0       	push   $0xf0126414
f01035e2:	e8 85 d9 ff ff       	call   f0100f6c <cprintf>
f01035e7:	83 c4 10             	add    $0x10,%esp

	return 0;
f01035ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035ef:	c9                   	leave  
f01035f0:	c3                   	ret    

f01035f1 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01035f1:	55                   	push   %ebp
f01035f2:	89 e5                	mov    %esp,%ebp
f01035f4:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f01035f7:	e8 bf ef ff ff       	call   f01025bb <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f01035fc:	83 ec 0c             	sub    $0xc,%esp
f01035ff:	68 40 64 12 f0       	push   $0xf0126440
f0103604:	e8 63 d9 ff ff       	call   f0100f6c <cprintf>
f0103609:	83 c4 10             	add    $0x10,%esp
	return 0;
f010360c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103611:	c9                   	leave  
f0103612:	c3                   	ret    

f0103613 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103613:	55                   	push   %ebp
f0103614:	89 e5                	mov    %esp,%ebp
f0103616:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0103619:	e8 ad ef ff ff       	call   f01025cb <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f010361e:	83 ec 0c             	sub    $0xc,%esp
f0103621:	68 70 64 12 f0       	push   $0xf0126470
f0103626:	e8 41 d9 ff ff       	call   f0100f6c <cprintf>
f010362b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010362e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103633:	c9                   	leave  
f0103634:	c3                   	ret    

f0103635 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103635:	55                   	push   %ebp
f0103636:	89 e5                	mov    %esp,%ebp
f0103638:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f010363b:	e8 9b ef ff ff       	call   f01025db <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f0103640:	83 ec 0c             	sub    $0xc,%esp
f0103643:	68 a0 64 12 f0       	push   $0xf01264a0
f0103648:	e8 1f d9 ff ff       	call   f0100f6c <cprintf>
f010364d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103650:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103655:	c9                   	leave  
f0103656:	c3                   	ret    

f0103657 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103657:	55                   	push   %ebp
f0103658:	89 e5                	mov    %esp,%ebp
f010365a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f010365d:	e8 89 ef ff ff       	call   f01025eb <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0103662:	83 ec 0c             	sub    $0xc,%esp
f0103665:	68 d0 64 12 f0       	push   $0xf01264d0
f010366a:	e8 fd d8 ff ff       	call   f0100f6c <cprintf>
f010366f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103672:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103677:	c9                   	leave  
f0103678:	c3                   	ret    

f0103679 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f0103679:	55                   	push   %ebp
f010367a:	89 e5                	mov    %esp,%ebp
f010367c:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f010367f:	e8 77 ef ff ff       	call   f01025fb <isUHeapPlacementStrategyFIRSTFIT>
f0103684:	84 c0                	test   %al,%al
f0103686:	74 12                	je     f010369a <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0103688:	83 ec 0c             	sub    $0xc,%esp
f010368b:	68 00 65 12 f0       	push   $0xf0126500
f0103690:	e8 d7 d8 ff ff       	call   f0100f6c <cprintf>
f0103695:	83 c4 10             	add    $0x10,%esp
f0103698:	eb 61                	jmp    f01036fb <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010369a:	e8 71 ef ff ff       	call   f0102610 <isUHeapPlacementStrategyBESTFIT>
f010369f:	84 c0                	test   %al,%al
f01036a1:	74 12                	je     f01036b5 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f01036a3:	83 ec 0c             	sub    $0xc,%esp
f01036a6:	68 2c 65 12 f0       	push   $0xf012652c
f01036ab:	e8 bc d8 ff ff       	call   f0100f6c <cprintf>
f01036b0:	83 c4 10             	add    $0x10,%esp
f01036b3:	eb 46                	jmp    f01036fb <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f01036b5:	e8 6b ef ff ff       	call   f0102625 <isUHeapPlacementStrategyNEXTFIT>
f01036ba:	84 c0                	test   %al,%al
f01036bc:	74 12                	je     f01036d0 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f01036be:	83 ec 0c             	sub    $0xc,%esp
f01036c1:	68 58 65 12 f0       	push   $0xf0126558
f01036c6:	e8 a1 d8 ff ff       	call   f0100f6c <cprintf>
f01036cb:	83 c4 10             	add    $0x10,%esp
f01036ce:	eb 2b                	jmp    f01036fb <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f01036d0:	e8 65 ef ff ff       	call   f010263a <isUHeapPlacementStrategyWORSTFIT>
f01036d5:	84 c0                	test   %al,%al
f01036d7:	74 12                	je     f01036eb <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f01036d9:	83 ec 0c             	sub    $0xc,%esp
f01036dc:	68 84 65 12 f0       	push   $0xf0126584
f01036e1:	e8 86 d8 ff ff       	call   f0100f6c <cprintf>
f01036e6:	83 c4 10             	add    $0x10,%esp
f01036e9:	eb 10                	jmp    f01036fb <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01036eb:	83 ec 0c             	sub    $0xc,%esp
f01036ee:	68 b0 65 12 f0       	push   $0xf01265b0
f01036f3:	e8 74 d8 ff ff       	call   f0100f6c <cprintf>
f01036f8:	83 c4 10             	add    $0x10,%esp

	return 0;
f01036fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103700:	c9                   	leave  
f0103701:	c3                   	ret    

f0103702 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103702:	55                   	push   %ebp
f0103703:	89 e5                	mov    %esp,%ebp
f0103705:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103708:	e8 f6 ed ff ff       	call   f0102503 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010370d:	83 ec 0c             	sub    $0xc,%esp
f0103710:	68 dc 65 12 f0       	push   $0xf01265dc
f0103715:	e8 52 d8 ff ff       	call   f0100f6c <cprintf>
f010371a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010371d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103722:	c9                   	leave  
f0103723:	c3                   	ret    

f0103724 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103724:	55                   	push   %ebp
f0103725:	89 e5                	mov    %esp,%ebp
f0103727:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f010372a:	e8 e4 ed ff ff       	call   f0102513 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010372f:	83 ec 0c             	sub    $0xc,%esp
f0103732:	68 dc 65 12 f0       	push   $0xf01265dc
f0103737:	e8 30 d8 ff ff       	call   f0100f6c <cprintf>
f010373c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010373f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103744:	c9                   	leave  
f0103745:	c3                   	ret    

f0103746 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103746:	55                   	push   %ebp
f0103747:	89 e5                	mov    %esp,%ebp
f0103749:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f010374c:	e8 d2 ed ff ff       	call   f0102523 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103751:	83 ec 0c             	sub    $0xc,%esp
f0103754:	68 10 66 12 f0       	push   $0xf0126610
f0103759:	e8 0e d8 ff ff       	call   f0100f6c <cprintf>
f010375e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103761:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103766:	c9                   	leave  
f0103767:	c3                   	ret    

f0103768 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103768:	55                   	push   %ebp
f0103769:	89 e5                	mov    %esp,%ebp
f010376b:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f010376e:	e8 c0 ed ff ff       	call   f0102533 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103773:	83 ec 0c             	sub    $0xc,%esp
f0103776:	68 40 66 12 f0       	push   $0xf0126640
f010377b:	e8 ec d7 ff ff       	call   f0100f6c <cprintf>
f0103780:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103783:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103788:	c9                   	leave  
f0103789:	c3                   	ret    

f010378a <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010378a:	55                   	push   %ebp
f010378b:	89 e5                	mov    %esp,%ebp
f010378d:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103790:	e8 ae ed ff ff       	call   f0102543 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103795:	83 ec 0c             	sub    $0xc,%esp
f0103798:	68 70 66 12 f0       	push   $0xf0126670
f010379d:	e8 ca d7 ff ff       	call   f0100f6c <cprintf>
f01037a2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037aa:	c9                   	leave  
f01037ab:	c3                   	ret    

f01037ac <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01037ac:	55                   	push   %ebp
f01037ad:	89 e5                	mov    %esp,%ebp
f01037af:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f01037b2:	e8 9c ed ff ff       	call   f0102553 <isKHeapPlacementStrategyCONTALLOC>
f01037b7:	84 c0                	test   %al,%al
f01037b9:	74 12                	je     f01037cd <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01037bb:	83 ec 0c             	sub    $0xc,%esp
f01037be:	68 a4 66 12 f0       	push   $0xf01266a4
f01037c3:	e8 a4 d7 ff ff       	call   f0100f6c <cprintf>
f01037c8:	83 c4 10             	add    $0x10,%esp
f01037cb:	eb 7c                	jmp    f0103849 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f01037cd:	e8 95 ed ff ff       	call   f0102567 <isKHeapPlacementStrategyFIRSTFIT>
f01037d2:	84 c0                	test   %al,%al
f01037d4:	74 12                	je     f01037e8 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01037d6:	83 ec 0c             	sub    $0xc,%esp
f01037d9:	68 e0 66 12 f0       	push   $0xf01266e0
f01037de:	e8 89 d7 ff ff       	call   f0100f6c <cprintf>
f01037e3:	83 c4 10             	add    $0x10,%esp
f01037e6:	eb 61                	jmp    f0103849 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f01037e8:	e8 8f ed ff ff       	call   f010257c <isKHeapPlacementStrategyBESTFIT>
f01037ed:	84 c0                	test   %al,%al
f01037ef:	74 12                	je     f0103803 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f01037f1:	83 ec 0c             	sub    $0xc,%esp
f01037f4:	68 10 67 12 f0       	push   $0xf0126710
f01037f9:	e8 6e d7 ff ff       	call   f0100f6c <cprintf>
f01037fe:	83 c4 10             	add    $0x10,%esp
f0103801:	eb 46                	jmp    f0103849 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103803:	e8 89 ed ff ff       	call   f0102591 <isKHeapPlacementStrategyNEXTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 3c 67 12 f0       	push   $0xf012673c
f0103814:	e8 53 d7 ff ff       	call   f0100f6c <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 2b                	jmp    f0103849 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f010381e:	e8 83 ed ff ff       	call   f01025a6 <isKHeapPlacementStrategyWORSTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 68 67 12 f0       	push   $0xf0126768
f010382f:	e8 38 d7 ff ff       	call   f0100f6c <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 10                	jmp    f0103849 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0103839:	83 ec 0c             	sub    $0xc,%esp
f010383c:	68 98 67 12 f0       	push   $0xf0126798
f0103841:	e8 26 d7 ff ff       	call   f0100f6c <cprintf>
f0103846:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103849:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010384e:	c9                   	leave  
f010384f:	c3                   	ret    

f0103850 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103850:	55                   	push   %ebp
f0103851:	89 e5                	mov    %esp,%ebp
f0103853:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103856:	e8 78 af 00 00       	call   f010e7d3 <isBufferingEnabled>
f010385b:	84 c0                	test   %al,%al
f010385d:	75 12                	jne    f0103871 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f010385f:	83 ec 0c             	sub    $0xc,%esp
f0103862:	68 c8 67 12 f0       	push   $0xf01267c8
f0103867:	e8 00 d7 ff ff       	call   f0100f6c <cprintf>
f010386c:	83 c4 10             	add    $0x10,%esp
f010386f:	eb 1d                	jmp    f010388e <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103871:	83 ec 0c             	sub    $0xc,%esp
f0103874:	6a 00                	push   $0x0
f0103876:	e8 32 af 00 00       	call   f010e7ad <enableModifiedBuffer>
f010387b:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f010387e:	83 ec 0c             	sub    $0xc,%esp
f0103881:	68 04 68 12 f0       	push   $0xf0126804
f0103886:	e8 e1 d6 ff ff       	call   f0100f6c <cprintf>
f010388b:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010388e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103893:	c9                   	leave  
f0103894:	c3                   	ret    

f0103895 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103895:	55                   	push   %ebp
f0103896:	89 e5                	mov    %esp,%ebp
f0103898:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f010389b:	e8 33 af 00 00       	call   f010e7d3 <isBufferingEnabled>
f01038a0:	84 c0                	test   %al,%al
f01038a2:	75 12                	jne    f01038b6 <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01038a4:	83 ec 0c             	sub    $0xc,%esp
f01038a7:	68 c8 67 12 f0       	push   $0xf01267c8
f01038ac:	e8 bb d6 ff ff       	call   f0100f6c <cprintf>
f01038b1:	83 c4 10             	add    $0x10,%esp
f01038b4:	eb 1d                	jmp    f01038d3 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f01038b6:	83 ec 0c             	sub    $0xc,%esp
f01038b9:	6a 01                	push   $0x1
f01038bb:	e8 ed ae 00 00       	call   f010e7ad <enableModifiedBuffer>
f01038c0:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f01038c3:	83 ec 0c             	sub    $0xc,%esp
f01038c6:	68 28 68 12 f0       	push   $0xf0126828
f01038cb:	e8 9c d6 ff ff       	call   f0100f6c <cprintf>
f01038d0:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01038d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038d8:	c9                   	leave  
f01038d9:	c3                   	ret    

f01038da <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01038da:	55                   	push   %ebp
f01038db:	89 e5                	mov    %esp,%ebp
f01038dd:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01038e0:	83 ec 0c             	sub    $0xc,%esp
f01038e3:	6a 00                	push   $0x0
f01038e5:	e8 db ae 00 00       	call   f010e7c5 <enableBuffering>
f01038ea:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f01038ed:	83 ec 0c             	sub    $0xc,%esp
f01038f0:	6a 00                	push   $0x0
f01038f2:	e8 b6 ae 00 00       	call   f010e7ad <enableModifiedBuffer>
f01038f7:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f01038fa:	83 ec 0c             	sub    $0xc,%esp
f01038fd:	68 48 68 12 f0       	push   $0xf0126848
f0103902:	e8 65 d6 ff ff       	call   f0100f6c <cprintf>
f0103907:	83 c4 10             	add    $0x10,%esp
	return 0;
f010390a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390f:	c9                   	leave  
f0103910:	c3                   	ret    

f0103911 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103911:	55                   	push   %ebp
f0103912:	89 e5                	mov    %esp,%ebp
f0103914:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103917:	83 ec 0c             	sub    $0xc,%esp
f010391a:	6a 01                	push   $0x1
f010391c:	e8 a4 ae 00 00       	call   f010e7c5 <enableBuffering>
f0103921:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103924:	83 ec 0c             	sub    $0xc,%esp
f0103927:	6a 01                	push   $0x1
f0103929:	e8 7f ae 00 00       	call   f010e7ad <enableModifiedBuffer>
f010392e:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103931:	e8 b5 ae 00 00       	call   f010e7eb <getModifiedBufferLength>
f0103936:	85 c0                	test   %eax,%eax
f0103938:	75 59                	jne    f0103993 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f010393a:	83 ec 0c             	sub    $0xc,%esp
f010393d:	68 64 68 12 f0       	push   $0xf0126864
f0103942:	e8 25 d6 ff ff       	call   f0100f6c <cprintf>
f0103947:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f010394a:	83 ec 08             	sub    $0x8,%esp
f010394d:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103950:	50                   	push   %eax
f0103951:	68 94 68 12 f0       	push   $0xf0126894
f0103956:	e8 72 ea 01 00       	call   f01223cd <readline>
f010395b:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f010395e:	83 ec 04             	sub    $0x4,%esp
f0103961:	6a 0a                	push   $0xa
f0103963:	6a 00                	push   $0x0
f0103965:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103968:	50                   	push   %eax
f0103969:	e8 c7 ef 01 00       	call   f0122935 <strtol>
f010396e:	83 c4 10             	add    $0x10,%esp
f0103971:	83 ec 0c             	sub    $0xc,%esp
f0103974:	50                   	push   %eax
f0103975:	e8 63 ae 00 00       	call   f010e7dd <setModifiedBufferLength>
f010397a:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f010397d:	e8 69 ae 00 00       	call   f010e7eb <getModifiedBufferLength>
f0103982:	83 ec 08             	sub    $0x8,%esp
f0103985:	50                   	push   %eax
f0103986:	68 c0 68 12 f0       	push   $0xf01268c0
f010398b:	e8 dc d5 ff ff       	call   f0100f6c <cprintf>
f0103990:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103993:	83 ec 0c             	sub    $0xc,%esp
f0103996:	68 e5 68 12 f0       	push   $0xf01268e5
f010399b:	e8 cc d5 ff ff       	call   f0100f6c <cprintf>
f01039a0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039a8:	c9                   	leave  
f01039a9:	c3                   	ret    

f01039aa <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f01039aa:	55                   	push   %ebp
f01039ab:	89 e5                	mov    %esp,%ebp
f01039ad:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039b0:	e8 1e ae 00 00       	call   f010e7d3 <isBufferingEnabled>
f01039b5:	84 c0                	test   %al,%al
f01039b7:	75 12                	jne    f01039cb <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f01039b9:	83 ec 0c             	sub    $0xc,%esp
f01039bc:	68 00 69 12 f0       	push   $0xf0126900
f01039c1:	e8 a6 d5 ff ff       	call   f0100f6c <cprintf>
f01039c6:	83 c4 10             	add    $0x10,%esp
f01039c9:	eb 19                	jmp    f01039e4 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f01039cb:	e8 eb ad 00 00       	call   f010e7bb <isModifiedBufferEnabled>
f01039d0:	84 c0                	test   %al,%al
f01039d2:	75 10                	jne    f01039e4 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f01039d4:	83 ec 0c             	sub    $0xc,%esp
f01039d7:	68 50 69 12 f0       	push   $0xf0126950
f01039dc:	e8 8b d5 ff ff       	call   f0100f6c <cprintf>
f01039e1:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f01039e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01039e7:	83 c0 04             	add    $0x4,%eax
f01039ea:	8b 00                	mov    (%eax),%eax
f01039ec:	83 ec 04             	sub    $0x4,%esp
f01039ef:	6a 0a                	push   $0xa
f01039f1:	6a 00                	push   $0x0
f01039f3:	50                   	push   %eax
f01039f4:	e8 3c ef 01 00       	call   f0122935 <strtol>
f01039f9:	83 c4 10             	add    $0x10,%esp
f01039fc:	83 ec 0c             	sub    $0xc,%esp
f01039ff:	50                   	push   %eax
f0103a00:	e8 d8 ad 00 00       	call   f010e7dd <setModifiedBufferLength>
f0103a05:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103a08:	e8 de ad 00 00       	call   f010e7eb <getModifiedBufferLength>
f0103a0d:	83 ec 08             	sub    $0x8,%esp
f0103a10:	50                   	push   %eax
f0103a11:	68 c0 68 12 f0       	push   $0xf01268c0
f0103a16:	e8 51 d5 ff ff       	call   f0100f6c <cprintf>
f0103a1b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a23:	c9                   	leave  
f0103a24:	c3                   	ret    

f0103a25 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103a25:	55                   	push   %ebp
f0103a26:	89 e5                	mov    %esp,%ebp
f0103a28:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a2b:	e8 a3 ad 00 00       	call   f010e7d3 <isBufferingEnabled>
f0103a30:	84 c0                	test   %al,%al
f0103a32:	75 12                	jne    f0103a46 <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103a34:	83 ec 0c             	sub    $0xc,%esp
f0103a37:	68 00 69 12 f0       	push   $0xf0126900
f0103a3c:	e8 2b d5 ff ff       	call   f0100f6c <cprintf>
f0103a41:	83 c4 10             	add    $0x10,%esp
f0103a44:	eb 19                	jmp    f0103a5f <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103a46:	e8 70 ad 00 00       	call   f010e7bb <isModifiedBufferEnabled>
f0103a4b:	84 c0                	test   %al,%al
f0103a4d:	75 10                	jne    f0103a5f <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103a4f:	83 ec 0c             	sub    $0xc,%esp
f0103a52:	68 50 69 12 f0       	push   $0xf0126950
f0103a57:	e8 10 d5 ff ff       	call   f0100f6c <cprintf>
f0103a5c:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103a5f:	e8 87 ad 00 00       	call   f010e7eb <getModifiedBufferLength>
f0103a64:	83 ec 08             	sub    $0x8,%esp
f0103a67:	50                   	push   %eax
f0103a68:	68 96 69 12 f0       	push   $0xf0126996
f0103a6d:	e8 fa d4 ff ff       	call   f0100f6c <cprintf>
f0103a72:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a75:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a7a:	c9                   	leave  
f0103a7b:	c3                   	ret    

f0103a7c <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103a7c:	55                   	push   %ebp
f0103a7d:	89 e5                	mov    %esp,%ebp
f0103a7f:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103a82:	83 ec 08             	sub    $0x8,%esp
f0103a85:	ff 75 0c             	pushl  0xc(%ebp)
f0103a88:	ff 75 08             	pushl  0x8(%ebp)
f0103a8b:	e8 78 b6 00 00       	call   f010f108 <tst_handler>
f0103a90:	83 c4 10             	add    $0x10,%esp
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0103a98:	8b 45 08             	mov    0x8(%ebp),%eax
f0103a9b:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f0103aa1:	29 d0                	sub    %edx,%eax
f0103aa3:	c1 f8 03             	sar    $0x3,%eax
f0103aa6:	89 c2                	mov    %eax,%edx
f0103aa8:	89 d0                	mov    %edx,%eax
f0103aaa:	c1 e0 02             	shl    $0x2,%eax
f0103aad:	01 d0                	add    %edx,%eax
f0103aaf:	c1 e0 02             	shl    $0x2,%eax
f0103ab2:	01 d0                	add    %edx,%eax
f0103ab4:	c1 e0 02             	shl    $0x2,%eax
f0103ab7:	01 d0                	add    %edx,%eax
f0103ab9:	89 c1                	mov    %eax,%ecx
f0103abb:	c1 e1 08             	shl    $0x8,%ecx
f0103abe:	01 c8                	add    %ecx,%eax
f0103ac0:	89 c1                	mov    %eax,%ecx
f0103ac2:	c1 e1 10             	shl    $0x10,%ecx
f0103ac5:	01 c8                	add    %ecx,%eax
f0103ac7:	01 c0                	add    %eax,%eax
f0103ac9:	01 d0                	add    %edx,%eax
}
f0103acb:	5d                   	pop    %ebp
f0103acc:	c3                   	ret    

f0103acd <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0103acd:	55                   	push   %ebp
f0103ace:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0103ad0:	ff 75 08             	pushl  0x8(%ebp)
f0103ad3:	e8 bd ff ff ff       	call   f0103a95 <to_frame_number>
f0103ad8:	83 c4 04             	add    $0x4,%esp
f0103adb:	c1 e0 0c             	shl    $0xc,%eax
}
f0103ade:	c9                   	leave  
f0103adf:	c3                   	ret    

f0103ae0 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0103ae0:	55                   	push   %ebp
f0103ae1:	89 e5                	mov    %esp,%ebp
f0103ae3:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0103ae6:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ae9:	c1 e8 0c             	shr    $0xc,%eax
f0103aec:	89 c2                	mov    %eax,%edx
f0103aee:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0103af3:	39 c2                	cmp    %eax,%edx
f0103af5:	72 14                	jb     f0103b0b <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0103af7:	83 ec 04             	sub    $0x4,%esp
f0103afa:	68 b4 69 12 f0       	push   $0xf01269b4
f0103aff:	6a 55                	push   $0x55
f0103b01:	68 dc 69 12 f0       	push   $0xf01269dc
f0103b06:	e8 0f c8 ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0103b0b:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f0103b11:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b14:	c1 e8 0c             	shr    $0xc,%eax
f0103b17:	89 c1                	mov    %eax,%ecx
f0103b19:	89 c8                	mov    %ecx,%eax
f0103b1b:	01 c0                	add    %eax,%eax
f0103b1d:	01 c8                	add    %ecx,%eax
f0103b1f:	c1 e0 03             	shl    $0x3,%eax
f0103b22:	01 d0                	add    %edx,%eax
}
f0103b24:	c9                   	leave  
f0103b25:	c3                   	ret    

f0103b26 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103b26:	55                   	push   %ebp
f0103b27:	89 e5                	mov    %esp,%ebp
f0103b29:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103b2c:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b2f:	05 00 14 00 00       	add    $0x1400,%eax
f0103b34:	c1 e0 03             	shl    $0x3,%eax
f0103b37:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103b3a:	83 ec 04             	sub    $0x4,%esp
f0103b3d:	6a 08                	push   $0x8
f0103b3f:	ff 75 0c             	pushl  0xc(%ebp)
f0103b42:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b45:	e8 73 f2 01 00       	call   f0122dbd <ide_read>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103b53:	c9                   	leave  
f0103b54:	c3                   	ret    

f0103b55 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103b55:	55                   	push   %ebp
f0103b56:	89 e5                	mov    %esp,%ebp
f0103b58:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103b5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b5e:	05 00 14 00 00       	add    $0x1400,%eax
f0103b63:	c1 e0 03             	shl    $0x3,%eax
f0103b66:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103b69:	83 ec 04             	sub    $0x4,%esp
f0103b6c:	6a 08                	push   $0x8
f0103b6e:	ff 75 0c             	pushl  0xc(%ebp)
f0103b71:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b74:	e8 84 f3 01 00       	call   f0122efd <ide_write>
f0103b79:	83 c4 10             	add    $0x10,%esp
f0103b7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103b7f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103b83:	74 14                	je     f0103b99 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103b85:	83 ec 04             	sub    $0x4,%esp
f0103b88:	68 fe 69 12 f0       	push   $0xf01269fe
f0103b8d:	6a 2f                	push   $0x2f
f0103b8f:	68 15 6a 12 f0       	push   $0xf0126a15
f0103b94:	e8 81 c7 ff ff       	call   f010031a <_panic>
	return success;
f0103b99:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103b9c:	c9                   	leave  
f0103b9d:	c3                   	ret    

f0103b9e <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103b9e:	55                   	push   %ebp
f0103b9f:	89 e5                	mov    %esp,%ebp
f0103ba1:	53                   	push   %ebx
f0103ba2:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103ba5:	c7 05 80 3a 5a f0 00 	movl   $0x0,0xf05a3a80
f0103bac:	00 00 00 
f0103baf:	c7 05 84 3a 5a f0 00 	movl   $0x0,0xf05a3a84
f0103bb6:	00 00 00 
f0103bb9:	c7 05 8c 3a 5a f0 00 	movl   $0x0,0xf05a3a8c
f0103bc0:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103bc3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103bca:	e9 e8 00 00 00       	jmp    f0103cb7 <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103bcf:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103bd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103bd8:	89 d0                	mov    %edx,%eax
f0103bda:	01 c0                	add    %eax,%eax
f0103bdc:	01 d0                	add    %edx,%eax
f0103bde:	c1 e0 03             	shl    $0x3,%eax
f0103be1:	01 c8                	add    %ecx,%eax
f0103be3:	83 ec 0c             	sub    $0xc,%esp
f0103be6:	50                   	push   %eax
f0103be7:	e8 c9 45 00 00       	call   f01081b5 <initialize_frame_info>
f0103bec:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103bef:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103bf5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103bf8:	89 d0                	mov    %edx,%eax
f0103bfa:	01 c0                	add    %eax,%eax
f0103bfc:	01 d0                	add    %edx,%eax
f0103bfe:	c1 e0 03             	shl    $0x3,%eax
f0103c01:	01 c8                	add    %ecx,%eax
f0103c03:	85 c0                	test   %eax,%eax
f0103c05:	75 14                	jne    f0103c1b <initialize_disk_page_file+0x7d>
f0103c07:	83 ec 04             	sub    $0x4,%esp
f0103c0a:	68 34 6a 12 f0       	push   $0xf0126a34
f0103c0f:	6a 56                	push   $0x56
f0103c11:	68 15 6a 12 f0       	push   $0xf0126a15
f0103c16:	e8 ff c6 ff ff       	call   f010031a <_panic>
f0103c1b:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103c21:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c24:	89 d0                	mov    %edx,%eax
f0103c26:	01 c0                	add    %eax,%eax
f0103c28:	01 d0                	add    %edx,%eax
f0103c2a:	c1 e0 03             	shl    $0x3,%eax
f0103c2d:	01 c8                	add    %ecx,%eax
f0103c2f:	8b 15 80 3a 5a f0    	mov    0xf05a3a80,%edx
f0103c35:	89 10                	mov    %edx,(%eax)
f0103c37:	8b 00                	mov    (%eax),%eax
f0103c39:	85 c0                	test   %eax,%eax
f0103c3b:	74 1f                	je     f0103c5c <initialize_disk_page_file+0xbe>
f0103c3d:	8b 15 80 3a 5a f0    	mov    0xf05a3a80,%edx
f0103c43:	8b 1d 60 0c 5a f0    	mov    0xf05a0c60,%ebx
f0103c49:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103c4c:	89 c8                	mov    %ecx,%eax
f0103c4e:	01 c0                	add    %eax,%eax
f0103c50:	01 c8                	add    %ecx,%eax
f0103c52:	c1 e0 03             	shl    $0x3,%eax
f0103c55:	01 d8                	add    %ebx,%eax
f0103c57:	89 42 04             	mov    %eax,0x4(%edx)
f0103c5a:	eb 19                	jmp    f0103c75 <initialize_disk_page_file+0xd7>
f0103c5c:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103c62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c65:	89 d0                	mov    %edx,%eax
f0103c67:	01 c0                	add    %eax,%eax
f0103c69:	01 d0                	add    %edx,%eax
f0103c6b:	c1 e0 03             	shl    $0x3,%eax
f0103c6e:	01 c8                	add    %ecx,%eax
f0103c70:	a3 84 3a 5a f0       	mov    %eax,0xf05a3a84
f0103c75:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103c7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c7e:	89 d0                	mov    %edx,%eax
f0103c80:	01 c0                	add    %eax,%eax
f0103c82:	01 d0                	add    %edx,%eax
f0103c84:	c1 e0 03             	shl    $0x3,%eax
f0103c87:	01 c8                	add    %ecx,%eax
f0103c89:	a3 80 3a 5a f0       	mov    %eax,0xf05a3a80
f0103c8e:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103c94:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c97:	89 d0                	mov    %edx,%eax
f0103c99:	01 c0                	add    %eax,%eax
f0103c9b:	01 d0                	add    %edx,%eax
f0103c9d:	c1 e0 03             	shl    $0x3,%eax
f0103ca0:	01 c8                	add    %ecx,%eax
f0103ca2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ca9:	a1 8c 3a 5a f0       	mov    0xf05a3a8c,%eax
f0103cae:	40                   	inc    %eax
f0103caf:	a3 8c 3a 5a f0       	mov    %eax,0xf05a3a8c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb4:	ff 45 f4             	incl   -0xc(%ebp)
f0103cb7:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103cbe:	0f 8e 0b ff ff ff    	jle    f0103bcf <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103cc4:	90                   	nop
f0103cc5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103cc8:	c9                   	leave  
f0103cc9:	c3                   	ret    

f0103cca <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103cca:	55                   	push   %ebp
f0103ccb:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103ccd:	8b 45 08             	mov    0x8(%ebp),%eax
f0103cd0:	8b 15 60 0c 5a f0    	mov    0xf05a0c60,%edx
f0103cd6:	29 d0                	sub    %edx,%eax
f0103cd8:	c1 f8 03             	sar    $0x3,%eax
f0103cdb:	89 c2                	mov    %eax,%edx
f0103cdd:	89 d0                	mov    %edx,%eax
f0103cdf:	c1 e0 02             	shl    $0x2,%eax
f0103ce2:	01 d0                	add    %edx,%eax
f0103ce4:	c1 e0 02             	shl    $0x2,%eax
f0103ce7:	01 d0                	add    %edx,%eax
f0103ce9:	c1 e0 02             	shl    $0x2,%eax
f0103cec:	01 d0                	add    %edx,%eax
f0103cee:	89 c1                	mov    %eax,%ecx
f0103cf0:	c1 e1 08             	shl    $0x8,%ecx
f0103cf3:	01 c8                	add    %ecx,%eax
f0103cf5:	89 c1                	mov    %eax,%ecx
f0103cf7:	c1 e1 10             	shl    $0x10,%ecx
f0103cfa:	01 c8                	add    %ecx,%eax
f0103cfc:	01 c0                	add    %eax,%eax
f0103cfe:	01 d0                	add    %edx,%eax
}
f0103d00:	5d                   	pop    %ebp
f0103d01:	c3                   	ret    

f0103d02 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103d02:	55                   	push   %ebp
f0103d03:	89 e5                	mov    %esp,%ebp
f0103d05:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103d08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103d0f:	83 ec 0c             	sub    $0xc,%esp
f0103d12:	68 90 3a 5a f0       	push   $0xf05a3a90
f0103d17:	e8 05 ae 00 00       	call   f010eb21 <acquire_spinlock>
f0103d1c:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103d1f:	a1 80 3a 5a f0       	mov    0xf05a3a80,%eax
f0103d24:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103d27:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103d2b:	75 0c                	jne    f0103d39 <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103d2d:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103d34:	e9 a2 00 00 00       	jmp    f0103ddb <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103d39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103d3d:	75 14                	jne    f0103d53 <allocate_disk_frame+0x51>
f0103d3f:	83 ec 04             	sub    $0x4,%esp
f0103d42:	68 57 6a 12 f0       	push   $0xf0126a57
f0103d47:	6a 7b                	push   $0x7b
f0103d49:	68 15 6a 12 f0       	push   $0xf0126a15
f0103d4e:	e8 c7 c5 ff ff       	call   f010031a <_panic>
f0103d53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d56:	8b 00                	mov    (%eax),%eax
f0103d58:	85 c0                	test   %eax,%eax
f0103d5a:	74 10                	je     f0103d6c <allocate_disk_frame+0x6a>
f0103d5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d5f:	8b 00                	mov    (%eax),%eax
f0103d61:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103d64:	8b 52 04             	mov    0x4(%edx),%edx
f0103d67:	89 50 04             	mov    %edx,0x4(%eax)
f0103d6a:	eb 0b                	jmp    f0103d77 <allocate_disk_frame+0x75>
f0103d6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d6f:	8b 40 04             	mov    0x4(%eax),%eax
f0103d72:	a3 84 3a 5a f0       	mov    %eax,0xf05a3a84
f0103d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d7a:	8b 40 04             	mov    0x4(%eax),%eax
f0103d7d:	85 c0                	test   %eax,%eax
f0103d7f:	74 0f                	je     f0103d90 <allocate_disk_frame+0x8e>
f0103d81:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d84:	8b 40 04             	mov    0x4(%eax),%eax
f0103d87:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103d8a:	8b 12                	mov    (%edx),%edx
f0103d8c:	89 10                	mov    %edx,(%eax)
f0103d8e:	eb 0a                	jmp    f0103d9a <allocate_disk_frame+0x98>
f0103d90:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d93:	8b 00                	mov    (%eax),%eax
f0103d95:	a3 80 3a 5a f0       	mov    %eax,0xf05a3a80
f0103d9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103da3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103da6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103dad:	a1 8c 3a 5a f0       	mov    0xf05a3a8c,%eax
f0103db2:	48                   	dec    %eax
f0103db3:	a3 8c 3a 5a f0       	mov    %eax,0xf05a3a8c
			initialize_frame_info(ptr_frame_info);
f0103db8:	83 ec 0c             	sub    $0xc,%esp
f0103dbb:	ff 75 f0             	pushl  -0x10(%ebp)
f0103dbe:	e8 f2 43 00 00       	call   f01081b5 <initialize_frame_info>
f0103dc3:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103dc6:	83 ec 0c             	sub    $0xc,%esp
f0103dc9:	ff 75 f0             	pushl  -0x10(%ebp)
f0103dcc:	e8 f9 fe ff ff       	call   f0103cca <to_disk_frame_number>
f0103dd1:	83 c4 10             	add    $0x10,%esp
f0103dd4:	89 c2                	mov    %eax,%edx
f0103dd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dd9:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ddb:	83 ec 0c             	sub    $0xc,%esp
f0103dde:	68 90 3a 5a f0       	push   $0xf05a3a90
f0103de3:	e8 c0 ad 00 00       	call   f010eba8 <release_spinlock>
f0103de8:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103deb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103dee:	c9                   	leave  
f0103def:	c3                   	ret    

f0103df0 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103df0:	55                   	push   %ebp
f0103df1:	89 e5                	mov    %esp,%ebp
f0103df3:	53                   	push   %ebx
f0103df4:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103df7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103dfb:	0f 84 ea 00 00 00    	je     f0103eeb <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e01:	83 ec 0c             	sub    $0xc,%esp
f0103e04:	68 90 3a 5a f0       	push   $0xf05a3a90
f0103e09:	e8 13 ad 00 00       	call   f010eb21 <acquire_spinlock>
f0103e0e:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103e11:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103e17:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e1a:	89 d0                	mov    %edx,%eax
f0103e1c:	01 c0                	add    %eax,%eax
f0103e1e:	01 d0                	add    %edx,%eax
f0103e20:	c1 e0 03             	shl    $0x3,%eax
f0103e23:	01 c8                	add    %ecx,%eax
f0103e25:	85 c0                	test   %eax,%eax
f0103e27:	75 17                	jne    f0103e40 <free_disk_frame+0x50>
f0103e29:	83 ec 04             	sub    $0x4,%esp
f0103e2c:	68 34 6a 12 f0       	push   $0xf0126a34
f0103e31:	68 8e 00 00 00       	push   $0x8e
f0103e36:	68 15 6a 12 f0       	push   $0xf0126a15
f0103e3b:	e8 da c4 ff ff       	call   f010031a <_panic>
f0103e40:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103e46:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e49:	89 d0                	mov    %edx,%eax
f0103e4b:	01 c0                	add    %eax,%eax
f0103e4d:	01 d0                	add    %edx,%eax
f0103e4f:	c1 e0 03             	shl    $0x3,%eax
f0103e52:	01 c8                	add    %ecx,%eax
f0103e54:	8b 15 80 3a 5a f0    	mov    0xf05a3a80,%edx
f0103e5a:	89 10                	mov    %edx,(%eax)
f0103e5c:	8b 00                	mov    (%eax),%eax
f0103e5e:	85 c0                	test   %eax,%eax
f0103e60:	74 1f                	je     f0103e81 <free_disk_frame+0x91>
f0103e62:	8b 15 80 3a 5a f0    	mov    0xf05a3a80,%edx
f0103e68:	8b 1d 60 0c 5a f0    	mov    0xf05a0c60,%ebx
f0103e6e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103e71:	89 c8                	mov    %ecx,%eax
f0103e73:	01 c0                	add    %eax,%eax
f0103e75:	01 c8                	add    %ecx,%eax
f0103e77:	c1 e0 03             	shl    $0x3,%eax
f0103e7a:	01 d8                	add    %ebx,%eax
f0103e7c:	89 42 04             	mov    %eax,0x4(%edx)
f0103e7f:	eb 19                	jmp    f0103e9a <free_disk_frame+0xaa>
f0103e81:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103e87:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e8a:	89 d0                	mov    %edx,%eax
f0103e8c:	01 c0                	add    %eax,%eax
f0103e8e:	01 d0                	add    %edx,%eax
f0103e90:	c1 e0 03             	shl    $0x3,%eax
f0103e93:	01 c8                	add    %ecx,%eax
f0103e95:	a3 84 3a 5a f0       	mov    %eax,0xf05a3a84
f0103e9a:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103ea0:	8b 55 08             	mov    0x8(%ebp),%edx
f0103ea3:	89 d0                	mov    %edx,%eax
f0103ea5:	01 c0                	add    %eax,%eax
f0103ea7:	01 d0                	add    %edx,%eax
f0103ea9:	c1 e0 03             	shl    $0x3,%eax
f0103eac:	01 c8                	add    %ecx,%eax
f0103eae:	a3 80 3a 5a f0       	mov    %eax,0xf05a3a80
f0103eb3:	8b 0d 60 0c 5a f0    	mov    0xf05a0c60,%ecx
f0103eb9:	8b 55 08             	mov    0x8(%ebp),%edx
f0103ebc:	89 d0                	mov    %edx,%eax
f0103ebe:	01 c0                	add    %eax,%eax
f0103ec0:	01 d0                	add    %edx,%eax
f0103ec2:	c1 e0 03             	shl    $0x3,%eax
f0103ec5:	01 c8                	add    %ecx,%eax
f0103ec7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ece:	a1 8c 3a 5a f0       	mov    0xf05a3a8c,%eax
f0103ed3:	40                   	inc    %eax
f0103ed4:	a3 8c 3a 5a f0       	mov    %eax,0xf05a3a8c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ed9:	83 ec 0c             	sub    $0xc,%esp
f0103edc:	68 90 3a 5a f0       	push   $0xf05a3a90
f0103ee1:	e8 c2 ac 00 00       	call   f010eba8 <release_spinlock>
f0103ee6:	83 c4 10             	add    $0x10,%esp
f0103ee9:	eb 01                	jmp    f0103eec <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103eeb:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103eec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103eef:	c9                   	leave  
f0103ef0:	c3                   	ret    

f0103ef1 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103ef1:	55                   	push   %ebp
f0103ef2:	89 e5                	mov    %esp,%ebp
f0103ef4:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103ef7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103efa:	c1 e8 16             	shr    $0x16,%eax
f0103efd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103f04:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f07:	01 d0                	add    %edx,%eax
f0103f09:	8b 00                	mov    (%eax),%eax
f0103f0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0103f0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103f11:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103f16:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103f1c:	c1 e8 0c             	shr    $0xc,%eax
f0103f1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103f22:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0103f27:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0103f2a:	72 17                	jb     f0103f43 <get_disk_page_table+0x52>
f0103f2c:	ff 75 f0             	pushl  -0x10(%ebp)
f0103f2f:	68 78 6a 12 f0       	push   $0xf0126a78
f0103f34:	68 9d 00 00 00       	push   $0x9d
f0103f39:	68 15 6a 12 f0       	push   $0xf0126a15
f0103f3e:	e8 d7 c3 ff ff       	call   f010031a <_panic>
f0103f43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103f46:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103f4b:	89 c2                	mov    %eax,%edx
f0103f4d:	8b 45 14             	mov    0x14(%ebp),%eax
f0103f50:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0103f52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103f56:	0f 85 b7 00 00 00    	jne    f0104013 <get_disk_page_table+0x122>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0103f5c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0103f60:	0f 84 9d 00 00 00    	je     f0104003 <get_disk_page_table+0x112>
						,PERM_PRESENT);
			}
#else
			{
				struct FrameInfo* ptr_frame_info;
				allocate_frame(&ptr_frame_info) ;
f0103f66:	83 ec 0c             	sub    $0xc,%esp
f0103f69:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0103f6c:	50                   	push   %eax
f0103f6d:	e8 5e 42 00 00       	call   f01081d0 <allocate_frame>
f0103f72:	83 c4 10             	add    $0x10,%esp

				//LOG_STATMENT(cprintf("created table"));
				uint32 phys_page_table = to_physical_address(ptr_frame_info);
f0103f75:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103f78:	83 ec 0c             	sub    $0xc,%esp
f0103f7b:	50                   	push   %eax
f0103f7c:	e8 4c fb ff ff       	call   f0103acd <to_physical_address>
f0103f81:	83 c4 10             	add    $0x10,%esp
f0103f84:	89 45 e8             	mov    %eax,-0x18(%ebp)
				*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0103f87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103f8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103f8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103f90:	c1 e8 0c             	shr    $0xc,%eax
f0103f93:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0103f96:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0103f9b:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f0103f9e:	72 17                	jb     f0103fb7 <get_disk_page_table+0xc6>
f0103fa0:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103fa3:	68 78 6a 12 f0       	push   $0xf0126a78
f0103fa8:	68 b9 00 00 00       	push   $0xb9
f0103fad:	68 15 6a 12 f0       	push   $0xf0126a15
f0103fb2:	e8 63 c3 ff ff       	call   f010031a <_panic>
f0103fb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103fba:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103fbf:	89 c2                	mov    %eax,%edx
f0103fc1:	8b 45 14             	mov    0x14(%ebp),%eax
f0103fc4:	89 10                	mov    %edx,(%eax)
				ptr_frame_info->references = 1;
f0103fc6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103fc9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
f0103fcf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fd2:	c1 e8 16             	shr    $0x16,%eax
f0103fd5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103fdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fdf:	01 d0                	add    %edx,%eax
f0103fe1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0103fe4:	83 ca 01             	or     $0x1,%edx
f0103fe7:	89 10                	mov    %edx,(%eax)
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0103fe9:	8b 45 14             	mov    0x14(%ebp),%eax
f0103fec:	8b 00                	mov    (%eax),%eax
f0103fee:	83 ec 04             	sub    $0x4,%esp
f0103ff1:	68 00 10 00 00       	push   $0x1000
f0103ff6:	6a 00                	push   $0x0
f0103ff8:	50                   	push   %eax
f0103ff9:	e8 c5 e7 01 00       	call   f01227c3 <memset>
f0103ffe:	83 c4 10             	add    $0x10,%esp
f0104001:	eb 10                	jmp    f0104013 <get_disk_page_table+0x122>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f0104003:	8b 45 14             	mov    0x14(%ebp),%eax
f0104006:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f010400c:	b8 00 00 00 00       	mov    $0x0,%eax
f0104011:	eb 05                	jmp    f0104018 <get_disk_page_table+0x127>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f0104013:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104018:	c9                   	leave  
f0104019:	c3                   	ret    

f010401a <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f010401a:	55                   	push   %ebp
f010401b:	89 e5                	mov    %esp,%ebp
f010401d:	83 ec 28             	sub    $0x28,%esp
f0104020:	8b 45 10             	mov    0x10(%ebp),%eax
f0104023:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0104026:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f010402a:	74 72                	je     f010409e <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f010402c:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104033:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104036:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010403b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010403e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104041:	ba 00 00 00 00       	mov    $0x0,%edx
f0104046:	f7 75 f4             	divl   -0xc(%ebp)
f0104049:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010404c:	29 d0                	sub    %edx,%eax
f010404e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104051:	73 2f                	jae    f0104082 <pf_add_empty_env_page+0x68>
f0104053:	8b 45 08             	mov    0x8(%ebp),%eax
f0104056:	8b 50 6c             	mov    0x6c(%eax),%edx
f0104059:	b8 00 00 00 00       	mov    $0x0,%eax
f010405e:	29 d0                	sub    %edx,%eax
f0104060:	c1 e0 0c             	shl    $0xc,%eax
f0104063:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0104068:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010406b:	76 15                	jbe    f0104082 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f010406d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104070:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f0104076:	8d 50 01             	lea    0x1(%eax),%edx
f0104079:	8b 45 08             	mov    0x8(%ebp),%eax
f010407c:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104082:	a1 54 39 5a f0       	mov    0xf05a3954,%eax
f0104087:	83 ec 04             	sub    $0x4,%esp
f010408a:	50                   	push   %eax
f010408b:	ff 75 0c             	pushl  0xc(%ebp)
f010408e:	ff 75 08             	pushl  0x8(%ebp)
f0104091:	e8 b2 00 00 00       	call   f0104148 <pf_add_env_page>
f0104096:	83 c4 10             	add    $0x10,%esp
f0104099:	e9 a8 00 00 00       	jmp    f0104146 <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010409e:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01040a5:	76 19                	jbe    f01040c0 <pf_add_empty_env_page+0xa6>
f01040a7:	68 a8 6a 12 f0       	push   $0xf0126aa8
f01040ac:	68 ce 6a 12 f0       	push   $0xf0126ace
f01040b1:	68 dc 00 00 00       	push   $0xdc
f01040b6:	68 15 6a 12 f0       	push   $0xf0126a15
f01040bb:	e8 5a c2 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01040c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040c3:	83 c0 74             	add    $0x74,%eax
f01040c6:	83 ec 08             	sub    $0x8,%esp
f01040c9:	50                   	push   %eax
f01040ca:	ff 75 08             	pushl  0x8(%ebp)
f01040cd:	e8 ce 05 00 00       	call   f01046a0 <get_disk_page_directory>
f01040d2:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01040d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01040d8:	8b 40 74             	mov    0x74(%eax),%eax
f01040db:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01040de:	52                   	push   %edx
f01040df:	6a 01                	push   $0x1
f01040e1:	ff 75 0c             	pushl  0xc(%ebp)
f01040e4:	50                   	push   %eax
f01040e5:	e8 07 fe ff ff       	call   f0103ef1 <get_disk_page_table>
f01040ea:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01040ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01040f0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01040f3:	c1 ea 0c             	shr    $0xc,%edx
f01040f6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01040fc:	c1 e2 02             	shl    $0x2,%edx
f01040ff:	01 d0                	add    %edx,%eax
f0104101:	8b 00                	mov    (%eax),%eax
f0104103:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f0104106:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104109:	85 c0                	test   %eax,%eax
f010410b:	75 34                	jne    f0104141 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010410d:	83 ec 0c             	sub    $0xc,%esp
f0104110:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0104113:	50                   	push   %eax
f0104114:	e8 e9 fb ff ff       	call   f0103d02 <allocate_disk_frame>
f0104119:	83 c4 10             	add    $0x10,%esp
f010411c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010411f:	75 07                	jne    f0104128 <pf_add_empty_env_page+0x10e>
f0104121:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104126:	eb 1e                	jmp    f0104146 <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104128:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010412b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010412e:	c1 ea 0c             	shr    $0xc,%edx
f0104131:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104137:	c1 e2 02             	shl    $0x2,%edx
f010413a:	01 c2                	add    %eax,%edx
f010413c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010413f:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0104141:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0104146:	c9                   	leave  
f0104147:	c3                   	ret    

f0104148 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104148:	55                   	push   %ebp
f0104149:	89 e5                	mov    %esp,%ebp
f010414b:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010414e:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104155:	76 19                	jbe    f0104170 <pf_add_env_page+0x28>
f0104157:	68 a8 6a 12 f0       	push   $0xf0126aa8
f010415c:	68 ce 6a 12 f0       	push   $0xf0126ace
f0104161:	68 f1 00 00 00       	push   $0xf1
f0104166:	68 15 6a 12 f0       	push   $0xf0126a15
f010416b:	e8 aa c1 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104170:	8b 45 08             	mov    0x8(%ebp),%eax
f0104173:	83 c0 74             	add    $0x74,%eax
f0104176:	83 ec 08             	sub    $0x8,%esp
f0104179:	50                   	push   %eax
f010417a:	ff 75 08             	pushl  0x8(%ebp)
f010417d:	e8 1e 05 00 00       	call   f01046a0 <get_disk_page_directory>
f0104182:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0104185:	8b 45 08             	mov    0x8(%ebp),%eax
f0104188:	8b 40 74             	mov    0x74(%eax),%eax
f010418b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010418e:	52                   	push   %edx
f010418f:	6a 01                	push   $0x1
f0104191:	ff 75 0c             	pushl  0xc(%ebp)
f0104194:	50                   	push   %eax
f0104195:	e8 57 fd ff ff       	call   f0103ef1 <get_disk_page_table>
f010419a:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010419d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041a0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041a3:	c1 ea 0c             	shr    $0xc,%edx
f01041a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041ac:	c1 e2 02             	shl    $0x2,%edx
f01041af:	01 d0                	add    %edx,%eax
f01041b1:	8b 00                	mov    (%eax),%eax
f01041b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01041b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041b9:	85 c0                	test   %eax,%eax
f01041bb:	75 34                	jne    f01041f1 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041bd:	83 ec 0c             	sub    $0xc,%esp
f01041c0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01041c3:	50                   	push   %eax
f01041c4:	e8 39 fb ff ff       	call   f0103d02 <allocate_disk_frame>
f01041c9:	83 c4 10             	add    $0x10,%esp
f01041cc:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01041cf:	75 07                	jne    f01041d8 <pf_add_env_page+0x90>
f01041d1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01041d6:	eb 31                	jmp    f0104209 <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01041d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041db:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041de:	c1 ea 0c             	shr    $0xc,%edx
f01041e1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e7:	c1 e2 02             	shl    $0x2,%edx
f01041ea:	01 c2                	add    %eax,%edx
f01041ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041ef:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01041f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041f4:	83 ec 08             	sub    $0x8,%esp
f01041f7:	ff 75 10             	pushl  0x10(%ebp)
f01041fa:	50                   	push   %eax
f01041fb:	e8 55 f9 ff ff       	call   f0103b55 <write_disk_page>
f0104200:	83 c4 10             	add    $0x10,%esp
f0104203:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f0104206:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104209:	c9                   	leave  
f010420a:	c3                   	ret    

f010420b <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f010420b:	55                   	push   %ebp
f010420c:	89 e5                	mov    %esp,%ebp
f010420e:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f0104211:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104218:	76 19                	jbe    f0104233 <pf_update_env_page+0x28>
f010421a:	68 a8 6a 12 f0       	push   $0xf0126aa8
f010421f:	68 ce 6a 12 f0       	push   $0xf0126ace
f0104224:	68 13 01 00 00       	push   $0x113
f0104229:	68 15 6a 12 f0       	push   $0xf0126a15
f010422e:	e8 e7 c0 ff ff       	call   f010031a <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104233:	8b 45 08             	mov    0x8(%ebp),%eax
f0104236:	83 c0 74             	add    $0x74,%eax
f0104239:	83 ec 08             	sub    $0x8,%esp
f010423c:	50                   	push   %eax
f010423d:	ff 75 08             	pushl  0x8(%ebp)
f0104240:	e8 5b 04 00 00       	call   f01046a0 <get_disk_page_directory>
f0104245:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104248:	8b 45 08             	mov    0x8(%ebp),%eax
f010424b:	8b 40 74             	mov    0x74(%eax),%eax
f010424e:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0104251:	52                   	push   %edx
f0104252:	6a 00                	push   $0x0
f0104254:	ff 75 0c             	pushl  0xc(%ebp)
f0104257:	50                   	push   %eax
f0104258:	e8 94 fc ff ff       	call   f0103ef1 <get_disk_page_table>
f010425d:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104260:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104263:	85 c0                	test   %eax,%eax
f0104265:	74 29                	je     f0104290 <pf_update_env_page+0x85>
f0104267:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010426a:	85 c0                	test   %eax,%eax
f010426c:	0f 84 c5 00 00 00    	je     f0104337 <pf_update_env_page+0x12c>
f0104272:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104275:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104278:	c1 ea 0c             	shr    $0xc,%edx
f010427b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104281:	c1 e2 02             	shl    $0x2,%edx
f0104284:	01 d0                	add    %edx,%eax
f0104286:	8b 00                	mov    (%eax),%eax
f0104288:	85 c0                	test   %eax,%eax
f010428a:	0f 85 a7 00 00 00    	jne    f0104337 <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0104290:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104293:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104296:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104299:	85 c0                	test   %eax,%eax
f010429b:	79 09                	jns    f01042a6 <pf_update_env_page+0x9b>
f010429d:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f01042a4:	76 30                	jbe    f01042d6 <pf_update_env_page+0xcb>
f01042a6:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01042ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042b0:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01042b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01042b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042bb:	ba 00 00 00 00       	mov    $0x0,%edx
f01042c0:	f7 75 f0             	divl   -0x10(%ebp)
f01042c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042c6:	29 d0                	sub    %edx,%eax
f01042c8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01042cb:	77 53                	ja     f0104320 <pf_update_env_page+0x115>
f01042cd:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01042d4:	77 4a                	ja     f0104320 <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01042d6:	83 ec 04             	sub    $0x4,%esp
f01042d9:	6a 00                	push   $0x0
f01042db:	ff 75 f4             	pushl  -0xc(%ebp)
f01042de:	ff 75 08             	pushl  0x8(%ebp)
f01042e1:	e8 34 fd ff ff       	call   f010401a <pf_add_empty_env_page>
f01042e6:	83 c4 10             	add    $0x10,%esp
f01042e9:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01042ec:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01042f0:	75 17                	jne    f0104309 <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01042f2:	83 ec 04             	sub    $0x4,%esp
f01042f5:	68 e4 6a 12 f0       	push   $0xf0126ae4
f01042fa:	68 43 01 00 00       	push   $0x143
f01042ff:	68 15 6a 12 f0       	push   $0xf0126a15
f0104304:	e8 11 c0 ff ff       	call   f010031a <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f0104309:	8b 45 08             	mov    0x8(%ebp),%eax
f010430c:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f0104312:	8d 50 01             	lea    0x1(%eax),%edx
f0104315:	8b 45 08             	mov    0x8(%ebp),%eax
f0104318:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
f010431e:	eb 17                	jmp    f0104337 <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f0104320:	83 ec 04             	sub    $0x4,%esp
f0104323:	68 30 6b 12 f0       	push   $0xf0126b30
f0104328:	68 4c 01 00 00       	push   $0x14c
f010432d:	68 15 6a 12 f0       	push   $0xf0126a15
f0104332:	e8 e3 bf ff ff       	call   f010031a <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104337:	8b 45 08             	mov    0x8(%ebp),%eax
f010433a:	8b 40 74             	mov    0x74(%eax),%eax
f010433d:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 a5 fb ff ff       	call   f0103ef1 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010434f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104352:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104355:	c1 ea 0c             	shr    $0xc,%edx
f0104358:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010435e:	c1 e2 02             	shl    $0x2,%edx
f0104361:	01 d0                	add    %edx,%eax
f0104363:	8b 00                	mov    (%eax),%eax
f0104365:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//cprintf("[%s] updating page\n",ptr_env->prog_name);
	}
#else
	{
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
f0104368:	83 ec 0c             	sub    $0xc,%esp
f010436b:	ff 75 10             	pushl  0x10(%ebp)
f010436e:	e8 5a f7 ff ff       	call   f0103acd <to_physical_address>
f0104373:	83 c4 10             	add    $0x10,%esp
f0104376:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0104379:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010437c:	c1 e8 0c             	shr    $0xc,%eax
f010437f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0104382:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0104387:	39 45 dc             	cmp    %eax,-0x24(%ebp)
f010438a:	72 17                	jb     f01043a3 <pf_update_env_page+0x198>
f010438c:	ff 75 e0             	pushl  -0x20(%ebp)
f010438f:	68 78 6a 12 f0       	push   $0xf0126a78
f0104394:	68 68 01 00 00       	push   $0x168
f0104399:	68 15 6a 12 f0       	push   $0xf0126a15
f010439e:	e8 77 bf ff ff       	call   f010031a <_panic>
f01043a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01043a6:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01043ab:	83 ec 08             	sub    $0x8,%esp
f01043ae:	50                   	push   %eax
f01043af:	ff 75 e4             	pushl  -0x1c(%ebp)
f01043b2:	e8 9e f7 ff ff       	call   f0103b55 <write_disk_page>
f01043b7:	83 c4 10             	add    $0x10,%esp
f01043ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01043bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01043c0:	8b 80 60 da 01 00    	mov    0x1da60(%eax),%eax
f01043c6:	8d 50 01             	lea    0x1(%eax),%edx
f01043c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01043cc:	89 90 60 da 01 00    	mov    %edx,0x1da60(%eax)
	//======================

	return ret;
f01043d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01043d5:	c9                   	leave  
f01043d6:	c3                   	ret    

f01043d7 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01043d7:	55                   	push   %ebp
f01043d8:	89 e5                	mov    %esp,%ebp
f01043da:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01043dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01043e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01043e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01043eb:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01043ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01043f1:	8b 40 74             	mov    0x74(%eax),%eax
f01043f4:	85 c0                	test   %eax,%eax
f01043f6:	75 0a                	jne    f0104402 <pf_read_env_page+0x2b>
f01043f8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01043fd:	e9 90 00 00 00       	jmp    f0104492 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f0104402:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104405:	8b 45 08             	mov    0x8(%ebp),%eax
f0104408:	8b 40 74             	mov    0x74(%eax),%eax
f010440b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010440e:	51                   	push   %ecx
f010440f:	6a 00                	push   $0x0
f0104411:	52                   	push   %edx
f0104412:	50                   	push   %eax
f0104413:	e8 d9 fa ff ff       	call   f0103ef1 <get_disk_page_table>
f0104418:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010441b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010441e:	85 c0                	test   %eax,%eax
f0104420:	75 07                	jne    f0104429 <pf_read_env_page+0x52>
f0104422:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104427:	eb 69                	jmp    f0104492 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104429:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010442c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010442f:	c1 ea 0c             	shr    $0xc,%edx
f0104432:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104438:	c1 e2 02             	shl    $0x2,%edx
f010443b:	01 d0                	add    %edx,%eax
f010443d:	8b 00                	mov    (%eax),%eax
f010443f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104442:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104446:	75 07                	jne    f010444f <pf_read_env_page+0x78>
f0104448:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010444d:	eb 43                	jmp    f0104492 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010444f:	83 ec 08             	sub    $0x8,%esp
f0104452:	ff 75 0c             	pushl  0xc(%ebp)
f0104455:	ff 75 f0             	pushl  -0x10(%ebp)
f0104458:	e8 c9 f6 ff ff       	call   f0103b26 <read_disk_page>
f010445d:	83 c4 10             	add    $0x10,%esp
f0104460:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104463:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104466:	8b 45 08             	mov    0x8(%ebp),%eax
f0104469:	8b 40 64             	mov    0x64(%eax),%eax
f010446c:	6a 40                	push   $0x40
f010446e:	6a 00                	push   $0x0
f0104470:	52                   	push   %edx
f0104471:	50                   	push   %eax
f0104472:	e8 b1 46 00 00       	call   f0108b28 <pt_set_page_permissions>
f0104477:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010447a:	8b 45 08             	mov    0x8(%ebp),%eax
f010447d:	8b 80 5c da 01 00    	mov    0x1da5c(%eax),%eax
f0104483:	8d 50 01             	lea    0x1(%eax),%edx
f0104486:	8b 45 08             	mov    0x8(%ebp),%eax
f0104489:	89 90 5c da 01 00    	mov    %edx,0x1da5c(%eax)
	//======================

	return disk_read_error;
f010448f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104492:	c9                   	leave  
f0104493:	c3                   	ret    

f0104494 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104494:	55                   	push   %ebp
f0104495:	89 e5                	mov    %esp,%ebp
f0104497:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010449a:	8b 45 08             	mov    0x8(%ebp),%eax
f010449d:	8b 40 74             	mov    0x74(%eax),%eax
f01044a0:	85 c0                	test   %eax,%eax
f01044a2:	74 62                	je     f0104506 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01044a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a7:	8b 40 74             	mov    0x74(%eax),%eax
f01044aa:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01044ad:	52                   	push   %edx
f01044ae:	6a 00                	push   $0x0
f01044b0:	ff 75 0c             	pushl  0xc(%ebp)
f01044b3:	50                   	push   %eax
f01044b4:	e8 38 fa ff ff       	call   f0103ef1 <get_disk_page_table>
f01044b9:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01044bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044bf:	85 c0                	test   %eax,%eax
f01044c1:	74 46                	je     f0104509 <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01044c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044c6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044c9:	c1 ea 0c             	shr    $0xc,%edx
f01044cc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044d2:	c1 e2 02             	shl    $0x2,%edx
f01044d5:	01 d0                	add    %edx,%eax
f01044d7:	8b 00                	mov    (%eax),%eax
f01044d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01044dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044df:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044e2:	c1 ea 0c             	shr    $0xc,%edx
f01044e5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044eb:	c1 e2 02             	shl    $0x2,%edx
f01044ee:	01 d0                	add    %edx,%eax
f01044f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01044f6:	83 ec 0c             	sub    $0xc,%esp
f01044f9:	ff 75 f4             	pushl  -0xc(%ebp)
f01044fc:	e8 ef f8 ff ff       	call   f0103df0 <free_disk_frame>
f0104501:	83 c4 10             	add    $0x10,%esp
f0104504:	eb 04                	jmp    f010450a <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104506:	90                   	nop
f0104507:	eb 01                	jmp    f010450a <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f0104509:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f010450a:	c9                   	leave  
f010450b:	c3                   	ret    

f010450c <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f010450c:	55                   	push   %ebp
f010450d:	89 e5                	mov    %esp,%ebp
f010450f:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104512:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104519:	e9 ee 00 00 00       	jmp    f010460c <pf_free_env+0x100>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f010451e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104521:	8b 40 74             	mov    0x74(%eax),%eax
f0104524:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104527:	c1 e2 02             	shl    $0x2,%edx
f010452a:	01 d0                	add    %edx,%eax
f010452c:	8b 00                	mov    (%eax),%eax
f010452e:	83 e0 01             	and    $0x1,%eax
f0104531:	85 c0                	test   %eax,%eax
f0104533:	0f 84 cf 00 00 00    	je     f0104608 <pf_free_env+0xfc>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104539:	8b 45 08             	mov    0x8(%ebp),%eax
f010453c:	8b 40 74             	mov    0x74(%eax),%eax
f010453f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104542:	c1 e2 02             	shl    $0x2,%edx
f0104545:	01 d0                	add    %edx,%eax
f0104547:	8b 00                	mov    (%eax),%eax
f0104549:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010454e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f0104551:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104554:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0104557:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010455a:	c1 e8 0c             	shr    $0xc,%eax
f010455d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104560:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0104565:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0104568:	72 17                	jb     f0104581 <pf_free_env+0x75>
f010456a:	ff 75 e8             	pushl  -0x18(%ebp)
f010456d:	68 78 6a 12 f0       	push   $0xf0126a78
f0104572:	68 c8 01 00 00       	push   $0x1c8
f0104577:	68 15 6a 12 f0       	push   $0xf0126a15
f010457c:	e8 99 bd ff ff       	call   f010031a <_panic>
f0104581:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104584:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104589:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010458c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104593:	eb 3a                	jmp    f01045cf <pf_free_env+0xc3>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104595:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104598:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010459f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01045a2:	01 d0                	add    %edx,%eax
f01045a4:	8b 00                	mov    (%eax),%eax
f01045a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
			pt[pteno] = 0;
f01045a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045ac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01045b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01045b6:	01 d0                	add    %edx,%eax
f01045b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01045be:	83 ec 0c             	sub    $0xc,%esp
f01045c1:	ff 75 dc             	pushl  -0x24(%ebp)
f01045c4:	e8 27 f8 ff ff       	call   f0103df0 <free_disk_frame>
f01045c9:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01045cc:	ff 45 f0             	incl   -0x10(%ebp)
f01045cf:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01045d6:	76 bd                	jbe    f0104595 <pf_free_env+0x89>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01045d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01045db:	8b 40 74             	mov    0x74(%eax),%eax
f01045de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01045e1:	c1 e2 02             	shl    $0x2,%edx
f01045e4:	01 d0                	add    %edx,%eax
f01045e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		{
			kfree(pt);
		}
#else
		{
			decrement_references(to_frame_info(pa));
f01045ec:	83 ec 0c             	sub    $0xc,%esp
f01045ef:	ff 75 ec             	pushl  -0x14(%ebp)
f01045f2:	e8 e9 f4 ff ff       	call   f0103ae0 <to_frame_info>
f01045f7:	83 c4 10             	add    $0x10,%esp
f01045fa:	83 ec 0c             	sub    $0xc,%esp
f01045fd:	50                   	push   %eax
f01045fe:	e8 da 3d 00 00       	call   f01083dd <decrement_references>
f0104603:	83 c4 10             	add    $0x10,%esp
f0104606:	eb 01                	jmp    f0104609 <pf_free_env+0xfd>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0104608:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104609:	ff 45 f4             	incl   -0xc(%ebp)
f010460c:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104613:	0f 86 05 ff ff ff    	jbe    f010451e <pf_free_env+0x12>
	{
		kfree(ptr_env->disk_env_pgdir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
f0104619:	8b 45 08             	mov    0x8(%ebp),%eax
f010461c:	8b 40 78             	mov    0x78(%eax),%eax
f010461f:	83 ec 0c             	sub    $0xc,%esp
f0104622:	50                   	push   %eax
f0104623:	e8 b8 f4 ff ff       	call   f0103ae0 <to_frame_info>
f0104628:	83 c4 10             	add    $0x10,%esp
f010462b:	83 ec 0c             	sub    $0xc,%esp
f010462e:	50                   	push   %eax
f010462f:	e8 a9 3d 00 00       	call   f01083dd <decrement_references>
f0104634:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104637:	8b 45 08             	mov    0x8(%ebp),%eax
f010463a:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f0104641:	8b 45 08             	mov    0x8(%ebp),%eax
f0104644:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f010464b:	8b 45 08             	mov    0x8(%ebp),%eax
f010464e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104651:	85 c0                	test   %eax,%eax
f0104653:	74 48                	je     f010469d <pf_free_env+0x191>
		return;
	__pf_remove_env_all_tables(ptr_env);
f0104655:	83 ec 0c             	sub    $0xc,%esp
f0104658:	ff 75 08             	pushl  0x8(%ebp)
f010465b:	e8 dd 03 00 00       	call   f0104a3d <__pf_remove_env_all_tables>
f0104660:	83 c4 10             	add    $0x10,%esp
	{
		kfree(ptr_env->disk_env_tabledir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
f0104663:	8b 45 08             	mov    0x8(%ebp),%eax
f0104666:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010466c:	83 ec 0c             	sub    $0xc,%esp
f010466f:	50                   	push   %eax
f0104670:	e8 6b f4 ff ff       	call   f0103ae0 <to_frame_info>
f0104675:	83 c4 10             	add    $0x10,%esp
f0104678:	83 ec 0c             	sub    $0xc,%esp
f010467b:	50                   	push   %eax
f010467c:	e8 5c 3d 00 00       	call   f01083dd <decrement_references>
f0104681:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104684:	8b 45 08             	mov    0x8(%ebp),%eax
f0104687:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f010468e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104691:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104698:	00 00 00 
f010469b:	eb 01                	jmp    f010469e <pf_free_env+0x192>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010469d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010469e:	c9                   	leave  
f010469f:	c3                   	ret    

f01046a0 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f01046a0:	55                   	push   %ebp
f01046a1:	89 e5                	mov    %esp,%ebp
f01046a3:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f01046a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01046a9:	8b 50 74             	mov    0x74(%eax),%edx
f01046ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01046af:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f01046b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01046b4:	8b 00                	mov    (%eax),%eax
f01046b6:	85 c0                	test   %eax,%eax
f01046b8:	0f 85 aa 00 00 00    	jne    f0104768 <get_disk_page_directory+0xc8>
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f01046be:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f01046c5:	83 ec 0c             	sub    $0xc,%esp
f01046c8:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01046cb:	50                   	push   %eax
f01046cc:	e8 ff 3a 00 00       	call   f01081d0 <allocate_frame>
f01046d1:	83 c4 10             	add    $0x10,%esp
f01046d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01046d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01046db:	79 08                	jns    f01046e5 <get_disk_page_directory+0x45>
				return r;
f01046dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01046e0:	e9 88 00 00 00       	jmp    f010476d <get_disk_page_directory+0xcd>
			p->references = 1;
f01046e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046e8:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f01046ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046f1:	83 ec 0c             	sub    $0xc,%esp
f01046f4:	50                   	push   %eax
f01046f5:	e8 d3 f3 ff ff       	call   f0103acd <to_physical_address>
f01046fa:	83 c4 10             	add    $0x10,%esp
f01046fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104700:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104703:	c1 e8 0c             	shr    $0xc,%eax
f0104706:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104709:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f010470e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104711:	72 17                	jb     f010472a <get_disk_page_directory+0x8a>
f0104713:	ff 75 f0             	pushl  -0x10(%ebp)
f0104716:	68 78 6a 12 f0       	push   $0xf0126a78
f010471b:	68 20 02 00 00       	push   $0x220
f0104720:	68 15 6a 12 f0       	push   $0xf0126a15
f0104725:	e8 f0 bb ff ff       	call   f010031a <_panic>
f010472a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010472d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104732:	89 c2                	mov    %eax,%edx
f0104734:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104737:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
f0104739:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010473c:	83 ec 0c             	sub    $0xc,%esp
f010473f:	50                   	push   %eax
f0104740:	e8 88 f3 ff ff       	call   f0103acd <to_physical_address>
f0104745:	83 c4 10             	add    $0x10,%esp
f0104748:	89 c2                	mov    %eax,%edx
f010474a:	8b 45 08             	mov    0x8(%ebp),%eax
f010474d:	89 50 78             	mov    %edx,0x78(%eax)
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f0104750:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104753:	8b 00                	mov    (%eax),%eax
f0104755:	83 ec 04             	sub    $0x4,%esp
f0104758:	68 00 10 00 00       	push   $0x1000
f010475d:	6a 00                	push   $0x0
f010475f:	50                   	push   %eax
f0104760:	e8 5e e0 01 00       	call   f01227c3 <memset>
f0104765:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104768:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010476d:	c9                   	leave  
f010476e:	c3                   	ret    

f010476f <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f010476f:	55                   	push   %ebp
f0104770:	89 e5                	mov    %esp,%ebp
f0104772:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104775:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010477c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104783:	e9 a6 00 00 00       	jmp    f010482e <pf_calculate_allocated_pages+0xbf>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104788:	8b 45 08             	mov    0x8(%ebp),%eax
f010478b:	8b 40 74             	mov    0x74(%eax),%eax
f010478e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104791:	c1 e2 02             	shl    $0x2,%edx
f0104794:	01 d0                	add    %edx,%eax
f0104796:	8b 00                	mov    (%eax),%eax
f0104798:	83 e0 01             	and    $0x1,%eax
f010479b:	85 c0                	test   %eax,%eax
f010479d:	0f 84 87 00 00 00    	je     f010482a <pf_calculate_allocated_pages+0xbb>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01047a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a6:	8b 40 74             	mov    0x74(%eax),%eax
f01047a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01047ac:	c1 e2 02             	shl    $0x2,%edx
f01047af:	01 d0                	add    %edx,%eax
f01047b1:	8b 00                	mov    (%eax),%eax
f01047b3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01047b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f01047bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01047be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01047c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01047c4:	c1 e8 0c             	shr    $0xc,%eax
f01047c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01047ca:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f01047cf:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f01047d2:	72 17                	jb     f01047eb <pf_calculate_allocated_pages+0x7c>
f01047d4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01047d7:	68 78 6a 12 f0       	push   $0xf0126a78
f01047dc:	68 40 02 00 00       	push   $0x240
f01047e1:	68 15 6a 12 f0       	push   $0xf0126a15
f01047e6:	e8 2f bb ff ff       	call   f010031a <_panic>
f01047eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01047ee:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01047f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01047f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01047fd:	eb 20                	jmp    f010481f <pf_calculate_allocated_pages+0xb0>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f01047ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104802:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104809:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010480c:	01 d0                	add    %edx,%eax
f010480e:	8b 00                	mov    (%eax),%eax
f0104810:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if(dfn != 0)
f0104813:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0104817:	74 03                	je     f010481c <pf_calculate_allocated_pages+0xad>
				counter ++;
f0104819:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010481c:	ff 45 ec             	incl   -0x14(%ebp)
f010481f:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104826:	76 d7                	jbe    f01047ff <pf_calculate_allocated_pages+0x90>
f0104828:	eb 01                	jmp    f010482b <pf_calculate_allocated_pages+0xbc>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010482a:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010482b:	ff 45 f4             	incl   -0xc(%ebp)
f010482e:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104835:	0f 86 4d ff ff ff    	jbe    f0104788 <pf_calculate_allocated_pages+0x19>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f010483b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010483e:	c9                   	leave  
f010483f:	c3                   	ret    

f0104840 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104840:	55                   	push   %ebp
f0104841:	89 e5                	mov    %esp,%ebp
f0104843:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104846:	83 ec 0c             	sub    $0xc,%esp
f0104849:	68 90 3a 5a f0       	push   $0xf05a3a90
f010484e:	e8 ce a2 00 00       	call   f010eb21 <acquire_spinlock>
f0104853:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104856:	a1 8c 3a 5a f0       	mov    0xf05a3a8c,%eax
f010485b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f010485e:	83 ec 0c             	sub    $0xc,%esp
f0104861:	68 90 3a 5a f0       	push   $0xf05a3a90
f0104866:	e8 3d a3 00 00       	call   f010eba8 <release_spinlock>
f010486b:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f010486e:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104871:	c9                   	leave  
f0104872:	c3                   	ret    

f0104873 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104873:	55                   	push   %ebp
f0104874:	89 e5                	mov    %esp,%ebp
f0104876:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104879:	8b 45 08             	mov    0x8(%ebp),%eax
f010487c:	8b 50 7c             	mov    0x7c(%eax),%edx
f010487f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104882:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104884:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104887:	8b 00                	mov    (%eax),%eax
f0104889:	85 c0                	test   %eax,%eax
f010488b:	0f 85 ad 00 00 00    	jne    f010493e <get_disk_table_directory+0xcb>
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f0104891:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f0104898:	83 ec 0c             	sub    $0xc,%esp
f010489b:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010489e:	50                   	push   %eax
f010489f:	e8 2c 39 00 00       	call   f01081d0 <allocate_frame>
f01048a4:	83 c4 10             	add    $0x10,%esp
f01048a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01048aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01048ae:	79 08                	jns    f01048b8 <get_disk_table_directory+0x45>
				return r;
f01048b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01048b3:	e9 8b 00 00 00       	jmp    f0104943 <get_disk_table_directory+0xd0>
			p->references = 1;
f01048b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01048bb:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f01048c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01048c4:	83 ec 0c             	sub    $0xc,%esp
f01048c7:	50                   	push   %eax
f01048c8:	e8 00 f2 ff ff       	call   f0103acd <to_physical_address>
f01048cd:	83 c4 10             	add    $0x10,%esp
f01048d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01048d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01048d6:	c1 e8 0c             	shr    $0xc,%eax
f01048d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01048dc:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f01048e1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01048e4:	72 17                	jb     f01048fd <get_disk_table_directory+0x8a>
f01048e6:	ff 75 f0             	pushl  -0x10(%ebp)
f01048e9:	68 78 6a 12 f0       	push   $0xf0126a78
f01048ee:	68 83 02 00 00       	push   $0x283
f01048f3:	68 15 6a 12 f0       	push   $0xf0126a15
f01048f8:	e8 1d ba ff ff       	call   f010031a <_panic>
f01048fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104900:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
f010490c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010490f:	83 ec 0c             	sub    $0xc,%esp
f0104912:	50                   	push   %eax
f0104913:	e8 b5 f1 ff ff       	call   f0103acd <to_physical_address>
f0104918:	83 c4 10             	add    $0x10,%esp
f010491b:	89 c2                	mov    %eax,%edx
f010491d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104920:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104926:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104929:	8b 00                	mov    (%eax),%eax
f010492b:	83 ec 04             	sub    $0x4,%esp
f010492e:	68 00 10 00 00       	push   $0x1000
f0104933:	6a 00                	push   $0x0
f0104935:	50                   	push   %eax
f0104936:	e8 88 de 01 00       	call   f01227c3 <memset>
f010493b:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010493e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104943:	c9                   	leave  
f0104944:	c3                   	ret    

f0104945 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104945:	55                   	push   %ebp
f0104946:	89 e5                	mov    %esp,%ebp
f0104948:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010494b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104952:	76 19                	jbe    f010496d <__pf_write_env_table+0x28>
f0104954:	68 a8 6a 12 f0       	push   $0xf0126aa8
f0104959:	68 ce 6a 12 f0       	push   $0xf0126ace
f010495e:	68 91 02 00 00       	push   $0x291
f0104963:	68 15 6a 12 f0       	push   $0xf0126a15
f0104968:	e8 ad b9 ff ff       	call   f010031a <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010496d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104970:	83 c0 7c             	add    $0x7c,%eax
f0104973:	83 ec 08             	sub    $0x8,%esp
f0104976:	50                   	push   %eax
f0104977:	ff 75 08             	pushl  0x8(%ebp)
f010497a:	e8 f4 fe ff ff       	call   f0104873 <get_disk_table_directory>
f010497f:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104982:	8b 45 08             	mov    0x8(%ebp),%eax
f0104985:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104988:	8b 55 0c             	mov    0xc(%ebp),%edx
f010498b:	c1 ea 16             	shr    $0x16,%edx
f010498e:	c1 e2 02             	shl    $0x2,%edx
f0104991:	01 d0                	add    %edx,%eax
f0104993:	8b 00                	mov    (%eax),%eax
f0104995:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104998:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010499b:	85 c0                	test   %eax,%eax
f010499d:	75 31                	jne    f01049d0 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010499f:	83 ec 0c             	sub    $0xc,%esp
f01049a2:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049a5:	50                   	push   %eax
f01049a6:	e8 57 f3 ff ff       	call   f0103d02 <allocate_disk_frame>
f01049ab:	83 c4 10             	add    $0x10,%esp
f01049ae:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049b1:	75 07                	jne    f01049ba <__pf_write_env_table+0x75>
f01049b3:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049b8:	eb 2e                	jmp    f01049e8 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01049bd:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049c0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049c3:	c1 ea 16             	shr    $0x16,%edx
f01049c6:	c1 e2 02             	shl    $0x2,%edx
f01049c9:	01 c2                	add    %eax,%edx
f01049cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ce:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049d3:	83 ec 08             	sub    $0x8,%esp
f01049d6:	ff 75 10             	pushl  0x10(%ebp)
f01049d9:	50                   	push   %eax
f01049da:	e8 76 f1 ff ff       	call   f0103b55 <write_disk_page>
f01049df:	83 c4 10             	add    $0x10,%esp
f01049e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01049e8:	c9                   	leave  
f01049e9:	c3                   	ret    

f01049ea <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01049ea:	55                   	push   %ebp
f01049eb:	89 e5                	mov    %esp,%ebp
f01049ed:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01049f3:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049f6:	85 c0                	test   %eax,%eax
f01049f8:	75 07                	jne    f0104a01 <__pf_read_env_table+0x17>
f01049fa:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049ff:	eb 3a                	jmp    f0104a3b <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a01:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a04:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a07:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a0a:	c1 ea 16             	shr    $0x16,%edx
f0104a0d:	c1 e2 02             	shl    $0x2,%edx
f0104a10:	01 d0                	add    %edx,%eax
f0104a12:	8b 00                	mov    (%eax),%eax
f0104a14:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a1b:	75 07                	jne    f0104a24 <__pf_read_env_table+0x3a>
f0104a1d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a22:	eb 17                	jmp    f0104a3b <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a24:	83 ec 08             	sub    $0x8,%esp
f0104a27:	ff 75 10             	pushl  0x10(%ebp)
f0104a2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a2d:	e8 f4 f0 ff ff       	call   f0103b26 <read_disk_page>
f0104a32:	83 c4 10             	add    $0x10,%esp
f0104a35:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a38:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a3b:	c9                   	leave  
f0104a3c:	c3                   	ret    

f0104a3d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a3d:	55                   	push   %ebp
f0104a3e:	89 e5                	mov    %esp,%ebp
f0104a40:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a43:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a46:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a49:	85 c0                	test   %eax,%eax
f0104a4b:	74 4c                	je     f0104a99 <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a54:	eb 38                	jmp    f0104a8e <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a56:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a59:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a5f:	c1 e2 02             	shl    $0x2,%edx
f0104a62:	01 d0                	add    %edx,%eax
f0104a64:	8b 00                	mov    (%eax),%eax
f0104a66:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a6c:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a72:	c1 e2 02             	shl    $0x2,%edx
f0104a75:	01 d0                	add    %edx,%eax
f0104a77:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104a7d:	83 ec 0c             	sub    $0xc,%esp
f0104a80:	ff 75 f0             	pushl  -0x10(%ebp)
f0104a83:	e8 68 f3 ff ff       	call   f0103df0 <free_disk_frame>
f0104a88:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a8b:	ff 45 f4             	incl   -0xc(%ebp)
f0104a8e:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a95:	76 bf                	jbe    f0104a56 <__pf_remove_env_all_tables+0x19>
f0104a97:	eb 01                	jmp    f0104a9a <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a99:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104a9a:	c9                   	leave  
f0104a9b:	c3                   	ret    

f0104a9c <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104a9c:	55                   	push   %ebp
f0104a9d:	89 e5                	mov    %esp,%ebp
f0104a9f:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104aa2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104aa6:	75 10                	jne    f0104ab8 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104aa8:	83 ec 0c             	sub    $0xc,%esp
f0104aab:	68 ac 6b 12 f0       	push   $0xf0126bac
f0104ab0:	e8 b7 c4 ff ff       	call   f0100f6c <cprintf>
f0104ab5:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ab8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104abb:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104abe:	85 c0                	test   %eax,%eax
f0104ac0:	74 3d                	je     f0104aff <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104ac2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ac5:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104ac8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104acb:	c1 ea 16             	shr    $0x16,%edx
f0104ace:	c1 e2 02             	shl    $0x2,%edx
f0104ad1:	01 d0                	add    %edx,%eax
f0104ad3:	8b 00                	mov    (%eax),%eax
f0104ad5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104ad8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104adb:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104ade:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ae1:	c1 ea 16             	shr    $0x16,%edx
f0104ae4:	c1 e2 02             	shl    $0x2,%edx
f0104ae7:	01 d0                	add    %edx,%eax
f0104ae9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104aef:	83 ec 0c             	sub    $0xc,%esp
f0104af2:	ff 75 f4             	pushl  -0xc(%ebp)
f0104af5:	e8 f6 f2 ff ff       	call   f0103df0 <free_disk_frame>
f0104afa:	83 c4 10             	add    $0x10,%esp
f0104afd:	eb 01                	jmp    f0104b00 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104aff:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b00:	c9                   	leave  
f0104b01:	c3                   	ret    

f0104b02 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b02:	55                   	push   %ebp
f0104b03:	89 e5                	mov    %esp,%ebp
f0104b05:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b08:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b0f:	eb 1f                	jmp    f0104b30 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b14:	83 ec 04             	sub    $0x4,%esp
f0104b17:	6a 08                	push   $0x8
f0104b19:	ff 75 08             	pushl  0x8(%ebp)
f0104b1c:	50                   	push   %eax
f0104b1d:	e8 db e3 01 00       	call   f0122efd <ide_write>
f0104b22:	83 c4 10             	add    $0x10,%esp
f0104b25:	85 c0                	test   %eax,%eax
f0104b27:	75 12                	jne    f0104b3b <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b29:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b30:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b37:	7e d8                	jle    f0104b11 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b39:	eb 01                	jmp    f0104b3c <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b3b:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b3c:	90                   	nop
f0104b3d:	c9                   	leave  
f0104b3e:	c3                   	ret    

f0104b3f <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b3f:	55                   	push   %ebp
  pushl %eax
f0104b40:	50                   	push   %eax
  pushl %ebx
f0104b41:	53                   	push   %ebx
  pushl %ecx
f0104b42:	51                   	push   %ecx
  pushl %edx
f0104b43:	52                   	push   %edx
  pushl %esi
f0104b44:	56                   	push   %esi
  pushl %edi
f0104b45:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b46:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b4a:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b4e:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b50:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b52:	5f                   	pop    %edi
  popl %esi
f0104b53:	5e                   	pop    %esi
  popl %edx
f0104b54:	5a                   	pop    %edx
  popl %ecx
f0104b55:	59                   	pop    %ecx
  popl %ebx
f0104b56:	5b                   	pop    %ebx
  popl %eax
f0104b57:	58                   	pop    %eax
  popl %ebp
f0104b58:	5d                   	pop    %ebp
  ret
f0104b59:	c3                   	ret    

f0104b5a <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b5a:	55                   	push   %ebp
f0104b5b:	89 e5                	mov    %esp,%ebp
f0104b5d:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b60:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b63:	0f b6 c0             	movzbl %al,%eax
f0104b66:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b6d:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b70:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b73:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b76:	ee                   	out    %al,(%dx)
f0104b77:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104b81:	89 c2                	mov    %eax,%edx
f0104b83:	ec                   	in     (%dx),%al
f0104b84:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104b87:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104b8a:	0f b6 c0             	movzbl %al,%eax
}
f0104b8d:	c9                   	leave  
f0104b8e:	c3                   	ret    

f0104b8f <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104b8f:	55                   	push   %ebp
f0104b90:	89 e5                	mov    %esp,%ebp
f0104b92:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b95:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b98:	0f b6 c0             	movzbl %al,%eax
f0104b9b:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104ba2:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba5:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bab:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bac:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104baf:	0f b6 c0             	movzbl %al,%eax
f0104bb2:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104bb9:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bbc:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bbf:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bc2:	ee                   	out    %al,(%dx)
}
f0104bc3:	90                   	nop
f0104bc4:	c9                   	leave  
f0104bc5:	c3                   	ret    

f0104bc6 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bc6:	55                   	push   %ebp
f0104bc7:	89 e5                	mov    %esp,%ebp
f0104bc9:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bcc:	c7 05 68 3a 5a f0 00 	movl   $0x0,0xf05a3a68
f0104bd3:	00 00 00 
f0104bd6:	c7 05 6c 3a 5a f0 00 	movl   $0x0,0xf05a3a6c
f0104bdd:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104be0:	83 ec 08             	sub    $0x8,%esp
f0104be3:	68 b4 6b 10 f0       	push   $0xf0106bb4
f0104be8:	6a 00                	push   $0x0
f0104bea:	e8 a9 87 00 00       	call   f010d398 <irq_install_handler>
f0104bef:	83 c4 10             	add    $0x10,%esp
}
f0104bf2:	90                   	nop
f0104bf3:	c9                   	leave  
f0104bf4:	c3                   	ret    

f0104bf5 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104bf5:	55                   	push   %ebp
f0104bf6:	89 e5                	mov    %esp,%ebp
f0104bf8:	53                   	push   %ebx
f0104bf9:	83 ec 24             	sub    $0x24,%esp
f0104bfc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bff:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c02:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c09:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c0d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c10:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c13:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c14:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c18:	77 48                	ja     f0104c62 <kclock_start+0x6d>
f0104c1a:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c21:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c25:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c2b:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c2c:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c30:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c35:	99                   	cltd   
f0104c36:	f7 fb                	idiv   %ebx
f0104c38:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c3e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c42:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c47:	99                   	cltd   
f0104c48:	f7 fb                	idiv   %ebx
f0104c4a:	89 c3                	mov    %eax,%ebx
f0104c4c:	89 c8                	mov    %ecx,%eax
f0104c4e:	99                   	cltd   
f0104c4f:	f7 fb                	idiv   %ebx
f0104c51:	0f b7 c0             	movzwl %ax,%eax
f0104c54:	83 ec 0c             	sub    $0xc,%esp
f0104c57:	50                   	push   %eax
f0104c58:	e8 b3 01 00 00       	call   f0104e10 <kclock_write_cnt0_LSB_first>
f0104c5d:	83 c4 10             	add    $0x10,%esp
f0104c60:	eb 13                	jmp    f0104c75 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c62:	6a 35                	push   $0x35
f0104c64:	68 d0 6b 12 f0       	push   $0xf0126bd0
f0104c69:	6a 41                	push   $0x41
f0104c6b:	68 2c 6c 12 f0       	push   $0xf0126c2c
f0104c70:	e8 a5 b6 ff ff       	call   f010031a <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104c75:	83 ec 0c             	sub    $0xc,%esp
f0104c78:	6a 00                	push   $0x0
f0104c7a:	e8 66 23 00 00       	call   f0106fe5 <irq_clear_mask>
f0104c7f:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104c82:	90                   	nop
f0104c83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104c86:	c9                   	leave  
f0104c87:	c3                   	ret    

f0104c88 <kclock_stop>:

void
kclock_stop(void)
{
f0104c88:	55                   	push   %ebp
f0104c89:	89 e5                	mov    %esp,%ebp
f0104c8b:	83 ec 18             	sub    $0x18,%esp
f0104c8e:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c95:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104c99:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104c9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c9f:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104ca0:	83 ec 0c             	sub    $0xc,%esp
f0104ca3:	6a 00                	push   $0x0
f0104ca5:	e8 c6 22 00 00       	call   f0106f70 <irq_set_mask>
f0104caa:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cad:	90                   	nop
f0104cae:	c9                   	leave  
f0104caf:	c3                   	ret    

f0104cb0 <kclock_resume>:

void
kclock_resume(void)
{
f0104cb0:	55                   	push   %ebp
f0104cb1:	89 e5                	mov    %esp,%ebp
f0104cb3:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104cb6:	e8 f5 01 00 00       	call   f0104eb0 <kclock_read_cnt0_latch>
f0104cbb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cbf:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cc4:	77 06                	ja     f0104ccc <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cc6:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104ccc:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104cd0:	83 e0 01             	and    $0x1,%eax
f0104cd3:	66 85 c0             	test   %ax,%ax
f0104cd6:	74 09                	je     f0104ce1 <kclock_resume+0x31>
		cnt0++;
f0104cd8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104cdc:	40                   	inc    %eax
f0104cdd:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104ce1:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104ce8:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104cec:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104cef:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104cf2:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104cf3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104cf7:	83 ec 0c             	sub    $0xc,%esp
f0104cfa:	50                   	push   %eax
f0104cfb:	e8 10 01 00 00       	call   f0104e10 <kclock_write_cnt0_LSB_first>
f0104d00:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d03:	83 ec 0c             	sub    $0xc,%esp
f0104d06:	6a 00                	push   $0x0
f0104d08:	e8 d8 22 00 00       	call   f0106fe5 <irq_clear_mask>
f0104d0d:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d10:	90                   	nop
f0104d11:	c9                   	leave  
f0104d12:	c3                   	ret    

f0104d13 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d13:	55                   	push   %ebp
f0104d14:	89 e5                	mov    %esp,%ebp
f0104d16:	83 ec 28             	sub    $0x28,%esp
f0104d19:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d1c:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d1f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d26:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d2a:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d30:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d31:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	50                   	push   %eax
f0104d39:	e8 d2 00 00 00       	call   f0104e10 <kclock_write_cnt0_LSB_first>
f0104d3e:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d41:	83 ec 0c             	sub    $0xc,%esp
f0104d44:	6a 00                	push   $0x0
f0104d46:	e8 9a 22 00 00       	call   f0106fe5 <irq_clear_mask>
f0104d4b:	83 c4 10             	add    $0x10,%esp
}
f0104d4e:	90                   	nop
f0104d4f:	c9                   	leave  
f0104d50:	c3                   	ret    

f0104d51 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d51:	55                   	push   %ebp
f0104d52:	89 e5                	mov    %esp,%ebp
f0104d54:	56                   	push   %esi
f0104d55:	53                   	push   %ebx
f0104d56:	83 ec 20             	sub    $0x20,%esp
f0104d59:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d5c:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d5f:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d63:	0f 87 8a 00 00 00    	ja     f0104df3 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d69:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d6d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d72:	99                   	cltd   
f0104d73:	f7 fe                	idiv   %esi
f0104d75:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d7b:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104d7f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d84:	99                   	cltd   
f0104d85:	f7 fb                	idiv   %ebx
f0104d87:	89 c6                	mov    %eax,%esi
f0104d89:	89 c8                	mov    %ecx,%eax
f0104d8b:	99                   	cltd   
f0104d8c:	f7 fe                	idiv   %esi
f0104d8e:	89 c3                	mov    %eax,%ebx
f0104d90:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104d94:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d99:	99                   	cltd   
f0104d9a:	f7 f9                	idiv   %ecx
f0104d9c:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104da2:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104da6:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104dab:	99                   	cltd   
f0104dac:	f7 fe                	idiv   %esi
f0104dae:	89 c6                	mov    %eax,%esi
f0104db0:	89 c8                	mov    %ecx,%eax
f0104db2:	99                   	cltd   
f0104db3:	f7 fe                	idiv   %esi
f0104db5:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dba:	85 c0                	test   %eax,%eax
f0104dbc:	79 05                	jns    f0104dc3 <kclock_set_quantum+0x72>
f0104dbe:	48                   	dec    %eax
f0104dbf:	83 c8 fe             	or     $0xfffffffe,%eax
f0104dc2:	40                   	inc    %eax
f0104dc3:	01 d8                	add    %ebx,%eax
f0104dc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dc8:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104dcf:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104dd3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104dd6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104dd9:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ddd:	0f b7 c0             	movzwl %ax,%eax
f0104de0:	83 ec 0c             	sub    $0xc,%esp
f0104de3:	50                   	push   %eax
f0104de4:	e8 27 00 00 00       	call   f0104e10 <kclock_write_cnt0_LSB_first>
f0104de9:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104dec:	e8 97 fe ff ff       	call   f0104c88 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104df1:	eb 16                	jmp    f0104e09 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104df3:	6a 35                	push   $0x35
f0104df5:	68 d0 6b 12 f0       	push   $0xf0126bd0
f0104dfa:	68 ea 00 00 00       	push   $0xea
f0104dff:	68 2c 6c 12 f0       	push   $0xf0126c2c
f0104e04:	e8 11 b5 ff ff       	call   f010031a <_panic>
	}
}
f0104e09:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e0c:	5b                   	pop    %ebx
f0104e0d:	5e                   	pop    %esi
f0104e0e:	5d                   	pop    %ebp
f0104e0f:	c3                   	ret    

f0104e10 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e10:	55                   	push   %ebp
f0104e11:	89 e5                	mov    %esp,%ebp
f0104e13:	83 ec 28             	sub    $0x28,%esp
f0104e16:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e19:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e1d:	e8 9e 23 00 00       	call   f01071c0 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e25:	0f b6 c0             	movzbl %al,%eax
f0104e28:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e2f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e32:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e35:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e38:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e3c:	66 c1 e8 08          	shr    $0x8,%ax
f0104e40:	0f b6 c0             	movzbl %al,%eax
f0104e43:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e4a:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e4d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e50:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e53:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e54:	e8 b9 23 00 00       	call   f0107212 <popcli>

}
f0104e59:	90                   	nop
f0104e5a:	c9                   	leave  
f0104e5b:	c3                   	ret    

f0104e5c <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e5c:	55                   	push   %ebp
f0104e5d:	89 e5                	mov    %esp,%ebp
f0104e5f:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e62:	e8 59 23 00 00       	call   f01071c0 <pushcli>
f0104e67:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e71:	89 c2                	mov    %eax,%edx
f0104e73:	ec                   	in     (%dx),%al
f0104e74:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104e77:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104e7a:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104e7d:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e84:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104e87:	89 c2                	mov    %eax,%edx
f0104e89:	ec                   	in     (%dx),%al
f0104e8a:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104e8d:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104e90:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104e93:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104e97:	c1 e0 08             	shl    $0x8,%eax
f0104e9a:	89 c2                	mov    %eax,%edx
f0104e9c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ea0:	09 d0                	or     %edx,%eax
f0104ea2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ea6:	e8 67 23 00 00       	call   f0107212 <popcli>
	return cnt0 ;
f0104eab:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104eae:	c9                   	leave  
f0104eaf:	c3                   	ret    

f0104eb0 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104eb0:	55                   	push   %ebp
f0104eb1:	89 e5                	mov    %esp,%ebp
f0104eb3:	83 ec 30             	sub    $0x30,%esp
f0104eb6:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ebd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ec0:	89 c2                	mov    %eax,%edx
f0104ec2:	ec                   	in     (%dx),%al
f0104ec3:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ec6:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104ec9:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104ecc:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104ed3:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ed7:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104eda:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104edd:	ee                   	out    %al,(%dx)
f0104ede:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ee5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104ee8:	89 c2                	mov    %eax,%edx
f0104eea:	ec                   	in     (%dx),%al
f0104eeb:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104eee:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104ef1:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104ef4:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104efb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104efe:	89 c2                	mov    %eax,%edx
f0104f00:	ec                   	in     (%dx),%al
f0104f01:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f04:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f07:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f0a:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f0e:	c1 e0 08             	shl    $0x8,%eax
f0104f11:	89 c2                	mov    %eax,%edx
f0104f13:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f17:	09 d0                	or     %edx,%eax
f0104f19:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f1d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f21:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f28:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f2b:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f2e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f31:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f32:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f35:	c9                   	leave  
f0104f36:	c3                   	ret    

f0104f37 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f37:	55                   	push   %ebp
f0104f38:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f3a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f3e:	74 1d                	je     f0104f5d <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f40:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f49:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f53:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f56:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f5d:	90                   	nop
f0104f5e:	5d                   	pop    %ebp
f0104f5f:	c3                   	ret    

f0104f60 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f60:	55                   	push   %ebp
f0104f61:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f63:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f67:	74 08                	je     f0104f71 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f69:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f6c:	8b 40 0c             	mov    0xc(%eax),%eax
f0104f6f:	eb 05                	jmp    f0104f76 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104f71:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104f76:	5d                   	pop    %ebp
f0104f77:	c3                   	ret    

f0104f78 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104f78:	55                   	push   %ebp
f0104f79:	89 e5                	mov    %esp,%ebp
f0104f7b:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104f7e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f82:	75 16                	jne    f0104f9a <enqueue+0x22>
f0104f84:	68 40 6c 12 f0       	push   $0xf0126c40
f0104f89:	68 4e 6c 12 f0       	push   $0xf0126c4e
f0104f8e:	6a 34                	push   $0x34
f0104f90:	68 63 6c 12 f0       	push   $0xf0126c63
f0104f95:	e8 80 b3 ff ff       	call   f010031a <_panic>
	if(env != NULL)
f0104f9a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f9e:	74 66                	je     f0105006 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fa0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fa4:	75 14                	jne    f0104fba <enqueue+0x42>
f0104fa6:	83 ec 04             	sub    $0x4,%esp
f0104fa9:	68 7c 6c 12 f0       	push   $0xf0126c7c
f0104fae:	6a 37                	push   $0x37
f0104fb0:	68 63 6c 12 f0       	push   $0xf0126c63
f0104fb5:	e8 60 b3 ff ff       	call   f010031a <_panic>
f0104fba:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fbd:	8b 10                	mov    (%eax),%edx
f0104fbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fc2:	89 50 08             	mov    %edx,0x8(%eax)
f0104fc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fc8:	8b 40 08             	mov    0x8(%eax),%eax
f0104fcb:	85 c0                	test   %eax,%eax
f0104fcd:	74 0d                	je     f0104fdc <enqueue+0x64>
f0104fcf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fd2:	8b 00                	mov    (%eax),%eax
f0104fd4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fd7:	89 50 0c             	mov    %edx,0xc(%eax)
f0104fda:	eb 09                	jmp    f0104fe5 <enqueue+0x6d>
f0104fdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fdf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fe2:	89 50 04             	mov    %edx,0x4(%eax)
f0104fe5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fe8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104feb:	89 10                	mov    %edx,(%eax)
f0104fed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104ff7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ffa:	8b 40 0c             	mov    0xc(%eax),%eax
f0104ffd:	8d 50 01             	lea    0x1(%eax),%edx
f0105000:	8b 45 08             	mov    0x8(%ebp),%eax
f0105003:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105006:	90                   	nop
f0105007:	c9                   	leave  
f0105008:	c3                   	ret    

f0105009 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0105009:	55                   	push   %ebp
f010500a:	89 e5                	mov    %esp,%ebp
f010500c:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f010500f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105013:	75 0a                	jne    f010501f <dequeue+0x16>
f0105015:	b8 00 00 00 00       	mov    $0x0,%eax
f010501a:	e9 a0 00 00 00       	jmp    f01050bf <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f010501f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105022:	8b 40 04             	mov    0x4(%eax),%eax
f0105025:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0105028:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010502c:	0f 84 8a 00 00 00    	je     f01050bc <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105032:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105036:	75 14                	jne    f010504c <dequeue+0x43>
f0105038:	83 ec 04             	sub    $0x4,%esp
f010503b:	68 9f 6c 12 f0       	push   $0xf0126c9f
f0105040:	6a 44                	push   $0x44
f0105042:	68 63 6c 12 f0       	push   $0xf0126c63
f0105047:	e8 ce b2 ff ff       	call   f010031a <_panic>
f010504c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010504f:	8b 40 08             	mov    0x8(%eax),%eax
f0105052:	85 c0                	test   %eax,%eax
f0105054:	74 11                	je     f0105067 <dequeue+0x5e>
f0105056:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105059:	8b 40 08             	mov    0x8(%eax),%eax
f010505c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010505f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105062:	89 50 0c             	mov    %edx,0xc(%eax)
f0105065:	eb 0c                	jmp    f0105073 <dequeue+0x6a>
f0105067:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010506a:	8b 50 0c             	mov    0xc(%eax),%edx
f010506d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105070:	89 50 04             	mov    %edx,0x4(%eax)
f0105073:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105076:	8b 40 0c             	mov    0xc(%eax),%eax
f0105079:	85 c0                	test   %eax,%eax
f010507b:	74 11                	je     f010508e <dequeue+0x85>
f010507d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105080:	8b 40 0c             	mov    0xc(%eax),%eax
f0105083:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105086:	8b 52 08             	mov    0x8(%edx),%edx
f0105089:	89 50 08             	mov    %edx,0x8(%eax)
f010508c:	eb 0b                	jmp    f0105099 <dequeue+0x90>
f010508e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105091:	8b 50 08             	mov    0x8(%eax),%edx
f0105094:	8b 45 08             	mov    0x8(%ebp),%eax
f0105097:	89 10                	mov    %edx,(%eax)
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01050b0:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050b9:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050bf:	c9                   	leave  
f01050c0:	c3                   	ret    

f01050c1 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050c1:	55                   	push   %ebp
f01050c2:	89 e5                	mov    %esp,%ebp
f01050c4:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050c7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050cb:	75 16                	jne    f01050e3 <remove_from_queue+0x22>
f01050cd:	68 40 6c 12 f0       	push   $0xf0126c40
f01050d2:	68 4e 6c 12 f0       	push   $0xf0126c4e
f01050d7:	6a 4e                	push   $0x4e
f01050d9:	68 63 6c 12 f0       	push   $0xf0126c63
f01050de:	e8 37 b2 ff ff       	call   f010031a <_panic>

	if (e != NULL)
f01050e3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050e7:	0f 84 8a 00 00 00    	je     f0105177 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f01050ed:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050f1:	75 14                	jne    f0105107 <remove_from_queue+0x46>
f01050f3:	83 ec 04             	sub    $0x4,%esp
f01050f6:	68 9f 6c 12 f0       	push   $0xf0126c9f
f01050fb:	6a 52                	push   $0x52
f01050fd:	68 63 6c 12 f0       	push   $0xf0126c63
f0105102:	e8 13 b2 ff ff       	call   f010031a <_panic>
f0105107:	8b 45 0c             	mov    0xc(%ebp),%eax
f010510a:	8b 40 08             	mov    0x8(%eax),%eax
f010510d:	85 c0                	test   %eax,%eax
f010510f:	74 11                	je     f0105122 <remove_from_queue+0x61>
f0105111:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105114:	8b 40 08             	mov    0x8(%eax),%eax
f0105117:	8b 55 0c             	mov    0xc(%ebp),%edx
f010511a:	8b 52 0c             	mov    0xc(%edx),%edx
f010511d:	89 50 0c             	mov    %edx,0xc(%eax)
f0105120:	eb 0c                	jmp    f010512e <remove_from_queue+0x6d>
f0105122:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105125:	8b 50 0c             	mov    0xc(%eax),%edx
f0105128:	8b 45 08             	mov    0x8(%ebp),%eax
f010512b:	89 50 04             	mov    %edx,0x4(%eax)
f010512e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105131:	8b 40 0c             	mov    0xc(%eax),%eax
f0105134:	85 c0                	test   %eax,%eax
f0105136:	74 11                	je     f0105149 <remove_from_queue+0x88>
f0105138:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513b:	8b 40 0c             	mov    0xc(%eax),%eax
f010513e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105141:	8b 52 08             	mov    0x8(%edx),%edx
f0105144:	89 50 08             	mov    %edx,0x8(%eax)
f0105147:	eb 0b                	jmp    f0105154 <remove_from_queue+0x93>
f0105149:	8b 45 0c             	mov    0xc(%ebp),%eax
f010514c:	8b 50 08             	mov    0x8(%eax),%edx
f010514f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105152:	89 10                	mov    %edx,(%eax)
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010515e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105161:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105168:	8b 45 08             	mov    0x8(%ebp),%eax
f010516b:	8b 40 0c             	mov    0xc(%eax),%eax
f010516e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105171:	8b 45 08             	mov    0x8(%ebp),%eax
f0105174:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105177:	90                   	nop
f0105178:	c9                   	leave  
f0105179:	c3                   	ret    

f010517a <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010517a:	55                   	push   %ebp
f010517b:	89 e5                	mov    %esp,%ebp
f010517d:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0105180:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105184:	75 07                	jne    f010518d <find_env_in_queue+0x13>
f0105186:	b8 00 00 00 00       	mov    $0x0,%eax
f010518b:	eb 58                	jmp    f01051e5 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f010518d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0105194:	8b 45 08             	mov    0x8(%ebp),%eax
f0105197:	8b 00                	mov    (%eax),%eax
f0105199:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010519c:	eb 19                	jmp    f01051b7 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f010519e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051a1:	8b 40 10             	mov    0x10(%eax),%eax
f01051a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051a7:	75 05                	jne    f01051ae <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051ac:	eb 37                	jmp    f01051e5 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01051b1:	8b 40 08             	mov    0x8(%eax),%eax
f01051b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051b7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051bb:	74 08                	je     f01051c5 <find_env_in_queue+0x4b>
f01051bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051c0:	8b 40 08             	mov    0x8(%eax),%eax
f01051c3:	eb 05                	jmp    f01051ca <find_env_in_queue+0x50>
f01051c5:	b8 00 00 00 00       	mov    $0x0,%eax
f01051ca:	8b 55 08             	mov    0x8(%ebp),%edx
f01051cd:	89 42 08             	mov    %eax,0x8(%edx)
f01051d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051d3:	8b 40 08             	mov    0x8(%eax),%eax
f01051d6:	85 c0                	test   %eax,%eax
f01051d8:	75 c4                	jne    f010519e <find_env_in_queue+0x24>
f01051da:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051de:	75 be                	jne    f010519e <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f01051e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01051e5:	c9                   	leave  
f01051e6:	c3                   	ret    

f01051e7 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f01051e7:	55                   	push   %ebp
f01051e8:	89 e5                	mov    %esp,%ebp
			kfree(quantums);
	}
	release_spinlock(&ProcessQueues.qlock);

#endif
}
f01051ea:	90                   	nop
f01051eb:	5d                   	pop    %ebp
f01051ec:	c3                   	ret    

f01051ed <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f01051ed:	55                   	push   %ebp
f01051ee:	89 e5                	mov    %esp,%ebp
f01051f0:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01051f3:	83 ec 0c             	sub    $0xc,%esp
f01051f6:	68 00 0e 5a f0       	push   $0xf05a0e00
f01051fb:	e8 3a 9b 00 00       	call   f010ed3a <holding_spinlock>
f0105200:	83 c4 10             	add    $0x10,%esp
f0105203:	85 c0                	test   %eax,%eax
f0105205:	75 17                	jne    f010521e <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105207:	83 ec 04             	sub    $0x4,%esp
f010520a:	68 c0 6c 12 f0       	push   $0xf0126cc0
f010520f:	68 85 00 00 00       	push   $0x85
f0105214:	68 63 6c 12 f0       	push   $0xf0126c63
f0105219:	e8 fc b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f010521e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105222:	75 19                	jne    f010523d <sched_insert_ready0+0x50>
f0105224:	68 01 6d 12 f0       	push   $0xf0126d01
f0105229:	68 4e 6c 12 f0       	push   $0xf0126c4e
f010522e:	68 88 00 00 00       	push   $0x88
f0105233:	68 63 6c 12 f0       	push   $0xf0126c63
f0105238:	e8 dd b0 ff ff       	call   f010031a <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f010523d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105240:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f0105247:	83 ec 08             	sub    $0x8,%esp
f010524a:	ff 75 08             	pushl  0x8(%ebp)
f010524d:	68 90 0e 5a f0       	push   $0xf05a0e90
f0105252:	e8 21 fd ff ff       	call   f0104f78 <enqueue>
f0105257:	83 c4 10             	add    $0x10,%esp
	}
}
f010525a:	90                   	nop
f010525b:	c9                   	leave  
f010525c:	c3                   	ret    

f010525d <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f010525d:	55                   	push   %ebp
f010525e:	89 e5                	mov    %esp,%ebp
f0105260:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 00 0e 5a f0       	push   $0xf05a0e00
f010526b:	e8 ca 9a 00 00       	call   f010ed3a <holding_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp
f0105273:	85 c0                	test   %eax,%eax
f0105275:	75 17                	jne    f010528e <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105277:	83 ec 04             	sub    $0x4,%esp
f010527a:	68 c0 6c 12 f0       	push   $0xf0126cc0
f010527f:	68 97 00 00 00       	push   $0x97
f0105284:	68 63 6c 12 f0       	push   $0xf0126c63
f0105289:	e8 8c b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f010528e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105292:	74 0b                	je     f010529f <sched_remove_ready+0x42>
f0105294:	8b 45 08             	mov    0x8(%ebp),%eax
f0105297:	8b 40 18             	mov    0x18(%eax),%eax
f010529a:	83 f8 01             	cmp    $0x1,%eax
f010529d:	74 19                	je     f01052b8 <sched_remove_ready+0x5b>
f010529f:	68 10 6d 12 f0       	push   $0xf0126d10
f01052a4:	68 4e 6c 12 f0       	push   $0xf0126c4e
f01052a9:	68 9a 00 00 00       	push   $0x9a
f01052ae:	68 63 6c 12 f0       	push   $0xf0126c63
f01052b3:	e8 62 b0 ff ff       	call   f010031a <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01052b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01052bf:	e9 f7 00 00 00       	jmp    f01053bb <sched_remove_ready+0x15e>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01052c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c7:	8b 40 10             	mov    0x10(%eax),%eax
f01052ca:	89 c2                	mov    %eax,%edx
f01052cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052cf:	83 c0 09             	add    $0x9,%eax
f01052d2:	c1 e0 04             	shl    $0x4,%eax
f01052d5:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f01052da:	83 ec 08             	sub    $0x8,%esp
f01052dd:	52                   	push   %edx
f01052de:	50                   	push   %eax
f01052df:	e8 96 fe ff ff       	call   f010517a <find_env_in_queue>
f01052e4:	83 c4 10             	add    $0x10,%esp
f01052e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01052ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01052ee:	0f 84 c4 00 00 00    	je     f01053b8 <sched_remove_ready+0x15b>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01052f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052f8:	75 17                	jne    f0105311 <sched_remove_ready+0xb4>
f01052fa:	83 ec 04             	sub    $0x4,%esp
f01052fd:	68 9f 6c 12 f0       	push   $0xf0126c9f
f0105302:	68 a1 00 00 00       	push   $0xa1
f0105307:	68 63 6c 12 f0       	push   $0xf0126c63
f010530c:	e8 09 b0 ff ff       	call   f010031a <_panic>
f0105311:	8b 45 08             	mov    0x8(%ebp),%eax
f0105314:	8b 40 08             	mov    0x8(%eax),%eax
f0105317:	85 c0                	test   %eax,%eax
f0105319:	74 11                	je     f010532c <sched_remove_ready+0xcf>
f010531b:	8b 45 08             	mov    0x8(%ebp),%eax
f010531e:	8b 40 08             	mov    0x8(%eax),%eax
f0105321:	8b 55 08             	mov    0x8(%ebp),%edx
f0105324:	8b 52 0c             	mov    0xc(%edx),%edx
f0105327:	89 50 0c             	mov    %edx,0xc(%eax)
f010532a:	eb 17                	jmp    f0105343 <sched_remove_ready+0xe6>
f010532c:	8b 45 08             	mov    0x8(%ebp),%eax
f010532f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105332:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105335:	83 c2 09             	add    $0x9,%edx
f0105338:	c1 e2 04             	shl    $0x4,%edx
f010533b:	81 c2 04 0e 5a f0    	add    $0xf05a0e04,%edx
f0105341:	89 02                	mov    %eax,(%edx)
f0105343:	8b 45 08             	mov    0x8(%ebp),%eax
f0105346:	8b 40 0c             	mov    0xc(%eax),%eax
f0105349:	85 c0                	test   %eax,%eax
f010534b:	74 11                	je     f010535e <sched_remove_ready+0x101>
f010534d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105350:	8b 40 0c             	mov    0xc(%eax),%eax
f0105353:	8b 55 08             	mov    0x8(%ebp),%edx
f0105356:	8b 52 08             	mov    0x8(%edx),%edx
f0105359:	89 50 08             	mov    %edx,0x8(%eax)
f010535c:	eb 17                	jmp    f0105375 <sched_remove_ready+0x118>
f010535e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105361:	8b 40 08             	mov    0x8(%eax),%eax
f0105364:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105367:	83 c2 09             	add    $0x9,%edx
f010536a:	c1 e2 04             	shl    $0x4,%edx
f010536d:	81 c2 00 0e 5a f0    	add    $0xf05a0e00,%edx
f0105373:	89 02                	mov    %eax,(%edx)
f0105375:	8b 45 08             	mov    0x8(%ebp),%eax
f0105378:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010537f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105382:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010538c:	83 c0 09             	add    $0x9,%eax
f010538f:	c1 e0 04             	shl    $0x4,%eax
f0105392:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f0105397:	8b 00                	mov    (%eax),%eax
f0105399:	8d 50 ff             	lea    -0x1(%eax),%edx
f010539c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010539f:	83 c0 09             	add    $0x9,%eax
f01053a2:	c1 e0 04             	shl    $0x4,%eax
f01053a5:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f01053aa:	89 10                	mov    %edx,(%eax)
				env->env_status = ENV_UNKNOWN;
f01053ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01053af:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f01053b6:	eb 14                	jmp    f01053cc <sched_remove_ready+0x16f>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01053b8:	ff 45 f4             	incl   -0xc(%ebp)
f01053bb:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f01053c0:	0f b6 c0             	movzbl %al,%eax
f01053c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01053c6:	0f 8f f8 fe ff ff    	jg     f01052c4 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01053cc:	c9                   	leave  
f01053cd:	c3                   	ret    

f01053ce <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01053ce:	55                   	push   %ebp
f01053cf:	89 e5                	mov    %esp,%ebp
f01053d1:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01053d4:	83 ec 0c             	sub    $0xc,%esp
f01053d7:	68 00 0e 5a f0       	push   $0xf05a0e00
f01053dc:	e8 59 99 00 00       	call   f010ed3a <holding_spinlock>
f01053e1:	83 c4 10             	add    $0x10,%esp
f01053e4:	85 c0                	test   %eax,%eax
f01053e6:	75 17                	jne    f01053ff <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01053e8:	83 ec 04             	sub    $0x4,%esp
f01053eb:	68 c0 6c 12 f0       	push   $0xf0126cc0
f01053f0:	68 b0 00 00 00       	push   $0xb0
f01053f5:	68 63 6c 12 f0       	push   $0xf0126c63
f01053fa:	e8 1b af ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01053ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105403:	75 19                	jne    f010541e <sched_insert_new+0x50>
f0105405:	68 01 6d 12 f0       	push   $0xf0126d01
f010540a:	68 4e 6c 12 f0       	push   $0xf0126c4e
f010540f:	68 b3 00 00 00       	push   $0xb3
f0105414:	68 63 6c 12 f0       	push   $0xf0126c63
f0105419:	e8 fc ae ff ff       	call   f010031a <_panic>
	{
		env->env_status = ENV_NEW ;
f010541e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105421:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f0105428:	83 ec 08             	sub    $0x8,%esp
f010542b:	ff 75 08             	pushl  0x8(%ebp)
f010542e:	68 70 0e 5a f0       	push   $0xf05a0e70
f0105433:	e8 40 fb ff ff       	call   f0104f78 <enqueue>
f0105438:	83 c4 10             	add    $0x10,%esp
	}
}
f010543b:	90                   	nop
f010543c:	c9                   	leave  
f010543d:	c3                   	ret    

f010543e <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f010543e:	55                   	push   %ebp
f010543f:	89 e5                	mov    %esp,%ebp
f0105441:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105444:	83 ec 0c             	sub    $0xc,%esp
f0105447:	68 00 0e 5a f0       	push   $0xf05a0e00
f010544c:	e8 e9 98 00 00       	call   f010ed3a <holding_spinlock>
f0105451:	83 c4 10             	add    $0x10,%esp
f0105454:	85 c0                	test   %eax,%eax
f0105456:	75 17                	jne    f010546f <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105458:	83 ec 04             	sub    $0x4,%esp
f010545b:	68 c0 6c 12 f0       	push   $0xf0126cc0
f0105460:	68 c1 00 00 00       	push   $0xc1
f0105465:	68 63 6c 12 f0       	push   $0xf0126c63
f010546a:	e8 ab ae ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f010546f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105473:	74 0b                	je     f0105480 <sched_remove_new+0x42>
f0105475:	8b 45 08             	mov    0x8(%ebp),%eax
f0105478:	8b 40 18             	mov    0x18(%eax),%eax
f010547b:	83 f8 04             	cmp    $0x4,%eax
f010547e:	74 19                	je     f0105499 <sched_remove_new+0x5b>
f0105480:	68 3c 6d 12 f0       	push   $0xf0126d3c
f0105485:	68 4e 6c 12 f0       	push   $0xf0126c4e
f010548a:	68 c4 00 00 00       	push   $0xc4
f010548f:	68 63 6c 12 f0       	push   $0xf0126c63
f0105494:	e8 81 ae ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105499:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010549d:	75 17                	jne    f01054b6 <sched_remove_new+0x78>
f010549f:	83 ec 04             	sub    $0x4,%esp
f01054a2:	68 9f 6c 12 f0       	push   $0xf0126c9f
f01054a7:	68 c6 00 00 00       	push   $0xc6
f01054ac:	68 63 6c 12 f0       	push   $0xf0126c63
f01054b1:	e8 64 ae ff ff       	call   f010031a <_panic>
f01054b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b9:	8b 40 08             	mov    0x8(%eax),%eax
f01054bc:	85 c0                	test   %eax,%eax
f01054be:	74 11                	je     f01054d1 <sched_remove_new+0x93>
f01054c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01054c3:	8b 40 08             	mov    0x8(%eax),%eax
f01054c6:	8b 55 08             	mov    0x8(%ebp),%edx
f01054c9:	8b 52 0c             	mov    0xc(%edx),%edx
f01054cc:	89 50 0c             	mov    %edx,0xc(%eax)
f01054cf:	eb 0b                	jmp    f01054dc <sched_remove_new+0x9e>
f01054d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01054d4:	8b 40 0c             	mov    0xc(%eax),%eax
f01054d7:	a3 74 0e 5a f0       	mov    %eax,0xf05a0e74
f01054dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01054df:	8b 40 0c             	mov    0xc(%eax),%eax
f01054e2:	85 c0                	test   %eax,%eax
f01054e4:	74 11                	je     f01054f7 <sched_remove_new+0xb9>
f01054e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054e9:	8b 40 0c             	mov    0xc(%eax),%eax
f01054ec:	8b 55 08             	mov    0x8(%ebp),%edx
f01054ef:	8b 52 08             	mov    0x8(%edx),%edx
f01054f2:	89 50 08             	mov    %edx,0x8(%eax)
f01054f5:	eb 0b                	jmp    f0105502 <sched_remove_new+0xc4>
f01054f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01054fa:	8b 40 08             	mov    0x8(%eax),%eax
f01054fd:	a3 70 0e 5a f0       	mov    %eax,0xf05a0e70
f0105502:	8b 45 08             	mov    0x8(%ebp),%eax
f0105505:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010550c:	8b 45 08             	mov    0x8(%ebp),%eax
f010550f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105516:	a1 7c 0e 5a f0       	mov    0xf05a0e7c,%eax
f010551b:	48                   	dec    %eax
f010551c:	a3 7c 0e 5a f0       	mov    %eax,0xf05a0e7c
		env->env_status = ENV_UNKNOWN;
f0105521:	8b 45 08             	mov    0x8(%ebp),%eax
f0105524:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f010552b:	90                   	nop
f010552c:	c9                   	leave  
f010552d:	c3                   	ret    

f010552e <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f010552e:	55                   	push   %ebp
f010552f:	89 e5                	mov    %esp,%ebp
f0105531:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105534:	83 ec 0c             	sub    $0xc,%esp
f0105537:	68 00 0e 5a f0       	push   $0xf05a0e00
f010553c:	e8 f9 97 00 00       	call   f010ed3a <holding_spinlock>
f0105541:	83 c4 10             	add    $0x10,%esp
f0105544:	85 c0                	test   %eax,%eax
f0105546:	75 17                	jne    f010555f <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105548:	83 ec 04             	sub    $0x4,%esp
f010554b:	68 c0 6c 12 f0       	push   $0xf0126cc0
f0105550:	68 d2 00 00 00       	push   $0xd2
f0105555:	68 63 6c 12 f0       	push   $0xf0126c63
f010555a:	e8 bb ad ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f010555f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105563:	75 19                	jne    f010557e <sched_insert_exit+0x50>
f0105565:	68 01 6d 12 f0       	push   $0xf0126d01
f010556a:	68 4e 6c 12 f0       	push   $0xf0126c4e
f010556f:	68 d5 00 00 00       	push   $0xd5
f0105574:	68 63 6c 12 f0       	push   $0xf0126c63
f0105579:	e8 9c ad ff ff       	call   f010031a <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f010557e:	e8 50 92 00 00       	call   f010e7d3 <isBufferingEnabled>
f0105583:	84 c0                	test   %al,%al
f0105585:	74 0e                	je     f0105595 <sched_insert_exit+0x67>
f0105587:	83 ec 0c             	sub    $0xc,%esp
f010558a:	ff 75 08             	pushl  0x8(%ebp)
f010558d:	e8 ef 67 00 00       	call   f010bd81 <cleanup_buffers>
f0105592:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0105595:	8b 45 08             	mov    0x8(%ebp),%eax
f0105598:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f010559f:	83 ec 08             	sub    $0x8,%esp
f01055a2:	ff 75 08             	pushl  0x8(%ebp)
f01055a5:	68 80 0e 5a f0       	push   $0xf05a0e80
f01055aa:	e8 c9 f9 ff ff       	call   f0104f78 <enqueue>
f01055af:	83 c4 10             	add    $0x10,%esp
	}
}
f01055b2:	90                   	nop
f01055b3:	c9                   	leave  
f01055b4:	c3                   	ret    

f01055b5 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01055b5:	55                   	push   %ebp
f01055b6:	89 e5                	mov    %esp,%ebp
f01055b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055bb:	83 ec 0c             	sub    $0xc,%esp
f01055be:	68 00 0e 5a f0       	push   $0xf05a0e00
f01055c3:	e8 72 97 00 00       	call   f010ed3a <holding_spinlock>
f01055c8:	83 c4 10             	add    $0x10,%esp
f01055cb:	85 c0                	test   %eax,%eax
f01055cd:	75 17                	jne    f01055e6 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055cf:	83 ec 04             	sub    $0x4,%esp
f01055d2:	68 c0 6c 12 f0       	push   $0xf0126cc0
f01055d7:	68 e3 00 00 00       	push   $0xe3
f01055dc:	68 63 6c 12 f0       	push   $0xf0126c63
f01055e1:	e8 34 ad ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01055e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ea:	74 0b                	je     f01055f7 <sched_remove_exit+0x42>
f01055ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01055ef:	8b 40 18             	mov    0x18(%eax),%eax
f01055f2:	83 f8 05             	cmp    $0x5,%eax
f01055f5:	74 19                	je     f0105610 <sched_remove_exit+0x5b>
f01055f7:	68 68 6d 12 f0       	push   $0xf0126d68
f01055fc:	68 4e 6c 12 f0       	push   $0xf0126c4e
f0105601:	68 e6 00 00 00       	push   $0xe6
f0105606:	68 63 6c 12 f0       	push   $0xf0126c63
f010560b:	e8 0a ad ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105610:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105614:	75 17                	jne    f010562d <sched_remove_exit+0x78>
f0105616:	83 ec 04             	sub    $0x4,%esp
f0105619:	68 9f 6c 12 f0       	push   $0xf0126c9f
f010561e:	68 e8 00 00 00       	push   $0xe8
f0105623:	68 63 6c 12 f0       	push   $0xf0126c63
f0105628:	e8 ed ac ff ff       	call   f010031a <_panic>
f010562d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105630:	8b 40 08             	mov    0x8(%eax),%eax
f0105633:	85 c0                	test   %eax,%eax
f0105635:	74 11                	je     f0105648 <sched_remove_exit+0x93>
f0105637:	8b 45 08             	mov    0x8(%ebp),%eax
f010563a:	8b 40 08             	mov    0x8(%eax),%eax
f010563d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105640:	8b 52 0c             	mov    0xc(%edx),%edx
f0105643:	89 50 0c             	mov    %edx,0xc(%eax)
f0105646:	eb 0b                	jmp    f0105653 <sched_remove_exit+0x9e>
f0105648:	8b 45 08             	mov    0x8(%ebp),%eax
f010564b:	8b 40 0c             	mov    0xc(%eax),%eax
f010564e:	a3 84 0e 5a f0       	mov    %eax,0xf05a0e84
f0105653:	8b 45 08             	mov    0x8(%ebp),%eax
f0105656:	8b 40 0c             	mov    0xc(%eax),%eax
f0105659:	85 c0                	test   %eax,%eax
f010565b:	74 11                	je     f010566e <sched_remove_exit+0xb9>
f010565d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105660:	8b 40 0c             	mov    0xc(%eax),%eax
f0105663:	8b 55 08             	mov    0x8(%ebp),%edx
f0105666:	8b 52 08             	mov    0x8(%edx),%edx
f0105669:	89 50 08             	mov    %edx,0x8(%eax)
f010566c:	eb 0b                	jmp    f0105679 <sched_remove_exit+0xc4>
f010566e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105671:	8b 40 08             	mov    0x8(%eax),%eax
f0105674:	a3 80 0e 5a f0       	mov    %eax,0xf05a0e80
f0105679:	8b 45 08             	mov    0x8(%ebp),%eax
f010567c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105683:	8b 45 08             	mov    0x8(%ebp),%eax
f0105686:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010568d:	a1 8c 0e 5a f0       	mov    0xf05a0e8c,%eax
f0105692:	48                   	dec    %eax
f0105693:	a3 8c 0e 5a f0       	mov    %eax,0xf05a0e8c
		env->env_status = ENV_UNKNOWN;
f0105698:	8b 45 08             	mov    0x8(%ebp),%eax
f010569b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01056a2:	90                   	nop
f01056a3:	c9                   	leave  
f01056a4:	c3                   	ret    

f01056a5 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f01056a5:	55                   	push   %ebp
f01056a6:	89 e5                	mov    %esp,%ebp
f01056a8:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056ab:	83 ec 0c             	sub    $0xc,%esp
f01056ae:	68 00 0e 5a f0       	push   $0xf05a0e00
f01056b3:	e8 69 94 00 00       	call   f010eb21 <acquire_spinlock>
f01056b8:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01056bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056bf:	75 19                	jne    f01056da <sched_new_env+0x35>
f01056c1:	68 93 6d 12 f0       	push   $0xf0126d93
f01056c6:	68 4e 6c 12 f0       	push   $0xf0126c4e
f01056cb:	68 f6 00 00 00       	push   $0xf6
f01056d0:	68 63 6c 12 f0       	push   $0xf0126c63
f01056d5:	e8 40 ac ff ff       	call   f010031a <_panic>
	{
		sched_insert_new(e);
f01056da:	83 ec 0c             	sub    $0xc,%esp
f01056dd:	ff 75 08             	pushl  0x8(%ebp)
f01056e0:	e8 e9 fc ff ff       	call   f01053ce <sched_insert_new>
f01056e5:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056e8:	83 ec 0c             	sub    $0xc,%esp
f01056eb:	68 00 0e 5a f0       	push   $0xf05a0e00
f01056f0:	e8 b3 94 00 00       	call   f010eba8 <release_spinlock>
f01056f5:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01056f8:	90                   	nop
f01056f9:	c9                   	leave  
f01056fa:	c3                   	ret    

f01056fb <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01056fb:	55                   	push   %ebp
f01056fc:	89 e5                	mov    %esp,%ebp
f01056fe:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105701:	83 ec 0c             	sub    $0xc,%esp
f0105704:	68 00 0e 5a f0       	push   $0xf05a0e00
f0105709:	e8 13 94 00 00       	call   f010eb21 <acquire_spinlock>
f010570e:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105711:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105718:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f010571d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105720:	eb 53                	jmp    f0105775 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105722:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105725:	8b 40 10             	mov    0x10(%eax),%eax
f0105728:	3b 45 08             	cmp    0x8(%ebp),%eax
f010572b:	75 40                	jne    f010576d <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f010572d:	83 ec 0c             	sub    $0xc,%esp
f0105730:	ff 75 f4             	pushl  -0xc(%ebp)
f0105733:	e8 06 fd ff ff       	call   f010543e <sched_remove_new>
f0105738:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f010573b:	83 ec 0c             	sub    $0xc,%esp
f010573e:	ff 75 f4             	pushl  -0xc(%ebp)
f0105741:	e8 a7 fa ff ff       	call   f01051ed <sched_insert_ready0>
f0105746:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105749:	e8 af 19 00 00       	call   f01070fd <mycpu>
f010574e:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105754:	85 c0                	test   %eax,%eax
f0105756:	75 46                	jne    f010579e <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105758:	83 ec 0c             	sub    $0xc,%esp
f010575b:	68 00 0e 5a f0       	push   $0xf05a0e00
f0105760:	e8 43 94 00 00       	call   f010eba8 <release_spinlock>
f0105765:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105768:	e8 45 10 00 00       	call   f01067b2 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010576d:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105772:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105775:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105779:	74 08                	je     f0105783 <sched_run_env+0x88>
f010577b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010577e:	8b 40 08             	mov    0x8(%eax),%eax
f0105781:	eb 05                	jmp    f0105788 <sched_run_env+0x8d>
f0105783:	b8 00 00 00 00       	mov    $0x0,%eax
f0105788:	a3 78 0e 5a f0       	mov    %eax,0xf05a0e78
f010578d:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105792:	85 c0                	test   %eax,%eax
f0105794:	75 8c                	jne    f0105722 <sched_run_env+0x27>
f0105796:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010579a:	75 86                	jne    f0105722 <sched_run_env+0x27>
f010579c:	eb 01                	jmp    f010579f <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f010579e:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010579f:	83 ec 0c             	sub    $0xc,%esp
f01057a2:	68 00 0e 5a f0       	push   $0xf05a0e00
f01057a7:	e8 fc 93 00 00       	call   f010eba8 <release_spinlock>
f01057ac:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f01057af:	90                   	nop
f01057b0:	c9                   	leave  
f01057b1:	c3                   	ret    

f01057b2 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f01057b2:	55                   	push   %ebp
f01057b3:	89 e5                	mov    %esp,%ebp
f01057b5:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f01057b8:	83 ec 0c             	sub    $0xc,%esp
f01057bb:	68 00 0e 5a f0       	push   $0xf05a0e00
f01057c0:	e8 75 95 00 00       	call   f010ed3a <holding_spinlock>
f01057c5:	83 c4 10             	add    $0x10,%esp
f01057c8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01057cb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01057cf:	75 10                	jne    f01057e1 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01057d1:	83 ec 0c             	sub    $0xc,%esp
f01057d4:	68 00 0e 5a f0       	push   $0xf05a0e00
f01057d9:	e8 43 93 00 00       	call   f010eb21 <acquire_spinlock>
f01057de:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01057e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01057e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01057ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01057f3:	75 59                	jne    f010584e <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057f5:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f01057fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057fd:	eb 28                	jmp    f0105827 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01057ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105802:	8b 40 10             	mov    0x10(%eax),%eax
f0105805:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105808:	75 15                	jne    f010581f <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f010580a:	83 ec 0c             	sub    $0xc,%esp
f010580d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105810:	e8 29 fc ff ff       	call   f010543e <sched_remove_new>
f0105815:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105818:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010581f:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105824:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105827:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010582b:	74 08                	je     f0105835 <sched_exit_env+0x83>
f010582d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105830:	8b 40 08             	mov    0x8(%eax),%eax
f0105833:	eb 05                	jmp    f010583a <sched_exit_env+0x88>
f0105835:	b8 00 00 00 00       	mov    $0x0,%eax
f010583a:	a3 78 0e 5a f0       	mov    %eax,0xf05a0e78
f010583f:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105844:	85 c0                	test   %eax,%eax
f0105846:	75 b7                	jne    f01057ff <sched_exit_env+0x4d>
f0105848:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010584c:	75 b1                	jne    f01057ff <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f010584e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105852:	0f 85 89 01 00 00    	jne    f01059e1 <sched_exit_env+0x22f>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105858:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010585f:	e9 69 01 00 00       	jmp    f01059cd <sched_exit_env+0x21b>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105867:	83 c0 09             	add    $0x9,%eax
f010586a:	c1 e0 04             	shl    $0x4,%eax
f010586d:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0105872:	8b 00                	mov    (%eax),%eax
f0105874:	85 c0                	test   %eax,%eax
f0105876:	0f 84 48 01 00 00    	je     f01059c4 <sched_exit_env+0x212>
			{
				ptr_env=NULL;
f010587c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105883:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105886:	83 c0 09             	add    $0x9,%eax
f0105889:	c1 e0 04             	shl    $0x4,%eax
f010588c:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0105891:	8b 00                	mov    (%eax),%eax
f0105893:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105896:	e9 e3 00 00 00       	jmp    f010597e <sched_exit_env+0x1cc>
				{
					if(ptr_env->env_id == envId)
f010589b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010589e:	8b 40 10             	mov    0x10(%eax),%eax
f01058a1:	3b 45 08             	cmp    0x8(%ebp),%eax
f01058a4:	0f 85 c1 00 00 00    	jne    f010596b <sched_exit_env+0x1b9>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01058aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058ae:	75 17                	jne    f01058c7 <sched_exit_env+0x115>
f01058b0:	83 ec 04             	sub    $0x4,%esp
f01058b3:	68 9f 6c 12 f0       	push   $0xf0126c9f
f01058b8:	68 44 01 00 00       	push   $0x144
f01058bd:	68 63 6c 12 f0       	push   $0xf0126c63
f01058c2:	e8 53 aa ff ff       	call   f010031a <_panic>
f01058c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ca:	8b 40 08             	mov    0x8(%eax),%eax
f01058cd:	85 c0                	test   %eax,%eax
f01058cf:	74 11                	je     f01058e2 <sched_exit_env+0x130>
f01058d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058d4:	8b 40 08             	mov    0x8(%eax),%eax
f01058d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058da:	8b 52 0c             	mov    0xc(%edx),%edx
f01058dd:	89 50 0c             	mov    %edx,0xc(%eax)
f01058e0:	eb 17                	jmp    f01058f9 <sched_exit_env+0x147>
f01058e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058e5:	8b 40 0c             	mov    0xc(%eax),%eax
f01058e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058eb:	83 c2 09             	add    $0x9,%edx
f01058ee:	c1 e2 04             	shl    $0x4,%edx
f01058f1:	81 c2 04 0e 5a f0    	add    $0xf05a0e04,%edx
f01058f7:	89 02                	mov    %eax,(%edx)
f01058f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058fc:	8b 40 0c             	mov    0xc(%eax),%eax
f01058ff:	85 c0                	test   %eax,%eax
f0105901:	74 11                	je     f0105914 <sched_exit_env+0x162>
f0105903:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105906:	8b 40 0c             	mov    0xc(%eax),%eax
f0105909:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010590c:	8b 52 08             	mov    0x8(%edx),%edx
f010590f:	89 50 08             	mov    %edx,0x8(%eax)
f0105912:	eb 17                	jmp    f010592b <sched_exit_env+0x179>
f0105914:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105917:	8b 40 08             	mov    0x8(%eax),%eax
f010591a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010591d:	83 c2 09             	add    $0x9,%edx
f0105920:	c1 e2 04             	shl    $0x4,%edx
f0105923:	81 c2 00 0e 5a f0    	add    $0xf05a0e00,%edx
f0105929:	89 02                	mov    %eax,(%edx)
f010592b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010592e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105935:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105938:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010593f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105942:	83 c0 09             	add    $0x9,%eax
f0105945:	c1 e0 04             	shl    $0x4,%eax
f0105948:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f010594d:	8b 00                	mov    (%eax),%eax
f010594f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105952:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105955:	83 c0 09             	add    $0x9,%eax
f0105958:	c1 e0 04             	shl    $0x4,%eax
f010595b:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f0105960:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105962:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105969:	eb 59                	jmp    f01059c4 <sched_exit_env+0x212>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010596b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010596e:	83 c0 09             	add    $0x9,%eax
f0105971:	c1 e0 04             	shl    $0x4,%eax
f0105974:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0105979:	8b 00                	mov    (%eax),%eax
f010597b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010597e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105982:	74 08                	je     f010598c <sched_exit_env+0x1da>
f0105984:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105987:	8b 40 08             	mov    0x8(%eax),%eax
f010598a:	eb 05                	jmp    f0105991 <sched_exit_env+0x1df>
f010598c:	b8 00 00 00 00       	mov    $0x0,%eax
f0105991:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105994:	83 c2 09             	add    $0x9,%edx
f0105997:	c1 e2 04             	shl    $0x4,%edx
f010599a:	81 c2 08 0e 5a f0    	add    $0xf05a0e08,%edx
f01059a0:	89 02                	mov    %eax,(%edx)
f01059a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01059a5:	83 c0 09             	add    $0x9,%eax
f01059a8:	c1 e0 04             	shl    $0x4,%eax
f01059ab:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f01059b0:	8b 00                	mov    (%eax),%eax
f01059b2:	85 c0                	test   %eax,%eax
f01059b4:	0f 85 e1 fe ff ff    	jne    f010589b <sched_exit_env+0xe9>
f01059ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059be:	0f 85 d7 fe ff ff    	jne    f010589b <sched_exit_env+0xe9>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059c8:	75 16                	jne    f01059e0 <sched_exit_env+0x22e>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01059ca:	ff 45 ec             	incl   -0x14(%ebp)
f01059cd:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f01059d2:	0f b6 c0             	movzbl %al,%eax
f01059d5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01059d8:	0f 8f 86 fe ff ff    	jg     f0105864 <sched_exit_env+0xb2>
f01059de:	eb 01                	jmp    f01059e1 <sched_exit_env+0x22f>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059e0:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01059e1:	e8 8a 4d 00 00       	call   f010a770 <get_cpu_proc>
f01059e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01059e9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01059ed:	75 19                	jne    f0105a08 <sched_exit_env+0x256>
f01059ef:	68 9b 6d 12 f0       	push   $0xf0126d9b
f01059f4:	68 4e 6c 12 f0       	push   $0xf0126c4e
f01059f9:	68 4e 01 00 00       	push   $0x14e
f01059fe:	68 63 6c 12 f0       	push   $0xf0126c63
f0105a03:	e8 12 a9 ff ff       	call   f010031a <_panic>
	if (!found)
f0105a08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a0c:	75 18                	jne    f0105a26 <sched_exit_env+0x274>
	{
		if (cur_env->env_id == envId)
f0105a0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a11:	8b 40 10             	mov    0x10(%eax),%eax
f0105a14:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a17:	75 0d                	jne    f0105a26 <sched_exit_env+0x274>
		{
			ptr_env = cur_env;
f0105a19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a1f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a26:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a2a:	74 1e                	je     f0105a4a <sched_exit_env+0x298>
	{
		sched_insert_exit(ptr_env);
f0105a2c:	83 ec 0c             	sub    $0xc,%esp
f0105a2f:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a32:	e8 f7 fa ff ff       	call   f010552e <sched_insert_exit>
f0105a37:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a3d:	8b 40 10             	mov    0x10(%eax),%eax
f0105a40:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a43:	75 05                	jne    f0105a4a <sched_exit_env+0x298>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a45:	e8 b3 4e 00 00       	call   f010a8fd <sched>
		}
	}
	if (!lock_already_held)
f0105a4a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105a4e:	75 10                	jne    f0105a60 <sched_exit_env+0x2ae>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105a50:	83 ec 0c             	sub    $0xc,%esp
f0105a53:	68 00 0e 5a f0       	push   $0xf05a0e00
f0105a58:	e8 4b 91 00 00       	call   f010eba8 <release_spinlock>
f0105a5d:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105a60:	90                   	nop
f0105a61:	c9                   	leave  
f0105a62:	c3                   	ret    

f0105a63 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105a63:	55                   	push   %ebp
f0105a64:	89 e5                	mov    %esp,%ebp
f0105a66:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a69:	83 ec 0c             	sub    $0xc,%esp
f0105a6c:	68 00 0e 5a f0       	push   $0xf05a0e00
f0105a71:	e8 ab 90 00 00       	call   f010eb21 <acquire_spinlock>
f0105a76:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105a79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105a80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105a87:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a8b:	75 79                	jne    f0105b06 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a8d:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f0105a92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a95:	eb 48                	jmp    f0105adf <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105a97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a9a:	8b 40 10             	mov    0x10(%eax),%eax
f0105a9d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105aa0:	75 35                	jne    f0105ad7 <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105aa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aa5:	8d 50 20             	lea    0x20(%eax),%edx
f0105aa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aab:	8b 40 10             	mov    0x10(%eax),%eax
f0105aae:	83 ec 04             	sub    $0x4,%esp
f0105ab1:	52                   	push   %edx
f0105ab2:	50                   	push   %eax
f0105ab3:	68 ac 6d 12 f0       	push   $0xf0126dac
f0105ab8:	e8 af b4 ff ff       	call   f0100f6c <cprintf>
f0105abd:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105ac0:	83 ec 0c             	sub    $0xc,%esp
f0105ac3:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ac6:	e8 73 f9 ff ff       	call   f010543e <sched_remove_new>
f0105acb:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105ace:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105ad5:	eb 2f                	jmp    f0105b06 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ad7:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105adf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ae3:	74 08                	je     f0105aed <sched_kill_env+0x8a>
f0105ae5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ae8:	8b 40 08             	mov    0x8(%eax),%eax
f0105aeb:	eb 05                	jmp    f0105af2 <sched_kill_env+0x8f>
f0105aed:	b8 00 00 00 00       	mov    $0x0,%eax
f0105af2:	a3 78 0e 5a f0       	mov    %eax,0xf05a0e78
f0105af7:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105afc:	85 c0                	test   %eax,%eax
f0105afe:	75 97                	jne    f0105a97 <sched_kill_env+0x34>
f0105b00:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b04:	75 91                	jne    f0105a97 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b0a:	0f 85 a7 01 00 00    	jne    f0105cb7 <sched_kill_env+0x254>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b10:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b17:	e9 87 01 00 00       	jmp    f0105ca3 <sched_kill_env+0x240>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105b1f:	83 c0 09             	add    $0x9,%eax
f0105b22:	c1 e0 04             	shl    $0x4,%eax
f0105b25:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0105b2a:	8b 00                	mov    (%eax),%eax
f0105b2c:	85 c0                	test   %eax,%eax
f0105b2e:	0f 84 66 01 00 00    	je     f0105c9a <sched_kill_env+0x237>
			{
				ptr_env=NULL;
f0105b34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105b3e:	83 c0 09             	add    $0x9,%eax
f0105b41:	c1 e0 04             	shl    $0x4,%eax
f0105b44:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0105b49:	8b 00                	mov    (%eax),%eax
f0105b4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b4e:	e9 01 01 00 00       	jmp    f0105c54 <sched_kill_env+0x1f1>
				{
					if(ptr_env->env_id == envId)
f0105b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b56:	8b 40 10             	mov    0x10(%eax),%eax
f0105b59:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b5c:	0f 85 df 00 00 00    	jne    f0105c41 <sched_kill_env+0x1de>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b65:	8d 50 20             	lea    0x20(%eax),%edx
f0105b68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b6b:	8b 40 10             	mov    0x10(%eax),%eax
f0105b6e:	ff 75 ec             	pushl  -0x14(%ebp)
f0105b71:	52                   	push   %edx
f0105b72:	50                   	push   %eax
f0105b73:	68 d4 6d 12 f0       	push   $0xf0126dd4
f0105b78:	e8 ef b3 ff ff       	call   f0100f6c <cprintf>
f0105b7d:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b80:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b84:	75 17                	jne    f0105b9d <sched_kill_env+0x13a>
f0105b86:	83 ec 04             	sub    $0x4,%esp
f0105b89:	68 9f 6c 12 f0       	push   $0xf0126c9f
f0105b8e:	68 91 01 00 00       	push   $0x191
f0105b93:	68 63 6c 12 f0       	push   $0xf0126c63
f0105b98:	e8 7d a7 ff ff       	call   f010031a <_panic>
f0105b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba0:	8b 40 08             	mov    0x8(%eax),%eax
f0105ba3:	85 c0                	test   %eax,%eax
f0105ba5:	74 11                	je     f0105bb8 <sched_kill_env+0x155>
f0105ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105baa:	8b 40 08             	mov    0x8(%eax),%eax
f0105bad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bb0:	8b 52 0c             	mov    0xc(%edx),%edx
f0105bb3:	89 50 0c             	mov    %edx,0xc(%eax)
f0105bb6:	eb 17                	jmp    f0105bcf <sched_kill_env+0x16c>
f0105bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbb:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bbe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bc1:	83 c2 09             	add    $0x9,%edx
f0105bc4:	c1 e2 04             	shl    $0x4,%edx
f0105bc7:	81 c2 04 0e 5a f0    	add    $0xf05a0e04,%edx
f0105bcd:	89 02                	mov    %eax,(%edx)
f0105bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bd2:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bd5:	85 c0                	test   %eax,%eax
f0105bd7:	74 11                	je     f0105bea <sched_kill_env+0x187>
f0105bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bdc:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bdf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105be2:	8b 52 08             	mov    0x8(%edx),%edx
f0105be5:	89 50 08             	mov    %edx,0x8(%eax)
f0105be8:	eb 17                	jmp    f0105c01 <sched_kill_env+0x19e>
f0105bea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bed:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bf3:	83 c2 09             	add    $0x9,%edx
f0105bf6:	c1 e2 04             	shl    $0x4,%edx
f0105bf9:	81 c2 00 0e 5a f0    	add    $0xf05a0e00,%edx
f0105bff:	89 02                	mov    %eax,(%edx)
f0105c01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c04:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c0e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c15:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c18:	83 c0 09             	add    $0x9,%eax
f0105c1b:	c1 e0 04             	shl    $0x4,%eax
f0105c1e:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f0105c23:	8b 00                	mov    (%eax),%eax
f0105c25:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105c28:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c2b:	83 c0 09             	add    $0x9,%eax
f0105c2e:	c1 e0 04             	shl    $0x4,%eax
f0105c31:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f0105c36:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105c38:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c3f:	eb 59                	jmp    f0105c9a <sched_kill_env+0x237>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c41:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c44:	83 c0 09             	add    $0x9,%eax
f0105c47:	c1 e0 04             	shl    $0x4,%eax
f0105c4a:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0105c4f:	8b 00                	mov    (%eax),%eax
f0105c51:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c58:	74 08                	je     f0105c62 <sched_kill_env+0x1ff>
f0105c5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5d:	8b 40 08             	mov    0x8(%eax),%eax
f0105c60:	eb 05                	jmp    f0105c67 <sched_kill_env+0x204>
f0105c62:	b8 00 00 00 00       	mov    $0x0,%eax
f0105c67:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6a:	83 c2 09             	add    $0x9,%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	81 c2 08 0e 5a f0    	add    $0xf05a0e08,%edx
f0105c76:	89 02                	mov    %eax,(%edx)
f0105c78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c7b:	83 c0 09             	add    $0x9,%eax
f0105c7e:	c1 e0 04             	shl    $0x4,%eax
f0105c81:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0105c86:	8b 00                	mov    (%eax),%eax
f0105c88:	85 c0                	test   %eax,%eax
f0105c8a:	0f 85 c3 fe ff ff    	jne    f0105b53 <sched_kill_env+0xf0>
f0105c90:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c94:	0f 85 b9 fe ff ff    	jne    f0105b53 <sched_kill_env+0xf0>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105c9a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c9e:	75 16                	jne    f0105cb6 <sched_kill_env+0x253>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105ca0:	ff 45 ec             	incl   -0x14(%ebp)
f0105ca3:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f0105ca8:	0f b6 c0             	movzbl %al,%eax
f0105cab:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105cae:	0f 8f 68 fe ff ff    	jg     f0105b1c <sched_kill_env+0xb9>
f0105cb4:	eb 01                	jmp    f0105cb7 <sched_kill_env+0x254>
						break;
					}
				}
			}
			if (found)
				break;
f0105cb6:	90                   	nop
		}
	}
	if (!found)
f0105cb7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cbb:	0f 85 80 00 00 00    	jne    f0105d41 <sched_kill_env+0x2de>
	{
		ptr_env=NULL;
f0105cc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cc8:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f0105ccd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105cd0:	eb 48                	jmp    f0105d1a <sched_kill_env+0x2b7>
		{
			if(ptr_env->env_id == envId)
f0105cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cd5:	8b 40 10             	mov    0x10(%eax),%eax
f0105cd8:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cdb:	75 35                	jne    f0105d12 <sched_kill_env+0x2af>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105cdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ce0:	8d 50 20             	lea    0x20(%eax),%edx
f0105ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ce6:	8b 40 10             	mov    0x10(%eax),%eax
f0105ce9:	83 ec 04             	sub    $0x4,%esp
f0105cec:	52                   	push   %edx
f0105ced:	50                   	push   %eax
f0105cee:	68 00 6e 12 f0       	push   $0xf0126e00
f0105cf3:	e8 74 b2 ff ff       	call   f0100f6c <cprintf>
f0105cf8:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105cfb:	83 ec 0c             	sub    $0xc,%esp
f0105cfe:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d01:	e8 af f8 ff ff       	call   f01055b5 <sched_remove_exit>
f0105d06:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d09:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d10:	eb 2f                	jmp    f0105d41 <sched_kill_env+0x2de>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d12:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f0105d17:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d1a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d1e:	74 08                	je     f0105d28 <sched_kill_env+0x2c5>
f0105d20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d23:	8b 40 08             	mov    0x8(%eax),%eax
f0105d26:	eb 05                	jmp    f0105d2d <sched_kill_env+0x2ca>
f0105d28:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d2d:	a3 88 0e 5a f0       	mov    %eax,0xf05a0e88
f0105d32:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f0105d37:	85 c0                	test   %eax,%eax
f0105d39:	75 97                	jne    f0105cd2 <sched_kill_env+0x26f>
f0105d3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d3f:	75 91                	jne    f0105cd2 <sched_kill_env+0x26f>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d41:	83 ec 0c             	sub    $0xc,%esp
f0105d44:	68 00 0e 5a f0       	push   $0xf05a0e00
f0105d49:	e8 5a 8e 00 00       	call   f010eba8 <release_spinlock>
f0105d4e:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d51:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d55:	74 23                	je     f0105d7a <sched_kill_env+0x317>
	{
		env_free(ptr_env);
f0105d57:	83 ec 0c             	sub    $0xc,%esp
f0105d5a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d5d:	e8 c6 49 00 00       	call   f010a728 <env_free>
f0105d62:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d65:	83 ec 0c             	sub    $0xc,%esp
f0105d68:	68 26 6e 12 f0       	push   $0xf0126e26
f0105d6d:	e8 fa b1 ff ff       	call   f0100f6c <cprintf>
f0105d72:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105d75:	e9 a4 00 00 00       	jmp    f0105e1e <sched_kill_env+0x3bb>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105d7a:	e8 f1 49 00 00       	call   f010a770 <get_cpu_proc>
f0105d7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105d82:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d86:	75 19                	jne    f0105da1 <sched_kill_env+0x33e>
f0105d88:	68 9b 6d 12 f0       	push   $0xf0126d9b
f0105d8d:	68 4e 6c 12 f0       	push   $0xf0126c4e
f0105d92:	68 b3 01 00 00       	push   $0x1b3
f0105d97:	68 63 6c 12 f0       	push   $0xf0126c63
f0105d9c:	e8 79 a5 ff ff       	call   f010031a <_panic>

		if (cur_env->env_id == envId)
f0105da1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105da4:	8b 40 10             	mov    0x10(%eax),%eax
f0105da7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105daa:	75 72                	jne    f0105e1e <sched_kill_env+0x3bb>
		{
			ptr_env = cur_env;
f0105dac:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105daf:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105db2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105db5:	8b 40 18             	mov    0x18(%eax),%eax
f0105db8:	83 f8 02             	cmp    $0x2,%eax
f0105dbb:	74 19                	je     f0105dd6 <sched_kill_env+0x373>
f0105dbd:	68 2c 6e 12 f0       	push   $0xf0126e2c
f0105dc2:	68 4e 6c 12 f0       	push   $0xf0126c4e
f0105dc7:	68 b8 01 00 00       	push   $0x1b8
f0105dcc:	68 63 6c 12 f0       	push   $0xf0126c63
f0105dd1:	e8 44 a5 ff ff       	call   f010031a <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105dd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105dd9:	8d 50 20             	lea    0x20(%eax),%edx
f0105ddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ddf:	8b 40 10             	mov    0x10(%eax),%eax
f0105de2:	83 ec 04             	sub    $0x4,%esp
f0105de5:	52                   	push   %edx
f0105de6:	50                   	push   %eax
f0105de7:	68 50 6e 12 f0       	push   $0xf0126e50
f0105dec:	e8 7b b1 ff ff       	call   f0100f6c <cprintf>
f0105df1:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105df4:	83 ec 0c             	sub    $0xc,%esp
f0105df7:	ff 75 f4             	pushl  -0xc(%ebp)
f0105dfa:	e8 29 49 00 00       	call   f010a728 <env_free>
f0105dff:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e02:	83 ec 0c             	sub    $0xc,%esp
f0105e05:	68 26 6e 12 f0       	push   $0xf0126e26
f0105e0a:	e8 5d b1 ff ff       	call   f0100f6c <cprintf>
f0105e0f:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e12:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e19:	e8 df 4a 00 00       	call   f010a8fd <sched>
		}
	}

}
f0105e1e:	90                   	nop
f0105e1f:	c9                   	leave  
f0105e20:	c3                   	ret    

f0105e21 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e21:	55                   	push   %ebp
f0105e22:	89 e5                	mov    %esp,%ebp
f0105e24:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	68 00 0e 5a f0       	push   $0xf05a0e00
f0105e2f:	e8 ed 8c 00 00       	call   f010eb21 <acquire_spinlock>
f0105e34:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e37:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f0105e3c:	85 c0                	test   %eax,%eax
f0105e3e:	74 69                	je     f0105ea9 <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e40:	83 ec 0c             	sub    $0xc,%esp
f0105e43:	68 7c 6e 12 f0       	push   $0xf0126e7c
f0105e48:	e8 1f b1 ff ff       	call   f0100f6c <cprintf>
f0105e4d:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e50:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f0105e55:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e58:	eb 26                	jmp    f0105e80 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5d:	8d 50 20             	lea    0x20(%eax),%edx
f0105e60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e63:	8b 40 10             	mov    0x10(%eax),%eax
f0105e66:	83 ec 04             	sub    $0x4,%esp
f0105e69:	52                   	push   %edx
f0105e6a:	50                   	push   %eax
f0105e6b:	68 9e 6e 12 f0       	push   $0xf0126e9e
f0105e70:	e8 f7 b0 ff ff       	call   f0100f6c <cprintf>
f0105e75:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e78:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105e7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e80:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e84:	74 08                	je     f0105e8e <sched_print_all+0x6d>
f0105e86:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e89:	8b 40 08             	mov    0x8(%eax),%eax
f0105e8c:	eb 05                	jmp    f0105e93 <sched_print_all+0x72>
f0105e8e:	b8 00 00 00 00       	mov    $0x0,%eax
f0105e93:	a3 78 0e 5a f0       	mov    %eax,0xf05a0e78
f0105e98:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0105e9d:	85 c0                	test   %eax,%eax
f0105e9f:	75 b9                	jne    f0105e5a <sched_print_all+0x39>
f0105ea1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ea5:	75 b3                	jne    f0105e5a <sched_print_all+0x39>
f0105ea7:	eb 10                	jmp    f0105eb9 <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105ea9:	83 ec 0c             	sub    $0xc,%esp
f0105eac:	68 a8 6e 12 f0       	push   $0xf0126ea8
f0105eb1:	e8 b6 b0 ff ff       	call   f0100f6c <cprintf>
f0105eb6:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eb9:	83 ec 0c             	sub    $0xc,%esp
f0105ebc:	68 c4 6e 12 f0       	push   $0xf0126ec4
f0105ec1:	e8 a6 b0 ff ff       	call   f0100f6c <cprintf>
f0105ec6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105ec9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105ed0:	e9 d7 00 00 00       	jmp    f0105fac <sched_print_all+0x18b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105ed8:	83 c0 09             	add    $0x9,%eax
f0105edb:	c1 e0 04             	shl    $0x4,%eax
f0105ede:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0105ee3:	8b 00                	mov    (%eax),%eax
f0105ee5:	85 c0                	test   %eax,%eax
f0105ee7:	0f 84 99 00 00 00    	je     f0105f86 <sched_print_all+0x165>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105eed:	83 ec 08             	sub    $0x8,%esp
f0105ef0:	ff 75 f0             	pushl  -0x10(%ebp)
f0105ef3:	68 f8 6e 12 f0       	push   $0xf0126ef8
f0105ef8:	e8 6f b0 ff ff       	call   f0100f6c <cprintf>
f0105efd:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f03:	83 c0 09             	add    $0x9,%eax
f0105f06:	c1 e0 04             	shl    $0x4,%eax
f0105f09:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0105f0e:	8b 00                	mov    (%eax),%eax
f0105f10:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f13:	eb 31                	jmp    f0105f46 <sched_print_all+0x125>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f18:	8d 50 20             	lea    0x20(%eax),%edx
f0105f1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f1e:	8b 40 10             	mov    0x10(%eax),%eax
f0105f21:	83 ec 04             	sub    $0x4,%esp
f0105f24:	52                   	push   %edx
f0105f25:	50                   	push   %eax
f0105f26:	68 9e 6e 12 f0       	push   $0xf0126e9e
f0105f2b:	e8 3c b0 ff ff       	call   f0100f6c <cprintf>
f0105f30:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f36:	83 c0 09             	add    $0x9,%eax
f0105f39:	c1 e0 04             	shl    $0x4,%eax
f0105f3c:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0105f41:	8b 00                	mov    (%eax),%eax
f0105f43:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f46:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f4a:	74 08                	je     f0105f54 <sched_print_all+0x133>
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 08             	mov    0x8(%eax),%eax
f0105f52:	eb 05                	jmp    f0105f59 <sched_print_all+0x138>
f0105f54:	b8 00 00 00 00       	mov    $0x0,%eax
f0105f59:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f5c:	83 c2 09             	add    $0x9,%edx
f0105f5f:	c1 e2 04             	shl    $0x4,%edx
f0105f62:	81 c2 08 0e 5a f0    	add    $0xf05a0e08,%edx
f0105f68:	89 02                	mov    %eax,(%edx)
f0105f6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f6d:	83 c0 09             	add    $0x9,%eax
f0105f70:	c1 e0 04             	shl    $0x4,%eax
f0105f73:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0105f78:	8b 00                	mov    (%eax),%eax
f0105f7a:	85 c0                	test   %eax,%eax
f0105f7c:	75 97                	jne    f0105f15 <sched_print_all+0xf4>
f0105f7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f82:	75 91                	jne    f0105f15 <sched_print_all+0xf4>
f0105f84:	eb 13                	jmp    f0105f99 <sched_print_all+0x178>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105f86:	83 ec 08             	sub    $0x8,%esp
f0105f89:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f8c:	68 20 6f 12 f0       	push   $0xf0126f20
f0105f91:	e8 d6 af ff ff       	call   f0100f6c <cprintf>
f0105f96:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105f99:	83 ec 0c             	sub    $0xc,%esp
f0105f9c:	68 c4 6e 12 f0       	push   $0xf0126ec4
f0105fa1:	e8 c6 af ff ff       	call   f0100f6c <cprintf>
f0105fa6:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fa9:	ff 45 f0             	incl   -0x10(%ebp)
f0105fac:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f0105fb1:	0f b6 c0             	movzbl %al,%eax
f0105fb4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fb7:	0f 8f 18 ff ff ff    	jg     f0105ed5 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fbd:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f0105fc2:	85 c0                	test   %eax,%eax
f0105fc4:	74 69                	je     f010602f <sched_print_all+0x20e>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fc6:	83 ec 0c             	sub    $0xc,%esp
f0105fc9:	68 44 6f 12 f0       	push   $0xf0126f44
f0105fce:	e8 99 af ff ff       	call   f0100f6c <cprintf>
f0105fd3:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fd6:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f0105fdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fde:	eb 26                	jmp    f0106006 <sched_print_all+0x1e5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105fe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fe3:	8d 50 20             	lea    0x20(%eax),%edx
f0105fe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fe9:	8b 40 10             	mov    0x10(%eax),%eax
f0105fec:	83 ec 04             	sub    $0x4,%esp
f0105fef:	52                   	push   %edx
f0105ff0:	50                   	push   %eax
f0105ff1:	68 9e 6e 12 f0       	push   $0xf0126e9e
f0105ff6:	e8 71 af ff ff       	call   f0100f6c <cprintf>
f0105ffb:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ffe:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f0106003:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106006:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010600a:	74 08                	je     f0106014 <sched_print_all+0x1f3>
f010600c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600f:	8b 40 08             	mov    0x8(%eax),%eax
f0106012:	eb 05                	jmp    f0106019 <sched_print_all+0x1f8>
f0106014:	b8 00 00 00 00       	mov    $0x0,%eax
f0106019:	a3 88 0e 5a f0       	mov    %eax,0xf05a0e88
f010601e:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f0106023:	85 c0                	test   %eax,%eax
f0106025:	75 b9                	jne    f0105fe0 <sched_print_all+0x1bf>
f0106027:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602b:	75 b3                	jne    f0105fe0 <sched_print_all+0x1bf>
f010602d:	eb 10                	jmp    f010603f <sched_print_all+0x21e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f010602f:	83 ec 0c             	sub    $0xc,%esp
f0106032:	68 66 6f 12 f0       	push   $0xf0126f66
f0106037:	e8 30 af ff ff       	call   f0100f6c <cprintf>
f010603c:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010603f:	83 ec 0c             	sub    $0xc,%esp
f0106042:	68 00 0e 5a f0       	push   $0xf05a0e00
f0106047:	e8 5c 8b 00 00       	call   f010eba8 <release_spinlock>
f010604c:	83 c4 10             	add    $0x10,%esp
}
f010604f:	90                   	nop
f0106050:	c9                   	leave  
f0106051:	c3                   	ret    

f0106052 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106052:	55                   	push   %ebp
f0106053:	89 e5                	mov    %esp,%ebp
f0106055:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106058:	83 ec 0c             	sub    $0xc,%esp
f010605b:	68 00 0e 5a f0       	push   $0xf05a0e00
f0106060:	e8 bc 8a 00 00       	call   f010eb21 <acquire_spinlock>
f0106065:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106068:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f010606f:	a1 7c 0e 5a f0       	mov    0xf05a0e7c,%eax
f0106074:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0106077:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010607e:	eb 24                	jmp    f01060a4 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0106080:	83 ec 0c             	sub    $0xc,%esp
f0106083:	68 70 0e 5a f0       	push   $0xf05a0e70
f0106088:	e8 7c ef ff ff       	call   f0105009 <dequeue>
f010608d:	83 c4 10             	add    $0x10,%esp
f0106090:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f0106093:	83 ec 0c             	sub    $0xc,%esp
f0106096:	ff 75 f0             	pushl  -0x10(%ebp)
f0106099:	e8 4f f1 ff ff       	call   f01051ed <sched_insert_ready0>
f010609e:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060a1:	ff 45 f4             	incl   -0xc(%ebp)
f01060a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060a7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060aa:	7c d4                	jl     f0106080 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060ac:	83 ec 0c             	sub    $0xc,%esp
f01060af:	68 00 0e 5a f0       	push   $0xf05a0e00
f01060b4:	e8 ef 8a 00 00       	call   f010eba8 <release_spinlock>
f01060b9:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060bc:	e8 3c 10 00 00       	call   f01070fd <mycpu>
f01060c1:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060c7:	85 c0                	test   %eax,%eax
f01060c9:	75 05                	jne    f01060d0 <sched_run_all+0x7e>
		fos_scheduler();
f01060cb:	e8 e2 06 00 00       	call   f01067b2 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060d0:	83 ec 04             	sub    $0x4,%esp
f01060d3:	68 84 6f 12 f0       	push   $0xf0126f84
f01060d8:	68 15 02 00 00       	push   $0x215
f01060dd:	68 63 6c 12 f0       	push   $0xf0126c63
f01060e2:	e8 33 a2 ff ff       	call   f010031a <_panic>

f01060e7 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f01060e7:	55                   	push   %ebp
f01060e8:	89 e5                	mov    %esp,%ebp
f01060ea:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060ed:	83 ec 0c             	sub    $0xc,%esp
f01060f0:	68 00 0e 5a f0       	push   $0xf05a0e00
f01060f5:	e8 27 8a 00 00       	call   f010eb21 <acquire_spinlock>
f01060fa:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060fd:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f0106102:	85 c0                	test   %eax,%eax
f0106104:	0f 84 95 00 00 00    	je     f010619f <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010610a:	83 ec 0c             	sub    $0xc,%esp
f010610d:	68 c0 6f 12 f0       	push   $0xf0126fc0
f0106112:	e8 55 ae ff ff       	call   f0100f6c <cprintf>
f0106117:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010611a:	a1 70 0e 5a f0       	mov    0xf05a0e70,%eax
f010611f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106122:	eb 52                	jmp    f0106176 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106127:	8d 50 20             	lea    0x20(%eax),%edx
f010612a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010612d:	8b 40 10             	mov    0x10(%eax),%eax
f0106130:	83 ec 04             	sub    $0x4,%esp
f0106133:	52                   	push   %edx
f0106134:	50                   	push   %eax
f0106135:	68 ec 6f 12 f0       	push   $0xf0126fec
f010613a:	e8 2d ae ff ff       	call   f0100f6c <cprintf>
f010613f:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106142:	83 ec 0c             	sub    $0xc,%esp
f0106145:	ff 75 f4             	pushl  -0xc(%ebp)
f0106148:	e8 f1 f2 ff ff       	call   f010543e <sched_remove_new>
f010614d:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106150:	83 ec 0c             	sub    $0xc,%esp
f0106153:	ff 75 f4             	pushl  -0xc(%ebp)
f0106156:	e8 cd 45 00 00       	call   f010a728 <env_free>
f010615b:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f010615e:	83 ec 0c             	sub    $0xc,%esp
f0106161:	68 26 6e 12 f0       	push   $0xf0126e26
f0106166:	e8 01 ae ff ff       	call   f0100f6c <cprintf>
f010616b:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010616e:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0106173:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106176:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010617a:	74 08                	je     f0106184 <sched_kill_all+0x9d>
f010617c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010617f:	8b 40 08             	mov    0x8(%eax),%eax
f0106182:	eb 05                	jmp    f0106189 <sched_kill_all+0xa2>
f0106184:	b8 00 00 00 00       	mov    $0x0,%eax
f0106189:	a3 78 0e 5a f0       	mov    %eax,0xf05a0e78
f010618e:	a1 78 0e 5a f0       	mov    0xf05a0e78,%eax
f0106193:	85 c0                	test   %eax,%eax
f0106195:	75 8d                	jne    f0106124 <sched_kill_all+0x3d>
f0106197:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619b:	75 87                	jne    f0106124 <sched_kill_all+0x3d>
f010619d:	eb 10                	jmp    f01061af <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f010619f:	83 ec 0c             	sub    $0xc,%esp
f01061a2:	68 ff 6f 12 f0       	push   $0xf0126fff
f01061a7:	e8 c0 ad ff ff       	call   f0100f6c <cprintf>
f01061ac:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061af:	83 ec 0c             	sub    $0xc,%esp
f01061b2:	68 c4 6e 12 f0       	push   $0xf0126ec4
f01061b7:	e8 b0 ad ff ff       	call   f0100f6c <cprintf>
f01061bc:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061c6:	e9 b8 01 00 00       	jmp    f0106383 <sched_kill_all+0x29c>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01061ce:	83 c0 09             	add    $0x9,%eax
f01061d1:	c1 e0 04             	shl    $0x4,%eax
f01061d4:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f01061d9:	8b 00                	mov    (%eax),%eax
f01061db:	85 c0                	test   %eax,%eax
f01061dd:	0f 84 7a 01 00 00    	je     f010635d <sched_kill_all+0x276>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f01061e3:	83 ec 08             	sub    $0x8,%esp
f01061e6:	ff 75 f0             	pushl  -0x10(%ebp)
f01061e9:	68 1c 70 12 f0       	push   $0xf012701c
f01061ee:	e8 79 ad ff ff       	call   f0100f6c <cprintf>
f01061f3:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01061f9:	83 c0 09             	add    $0x9,%eax
f01061fc:	c1 e0 04             	shl    $0x4,%eax
f01061ff:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f0106204:	8b 00                	mov    (%eax),%eax
f0106206:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106209:	e9 07 01 00 00       	jmp    f0106315 <sched_kill_all+0x22e>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010620e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106211:	8d 50 20             	lea    0x20(%eax),%edx
f0106214:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106217:	8b 40 10             	mov    0x10(%eax),%eax
f010621a:	83 ec 04             	sub    $0x4,%esp
f010621d:	52                   	push   %edx
f010621e:	50                   	push   %eax
f010621f:	68 ec 6f 12 f0       	push   $0xf0126fec
f0106224:	e8 43 ad ff ff       	call   f0100f6c <cprintf>
f0106229:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010622c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106230:	75 17                	jne    f0106249 <sched_kill_all+0x162>
f0106232:	83 ec 04             	sub    $0x4,%esp
f0106235:	68 9f 6c 12 f0       	push   $0xf0126c9f
f010623a:	68 37 02 00 00       	push   $0x237
f010623f:	68 63 6c 12 f0       	push   $0xf0126c63
f0106244:	e8 d1 a0 ff ff       	call   f010031a <_panic>
f0106249:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010624c:	8b 40 08             	mov    0x8(%eax),%eax
f010624f:	85 c0                	test   %eax,%eax
f0106251:	74 11                	je     f0106264 <sched_kill_all+0x17d>
f0106253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106256:	8b 40 08             	mov    0x8(%eax),%eax
f0106259:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010625c:	8b 52 0c             	mov    0xc(%edx),%edx
f010625f:	89 50 0c             	mov    %edx,0xc(%eax)
f0106262:	eb 17                	jmp    f010627b <sched_kill_all+0x194>
f0106264:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106267:	8b 40 0c             	mov    0xc(%eax),%eax
f010626a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010626d:	83 c2 09             	add    $0x9,%edx
f0106270:	c1 e2 04             	shl    $0x4,%edx
f0106273:	81 c2 04 0e 5a f0    	add    $0xf05a0e04,%edx
f0106279:	89 02                	mov    %eax,(%edx)
f010627b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010627e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106281:	85 c0                	test   %eax,%eax
f0106283:	74 11                	je     f0106296 <sched_kill_all+0x1af>
f0106285:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106288:	8b 40 0c             	mov    0xc(%eax),%eax
f010628b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010628e:	8b 52 08             	mov    0x8(%edx),%edx
f0106291:	89 50 08             	mov    %edx,0x8(%eax)
f0106294:	eb 17                	jmp    f01062ad <sched_kill_all+0x1c6>
f0106296:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106299:	8b 40 08             	mov    0x8(%eax),%eax
f010629c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010629f:	83 c2 09             	add    $0x9,%edx
f01062a2:	c1 e2 04             	shl    $0x4,%edx
f01062a5:	81 c2 00 0e 5a f0    	add    $0xf05a0e00,%edx
f01062ab:	89 02                	mov    %eax,(%edx)
f01062ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062b0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ba:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062c4:	83 c0 09             	add    $0x9,%eax
f01062c7:	c1 e0 04             	shl    $0x4,%eax
f01062ca:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f01062cf:	8b 00                	mov    (%eax),%eax
f01062d1:	8d 50 ff             	lea    -0x1(%eax),%edx
f01062d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062d7:	83 c0 09             	add    $0x9,%eax
f01062da:	c1 e0 04             	shl    $0x4,%eax
f01062dd:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f01062e2:	89 10                	mov    %edx,(%eax)
				env_free(ptr_env);
f01062e4:	83 ec 0c             	sub    $0xc,%esp
f01062e7:	ff 75 f4             	pushl  -0xc(%ebp)
f01062ea:	e8 39 44 00 00       	call   f010a728 <env_free>
f01062ef:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f01062f2:	83 ec 0c             	sub    $0xc,%esp
f01062f5:	68 26 6e 12 f0       	push   $0xf0126e26
f01062fa:	e8 6d ac ff ff       	call   f0100f6c <cprintf>
f01062ff:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106302:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106305:	83 c0 09             	add    $0x9,%eax
f0106308:	c1 e0 04             	shl    $0x4,%eax
f010630b:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0106310:	8b 00                	mov    (%eax),%eax
f0106312:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106315:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106319:	74 08                	je     f0106323 <sched_kill_all+0x23c>
f010631b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	eb 05                	jmp    f0106328 <sched_kill_all+0x241>
f0106323:	b8 00 00 00 00       	mov    $0x0,%eax
f0106328:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632b:	83 c2 09             	add    $0x9,%edx
f010632e:	c1 e2 04             	shl    $0x4,%edx
f0106331:	81 c2 08 0e 5a f0    	add    $0xf05a0e08,%edx
f0106337:	89 02                	mov    %eax,(%edx)
f0106339:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010633c:	83 c0 09             	add    $0x9,%eax
f010633f:	c1 e0 04             	shl    $0x4,%eax
f0106342:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0106347:	8b 00                	mov    (%eax),%eax
f0106349:	85 c0                	test   %eax,%eax
f010634b:	0f 85 bd fe ff ff    	jne    f010620e <sched_kill_all+0x127>
f0106351:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106355:	0f 85 b3 fe ff ff    	jne    f010620e <sched_kill_all+0x127>
f010635b:	eb 13                	jmp    f0106370 <sched_kill_all+0x289>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635d:	83 ec 08             	sub    $0x8,%esp
f0106360:	ff 75 f0             	pushl  -0x10(%ebp)
f0106363:	68 20 6f 12 f0       	push   $0xf0126f20
f0106368:	e8 ff ab ff ff       	call   f0100f6c <cprintf>
f010636d:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106370:	83 ec 0c             	sub    $0xc,%esp
f0106373:	68 c4 6e 12 f0       	push   $0xf0126ec4
f0106378:	e8 ef ab ff ff       	call   f0100f6c <cprintf>
f010637d:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106380:	ff 45 f0             	incl   -0x10(%ebp)
f0106383:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f0106388:	0f b6 c0             	movzbl %al,%eax
f010638b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638e:	0f 8f 37 fe ff ff    	jg     f01061cb <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106394:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f0106399:	85 c0                	test   %eax,%eax
f010639b:	0f 84 95 00 00 00    	je     f0106436 <sched_kill_all+0x34f>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a1:	83 ec 0c             	sub    $0xc,%esp
f01063a4:	68 50 70 12 f0       	push   $0xf0127050
f01063a9:	e8 be ab ff ff       	call   f0100f6c <cprintf>
f01063ae:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b1:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f01063b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063b9:	eb 52                	jmp    f010640d <sched_kill_all+0x326>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063be:	8d 50 20             	lea    0x20(%eax),%edx
f01063c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c4:	8b 40 10             	mov    0x10(%eax),%eax
f01063c7:	83 ec 04             	sub    $0x4,%esp
f01063ca:	52                   	push   %edx
f01063cb:	50                   	push   %eax
f01063cc:	68 ec 6f 12 f0       	push   $0xf0126fec
f01063d1:	e8 96 ab ff ff       	call   f0100f6c <cprintf>
f01063d6:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063d9:	83 ec 0c             	sub    $0xc,%esp
f01063dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01063df:	e8 d1 f1 ff ff       	call   f01055b5 <sched_remove_exit>
f01063e4:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e7:	83 ec 0c             	sub    $0xc,%esp
f01063ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ed:	e8 36 43 00 00       	call   f010a728 <env_free>
f01063f2:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f5:	83 ec 0c             	sub    $0xc,%esp
f01063f8:	68 26 6e 12 f0       	push   $0xf0126e26
f01063fd:	e8 6a ab ff ff       	call   f0100f6c <cprintf>
f0106402:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106405:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f010640a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106411:	74 08                	je     f010641b <sched_kill_all+0x334>
f0106413:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106416:	8b 40 08             	mov    0x8(%eax),%eax
f0106419:	eb 05                	jmp    f0106420 <sched_kill_all+0x339>
f010641b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106420:	a3 88 0e 5a f0       	mov    %eax,0xf05a0e88
f0106425:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f010642a:	85 c0                	test   %eax,%eax
f010642c:	75 8d                	jne    f01063bb <sched_kill_all+0x2d4>
f010642e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106432:	75 87                	jne    f01063bb <sched_kill_all+0x2d4>
f0106434:	eb 10                	jmp    f0106446 <sched_kill_all+0x35f>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106436:	83 ec 0c             	sub    $0xc,%esp
f0106439:	68 66 6f 12 f0       	push   $0xf0126f66
f010643e:	e8 29 ab ff ff       	call   f0100f6c <cprintf>
f0106443:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106446:	e8 25 43 00 00       	call   f010a770 <get_cpu_proc>
f010644b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106452:	74 6b                	je     f01064bf <sched_kill_all+0x3d8>
	{
		ptr_env = cur_env;
f0106454:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106457:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645d:	8b 40 18             	mov    0x18(%eax),%eax
f0106460:	83 f8 02             	cmp    $0x2,%eax
f0106463:	74 19                	je     f010647e <sched_kill_all+0x397>
f0106465:	68 2c 6e 12 f0       	push   $0xf0126e2c
f010646a:	68 4e 6c 12 f0       	push   $0xf0126c4e
f010646f:	68 57 02 00 00       	push   $0x257
f0106474:	68 63 6c 12 f0       	push   $0xf0126c63
f0106479:	e8 9c 9e ff ff       	call   f010031a <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106481:	8d 50 20             	lea    0x20(%eax),%edx
f0106484:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106487:	8b 40 10             	mov    0x10(%eax),%eax
f010648a:	83 ec 04             	sub    $0x4,%esp
f010648d:	52                   	push   %edx
f010648e:	50                   	push   %eax
f010648f:	68 50 6e 12 f0       	push   $0xf0126e50
f0106494:	e8 d3 aa ff ff       	call   f0100f6c <cprintf>
f0106499:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649c:	83 ec 0c             	sub    $0xc,%esp
f010649f:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a2:	e8 81 42 00 00       	call   f010a728 <env_free>
f01064a7:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064aa:	83 ec 0c             	sub    $0xc,%esp
f01064ad:	68 26 6e 12 f0       	push   $0xf0126e26
f01064b2:	e8 b5 aa ff ff       	call   f0100f6c <cprintf>
f01064b7:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064ba:	e8 3e 44 00 00       	call   f010a8fd <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064bf:	83 ec 0c             	sub    $0xc,%esp
f01064c2:	68 00 0e 5a f0       	push   $0xf05a0e00
f01064c7:	e8 dc 86 00 00       	call   f010eba8 <release_spinlock>
f01064cc:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064cf:	e8 cf b8 ff ff       	call   f0101da3 <get_into_prompt>

f01064d4 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d4:	55                   	push   %ebp
f01064d5:	89 e5                	mov    %esp,%ebp
f01064d7:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064da:	83 ec 0c             	sub    $0xc,%esp
f01064dd:	68 00 0e 5a f0       	push   $0xf05a0e00
f01064e2:	e8 3a 86 00 00       	call   f010eb21 <acquire_spinlock>
f01064e7:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f8:	e9 59 01 00 00       	jmp    f0106656 <sched_exit_all_ready_envs+0x182>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106500:	83 c0 09             	add    $0x9,%eax
f0106503:	c1 e0 04             	shl    $0x4,%eax
f0106506:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 3e 01 00 00    	je     f0106653 <sched_exit_all_ready_envs+0x17f>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010651f:	83 c0 09             	add    $0x9,%eax
f0106522:	c1 e0 04             	shl    $0x4,%eax
f0106525:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f010652a:	8b 00                	mov    (%eax),%eax
f010652c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652f:	e9 d9 00 00 00       	jmp    f010660d <sched_exit_all_ready_envs+0x139>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106534:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106538:	75 17                	jne    f0106551 <sched_exit_all_ready_envs+0x7d>
f010653a:	83 ec 04             	sub    $0x4,%esp
f010653d:	68 9f 6c 12 f0       	push   $0xf0126c9f
f0106542:	68 79 02 00 00       	push   $0x279
f0106547:	68 63 6c 12 f0       	push   $0xf0126c63
f010654c:	e8 c9 9d ff ff       	call   f010031a <_panic>
f0106551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106554:	8b 40 08             	mov    0x8(%eax),%eax
f0106557:	85 c0                	test   %eax,%eax
f0106559:	74 11                	je     f010656c <sched_exit_all_ready_envs+0x98>
f010655b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655e:	8b 40 08             	mov    0x8(%eax),%eax
f0106561:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106564:	8b 52 0c             	mov    0xc(%edx),%edx
f0106567:	89 50 0c             	mov    %edx,0xc(%eax)
f010656a:	eb 17                	jmp    f0106583 <sched_exit_all_ready_envs+0xaf>
f010656c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010656f:	8b 40 0c             	mov    0xc(%eax),%eax
f0106572:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106575:	83 c2 09             	add    $0x9,%edx
f0106578:	c1 e2 04             	shl    $0x4,%edx
f010657b:	81 c2 04 0e 5a f0    	add    $0xf05a0e04,%edx
f0106581:	89 02                	mov    %eax,(%edx)
f0106583:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106586:	8b 40 0c             	mov    0xc(%eax),%eax
f0106589:	85 c0                	test   %eax,%eax
f010658b:	74 11                	je     f010659e <sched_exit_all_ready_envs+0xca>
f010658d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106590:	8b 40 0c             	mov    0xc(%eax),%eax
f0106593:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106596:	8b 52 08             	mov    0x8(%edx),%edx
f0106599:	89 50 08             	mov    %edx,0x8(%eax)
f010659c:	eb 17                	jmp    f01065b5 <sched_exit_all_ready_envs+0xe1>
f010659e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065a1:	8b 40 08             	mov    0x8(%eax),%eax
f01065a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a7:	83 c2 09             	add    $0x9,%edx
f01065aa:	c1 e2 04             	shl    $0x4,%edx
f01065ad:	81 c2 00 0e 5a f0    	add    $0xf05a0e00,%edx
f01065b3:	89 02                	mov    %eax,(%edx)
f01065b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065c2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01065cc:	83 c0 09             	add    $0x9,%eax
f01065cf:	c1 e0 04             	shl    $0x4,%eax
f01065d2:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f01065d7:	8b 00                	mov    (%eax),%eax
f01065d9:	8d 50 ff             	lea    -0x1(%eax),%edx
f01065dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01065df:	83 c0 09             	add    $0x9,%eax
f01065e2:	c1 e0 04             	shl    $0x4,%eax
f01065e5:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f01065ea:	89 10                	mov    %edx,(%eax)
				sched_insert_exit(ptr_env);
f01065ec:	83 ec 0c             	sub    $0xc,%esp
f01065ef:	ff 75 f4             	pushl  -0xc(%ebp)
f01065f2:	e8 37 ef ff ff       	call   f010552e <sched_insert_exit>
f01065f7:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01065fd:	83 c0 09             	add    $0x9,%eax
f0106600:	c1 e0 04             	shl    $0x4,%eax
f0106603:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0106608:	8b 00                	mov    (%eax),%eax
f010660a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010660d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106611:	74 08                	je     f010661b <sched_exit_all_ready_envs+0x147>
f0106613:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106616:	8b 40 08             	mov    0x8(%eax),%eax
f0106619:	eb 05                	jmp    f0106620 <sched_exit_all_ready_envs+0x14c>
f010661b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106620:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106623:	83 c2 09             	add    $0x9,%edx
f0106626:	c1 e2 04             	shl    $0x4,%edx
f0106629:	81 c2 08 0e 5a f0    	add    $0xf05a0e08,%edx
f010662f:	89 02                	mov    %eax,(%edx)
f0106631:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106634:	83 c0 09             	add    $0x9,%eax
f0106637:	c1 e0 04             	shl    $0x4,%eax
f010663a:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f010663f:	8b 00                	mov    (%eax),%eax
f0106641:	85 c0                	test   %eax,%eax
f0106643:	0f 85 eb fe ff ff    	jne    f0106534 <sched_exit_all_ready_envs+0x60>
f0106649:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010664d:	0f 85 e1 fe ff ff    	jne    f0106534 <sched_exit_all_ready_envs+0x60>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106653:	ff 45 f0             	incl   -0x10(%ebp)
f0106656:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f010665b:	0f b6 c0             	movzbl %al,%eax
f010665e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106661:	0f 8f 96 fe ff ff    	jg     f01064fd <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106667:	83 ec 0c             	sub    $0xc,%esp
f010666a:	68 00 0e 5a f0       	push   $0xf05a0e00
f010666f:	e8 34 85 00 00       	call   f010eba8 <release_spinlock>
f0106674:	83 c4 10             	add    $0x10,%esp
}
f0106677:	90                   	nop
f0106678:	c9                   	leave  
f0106679:	c3                   	ret    

f010667a <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f010667a:	55                   	push   %ebp
f010667b:	89 e5                	mov    %esp,%ebp
	return ticks;
f010667d:	a1 68 3a 5a f0       	mov    0xf05a3a68,%eax
f0106682:	8b 15 6c 3a 5a f0    	mov    0xf05a3a6c,%edx
}
f0106688:	5d                   	pop    %ebp
f0106689:	c3                   	ret    

f010668a <env_get_nice>:
int env_get_nice(struct Env* e)
{
f010668a:	55                   	push   %ebp
f010668b:	89 e5                	mov    %esp,%ebp
f010668d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106690:	83 ec 04             	sub    $0x4,%esp
f0106693:	68 7c 70 12 f0       	push   $0xf012707c
f0106698:	68 8c 02 00 00       	push   $0x28c
f010669d:	68 63 6c 12 f0       	push   $0xf0126c63
f01066a2:	e8 73 9c ff ff       	call   f010031a <_panic>

f01066a7 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01066a7:	55                   	push   %ebp
f01066a8:	89 e5                	mov    %esp,%ebp
f01066aa:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066ad:	83 ec 04             	sub    $0x4,%esp
f01066b0:	68 7c 70 12 f0       	push   $0xf012707c
f01066b5:	68 94 02 00 00       	push   $0x294
f01066ba:	68 63 6c 12 f0       	push   $0xf0126c63
f01066bf:	e8 56 9c ff ff       	call   f010031a <_panic>

f01066c4 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066c4:	55                   	push   %ebp
f01066c5:	89 e5                	mov    %esp,%ebp
f01066c7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066ca:	83 ec 04             	sub    $0x4,%esp
f01066cd:	68 7c 70 12 f0       	push   $0xf012707c
f01066d2:	68 9c 02 00 00       	push   $0x29c
f01066d7:	68 63 6c 12 f0       	push   $0xf0126c63
f01066dc:	e8 39 9c ff ff       	call   f010031a <_panic>

f01066e1 <get_load_average>:
}
int get_load_average()
{
f01066e1:	55                   	push   %ebp
f01066e2:	89 e5                	mov    %esp,%ebp
f01066e4:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066e7:	83 ec 04             	sub    $0x4,%esp
f01066ea:	68 7c 70 12 f0       	push   $0xf012707c
f01066ef:	68 a4 02 00 00       	push   $0x2a4
f01066f4:	68 63 6c 12 f0       	push   $0xf0126c63
f01066f9:	e8 1c 9c ff ff       	call   f010031a <_panic>

f01066fe <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066fe:	55                   	push   %ebp
f01066ff:	89 e5                	mov    %esp,%ebp
f0106701:	a1 b4 38 5a f0       	mov    0xf05a38b4,%eax
f0106706:	85 c0                	test   %eax,%eax
f0106708:	75 07                	jne    f0106711 <isSchedMethodRR+0x13>
f010670a:	b8 01 00 00 00       	mov    $0x1,%eax
f010670f:	eb 05                	jmp    f0106716 <isSchedMethodRR+0x18>
f0106711:	b8 00 00 00 00       	mov    $0x0,%eax
f0106716:	5d                   	pop    %ebp
f0106717:	c3                   	ret    

f0106718 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f0106718:	55                   	push   %ebp
f0106719:	89 e5                	mov    %esp,%ebp
f010671b:	a1 b4 38 5a f0       	mov    0xf05a38b4,%eax
f0106720:	83 f8 01             	cmp    $0x1,%eax
f0106723:	75 07                	jne    f010672c <isSchedMethodMLFQ+0x14>
f0106725:	b8 01 00 00 00       	mov    $0x1,%eax
f010672a:	eb 05                	jmp    f0106731 <isSchedMethodMLFQ+0x19>
f010672c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106731:	5d                   	pop    %ebp
f0106732:	c3                   	ret    

f0106733 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106733:	55                   	push   %ebp
f0106734:	89 e5                	mov    %esp,%ebp
f0106736:	a1 b4 38 5a f0       	mov    0xf05a38b4,%eax
f010673b:	83 f8 02             	cmp    $0x2,%eax
f010673e:	75 07                	jne    f0106747 <isSchedMethodBSD+0x14>
f0106740:	b8 01 00 00 00       	mov    $0x1,%eax
f0106745:	eb 05                	jmp    f010674c <isSchedMethodBSD+0x19>
f0106747:	b8 00 00 00 00       	mov    $0x0,%eax
f010674c:	5d                   	pop    %ebp
f010674d:	c3                   	ret    

f010674e <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010674e:	55                   	push   %ebp
f010674f:	89 e5                	mov    %esp,%ebp
f0106751:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106754:	c7 05 88 35 5a f0 00 	movl   $0x0,0xf05a3588
f010675b:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010675e:	83 ec 0c             	sub    $0xc,%esp
f0106761:	6a 0a                	push   $0xa
f0106763:	e8 6d 02 00 00       	call   f01069d5 <sched_init_RR>
f0106768:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010676b:	83 ec 0c             	sub    $0xc,%esp
f010676e:	68 70 0e 5a f0       	push   $0xf05a0e70
f0106773:	e8 bf e7 ff ff       	call   f0104f37 <init_queue>
f0106778:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010677b:	83 ec 0c             	sub    $0xc,%esp
f010677e:	68 80 0e 5a f0       	push   $0xf05a0e80
f0106783:	e8 af e7 ff ff       	call   f0104f37 <init_queue>
f0106788:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010678b:	e8 6d 09 00 00       	call   f01070fd <mycpu>
f0106790:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106797:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f010679a:	83 ec 08             	sub    $0x8,%esp
f010679d:	68 90 70 12 f0       	push   $0xf0127090
f01067a2:	68 00 0e 5a f0       	push   $0xf05a0e00
f01067a7:	e8 44 83 00 00       	call   f010eaf0 <init_spinlock>
f01067ac:	83 c4 10             	add    $0x10,%esp
}
f01067af:	90                   	nop
f01067b0:	c9                   	leave  
f01067b1:	c3                   	ret    

f01067b2 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f01067b2:	55                   	push   %ebp
f01067b3:	89 e5                	mov    %esp,%ebp
f01067b5:	53                   	push   %ebx
f01067b6:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01067b9:	9c                   	pushf  
f01067ba:	58                   	pop    %eax
f01067bb:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f01067be:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067c1:	25 00 02 00 00       	and    $0x200,%eax
f01067c6:	85 c0                	test   %eax,%eax
f01067c8:	74 14                	je     f01067de <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067ca:	83 ec 04             	sub    $0x4,%esp
f01067cd:	68 a4 70 12 f0       	push   $0xf01270a4
f01067d2:	6a 37                	push   $0x37
f01067d4:	68 da 70 12 f0       	push   $0xf01270da
f01067d9:	e8 3c 9b ff ff       	call   f010031a <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067de:	e8 1a 09 00 00       	call   f01070fd <mycpu>
f01067e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067e9:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067f0:	00 00 00 

	chk1();
f01067f3:	e8 a2 af 01 00       	call   f012179a <chk1>
	c->scheduler_status = SCH_STARTED;
f01067f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067fb:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106802:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106805:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f010680c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106813:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106814:	83 ec 0c             	sub    $0xc,%esp
f0106817:	68 00 0e 5a f0       	push   $0xf05a0e00
f010681c:	e8 00 83 00 00       	call   f010eb21 <acquire_spinlock>
f0106821:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106824:	a1 b4 38 5a f0       	mov    0xf05a38b4,%eax
f0106829:	8b 04 85 4c f9 17 f0 	mov    -0xfe806b4(,%eax,4),%eax
f0106830:	ff d0                	call   *%eax
f0106832:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106835:	e8 36 3f 00 00       	call   f010a770 <get_cpu_proc>
f010683a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010683d:	83 ec 0c             	sub    $0xc,%esp
f0106840:	ff 75 e8             	pushl  -0x18(%ebp)
f0106843:	e8 51 3f 00 00       	call   f010a799 <set_cpu_proc>
f0106848:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010684b:	83 ec 0c             	sub    $0xc,%esp
f010684e:	ff 75 e8             	pushl  -0x18(%ebp)
f0106851:	e8 4a af 01 00       	call   f01217a0 <chk2>
f0106856:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106859:	83 ec 0c             	sub    $0xc,%esp
f010685c:	ff 75 e0             	pushl  -0x20(%ebp)
f010685f:	e8 35 3f 00 00       	call   f010a799 <set_cpu_proc>
f0106864:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106867:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010686b:	0f 84 d6 00 00 00    	je     f0106947 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106871:	83 ec 0c             	sub    $0xc,%esp
f0106874:	ff 75 e8             	pushl  -0x18(%ebp)
f0106877:	e8 1d 3f 00 00       	call   f010a799 <set_cpu_proc>
f010687c:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010687f:	83 ec 0c             	sub    $0xc,%esp
f0106882:	ff 75 e8             	pushl  -0x18(%ebp)
f0106885:	e8 96 41 00 00       	call   f010aa20 <switchuvm>
f010688a:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010688d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106890:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106897:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010689a:	8b 40 04             	mov    0x4(%eax),%eax
f010689d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01068a0:	83 c2 04             	add    $0x4,%edx
f01068a3:	83 ec 08             	sub    $0x8,%esp
f01068a6:	50                   	push   %eax
f01068a7:	52                   	push   %edx
f01068a8:	e8 92 e2 ff ff       	call   f0104b3f <context_switch>
f01068ad:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01068b0:	9c                   	pushf  
f01068b1:	58                   	pop    %eax
f01068b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f01068b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f01068b8:	25 00 02 00 00       	and    $0x200,%eax
f01068bd:	85 c0                	test   %eax,%eax
f01068bf:	74 14                	je     f01068d5 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068c1:	83 ec 04             	sub    $0x4,%esp
f01068c4:	68 ec 70 12 f0       	push   $0xf01270ec
f01068c9:	6a 74                	push   $0x74
f01068cb:	68 da 70 12 f0       	push   $0xf01270da
f01068d0:	e8 45 9a ff ff       	call   f010031a <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068d5:	e8 ae e3 ff ff       	call   f0104c88 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068da:	e8 91 3e 00 00       	call   f010a770 <get_cpu_proc>
f01068df:	89 c2                	mov    %eax,%edx
f01068e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e4:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ea:	39 c2                	cmp    %eax,%edx
f01068ec:	74 16                	je     f0106904 <fos_scheduler+0x152>
f01068ee:	68 23 71 12 f0       	push   $0xf0127123
f01068f3:	68 3d 71 12 f0       	push   $0xf012713d
f01068f8:	6a 7d                	push   $0x7d
f01068fa:	68 da 70 12 f0       	push   $0xf01270da
f01068ff:	e8 16 9a ff ff       	call   f010031a <_panic>
				int status = c->proc->env_status ;
f0106904:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106907:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010690d:	8b 40 18             	mov    0x18(%eax),%eax
f0106910:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106913:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106917:	75 16                	jne    f010692f <fos_scheduler+0x17d>
f0106919:	68 52 71 12 f0       	push   $0xf0127152
f010691e:	68 3d 71 12 f0       	push   $0xf012713d
f0106923:	6a 7f                	push   $0x7f
f0106925:	68 da 70 12 f0       	push   $0xf01270da
f010692a:	e8 eb 99 ff ff       	call   f010031a <_panic>
				if (status == ENV_READY)
f010692f:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106933:	74 12                	je     f0106947 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106935:	e8 cf 40 00 00       	call   f010aa09 <switchkvm>
					set_cpu_proc(NULL);
f010693a:	83 ec 0c             	sub    $0xc,%esp
f010693d:	6a 00                	push   $0x0
f010693f:	e8 55 3e 00 00       	call   f010a799 <set_cpu_proc>
f0106944:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106947:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010694b:	0f 85 d3 fe ff ff    	jne    f0106824 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106951:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106958:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010695f:	eb 4d                	jmp    f01069ae <fos_scheduler+0x1fc>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106961:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f0106967:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010696a:	89 d0                	mov    %edx,%eax
f010696c:	c1 e0 06             	shl    $0x6,%eax
f010696f:	29 d0                	sub    %edx,%eax
f0106971:	c1 e0 02             	shl    $0x2,%eax
f0106974:	01 d0                	add    %edx,%eax
f0106976:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f010697d:	01 d8                	add    %ebx,%eax
f010697f:	c1 e0 03             	shl    $0x3,%eax
f0106982:	01 d0                	add    %edx,%eax
f0106984:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010698b:	29 c2                	sub    %eax,%edx
f010698d:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0106994:	89 c2                	mov    %eax,%edx
f0106996:	89 d0                	mov    %edx,%eax
f0106998:	01 c8                	add    %ecx,%eax
f010699a:	8b 40 18             	mov    0x18(%eax),%eax
f010699d:	83 f8 03             	cmp    $0x3,%eax
f01069a0:	75 09                	jne    f01069ab <fos_scheduler+0x1f9>
			{
				is_any_blocked = 1;
f01069a2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f01069a9:	eb 0b                	jmp    f01069b6 <fos_scheduler+0x204>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f01069ab:	ff 45 f0             	incl   -0x10(%ebp)
f01069ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01069b1:	83 f8 07             	cmp    $0x7,%eax
f01069b4:	76 ab                	jbe    f0106961 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f01069b6:	83 ec 0c             	sub    $0xc,%esp
f01069b9:	68 00 0e 5a f0       	push   $0xf05a0e00
f01069be:	e8 e5 81 00 00       	call   f010eba8 <release_spinlock>
f01069c3:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f01069c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01069ca:	0f 8f 43 fe ff ff    	jg     f0106813 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069d0:	e8 ce b3 ff ff       	call   f0101da3 <get_into_prompt>

f01069d5 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069d5:	55                   	push   %ebp
f01069d6:	89 e5                	mov    %esp,%ebp
f01069d8:	83 ec 28             	sub    $0x28,%esp
f01069db:	8b 45 08             	mov    0x8(%ebp),%eax
f01069de:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069e1:	c6 05 00 3b 5a f0 01 	movb   $0x1,0xf05a3b00
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069e8:	8a 45 e4             	mov    -0x1c(%ebp),%al
f01069eb:	a2 84 37 5a f0       	mov    %al,0xf05a3784
	kclock_set_quantum(quantums[0]);
f01069f0:	a0 84 37 5a f0       	mov    0xf05a3784,%al
f01069f5:	0f b6 c0             	movzbl %al,%eax
f01069f8:	83 ec 0c             	sub    $0xc,%esp
f01069fb:	50                   	push   %eax
f01069fc:	e8 50 e3 ff ff       	call   f0104d51 <kclock_set_quantum>
f0106a01:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a04:	83 ec 0c             	sub    $0xc,%esp
f0106a07:	68 90 0e 5a f0       	push   $0xf05a0e90
f0106a0c:	e8 26 e5 ff ff       	call   f0104f37 <init_queue>
f0106a11:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a14:	e8 97 e4 ff ff       	call   f0104eb0 <kclock_read_cnt0_latch>
f0106a19:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a1d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a21:	83 ec 08             	sub    $0x8,%esp
f0106a24:	50                   	push   %eax
f0106a25:	68 68 71 12 f0       	push   $0xf0127168
f0106a2a:	e8 3d a5 ff ff       	call   f0100f6c <cprintf>
f0106a2f:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a32:	e8 c6 06 00 00       	call   f01070fd <mycpu>
f0106a37:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a3e:	00 00 00 
	scheduler_method = SCH_RR;
f0106a41:	c7 05 b4 38 5a f0 00 	movl   $0x0,0xf05a38b4
f0106a48:	00 00 00 
	//=========================================
	//=========================================
}
f0106a4b:	90                   	nop
f0106a4c:	c9                   	leave  
f0106a4d:	c3                   	ret    

f0106a4e <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a4e:	55                   	push   %ebp
f0106a4f:	89 e5                	mov    %esp,%ebp
f0106a51:	83 ec 18             	sub    $0x18,%esp
f0106a54:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a57:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a5a:	e8 88 e7 ff ff       	call   f01051e7 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a5f:	83 ec 04             	sub    $0x4,%esp
f0106a62:	68 90 71 12 f0       	push   $0xf0127190
f0106a67:	68 ce 00 00 00       	push   $0xce
f0106a6c:	68 da 70 12 f0       	push   $0xf01270da
f0106a71:	e8 a4 98 ff ff       	call   f010031a <_panic>

f0106a76 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a76:	55                   	push   %ebp
f0106a77:	89 e5                	mov    %esp,%ebp
f0106a79:	83 ec 18             	sub    $0x18,%esp
f0106a7c:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a82:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a85:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a88:	83 ec 04             	sub    $0x4,%esp
f0106a8b:	68 90 71 12 f0       	push   $0xf0127190
f0106a90:	68 e4 00 00 00       	push   $0xe4
f0106a95:	68 da 70 12 f0       	push   $0xf01270da
f0106a9a:	e8 7b 98 ff ff       	call   f010031a <_panic>

f0106a9f <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106a9f:	55                   	push   %ebp
f0106aa0:	89 e5                	mov    %esp,%ebp
f0106aa2:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aa5:	83 ec 0c             	sub    $0xc,%esp
f0106aa8:	68 00 0e 5a f0       	push   $0xf05a0e00
f0106aad:	e8 88 82 00 00       	call   f010ed3a <holding_spinlock>
f0106ab2:	83 c4 10             	add    $0x10,%esp
f0106ab5:	85 c0                	test   %eax,%eax
f0106ab7:	75 17                	jne    f0106ad0 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ab9:	83 ec 04             	sub    $0x4,%esp
f0106abc:	68 a4 71 12 f0       	push   $0xf01271a4
f0106ac1:	68 fe 00 00 00       	push   $0xfe
f0106ac6:	68 da 70 12 f0       	push   $0xf01270da
f0106acb:	e8 4a 98 ff ff       	call   f010031a <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ad7:	e8 94 3c 00 00       	call   f010a770 <get_cpu_proc>
f0106adc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106adf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106ae3:	74 13                	je     f0106af8 <fos_scheduler_RR+0x59>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106ae5:	83 ec 08             	sub    $0x8,%esp
f0106ae8:	ff 75 f0             	pushl  -0x10(%ebp)
f0106aeb:	68 90 0e 5a f0       	push   $0xf05a0e90
f0106af0:	e8 83 e4 ff ff       	call   f0104f78 <enqueue>
f0106af5:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106af8:	83 ec 0c             	sub    $0xc,%esp
f0106afb:	68 90 0e 5a f0       	push   $0xf05a0e90
f0106b00:	e8 04 e5 ff ff       	call   f0105009 <dequeue>
f0106b05:	83 c4 10             	add    $0x10,%esp
f0106b08:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b0b:	a0 84 37 5a f0       	mov    0xf05a3784,%al
f0106b10:	0f b6 c0             	movzbl %al,%eax
f0106b13:	83 ec 0c             	sub    $0xc,%esp
f0106b16:	50                   	push   %eax
f0106b17:	e8 35 e2 ff ff       	call   f0104d51 <kclock_set_quantum>
f0106b1c:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b22:	c9                   	leave  
f0106b23:	c3                   	ret    

f0106b24 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b24:	55                   	push   %ebp
f0106b25:	89 e5                	mov    %esp,%ebp
f0106b27:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b2a:	83 ec 0c             	sub    $0xc,%esp
f0106b2d:	68 00 0e 5a f0       	push   $0xf05a0e00
f0106b32:	e8 03 82 00 00       	call   f010ed3a <holding_spinlock>
f0106b37:	83 c4 10             	add    $0x10,%esp
f0106b3a:	85 c0                	test   %eax,%eax
f0106b3c:	75 17                	jne    f0106b55 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b3e:	83 ec 04             	sub    $0x4,%esp
f0106b41:	68 f0 71 12 f0       	push   $0xf01271f0
f0106b46:	68 1d 01 00 00       	push   $0x11d
f0106b4b:	68 da 70 12 f0       	push   $0xf01270da
f0106b50:	e8 c5 97 ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b55:	83 ec 04             	sub    $0x4,%esp
f0106b58:	68 90 71 12 f0       	push   $0xf0127190
f0106b5d:	68 23 01 00 00       	push   $0x123
f0106b62:	68 da 70 12 f0       	push   $0xf01270da
f0106b67:	e8 ae 97 ff ff       	call   f010031a <_panic>

f0106b6c <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b6c:	55                   	push   %ebp
f0106b6d:	89 e5                	mov    %esp,%ebp
f0106b6f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b72:	83 ec 0c             	sub    $0xc,%esp
f0106b75:	68 00 0e 5a f0       	push   $0xf05a0e00
f0106b7a:	e8 bb 81 00 00       	call   f010ed3a <holding_spinlock>
f0106b7f:	83 c4 10             	add    $0x10,%esp
f0106b82:	85 c0                	test   %eax,%eax
f0106b84:	75 17                	jne    f0106b9d <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b86:	83 ec 04             	sub    $0x4,%esp
f0106b89:	68 40 72 12 f0       	push   $0xf0127240
f0106b8e:	68 2e 01 00 00       	push   $0x12e
f0106b93:	68 da 70 12 f0       	push   $0xf01270da
f0106b98:	e8 7d 97 ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b9d:	83 ec 04             	sub    $0x4,%esp
f0106ba0:	68 90 71 12 f0       	push   $0xf0127190
f0106ba5:	68 34 01 00 00       	push   $0x134
f0106baa:	68 da 70 12 f0       	push   $0xf01270da
f0106baf:	e8 66 97 ff ff       	call   f010031a <_panic>

f0106bb4 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bb4:	55                   	push   %ebp
f0106bb5:	89 e5                	mov    %esp,%ebp
f0106bb7:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bba:	e8 74 fb ff ff       	call   f0106733 <isSchedMethodBSD>
f0106bbf:	85 c0                	test   %eax,%eax
f0106bc1:	74 17                	je     f0106bda <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bc3:	83 ec 04             	sub    $0x4,%esp
f0106bc6:	68 90 71 12 f0       	push   $0xf0127190
f0106bcb:	68 43 01 00 00       	push   $0x143
f0106bd0:	68 da 70 12 f0       	push   $0xf01270da
f0106bd5:	e8 40 97 ff ff       	call   f010031a <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106bda:	a1 68 3a 5a f0       	mov    0xf05a3a68,%eax
f0106bdf:	8b 15 6c 3a 5a f0    	mov    0xf05a3a6c,%edx
f0106be5:	83 c0 01             	add    $0x1,%eax
f0106be8:	83 d2 00             	adc    $0x0,%edx
f0106beb:	a3 68 3a 5a f0       	mov    %eax,0xf05a3a68
f0106bf0:	89 15 6c 3a 5a f0    	mov    %edx,0xf05a3a6c
	struct Env* p = get_cpu_proc();
f0106bf6:	e8 75 3b 00 00       	call   f010a770 <get_cpu_proc>
f0106bfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106bfe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c02:	74 30                	je     f0106c34 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c07:	8b 80 68 da 01 00    	mov    0x1da68(%eax),%eax
f0106c0d:	8d 50 01             	lea    0x1(%eax),%edx
f0106c10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c13:	89 90 68 da 01 00    	mov    %edx,0x1da68(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c19:	83 ec 0c             	sub    $0xc,%esp
f0106c1c:	6a 01                	push   $0x1
f0106c1e:	e8 ed 7a 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f0106c23:	83 c4 10             	add    $0x10,%esp
f0106c26:	85 c0                	test   %eax,%eax
f0106c28:	74 05                	je     f0106c2f <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c2a:	e8 08 00 00 00       	call   f0106c37 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c2f:	e8 6a 3c 00 00       	call   f010a89e <yield>
	}
	/*****************************************/
}
f0106c34:	90                   	nop
f0106c35:	c9                   	leave  
f0106c36:	c3                   	ret    

f0106c37 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c37:	55                   	push   %ebp
f0106c38:	89 e5                	mov    %esp,%ebp
f0106c3a:	53                   	push   %ebx
f0106c3b:	83 ec 34             	sub    $0x34,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c3e:	e8 2d 3b 00 00       	call   f010a770 <get_cpu_proc>
f0106c43:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c46:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c4a:	0f 84 9d 01 00 00    	je     f0106ded <update_WS_time_stamps+0x1b6>
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0106c50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106c57:	e9 99 00 00 00       	jmp    f0106cf5 <update_WS_time_stamps+0xbe>
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
f0106c5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106c5f:	89 d0                	mov    %edx,%eax
f0106c61:	01 c0                	add    %eax,%eax
f0106c63:	01 d0                	add    %edx,%eax
f0106c65:	c1 e0 03             	shl    $0x3,%eax
f0106c68:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f0106c6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c71:	01 d0                	add    %edx,%eax
f0106c73:	83 c0 08             	add    $0x8,%eax
f0106c76:	89 45 e8             	mov    %eax,-0x18(%ebp)
					if( wse->empty == 1)
f0106c79:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c7c:	8a 40 04             	mov    0x4(%eax),%al
f0106c7f:	3c 01                	cmp    $0x1,%al
f0106c81:	74 6e                	je     f0106cf1 <update_WS_time_stamps+0xba>
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c83:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c86:	8b 00                	mov    (%eax),%eax
f0106c88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c8e:	8b 40 64             	mov    0x64(%eax),%eax
f0106c91:	83 ec 08             	sub    $0x8,%esp
f0106c94:	ff 75 e4             	pushl  -0x1c(%ebp)
f0106c97:	50                   	push   %eax
f0106c98:	e8 4f 1f 00 00       	call   f0108bec <pt_get_page_permissions>
f0106c9d:	83 c4 10             	add    $0x10,%esp
f0106ca0:	89 45 e0             	mov    %eax,-0x20(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106ca3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106ca6:	8b 40 08             	mov    0x8(%eax),%eax
f0106ca9:	89 45 dc             	mov    %eax,-0x24(%ebp)

					if (perm & PERM_USED)
f0106cac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106caf:	83 e0 20             	and    $0x20,%eax
f0106cb2:	85 c0                	test   %eax,%eax
f0106cb4:	74 2b                	je     f0106ce1 <update_WS_time_stamps+0xaa>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106cb6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0106cb9:	c1 e8 02             	shr    $0x2,%eax
f0106cbc:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106cc1:	89 c2                	mov    %eax,%edx
f0106cc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106cc6:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106cc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ccc:	8b 40 64             	mov    0x64(%eax),%eax
f0106ccf:	6a 20                	push   $0x20
f0106cd1:	6a 00                	push   $0x0
f0106cd3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0106cd6:	50                   	push   %eax
f0106cd7:	e8 4c 1e 00 00       	call   f0108b28 <pt_set_page_permissions>
f0106cdc:	83 c4 10             	add    $0x10,%esp
f0106cdf:	eb 11                	jmp    f0106cf2 <update_WS_time_stamps+0xbb>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106ce1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0106ce4:	c1 e8 02             	shr    $0x2,%eax
f0106ce7:	89 c2                	mov    %eax,%edx
f0106ce9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106cec:	89 50 08             	mov    %edx,0x8(%eax)
f0106cef:	eb 01                	jmp    f0106cf2 <update_WS_time_stamps+0xbb>
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
f0106cf1:	90                   	nop
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0106cf2:	ff 45 f4             	incl   -0xc(%ebp)
f0106cf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cf8:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0106cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d01:	39 c2                	cmp    %eax,%edx
f0106d03:	0f 87 53 ff ff ff    	ja     f0106c5c <update_WS_time_stamps+0x25>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d09:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d10:	e9 ce 00 00 00       	jmp    f0106de3 <update_WS_time_stamps+0x1ac>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d15:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d18:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d1b:	89 d0                	mov    %edx,%eax
f0106d1d:	01 c0                	add    %eax,%eax
f0106d1f:	01 d0                	add    %edx,%eax
f0106d21:	c1 e0 03             	shl    $0x3,%eax
f0106d24:	01 c8                	add    %ecx,%eax
f0106d26:	05 60 d5 01 00       	add    $0x1d560,%eax
f0106d2b:	8a 00                	mov    (%eax),%al
f0106d2d:	3c 01                	cmp    $0x1,%al
f0106d2f:	0f 84 ab 00 00 00    	je     f0106de0 <update_WS_time_stamps+0x1a9>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d35:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d38:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d3b:	89 d0                	mov    %edx,%eax
f0106d3d:	01 c0                	add    %eax,%eax
f0106d3f:	01 d0                	add    %edx,%eax
f0106d41:	c1 e0 03             	shl    $0x3,%eax
f0106d44:	01 c8                	add    %ecx,%eax
f0106d46:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0106d4b:	8b 00                	mov    (%eax),%eax
f0106d4d:	89 45 d8             	mov    %eax,-0x28(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d50:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d53:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d56:	89 d0                	mov    %edx,%eax
f0106d58:	01 c0                	add    %eax,%eax
f0106d5a:	01 d0                	add    %edx,%eax
f0106d5c:	c1 e0 03             	shl    $0x3,%eax
f0106d5f:	01 c8                	add    %ecx,%eax
f0106d61:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106d66:	8b 00                	mov    (%eax),%eax
f0106d68:	89 45 d4             	mov    %eax,-0x2c(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d6e:	8b 40 64             	mov    0x64(%eax),%eax
f0106d71:	83 ec 08             	sub    $0x8,%esp
f0106d74:	ff 75 d8             	pushl  -0x28(%ebp)
f0106d77:	50                   	push   %eax
f0106d78:	e8 4b 1f 00 00       	call   f0108cc8 <pd_is_table_used>
f0106d7d:	83 c4 10             	add    $0x10,%esp
f0106d80:	85 c0                	test   %eax,%eax
f0106d82:	74 3c                	je     f0106dc0 <update_WS_time_stamps+0x189>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106d87:	c1 e8 02             	shr    $0x2,%eax
f0106d8a:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d8f:	89 c1                	mov    %eax,%ecx
f0106d91:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106d94:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d97:	89 d0                	mov    %edx,%eax
f0106d99:	01 c0                	add    %eax,%eax
f0106d9b:	01 d0                	add    %edx,%eax
f0106d9d:	c1 e0 03             	shl    $0x3,%eax
f0106da0:	01 d8                	add    %ebx,%eax
f0106da2:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106da7:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106da9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dac:	8b 40 64             	mov    0x64(%eax),%eax
f0106daf:	83 ec 08             	sub    $0x8,%esp
f0106db2:	ff 75 d8             	pushl  -0x28(%ebp)
f0106db5:	50                   	push   %eax
f0106db6:	e8 31 1f 00 00       	call   f0108cec <pd_set_table_unused>
f0106dbb:	83 c4 10             	add    $0x10,%esp
f0106dbe:	eb 20                	jmp    f0106de0 <update_WS_time_stamps+0x1a9>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dc0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106dc3:	c1 e8 02             	shr    $0x2,%eax
f0106dc6:	89 c1                	mov    %eax,%ecx
f0106dc8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dcb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106dce:	89 d0                	mov    %edx,%eax
f0106dd0:	01 c0                	add    %eax,%eax
f0106dd2:	01 d0                	add    %edx,%eax
f0106dd4:	c1 e0 03             	shl    $0x3,%eax
f0106dd7:	01 d8                	add    %ebx,%eax
f0106dd9:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106dde:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106de0:	ff 45 f0             	incl   -0x10(%ebp)
f0106de3:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106de7:	0f 8e 28 ff ff ff    	jle    f0106d15 <update_WS_time_stamps+0xde>
						}
					}
				}
			}
		}
	}
f0106ded:	90                   	nop
f0106dee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106df1:	c9                   	leave  
f0106df2:	c3                   	ret    

f0106df3 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106df3:	55                   	push   %ebp
f0106df4:	89 e5                	mov    %esp,%ebp
f0106df6:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106df9:	c7 05 ac 03 5a f0 01 	movl   $0x1,0xf05a03ac
f0106e00:	00 00 00 
f0106e03:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e0a:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e0e:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e11:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e14:	ee                   	out    %al,(%dx)
f0106e15:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e1c:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e20:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e23:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e26:	ee                   	out    %al,(%dx)
f0106e27:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e2e:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e32:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e38:	ee                   	out    %al,(%dx)
f0106e39:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e40:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e44:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e47:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e4a:	ee                   	out    %al,(%dx)
f0106e4b:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e52:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e56:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e59:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e5c:	ee                   	out    %al,(%dx)
f0106e5d:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e64:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e68:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e6b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e6e:	ee                   	out    %al,(%dx)
f0106e6f:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e76:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e7a:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e7d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e80:	ee                   	out    %al,(%dx)
f0106e81:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e88:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e8c:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e8f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106e92:	ee                   	out    %al,(%dx)
f0106e93:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106e9a:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106e9e:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106ea1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106ea4:	ee                   	out    %al,(%dx)
f0106ea5:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106eac:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106eb0:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106eb3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106eb6:	ee                   	out    %al,(%dx)
f0106eb7:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ebe:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ec2:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ec5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ec8:	ee                   	out    %al,(%dx)
f0106ec9:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106ed0:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ed4:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ed7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106eda:	ee                   	out    %al,(%dx)
f0106edb:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ee2:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ee6:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ee9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106eec:	ee                   	out    %al,(%dx)
f0106eed:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106ef4:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106ef8:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106efb:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106efe:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106eff:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f05:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f09:	74 15                	je     f0106f20 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f0b:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f11:	0f b7 c0             	movzwl %ax,%eax
f0106f14:	83 ec 0c             	sub    $0xc,%esp
f0106f17:	50                   	push   %eax
f0106f18:	e8 06 00 00 00       	call   f0106f23 <irq_setmask_8259A>
f0106f1d:	83 c4 10             	add    $0x10,%esp
}
f0106f20:	90                   	nop
f0106f21:	c9                   	leave  
f0106f22:	c3                   	ret    

f0106f23 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f23:	55                   	push   %ebp
f0106f24:	89 e5                	mov    %esp,%ebp
f0106f26:	83 ec 14             	sub    $0x14,%esp
f0106f29:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f2c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f30:	a1 ac 03 5a f0       	mov    0xf05a03ac,%eax
f0106f35:	85 c0                	test   %eax,%eax
f0106f37:	74 34                	je     f0106f6d <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f39:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f3c:	0f b6 c0             	movzbl %al,%eax
f0106f3f:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f46:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f49:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f4f:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f50:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f53:	66 c1 e8 08          	shr    $0x8,%ax
f0106f57:	0f b6 c0             	movzbl %al,%eax
f0106f5a:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f61:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f64:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f67:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f6a:	ee                   	out    %al,(%dx)
f0106f6b:	eb 01                	jmp    f0106f6e <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f6d:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f6e:	c9                   	leave  
f0106f6f:	c3                   	ret    

f0106f70 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f70:	55                   	push   %ebp
f0106f71:	89 e5                	mov    %esp,%ebp
f0106f73:	53                   	push   %ebx
f0106f74:	83 ec 14             	sub    $0x14,%esp
f0106f77:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f7a:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f7d:	a1 ac 03 5a f0       	mov    0xf05a03ac,%eax
f0106f82:	85 c0                	test   %eax,%eax
f0106f84:	74 58                	je     f0106fde <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f86:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f8a:	77 08                	ja     f0106f94 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f8c:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106f92:	eb 0a                	jmp    f0106f9e <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106f94:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106f9a:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106f9e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fa2:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fa8:	89 c2                	mov    %eax,%edx
f0106faa:	ec                   	in     (%dx),%al
f0106fab:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fae:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fb1:	88 c2                	mov    %al,%dl
f0106fb3:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fb7:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fbc:	88 c1                	mov    %al,%cl
f0106fbe:	d3 e3                	shl    %cl,%ebx
f0106fc0:	89 d8                	mov    %ebx,%eax
f0106fc2:	09 d0                	or     %edx,%eax
f0106fc4:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fc7:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fcb:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fcf:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fd2:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fd5:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fdb:	ee                   	out    %al,(%dx)
f0106fdc:	eb 01                	jmp    f0106fdf <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fde:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fdf:	83 c4 14             	add    $0x14,%esp
f0106fe2:	5b                   	pop    %ebx
f0106fe3:	5d                   	pop    %ebp
f0106fe4:	c3                   	ret    

f0106fe5 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106fe5:	55                   	push   %ebp
f0106fe6:	89 e5                	mov    %esp,%ebp
f0106fe8:	53                   	push   %ebx
f0106fe9:	83 ec 14             	sub    $0x14,%esp
f0106fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0106fef:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106ff2:	a1 ac 03 5a f0       	mov    0xf05a03ac,%eax
f0106ff7:	85 c0                	test   %eax,%eax
f0106ff9:	74 5a                	je     f0107055 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106ffb:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106fff:	77 08                	ja     f0107009 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107001:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107007:	eb 0a                	jmp    f0107013 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107009:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010700f:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107013:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107017:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010701a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010701d:	89 c2                	mov    %eax,%edx
f010701f:	ec                   	in     (%dx),%al
f0107020:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107023:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107026:	88 c2                	mov    %al,%dl
f0107028:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010702c:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107031:	88 c1                	mov    %al,%cl
f0107033:	d3 e3                	shl    %cl,%ebx
f0107035:	89 d8                	mov    %ebx,%eax
f0107037:	f7 d0                	not    %eax
f0107039:	21 d0                	and    %edx,%eax
f010703b:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010703e:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107042:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107046:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107049:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010704c:	8a 45 ef             	mov    -0x11(%ebp),%al
f010704f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107052:	ee                   	out    %al,(%dx)
f0107053:	eb 01                	jmp    f0107056 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107055:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107056:	83 c4 14             	add    $0x14,%esp
f0107059:	5b                   	pop    %ebx
f010705a:	5d                   	pop    %ebp
f010705b:	c3                   	ret    

f010705c <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010705c:	55                   	push   %ebp
f010705d:	89 e5                	mov    %esp,%ebp
f010705f:	53                   	push   %ebx
f0107060:	83 ec 14             	sub    $0x14,%esp
f0107063:	8b 45 08             	mov    0x8(%ebp),%eax
f0107066:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107069:	a1 ac 03 5a f0       	mov    0xf05a03ac,%eax
f010706e:	85 c0                	test   %eax,%eax
f0107070:	75 07                	jne    f0107079 <irq_get_mask+0x1d>
		return -1;
f0107072:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107077:	eb 45                	jmp    f01070be <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107079:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010707d:	77 08                	ja     f0107087 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010707f:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107085:	eb 0a                	jmp    f0107091 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107087:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010708d:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0107091:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107095:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107098:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010709b:	89 c2                	mov    %eax,%edx
f010709d:	ec                   	in     (%dx),%al
f010709e:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070a1:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070a4:	88 c2                	mov    %al,%dl
f01070a6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070aa:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070af:	88 c1                	mov    %al,%cl
f01070b1:	d3 e3                	shl    %cl,%ebx
f01070b3:	89 d8                	mov    %ebx,%eax
f01070b5:	21 d0                	and    %edx,%eax
f01070b7:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070ba:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070be:	83 c4 14             	add    $0x14,%esp
f01070c1:	5b                   	pop    %ebx
f01070c2:	5d                   	pop    %ebp
f01070c3:	c3                   	ret    

f01070c4 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070c4:	55                   	push   %ebp
f01070c5:	89 e5                	mov    %esp,%ebp
f01070c7:	83 ec 14             	sub    $0x14,%esp
f01070ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01070cd:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070d0:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070d4:	76 12                	jbe    f01070e8 <pic_sendEOI+0x24>
f01070d6:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070dd:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070e1:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070e7:	ee                   	out    %al,(%dx)
f01070e8:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070ef:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f01070f3:	8a 45 f6             	mov    -0xa(%ebp),%al
f01070f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01070f9:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f01070fa:	90                   	nop
f01070fb:	c9                   	leave  
f01070fc:	c3                   	ret    

f01070fd <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f01070fd:	55                   	push   %ebp
f01070fe:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0107100:	b8 a0 35 5a f0       	mov    $0xf05a35a0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107105:	5d                   	pop    %ebp
f0107106:	c3                   	ret    

f0107107 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107107:	55                   	push   %ebp
f0107108:	89 e5                	mov    %esp,%ebp
f010710a:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010710d:	e8 eb ff ff ff       	call   f01070fd <mycpu>
f0107112:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107115:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107118:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010711f:	00 00 00 
  c->ncli = 0;
f0107122:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107125:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010712c:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010712f:	9c                   	pushf  
f0107130:	58                   	pop    %eax
f0107131:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107134:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107137:	25 00 02 00 00       	and    $0x200,%eax
f010713c:	85 c0                	test   %eax,%eax
f010713e:	0f 95 c0             	setne  %al
f0107141:	0f b6 d0             	movzbl %al,%edx
f0107144:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107147:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010714d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107150:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107157:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715a:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107161:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107164:	8b 45 08             	mov    0x8(%ebp),%eax
f0107167:	40                   	inc    %eax
f0107168:	c1 e0 0f             	shl    $0xf,%eax
f010716b:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107170:	29 c2                	sub    %eax,%edx
f0107172:	89 d0                	mov    %edx,%eax
f0107174:	89 c2                	mov    %eax,%edx
f0107176:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107179:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010717c:	e8 18 01 00 00       	call   f0107299 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107181:	e8 49 50 00 00       	call   f010c1cf <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107186:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107189:	83 c0 0c             	add    $0xc,%eax
f010718c:	83 ec 04             	sub    $0x4,%esp
f010718f:	6a 68                	push   $0x68
f0107191:	6a 00                	push   $0x0
f0107193:	50                   	push   %eax
f0107194:	e8 2a b6 01 00       	call   f01227c3 <memset>
f0107199:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f010719c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010719f:	05 a4 00 00 00       	add    $0xa4,%eax
f01071a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071a7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071ae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071b4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071b7:	f0 87 02             	lock xchg %eax,(%edx)
f01071ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071bd:	90                   	nop
f01071be:	c9                   	leave  
f01071bf:	c3                   	ret    

f01071c0 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071c0:	55                   	push   %ebp
f01071c1:	89 e5                	mov    %esp,%ebp
f01071c3:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071c6:	9c                   	pushf  
f01071c7:	58                   	pop    %eax
f01071c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071d1:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071d2:	e8 26 ff ff ff       	call   f01070fd <mycpu>
f01071d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071dd:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071e3:	85 c0                	test   %eax,%eax
f01071e5:	75 13                	jne    f01071fa <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071ea:	25 00 02 00 00       	and    $0x200,%eax
f01071ef:	89 c2                	mov    %eax,%edx
f01071f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071f4:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f01071fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071fd:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107203:	8d 50 01             	lea    0x1(%eax),%edx
f0107206:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107209:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010720f:	90                   	nop
f0107210:	c9                   	leave  
f0107211:	c3                   	ret    

f0107212 <popcli>:

void popcli(void)
{
f0107212:	55                   	push   %ebp
f0107213:	89 e5                	mov    %esp,%ebp
f0107215:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107218:	9c                   	pushf  
f0107219:	58                   	pop    %eax
f010721a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010721d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0107220:	25 00 02 00 00       	and    $0x200,%eax
f0107225:	85 c0                	test   %eax,%eax
f0107227:	74 14                	je     f010723d <popcli+0x2b>
    panic("popcli - interruptible");
f0107229:	83 ec 04             	sub    $0x4,%esp
f010722c:	68 8d 72 12 f0       	push   $0xf012728d
f0107231:	6a 5e                	push   $0x5e
f0107233:	68 a4 72 12 f0       	push   $0xf01272a4
f0107238:	e8 dd 90 ff ff       	call   f010031a <_panic>
  struct cpu* c = mycpu();
f010723d:	e8 bb fe ff ff       	call   f01070fd <mycpu>
f0107242:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107245:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107248:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010724e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107251:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107254:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f010725a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010725d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107263:	85 c0                	test   %eax,%eax
f0107265:	79 14                	jns    f010727b <popcli+0x69>
    panic("popcli");
f0107267:	83 ec 04             	sub    $0x4,%esp
f010726a:	68 b3 72 12 f0       	push   $0xf01272b3
f010726f:	6a 61                	push   $0x61
f0107271:	68 a4 72 12 f0       	push   $0xf01272a4
f0107276:	e8 9f 90 ff ff       	call   f010031a <_panic>
  if(c->ncli == 0 && c->intena)
f010727b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010727e:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107284:	85 c0                	test   %eax,%eax
f0107286:	75 0e                	jne    f0107296 <popcli+0x84>
f0107288:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0107291:	85 c0                	test   %eax,%eax
f0107293:	74 01                	je     f0107296 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0107295:	fb                   	sti    
    sti();
}
f0107296:	90                   	nop
f0107297:	c9                   	leave  
f0107298:	c3                   	ret    

f0107299 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f0107299:	55                   	push   %ebp
f010729a:	89 e5                	mov    %esp,%ebp
f010729c:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f010729f:	e8 1c ff ff ff       	call   f01071c0 <pushcli>

	c = mycpu();
f01072a4:	e8 54 fe ff ff       	call   f01070fd <mycpu>
f01072a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072af:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072b6:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072c0:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072c9:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d2:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072dc:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072e2:	83 e2 f0             	and    $0xfffffff0,%edx
f01072e5:	83 ca 0a             	or     $0xa,%edx
f01072e8:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072f1:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f7:	83 ca 10             	or     $0x10,%edx
f01072fa:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107300:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107303:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107309:	83 e2 9f             	and    $0xffffff9f,%edx
f010730c:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107312:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107315:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010731b:	83 ca 80             	or     $0xffffff80,%edx
f010731e:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107324:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107327:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010732d:	83 ca 0f             	or     $0xf,%edx
f0107330:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107336:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107339:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733f:	83 e2 ef             	and    $0xffffffef,%edx
f0107342:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107348:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010734b:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107351:	83 e2 df             	and    $0xffffffdf,%edx
f0107354:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010735a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735d:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107363:	83 ca 40             	or     $0x40,%edx
f0107366:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010736c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736f:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107375:	83 ca 80             	or     $0xffffff80,%edx
f0107378:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107381:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107388:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010738b:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0107392:	ff ff 
f0107394:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107397:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f010739e:	00 00 
f01073a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a3:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073ad:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073b3:	83 e2 f0             	and    $0xfffffff0,%edx
f01073b6:	83 ca 02             	or     $0x2,%edx
f01073b9:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073c2:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c8:	83 ca 10             	or     $0x10,%edx
f01073cb:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d4:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073da:	83 e2 9f             	and    $0xffffff9f,%edx
f01073dd:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e6:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073ec:	83 ca 80             	or     $0xffffff80,%edx
f01073ef:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f8:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073fe:	83 ca 0f             	or     $0xf,%edx
f0107401:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107407:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010740a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107410:	83 e2 ef             	and    $0xffffffef,%edx
f0107413:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107419:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010741c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107422:	83 e2 df             	and    $0xffffffdf,%edx
f0107425:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010742b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742e:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107434:	83 ca 40             	or     $0x40,%edx
f0107437:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107440:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107446:	83 ca 80             	or     $0xffffff80,%edx
f0107449:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107452:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107459:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010745c:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107463:	ff ff 
f0107465:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107468:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010746f:	00 00 
f0107471:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107474:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010747b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010747e:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107484:	83 e2 f0             	and    $0xfffffff0,%edx
f0107487:	83 ca 0a             	or     $0xa,%edx
f010748a:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107490:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107493:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107499:	83 ca 10             	or     $0x10,%edx
f010749c:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a5:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ab:	83 ca 60             	or     $0x60,%edx
f01074ae:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b7:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074bd:	83 ca 80             	or     $0xffffff80,%edx
f01074c0:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c9:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074cf:	83 ca 0f             	or     $0xf,%edx
f01074d2:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074db:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074e1:	83 e2 ef             	and    $0xffffffef,%edx
f01074e4:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ed:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f3:	83 e2 df             	and    $0xffffffdf,%edx
f01074f6:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ff:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107505:	83 ca 40             	or     $0x40,%edx
f0107508:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107511:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107517:	83 ca 80             	or     $0xffffff80,%edx
f010751a:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107520:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107523:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f010752a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752d:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107534:	ff ff 
f0107536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107539:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f0107540:	00 00 
f0107542:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107545:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010754c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010754f:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107555:	83 e2 f0             	and    $0xfffffff0,%edx
f0107558:	83 ca 02             	or     $0x2,%edx
f010755b:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107561:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107564:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010756a:	83 ca 10             	or     $0x10,%edx
f010756d:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107573:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107576:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010757c:	83 ca 60             	or     $0x60,%edx
f010757f:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107585:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107588:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758e:	83 ca 80             	or     $0xffffff80,%edx
f0107591:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107597:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010759a:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075a0:	83 ca 0f             	or     $0xf,%edx
f01075a3:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075ac:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075b2:	83 e2 ef             	and    $0xffffffef,%edx
f01075b5:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075be:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c4:	83 e2 df             	and    $0xffffffdf,%edx
f01075c7:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075d0:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d6:	83 ca 40             	or     $0x40,%edx
f01075d9:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075e2:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e8:	83 ca 80             	or     $0xffffff80,%edx
f01075eb:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f4:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f01075fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075fe:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107605:	00 00 00 
f0107608:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010760f:	00 00 00 

	popcli();	//enable interrupt
f0107612:	e8 fb fb ff ff       	call   f0107212 <popcli>


}
f0107617:	90                   	nop
f0107618:	c9                   	leave  
f0107619:	c3                   	ret    

f010761a <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f010761a:	55                   	push   %ebp
f010761b:	89 e5                	mov    %esp,%ebp
f010761d:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0107620:	83 ec 08             	sub    $0x8,%esp
f0107623:	68 00 10 00 00       	push   $0x1000
f0107628:	68 00 10 00 00       	push   $0x1000
f010762d:	e8 35 02 00 00       	call   f0107867 <boot_allocate_space>
f0107632:	83 c4 10             	add    $0x10,%esp
f0107635:	a3 7c 3a 5a f0       	mov    %eax,0xf05a3a7c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f010763a:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f010763f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107642:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107649:	77 14                	ja     f010765f <initialize_kernel_VM+0x45>
f010764b:	ff 75 e0             	pushl  -0x20(%ebp)
f010764e:	68 bc 72 12 f0       	push   $0xf01272bc
f0107653:	6a 57                	push   $0x57
f0107655:	68 f0 72 12 f0       	push   $0xf01272f0
f010765a:	e8 bb 8c ff ff       	call   f010031a <_panic>
f010765f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107662:	05 00 00 00 10       	add    $0x10000000,%eax
f0107667:	a3 84 3b 5a f0       	mov    %eax,0xf05a3b84
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010766c:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f0107673:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010767a:	77 14                	ja     f0107690 <initialize_kernel_VM+0x76>
f010767c:	ff 75 dc             	pushl  -0x24(%ebp)
f010767f:	68 bc 72 12 f0       	push   $0xf01272bc
f0107684:	6a 63                	push   $0x63
f0107686:	68 f0 72 12 f0       	push   $0xf01272f0
f010768b:	e8 8a 8c ff ff       	call   f010031a <_panic>
f0107690:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107693:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107699:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f010769e:	83 ec 0c             	sub    $0xc,%esp
f01076a1:	6a 02                	push   $0x2
f01076a3:	52                   	push   %edx
f01076a4:	68 00 80 00 00       	push   $0x8000
f01076a9:	68 00 80 bf ef       	push   $0xefbf8000
f01076ae:	50                   	push   %eax
f01076af:	e8 27 02 00 00       	call   f01078db <boot_map_range>
f01076b4:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076be:	eb 24                	jmp    f01076e4 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076c3:	40                   	inc    %eax
f01076c4:	c1 e0 0f             	shl    $0xf,%eax
f01076c7:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076cc:	29 c2                	sub    %eax,%edx
f01076ce:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f01076d3:	6a 01                	push   $0x1
f01076d5:	6a 00                	push   $0x0
f01076d7:	52                   	push   %edx
f01076d8:	50                   	push   %eax
f01076d9:	e8 4a 14 00 00       	call   f0108b28 <pt_set_page_permissions>
f01076de:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076e1:	ff 45 f4             	incl   -0xc(%ebp)
f01076e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076e8:	7e d6                	jle    f01076c0 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076ea:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f01076f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f01076f8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076ff:	eb 25                	jmp    f0107726 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107701:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107704:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107707:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f010770c:	83 ec 04             	sub    $0x4,%esp
f010770f:	6a 01                	push   $0x1
f0107711:	52                   	push   %edx
f0107712:	50                   	push   %eax
f0107713:	e8 37 02 00 00       	call   f010794f <boot_get_page_table>
f0107718:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010771b:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107722:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107726:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010772a:	72 d5                	jb     f0107701 <initialize_kernel_VM+0xe7>
f010772c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107730:	77 06                	ja     f0107738 <initialize_kernel_VM+0x11e>
f0107732:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107736:	76 c9                	jbe    f0107701 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107738:	8b 15 58 36 5a f0    	mov    0xf05a3658,%edx
f010773e:	89 d0                	mov    %edx,%eax
f0107740:	01 c0                	add    %eax,%eax
f0107742:	01 d0                	add    %edx,%eax
f0107744:	c1 e0 03             	shl    $0x3,%eax
f0107747:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f010774a:	83 ec 08             	sub    $0x8,%esp
f010774d:	68 00 10 00 00       	push   $0x1000
f0107752:	ff 75 d8             	pushl  -0x28(%ebp)
f0107755:	e8 0d 01 00 00       	call   f0107867 <boot_allocate_space>
f010775a:	83 c4 10             	add    $0x10,%esp
f010775d:	a3 c0 38 5a f0       	mov    %eax,0xf05a38c0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107762:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107769:	83 ec 08             	sub    $0x8,%esp
f010776c:	68 00 10 00 00       	push   $0x1000
f0107771:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107774:	e8 ee 00 00 00       	call   f0107867 <boot_allocate_space>
f0107779:	83 c4 10             	add    $0x10,%esp
f010777c:	a3 60 0c 5a f0       	mov    %eax,0xf05a0c60
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107781:	e8 32 05 00 00       	call   f0107cb8 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107786:	83 ec 0c             	sub    $0xc,%esp
f0107789:	6a 08                	push   $0x8
f010778b:	e8 9d 94 01 00       	call   f0120c2d <nearest_pow2_ceil>
f0107790:	83 c4 10             	add    $0x10,%esp
f0107793:	83 ec 04             	sub    $0x4,%esp
f0107796:	50                   	push   %eax
f0107797:	6a 08                	push   $0x8
f0107799:	68 10 73 12 f0       	push   $0xf0127310
f010779e:	e8 c9 97 ff ff       	call   f0100f6c <cprintf>
f01077a3:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077a6:	c7 45 d0 60 d3 0e 00 	movl   $0xed360,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077b0:	83 ec 08             	sub    $0x8,%esp
f01077b3:	68 00 10 00 00       	push   $0x1000
f01077b8:	50                   	push   %eax
f01077b9:	e8 a9 00 00 00       	call   f0107867 <boot_allocate_space>
f01077be:	83 c4 10             	add    $0x10,%esp
f01077c1:	a3 b0 03 5a f0       	mov    %eax,0xf05a03b0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077c6:	a1 b0 03 5a f0       	mov    0xf05a03b0,%eax
f01077cb:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077ce:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077d5:	77 17                	ja     f01077ee <initialize_kernel_VM+0x1d4>
f01077d7:	ff 75 cc             	pushl  -0x34(%ebp)
f01077da:	68 bc 72 12 f0       	push   $0xf01272bc
f01077df:	68 b1 00 00 00       	push   $0xb1
f01077e4:	68 f0 72 12 f0       	push   $0xf01272f0
f01077e9:	e8 2c 8b ff ff       	call   f010031a <_panic>
f01077ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01077f1:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01077f7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01077fa:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f01077ff:	83 ec 0c             	sub    $0xc,%esp
f0107802:	6a 04                	push   $0x4
f0107804:	51                   	push   %ecx
f0107805:	52                   	push   %edx
f0107806:	68 00 00 c0 ee       	push   $0xeec00000
f010780b:	50                   	push   %eax
f010780c:	e8 ca 00 00 00       	call   f01078db <boot_map_range>
f0107811:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107814:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107819:	05 ec 0e 00 00       	add    $0xeec,%eax
f010781e:	8b 15 7c 3a 5a f0    	mov    0xf05a3a7c,%edx
f0107824:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010782a:	8b 12                	mov    (%edx),%edx
f010782c:	83 ca 05             	or     $0x5,%edx
f010782f:	89 10                	mov    %edx,(%eax)
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#else
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107831:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107836:	83 ec 0c             	sub    $0xc,%esp
f0107839:	6a 02                	push   $0x2
f010783b:	6a 00                	push   $0x0
f010783d:	68 ff ff ff 0f       	push   $0xfffffff
f0107842:	68 00 00 00 f0       	push   $0xf0000000
f0107847:	50                   	push   %eax
f0107848:	e8 8e 00 00 00       	call   f01078db <boot_map_range>
f010784d:	83 c4 20             	add    $0x20,%esp
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107850:	e8 ba a2 01 00       	call   f0121b0f <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107855:	c7 05 80 35 5a f0 19 	movl   $0x19,0xf05a3580
f010785c:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010785f:	e8 20 03 00 00       	call   f0107b84 <turn_on_paging>
}
f0107864:	90                   	nop
f0107865:	c9                   	leave  
f0107866:	c3                   	ret    

f0107867 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107867:	55                   	push   %ebp
f0107868:	89 e5                	mov    %esp,%ebp
f010786a:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f010786d:	a1 78 3a 5a f0       	mov    0xf05a3a78,%eax
f0107872:	85 c0                	test   %eax,%eax
f0107874:	75 0a                	jne    f0107880 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107876:	c7 05 78 3a 5a f0 30 	movl   $0xf05c6430,0xf05a3a78
f010787d:	64 5c f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107880:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107883:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107886:	a1 78 3a 5a f0       	mov    0xf05a3a78,%eax
f010788b:	89 c2                	mov    %eax,%edx
f010788d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107890:	01 d0                	add    %edx,%eax
f0107892:	48                   	dec    %eax
f0107893:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107896:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107899:	ba 00 00 00 00       	mov    $0x0,%edx
f010789e:	f7 75 f4             	divl   -0xc(%ebp)
f01078a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078a4:	29 d0                	sub    %edx,%eax
f01078a6:	a3 78 3a 5a f0       	mov    %eax,0xf05a3a78

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078ab:	a1 78 3a 5a f0       	mov    0xf05a3a78,%eax
f01078b0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078b3:	8b 15 78 3a 5a f0    	mov    0xf05a3a78,%edx
f01078b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01078bc:	01 d0                	add    %edx,%eax
f01078be:	a3 78 3a 5a f0       	mov    %eax,0xf05a3a78

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078c3:	83 ec 04             	sub    $0x4,%esp
f01078c6:	ff 75 08             	pushl  0x8(%ebp)
f01078c9:	6a 00                	push   $0x0
f01078cb:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ce:	e8 f0 ae 01 00       	call   f01227c3 <memset>
f01078d3:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078d6:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078d9:	c9                   	leave  
f01078da:	c3                   	ret    

f01078db <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078db:	55                   	push   %ebp
f01078dc:	89 e5                	mov    %esp,%ebp
f01078de:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01078e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01078ef:	eb 53                	jmp    f0107944 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f01078f1:	83 ec 04             	sub    $0x4,%esp
f01078f4:	6a 01                	push   $0x1
f01078f6:	ff 75 0c             	pushl  0xc(%ebp)
f01078f9:	ff 75 08             	pushl  0x8(%ebp)
f01078fc:	e8 4e 00 00 00       	call   f010794f <boot_get_page_table>
f0107901:	83 c4 10             	add    $0x10,%esp
f0107904:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010790a:	c1 e8 0c             	shr    $0xc,%eax
f010790d:	25 ff 03 00 00       	and    $0x3ff,%eax
f0107912:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107915:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107918:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010791f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107922:	01 c2                	add    %eax,%edx
f0107924:	8b 45 18             	mov    0x18(%ebp),%eax
f0107927:	0b 45 14             	or     0x14(%ebp),%eax
f010792a:	83 c8 01             	or     $0x1,%eax
f010792d:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010792f:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107936:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f010793d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107944:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107947:	3b 45 10             	cmp    0x10(%ebp),%eax
f010794a:	72 a5                	jb     f01078f1 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f010794c:	90                   	nop
f010794d:	c9                   	leave  
f010794e:	c3                   	ret    

f010794f <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010794f:	55                   	push   %ebp
f0107950:	89 e5                	mov    %esp,%ebp
f0107952:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107955:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107958:	c1 e8 16             	shr    $0x16,%eax
f010795b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010795e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107961:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107968:	8b 45 08             	mov    0x8(%ebp),%eax
f010796b:	01 d0                	add    %edx,%eax
f010796d:	8b 00                	mov    (%eax),%eax
f010796f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107972:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107975:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010797a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f010797d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107980:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107983:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107986:	c1 e8 0c             	shr    $0xc,%eax
f0107989:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010798c:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0107991:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107994:	72 17                	jb     f01079ad <boot_get_page_table+0x5e>
f0107996:	ff 75 e8             	pushl  -0x18(%ebp)
f0107999:	68 38 73 12 f0       	push   $0xf0127338
f010799e:	68 33 01 00 00       	push   $0x133
f01079a3:	68 f0 72 12 f0       	push   $0xf01272f0
f01079a8:	e8 6d 89 ff ff       	call   f010031a <_panic>
f01079ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079b0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079bc:	75 72                	jne    f0107a30 <boot_get_page_table+0xe1>
	{
		if (create)
f01079be:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079c2:	74 65                	je     f0107a29 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079c4:	83 ec 08             	sub    $0x8,%esp
f01079c7:	68 00 10 00 00       	push   $0x1000
f01079cc:	68 00 10 00 00       	push   $0x1000
f01079d1:	e8 91 fe ff ff       	call   f0107867 <boot_allocate_space>
f01079d6:	83 c4 10             	add    $0x10,%esp
f01079d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079df:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079e2:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01079e9:	77 17                	ja     f0107a02 <boot_get_page_table+0xb3>
f01079eb:	ff 75 dc             	pushl  -0x24(%ebp)
f01079ee:	68 bc 72 12 f0       	push   $0xf01272bc
f01079f3:	68 39 01 00 00       	push   $0x139
f01079f8:	68 f0 72 12 f0       	push   $0xf01272f0
f01079fd:	e8 18 89 ff ff       	call   f010031a <_panic>
f0107a02:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a05:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a10:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a17:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a1a:	01 d0                	add    %edx,%eax
f0107a1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a1f:	83 ca 03             	or     $0x3,%edx
f0107a22:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a24:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a27:	eb 0a                	jmp    f0107a33 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a29:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a2e:	eb 03                	jmp    f0107a33 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a30:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a33:	c9                   	leave  
f0107a34:	c3                   	ret    

f0107a35 <nvram_read>:


int nvram_read(int r)
{
f0107a35:	55                   	push   %ebp
f0107a36:	89 e5                	mov    %esp,%ebp
f0107a38:	53                   	push   %ebx
f0107a39:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a3f:	83 ec 0c             	sub    $0xc,%esp
f0107a42:	50                   	push   %eax
f0107a43:	e8 12 d1 ff ff       	call   f0104b5a <mc146818_read>
f0107a48:	83 c4 10             	add    $0x10,%esp
f0107a4b:	89 c3                	mov    %eax,%ebx
f0107a4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a50:	40                   	inc    %eax
f0107a51:	83 ec 0c             	sub    $0xc,%esp
f0107a54:	50                   	push   %eax
f0107a55:	e8 00 d1 ff ff       	call   f0104b5a <mc146818_read>
f0107a5a:	83 c4 10             	add    $0x10,%esp
f0107a5d:	c1 e0 08             	shl    $0x8,%eax
f0107a60:	09 d8                	or     %ebx,%eax
}
f0107a62:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a65:	c9                   	leave  
f0107a66:	c3                   	ret    

f0107a67 <detect_memory>:

void detect_memory()
{
f0107a67:	55                   	push   %ebp
f0107a68:	89 e5                	mov    %esp,%ebp
f0107a6a:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	6a 15                	push   $0x15
f0107a72:	e8 be ff ff ff       	call   f0107a35 <nvram_read>
f0107a77:	83 c4 10             	add    $0x10,%esp
f0107a7a:	c1 e0 0a             	shl    $0xa,%eax
f0107a7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a80:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a83:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a88:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107a8b:	83 ec 0c             	sub    $0xc,%esp
f0107a8e:	6a 17                	push   $0x17
f0107a90:	e8 a0 ff ff ff       	call   f0107a35 <nvram_read>
f0107a95:	83 c4 10             	add    $0x10,%esp
f0107a98:	c1 e0 0a             	shl    $0xa,%eax
f0107a9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107a9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107aa1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107aa9:	83 ec 0c             	sub    $0xc,%esp
f0107aac:	6a 34                	push   $0x34
f0107aae:	e8 82 ff ff ff       	call   f0107a35 <nvram_read>
f0107ab3:	83 c4 10             	add    $0x10,%esp
f0107ab6:	c1 e0 10             	shl    $0x10,%eax
f0107ab9:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107abc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107abf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ac7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107acb:	74 18                	je     f0107ae5 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107acd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107ad0:	05 00 00 00 01       	add    $0x1000000,%eax
f0107ad5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107adb:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107ae0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107ae3:	eb 19                	jmp    f0107afe <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107ae5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107ae9:	74 0d                	je     f0107af8 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107aee:	05 00 00 10 00       	add    $0x100000,%eax
f0107af3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107af6:	eb 06                	jmp    f0107afe <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107af8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107afb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107afe:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	if(USE_KHEAP == 0 && maxpa > kernel_virtual_area)
f0107b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b08:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0107b0b:	76 32                	jbe    f0107b3f <detect_memory+0xd8>
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
f0107b0d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0107b10:	c1 e8 0a             	shr    $0xa,%eax
f0107b13:	89 c2                	mov    %eax,%edx
f0107b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b18:	c1 e8 0a             	shr    $0xa,%eax
f0107b1b:	83 ec 04             	sub    $0x4,%esp
f0107b1e:	52                   	push   %edx
f0107b1f:	50                   	push   %eax
f0107b20:	68 68 73 12 f0       	push   $0xf0127368
f0107b25:	e8 42 94 ff ff       	call   f0100f6c <cprintf>
f0107b2a:	83 c4 10             	add    $0x10,%esp
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
f0107b2d:	83 ec 0c             	sub    $0xc,%esp
f0107b30:	68 b0 73 12 f0       	push   $0xf01273b0
f0107b35:	e8 32 94 ff ff       	call   f0100f6c <cprintf>
f0107b3a:	83 c4 10             	add    $0x10,%esp
		while(1);
f0107b3d:	eb fe                	jmp    f0107b3d <detect_memory+0xd6>
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b42:	c1 e8 0c             	shr    $0xc,%eax
f0107b45:	a3 58 36 5a f0       	mov    %eax,0xf05a3658

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b4d:	c1 e8 0a             	shr    $0xa,%eax
f0107b50:	83 ec 08             	sub    $0x8,%esp
f0107b53:	50                   	push   %eax
f0107b54:	68 48 74 12 f0       	push   $0xf0127448
f0107b59:	e8 0e 94 ff ff       	call   f0100f6c <cprintf>
f0107b5e:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b64:	c1 e8 0a             	shr    $0xa,%eax
f0107b67:	89 c2                	mov    %eax,%edx
f0107b69:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b6c:	c1 e8 0a             	shr    $0xa,%eax
f0107b6f:	83 ec 04             	sub    $0x4,%esp
f0107b72:	52                   	push   %edx
f0107b73:	50                   	push   %eax
f0107b74:	68 6b 74 12 f0       	push   $0xf012746b
f0107b79:	e8 ee 93 ff ff       	call   f0100f6c <cprintf>
f0107b7e:	83 c4 10             	add    $0x10,%esp
}
f0107b81:	90                   	nop
f0107b82:	c9                   	leave  
f0107b83:	c3                   	ret    

f0107b84 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b84:	55                   	push   %ebp
f0107b85:	89 e5                	mov    %esp,%ebp
f0107b87:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b8a:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b98:	eb 24                	jmp    f0107bbe <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b9a:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107b9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ba2:	c1 e2 02             	shl    $0x2,%edx
f0107ba5:	01 c2                	add    %eax,%edx
f0107ba7:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107bac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107baf:	c1 e1 02             	shl    $0x2,%ecx
f0107bb2:	01 c8                	add    %ecx,%eax
f0107bb4:	8b 00                	mov    (%eax),%eax
f0107bb6:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107bb8:	ff 45 f4             	incl   -0xc(%ebp)
f0107bbb:	ff 45 f0             	incl   -0x10(%ebp)
f0107bbe:	a1 78 3a 5a f0       	mov    0xf05a3a78,%eax
f0107bc3:	c1 e8 16             	shr    $0x16,%eax
f0107bc6:	89 c2                	mov    %eax,%edx
f0107bc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bcb:	39 c2                	cmp    %eax,%edx
f0107bcd:	77 cb                	ja     f0107b9a <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bcf:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f0107bd4:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bda:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bdd:	0f 20 c0             	mov    %cr0,%eax
f0107be0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107be3:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107be6:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107be9:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bf0:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bf4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bf7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bfa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bfd:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107c00:	e8 bb f5 ff ff       	call   f01071c0 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107c05:	e8 f3 f4 ff ff       	call   f01070fd <mycpu>
f0107c0a:	83 c0 74             	add    $0x74,%eax
f0107c0d:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107c10:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107c17:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107c1a:	48                   	dec    %eax
f0107c1b:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c1f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c22:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c26:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c29:	c1 e8 10             	shr    $0x10,%eax
f0107c2c:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c30:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c33:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c36:	e8 d7 f5 ff ff       	call   f0107212 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c3b:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c40:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c42:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c47:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c49:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c4e:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c50:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c55:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c57:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c5c:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c5e:	ea 65 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c65
	asm volatile("lldt %%ax" :: "a" (0));
f0107c65:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c6a:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c6d:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c74:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c7b:	eb 19                	jmp    f0107c96 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c7d:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107c82:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c85:	c1 e2 02             	shl    $0x2,%edx
f0107c88:	01 d0                	add    %edx,%eax
f0107c8a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c90:	ff 45 ec             	incl   -0x14(%ebp)
f0107c93:	ff 45 e8             	incl   -0x18(%ebp)
f0107c96:	a1 78 3a 5a f0       	mov    0xf05a3a78,%eax
f0107c9b:	c1 e8 16             	shr    $0x16,%eax
f0107c9e:	89 c2                	mov    %eax,%edx
f0107ca0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ca3:	39 c2                	cmp    %eax,%edx
f0107ca5:	77 d6                	ja     f0107c7d <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107ca7:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f0107cac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107caf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107cb2:	0f 22 d8             	mov    %eax,%cr3

}
f0107cb5:	90                   	nop
f0107cb6:	c9                   	leave  
f0107cb7:	c3                   	ret    

f0107cb8 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107cb8:	55                   	push   %ebp
f0107cb9:	89 e5                	mov    %esp,%ebp
f0107cbb:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107cbe:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107cc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107cc6:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107ccd:	77 17                	ja     f0107ce6 <setup_listing_to_all_page_tables_entries+0x2e>
f0107ccf:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cd2:	68 bc 72 12 f0       	push   $0xf01272bc
f0107cd7:	68 cf 01 00 00       	push   $0x1cf
f0107cdc:	68 f0 72 12 f0       	push   $0xf01272f0
f0107ce1:	e8 34 86 ff ff       	call   f010031a <_panic>
f0107ce6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ce9:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cee:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cf1:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107cf6:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cfb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107cfe:	83 ca 03             	or     $0x3,%edx
f0107d01:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107d03:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107d08:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107d0e:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0107d13:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107d16:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107d1d:	77 17                	ja     f0107d36 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d1f:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d22:	68 bc 72 12 f0       	push   $0xf01272bc
f0107d27:	68 d4 01 00 00       	push   $0x1d4
f0107d2c:	68 f0 72 12 f0       	push   $0xf01272f0
f0107d31:	e8 e4 85 ff ff       	call   f010031a <_panic>
f0107d36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d39:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d3e:	83 c8 05             	or     $0x5,%eax
f0107d41:	89 02                	mov    %eax,(%edx)

}
f0107d43:	90                   	nop
f0107d44:	c9                   	leave  
f0107d45:	c3                   	ret    

f0107d46 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d46:	55                   	push   %ebp
f0107d47:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d49:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d4c:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f0107d52:	29 d0                	sub    %edx,%eax
f0107d54:	c1 f8 03             	sar    $0x3,%eax
f0107d57:	89 c2                	mov    %eax,%edx
f0107d59:	89 d0                	mov    %edx,%eax
f0107d5b:	c1 e0 02             	shl    $0x2,%eax
f0107d5e:	01 d0                	add    %edx,%eax
f0107d60:	c1 e0 02             	shl    $0x2,%eax
f0107d63:	01 d0                	add    %edx,%eax
f0107d65:	c1 e0 02             	shl    $0x2,%eax
f0107d68:	01 d0                	add    %edx,%eax
f0107d6a:	89 c1                	mov    %eax,%ecx
f0107d6c:	c1 e1 08             	shl    $0x8,%ecx
f0107d6f:	01 c8                	add    %ecx,%eax
f0107d71:	89 c1                	mov    %eax,%ecx
f0107d73:	c1 e1 10             	shl    $0x10,%ecx
f0107d76:	01 c8                	add    %ecx,%eax
f0107d78:	01 c0                	add    %eax,%eax
f0107d7a:	01 d0                	add    %edx,%eax
}
f0107d7c:	5d                   	pop    %ebp
f0107d7d:	c3                   	ret    

f0107d7e <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d7e:	55                   	push   %ebp
f0107d7f:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d81:	ff 75 08             	pushl  0x8(%ebp)
f0107d84:	e8 bd ff ff ff       	call   f0107d46 <to_frame_number>
f0107d89:	83 c4 04             	add    $0x4,%esp
f0107d8c:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d8f:	c9                   	leave  
f0107d90:	c3                   	ret    

f0107d91 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d91:	55                   	push   %ebp
f0107d92:	89 e5                	mov    %esp,%ebp
f0107d94:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d97:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d9a:	c1 e8 0c             	shr    $0xc,%eax
f0107d9d:	89 c2                	mov    %eax,%edx
f0107d9f:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0107da4:	39 c2                	cmp    %eax,%edx
f0107da6:	72 14                	jb     f0107dbc <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107da8:	83 ec 04             	sub    $0x4,%esp
f0107dab:	68 88 74 12 f0       	push   $0xf0127488
f0107db0:	6a 55                	push   $0x55
f0107db2:	68 ad 74 12 f0       	push   $0xf01274ad
f0107db7:	e8 5e 85 ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0107dbc:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f0107dc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0107dc5:	c1 e8 0c             	shr    $0xc,%eax
f0107dc8:	89 c1                	mov    %eax,%ecx
f0107dca:	89 c8                	mov    %ecx,%eax
f0107dcc:	01 c0                	add    %eax,%eax
f0107dce:	01 c8                	add    %ecx,%eax
f0107dd0:	c1 e0 03             	shl    $0x3,%eax
f0107dd3:	01 d0                	add    %edx,%eax
}
f0107dd5:	c9                   	leave  
f0107dd6:	c3                   	ret    

f0107dd7 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107dd7:	55                   	push   %ebp
f0107dd8:	89 e5                	mov    %esp,%ebp
f0107dda:	83 ec 10             	sub    $0x10,%esp
f0107ddd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107de0:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107de3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107de6:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107de9:	90                   	nop
f0107dea:	c9                   	leave  
f0107deb:	c3                   	ret    

f0107dec <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dec:	55                   	push   %ebp
f0107ded:	89 e5                	mov    %esp,%ebp
f0107def:	53                   	push   %ebx
f0107df0:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107df3:	c7 05 c0 0e 5a f0 00 	movl   $0x0,0xf05a0ec0
f0107dfa:	00 00 00 
f0107dfd:	c7 05 c4 0e 5a f0 00 	movl   $0x0,0xf05a0ec4
f0107e04:	00 00 00 
f0107e07:	c7 05 cc 0e 5a f0 00 	movl   $0x0,0xf05a0ecc
f0107e0e:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107e11:	c7 05 d0 0e 5a f0 00 	movl   $0x0,0xf05a0ed0
f0107e18:	00 00 00 
f0107e1b:	c7 05 d4 0e 5a f0 00 	movl   $0x0,0xf05a0ed4
f0107e22:	00 00 00 
f0107e25:	c7 05 dc 0e 5a f0 00 	movl   $0x0,0xf05a0edc
f0107e2c:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e2f:	83 ec 08             	sub    $0x8,%esp
f0107e32:	68 c7 74 12 f0       	push   $0xf01274c7
f0107e37:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f0107e3c:	e8 af 6c 00 00       	call   f010eaf0 <init_spinlock>
f0107e41:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e44:	a1 c0 38 5a f0       	mov    0xf05a38c0,%eax
f0107e49:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e4f:	a1 c0 38 5a f0       	mov    0xf05a38c0,%eax
f0107e54:	83 c0 18             	add    $0x18,%eax
f0107e57:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e5d:	a1 c0 38 5a f0       	mov    0xf05a38c0,%eax
f0107e62:	83 c0 30             	add    $0x30,%eax
f0107e65:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e6b:	c7 05 54 39 5a f0 00 	movl   $0xf0001000,0xf05a3954
f0107e72:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e75:	c7 05 04 3b 5a f0 00 	movl   $0xf0002000,0xf05a3b04
f0107e7c:	20 00 f0 
	i =0;
f0107e7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e86:	eb 1f                	jmp    f0107ea7 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e88:	8b 15 54 39 5a f0    	mov    0xf05a3954,%edx
f0107e8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e91:	01 d0                	add    %edx,%eax
f0107e93:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e96:	8b 15 04 3b 5a f0    	mov    0xf05a3b04,%edx
f0107e9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e9f:	01 d0                	add    %edx,%eax
f0107ea1:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107ea4:	ff 45 f4             	incl   -0xc(%ebp)
f0107ea7:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107eae:	7e d8                	jle    f0107e88 <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107eb0:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107eb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107eba:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ebf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ec2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ec5:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eca:	f7 75 f0             	divl   -0x10(%ebp)
f0107ecd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ed0:	29 d0                	sub    %edx,%eax
f0107ed2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107ed5:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107edc:	e9 e8 00 00 00       	jmp    f0107fc9 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ee1:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107ee7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eea:	89 d0                	mov    %edx,%eax
f0107eec:	01 c0                	add    %eax,%eax
f0107eee:	01 d0                	add    %edx,%eax
f0107ef0:	c1 e0 03             	shl    $0x3,%eax
f0107ef3:	01 c8                	add    %ecx,%eax
f0107ef5:	83 ec 0c             	sub    $0xc,%esp
f0107ef8:	50                   	push   %eax
f0107ef9:	e8 b7 02 00 00       	call   f01081b5 <initialize_frame_info>
f0107efe:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107f01:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107f07:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f0a:	89 d0                	mov    %edx,%eax
f0107f0c:	01 c0                	add    %eax,%eax
f0107f0e:	01 d0                	add    %edx,%eax
f0107f10:	c1 e0 03             	shl    $0x3,%eax
f0107f13:	01 c8                	add    %ecx,%eax
f0107f15:	85 c0                	test   %eax,%eax
f0107f17:	75 14                	jne    f0107f2d <initialize_paging+0x141>
f0107f19:	83 ec 04             	sub    $0x4,%esp
f0107f1c:	68 d8 74 12 f0       	push   $0xf01274d8
f0107f21:	6a 60                	push   $0x60
f0107f23:	68 fb 74 12 f0       	push   $0xf01274fb
f0107f28:	e8 ed 83 ff ff       	call   f010031a <_panic>
f0107f2d:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107f33:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f36:	89 d0                	mov    %edx,%eax
f0107f38:	01 c0                	add    %eax,%eax
f0107f3a:	01 d0                	add    %edx,%eax
f0107f3c:	c1 e0 03             	shl    $0x3,%eax
f0107f3f:	01 c8                	add    %ecx,%eax
f0107f41:	8b 15 c0 0e 5a f0    	mov    0xf05a0ec0,%edx
f0107f47:	89 10                	mov    %edx,(%eax)
f0107f49:	8b 00                	mov    (%eax),%eax
f0107f4b:	85 c0                	test   %eax,%eax
f0107f4d:	74 1f                	je     f0107f6e <initialize_paging+0x182>
f0107f4f:	8b 15 c0 0e 5a f0    	mov    0xf05a0ec0,%edx
f0107f55:	8b 1d c0 38 5a f0    	mov    0xf05a38c0,%ebx
f0107f5b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f5e:	89 c8                	mov    %ecx,%eax
f0107f60:	01 c0                	add    %eax,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	c1 e0 03             	shl    $0x3,%eax
f0107f67:	01 d8                	add    %ebx,%eax
f0107f69:	89 42 04             	mov    %eax,0x4(%edx)
f0107f6c:	eb 19                	jmp    f0107f87 <initialize_paging+0x19b>
f0107f6e:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107f74:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f77:	89 d0                	mov    %edx,%eax
f0107f79:	01 c0                	add    %eax,%eax
f0107f7b:	01 d0                	add    %edx,%eax
f0107f7d:	c1 e0 03             	shl    $0x3,%eax
f0107f80:	01 c8                	add    %ecx,%eax
f0107f82:	a3 c4 0e 5a f0       	mov    %eax,0xf05a0ec4
f0107f87:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107f8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f90:	89 d0                	mov    %edx,%eax
f0107f92:	01 c0                	add    %eax,%eax
f0107f94:	01 d0                	add    %edx,%eax
f0107f96:	c1 e0 03             	shl    $0x3,%eax
f0107f99:	01 c8                	add    %ecx,%eax
f0107f9b:	a3 c0 0e 5a f0       	mov    %eax,0xf05a0ec0
f0107fa0:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107fa6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fa9:	89 d0                	mov    %edx,%eax
f0107fab:	01 c0                	add    %eax,%eax
f0107fad:	01 d0                	add    %edx,%eax
f0107faf:	c1 e0 03             	shl    $0x3,%eax
f0107fb2:	01 c8                	add    %ecx,%eax
f0107fb4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107fbb:	a1 cc 0e 5a f0       	mov    0xf05a0ecc,%eax
f0107fc0:	40                   	inc    %eax
f0107fc1:	a3 cc 0e 5a f0       	mov    %eax,0xf05a0ecc
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fc6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fcc:	85 c0                	test   %eax,%eax
f0107fce:	79 05                	jns    f0107fd5 <initialize_paging+0x1e9>
f0107fd0:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fd5:	c1 f8 0c             	sar    $0xc,%eax
f0107fd8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fdb:	0f 8f 00 ff ff ff    	jg     f0107ee1 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe1:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fe8:	eb 1d                	jmp    f0108007 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fea:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0107ff0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ff3:	89 d0                	mov    %edx,%eax
f0107ff5:	01 c0                	add    %eax,%eax
f0107ff7:	01 d0                	add    %edx,%eax
f0107ff9:	c1 e0 03             	shl    $0x3,%eax
f0107ffc:	01 c8                	add    %ecx,%eax
f0107ffe:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108004:	ff 45 f4             	incl   -0xc(%ebp)
f0108007:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010800e:	7e da                	jle    f0107fea <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0108010:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108017:	a1 78 3a 5a f0       	mov    0xf05a3a78,%eax
f010801c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010801f:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108026:	77 14                	ja     f010803c <initialize_paging+0x250>
f0108028:	ff 75 e0             	pushl  -0x20(%ebp)
f010802b:	68 18 75 12 f0       	push   $0xf0127518
f0108030:	6a 68                	push   $0x68
f0108032:	68 fb 74 12 f0       	push   $0xf01274fb
f0108037:	e8 de 82 ff ff       	call   f010031a <_panic>
f010803c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010803f:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108045:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108048:	01 d0                	add    %edx,%eax
f010804a:	48                   	dec    %eax
f010804b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010804e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108051:	ba 00 00 00 00       	mov    $0x0,%edx
f0108056:	f7 75 e4             	divl   -0x1c(%ebp)
f0108059:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010805c:	29 d0                	sub    %edx,%eax
f010805e:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108061:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108068:	eb 1d                	jmp    f0108087 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010806a:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0108070:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108073:	89 d0                	mov    %edx,%eax
f0108075:	01 c0                	add    %eax,%eax
f0108077:	01 d0                	add    %edx,%eax
f0108079:	c1 e0 03             	shl    $0x3,%eax
f010807c:	01 c8                	add    %ecx,%eax
f010807e:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108084:	ff 45 f4             	incl   -0xc(%ebp)
f0108087:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010808a:	85 c0                	test   %eax,%eax
f010808c:	79 05                	jns    f0108093 <initialize_paging+0x2a7>
f010808e:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108093:	c1 f8 0c             	sar    $0xc,%eax
f0108096:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108099:	7f cf                	jg     f010806a <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010809b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010809e:	85 c0                	test   %eax,%eax
f01080a0:	79 05                	jns    f01080a7 <initialize_paging+0x2bb>
f01080a2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01080a7:	c1 f8 0c             	sar    $0xc,%eax
f01080aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01080ad:	e9 e8 00 00 00       	jmp    f010819a <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f01080b2:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f01080b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bb:	89 d0                	mov    %edx,%eax
f01080bd:	01 c0                	add    %eax,%eax
f01080bf:	01 d0                	add    %edx,%eax
f01080c1:	c1 e0 03             	shl    $0x3,%eax
f01080c4:	01 c8                	add    %ecx,%eax
f01080c6:	83 ec 0c             	sub    $0xc,%esp
f01080c9:	50                   	push   %eax
f01080ca:	e8 e6 00 00 00       	call   f01081b5 <initialize_frame_info>
f01080cf:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080d2:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f01080d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080db:	89 d0                	mov    %edx,%eax
f01080dd:	01 c0                	add    %eax,%eax
f01080df:	01 d0                	add    %edx,%eax
f01080e1:	c1 e0 03             	shl    $0x3,%eax
f01080e4:	01 c8                	add    %ecx,%eax
f01080e6:	85 c0                	test   %eax,%eax
f01080e8:	75 14                	jne    f01080fe <initialize_paging+0x312>
f01080ea:	83 ec 04             	sub    $0x4,%esp
f01080ed:	68 d8 74 12 f0       	push   $0xf01274d8
f01080f2:	6a 74                	push   $0x74
f01080f4:	68 fb 74 12 f0       	push   $0xf01274fb
f01080f9:	e8 1c 82 ff ff       	call   f010031a <_panic>
f01080fe:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0108104:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108107:	89 d0                	mov    %edx,%eax
f0108109:	01 c0                	add    %eax,%eax
f010810b:	01 d0                	add    %edx,%eax
f010810d:	c1 e0 03             	shl    $0x3,%eax
f0108110:	01 c8                	add    %ecx,%eax
f0108112:	8b 15 c0 0e 5a f0    	mov    0xf05a0ec0,%edx
f0108118:	89 10                	mov    %edx,(%eax)
f010811a:	8b 00                	mov    (%eax),%eax
f010811c:	85 c0                	test   %eax,%eax
f010811e:	74 1f                	je     f010813f <initialize_paging+0x353>
f0108120:	8b 15 c0 0e 5a f0    	mov    0xf05a0ec0,%edx
f0108126:	8b 1d c0 38 5a f0    	mov    0xf05a38c0,%ebx
f010812c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010812f:	89 c8                	mov    %ecx,%eax
f0108131:	01 c0                	add    %eax,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	c1 e0 03             	shl    $0x3,%eax
f0108138:	01 d8                	add    %ebx,%eax
f010813a:	89 42 04             	mov    %eax,0x4(%edx)
f010813d:	eb 19                	jmp    f0108158 <initialize_paging+0x36c>
f010813f:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0108145:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108148:	89 d0                	mov    %edx,%eax
f010814a:	01 c0                	add    %eax,%eax
f010814c:	01 d0                	add    %edx,%eax
f010814e:	c1 e0 03             	shl    $0x3,%eax
f0108151:	01 c8                	add    %ecx,%eax
f0108153:	a3 c4 0e 5a f0       	mov    %eax,0xf05a0ec4
f0108158:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f010815e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108161:	89 d0                	mov    %edx,%eax
f0108163:	01 c0                	add    %eax,%eax
f0108165:	01 d0                	add    %edx,%eax
f0108167:	c1 e0 03             	shl    $0x3,%eax
f010816a:	01 c8                	add    %ecx,%eax
f010816c:	a3 c0 0e 5a f0       	mov    %eax,0xf05a0ec0
f0108171:	8b 0d c0 38 5a f0    	mov    0xf05a38c0,%ecx
f0108177:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817a:	89 d0                	mov    %edx,%eax
f010817c:	01 c0                	add    %eax,%eax
f010817e:	01 d0                	add    %edx,%eax
f0108180:	c1 e0 03             	shl    $0x3,%eax
f0108183:	01 c8                	add    %ecx,%eax
f0108185:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010818c:	a1 cc 0e 5a f0       	mov    0xf05a0ecc,%eax
f0108191:	40                   	inc    %eax
f0108192:	a3 cc 0e 5a f0       	mov    %eax,0xf05a0ecc
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108197:	ff 45 f4             	incl   -0xc(%ebp)
f010819a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010819d:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f01081a2:	39 c2                	cmp    %eax,%edx
f01081a4:	0f 82 08 ff ff ff    	jb     f01080b2 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f01081aa:	e8 ef b9 ff ff       	call   f0103b9e <initialize_disk_page_file>
}
f01081af:	90                   	nop
f01081b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01081b3:	c9                   	leave  
f01081b4:	c3                   	ret    

f01081b5 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f01081b5:	55                   	push   %ebp
f01081b6:	89 e5                	mov    %esp,%ebp
f01081b8:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f01081bb:	83 ec 04             	sub    $0x4,%esp
f01081be:	6a 18                	push   $0x18
f01081c0:	6a 00                	push   $0x0
f01081c2:	ff 75 08             	pushl  0x8(%ebp)
f01081c5:	e8 f9 a5 01 00       	call   f01227c3 <memset>
f01081ca:	83 c4 10             	add    $0x10,%esp
}
f01081cd:	90                   	nop
f01081ce:	c9                   	leave  
f01081cf:	c3                   	ret    

f01081d0 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081d0:	55                   	push   %ebp
f01081d1:	89 e5                	mov    %esp,%ebp
f01081d3:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081d6:	83 ec 0c             	sub    $0xc,%esp
f01081d9:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f01081de:	e8 57 6b 00 00       	call   f010ed3a <holding_spinlock>
f01081e3:	83 c4 10             	add    $0x10,%esp
f01081e6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081ed:	75 10                	jne    f01081ff <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081ef:	83 ec 0c             	sub    $0xc,%esp
f01081f2:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f01081f7:	e8 25 69 00 00       	call   f010eb21 <acquire_spinlock>
f01081fc:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081ff:	8b 15 c0 0e 5a f0    	mov    0xf05a0ec0,%edx
f0108205:	8b 45 08             	mov    0x8(%ebp),%eax
f0108208:	89 10                	mov    %edx,(%eax)
	int c = 0;
f010820a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f0108211:	8b 45 08             	mov    0x8(%ebp),%eax
f0108214:	8b 00                	mov    (%eax),%eax
f0108216:	85 c0                	test   %eax,%eax
f0108218:	75 17                	jne    f0108231 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f010821a:	83 ec 04             	sub    $0x4,%esp
f010821d:	68 4c 75 12 f0       	push   $0xf012754c
f0108222:	68 a2 00 00 00       	push   $0xa2
f0108227:	68 fb 74 12 f0       	push   $0xf01274fb
f010822c:	e8 e9 80 ff ff       	call   f010031a <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108231:	8b 45 08             	mov    0x8(%ebp),%eax
f0108234:	8b 00                	mov    (%eax),%eax
f0108236:	85 c0                	test   %eax,%eax
f0108238:	75 17                	jne    f0108251 <allocate_frame+0x81>
f010823a:	83 ec 04             	sub    $0x4,%esp
f010823d:	68 99 75 12 f0       	push   $0xf0127599
f0108242:	68 a8 00 00 00       	push   $0xa8
f0108247:	68 fb 74 12 f0       	push   $0xf01274fb
f010824c:	e8 c9 80 ff ff       	call   f010031a <_panic>
f0108251:	8b 45 08             	mov    0x8(%ebp),%eax
f0108254:	8b 00                	mov    (%eax),%eax
f0108256:	8b 00                	mov    (%eax),%eax
f0108258:	85 c0                	test   %eax,%eax
f010825a:	74 14                	je     f0108270 <allocate_frame+0xa0>
f010825c:	8b 45 08             	mov    0x8(%ebp),%eax
f010825f:	8b 00                	mov    (%eax),%eax
f0108261:	8b 00                	mov    (%eax),%eax
f0108263:	8b 55 08             	mov    0x8(%ebp),%edx
f0108266:	8b 12                	mov    (%edx),%edx
f0108268:	8b 52 04             	mov    0x4(%edx),%edx
f010826b:	89 50 04             	mov    %edx,0x4(%eax)
f010826e:	eb 0d                	jmp    f010827d <allocate_frame+0xad>
f0108270:	8b 45 08             	mov    0x8(%ebp),%eax
f0108273:	8b 00                	mov    (%eax),%eax
f0108275:	8b 40 04             	mov    0x4(%eax),%eax
f0108278:	a3 c4 0e 5a f0       	mov    %eax,0xf05a0ec4
f010827d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108280:	8b 00                	mov    (%eax),%eax
f0108282:	8b 40 04             	mov    0x4(%eax),%eax
f0108285:	85 c0                	test   %eax,%eax
f0108287:	74 13                	je     f010829c <allocate_frame+0xcc>
f0108289:	8b 45 08             	mov    0x8(%ebp),%eax
f010828c:	8b 00                	mov    (%eax),%eax
f010828e:	8b 40 04             	mov    0x4(%eax),%eax
f0108291:	8b 55 08             	mov    0x8(%ebp),%edx
f0108294:	8b 12                	mov    (%edx),%edx
f0108296:	8b 12                	mov    (%edx),%edx
f0108298:	89 10                	mov    %edx,(%eax)
f010829a:	eb 0c                	jmp    f01082a8 <allocate_frame+0xd8>
f010829c:	8b 45 08             	mov    0x8(%ebp),%eax
f010829f:	8b 00                	mov    (%eax),%eax
f01082a1:	8b 00                	mov    (%eax),%eax
f01082a3:	a3 c0 0e 5a f0       	mov    %eax,0xf05a0ec0
f01082a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ab:	8b 00                	mov    (%eax),%eax
f01082ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01082b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01082b6:	8b 00                	mov    (%eax),%eax
f01082b8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082bf:	a1 cc 0e 5a f0       	mov    0xf05a0ecc,%eax
f01082c4:	48                   	dec    %eax
f01082c5:	a3 cc 0e 5a f0       	mov    %eax,0xf05a0ecc

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01082cd:	8b 00                	mov    (%eax),%eax
f01082cf:	8a 40 14             	mov    0x14(%eax),%al
f01082d2:	84 c0                	test   %al,%al
f01082d4:	74 20                	je     f01082f6 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01082d9:	8b 00                	mov    (%eax),%eax
f01082db:	8b 50 10             	mov    0x10(%eax),%edx
f01082de:	8b 45 08             	mov    0x8(%ebp),%eax
f01082e1:	8b 00                	mov    (%eax),%eax
f01082e3:	8b 40 0c             	mov    0xc(%eax),%eax
f01082e6:	8b 40 64             	mov    0x64(%eax),%eax
f01082e9:	83 ec 08             	sub    $0x8,%esp
f01082ec:	52                   	push   %edx
f01082ed:	50                   	push   %eax
f01082ee:	e8 42 09 00 00       	call   f0108c35 <pt_clear_page_table_entry>
f01082f3:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01082f9:	8b 00                	mov    (%eax),%eax
f01082fb:	83 ec 0c             	sub    $0xc,%esp
f01082fe:	50                   	push   %eax
f01082ff:	e8 b1 fe ff ff       	call   f01081b5 <initialize_frame_info>
f0108304:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0108307:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010830b:	75 10                	jne    f010831d <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010830d:	83 ec 0c             	sub    $0xc,%esp
f0108310:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f0108315:	e8 8e 68 00 00       	call   f010eba8 <release_spinlock>
f010831a:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010831d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108322:	c9                   	leave  
f0108323:	c3                   	ret    

f0108324 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108324:	55                   	push   %ebp
f0108325:	89 e5                	mov    %esp,%ebp
f0108327:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010832a:	83 ec 0c             	sub    $0xc,%esp
f010832d:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f0108332:	e8 03 6a 00 00       	call   f010ed3a <holding_spinlock>
f0108337:	83 c4 10             	add    $0x10,%esp
f010833a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010833d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108341:	75 10                	jne    f0108353 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108343:	83 ec 0c             	sub    $0xc,%esp
f0108346:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f010834b:	e8 d1 67 00 00       	call   f010eb21 <acquire_spinlock>
f0108350:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108353:	83 ec 0c             	sub    $0xc,%esp
f0108356:	ff 75 08             	pushl  0x8(%ebp)
f0108359:	e8 57 fe ff ff       	call   f01081b5 <initialize_frame_info>
f010835e:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108361:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108365:	75 17                	jne    f010837e <free_frame+0x5a>
f0108367:	83 ec 04             	sub    $0x4,%esp
f010836a:	68 d8 74 12 f0       	push   $0xf01274d8
f010836f:	68 cf 00 00 00       	push   $0xcf
f0108374:	68 fb 74 12 f0       	push   $0xf01274fb
f0108379:	e8 9c 7f ff ff       	call   f010031a <_panic>
f010837e:	8b 15 c0 0e 5a f0    	mov    0xf05a0ec0,%edx
f0108384:	8b 45 08             	mov    0x8(%ebp),%eax
f0108387:	89 10                	mov    %edx,(%eax)
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	8b 00                	mov    (%eax),%eax
f010838e:	85 c0                	test   %eax,%eax
f0108390:	74 0d                	je     f010839f <free_frame+0x7b>
f0108392:	a1 c0 0e 5a f0       	mov    0xf05a0ec0,%eax
f0108397:	8b 55 08             	mov    0x8(%ebp),%edx
f010839a:	89 50 04             	mov    %edx,0x4(%eax)
f010839d:	eb 08                	jmp    f01083a7 <free_frame+0x83>
f010839f:	8b 45 08             	mov    0x8(%ebp),%eax
f01083a2:	a3 c4 0e 5a f0       	mov    %eax,0xf05a0ec4
f01083a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01083aa:	a3 c0 0e 5a f0       	mov    %eax,0xf05a0ec0
f01083af:	8b 45 08             	mov    0x8(%ebp),%eax
f01083b2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01083b9:	a1 cc 0e 5a f0       	mov    0xf05a0ecc,%eax
f01083be:	40                   	inc    %eax
f01083bf:	a3 cc 0e 5a f0       	mov    %eax,0xf05a0ecc
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083c8:	75 10                	jne    f01083da <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ca:	83 ec 0c             	sub    $0xc,%esp
f01083cd:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f01083d2:	e8 d1 67 00 00       	call   f010eba8 <release_spinlock>
f01083d7:	83 c4 10             	add    $0x10,%esp
	}
}
f01083da:	90                   	nop
f01083db:	c9                   	leave  
f01083dc:	c3                   	ret    

f01083dd <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083dd:	55                   	push   %ebp
f01083de:	89 e5                	mov    %esp,%ebp
f01083e0:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083e6:	8b 40 08             	mov    0x8(%eax),%eax
f01083e9:	48                   	dec    %eax
f01083ea:	8b 55 08             	mov    0x8(%ebp),%edx
f01083ed:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01083f4:	8b 40 08             	mov    0x8(%eax),%eax
f01083f7:	66 85 c0             	test   %ax,%ax
f01083fa:	75 0e                	jne    f010840a <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083fc:	83 ec 0c             	sub    $0xc,%esp
f01083ff:	ff 75 08             	pushl  0x8(%ebp)
f0108402:	e8 1d ff ff ff       	call   f0108324 <free_frame>
f0108407:	83 c4 10             	add    $0x10,%esp
}
f010840a:	90                   	nop
f010840b:	c9                   	leave  
f010840c:	c3                   	ret    

f010840d <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010840d:	55                   	push   %ebp
f010840e:	89 e5                	mov    %esp,%ebp
f0108410:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108413:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108416:	c1 e8 16             	shr    $0x16,%eax
f0108419:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108420:	8b 45 08             	mov    0x8(%ebp),%eax
f0108423:	01 d0                	add    %edx,%eax
f0108425:	8b 00                	mov    (%eax),%eax
f0108427:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010842a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010842d:	83 e0 01             	and    $0x1,%eax
f0108430:	85 c0                	test   %eax,%eax
f0108432:	74 4e                	je     f0108482 <get_page_table+0x75>
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108434:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108437:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010843c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010843f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108442:	c1 e8 0c             	shr    $0xc,%eax
f0108445:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108448:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f010844d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108450:	72 17                	jb     f0108469 <get_page_table+0x5c>
f0108452:	ff 75 f0             	pushl  -0x10(%ebp)
f0108455:	68 b8 75 12 f0       	push   $0xf01275b8
f010845a:	68 fb 00 00 00       	push   $0xfb
f010845f:	68 fb 74 12 f0       	push   $0xf01274fb
f0108464:	e8 b1 7e ff ff       	call   f010031a <_panic>
f0108469:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010846c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108471:	89 c2                	mov    %eax,%edx
f0108473:	8b 45 10             	mov    0x10(%ebp),%eax
f0108476:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108478:	b8 00 00 00 00       	mov    $0x0,%eax
f010847d:	e9 8f 00 00 00       	jmp    f0108511 <get_page_table+0x104>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0108482:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108486:	74 7b                	je     f0108503 <get_page_table+0xf6>
f0108488:	8b 45 0c             	mov    0xc(%ebp),%eax
f010848b:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010848e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108491:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108494:	83 ec 0c             	sub    $0xc,%esp
f0108497:	6a 00                	push   $0x0
f0108499:	e8 57 63 00 00       	call   f010e7f5 <fault_handler>
f010849e:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084a4:	c1 e8 16             	shr    $0x16,%eax
f01084a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01084b1:	01 d0                	add    %edx,%eax
f01084b3:	8b 00                	mov    (%eax),%eax
f01084b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084c6:	c1 e8 0c             	shr    $0xc,%eax
f01084c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084cc:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f01084d1:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01084d4:	72 17                	jb     f01084ed <get_page_table+0xe0>
f01084d6:	ff 75 e8             	pushl  -0x18(%ebp)
f01084d9:	68 b8 75 12 f0       	push   $0xf01275b8
f01084de:	68 13 01 00 00       	push   $0x113
f01084e3:	68 fb 74 12 f0       	push   $0xf01274fb
f01084e8:	e8 2d 7e ff ff       	call   f010031a <_panic>
f01084ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01084f5:	89 c2                	mov    %eax,%edx
f01084f7:	8b 45 10             	mov    0x10(%ebp),%eax
f01084fa:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01084fc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108501:	eb 0e                	jmp    f0108511 <get_page_table+0x104>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108503:	8b 45 10             	mov    0x10(%ebp),%eax
f0108506:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010850c:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108511:	c9                   	leave  
f0108512:	c3                   	ret    

f0108513 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108513:	55                   	push   %ebp
f0108514:	89 e5                	mov    %esp,%ebp
f0108516:	83 ec 18             	sub    $0x18,%esp
	memset(ptr_page_table , 0, PAGE_SIZE);
	tlbflush();

#else
	uint32 * ptr_page_table ;
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
f0108519:	83 ec 04             	sub    $0x4,%esp
f010851c:	8d 45 f4             	lea    -0xc(%ebp),%eax
f010851f:	50                   	push   %eax
f0108520:	ff 75 0c             	pushl  0xc(%ebp)
f0108523:	ff 75 08             	pushl  0x8(%ebp)
f0108526:	e8 08 00 00 00       	call   f0108533 <__static_cpt>
f010852b:	83 c4 10             	add    $0x10,%esp
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f010852e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108531:	c9                   	leave  
f0108532:	c3                   	ret    

f0108533 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108533:	55                   	push   %ebp
f0108534:	89 e5                	mov    %esp,%ebp
f0108536:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0108539:	83 ec 0c             	sub    $0xc,%esp
f010853c:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010853f:	50                   	push   %eax
f0108540:	e8 8b fc ff ff       	call   f01081d0 <allocate_frame>
f0108545:	83 c4 10             	add    $0x10,%esp
f0108548:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f010854b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010854e:	83 ec 0c             	sub    $0xc,%esp
f0108551:	50                   	push   %eax
f0108552:	e8 27 f8 ff ff       	call   f0107d7e <to_physical_address>
f0108557:	83 c4 10             	add    $0x10,%esp
f010855a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010855d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108560:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108563:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108566:	c1 e8 0c             	shr    $0xc,%eax
f0108569:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010856c:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0108571:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108574:	72 17                	jb     f010858d <__static_cpt+0x5a>
f0108576:	ff 75 ec             	pushl  -0x14(%ebp)
f0108579:	68 b8 75 12 f0       	push   $0xf01275b8
f010857e:	68 4e 01 00 00       	push   $0x14e
f0108583:	68 fb 74 12 f0       	push   $0xf01274fb
f0108588:	e8 8d 7d ff ff       	call   f010031a <_panic>
f010858d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108590:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108595:	89 c2                	mov    %eax,%edx
f0108597:	8b 45 10             	mov    0x10(%ebp),%eax
f010859a:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f010859c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010859f:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01085a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01085a8:	c1 e8 16             	shr    $0x16,%eax
f01085ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01085b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01085b5:	01 d0                	add    %edx,%eax
f01085b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01085ba:	83 ca 07             	or     $0x7,%edx
f01085bd:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01085bf:	8b 45 10             	mov    0x10(%ebp),%eax
f01085c2:	8b 00                	mov    (%eax),%eax
f01085c4:	83 ec 04             	sub    $0x4,%esp
f01085c7:	68 00 10 00 00       	push   $0x1000
f01085cc:	6a 00                	push   $0x0
f01085ce:	50                   	push   %eax
f01085cf:	e8 ef a1 01 00       	call   f01227c3 <memset>
f01085d4:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085d7:	0f 20 d8             	mov    %cr3,%eax
f01085da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01085e0:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01085e3:	90                   	nop
f01085e4:	c9                   	leave  
f01085e5:	c3                   	ret    

f01085e6 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01085e6:	55                   	push   %ebp
f01085e7:	89 e5                	mov    %esp,%ebp
f01085e9:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01085ec:	ff 75 0c             	pushl  0xc(%ebp)
f01085ef:	e8 8a f7 ff ff       	call   f0107d7e <to_physical_address>
f01085f4:	83 c4 04             	add    $0x4,%esp
f01085f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01085fa:	83 ec 04             	sub    $0x4,%esp
f01085fd:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0108600:	50                   	push   %eax
f0108601:	ff 75 10             	pushl  0x10(%ebp)
f0108604:	ff 75 08             	pushl  0x8(%ebp)
f0108607:	e8 01 fe ff ff       	call   f010840d <get_page_table>
f010860c:	83 c4 10             	add    $0x10,%esp
f010860f:	83 f8 01             	cmp    $0x1,%eax
f0108612:	75 15                	jne    f0108629 <map_frame+0x43>
			uint32* ptr_page_table2 =NULL;
			//cprintf("======> After the table created at %x\n\n", get_page_table(ptr_page_directory, virtual_address,&ptr_page_table2));
		}
#else
		{
			__static_cpt(ptr_page_directory, (uint32)virtual_address, &ptr_page_table);
f0108614:	83 ec 04             	sub    $0x4,%esp
f0108617:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010861a:	50                   	push   %eax
f010861b:	ff 75 10             	pushl  0x10(%ebp)
f010861e:	ff 75 08             	pushl  0x8(%ebp)
f0108621:	e8 0d ff ff ff       	call   f0108533 <__static_cpt>
f0108626:	83 c4 10             	add    $0x10,%esp
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f0108629:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010862c:	8b 55 10             	mov    0x10(%ebp),%edx
f010862f:	c1 ea 0c             	shr    $0xc,%edx
f0108632:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108638:	c1 e2 02             	shl    $0x2,%edx
f010863b:	01 d0                	add    %edx,%eax
f010863d:	8b 00                	mov    (%eax),%eax
f010863f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108642:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108645:	83 e0 01             	and    $0x1,%eax
f0108648:	85 c0                	test   %eax,%eax
f010864a:	74 25                	je     f0108671 <map_frame+0x8b>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f010864c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010864f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108654:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108657:	75 07                	jne    f0108660 <map_frame+0x7a>
			return 0;
f0108659:	b8 00 00 00 00       	mov    $0x0,%eax
f010865e:	eb 68                	jmp    f01086c8 <map_frame+0xe2>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108660:	83 ec 08             	sub    $0x8,%esp
f0108663:	ff 75 10             	pushl  0x10(%ebp)
f0108666:	ff 75 08             	pushl  0x8(%ebp)
f0108669:	e8 d2 00 00 00       	call   f0108740 <unmap_frame>
f010866e:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108671:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108674:	8b 40 08             	mov    0x8(%eax),%eax
f0108677:	40                   	inc    %eax
f0108678:	8b 55 0c             	mov    0xc(%ebp),%edx
f010867b:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010867f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108682:	8b 55 10             	mov    0x10(%ebp),%edx
f0108685:	c1 ea 0c             	shr    $0xc,%edx
f0108688:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010868e:	c1 e2 02             	shl    $0x2,%edx
f0108691:	01 d0                	add    %edx,%eax
f0108693:	8b 00                	mov    (%eax),%eax
f0108695:	25 00 0e 00 00       	and    $0xe00,%eax
f010869a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010869d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01086a0:	8b 55 10             	mov    0x10(%ebp),%edx
f01086a3:	c1 ea 0c             	shr    $0xc,%edx
f01086a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086ac:	c1 e2 02             	shl    $0x2,%edx
f01086af:	01 c2                	add    %eax,%edx
f01086b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086b4:	0b 45 ec             	or     -0x14(%ebp),%eax
f01086b7:	89 c1                	mov    %eax,%ecx
f01086b9:	8b 45 14             	mov    0x14(%ebp),%eax
f01086bc:	09 c8                	or     %ecx,%eax
f01086be:	83 c8 01             	or     $0x1,%eax
f01086c1:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01086c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01086c8:	c9                   	leave  
f01086c9:	c3                   	ret    

f01086ca <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01086ca:	55                   	push   %ebp
f01086cb:	89 e5                	mov    %esp,%ebp
f01086cd:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01086d0:	83 ec 04             	sub    $0x4,%esp
f01086d3:	ff 75 10             	pushl  0x10(%ebp)
f01086d6:	ff 75 0c             	pushl  0xc(%ebp)
f01086d9:	ff 75 08             	pushl  0x8(%ebp)
f01086dc:	e8 2c fd ff ff       	call   f010840d <get_page_table>
f01086e1:	83 c4 10             	add    $0x10,%esp
f01086e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f01086e7:	8b 45 10             	mov    0x10(%ebp),%eax
f01086ea:	8b 00                	mov    (%eax),%eax
f01086ec:	85 c0                	test   %eax,%eax
f01086ee:	74 49                	je     f0108739 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f01086f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01086f3:	c1 e8 0c             	shr    $0xc,%eax
f01086f6:	25 ff 03 00 00       	and    $0x3ff,%eax
f01086fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f01086fe:	8b 45 10             	mov    0x10(%ebp),%eax
f0108701:	8b 00                	mov    (%eax),%eax
f0108703:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108706:	c1 e2 02             	shl    $0x2,%edx
f0108709:	01 d0                	add    %edx,%eax
f010870b:	8b 00                	mov    (%eax),%eax
f010870d:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108710:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108713:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108718:	85 c0                	test   %eax,%eax
f010871a:	74 16                	je     f0108732 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010871c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010871f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108724:	83 ec 0c             	sub    $0xc,%esp
f0108727:	50                   	push   %eax
f0108728:	e8 64 f6 ff ff       	call   f0107d91 <to_frame_info>
f010872d:	83 c4 10             	add    $0x10,%esp
f0108730:	eb 0c                	jmp    f010873e <get_frame_info+0x74>
		}
		return 0;
f0108732:	b8 00 00 00 00       	mov    $0x0,%eax
f0108737:	eb 05                	jmp    f010873e <get_frame_info+0x74>
	}
	return 0;
f0108739:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010873e:	c9                   	leave  
f010873f:	c3                   	ret    

f0108740 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108740:	55                   	push   %ebp
f0108741:	89 e5                	mov    %esp,%ebp
f0108743:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108746:	83 ec 04             	sub    $0x4,%esp
f0108749:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010874c:	50                   	push   %eax
f010874d:	ff 75 0c             	pushl  0xc(%ebp)
f0108750:	ff 75 08             	pushl  0x8(%ebp)
f0108753:	e8 72 ff ff ff       	call   f01086ca <get_frame_info>
f0108758:	83 c4 10             	add    $0x10,%esp
f010875b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f010875e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108762:	74 7d                	je     f01087e1 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108764:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108767:	8a 40 14             	mov    0x14(%eax),%al
f010876a:	84 c0                	test   %al,%al
f010876c:	74 1c                	je     f010878a <unmap_frame+0x4a>
f010876e:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108775:	77 13                	ja     f010878a <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108777:	83 ec 08             	sub    $0x8,%esp
f010877a:	ff 75 0c             	pushl  0xc(%ebp)
f010877d:	68 e8 75 12 f0       	push   $0xf01275e8
f0108782:	e8 e5 87 ff ff       	call   f0100f6c <cprintf>
f0108787:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f010878a:	83 ec 0c             	sub    $0xc,%esp
f010878d:	ff 75 f4             	pushl  -0xc(%ebp)
f0108790:	e8 48 fc ff ff       	call   f01083dd <decrement_references>
f0108795:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108798:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010879b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010879e:	c1 ea 0c             	shr    $0xc,%edx
f01087a1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087a7:	c1 e2 02             	shl    $0x2,%edx
f01087aa:	01 d0                	add    %edx,%eax
f01087ac:	8b 00                	mov    (%eax),%eax
f01087ae:	25 00 0e 00 00       	and    $0xe00,%eax
f01087b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01087b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01087bc:	c1 ea 0c             	shr    $0xc,%edx
f01087bf:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087c5:	c1 e2 02             	shl    $0x2,%edx
f01087c8:	01 c2                	add    %eax,%edx
f01087ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087cd:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01087cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087d2:	83 ec 08             	sub    $0x8,%esp
f01087d5:	50                   	push   %eax
f01087d6:	ff 75 08             	pushl  0x8(%ebp)
f01087d9:	e8 f9 f5 ff ff       	call   f0107dd7 <tlb_invalidate>
f01087de:	83 c4 10             	add    $0x10,%esp
	}
}
f01087e1:	90                   	nop
f01087e2:	c9                   	leave  
f01087e3:	c3                   	ret    

f01087e4 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01087e4:	55                   	push   %ebp
f01087e5:	89 e5                	mov    %esp,%ebp
f01087e7:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01087ea:	ff 75 0c             	pushl  0xc(%ebp)
f01087ed:	e8 8c f5 ff ff       	call   f0107d7e <to_physical_address>
f01087f2:	83 c4 04             	add    $0x4,%esp
f01087f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01087f8:	8b 45 10             	mov    0x10(%ebp),%eax
f01087fb:	c1 e8 16             	shr    $0x16,%eax
f01087fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108805:	8b 45 08             	mov    0x8(%ebp),%eax
f0108808:	01 d0                	add    %edx,%eax
f010880a:	8b 00                	mov    (%eax),%eax
f010880c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010880f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108812:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108817:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010881a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010881d:	c1 e8 0c             	shr    $0xc,%eax
f0108820:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108823:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0108828:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010882b:	72 17                	jb     f0108844 <loadtime_map_frame+0x60>
f010882d:	ff 75 ec             	pushl  -0x14(%ebp)
f0108830:	68 b8 75 12 f0       	push   $0xf01275b8
f0108835:	68 f9 01 00 00       	push   $0x1f9
f010883a:	68 fb 74 12 f0       	push   $0xf01274fb
f010883f:	e8 d6 7a ff ff       	call   f010031a <_panic>
f0108844:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108847:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010884c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f010884f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108853:	75 15                	jne    f010886a <loadtime_map_frame+0x86>
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
		}
#else
		{
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
f0108855:	83 ec 04             	sub    $0x4,%esp
f0108858:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010885b:	50                   	push   %eax
f010885c:	ff 75 10             	pushl  0x10(%ebp)
f010885f:	ff 75 08             	pushl  0x8(%ebp)
f0108862:	e8 cc fc ff ff       	call   f0108533 <__static_cpt>
f0108867:	83 c4 10             	add    $0x10,%esp
		}
#endif
	}

	ptr_frame_info->references++;
f010886a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010886d:	8b 40 08             	mov    0x8(%eax),%eax
f0108870:	40                   	inc    %eax
f0108871:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108874:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108878:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010887b:	8b 55 10             	mov    0x10(%ebp),%edx
f010887e:	c1 ea 0c             	shr    $0xc,%edx
f0108881:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108887:	c1 e2 02             	shl    $0x2,%edx
f010888a:	01 c2                	add    %eax,%edx
f010888c:	8b 45 14             	mov    0x14(%ebp),%eax
f010888f:	0b 45 f4             	or     -0xc(%ebp),%eax
f0108892:	83 c8 01             	or     $0x1,%eax
f0108895:	89 02                	mov    %eax,(%edx)

	return 0;
f0108897:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010889c:	c9                   	leave  
f010889d:	c3                   	ret    

f010889e <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f010889e:	55                   	push   %ebp
f010889f:	89 e5                	mov    %esp,%ebp
f01088a1:	57                   	push   %edi
f01088a2:	56                   	push   %esi
f01088a3:	53                   	push   %ebx
f01088a4:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01088a7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f01088ae:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f01088b5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f01088bc:	83 ec 0c             	sub    $0xc,%esp
f01088bf:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f01088c4:	e8 71 64 00 00       	call   f010ed3a <holding_spinlock>
f01088c9:	83 c4 10             	add    $0x10,%esp
f01088cc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f01088cf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01088d3:	75 10                	jne    f01088e5 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01088d5:	83 ec 0c             	sub    $0xc,%esp
f01088d8:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f01088dd:	e8 3f 62 00 00       	call   f010eb21 <acquire_spinlock>
f01088e2:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01088e5:	a1 c0 0e 5a f0       	mov    0xf05a0ec0,%eax
f01088ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088ed:	eb 1a                	jmp    f0108909 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01088ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01088f2:	8a 40 14             	mov    0x14(%eax),%al
f01088f5:	84 c0                	test   %al,%al
f01088f7:	74 05                	je     f01088fe <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01088f9:	ff 45 dc             	incl   -0x24(%ebp)
f01088fc:	eb 03                	jmp    f0108901 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01088fe:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108901:	a1 c8 0e 5a f0       	mov    0xf05a0ec8,%eax
f0108906:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108909:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010890d:	74 07                	je     f0108916 <calculate_available_frames+0x78>
f010890f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108912:	8b 00                	mov    (%eax),%eax
f0108914:	eb 05                	jmp    f010891b <calculate_available_frames+0x7d>
f0108916:	b8 00 00 00 00       	mov    $0x0,%eax
f010891b:	a3 c8 0e 5a f0       	mov    %eax,0xf05a0ec8
f0108920:	a1 c8 0e 5a f0       	mov    0xf05a0ec8,%eax
f0108925:	85 c0                	test   %eax,%eax
f0108927:	75 c6                	jne    f01088ef <calculate_available_frames+0x51>
f0108929:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010892d:	75 c0                	jne    f01088ef <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f010892f:	a1 dc 0e 5a f0       	mov    0xf05a0edc,%eax
f0108934:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108937:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010893b:	75 10                	jne    f010894d <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010893d:	83 ec 0c             	sub    $0xc,%esp
f0108940:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f0108945:	e8 5e 62 00 00       	call   f010eba8 <release_spinlock>
f010894a:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f010894d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108950:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108953:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108956:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108959:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010895c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f010895f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108962:	89 c3                	mov    %eax,%ebx
f0108964:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108967:	ba 03 00 00 00       	mov    $0x3,%edx
f010896c:	89 df                	mov    %ebx,%edi
f010896e:	89 c6                	mov    %eax,%esi
f0108970:	89 d1                	mov    %edx,%ecx
f0108972:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108974:	8b 45 08             	mov    0x8(%ebp),%eax
f0108977:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010897a:	5b                   	pop    %ebx
f010897b:	5e                   	pop    %esi
f010897c:	5f                   	pop    %edi
f010897d:	5d                   	pop    %ebp
f010897e:	c2 04 00             	ret    $0x4

f0108981 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init(uint32 numOfElements)
{
f0108981:	55                   	push   %ebp
f0108982:	89 e5                	mov    %esp,%ebp
f0108984:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
	init_spinlock(&AllShares.shareslock, "shares lock");
#else
	panic("not handled when KERN HEAP is disabled");
f0108987:	83 ec 04             	sub    $0x4,%esp
f010898a:	68 18 76 12 f0       	push   $0xf0127618
f010898f:	6a 1e                	push   $0x1e
f0108991:	68 40 76 12 f0       	push   $0xf0127640
f0108996:	e8 7f 79 ff ff       	call   f010031a <_panic>

f010899b <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f010899b:	55                   	push   %ebp
f010899c:	89 e5                	mov    %esp,%ebp
f010899e:	83 ec 18             	sub    $0x18,%esp
f01089a1:	8b 45 14             	mov    0x14(%ebp),%eax
f01089a4:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f01089a7:	83 ec 04             	sub    $0x4,%esp
f01089aa:	68 64 76 12 f0       	push   $0xf0127664
f01089af:	6a 32                	push   $0x32
f01089b1:	68 40 76 12 f0       	push   $0xf0127640
f01089b6:	e8 5f 79 ff ff       	call   f010031a <_panic>

f01089bb <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f01089bb:	55                   	push   %ebp
f01089bc:	89 e5                	mov    %esp,%ebp
f01089be:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f01089c1:	83 ec 04             	sub    $0x4,%esp
f01089c4:	68 88 76 12 f0       	push   $0xf0127688
f01089c9:	6a 42                	push   $0x42
f01089cb:	68 40 76 12 f0       	push   $0xf0127640
f01089d0:	e8 45 79 ff ff       	call   f010031a <_panic>

f01089d5 <free_share>:
// [3] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f01089d5:	55                   	push   %ebp
f01089d6:	89 e5                	mov    %esp,%ebp
f01089d8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f01089db:	83 ec 04             	sub    $0x4,%esp
f01089de:	68 ac 76 12 f0       	push   $0xf01276ac
f01089e3:	6a 50                	push   $0x50
f01089e5:	68 40 76 12 f0       	push   $0xf0127640
f01089ea:	e8 2b 79 ff ff       	call   f010031a <_panic>

f01089ef <create_frames_storage>:
//===========================
// [4] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f01089ef:	55                   	push   %ebp
f01089f0:	89 e5                	mov    %esp,%ebp
f01089f2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f01089f5:	83 ec 04             	sub    $0x4,%esp
f01089f8:	68 d0 76 12 f0       	push   $0xf01276d0
f01089fd:	6a 5c                	push   $0x5c
f01089ff:	68 40 76 12 f0       	push   $0xf0127640
f0108a04:	e8 11 79 ff ff       	call   f010031a <_panic>

f0108a09 <createSharedObject>:

//=========================
// [5] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108a09:	55                   	push   %ebp
f0108a0a:	89 e5                	mov    %esp,%ebp
f0108a0c:	83 ec 18             	sub    $0x18,%esp
f0108a0f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a12:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f0108a15:	83 ec 04             	sub    $0x4,%esp
f0108a18:	68 00 77 12 f0       	push   $0xf0127700
f0108a1d:	6a 68                	push   $0x68
f0108a1f:	68 40 76 12 f0       	push   $0xf0127640
f0108a24:	e8 f1 78 ff ff       	call   f010031a <_panic>

f0108a29 <getSizeOfSharedObject>:

//==============================
// [6] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a29:	55                   	push   %ebp
f0108a2a:	89 e5                	mov    %esp,%ebp
f0108a2c:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a2f:	83 ec 08             	sub    $0x8,%esp
f0108a32:	ff 75 0c             	pushl  0xc(%ebp)
f0108a35:	ff 75 08             	pushl  0x8(%ebp)
f0108a38:	e8 7e ff ff ff       	call   f01089bb <get_share>
f0108a3d:	83 c4 10             	add    $0x10,%esp
f0108a40:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a47:	75 07                	jne    f0108a50 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108a49:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108a4e:	eb 06                	jmp    f0108a56 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a53:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108a56:	c9                   	leave  
f0108a57:	c3                   	ret    

f0108a58 <getSharedObject>:

//======================
// [7] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108a58:	55                   	push   %ebp
f0108a59:	89 e5                	mov    %esp,%ebp
f0108a5b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f0108a5e:	83 ec 04             	sub    $0x4,%esp
f0108a61:	68 2c 77 12 f0       	push   $0xf012772c
f0108a66:	68 89 00 00 00       	push   $0x89
f0108a6b:	68 40 76 12 f0       	push   $0xf0127640
f0108a70:	e8 a5 78 ff ff       	call   f010031a <_panic>

f0108a75 <freeSharedObject>:

//===================
// Free Share Object:
//===================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108a75:	55                   	push   %ebp
f0108a76:	89 e5                	mov    %esp,%ebp
f0108a78:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108a7b:	83 ec 04             	sub    $0x4,%esp
f0108a7e:	68 54 77 12 f0       	push   $0xf0127754
f0108a83:	68 9a 00 00 00       	push   $0x9a
f0108a88:	68 40 76 12 f0       	push   $0xf0127640
f0108a8d:	e8 88 78 ff ff       	call   f010031a <_panic>

f0108a92 <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): E_NO_MEM
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108a92:	55                   	push   %ebp
f0108a93:	89 e5                	mov    %esp,%ebp
f0108a95:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
f0108a98:	83 ec 04             	sub    $0x4,%esp
f0108a9b:	68 7c 77 12 f0       	push   $0xf012777c
f0108aa0:	6a 11                	push   $0x11
f0108aa2:	68 bd 77 12 f0       	push   $0xf01277bd
f0108aa7:	e8 6e 78 ff ff       	call   f010031a <_panic>

f0108aac <sbrk>:
}

void* sbrk(int numOfPages)
{
f0108aac:	55                   	push   %ebp
f0108aad:	89 e5                	mov    %esp,%ebp
	 * 	1) Allocating additional pages for a kernel dynamic allocator will fail if the free frames are exhausted
	 * 		or the break exceed the limit of the dynamic allocator. If sbrk fails, kernel should panic(...)
	 */

	//MS2: COMMENT THIS LINE BEFORE START CODING====
	return (void*)-1 ;
f0108aaf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	//====================================================

	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("sbrk() is not implemented yet...!!");
}
f0108ab4:	5d                   	pop    %ebp
f0108ab5:	c3                   	ret    

f0108ab6 <kmalloc>:


void* kmalloc(unsigned int size)
{
f0108ab6:	55                   	push   %ebp
f0108ab7:	89 e5                	mov    %esp,%ebp
f0108ab9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f0108abc:	83 ec 04             	sub    $0x4,%esp
f0108abf:	68 d0 77 12 f0       	push   $0xf01277d0
f0108ac4:	6a 2e                	push   $0x2e
f0108ac6:	68 bd 77 12 f0       	push   $0xf01277bd
f0108acb:	e8 75 79 ff ff       	call   f0100445 <_panic_into_prompt>

f0108ad0 <kfree>:
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

}

void kfree(void* virtual_address)
{
f0108ad0:	55                   	push   %ebp
f0108ad1:	89 e5                	mov    %esp,%ebp
f0108ad3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("kfree() is not implemented yet...!!");
f0108ad6:	83 ec 04             	sub    $0x4,%esp
f0108ad9:	68 f8 77 12 f0       	push   $0xf01277f8
f0108ade:	6a 38                	push   $0x38
f0108ae0:	68 bd 77 12 f0       	push   $0xf01277bd
f0108ae5:	e8 30 78 ff ff       	call   f010031a <_panic>

f0108aea <kheap_virtual_address>:
	//refer to the project presentation and documentation for details

}

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0108aea:	55                   	push   %ebp
f0108aeb:	89 e5                	mov    %esp,%ebp
f0108aed:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_virtual_address
	// Write your code here, remove the panic and write your code
	panic("kheap_virtual_address() is not implemented yet...!!");
f0108af0:	83 ec 04             	sub    $0x4,%esp
f0108af3:	68 1c 78 12 f0       	push   $0xf012781c
f0108af8:	6a 43                	push   $0x43
f0108afa:	68 bd 77 12 f0       	push   $0xf01277bd
f0108aff:	e8 16 78 ff ff       	call   f010031a <_panic>

f0108b04 <kheap_physical_address>:

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
}

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0108b04:	55                   	push   %ebp
f0108b05:	89 e5                	mov    %esp,%ebp
f0108b07:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_physical_address
	// Write your code here, remove the panic and write your code
	panic("kheap_physical_address() is not implemented yet...!!");
f0108b0a:	83 ec 04             	sub    $0x4,%esp
f0108b0d:	68 50 78 12 f0       	push   $0xf0127850
f0108b12:	6a 4f                	push   $0x4f
f0108b14:	68 bd 77 12 f0       	push   $0xf01277bd
f0108b19:	e8 fc 77 ff ff       	call   f010031a <_panic>

f0108b1e <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f0108b1e:	55                   	push   %ebp
f0108b1f:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2 BONUS2] Kernel Heap Realloc
	// Write your code here, remove the panic and write your code
	return NULL;
f0108b21:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f0108b26:	5d                   	pop    %ebp
f0108b27:	c3                   	ret    

f0108b28 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0108b28:	55                   	push   %ebp
f0108b29:	89 e5                	mov    %esp,%ebp
f0108b2b:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108b2e:	83 ec 04             	sub    $0x4,%esp
f0108b31:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108b34:	50                   	push   %eax
f0108b35:	ff 75 0c             	pushl  0xc(%ebp)
f0108b38:	ff 75 08             	pushl  0x8(%ebp)
f0108b3b:	e8 cd f8 ff ff       	call   f010840d <get_page_table>
f0108b40:	83 c4 10             	add    $0x10,%esp
f0108b43:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108b46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b49:	85 c0                	test   %eax,%eax
f0108b4b:	74 64                	je     f0108bb1 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0108b4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b50:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b53:	c1 ea 0c             	shr    $0xc,%edx
f0108b56:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b5c:	c1 e2 02             	shl    $0x2,%edx
f0108b5f:	01 c2                	add    %eax,%edx
f0108b61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b64:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108b67:	c1 e9 0c             	shr    $0xc,%ecx
f0108b6a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108b70:	c1 e1 02             	shl    $0x2,%ecx
f0108b73:	01 c8                	add    %ecx,%eax
f0108b75:	8b 00                	mov    (%eax),%eax
f0108b77:	0b 45 10             	or     0x10(%ebp),%eax
f0108b7a:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0108b7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b7f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b82:	c1 ea 0c             	shr    $0xc,%edx
f0108b85:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b8b:	c1 e2 02             	shl    $0x2,%edx
f0108b8e:	01 d0                	add    %edx,%eax
f0108b90:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108b93:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108b96:	c1 e9 0c             	shr    $0xc,%ecx
f0108b99:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108b9f:	c1 e1 02             	shl    $0x2,%ecx
f0108ba2:	01 ca                	add    %ecx,%edx
f0108ba4:	8b 12                	mov    (%edx),%edx
f0108ba6:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0108ba9:	f7 d1                	not    %ecx
f0108bab:	21 ca                	and    %ecx,%edx
f0108bad:	89 10                	mov    %edx,(%eax)
f0108baf:	eb 27                	jmp    f0108bd8 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0108bb1:	83 ec 08             	sub    $0x8,%esp
f0108bb4:	ff 75 0c             	pushl  0xc(%ebp)
f0108bb7:	68 88 78 12 f0       	push   $0xf0127888
f0108bbc:	e8 ab 83 ff ff       	call   f0100f6c <cprintf>
f0108bc1:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0108bc4:	83 ec 04             	sub    $0x4,%esp
f0108bc7:	68 b0 78 12 f0       	push   $0xf01278b0
f0108bcc:	6a 1c                	push   $0x1c
f0108bce:	68 24 79 12 f0       	push   $0xf0127924
f0108bd3:	e8 42 77 ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108bd8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108bdb:	83 ec 08             	sub    $0x8,%esp
f0108bde:	50                   	push   %eax
f0108bdf:	6a 00                	push   $0x0
f0108be1:	e8 f1 f1 ff ff       	call   f0107dd7 <tlb_invalidate>
f0108be6:	83 c4 10             	add    $0x10,%esp
}
f0108be9:	90                   	nop
f0108bea:	c9                   	leave  
f0108beb:	c3                   	ret    

f0108bec <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0108bec:	55                   	push   %ebp
f0108bed:	89 e5                	mov    %esp,%ebp
f0108bef:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108bf2:	83 ec 04             	sub    $0x4,%esp
f0108bf5:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108bf8:	50                   	push   %eax
f0108bf9:	ff 75 0c             	pushl  0xc(%ebp)
f0108bfc:	ff 75 08             	pushl  0x8(%ebp)
f0108bff:	e8 09 f8 ff ff       	call   f010840d <get_page_table>
f0108c04:	83 c4 10             	add    $0x10,%esp
f0108c07:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0108c0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c0d:	85 c0                	test   %eax,%eax
f0108c0f:	74 1d                	je     f0108c2e <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0108c11:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c14:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c17:	c1 ea 0c             	shr    $0xc,%edx
f0108c1a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108c20:	c1 e2 02             	shl    $0x2,%edx
f0108c23:	01 d0                	add    %edx,%eax
f0108c25:	8b 00                	mov    (%eax),%eax
f0108c27:	25 ff 0f 00 00       	and    $0xfff,%eax
f0108c2c:	eb 05                	jmp    f0108c33 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0108c2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0108c33:	c9                   	leave  
f0108c34:	c3                   	ret    

f0108c35 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0108c35:	55                   	push   %ebp
f0108c36:	89 e5                	mov    %esp,%ebp
f0108c38:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108c3b:	83 ec 04             	sub    $0x4,%esp
f0108c3e:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108c41:	50                   	push   %eax
f0108c42:	ff 75 0c             	pushl  0xc(%ebp)
f0108c45:	ff 75 08             	pushl  0x8(%ebp)
f0108c48:	e8 c0 f7 ff ff       	call   f010840d <get_page_table>
f0108c4d:	83 c4 10             	add    $0x10,%esp
f0108c50:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108c53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c56:	85 c0                	test   %eax,%eax
f0108c58:	74 46                	je     f0108ca0 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0108c5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c5d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c60:	c1 ea 0c             	shr    $0xc,%edx
f0108c63:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108c69:	c1 e2 02             	shl    $0x2,%edx
f0108c6c:	01 d0                	add    %edx,%eax
f0108c6e:	8b 00                	mov    (%eax),%eax
f0108c70:	83 ec 04             	sub    $0x4,%esp
f0108c73:	50                   	push   %eax
f0108c74:	ff 75 0c             	pushl  0xc(%ebp)
f0108c77:	68 40 79 12 f0       	push   $0xf0127940
f0108c7c:	e8 eb 82 ff ff       	call   f0100f6c <cprintf>
f0108c81:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0108c84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c87:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c8a:	c1 ea 0c             	shr    $0xc,%edx
f0108c8d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108c93:	c1 e2 02             	shl    $0x2,%edx
f0108c96:	01 d0                	add    %edx,%eax
f0108c98:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108c9e:	eb 14                	jmp    f0108cb4 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0108ca0:	83 ec 04             	sub    $0x4,%esp
f0108ca3:	68 68 79 12 f0       	push   $0xf0127968
f0108ca8:	6a 47                	push   $0x47
f0108caa:	68 24 79 12 f0       	push   $0xf0127924
f0108caf:	e8 66 76 ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108cb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108cb7:	83 ec 08             	sub    $0x8,%esp
f0108cba:	50                   	push   %eax
f0108cbb:	6a 00                	push   $0x0
f0108cbd:	e8 15 f1 ff ff       	call   f0107dd7 <tlb_invalidate>
f0108cc2:	83 c4 10             	add    $0x10,%esp
}
f0108cc5:	90                   	nop
f0108cc6:	c9                   	leave  
f0108cc7:	c3                   	ret    

f0108cc8 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0108cc8:	55                   	push   %ebp
f0108cc9:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0108ccb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108cce:	c1 e8 16             	shr    $0x16,%eax
f0108cd1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108cd8:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cdb:	01 d0                	add    %edx,%eax
f0108cdd:	8b 00                	mov    (%eax),%eax
f0108cdf:	83 e0 20             	and    $0x20,%eax
f0108ce2:	85 c0                	test   %eax,%eax
f0108ce4:	0f 95 c0             	setne  %al
f0108ce7:	0f b6 c0             	movzbl %al,%eax
}
f0108cea:	5d                   	pop    %ebp
f0108ceb:	c3                   	ret    

f0108cec <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0108cec:	55                   	push   %ebp
f0108ced:	89 e5                	mov    %esp,%ebp
f0108cef:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0108cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108cf5:	c1 e8 16             	shr    $0x16,%eax
f0108cf8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108cff:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d02:	01 d0                	add    %edx,%eax
f0108d04:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108d07:	c1 ea 16             	shr    $0x16,%edx
f0108d0a:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0108d11:	8b 55 08             	mov    0x8(%ebp),%edx
f0108d14:	01 ca                	add    %ecx,%edx
f0108d16:	8b 12                	mov    (%edx),%edx
f0108d18:	83 e2 df             	and    $0xffffffdf,%edx
f0108d1b:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d20:	83 ec 08             	sub    $0x8,%esp
f0108d23:	50                   	push   %eax
f0108d24:	6a 00                	push   $0x0
f0108d26:	e8 ac f0 ff ff       	call   f0107dd7 <tlb_invalidate>
f0108d2b:	83 c4 10             	add    $0x10,%esp
}
f0108d2e:	90                   	nop
f0108d2f:	c9                   	leave  
f0108d30:	c3                   	ret    

f0108d31 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0108d31:	55                   	push   %ebp
f0108d32:	89 e5                	mov    %esp,%ebp
f0108d34:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0108d37:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d3a:	c1 e8 16             	shr    $0x16,%eax
f0108d3d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108d44:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d47:	01 d0                	add    %edx,%eax
f0108d49:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108d4f:	0f 20 d8             	mov    %cr3,%eax
f0108d52:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108d55:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108d58:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108d5b:	90                   	nop
f0108d5c:	c9                   	leave  
f0108d5d:	c3                   	ret    

f0108d5e <env_page_ws_get_size>:
		}
	}
}
#else
inline uint32 env_page_ws_get_size(struct Env *e)
{
f0108d5e:	55                   	push   %ebp
f0108d5f:	89 e5                	mov    %esp,%ebp
f0108d61:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0108d64:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0108d6b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<e->page_WS_max_size; i++) if(e->ptr_pageWorkingSet[i].empty == 0) counter++;
f0108d72:	eb 22                	jmp    f0108d96 <env_page_ws_get_size+0x38>
f0108d74:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108d77:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0108d7a:	89 d0                	mov    %edx,%eax
f0108d7c:	01 c0                	add    %eax,%eax
f0108d7e:	01 d0                	add    %edx,%eax
f0108d80:	c1 e0 03             	shl    $0x3,%eax
f0108d83:	01 c8                	add    %ecx,%eax
f0108d85:	05 8c 00 00 00       	add    $0x8c,%eax
f0108d8a:	8a 00                	mov    (%eax),%al
f0108d8c:	84 c0                	test   %al,%al
f0108d8e:	75 03                	jne    f0108d93 <env_page_ws_get_size+0x35>
f0108d90:	ff 45 f8             	incl   -0x8(%ebp)
f0108d93:	ff 45 fc             	incl   -0x4(%ebp)
f0108d96:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d99:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108d9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108da2:	39 c2                	cmp    %eax,%edx
f0108da4:	77 ce                	ja     f0108d74 <env_page_ws_get_size+0x16>
	return counter;
f0108da6:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0108da9:	c9                   	leave  
f0108daa:	c3                   	ret    

f0108dab <env_page_ws_invalidate>:

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0108dab:	55                   	push   %ebp
f0108dac:	89 e5                	mov    %esp,%ebp
f0108dae:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0108db1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<e->page_WS_max_size; i++)
f0108db8:	eb 4e                	jmp    f0108e08 <env_page_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->ptr_pageWorkingSet[i].virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0108dba:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108dbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108dc0:	89 d0                	mov    %edx,%eax
f0108dc2:	01 c0                	add    %eax,%eax
f0108dc4:	01 d0                	add    %edx,%eax
f0108dc6:	c1 e0 03             	shl    $0x3,%eax
f0108dc9:	01 c8                	add    %ecx,%eax
f0108dcb:	05 88 00 00 00       	add    $0x88,%eax
f0108dd0:	8b 00                	mov    (%eax),%eax
f0108dd2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108dd8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ddd:	89 c2                	mov    %eax,%edx
f0108ddf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108de2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108de5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108de8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ded:	39 c2                	cmp    %eax,%edx
f0108def:	75 14                	jne    f0108e05 <env_page_ws_invalidate+0x5a>
		{
			env_page_ws_clear_entry(e, i);
f0108df1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108df4:	83 ec 08             	sub    $0x8,%esp
f0108df7:	50                   	push   %eax
f0108df8:	ff 75 08             	pushl  0x8(%ebp)
f0108dfb:	e8 ce 00 00 00       	call   f0108ece <env_page_ws_clear_entry>
f0108e00:	83 c4 10             	add    $0x10,%esp
			break;
f0108e03:	eb 13                	jmp    f0108e18 <env_page_ws_invalidate+0x6d>
}

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<e->page_WS_max_size; i++)
f0108e05:	ff 45 f4             	incl   -0xc(%ebp)
f0108e08:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e0b:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e14:	39 c2                	cmp    %eax,%edx
f0108e16:	77 a2                	ja     f0108dba <env_page_ws_invalidate+0xf>
		{
			env_page_ws_clear_entry(e, i);
			break;
		}
	}
}
f0108e18:	90                   	nop
f0108e19:	c9                   	leave  
f0108e1a:	c3                   	ret    

f0108e1b <env_page_ws_set_entry>:

inline void env_page_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0108e1b:	55                   	push   %ebp
f0108e1c:	89 e5                	mov    %esp,%ebp
f0108e1e:	53                   	push   %ebx
f0108e1f:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < e->page_WS_max_size);
f0108e22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e25:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108e2b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108e2e:	77 19                	ja     f0108e49 <env_page_ws_set_entry+0x2e>
f0108e30:	68 e0 79 12 f0       	push   $0xf01279e0
f0108e35:	68 16 7a 12 f0       	push   $0xf0127a16
f0108e3a:	68 a7 00 00 00       	push   $0xa7
f0108e3f:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0108e44:	e8 d1 74 ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0108e49:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108e50:	76 19                	jbe    f0108e6b <env_page_ws_set_entry+0x50>
f0108e52:	68 4c 7a 12 f0       	push   $0xf0127a4c
f0108e57:	68 16 7a 12 f0       	push   $0xf0127a16
f0108e5c:	68 a8 00 00 00       	push   $0xa8
f0108e61:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0108e66:	e8 af 74 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f0108e6b:	8b 45 10             	mov    0x10(%ebp),%eax
f0108e6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108e71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108e79:	89 c1                	mov    %eax,%ecx
f0108e7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0108e7e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e81:	89 d0                	mov    %edx,%eax
f0108e83:	01 c0                	add    %eax,%eax
f0108e85:	01 d0                	add    %edx,%eax
f0108e87:	c1 e0 03             	shl    $0x3,%eax
f0108e8a:	01 d8                	add    %ebx,%eax
f0108e8c:	05 88 00 00 00       	add    $0x88,%eax
f0108e91:	89 08                	mov    %ecx,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 0;
f0108e93:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108e96:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e99:	89 d0                	mov    %edx,%eax
f0108e9b:	01 c0                	add    %eax,%eax
f0108e9d:	01 d0                	add    %edx,%eax
f0108e9f:	c1 e0 03             	shl    $0x3,%eax
f0108ea2:	01 c8                	add    %ecx,%eax
f0108ea4:	05 8c 00 00 00       	add    $0x8c,%eax
f0108ea9:	c6 00 00             	movb   $0x0,(%eax)

	e->ptr_pageWorkingSet[entry_index].time_stamp = 0x80000000;
f0108eac:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108eaf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108eb2:	89 d0                	mov    %edx,%eax
f0108eb4:	01 c0                	add    %eax,%eax
f0108eb6:	01 d0                	add    %edx,%eax
f0108eb8:	c1 e0 03             	shl    $0x3,%eax
f0108ebb:	01 c8                	add    %ecx,%eax
f0108ebd:	05 90 00 00 00       	add    $0x90,%eax
f0108ec2:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	//e->ptr_pageWorkingSet[entry_index].time_stamp = time;
	return;
f0108ec8:	90                   	nop
}
f0108ec9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ecc:	c9                   	leave  
f0108ecd:	c3                   	ret    

f0108ece <env_page_ws_clear_entry>:

inline void env_page_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0108ece:	55                   	push   %ebp
f0108ecf:	89 e5                	mov    %esp,%ebp
f0108ed1:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108ed4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ed7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108edd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108ee0:	77 19                	ja     f0108efb <env_page_ws_clear_entry+0x2d>
f0108ee2:	68 80 7a 12 f0       	push   $0xf0127a80
f0108ee7:	68 16 7a 12 f0       	push   $0xf0127a16
f0108eec:	68 b3 00 00 00       	push   $0xb3
f0108ef1:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0108ef6:	e8 1f 74 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = 0;
f0108efb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108efe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f01:	89 d0                	mov    %edx,%eax
f0108f03:	01 c0                	add    %eax,%eax
f0108f05:	01 d0                	add    %edx,%eax
f0108f07:	c1 e0 03             	shl    $0x3,%eax
f0108f0a:	01 c8                	add    %ecx,%eax
f0108f0c:	05 88 00 00 00       	add    $0x88,%eax
f0108f11:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 1;
f0108f17:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f1a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f1d:	89 d0                	mov    %edx,%eax
f0108f1f:	01 c0                	add    %eax,%eax
f0108f21:	01 d0                	add    %edx,%eax
f0108f23:	c1 e0 03             	shl    $0x3,%eax
f0108f26:	01 c8                	add    %ecx,%eax
f0108f28:	05 8c 00 00 00       	add    $0x8c,%eax
f0108f2d:	c6 00 01             	movb   $0x1,(%eax)
	e->ptr_pageWorkingSet[entry_index].time_stamp = 0;
f0108f30:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f33:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f36:	89 d0                	mov    %edx,%eax
f0108f38:	01 c0                	add    %eax,%eax
f0108f3a:	01 d0                	add    %edx,%eax
f0108f3c:	c1 e0 03             	shl    $0x3,%eax
f0108f3f:	01 c8                	add    %ecx,%eax
f0108f41:	05 90 00 00 00       	add    $0x90,%eax
f0108f46:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0108f4c:	90                   	nop
f0108f4d:	c9                   	leave  
f0108f4e:	c3                   	ret    

f0108f4f <env_page_ws_get_virtual_address>:

inline uint32 env_page_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0108f4f:	55                   	push   %ebp
f0108f50:	89 e5                	mov    %esp,%ebp
f0108f52:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108f55:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f58:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108f5e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108f61:	77 19                	ja     f0108f7c <env_page_ws_get_virtual_address+0x2d>
f0108f63:	68 80 7a 12 f0       	push   $0xf0127a80
f0108f68:	68 16 7a 12 f0       	push   $0xf0127a16
f0108f6d:	68 bb 00 00 00       	push   $0xbb
f0108f72:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0108f77:	e8 9e 73 ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->ptr_pageWorkingSet[entry_index].virtual_address,PAGE_SIZE);
f0108f7c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f7f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f82:	89 d0                	mov    %edx,%eax
f0108f84:	01 c0                	add    %eax,%eax
f0108f86:	01 d0                	add    %edx,%eax
f0108f88:	c1 e0 03             	shl    $0x3,%eax
f0108f8b:	01 c8                	add    %ecx,%eax
f0108f8d:	05 88 00 00 00       	add    $0x88,%eax
f0108f92:	8b 00                	mov    (%eax),%eax
f0108f94:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f9a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0108f9f:	c9                   	leave  
f0108fa0:	c3                   	ret    

f0108fa1 <env_page_ws_get_time_stamp>:

inline uint32 env_page_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0108fa1:	55                   	push   %ebp
f0108fa2:	89 e5                	mov    %esp,%ebp
f0108fa4:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108fa7:	8b 45 08             	mov    0x8(%ebp),%eax
f0108faa:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108fb0:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108fb3:	77 19                	ja     f0108fce <env_page_ws_get_time_stamp+0x2d>
f0108fb5:	68 80 7a 12 f0       	push   $0xf0127a80
f0108fba:	68 16 7a 12 f0       	push   $0xf0127a16
f0108fbf:	68 c1 00 00 00       	push   $0xc1
f0108fc4:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0108fc9:	e8 4c 73 ff ff       	call   f010031a <_panic>
	return e->ptr_pageWorkingSet[entry_index].time_stamp;
f0108fce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108fd1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108fd4:	89 d0                	mov    %edx,%eax
f0108fd6:	01 c0                	add    %eax,%eax
f0108fd8:	01 d0                	add    %edx,%eax
f0108fda:	c1 e0 03             	shl    $0x3,%eax
f0108fdd:	01 c8                	add    %ecx,%eax
f0108fdf:	05 90 00 00 00       	add    $0x90,%eax
f0108fe4:	8b 00                	mov    (%eax),%eax
}
f0108fe6:	c9                   	leave  
f0108fe7:	c3                   	ret    

f0108fe8 <env_page_ws_is_entry_empty>:

inline uint32 env_page_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0108fe8:	55                   	push   %ebp
f0108fe9:	89 e5                	mov    %esp,%ebp
	return e->ptr_pageWorkingSet[entry_index].empty;
f0108feb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108fee:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108ff1:	89 d0                	mov    %edx,%eax
f0108ff3:	01 c0                	add    %eax,%eax
f0108ff5:	01 d0                	add    %edx,%eax
f0108ff7:	c1 e0 03             	shl    $0x3,%eax
f0108ffa:	01 c8                	add    %ecx,%eax
f0108ffc:	05 8c 00 00 00       	add    $0x8c,%eax
f0109001:	8a 00                	mov    (%eax),%al
f0109003:	0f b6 c0             	movzbl %al,%eax
}
f0109006:	5d                   	pop    %ebp
f0109007:	c3                   	ret    

f0109008 <env_page_ws_print>:

void env_page_ws_print(struct Env *e)
{
f0109008:	55                   	push   %ebp
f0109009:	89 e5                	mov    %esp,%ebp
f010900b:	53                   	push   %ebx
f010900c:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010900f:	83 ec 0c             	sub    $0xc,%esp
f0109012:	6a 02                	push   $0x2
f0109014:	e8 f7 56 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f0109019:	83 c4 10             	add    $0x10,%esp
f010901c:	85 c0                	test   %eax,%eax
f010901e:	0f 84 fe 00 00 00    	je     f0109122 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0109024:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010902b:	83 ec 0c             	sub    $0xc,%esp
f010902e:	68 b8 7a 12 f0       	push   $0xf0127ab8
f0109033:	e8 34 7f ff ff       	call   f0100f6c <cprintf>
f0109038:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010903b:	8b 45 08             	mov    0x8(%ebp),%eax
f010903e:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0109044:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109047:	eb 2c                	jmp    f0109075 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109049:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010904c:	8b 10                	mov    (%eax),%edx
f010904e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109051:	8d 48 01             	lea    0x1(%eax),%ecx
f0109054:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109057:	83 ec 04             	sub    $0x4,%esp
f010905a:	52                   	push   %edx
f010905b:	50                   	push   %eax
f010905c:	68 d2 7a 12 f0       	push   $0xf0127ad2
f0109061:	e8 06 7f ff ff       	call   f0100f6c <cprintf>
f0109066:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109069:	8b 45 08             	mov    0x8(%ebp),%eax
f010906c:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0109072:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109075:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109079:	74 08                	je     f0109083 <env_page_ws_print+0x7b>
f010907b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010907e:	8b 40 10             	mov    0x10(%eax),%eax
f0109081:	eb 05                	jmp    f0109088 <env_page_ws_print+0x80>
f0109083:	b8 00 00 00 00       	mov    $0x0,%eax
f0109088:	8b 55 08             	mov    0x8(%ebp),%edx
f010908b:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f0109091:	8b 45 08             	mov    0x8(%ebp),%eax
f0109094:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f010909a:	85 c0                	test   %eax,%eax
f010909c:	75 ab                	jne    f0109049 <env_page_ws_print+0x41>
f010909e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01090a2:	75 a5                	jne    f0109049 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f01090a4:	83 ec 0c             	sub    $0xc,%esp
f01090a7:	68 da 7a 12 f0       	push   $0xf0127ada
f01090ac:	e8 bb 7e ff ff       	call   f0100f6c <cprintf>
f01090b1:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f01090b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01090b7:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f01090bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01090c0:	eb 2c                	jmp    f01090ee <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f01090c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090c5:	8b 10                	mov    (%eax),%edx
f01090c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090ca:	8d 48 01             	lea    0x1(%eax),%ecx
f01090cd:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f01090d0:	83 ec 04             	sub    $0x4,%esp
f01090d3:	52                   	push   %edx
f01090d4:	50                   	push   %eax
f01090d5:	68 d2 7a 12 f0       	push   $0xf0127ad2
f01090da:	e8 8d 7e ff ff       	call   f0100f6c <cprintf>
f01090df:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f01090e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e5:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01090eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01090ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01090f2:	74 08                	je     f01090fc <env_page_ws_print+0xf4>
f01090f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090f7:	8b 40 10             	mov    0x10(%eax),%eax
f01090fa:	eb 05                	jmp    f0109101 <env_page_ws_print+0xf9>
f01090fc:	b8 00 00 00 00       	mov    $0x0,%eax
f0109101:	8b 55 08             	mov    0x8(%ebp),%edx
f0109104:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f010910a:	8b 45 08             	mov    0x8(%ebp),%eax
f010910d:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0109113:	85 c0                	test   %eax,%eax
f0109115:	75 ab                	jne    f01090c2 <env_page_ws_print+0xba>
f0109117:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010911b:	75 a5                	jne    f01090c2 <env_page_ws_print+0xba>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f010911d:	e9 9f 01 00 00       	jmp    f01092c1 <env_page_ws_print+0x2b9>
		}
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
f0109122:	83 ec 0c             	sub    $0xc,%esp
f0109125:	68 f5 7a 12 f0       	push   $0xf0127af5
f010912a:	e8 3d 7e ff ff       	call   f0100f6c <cprintf>
f010912f:	83 c4 10             	add    $0x10,%esp
		for(i=0; i< (e->page_WS_max_size); i++ )
f0109132:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0109139:	e9 71 01 00 00       	jmp    f01092af <env_page_ws_print+0x2a7>
		{
			if (e->ptr_pageWorkingSet[i].empty)
f010913e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109141:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109144:	89 d0                	mov    %edx,%eax
f0109146:	01 c0                	add    %eax,%eax
f0109148:	01 d0                	add    %edx,%eax
f010914a:	c1 e0 03             	shl    $0x3,%eax
f010914d:	01 c8                	add    %ecx,%eax
f010914f:	05 8c 00 00 00       	add    $0x8c,%eax
f0109154:	8a 00                	mov    (%eax),%al
f0109156:	84 c0                	test   %al,%al
f0109158:	74 43                	je     f010919d <env_page_ws_print+0x195>
			{
				cprintf("EMPTY LOCATION");
f010915a:	83 ec 0c             	sub    $0xc,%esp
f010915d:	68 ff 7a 12 f0       	push   $0xf0127aff
f0109162:	e8 05 7e ff ff       	call   f0100f6c <cprintf>
f0109167:	83 c4 10             	add    $0x10,%esp
				if(i==e->page_last_WS_index )
f010916a:	8b 45 08             	mov    0x8(%ebp),%eax
f010916d:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0109173:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109176:	75 10                	jne    f0109188 <env_page_ws_print+0x180>
				{
					cprintf("		<--");
f0109178:	83 ec 0c             	sub    $0xc,%esp
f010917b:	68 0e 7b 12 f0       	push   $0xf0127b0e
f0109180:	e8 e7 7d ff ff       	call   f0100f6c <cprintf>
f0109185:	83 c4 10             	add    $0x10,%esp
				}
				cprintf("\n");
f0109188:	83 ec 0c             	sub    $0xc,%esp
f010918b:	68 14 7b 12 f0       	push   $0xf0127b14
f0109190:	e8 d7 7d ff ff       	call   f0100f6c <cprintf>
f0109195:	83 c4 10             	add    $0x10,%esp
				continue;
f0109198:	e9 0f 01 00 00       	jmp    f01092ac <env_page_ws_print+0x2a4>
			}
			uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f010919d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01091a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01091a3:	89 d0                	mov    %edx,%eax
f01091a5:	01 c0                	add    %eax,%eax
f01091a7:	01 d0                	add    %edx,%eax
f01091a9:	c1 e0 03             	shl    $0x3,%eax
f01091ac:	01 c8                	add    %ecx,%eax
f01091ae:	05 88 00 00 00       	add    $0x88,%eax
f01091b3:	8b 00                	mov    (%eax),%eax
f01091b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 time_stamp = e->ptr_pageWorkingSet[i].time_stamp;
f01091b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01091bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01091be:	89 d0                	mov    %edx,%eax
f01091c0:	01 c0                	add    %eax,%eax
f01091c2:	01 d0                	add    %edx,%eax
f01091c4:	c1 e0 03             	shl    $0x3,%eax
f01091c7:	01 c8                	add    %ecx,%eax
f01091c9:	05 90 00 00 00       	add    $0x90,%eax
f01091ce:	8b 00                	mov    (%eax),%eax
f01091d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f01091d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d6:	8b 40 64             	mov    0x64(%eax),%eax
f01091d9:	83 ec 08             	sub    $0x8,%esp
f01091dc:	ff 75 e8             	pushl  -0x18(%ebp)
f01091df:	50                   	push   %eax
f01091e0:	e8 07 fa ff ff       	call   f0108bec <pt_get_page_permissions>
f01091e5:	83 c4 10             	add    $0x10,%esp
f01091e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f01091eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091ee:	83 e0 40             	and    $0x40,%eax
f01091f1:	85 c0                	test   %eax,%eax
f01091f3:	0f 95 c0             	setne  %al
f01091f6:	88 45 df             	mov    %al,-0x21(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f01091f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091fc:	83 e0 20             	and    $0x20,%eax
f01091ff:	85 c0                	test   %eax,%eax
f0109201:	0f 95 c0             	setne  %al
f0109204:	88 45 de             	mov    %al,-0x22(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0109207:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010920a:	25 00 02 00 00       	and    $0x200,%eax
f010920f:	85 c0                	test   %eax,%eax
f0109211:	0f 95 c0             	setne  %al
f0109214:	88 45 dd             	mov    %al,-0x23(%ebp)


			cprintf("address @ %d = %x",i, e->ptr_pageWorkingSet[i].virtual_address);
f0109217:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010921a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010921d:	89 d0                	mov    %edx,%eax
f010921f:	01 c0                	add    %eax,%eax
f0109221:	01 d0                	add    %edx,%eax
f0109223:	c1 e0 03             	shl    $0x3,%eax
f0109226:	01 c8                	add    %ecx,%eax
f0109228:	05 88 00 00 00       	add    $0x88,%eax
f010922d:	8b 00                	mov    (%eax),%eax
f010922f:	83 ec 04             	sub    $0x4,%esp
f0109232:	50                   	push   %eax
f0109233:	ff 75 ec             	pushl  -0x14(%ebp)
f0109236:	68 16 7b 12 f0       	push   $0xf0127b16
f010923b:	e8 2c 7d ff ff       	call   f0100f6c <cprintf>
f0109240:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d", isUsed, isModified, isBuffered, time_stamp, e->ptr_pageWorkingSet[i].sweeps_counter) ;
f0109243:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109246:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109249:	89 d0                	mov    %edx,%eax
f010924b:	01 c0                	add    %eax,%eax
f010924d:	01 d0                	add    %edx,%eax
f010924f:	c1 e0 03             	shl    $0x3,%eax
f0109252:	01 c8                	add    %ecx,%eax
f0109254:	05 94 00 00 00       	add    $0x94,%eax
f0109259:	8b 18                	mov    (%eax),%ebx
f010925b:	0f be 4d dd          	movsbl -0x23(%ebp),%ecx
f010925f:	0f be 55 df          	movsbl -0x21(%ebp),%edx
f0109263:	0f be 45 de          	movsbl -0x22(%ebp),%eax
f0109267:	83 ec 08             	sub    $0x8,%esp
f010926a:	53                   	push   %ebx
f010926b:	ff 75 e4             	pushl  -0x1c(%ebp)
f010926e:	51                   	push   %ecx
f010926f:	52                   	push   %edx
f0109270:	50                   	push   %eax
f0109271:	68 28 7b 12 f0       	push   $0xf0127b28
f0109276:	e8 f1 7c ff ff       	call   f0100f6c <cprintf>
f010927b:	83 c4 20             	add    $0x20,%esp

			if(i==e->page_last_WS_index )
f010927e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109281:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0109287:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010928a:	75 10                	jne    f010929c <env_page_ws_print+0x294>
			{
				cprintf(" <--");
f010928c:	83 ec 0c             	sub    $0xc,%esp
f010928f:	68 6f 7b 12 f0       	push   $0xf0127b6f
f0109294:	e8 d3 7c ff ff       	call   f0100f6c <cprintf>
f0109299:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010929c:	83 ec 0c             	sub    $0xc,%esp
f010929f:	68 14 7b 12 f0       	push   $0xf0127b14
f01092a4:	e8 c3 7c ff ff       	call   f0100f6c <cprintf>
f01092a9:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
		for(i=0; i< (e->page_WS_max_size); i++ )
f01092ac:	ff 45 ec             	incl   -0x14(%ebp)
f01092af:	8b 45 08             	mov    0x8(%ebp),%eax
f01092b2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01092b8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01092bb:	0f 87 7d fe ff ff    	ja     f010913e <env_page_ws_print+0x136>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f01092c1:	90                   	nop
f01092c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01092c5:	c9                   	leave  
f01092c6:	c3                   	ret    

f01092c7 <env_table_ws_print>:
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f01092c7:	55                   	push   %ebp
f01092c8:	89 e5                	mov    %esp,%ebp
f01092ca:	53                   	push   %ebx
f01092cb:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f01092ce:	83 ec 0c             	sub    $0xc,%esp
f01092d1:	68 74 7b 12 f0       	push   $0xf0127b74
f01092d6:	e8 91 7c ff ff       	call   f0100f6c <cprintf>
f01092db:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f01092de:	83 ec 0c             	sub    $0xc,%esp
f01092e1:	68 a9 7b 12 f0       	push   $0xf0127ba9
f01092e6:	e8 81 7c ff ff       	call   f0100f6c <cprintf>
f01092eb:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f01092ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01092f5:	e9 16 01 00 00       	jmp    f0109410 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f01092fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109300:	89 d0                	mov    %edx,%eax
f0109302:	01 c0                	add    %eax,%eax
f0109304:	01 d0                	add    %edx,%eax
f0109306:	c1 e0 03             	shl    $0x3,%eax
f0109309:	01 c8                	add    %ecx,%eax
f010930b:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109310:	8a 00                	mov    (%eax),%al
f0109312:	84 c0                	test   %al,%al
f0109314:	74 43                	je     f0109359 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f0109316:	83 ec 0c             	sub    $0xc,%esp
f0109319:	68 ff 7a 12 f0       	push   $0xf0127aff
f010931e:	e8 49 7c ff ff       	call   f0100f6c <cprintf>
f0109323:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f0109326:	8b 45 08             	mov    0x8(%ebp),%eax
f0109329:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010932f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109332:	75 10                	jne    f0109344 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109334:	83 ec 0c             	sub    $0xc,%esp
f0109337:	68 0e 7b 12 f0       	push   $0xf0127b0e
f010933c:	e8 2b 7c ff ff       	call   f0100f6c <cprintf>
f0109341:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109344:	83 ec 0c             	sub    $0xc,%esp
f0109347:	68 14 7b 12 f0       	push   $0xf0127b14
f010934c:	e8 1b 7c ff ff       	call   f0100f6c <cprintf>
f0109351:	83 c4 10             	add    $0x10,%esp
			continue;
f0109354:	e9 b4 00 00 00       	jmp    f010940d <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f0109359:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010935c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010935f:	89 d0                	mov    %edx,%eax
f0109361:	01 c0                	add    %eax,%eax
f0109363:	01 d0                	add    %edx,%eax
f0109365:	c1 e0 03             	shl    $0x3,%eax
f0109368:	01 c8                	add    %ecx,%eax
f010936a:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010936f:	8b 00                	mov    (%eax),%eax
f0109371:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109374:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109377:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010937a:	89 d0                	mov    %edx,%eax
f010937c:	01 c0                	add    %eax,%eax
f010937e:	01 d0                	add    %edx,%eax
f0109380:	c1 e0 03             	shl    $0x3,%eax
f0109383:	01 c8                	add    %ecx,%eax
f0109385:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010938a:	8b 00                	mov    (%eax),%eax
f010938c:	83 ec 04             	sub    $0x4,%esp
f010938f:	50                   	push   %eax
f0109390:	ff 75 f4             	pushl  -0xc(%ebp)
f0109393:	68 b4 7b 12 f0       	push   $0xf0127bb4
f0109398:	e8 cf 7b ff ff       	call   f0100f6c <cprintf>
f010939d:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f01093a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01093a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01093a6:	89 d0                	mov    %edx,%eax
f01093a8:	01 c0                	add    %eax,%eax
f01093aa:	01 d0                	add    %edx,%eax
f01093ac:	c1 e0 03             	shl    $0x3,%eax
f01093af:	01 c8                	add    %ecx,%eax
f01093b1:	05 64 d5 01 00       	add    $0x1d564,%eax
f01093b6:	8b 18                	mov    (%eax),%ebx
f01093b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01093bb:	8b 40 64             	mov    0x64(%eax),%eax
f01093be:	83 ec 08             	sub    $0x8,%esp
f01093c1:	ff 75 f0             	pushl  -0x10(%ebp)
f01093c4:	50                   	push   %eax
f01093c5:	e8 fe f8 ff ff       	call   f0108cc8 <pd_is_table_used>
f01093ca:	83 c4 10             	add    $0x10,%esp
f01093cd:	83 ec 04             	sub    $0x4,%esp
f01093d0:	53                   	push   %ebx
f01093d1:	50                   	push   %eax
f01093d2:	68 cc 7b 12 f0       	push   $0xf0127bcc
f01093d7:	e8 90 7b ff ff       	call   f0100f6c <cprintf>
f01093dc:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f01093df:	8b 45 08             	mov    0x8(%ebp),%eax
f01093e2:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f01093e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01093eb:	75 10                	jne    f01093fd <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f01093ed:	83 ec 0c             	sub    $0xc,%esp
f01093f0:	68 6f 7b 12 f0       	push   $0xf0127b6f
f01093f5:	e8 72 7b ff ff       	call   f0100f6c <cprintf>
f01093fa:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f01093fd:	83 ec 0c             	sub    $0xc,%esp
f0109400:	68 14 7b 12 f0       	push   $0xf0127b14
f0109405:	e8 62 7b ff ff       	call   f0100f6c <cprintf>
f010940a:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010940d:	ff 45 f4             	incl   -0xc(%ebp)
f0109410:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109414:	0f 86 e0 fe ff ff    	jbe    f01092fa <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010941a:	90                   	nop
f010941b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010941e:	c9                   	leave  
f010941f:	c3                   	ret    

f0109420 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f0109420:	55                   	push   %ebp
f0109421:	89 e5                	mov    %esp,%ebp
f0109423:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0109426:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010942d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0109434:	eb 22                	jmp    f0109458 <env_table_ws_get_size+0x38>
f0109436:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109439:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010943c:	89 d0                	mov    %edx,%eax
f010943e:	01 c0                	add    %eax,%eax
f0109440:	01 d0                	add    %edx,%eax
f0109442:	c1 e0 03             	shl    $0x3,%eax
f0109445:	01 c8                	add    %ecx,%eax
f0109447:	05 60 d5 01 00       	add    $0x1d560,%eax
f010944c:	8a 00                	mov    (%eax),%al
f010944e:	84 c0                	test   %al,%al
f0109450:	75 03                	jne    f0109455 <env_table_ws_get_size+0x35>
f0109452:	ff 45 f8             	incl   -0x8(%ebp)
f0109455:	ff 45 fc             	incl   -0x4(%ebp)
f0109458:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010945c:	7e d8                	jle    f0109436 <env_table_ws_get_size+0x16>
	return counter;
f010945e:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0109461:	c9                   	leave  
f0109462:	c3                   	ret    

f0109463 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109463:	55                   	push   %ebp
f0109464:	89 e5                	mov    %esp,%ebp
f0109466:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0109469:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0109470:	eb 4e                	jmp    f01094c0 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109472:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109475:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109478:	89 d0                	mov    %edx,%eax
f010947a:	01 c0                	add    %eax,%eax
f010947c:	01 d0                	add    %edx,%eax
f010947e:	c1 e0 03             	shl    $0x3,%eax
f0109481:	01 c8                	add    %ecx,%eax
f0109483:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109488:	8b 00                	mov    (%eax),%eax
f010948a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010948d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109490:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109495:	89 c2                	mov    %eax,%edx
f0109497:	8b 45 0c             	mov    0xc(%ebp),%eax
f010949a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010949d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094a0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f01094a5:	39 c2                	cmp    %eax,%edx
f01094a7:	75 14                	jne    f01094bd <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f01094a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094ac:	83 ec 08             	sub    $0x8,%esp
f01094af:	50                   	push   %eax
f01094b0:	ff 75 08             	pushl  0x8(%ebp)
f01094b3:	e8 bc 00 00 00       	call   f0109574 <env_table_ws_clear_entry>
f01094b8:	83 c4 10             	add    $0x10,%esp
			break;
f01094bb:	eb 09                	jmp    f01094c6 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f01094bd:	ff 45 f4             	incl   -0xc(%ebp)
f01094c0:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f01094c4:	7e ac                	jle    f0109472 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f01094c6:	90                   	nop
f01094c7:	c9                   	leave  
f01094c8:	c3                   	ret    

f01094c9 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f01094c9:	55                   	push   %ebp
f01094ca:	89 e5                	mov    %esp,%ebp
f01094cc:	53                   	push   %ebx
f01094cd:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01094d0:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01094d4:	76 19                	jbe    f01094ef <env_table_ws_set_entry+0x26>
f01094d6:	68 f0 7b 12 f0       	push   $0xf0127bf0
f01094db:	68 16 7a 12 f0       	push   $0xf0127a16
f01094e0:	68 37 01 00 00       	push   $0x137
f01094e5:	68 2c 7a 12 f0       	push   $0xf0127a2c
f01094ea:	e8 2b 6e ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f01094ef:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01094f6:	76 19                	jbe    f0109511 <env_table_ws_set_entry+0x48>
f01094f8:	68 4c 7a 12 f0       	push   $0xf0127a4c
f01094fd:	68 16 7a 12 f0       	push   $0xf0127a16
f0109502:	68 38 01 00 00       	push   $0x138
f0109507:	68 2c 7a 12 f0       	push   $0xf0127a2c
f010950c:	e8 09 6e ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f0109511:	8b 45 10             	mov    0x10(%ebp),%eax
f0109514:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109517:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010951a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010951f:	89 c1                	mov    %eax,%ecx
f0109521:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109524:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109527:	89 d0                	mov    %edx,%eax
f0109529:	01 c0                	add    %eax,%eax
f010952b:	01 d0                	add    %edx,%eax
f010952d:	c1 e0 03             	shl    $0x3,%eax
f0109530:	01 d8                	add    %ebx,%eax
f0109532:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109537:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f0109539:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010953c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010953f:	89 d0                	mov    %edx,%eax
f0109541:	01 c0                	add    %eax,%eax
f0109543:	01 d0                	add    %edx,%eax
f0109545:	c1 e0 03             	shl    $0x3,%eax
f0109548:	01 c8                	add    %ecx,%eax
f010954a:	05 60 d5 01 00       	add    $0x1d560,%eax
f010954f:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109552:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109555:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109558:	89 d0                	mov    %edx,%eax
f010955a:	01 c0                	add    %eax,%eax
f010955c:	01 d0                	add    %edx,%eax
f010955e:	c1 e0 03             	shl    $0x3,%eax
f0109561:	01 c8                	add    %ecx,%eax
f0109563:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109568:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010956e:	90                   	nop
}
f010956f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109572:	c9                   	leave  
f0109573:	c3                   	ret    

f0109574 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109574:	55                   	push   %ebp
f0109575:	89 e5                	mov    %esp,%ebp
f0109577:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010957a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010957e:	76 19                	jbe    f0109599 <env_table_ws_clear_entry+0x25>
f0109580:	68 f0 7b 12 f0       	push   $0xf0127bf0
f0109585:	68 16 7a 12 f0       	push   $0xf0127a16
f010958a:	68 43 01 00 00       	push   $0x143
f010958f:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0109594:	e8 81 6d ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f0109599:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010959c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010959f:	89 d0                	mov    %edx,%eax
f01095a1:	01 c0                	add    %eax,%eax
f01095a3:	01 d0                	add    %edx,%eax
f01095a5:	c1 e0 03             	shl    $0x3,%eax
f01095a8:	01 c8                	add    %ecx,%eax
f01095aa:	05 5c d5 01 00       	add    $0x1d55c,%eax
f01095af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f01095b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01095b8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01095bb:	89 d0                	mov    %edx,%eax
f01095bd:	01 c0                	add    %eax,%eax
f01095bf:	01 d0                	add    %edx,%eax
f01095c1:	c1 e0 03             	shl    $0x3,%eax
f01095c4:	01 c8                	add    %ecx,%eax
f01095c6:	05 60 d5 01 00       	add    $0x1d560,%eax
f01095cb:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f01095ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01095d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01095d4:	89 d0                	mov    %edx,%eax
f01095d6:	01 c0                	add    %eax,%eax
f01095d8:	01 d0                	add    %edx,%eax
f01095da:	c1 e0 03             	shl    $0x3,%eax
f01095dd:	01 c8                	add    %ecx,%eax
f01095df:	05 64 d5 01 00       	add    $0x1d564,%eax
f01095e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f01095ea:	90                   	nop
f01095eb:	c9                   	leave  
f01095ec:	c3                   	ret    

f01095ed <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f01095ed:	55                   	push   %ebp
f01095ee:	89 e5                	mov    %esp,%ebp
f01095f0:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01095f3:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01095f7:	76 19                	jbe    f0109612 <env_table_ws_get_virtual_address+0x25>
f01095f9:	68 f0 7b 12 f0       	push   $0xf0127bf0
f01095fe:	68 16 7a 12 f0       	push   $0xf0127a16
f0109603:	68 4b 01 00 00       	push   $0x14b
f0109608:	68 2c 7a 12 f0       	push   $0xf0127a2c
f010960d:	e8 08 6d ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0109612:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109615:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109618:	89 d0                	mov    %edx,%eax
f010961a:	01 c0                	add    %eax,%eax
f010961c:	01 d0                	add    %edx,%eax
f010961e:	c1 e0 03             	shl    $0x3,%eax
f0109621:	01 c8                	add    %ecx,%eax
f0109623:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109628:	8b 00                	mov    (%eax),%eax
f010962a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010962d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109630:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0109635:	c9                   	leave  
f0109636:	c3                   	ret    

f0109637 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0109637:	55                   	push   %ebp
f0109638:	89 e5                	mov    %esp,%ebp
f010963a:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010963d:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109641:	76 19                	jbe    f010965c <env_table_ws_get_time_stamp+0x25>
f0109643:	68 f0 7b 12 f0       	push   $0xf0127bf0
f0109648:	68 16 7a 12 f0       	push   $0xf0127a16
f010964d:	68 52 01 00 00       	push   $0x152
f0109652:	68 2c 7a 12 f0       	push   $0xf0127a2c
f0109657:	e8 be 6c ff ff       	call   f010031a <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010965c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010965f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109662:	89 d0                	mov    %edx,%eax
f0109664:	01 c0                	add    %eax,%eax
f0109666:	01 d0                	add    %edx,%eax
f0109668:	c1 e0 03             	shl    $0x3,%eax
f010966b:	01 c8                	add    %ecx,%eax
f010966d:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109672:	8b 00                	mov    (%eax),%eax
}
f0109674:	c9                   	leave  
f0109675:	c3                   	ret    

f0109676 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0109676:	55                   	push   %ebp
f0109677:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f0109679:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010967c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010967f:	89 d0                	mov    %edx,%eax
f0109681:	01 c0                	add    %eax,%eax
f0109683:	01 d0                	add    %edx,%eax
f0109685:	c1 e0 03             	shl    $0x3,%eax
f0109688:	01 c8                	add    %ecx,%eax
f010968a:	05 60 d5 01 00       	add    $0x1d560,%eax
f010968f:	8a 00                	mov    (%eax),%al
f0109691:	0f b6 c0             	movzbl %al,%eax
}
f0109694:	5d                   	pop    %ebp
f0109695:	c3                   	ret    

f0109696 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f0109696:	55                   	push   %ebp
f0109697:	89 e5                	mov    %esp,%ebp
f0109699:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010969c:	83 ec 04             	sub    $0x4,%esp
f010969f:	68 21 7c 12 f0       	push   $0xf0127c21
f01096a4:	68 62 01 00 00       	push   $0x162
f01096a9:	68 2c 7a 12 f0       	push   $0xf0127a2c
f01096ae:	e8 67 6c ff ff       	call   f010031a <_panic>

f01096b3 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f01096b3:	55                   	push   %ebp
f01096b4:	89 e5                	mov    %esp,%ebp
f01096b6:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f01096b9:	83 ec 04             	sub    $0x4,%esp
f01096bc:	68 21 7c 12 f0       	push   $0xf0127c21
f01096c1:	68 67 01 00 00       	push   $0x167
f01096c6:	68 2c 7a 12 f0       	push   $0xf0127a2c
f01096cb:	e8 4a 6c ff ff       	call   f010031a <_panic>

f01096d0 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f01096d0:	55                   	push   %ebp
f01096d1:	89 e5                	mov    %esp,%ebp
f01096d3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f01096d6:	83 ec 04             	sub    $0x4,%esp
f01096d9:	68 34 7c 12 f0       	push   $0xf0127c34
f01096de:	6a 21                	push   $0x21
f01096e0:	68 62 7c 12 f0       	push   $0xf0127c62
f01096e5:	e8 30 6c ff ff       	call   f010031a <_panic>

f01096ea <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f01096ea:	55                   	push   %ebp
f01096eb:	89 e5                	mov    %esp,%ebp
f01096ed:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f01096f0:	83 ec 04             	sub    $0x4,%esp
f01096f3:	68 80 7c 12 f0       	push   $0xf0127c80
f01096f8:	6a 34                	push   $0x34
f01096fa:	68 62 7c 12 f0       	push   $0xf0127c62
f01096ff:	e8 16 6c ff ff       	call   f010031a <_panic>

f0109704 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f0109704:	55                   	push   %ebp
f0109705:	89 e5                	mov    %esp,%ebp
f0109707:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010970a:	83 ec 04             	sub    $0x4,%esp
f010970d:	68 b0 7c 12 f0       	push   $0xf0127cb0
f0109712:	6a 44                	push   $0x44
f0109714:	68 62 7c 12 f0       	push   $0xf0127c62
f0109719:	e8 fc 6b ff ff       	call   f010031a <_panic>

f010971e <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010971e:	55                   	push   %ebp
f010971f:	89 e5                	mov    %esp,%ebp
f0109721:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f0109724:	83 ec 04             	sub    $0x4,%esp
f0109727:	68 dc 7c 12 f0       	push   $0xf0127cdc
f010972c:	6a 52                	push   $0x52
f010972e:	68 62 7c 12 f0       	push   $0xf0127c62
f0109733:	e8 e2 6b ff ff       	call   f010031a <_panic>

f0109738 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f0109738:	55                   	push   %ebp
f0109739:	89 e5                	mov    %esp,%ebp
f010973b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010973e:	83 ec 04             	sub    $0x4,%esp
f0109741:	68 0c 7d 12 f0       	push   $0xf0127d0c
f0109746:	6a 5c                	push   $0x5c
f0109748:	68 62 7c 12 f0       	push   $0xf0127c62
f010974d:	e8 c8 6b ff ff       	call   f010031a <_panic>

f0109752 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109752:	55                   	push   %ebp
f0109753:	89 e5                	mov    %esp,%ebp
f0109755:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f0109758:	83 ec 04             	sub    $0x4,%esp
f010975b:	68 44 7d 12 f0       	push   $0xf0127d44
f0109760:	6a 69                	push   $0x69
f0109762:	68 62 7c 12 f0       	push   $0xf0127c62
f0109767:	e8 ae 6b ff ff       	call   f010031a <_panic>

f010976c <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010976c:	55                   	push   %ebp
f010976d:	89 e5                	mov    %esp,%ebp
f010976f:	83 ec 18             	sub    $0x18,%esp
	 * 		or the break exceed the limit of the dynamic allocator. If sys_sbrk fails, the net effect should
	 * 		be that sys_sbrk returns (void*) -1 and that the segment break and the process heap are unaffected.
	 * 		You might have to undo any operations you have done so far in this case.
	 */

	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f0109772:	e8 f9 0f 00 00       	call   f010a770 <get_cpu_proc>
f0109777:	89 45 f4             	mov    %eax,-0xc(%ebp)

	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f010977a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/

	//[PROJECT'24.MS2] Implement this function

}
f010977f:	c9                   	leave  
f0109780:	c3                   	ret    

f0109781 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109781:	55                   	push   %ebp
f0109782:	89 e5                	mov    %esp,%ebp
f0109784:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f0109787:	e8 01 73 01 00       	call   f0120a8d <inctst>
	return;
f010978c:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] allocate_user_mem
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
}
f010978d:	c9                   	leave  
f010978e:	c3                   	ret    

f010978f <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010978f:	55                   	push   %ebp
f0109790:	89 e5                	mov    %esp,%ebp
f0109792:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f0109795:	e8 f3 72 01 00       	call   f0120a8d <inctst>
	return;
f010979a:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
}
f010979b:	c9                   	leave  
f010979c:	c3                   	ret    

f010979d <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010979d:	55                   	push   %ebp
f010979e:	89 e5                	mov    %esp,%ebp
f01097a0:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f01097a3:	83 ec 04             	sub    $0x4,%esp
f01097a6:	68 7c 7d 12 f0       	push   $0xf0127d7c
f01097ab:	68 bc 00 00 00       	push   $0xbc
f01097b0:	68 62 7c 12 f0       	push   $0xf0127c62
f01097b5:	e8 60 6b ff ff       	call   f010031a <_panic>

f01097ba <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f01097ba:	55                   	push   %ebp
f01097bb:	89 e5                	mov    %esp,%ebp
f01097bd:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f01097c0:	83 ec 04             	sub    $0x4,%esp
f01097c3:	68 bc 7d 12 f0       	push   $0xf0127dbc
f01097c8:	68 c6 00 00 00       	push   $0xc6
f01097cd:	68 62 7c 12 f0       	push   $0xf0127c62
f01097d2:	e8 43 6b ff ff       	call   f010031a <_panic>

f01097d7 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01097d7:	55                   	push   %ebp
f01097d8:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01097da:	8b 45 08             	mov    0x8(%ebp),%eax
f01097dd:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f01097e3:	29 d0                	sub    %edx,%eax
f01097e5:	c1 f8 03             	sar    $0x3,%eax
f01097e8:	89 c2                	mov    %eax,%edx
f01097ea:	89 d0                	mov    %edx,%eax
f01097ec:	c1 e0 02             	shl    $0x2,%eax
f01097ef:	01 d0                	add    %edx,%eax
f01097f1:	c1 e0 02             	shl    $0x2,%eax
f01097f4:	01 d0                	add    %edx,%eax
f01097f6:	c1 e0 02             	shl    $0x2,%eax
f01097f9:	01 d0                	add    %edx,%eax
f01097fb:	89 c1                	mov    %eax,%ecx
f01097fd:	c1 e1 08             	shl    $0x8,%ecx
f0109800:	01 c8                	add    %ecx,%eax
f0109802:	89 c1                	mov    %eax,%ecx
f0109804:	c1 e1 10             	shl    $0x10,%ecx
f0109807:	01 c8                	add    %ecx,%eax
f0109809:	01 c0                	add    %eax,%eax
f010980b:	01 d0                	add    %edx,%eax
}
f010980d:	5d                   	pop    %ebp
f010980e:	c3                   	ret    

f010980f <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010980f:	55                   	push   %ebp
f0109810:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109812:	ff 75 08             	pushl  0x8(%ebp)
f0109815:	e8 bd ff ff ff       	call   f01097d7 <to_frame_number>
f010981a:	83 c4 04             	add    $0x4,%esp
f010981d:	c1 e0 0c             	shl    $0xc,%eax
}
f0109820:	c9                   	leave  
f0109821:	c3                   	ret    

f0109822 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f0109822:	55                   	push   %ebp
f0109823:	89 e5                	mov    %esp,%ebp
f0109825:	56                   	push   %esi
f0109826:	53                   	push   %ebx
f0109827:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010982a:	c7 45 f4 07 00 00 00 	movl   $0x7,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f0109831:	e9 28 02 00 00       	jmp    f0109a5e <env_init+0x23c>
	{
		envs[iEnv].env_status = ENV_FREE;
f0109836:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f010983c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010983f:	89 d0                	mov    %edx,%eax
f0109841:	c1 e0 06             	shl    $0x6,%eax
f0109844:	29 d0                	sub    %edx,%eax
f0109846:	c1 e0 02             	shl    $0x2,%eax
f0109849:	01 d0                	add    %edx,%eax
f010984b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109852:	01 d8                	add    %ebx,%eax
f0109854:	c1 e0 03             	shl    $0x3,%eax
f0109857:	01 d0                	add    %edx,%eax
f0109859:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109860:	29 c2                	sub    %eax,%edx
f0109862:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109869:	89 c2                	mov    %eax,%edx
f010986b:	89 d0                	mov    %edx,%eax
f010986d:	01 c8                	add    %ecx,%eax
f010986f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f0109876:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f010987c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010987f:	89 d0                	mov    %edx,%eax
f0109881:	c1 e0 06             	shl    $0x6,%eax
f0109884:	29 d0                	sub    %edx,%eax
f0109886:	c1 e0 02             	shl    $0x2,%eax
f0109889:	01 d0                	add    %edx,%eax
f010988b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109892:	01 d8                	add    %ebx,%eax
f0109894:	c1 e0 03             	shl    $0x3,%eax
f0109897:	01 d0                	add    %edx,%eax
f0109899:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01098a0:	29 c2                	sub    %eax,%edx
f01098a2:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01098a9:	89 c2                	mov    %eax,%edx
f01098ab:	89 d0                	mov    %edx,%eax
f01098ad:	01 c8                	add    %ecx,%eax
f01098af:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f01098b6:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f01098bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01098bf:	89 d0                	mov    %edx,%eax
f01098c1:	c1 e0 06             	shl    $0x6,%eax
f01098c4:	29 d0                	sub    %edx,%eax
f01098c6:	c1 e0 02             	shl    $0x2,%eax
f01098c9:	01 d0                	add    %edx,%eax
f01098cb:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01098d2:	01 d8                	add    %ebx,%eax
f01098d4:	c1 e0 03             	shl    $0x3,%eax
f01098d7:	01 d0                	add    %edx,%eax
f01098d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01098e0:	29 c2                	sub    %eax,%edx
f01098e2:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01098e9:	89 c2                	mov    %eax,%edx
f01098eb:	89 d0                	mov    %edx,%eax
f01098ed:	01 c8                	add    %ecx,%eax
f01098ef:	85 c0                	test   %eax,%eax
f01098f1:	75 14                	jne    f0109907 <env_init+0xe5>
f01098f3:	83 ec 04             	sub    $0x4,%esp
f01098f6:	68 e8 7d 12 f0       	push   $0xf0127de8
f01098fb:	6a 64                	push   $0x64
f01098fd:	68 0b 7e 12 f0       	push   $0xf0127e0b
f0109902:	e8 13 6a ff ff       	call   f010031a <_panic>
f0109907:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f010990d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109910:	89 d0                	mov    %edx,%eax
f0109912:	c1 e0 06             	shl    $0x6,%eax
f0109915:	29 d0                	sub    %edx,%eax
f0109917:	c1 e0 02             	shl    $0x2,%eax
f010991a:	01 d0                	add    %edx,%eax
f010991c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109923:	01 d8                	add    %ebx,%eax
f0109925:	c1 e0 03             	shl    $0x3,%eax
f0109928:	01 d0                	add    %edx,%eax
f010992a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109931:	29 c2                	sub    %eax,%edx
f0109933:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010993a:	89 c2                	mov    %eax,%edx
f010993c:	89 d0                	mov    %edx,%eax
f010993e:	01 c8                	add    %ecx,%eax
f0109940:	8b 15 b4 03 5a f0    	mov    0xf05a03b4,%edx
f0109946:	89 50 08             	mov    %edx,0x8(%eax)
f0109949:	8b 40 08             	mov    0x8(%eax),%eax
f010994c:	85 c0                	test   %eax,%eax
f010994e:	74 44                	je     f0109994 <env_init+0x172>
f0109950:	8b 0d b4 03 5a f0    	mov    0xf05a03b4,%ecx
f0109956:	8b 1d b0 03 5a f0    	mov    0xf05a03b0,%ebx
f010995c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010995f:	89 d0                	mov    %edx,%eax
f0109961:	c1 e0 06             	shl    $0x6,%eax
f0109964:	29 d0                	sub    %edx,%eax
f0109966:	c1 e0 02             	shl    $0x2,%eax
f0109969:	01 d0                	add    %edx,%eax
f010996b:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
f0109972:	01 f0                	add    %esi,%eax
f0109974:	c1 e0 03             	shl    $0x3,%eax
f0109977:	01 d0                	add    %edx,%eax
f0109979:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109980:	29 c2                	sub    %eax,%edx
f0109982:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109989:	89 c2                	mov    %eax,%edx
f010998b:	89 d0                	mov    %edx,%eax
f010998d:	01 d8                	add    %ebx,%eax
f010998f:	89 41 0c             	mov    %eax,0xc(%ecx)
f0109992:	eb 3e                	jmp    f01099d2 <env_init+0x1b0>
f0109994:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f010999a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010999d:	89 d0                	mov    %edx,%eax
f010999f:	c1 e0 06             	shl    $0x6,%eax
f01099a2:	29 d0                	sub    %edx,%eax
f01099a4:	c1 e0 02             	shl    $0x2,%eax
f01099a7:	01 d0                	add    %edx,%eax
f01099a9:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01099b0:	01 d8                	add    %ebx,%eax
f01099b2:	c1 e0 03             	shl    $0x3,%eax
f01099b5:	01 d0                	add    %edx,%eax
f01099b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01099be:	29 c2                	sub    %eax,%edx
f01099c0:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01099c7:	89 c2                	mov    %eax,%edx
f01099c9:	89 d0                	mov    %edx,%eax
f01099cb:	01 c8                	add    %ecx,%eax
f01099cd:	a3 b8 03 5a f0       	mov    %eax,0xf05a03b8
f01099d2:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f01099d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01099db:	89 d0                	mov    %edx,%eax
f01099dd:	c1 e0 06             	shl    $0x6,%eax
f01099e0:	29 d0                	sub    %edx,%eax
f01099e2:	c1 e0 02             	shl    $0x2,%eax
f01099e5:	01 d0                	add    %edx,%eax
f01099e7:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01099ee:	01 d8                	add    %ebx,%eax
f01099f0:	c1 e0 03             	shl    $0x3,%eax
f01099f3:	01 d0                	add    %edx,%eax
f01099f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01099fc:	29 c2                	sub    %eax,%edx
f01099fe:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109a05:	89 c2                	mov    %eax,%edx
f0109a07:	89 d0                	mov    %edx,%eax
f0109a09:	01 c8                	add    %ecx,%eax
f0109a0b:	a3 b4 03 5a f0       	mov    %eax,0xf05a03b4
f0109a10:	8b 0d b0 03 5a f0    	mov    0xf05a03b0,%ecx
f0109a16:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109a19:	89 d0                	mov    %edx,%eax
f0109a1b:	c1 e0 06             	shl    $0x6,%eax
f0109a1e:	29 d0                	sub    %edx,%eax
f0109a20:	c1 e0 02             	shl    $0x2,%eax
f0109a23:	01 d0                	add    %edx,%eax
f0109a25:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109a2c:	01 d8                	add    %ebx,%eax
f0109a2e:	c1 e0 03             	shl    $0x3,%eax
f0109a31:	01 d0                	add    %edx,%eax
f0109a33:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109a3a:	29 c2                	sub    %eax,%edx
f0109a3c:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109a43:	89 c2                	mov    %eax,%edx
f0109a45:	89 d0                	mov    %edx,%eax
f0109a47:	01 c8                	add    %ecx,%eax
f0109a49:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0109a50:	a1 c0 03 5a f0       	mov    0xf05a03c0,%eax
f0109a55:	40                   	inc    %eax
f0109a56:	a3 c0 03 5a f0       	mov    %eax,0xf05a03c0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f0109a5b:	ff 4d f4             	decl   -0xc(%ebp)
f0109a5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109a62:	0f 89 ce fd ff ff    	jns    f0109836 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f0109a68:	90                   	nop
f0109a69:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109a6c:	5b                   	pop    %ebx
f0109a6d:	5e                   	pop    %esi
f0109a6e:	5d                   	pop    %ebp
f0109a6f:	c3                   	ret    

f0109a70 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f0109a70:	55                   	push   %ebp
f0109a71:	89 e5                	mov    %esp,%ebp
f0109a73:	57                   	push   %edi
f0109a74:	56                   	push   %esi
f0109a75:	53                   	push   %ebx
f0109a76:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f0109a7c:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f0109a83:	83 ec 0c             	sub    $0xc,%esp
f0109a86:	ff 75 08             	pushl  0x8(%ebp)
f0109a89:	e8 c8 24 00 00       	call   f010bf56 <get_user_program_info>
f0109a8e:	83 c4 10             	add    $0x10,%esp
f0109a91:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if(ptr_user_program_info == 0)
f0109a94:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0109a98:	75 0a                	jne    f0109aa4 <env_create+0x34>
	{
		return NULL;
f0109a9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a9f:	e9 2a 0c 00 00       	jmp    f010a6ce <env_create+0xc5e>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f0109aa4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109aa7:	8b 40 08             	mov    0x8(%eax),%eax
f0109aaa:	89 45 b8             	mov    %eax,-0x48(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f0109aad:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f0109ab4:	00 00 00 
	if(allocate_environment(&e) < 0)
f0109ab7:	83 ec 0c             	sub    $0xc,%esp
f0109aba:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f0109ac0:	50                   	push   %eax
f0109ac1:	e8 23 11 00 00       	call   f010abe9 <allocate_environment>
f0109ac6:	83 c4 10             	add    $0x10,%esp
f0109ac9:	85 c0                	test   %eax,%eax
f0109acb:	79 0a                	jns    f0109ad7 <env_create+0x67>
	{
		return NULL;
f0109acd:	b8 00 00 00 00       	mov    $0x0,%eax
f0109ad2:	e9 f7 0b 00 00       	jmp    f010a6ce <env_create+0xc5e>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f0109ad7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109ada:	8b 00                	mov    (%eax),%eax
f0109adc:	83 ec 0c             	sub    $0xc,%esp
f0109adf:	50                   	push   %eax
f0109ae0:	e8 f0 8a 01 00       	call   f01225d5 <strlen>
f0109ae5:	83 c4 10             	add    $0x10,%esp
f0109ae8:	83 f8 3f             	cmp    $0x3f,%eax
f0109aeb:	7f 1d                	jg     f0109b0a <env_create+0x9a>
		strcpy(e->prog_name, ptr_user_program_info->name);
f0109aed:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109af0:	8b 00                	mov    (%eax),%eax
f0109af2:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109af8:	83 c2 20             	add    $0x20,%edx
f0109afb:	83 ec 08             	sub    $0x8,%esp
f0109afe:	50                   	push   %eax
f0109aff:	52                   	push   %edx
f0109b00:	e8 1f 8b 01 00       	call   f0122624 <strcpy>
f0109b05:	83 c4 10             	add    $0x10,%esp
f0109b08:	eb 1d                	jmp    f0109b27 <env_create+0xb7>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f0109b0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109b0d:	8b 00                	mov    (%eax),%eax
f0109b0f:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109b15:	83 c2 20             	add    $0x20,%edx
f0109b18:	83 ec 04             	sub    $0x4,%esp
f0109b1b:	6a 3f                	push   $0x3f
f0109b1d:	50                   	push   %eax
f0109b1e:	52                   	push   %edx
f0109b1f:	e8 2e 8b 01 00       	call   f0122652 <strncpy>
f0109b24:	83 c4 10             	add    $0x10,%esp
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
	}
#else
	{
		int r;
		struct FrameInfo *p = NULL;
f0109b27:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%ebp)
f0109b2e:	00 00 00 

		allocate_frame(&p) ;
f0109b31:	83 ec 0c             	sub    $0xc,%esp
f0109b34:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
f0109b3a:	50                   	push   %eax
f0109b3b:	e8 90 e6 ff ff       	call   f01081d0 <allocate_frame>
f0109b40:	83 c4 10             	add    $0x10,%esp
		p->references = 1;
f0109b43:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109b49:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

		ptr_user_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f0109b4f:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109b55:	83 ec 0c             	sub    $0xc,%esp
f0109b58:	50                   	push   %eax
f0109b59:	e8 b1 fc ff ff       	call   f010980f <to_physical_address>
f0109b5e:	83 c4 10             	add    $0x10,%esp
f0109b61:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0109b64:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109b67:	c1 e8 0c             	shr    $0xc,%eax
f0109b6a:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0109b6d:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0109b72:	39 45 ac             	cmp    %eax,-0x54(%ebp)
f0109b75:	72 17                	jb     f0109b8e <env_create+0x11e>
f0109b77:	ff 75 b0             	pushl  -0x50(%ebp)
f0109b7a:	68 28 7e 12 f0       	push   $0xf0127e28
f0109b7f:	68 9c 00 00 00       	push   $0x9c
f0109b84:	68 0b 7e 12 f0       	push   $0xf0127e0b
f0109b89:	e8 8c 67 ff ff       	call   f010031a <_panic>
f0109b8e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109b91:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109b96:	89 45 a8             	mov    %eax,-0x58(%ebp)
		phys_user_page_directory = to_physical_address(p);
f0109b99:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109b9f:	83 ec 0c             	sub    $0xc,%esp
f0109ba2:	50                   	push   %eax
f0109ba3:	e8 67 fc ff ff       	call   f010980f <to_physical_address>
f0109ba8:	83 c4 10             	add    $0x10,%esp
f0109bab:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f0109bae:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bb4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109bb7:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109bbd:	83 ec 0c             	sub    $0xc,%esp
f0109bc0:	6a 02                	push   $0x2
f0109bc2:	e8 49 4b 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f0109bc7:	83 c4 10             	add    $0x10,%esp
f0109bca:	85 c0                	test   %eax,%eax
f0109bcc:	74 21                	je     f0109bef <env_create+0x17f>
	{
		e->SecondListSize = LRU_second_list_size;
f0109bce:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bd4:	8b 55 10             	mov    0x10(%ebp),%edx
f0109bd7:	89 90 34 da 01 00    	mov    %edx,0x1da34(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f0109bdd:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109be3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109be6:	2b 55 10             	sub    0x10(%ebp),%edx
f0109be9:	89 90 30 da 01 00    	mov    %edx,0x1da30(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f0109bef:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109bf3:	75 12                	jne    f0109c07 <env_create+0x197>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f0109bf5:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bfb:	c7 80 3c da 01 00 0a 	movl   $0xa,0x1da3c(%eax)
f0109c02:	00 00 00 
f0109c05:	eb 0f                	jmp    f0109c16 <env_create+0x1a6>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f0109c07:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c0d:	8b 55 14             	mov    0x14(%ebp),%edx
f0109c10:	89 90 3c da 01 00    	mov    %edx,0x1da3c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f0109c16:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c1c:	83 ec 04             	sub    $0x4,%esp
f0109c1f:	ff 75 a4             	pushl  -0x5c(%ebp)
f0109c22:	ff 75 a8             	pushl  -0x58(%ebp)
f0109c25:	50                   	push   %eax
f0109c26:	e8 76 18 00 00       	call   f010b4a1 <initialize_environment>
f0109c2b:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f0109c2e:	e8 8d d5 ff ff       	call   f01071c0 <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0109c33:	0f 20 d8             	mov    %cr3,%eax
f0109c36:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f0109c39:	8b 45 98             	mov    -0x68(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f0109c3c:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f0109c3f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c45:	8b 40 68             	mov    0x68(%eax),%eax
f0109c48:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0109c4e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0109c54:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f0109c57:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f0109c5e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f0109c65:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c6b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0109c71:	48                   	dec    %eax
f0109c72:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f0109c75:	c7 85 38 ff ff ff ff 	movl   $0xffffffff,-0xc8(%ebp)
f0109c7c:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109c7f:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f0109c85:	83 ec 08             	sub    $0x8,%esp
f0109c88:	ff 75 b8             	pushl  -0x48(%ebp)
f0109c8b:	50                   	push   %eax
f0109c8c:	e8 d7 1f 00 00       	call   f010bc68 <PROGRAM_SEGMENT_FIRST>
f0109c91:	83 c4 0c             	add    $0xc,%esp
f0109c94:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0109c9a:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f0109ca0:	b9 05 00 00 00       	mov    $0x5,%ecx
f0109ca5:	89 c7                	mov    %eax,%edi
f0109ca7:	89 d6                	mov    %edx,%esi
f0109ca9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0109cab:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0109cb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109cb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109cb7:	8b 40 10             	mov    0x10(%eax),%eax
f0109cba:	83 f8 ff             	cmp    $0xffffffff,%eax
f0109cbd:	75 07                	jne    f0109cc6 <env_create+0x256>
f0109cbf:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0109cc6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109cc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109ccc:	e9 24 03 00 00       	jmp    f0109ff5 <env_create+0x585>
		{
			segment_counter++;
f0109cd1:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f0109cd4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0109cdb:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f0109cde:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109ce4:	83 ec 0c             	sub    $0xc,%esp
f0109ce7:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0109ced:	52                   	push   %edx
f0109cee:	ff 75 dc             	pushl  -0x24(%ebp)
f0109cf1:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
f0109cf7:	52                   	push   %edx
f0109cf8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109cfb:	50                   	push   %eax
f0109cfc:	e8 a6 0f 00 00       	call   f010aca7 <program_segment_alloc_map_copy_workingset>
f0109d01:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f0109d04:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0109d0a:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f0109d0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109d10:	8b 00                	mov    (%eax),%eax
f0109d12:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f0109d15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109d18:	8b 40 0c             	mov    0xc(%eax),%eax
f0109d1b:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f0109d1e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109d21:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0109d24:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0109d27:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109d2c:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f0109d2f:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f0109d36:	8b 55 90             	mov    -0x70(%ebp),%edx
f0109d39:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0109d3c:	01 d0                	add    %edx,%eax
f0109d3e:	48                   	dec    %eax
f0109d3f:	89 45 80             	mov    %eax,-0x80(%ebp)
f0109d42:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109d45:	ba 00 00 00 00       	mov    $0x0,%edx
f0109d4a:	f7 75 84             	divl   -0x7c(%ebp)
f0109d4d:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109d50:	29 d0                	sub    %edx,%eax
f0109d52:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f0109d58:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109d5b:	2b 45 88             	sub    -0x78(%ebp),%eax
f0109d5e:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			memset(ptr_temp_page , 0, PAGE_SIZE);
f0109d64:	a1 04 3b 5a f0       	mov    0xf05a3b04,%eax
f0109d69:	83 ec 04             	sub    $0x4,%esp
f0109d6c:	68 00 10 00 00       	push   $0x1000
f0109d71:	6a 00                	push   $0x0
f0109d73:	50                   	push   %eax
f0109d74:	e8 4a 8a 01 00       	call   f01227c3 <memset>
f0109d79:	83 c4 10             	add    $0x10,%esp
			uint8 *src_ptr =  (uint8*) dataSrc_va;
f0109d7c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0109d7f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f0109d82:	8b 15 04 3b 5a f0    	mov    0xf05a3b04,%edx
f0109d88:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0109d8e:	01 d0                	add    %edx,%eax
f0109d90:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109d93:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109d96:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109d99:	eb 13                	jmp    f0109dae <env_create+0x33e>
			{
				*dst_ptr = *src_ptr ;
f0109d9b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109d9e:	8a 10                	mov    (%eax),%dl
f0109da0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109da3:	88 10                	mov    %dl,(%eax)

			memset(ptr_temp_page , 0, PAGE_SIZE);
			uint8 *src_ptr =  (uint8*) dataSrc_va;
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109da5:	ff 45 cc             	incl   -0x34(%ebp)
f0109da8:	ff 45 d4             	incl   -0x2c(%ebp)
f0109dab:	ff 45 d0             	incl   -0x30(%ebp)
f0109dae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109db1:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f0109db7:	72 e2                	jb     f0109d9b <env_create+0x32b>
			{
				*dst_ptr = *src_ptr ;
			}

			if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109db9:	8b 15 04 3b 5a f0    	mov    0xf05a3b04,%edx
f0109dbf:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109dc5:	83 ec 04             	sub    $0x4,%esp
f0109dc8:	52                   	push   %edx
f0109dc9:	ff 75 88             	pushl  -0x78(%ebp)
f0109dcc:	50                   	push   %eax
f0109dcd:	e8 76 a3 ff ff       	call   f0104148 <pf_add_env_page>
f0109dd2:	83 c4 10             	add    $0x10,%esp
f0109dd5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109dd8:	75 17                	jne    f0109df1 <env_create+0x381>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109dda:	83 ec 04             	sub    $0x4,%esp
f0109ddd:	68 58 7e 12 f0       	push   $0xf0127e58
f0109de2:	68 f2 00 00 00       	push   $0xf2
f0109de7:	68 0b 7e 12 f0       	push   $0xf0127e0b
f0109dec:	e8 29 65 ff ff       	call   f010031a <_panic>
			//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");


			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f0109df1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109df4:	8b 50 04             	mov    0x4(%eax),%edx
f0109df7:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109dfa:	01 d0                	add    %edx,%eax
f0109dfc:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0109e02:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0109e08:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109e0d:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f0109e13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109e16:	8b 50 04             	mov    0x4(%eax),%edx
f0109e19:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109e1c:	01 d0                	add    %edx,%eax
f0109e1e:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109e24:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0109e2a:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109e2d:	eb 43                	jmp    f0109e72 <env_create+0x402>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f0109e2f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109e32:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e38:	83 ec 04             	sub    $0x4,%esp
f0109e3b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109e3e:	52                   	push   %edx
f0109e3f:	50                   	push   %eax
f0109e40:	e8 03 a3 ff ff       	call   f0104148 <pf_add_env_page>
f0109e45:	83 c4 10             	add    $0x10,%esp
f0109e48:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109e4b:	75 17                	jne    f0109e64 <env_create+0x3f4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109e4d:	83 ec 04             	sub    $0x4,%esp
f0109e50:	68 58 7e 12 f0       	push   $0xf0127e58
f0109e55:	68 ff 00 00 00       	push   $0xff
f0109e5a:	68 0b 7e 12 f0       	push   $0xf0127e0b
f0109e5f:	e8 b6 64 ff ff       	call   f010031a <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109e64:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109e6b:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f0109e72:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e75:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f0109e7b:	72 b2                	jb     f0109e2f <env_create+0x3bf>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f0109e7d:	a1 04 3b 5a f0       	mov    0xf05a3b04,%eax
f0109e82:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f0109e85:	83 ec 04             	sub    $0x4,%esp
f0109e88:	68 00 10 00 00       	push   $0x1000
f0109e8d:	6a 00                	push   $0x0
f0109e8f:	ff 75 d0             	pushl  -0x30(%ebp)
f0109e92:	e8 2c 89 01 00       	call   f01227c3 <memset>
f0109e97:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109e9a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0109ea0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109ea3:	eb 13                	jmp    f0109eb8 <env_create+0x448>
			{
				*dst_ptr = *src_ptr;
f0109ea5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109ea8:	8a 10                	mov    (%eax),%dl
f0109eaa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109ead:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109eaf:	ff 45 cc             	incl   -0x34(%ebp)
f0109eb2:	ff 45 d4             	incl   -0x2c(%ebp)
f0109eb5:	ff 45 d0             	incl   -0x30(%ebp)
f0109eb8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ebb:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f0109ec1:	72 e2                	jb     f0109ea5 <env_create+0x435>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109ec3:	8b 15 04 3b 5a f0    	mov    0xf05a3b04,%edx
f0109ec9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109ecf:	83 ec 04             	sub    $0x4,%esp
f0109ed2:	52                   	push   %edx
f0109ed3:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f0109ed9:	50                   	push   %eax
f0109eda:	e8 69 a2 ff ff       	call   f0104148 <pf_add_env_page>
f0109edf:	83 c4 10             	add    $0x10,%esp
f0109ee2:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109ee5:	75 17                	jne    f0109efe <env_create+0x48e>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109ee7:	83 ec 04             	sub    $0x4,%esp
f0109eea:	68 58 7e 12 f0       	push   $0xf0127e58
f0109eef:	68 0e 01 00 00       	push   $0x10e
f0109ef4:	68 0b 7e 12 f0       	push   $0xf0127e0b
f0109ef9:	e8 1c 64 ff ff       	call   f010031a <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f0109efe:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f0109f05:	10 00 00 
f0109f08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109f0b:	8b 50 04             	mov    0x4(%eax),%edx
f0109f0e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109f11:	01 c2                	add    %eax,%edx
f0109f13:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f0109f19:	01 d0                	add    %edx,%eax
f0109f1b:	48                   	dec    %eax
f0109f1c:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f0109f22:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109f28:	ba 00 00 00 00       	mov    $0x0,%edx
f0109f2d:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f0109f33:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109f39:	29 d0                	sub    %edx,%eax
f0109f3b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f0109f3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109f41:	8b 50 08             	mov    0x8(%eax),%edx
f0109f44:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109f47:	01 d0                	add    %edx,%eax
f0109f49:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109f4c:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109f52:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0109f59:	eb 41                	jmp    f0109f9c <env_create+0x52c>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f0109f5b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109f61:	83 ec 04             	sub    $0x4,%esp
f0109f64:	6a 01                	push   $0x1
f0109f66:	ff 75 c8             	pushl  -0x38(%ebp)
f0109f69:	50                   	push   %eax
f0109f6a:	e8 ab a0 ff ff       	call   f010401a <pf_add_empty_env_page>
f0109f6f:	83 c4 10             	add    $0x10,%esp
f0109f72:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109f75:	75 17                	jne    f0109f8e <env_create+0x51e>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109f77:	83 ec 04             	sub    $0x4,%esp
f0109f7a:	68 58 7e 12 f0       	push   $0xf0127e58
f0109f7f:	68 1b 01 00 00       	push   $0x11b
f0109f84:	68 0b 7e 12 f0       	push   $0xf0127e0b
f0109f89:	e8 8c 63 ff ff       	call   f010031a <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109f8e:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109f95:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f0109f9c:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f0109fa3:	10 00 00 
f0109fa6:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f0109fac:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109fb2:	01 d0                	add    %edx,%eax
f0109fb4:	48                   	dec    %eax
f0109fb5:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f0109fbb:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109fc1:	ba 00 00 00 00       	mov    $0x0,%edx
f0109fc6:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f0109fcc:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109fd2:	29 d0                	sub    %edx,%eax
f0109fd4:	89 c2                	mov    %eax,%edx
f0109fd6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109fd9:	39 c2                	cmp    %eax,%edx
f0109fdb:	0f 87 7a ff ff ff    	ja     f0109f5b <env_create+0x4eb>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109fe1:	83 ec 08             	sub    $0x8,%esp
f0109fe4:	ff 75 b8             	pushl  -0x48(%ebp)
f0109fe7:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109fea:	e8 6e 1b 00 00       	call   f010bb5d <PROGRAM_SEGMENT_NEXT>
f0109fef:	83 c4 10             	add    $0x10,%esp
f0109ff2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109ff5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109ff9:	0f 85 d2 fc ff ff    	jne    f0109cd1 <env_create+0x261>
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
f0109fff:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		for(;i<(e->page_WS_max_size); i++)
f010a006:	e9 a0 00 00 00       	jmp    f010a0ab <env_create+0x63b>
		{
			if(e->ptr_pageWorkingSet[i].empty == 0)
f010a00b:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a011:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010a014:	89 d0                	mov    %edx,%eax
f010a016:	01 c0                	add    %eax,%eax
f010a018:	01 d0                	add    %edx,%eax
f010a01a:	c1 e0 03             	shl    $0x3,%eax
f010a01d:	01 c8                	add    %ecx,%eax
f010a01f:	05 8c 00 00 00       	add    $0x8c,%eax
f010a024:	8a 00                	mov    (%eax),%al
f010a026:	84 c0                	test   %al,%al
f010a028:	75 7e                	jne    f010a0a8 <env_create+0x638>
			{
				uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f010a02a:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a030:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010a033:	89 d0                	mov    %edx,%eax
f010a035:	01 c0                	add    %eax,%eax
f010a037:	01 d0                	add    %edx,%eax
f010a039:	c1 e0 03             	shl    $0x3,%eax
f010a03c:	01 c8                	add    %ecx,%eax
f010a03e:	05 88 00 00 00       	add    $0x88,%eax
f010a043:	8b 00                	mov    (%eax),%eax
f010a045:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
				uint32* ptr_page_table;

				//Here, page tables of all working set pages should be exist in memory
				//So, get_page_table should return the existing table
				get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010a04b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a051:	8b 40 64             	mov    0x64(%eax),%eax
f010a054:	83 ec 04             	sub    $0x4,%esp
f010a057:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
f010a05d:	52                   	push   %edx
f010a05e:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f010a064:	50                   	push   %eax
f010a065:	e8 a3 e3 ff ff       	call   f010840d <get_page_table>
f010a06a:	83 c4 10             	add    $0x10,%esp
				ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010a06d:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f010a073:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f010a079:	c1 ea 0c             	shr    $0xc,%edx
f010a07c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a082:	c1 e2 02             	shl    $0x2,%edx
f010a085:	01 d0                	add    %edx,%eax
f010a087:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f010a08d:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f010a093:	c1 e9 0c             	shr    $0xc,%ecx
f010a096:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a09c:	c1 e1 02             	shl    $0x2,%ecx
f010a09f:	01 ca                	add    %ecx,%edx
f010a0a1:	8b 12                	mov    (%edx),%edx
f010a0a3:	83 e2 bf             	and    $0xffffffbf,%edx
f010a0a6:	89 10                	mov    %edx,(%eax)
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
		for(;i<(e->page_WS_max_size); i++)
f010a0a8:	ff 45 c4             	incl   -0x3c(%ebp)
f010a0ab:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0b1:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010a0b7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a0ba:	39 c2                	cmp    %eax,%edx
f010a0bc:	0f 87 49 ff ff ff    	ja     f010a00b <env_create+0x59b>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010a0c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010a0c5:	8b 50 08             	mov    0x8(%eax),%edx
f010a0c8:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0ce:	83 ec 08             	sub    $0x8,%esp
f010a0d1:	52                   	push   %edx
f010a0d2:	50                   	push   %eax
f010a0d3:	e8 45 1a 00 00       	call   f010bb1d <set_environment_entry_point>
f010a0d8:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010a0db:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0e1:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010a0e8:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f010a0ef:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010a0f2:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a0f9:	e9 27 05 00 00       	jmp    f010a625 <env_create+0xbb5>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010a0fe:	c7 85 18 ff ff ff 00 	movl   $0x0,-0xe8(%ebp)
f010a105:	00 00 00 
			allocate_frame(&pp);
f010a108:	83 ec 0c             	sub    $0xc,%esp
f010a10b:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010a111:	50                   	push   %eax
f010a112:	e8 b9 e0 ff ff       	call   f01081d0 <allocate_frame>
f010a117:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010a11a:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
f010a120:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a126:	8b 40 64             	mov    0x64(%eax),%eax
f010a129:	6a 06                	push   $0x6
f010a12b:	ff 75 c0             	pushl  -0x40(%ebp)
f010a12e:	52                   	push   %edx
f010a12f:	50                   	push   %eax
f010a130:	e8 af e6 ff ff       	call   f01087e4 <loadtime_map_frame>
f010a135:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010a138:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a13b:	83 ec 04             	sub    $0x4,%esp
f010a13e:	68 00 10 00 00       	push   $0x1000
f010a143:	6a 00                	push   $0x0
f010a145:	50                   	push   %eax
f010a146:	e8 78 86 01 00       	call   f01227c3 <memset>
f010a14b:	83 c4 10             	add    $0x10,%esp
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
					}
				}
#else
				env_page_ws_set_entry(e, e->page_last_WS_index, (uint32) stackVa) ;
f010a14e:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a154:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010a15a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a160:	83 ec 04             	sub    $0x4,%esp
f010a163:	ff 75 c0             	pushl  -0x40(%ebp)
f010a166:	52                   	push   %edx
f010a167:	50                   	push   %eax
f010a168:	e8 ae ec ff ff       	call   f0108e1b <env_page_ws_set_entry>
f010a16d:	83 c4 10             	add    $0x10,%esp
				uint32 lastWSIndex = e->page_last_WS_index ++;
f010a170:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a176:	8b 82 58 d5 01 00    	mov    0x1d558(%edx),%eax
f010a17c:	8d 48 01             	lea    0x1(%eax),%ecx
f010a17f:	89 8a 58 d5 01 00    	mov    %ecx,0x1d558(%edx)
f010a185:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
				e->page_last_WS_index %= (e->page_WS_max_size);
f010a18b:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a191:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a197:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010a19d:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a1a3:	8b 9a 84 00 00 00    	mov    0x84(%edx),%ebx
f010a1a9:	ba 00 00 00 00       	mov    $0x0,%edx
f010a1ae:	f7 f3                	div    %ebx
f010a1b0:	89 d0                	mov    %edx,%eax
f010a1b2:	89 81 58 d5 01 00    	mov    %eax,0x1d558(%ecx)

				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a1b8:	83 ec 0c             	sub    $0xc,%esp
f010a1bb:	6a 02                	push   $0x2
f010a1bd:	e8 4e 45 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f010a1c2:	83 c4 10             	add    $0x10,%esp
f010a1c5:	85 c0                	test   %eax,%eax
f010a1c7:	0f 84 34 04 00 00    	je     f010a601 <env_create+0xb91>
				{
					LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a1cd:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a1d3:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1d9:	89 d0                	mov    %edx,%eax
f010a1db:	01 c0                	add    %eax,%eax
f010a1dd:	01 d0                	add    %edx,%eax
f010a1df:	c1 e0 03             	shl    $0x3,%eax
f010a1e2:	83 e8 80             	sub    $0xffffff80,%eax
f010a1e5:	01 c8                	add    %ecx,%eax
f010a1e7:	83 c0 08             	add    $0x8,%eax
f010a1ea:	85 c0                	test   %eax,%eax
f010a1ec:	75 17                	jne    f010a205 <env_create+0x795>
f010a1ee:	83 ec 04             	sub    $0x4,%esp
f010a1f1:	68 9d 7e 12 f0       	push   $0xf0127e9d
f010a1f6:	68 7a 01 00 00       	push   $0x17a
f010a1fb:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a200:	e8 15 61 ff ff       	call   f010031a <_panic>
f010a205:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a20b:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a211:	89 d0                	mov    %edx,%eax
f010a213:	01 c0                	add    %eax,%eax
f010a215:	01 d0                	add    %edx,%eax
f010a217:	c1 e0 03             	shl    $0x3,%eax
f010a21a:	01 c8                	add    %ecx,%eax
f010a21c:	05 98 00 00 00       	add    $0x98,%eax
f010a221:	8b 00                	mov    (%eax),%eax
f010a223:	85 c0                	test   %eax,%eax
f010a225:	74 41                	je     f010a268 <env_create+0x7f8>
f010a227:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a22d:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a233:	89 d0                	mov    %edx,%eax
f010a235:	01 c0                	add    %eax,%eax
f010a237:	01 d0                	add    %edx,%eax
f010a239:	c1 e0 03             	shl    $0x3,%eax
f010a23c:	01 c8                	add    %ecx,%eax
f010a23e:	05 98 00 00 00       	add    $0x98,%eax
f010a243:	8b 10                	mov    (%eax),%edx
f010a245:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a24b:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a251:	89 c8                	mov    %ecx,%eax
f010a253:	01 c0                	add    %eax,%eax
f010a255:	01 c8                	add    %ecx,%eax
f010a257:	c1 e0 03             	shl    $0x3,%eax
f010a25a:	01 d8                	add    %ebx,%eax
f010a25c:	05 9c 00 00 00       	add    $0x9c,%eax
f010a261:	8b 00                	mov    (%eax),%eax
f010a263:	89 42 14             	mov    %eax,0x14(%edx)
f010a266:	eb 2a                	jmp    f010a292 <env_create+0x822>
f010a268:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a26e:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a274:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a27a:	89 c8                	mov    %ecx,%eax
f010a27c:	01 c0                	add    %eax,%eax
f010a27e:	01 c8                	add    %ecx,%eax
f010a280:	c1 e0 03             	shl    $0x3,%eax
f010a283:	01 d8                	add    %ebx,%eax
f010a285:	05 9c 00 00 00       	add    $0x9c,%eax
f010a28a:	8b 00                	mov    (%eax),%eax
f010a28c:	89 82 4c d5 01 00    	mov    %eax,0x1d54c(%edx)
f010a292:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a298:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a29e:	89 d0                	mov    %edx,%eax
f010a2a0:	01 c0                	add    %eax,%eax
f010a2a2:	01 d0                	add    %edx,%eax
f010a2a4:	c1 e0 03             	shl    $0x3,%eax
f010a2a7:	01 c8                	add    %ecx,%eax
f010a2a9:	05 9c 00 00 00       	add    $0x9c,%eax
f010a2ae:	8b 00                	mov    (%eax),%eax
f010a2b0:	85 c0                	test   %eax,%eax
f010a2b2:	74 41                	je     f010a2f5 <env_create+0x885>
f010a2b4:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a2ba:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a2c0:	89 d0                	mov    %edx,%eax
f010a2c2:	01 c0                	add    %eax,%eax
f010a2c4:	01 d0                	add    %edx,%eax
f010a2c6:	c1 e0 03             	shl    $0x3,%eax
f010a2c9:	01 c8                	add    %ecx,%eax
f010a2cb:	05 9c 00 00 00       	add    $0x9c,%eax
f010a2d0:	8b 10                	mov    (%eax),%edx
f010a2d2:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a2d8:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a2de:	89 c8                	mov    %ecx,%eax
f010a2e0:	01 c0                	add    %eax,%eax
f010a2e2:	01 c8                	add    %ecx,%eax
f010a2e4:	c1 e0 03             	shl    $0x3,%eax
f010a2e7:	01 d8                	add    %ebx,%eax
f010a2e9:	05 98 00 00 00       	add    $0x98,%eax
f010a2ee:	8b 00                	mov    (%eax),%eax
f010a2f0:	89 42 10             	mov    %eax,0x10(%edx)
f010a2f3:	eb 2a                	jmp    f010a31f <env_create+0x8af>
f010a2f5:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a2fb:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a301:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a307:	89 c8                	mov    %ecx,%eax
f010a309:	01 c0                	add    %eax,%eax
f010a30b:	01 c8                	add    %ecx,%eax
f010a30d:	c1 e0 03             	shl    $0x3,%eax
f010a310:	01 d8                	add    %ebx,%eax
f010a312:	05 98 00 00 00       	add    $0x98,%eax
f010a317:	8b 00                	mov    (%eax),%eax
f010a319:	89 82 48 d5 01 00    	mov    %eax,0x1d548(%edx)
f010a31f:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a325:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a32b:	89 d0                	mov    %edx,%eax
f010a32d:	01 c0                	add    %eax,%eax
f010a32f:	01 d0                	add    %edx,%eax
f010a331:	c1 e0 03             	shl    $0x3,%eax
f010a334:	01 c8                	add    %ecx,%eax
f010a336:	05 98 00 00 00       	add    $0x98,%eax
f010a33b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a341:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a347:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a34d:	89 d0                	mov    %edx,%eax
f010a34f:	01 c0                	add    %eax,%eax
f010a351:	01 d0                	add    %edx,%eax
f010a353:	c1 e0 03             	shl    $0x3,%eax
f010a356:	01 c8                	add    %ecx,%eax
f010a358:	05 9c 00 00 00       	add    $0x9c,%eax
f010a35d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a363:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a369:	8b 90 54 d5 01 00    	mov    0x1d554(%eax),%edx
f010a36f:	4a                   	dec    %edx
f010a370:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a376:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a37c:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a382:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a388:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010a38e:	39 c2                	cmp    %eax,%edx
f010a390:	0f 83 38 01 00 00    	jae    f010a4ce <env_create+0xa5e>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a396:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a39c:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a3a2:	89 d0                	mov    %edx,%eax
f010a3a4:	01 c0                	add    %eax,%eax
f010a3a6:	01 d0                	add    %edx,%eax
f010a3a8:	c1 e0 03             	shl    $0x3,%eax
f010a3ab:	83 e8 80             	sub    $0xffffff80,%eax
f010a3ae:	01 c8                	add    %ecx,%eax
f010a3b0:	83 c0 08             	add    $0x8,%eax
f010a3b3:	85 c0                	test   %eax,%eax
f010a3b5:	75 17                	jne    f010a3ce <env_create+0x95e>
f010a3b7:	83 ec 04             	sub    $0x4,%esp
f010a3ba:	68 e8 7d 12 f0       	push   $0xf0127de8
f010a3bf:	68 7f 01 00 00       	push   $0x17f
f010a3c4:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a3c9:	e8 4c 5f ff ff       	call   f010031a <_panic>
f010a3ce:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a3d4:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a3da:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010a3e0:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a3e6:	89 d8                	mov    %ebx,%eax
f010a3e8:	01 c0                	add    %eax,%eax
f010a3ea:	01 d8                	add    %ebx,%eax
f010a3ec:	c1 e0 03             	shl    $0x3,%eax
f010a3ef:	01 d0                	add    %edx,%eax
f010a3f1:	05 98 00 00 00       	add    $0x98,%eax
f010a3f6:	89 08                	mov    %ecx,(%eax)
f010a3f8:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a3fe:	89 c8                	mov    %ecx,%eax
f010a400:	01 c0                	add    %eax,%eax
f010a402:	01 c8                	add    %ecx,%eax
f010a404:	c1 e0 03             	shl    $0x3,%eax
f010a407:	01 d0                	add    %edx,%eax
f010a409:	05 98 00 00 00       	add    $0x98,%eax
f010a40e:	8b 00                	mov    (%eax),%eax
f010a410:	85 c0                	test   %eax,%eax
f010a412:	74 2e                	je     f010a442 <env_create+0x9d2>
f010a414:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a41a:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010a420:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a426:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a42c:	89 c8                	mov    %ecx,%eax
f010a42e:	01 c0                	add    %eax,%eax
f010a430:	01 c8                	add    %ecx,%eax
f010a432:	c1 e0 03             	shl    $0x3,%eax
f010a435:	83 e8 80             	sub    $0xffffff80,%eax
f010a438:	01 d8                	add    %ebx,%eax
f010a43a:	83 c0 08             	add    $0x8,%eax
f010a43d:	89 42 14             	mov    %eax,0x14(%edx)
f010a440:	eb 29                	jmp    f010a46b <env_create+0x9fb>
f010a442:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a448:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a44e:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a454:	89 c8                	mov    %ecx,%eax
f010a456:	01 c0                	add    %eax,%eax
f010a458:	01 c8                	add    %ecx,%eax
f010a45a:	c1 e0 03             	shl    $0x3,%eax
f010a45d:	83 e8 80             	sub    $0xffffff80,%eax
f010a460:	01 d8                	add    %ebx,%eax
f010a462:	83 c0 08             	add    $0x8,%eax
f010a465:	89 82 14 da 01 00    	mov    %eax,0x1da14(%edx)
f010a46b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a471:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a477:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a47d:	89 c8                	mov    %ecx,%eax
f010a47f:	01 c0                	add    %eax,%eax
f010a481:	01 c8                	add    %ecx,%eax
f010a483:	c1 e0 03             	shl    $0x3,%eax
f010a486:	83 e8 80             	sub    $0xffffff80,%eax
f010a489:	01 d8                	add    %ebx,%eax
f010a48b:	83 c0 08             	add    $0x8,%eax
f010a48e:	89 82 10 da 01 00    	mov    %eax,0x1da10(%edx)
f010a494:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a49a:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a4a0:	89 d0                	mov    %edx,%eax
f010a4a2:	01 c0                	add    %eax,%eax
f010a4a4:	01 d0                	add    %edx,%eax
f010a4a6:	c1 e0 03             	shl    $0x3,%eax
f010a4a9:	01 c8                	add    %ecx,%eax
f010a4ab:	05 9c 00 00 00       	add    $0x9c,%eax
f010a4b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a4b6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a4bc:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a4c2:	42                   	inc    %edx
f010a4c3:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010a4c9:	e9 33 01 00 00       	jmp    f010a601 <env_create+0xb91>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a4ce:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a4d4:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a4da:	89 d0                	mov    %edx,%eax
f010a4dc:	01 c0                	add    %eax,%eax
f010a4de:	01 d0                	add    %edx,%eax
f010a4e0:	c1 e0 03             	shl    $0x3,%eax
f010a4e3:	83 e8 80             	sub    $0xffffff80,%eax
f010a4e6:	01 c8                	add    %ecx,%eax
f010a4e8:	83 c0 08             	add    $0x8,%eax
f010a4eb:	85 c0                	test   %eax,%eax
f010a4ed:	75 17                	jne    f010a506 <env_create+0xa96>
f010a4ef:	83 ec 04             	sub    $0x4,%esp
f010a4f2:	68 e8 7d 12 f0       	push   $0xf0127de8
f010a4f7:	68 83 01 00 00       	push   $0x183
f010a4fc:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a501:	e8 14 5e ff ff       	call   f010031a <_panic>
f010a506:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a50c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a512:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010a518:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a51e:	89 d8                	mov    %ebx,%eax
f010a520:	01 c0                	add    %eax,%eax
f010a522:	01 d8                	add    %ebx,%eax
f010a524:	c1 e0 03             	shl    $0x3,%eax
f010a527:	01 d0                	add    %edx,%eax
f010a529:	05 98 00 00 00       	add    $0x98,%eax
f010a52e:	89 08                	mov    %ecx,(%eax)
f010a530:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a536:	89 c8                	mov    %ecx,%eax
f010a538:	01 c0                	add    %eax,%eax
f010a53a:	01 c8                	add    %ecx,%eax
f010a53c:	c1 e0 03             	shl    $0x3,%eax
f010a53f:	01 d0                	add    %edx,%eax
f010a541:	05 98 00 00 00       	add    $0x98,%eax
f010a546:	8b 00                	mov    (%eax),%eax
f010a548:	85 c0                	test   %eax,%eax
f010a54a:	74 2e                	je     f010a57a <env_create+0xb0a>
f010a54c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a552:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010a558:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a55e:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a564:	89 c8                	mov    %ecx,%eax
f010a566:	01 c0                	add    %eax,%eax
f010a568:	01 c8                	add    %ecx,%eax
f010a56a:	c1 e0 03             	shl    $0x3,%eax
f010a56d:	83 e8 80             	sub    $0xffffff80,%eax
f010a570:	01 d8                	add    %ebx,%eax
f010a572:	83 c0 08             	add    $0x8,%eax
f010a575:	89 42 14             	mov    %eax,0x14(%edx)
f010a578:	eb 29                	jmp    f010a5a3 <env_create+0xb33>
f010a57a:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a580:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a586:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a58c:	89 c8                	mov    %ecx,%eax
f010a58e:	01 c0                	add    %eax,%eax
f010a590:	01 c8                	add    %ecx,%eax
f010a592:	c1 e0 03             	shl    $0x3,%eax
f010a595:	83 e8 80             	sub    $0xffffff80,%eax
f010a598:	01 d8                	add    %ebx,%eax
f010a59a:	83 c0 08             	add    $0x8,%eax
f010a59d:	89 82 24 da 01 00    	mov    %eax,0x1da24(%edx)
f010a5a3:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a5a9:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a5af:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a5b5:	89 c8                	mov    %ecx,%eax
f010a5b7:	01 c0                	add    %eax,%eax
f010a5b9:	01 c8                	add    %ecx,%eax
f010a5bb:	c1 e0 03             	shl    $0x3,%eax
f010a5be:	83 e8 80             	sub    $0xffffff80,%eax
f010a5c1:	01 d8                	add    %ebx,%eax
f010a5c3:	83 c0 08             	add    $0x8,%eax
f010a5c6:	89 82 20 da 01 00    	mov    %eax,0x1da20(%edx)
f010a5cc:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a5d2:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a5d8:	89 d0                	mov    %edx,%eax
f010a5da:	01 c0                	add    %eax,%eax
f010a5dc:	01 d0                	add    %edx,%eax
f010a5de:	c1 e0 03             	shl    $0x3,%eax
f010a5e1:	01 c8                	add    %ecx,%eax
f010a5e3:	05 9c 00 00 00       	add    $0x9c,%eax
f010a5e8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a5ee:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a5f4:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f010a5fa:	42                   	inc    %edx
f010a5fb:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010a601:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a607:	83 ec 04             	sub    $0x4,%esp
f010a60a:	6a 01                	push   $0x1
f010a60c:	ff 75 c0             	pushl  -0x40(%ebp)
f010a60f:	50                   	push   %eax
f010a610:	e8 05 9a ff ff       	call   f010401a <pf_add_empty_env_page>
f010a615:	83 c4 10             	add    $0x10,%esp
f010a618:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a61e:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010a625:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a628:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010a62e:	0f 83 ca fa ff ff    	jae    f010a0fe <env_create+0x68e>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a634:	83 ec 0c             	sub    $0xc,%esp
f010a637:	6a 02                	push   $0x2
f010a639:	e8 d2 40 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f010a63e:	83 c4 10             	add    $0x10,%esp
f010a641:	85 c0                	test   %eax,%eax
f010a643:	74 72                	je     f010a6b7 <env_create+0xc47>
		{
			struct WorkingSetElement * elm = NULL;
f010a645:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010a64c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a652:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f010a658:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a65b:	eb 2b                	jmp    f010a688 <env_create+0xc18>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010a65d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010a660:	8b 10                	mov    (%eax),%edx
f010a662:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a668:	8b 40 64             	mov    0x64(%eax),%eax
f010a66b:	6a 01                	push   $0x1
f010a66d:	6a 00                	push   $0x0
f010a66f:	52                   	push   %edx
f010a670:	50                   	push   %eax
f010a671:	e8 b2 e4 ff ff       	call   f0108b28 <pt_set_page_permissions>
f010a676:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010a679:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a67f:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a685:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a688:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a68e:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a692:	74 08                	je     f010a69c <env_create+0xc2c>
f010a694:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010a697:	8b 52 10             	mov    0x10(%edx),%edx
f010a69a:	eb 05                	jmp    f010a6a1 <env_create+0xc31>
f010a69c:	ba 00 00 00 00       	mov    $0x0,%edx
f010a6a1:	89 90 28 da 01 00    	mov    %edx,0x1da28(%eax)
f010a6a7:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a6ad:	85 c0                	test   %eax,%eax
f010a6af:	75 ac                	jne    f010a65d <env_create+0xbed>
f010a6b1:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a6b5:	75 a6                	jne    f010a65d <env_create+0xbed>
f010a6b7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a6ba:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010a6bd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010a6c0:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010a6c3:	e8 4a cb ff ff       	call   f0107212 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010a6c8:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
}
f010a6ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a6d1:	5b                   	pop    %ebx
f010a6d2:	5e                   	pop    %esi
f010a6d3:	5f                   	pop    %edi
f010a6d4:	5d                   	pop    %ebp
f010a6d5:	c3                   	ret    

f010a6d6 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010a6d6:	55                   	push   %ebp
f010a6d7:	89 e5                	mov    %esp,%ebp
f010a6d9:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010a6dc:	83 ec 0c             	sub    $0xc,%esp
f010a6df:	68 00 0e 5a f0       	push   $0xf05a0e00
f010a6e4:	e8 bf 44 00 00       	call   f010eba8 <release_spinlock>
f010a6e9:	83 c4 10             	add    $0x10,%esp

	if (first)
f010a6ec:	a1 60 f9 17 f0       	mov    0xf017f960,%eax
f010a6f1:	85 c0                	test   %eax,%eax
f010a6f3:	74 30                	je     f010a725 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010a6f5:	e8 76 00 00 00       	call   f010a770 <get_cpu_proc>
f010a6fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010a6fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a700:	8b 40 10             	mov    0x10(%eax),%eax
f010a703:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a706:	83 c2 20             	add    $0x20,%edx
f010a709:	83 ec 04             	sub    $0x4,%esp
f010a70c:	50                   	push   %eax
f010a70d:	52                   	push   %edx
f010a70e:	68 bb 7e 12 f0       	push   $0xf0127ebb
f010a713:	e8 54 68 ff ff       	call   f0100f6c <cprintf>
f010a718:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010a71b:	c7 05 60 f9 17 f0 00 	movl   $0x0,0xf017f960
f010a722:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010a725:	90                   	nop
f010a726:	c9                   	leave  
f010a727:	c3                   	ret    

f010a728 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010a728:	55                   	push   %ebp
f010a729:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010a72b:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010a72c:	5d                   	pop    %ebp
f010a72d:	c3                   	ret    

f010a72e <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010a72e:	55                   	push   %ebp
f010a72f:	89 e5                	mov    %esp,%ebp
f010a731:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010a734:	e8 37 00 00 00       	call   f010a770 <get_cpu_proc>
f010a739:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010a73c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a740:	75 19                	jne    f010a75b <env_exit+0x2d>
f010a742:	68 d1 7e 12 f0       	push   $0xf0127ed1
f010a747:	68 e1 7e 12 f0       	push   $0xf0127ee1
f010a74c:	68 ea 01 00 00       	push   $0x1ea
f010a751:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a756:	e8 bf 5b ff ff       	call   f010031a <_panic>
	sched_exit_env(cur_env->env_id);
f010a75b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a75e:	8b 40 10             	mov    0x10(%eax),%eax
f010a761:	83 ec 0c             	sub    $0xc,%esp
f010a764:	50                   	push   %eax
f010a765:	e8 48 b0 ff ff       	call   f01057b2 <sched_exit_env>
f010a76a:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010a76d:	90                   	nop
f010a76e:	c9                   	leave  
f010a76f:	c3                   	ret    

f010a770 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010a770:	55                   	push   %ebp
f010a771:	89 e5                	mov    %esp,%ebp
f010a773:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010a776:	e8 45 ca ff ff       	call   f01071c0 <pushcli>
	c = mycpu();
f010a77b:	e8 7d c9 ff ff       	call   f01070fd <mycpu>
f010a780:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010a783:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a786:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a78c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010a78f:	e8 7e ca ff ff       	call   f0107212 <popcli>
	return p;
f010a794:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a797:	c9                   	leave  
f010a798:	c3                   	ret    

f010a799 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010a799:	55                   	push   %ebp
f010a79a:	89 e5                	mov    %esp,%ebp
f010a79c:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010a79f:	e8 1c ca ff ff       	call   f01071c0 <pushcli>
	c = mycpu();
f010a7a4:	e8 54 c9 ff ff       	call   f01070fd <mycpu>
f010a7a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010a7ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7af:	8b 55 08             	mov    0x8(%ebp),%edx
f010a7b2:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010a7b8:	e8 55 ca ff ff       	call   f0107212 <popcli>
}
f010a7bd:	90                   	nop
f010a7be:	c9                   	leave  
f010a7bf:	c3                   	ret    

f010a7c0 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010a7c0:	55                   	push   %ebp
f010a7c1:	89 e5                	mov    %esp,%ebp
f010a7c3:	53                   	push   %ebx
f010a7c4:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010a7c7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a7cb:	75 16                	jne    f010a7e3 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010a7cd:	e8 9e ff ff ff       	call   f010a770 <get_cpu_proc>
f010a7d2:	89 c2                	mov    %eax,%edx
f010a7d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a7d7:	89 10                	mov    %edx,(%eax)
		return 0;
f010a7d9:	b8 00 00 00 00       	mov    $0x0,%eax
f010a7de:	e9 b6 00 00 00       	jmp    f010a899 <envid2env+0xd9>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010a7e3:	8b 1d b0 03 5a f0    	mov    0xf05a03b0,%ebx
f010a7e9:	83 ec 0c             	sub    $0xc,%esp
f010a7ec:	6a 08                	push   $0x8
f010a7ee:	e8 3a 64 01 00       	call   f0120c2d <nearest_pow2_ceil>
f010a7f3:	83 c4 10             	add    $0x10,%esp
f010a7f6:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a7f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7fc:	21 c2                	and    %eax,%edx
f010a7fe:	89 d0                	mov    %edx,%eax
f010a800:	c1 e0 06             	shl    $0x6,%eax
f010a803:	29 d0                	sub    %edx,%eax
f010a805:	c1 e0 02             	shl    $0x2,%eax
f010a808:	01 d0                	add    %edx,%eax
f010a80a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010a811:	01 c8                	add    %ecx,%eax
f010a813:	c1 e0 03             	shl    $0x3,%eax
f010a816:	01 d0                	add    %edx,%eax
f010a818:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a81f:	29 c2                	sub    %eax,%edx
f010a821:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010a828:	89 c2                	mov    %eax,%edx
f010a82a:	89 d0                	mov    %edx,%eax
f010a82c:	01 d8                	add    %ebx,%eax
f010a82e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010a831:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a834:	8b 40 18             	mov    0x18(%eax),%eax
f010a837:	85 c0                	test   %eax,%eax
f010a839:	74 0b                	je     f010a846 <envid2env+0x86>
f010a83b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a83e:	8b 40 10             	mov    0x10(%eax),%eax
f010a841:	3b 45 08             	cmp    0x8(%ebp),%eax
f010a844:	74 10                	je     f010a856 <envid2env+0x96>
		*env_store = 0;
f010a846:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a849:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a84f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a854:	eb 43                	jmp    f010a899 <envid2env+0xd9>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010a856:	e8 15 ff ff ff       	call   f010a770 <get_cpu_proc>
f010a85b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010a85e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a862:	74 28                	je     f010a88c <envid2env+0xcc>
f010a864:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a867:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010a86a:	74 20                	je     f010a88c <envid2env+0xcc>
f010a86c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a86f:	8b 50 14             	mov    0x14(%eax),%edx
f010a872:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a875:	8b 40 10             	mov    0x10(%eax),%eax
f010a878:	39 c2                	cmp    %eax,%edx
f010a87a:	74 10                	je     f010a88c <envid2env+0xcc>
		*env_store = 0;
f010a87c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a87f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a885:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a88a:	eb 0d                	jmp    f010a899 <envid2env+0xd9>
	}

	*env_store = e;
f010a88c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a88f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a892:	89 10                	mov    %edx,(%eax)
	return 0;
f010a894:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a899:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a89c:	c9                   	leave  
f010a89d:	c3                   	ret    

f010a89e <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010a89e:	55                   	push   %ebp
f010a89f:	89 e5                	mov    %esp,%ebp
f010a8a1:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010a8a4:	83 ec 0c             	sub    $0xc,%esp
f010a8a7:	68 00 0e 5a f0       	push   $0xf05a0e00
f010a8ac:	e8 70 42 00 00       	call   f010eb21 <acquire_spinlock>
f010a8b1:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010a8b4:	e8 b7 fe ff ff       	call   f010a770 <get_cpu_proc>
f010a8b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010a8bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a8c0:	75 19                	jne    f010a8db <yield+0x3d>
f010a8c2:	68 f6 7e 12 f0       	push   $0xf0127ef6
f010a8c7:	68 e1 7e 12 f0       	push   $0xf0127ee1
f010a8cc:	68 49 02 00 00       	push   $0x249
f010a8d1:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a8d6:	e8 3f 5a ff ff       	call   f010031a <_panic>
		p->env_status = ENV_READY;
f010a8db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8de:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010a8e5:	e8 13 00 00 00       	call   f010a8fd <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010a8ea:	83 ec 0c             	sub    $0xc,%esp
f010a8ed:	68 00 0e 5a f0       	push   $0xf05a0e00
f010a8f2:	e8 b1 42 00 00       	call   f010eba8 <release_spinlock>
f010a8f7:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010a8fa:	90                   	nop
f010a8fb:	c9                   	leave  
f010a8fc:	c3                   	ret    

f010a8fd <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010a8fd:	55                   	push   %ebp
f010a8fe:	89 e5                	mov    %esp,%ebp
f010a900:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010a903:	e8 68 fe ff ff       	call   f010a770 <get_cpu_proc>
f010a908:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010a90b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a90f:	75 19                	jne    f010a92a <sched+0x2d>
f010a911:	68 f6 7e 12 f0       	push   $0xf0127ef6
f010a916:	68 e1 7e 12 f0       	push   $0xf0127ee1
f010a91b:	68 5d 02 00 00       	push   $0x25d
f010a920:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a925:	e8 f0 59 ff ff       	call   f010031a <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010a92a:	83 ec 0c             	sub    $0xc,%esp
f010a92d:	68 00 0e 5a f0       	push   $0xf05a0e00
f010a932:	e8 03 44 00 00       	call   f010ed3a <holding_spinlock>
f010a937:	83 c4 10             	add    $0x10,%esp
f010a93a:	85 c0                	test   %eax,%eax
f010a93c:	75 17                	jne    f010a955 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010a93e:	83 ec 04             	sub    $0x4,%esp
f010a941:	68 00 7f 12 f0       	push   $0xf0127f00
f010a946:	68 61 02 00 00       	push   $0x261
f010a94b:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a950:	e8 c5 59 ff ff       	call   f010031a <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010a955:	e8 a3 c7 ff ff       	call   f01070fd <mycpu>
f010a95a:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a960:	83 f8 01             	cmp    $0x1,%eax
f010a963:	74 20                	je     f010a985 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010a965:	e8 93 c7 ff ff       	call   f01070fd <mycpu>
f010a96a:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a970:	50                   	push   %eax
f010a971:	68 42 7f 12 f0       	push   $0xf0127f42
f010a976:	68 64 02 00 00       	push   $0x264
f010a97b:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a980:	e8 95 59 ff ff       	call   f010031a <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010a985:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a988:	8b 40 18             	mov    0x18(%eax),%eax
f010a98b:	83 f8 02             	cmp    $0x2,%eax
f010a98e:	75 17                	jne    f010a9a7 <sched+0xaa>
		panic("sched a running process");
f010a990:	83 ec 04             	sub    $0x4,%esp
f010a993:	68 59 7f 12 f0       	push   $0xf0127f59
f010a998:	68 67 02 00 00       	push   $0x267
f010a99d:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a9a2:	e8 73 59 ff ff       	call   f010031a <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010a9a7:	9c                   	pushf  
f010a9a8:	58                   	pop    %eax
f010a9a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010a9ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010a9af:	25 00 02 00 00       	and    $0x200,%eax
f010a9b4:	85 c0                	test   %eax,%eax
f010a9b6:	74 17                	je     f010a9cf <sched+0xd2>
		panic("sched is interruptible!");
f010a9b8:	83 ec 04             	sub    $0x4,%esp
f010a9bb:	68 71 7f 12 f0       	push   $0xf0127f71
f010a9c0:	68 69 02 00 00       	push   $0x269
f010a9c5:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010a9ca:	e8 4b 59 ff ff       	call   f010031a <_panic>
	intena = mycpu()->intena;
f010a9cf:	e8 29 c7 ff ff       	call   f01070fd <mycpu>
f010a9d4:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010a9da:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010a9dd:	e8 1b c7 ff ff       	call   f01070fd <mycpu>
f010a9e2:	8b 40 04             	mov    0x4(%eax),%eax
f010a9e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a9e8:	83 c2 04             	add    $0x4,%edx
f010a9eb:	83 ec 08             	sub    $0x8,%esp
f010a9ee:	50                   	push   %eax
f010a9ef:	52                   	push   %edx
f010a9f0:	e8 4a a1 ff ff       	call   f0104b3f <context_switch>
f010a9f5:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010a9f8:	e8 00 c7 ff ff       	call   f01070fd <mycpu>
f010a9fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010aa00:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010aa06:	90                   	nop
f010aa07:	c9                   	leave  
f010aa08:	c3                   	ret    

f010aa09 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010aa09:	55                   	push   %ebp
f010aa0a:	89 e5                	mov    %esp,%ebp
f010aa0c:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010aa0f:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f010aa14:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010aa17:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010aa1a:	0f 22 d8             	mov    %eax,%cr3
}
f010aa1d:	90                   	nop
f010aa1e:	c9                   	leave  
f010aa1f:	c3                   	ret    

f010aa20 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010aa20:	55                   	push   %ebp
f010aa21:	89 e5                	mov    %esp,%ebp
f010aa23:	53                   	push   %ebx
f010aa24:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010aa27:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aa2b:	75 17                	jne    f010aa44 <switchuvm+0x24>
		panic("switchuvm: no process");
f010aa2d:	83 ec 04             	sub    $0x4,%esp
f010aa30:	68 89 7f 12 f0       	push   $0xf0127f89
f010aa35:	68 7e 02 00 00       	push   $0x27e
f010aa3a:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010aa3f:	e8 d6 58 ff ff       	call   f010031a <_panic>
	if(proc->kstack == 0)
f010aa44:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa47:	8b 40 70             	mov    0x70(%eax),%eax
f010aa4a:	85 c0                	test   %eax,%eax
f010aa4c:	75 17                	jne    f010aa65 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010aa4e:	83 ec 04             	sub    $0x4,%esp
f010aa51:	68 9f 7f 12 f0       	push   $0xf0127f9f
f010aa56:	68 80 02 00 00       	push   $0x280
f010aa5b:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010aa60:	e8 b5 58 ff ff       	call   f010031a <_panic>
	if(proc->env_page_directory == 0)
f010aa65:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa68:	8b 40 64             	mov    0x64(%eax),%eax
f010aa6b:	85 c0                	test   %eax,%eax
f010aa6d:	75 17                	jne    f010aa86 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010aa6f:	83 ec 04             	sub    $0x4,%esp
f010aa72:	68 b4 7f 12 f0       	push   $0xf0127fb4
f010aa77:	68 82 02 00 00       	push   $0x282
f010aa7c:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010aa81:	e8 94 58 ff ff       	call   f010031a <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010aa86:	e8 35 c7 ff ff       	call   f01071c0 <pushcli>
	struct cpu* c = mycpu();
f010aa8b:	e8 6d c6 ff ff       	call   f01070fd <mycpu>
f010aa90:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010aa93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa96:	8b 55 08             	mov    0x8(%ebp),%edx
f010aa99:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010aa9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaa2:	83 c0 0c             	add    $0xc,%eax
f010aaa5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aaa8:	83 c2 0c             	add    $0xc,%edx
f010aaab:	c1 ea 10             	shr    $0x10,%edx
f010aaae:	88 d3                	mov    %dl,%bl
f010aab0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aab3:	83 c2 0c             	add    $0xc,%edx
f010aab6:	c1 ea 18             	shr    $0x18,%edx
f010aab9:	88 d1                	mov    %dl,%cl
f010aabb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aabe:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010aac5:	68 00 
f010aac7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aaca:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010aad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aad4:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010aada:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aadd:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aae3:	83 e2 f0             	and    $0xfffffff0,%edx
f010aae6:	83 ca 09             	or     $0x9,%edx
f010aae9:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010aaef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaf2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aaf8:	83 ca 10             	or     $0x10,%edx
f010aafb:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ab01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab04:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ab0a:	83 e2 9f             	and    $0xffffff9f,%edx
f010ab0d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ab13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab16:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ab1c:	83 ca 80             	or     $0xffffff80,%edx
f010ab1f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ab25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab28:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab2e:	83 e2 f0             	and    $0xfffffff0,%edx
f010ab31:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab3a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab40:	83 e2 ef             	and    $0xffffffef,%edx
f010ab43:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab4c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab52:	83 e2 df             	and    $0xffffffdf,%edx
f010ab55:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab5e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab64:	83 ca 40             	or     $0x40,%edx
f010ab67:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab70:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab76:	83 e2 7f             	and    $0x7f,%edx
f010ab79:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab82:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010ab88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab8b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ab91:	83 e2 ef             	and    $0xffffffef,%edx
f010ab94:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010ab9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab9d:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010aba3:	8b 40 70             	mov    0x70(%eax),%eax
f010aba6:	05 00 80 00 00       	add    $0x8000,%eax
f010abab:	89 c2                	mov    %eax,%edx
f010abad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abb0:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010abb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abb6:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010abbc:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010abc2:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010abc6:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010abc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abcc:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010abd2:	8b 40 68             	mov    0x68(%eax),%eax
f010abd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010abd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010abdb:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010abde:	e8 2f c6 ff ff       	call   f0107212 <popcli>
}
f010abe3:	90                   	nop
f010abe4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010abe7:	c9                   	leave  
f010abe8:	c3                   	ret    

f010abe9 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010abe9:	55                   	push   %ebp
f010abea:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010abec:	8b 15 b4 03 5a f0    	mov    0xf05a03b4,%edx
f010abf2:	8b 45 08             	mov    0x8(%ebp),%eax
f010abf5:	89 10                	mov    %edx,(%eax)
f010abf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010abfa:	8b 00                	mov    (%eax),%eax
f010abfc:	85 c0                	test   %eax,%eax
f010abfe:	75 07                	jne    f010ac07 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010ac00:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010ac05:	eb 11                	jmp    f010ac18 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010ac07:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac0a:	8b 00                	mov    (%eax),%eax
f010ac0c:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010ac13:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ac18:	5d                   	pop    %ebp
f010ac19:	c3                   	ret    

f010ac1a <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010ac1a:	55                   	push   %ebp
f010ac1b:	89 e5                	mov    %esp,%ebp
f010ac1d:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010ac20:	83 ec 04             	sub    $0x4,%esp
f010ac23:	68 6c da 01 00       	push   $0x1da6c
f010ac28:	6a 00                	push   $0x0
f010ac2a:	ff 75 08             	pushl  0x8(%ebp)
f010ac2d:	e8 91 7b 01 00       	call   f01227c3 <memset>
f010ac32:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010ac35:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac38:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010ac3f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ac43:	75 17                	jne    f010ac5c <free_environment+0x42>
f010ac45:	83 ec 04             	sub    $0x4,%esp
f010ac48:	68 e8 7d 12 f0       	push   $0xf0127de8
f010ac4d:	68 bd 02 00 00       	push   $0x2bd
f010ac52:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010ac57:	e8 be 56 ff ff       	call   f010031a <_panic>
f010ac5c:	8b 15 b4 03 5a f0    	mov    0xf05a03b4,%edx
f010ac62:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac65:	89 50 08             	mov    %edx,0x8(%eax)
f010ac68:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac6b:	8b 40 08             	mov    0x8(%eax),%eax
f010ac6e:	85 c0                	test   %eax,%eax
f010ac70:	74 0d                	je     f010ac7f <free_environment+0x65>
f010ac72:	a1 b4 03 5a f0       	mov    0xf05a03b4,%eax
f010ac77:	8b 55 08             	mov    0x8(%ebp),%edx
f010ac7a:	89 50 0c             	mov    %edx,0xc(%eax)
f010ac7d:	eb 08                	jmp    f010ac87 <free_environment+0x6d>
f010ac7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac82:	a3 b8 03 5a f0       	mov    %eax,0xf05a03b8
f010ac87:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac8a:	a3 b4 03 5a f0       	mov    %eax,0xf05a03b4
f010ac8f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac92:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ac99:	a1 c0 03 5a f0       	mov    0xf05a03c0,%eax
f010ac9e:	40                   	inc    %eax
f010ac9f:	a3 c0 03 5a f0       	mov    %eax,0xf05a03c0
}
f010aca4:	90                   	nop
f010aca5:	c9                   	leave  
f010aca6:	c3                   	ret    

f010aca7 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010aca7:	55                   	push   %ebp
f010aca8:	89 e5                	mov    %esp,%ebp
f010acaa:	53                   	push   %ebx
f010acab:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010acae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acb1:	8b 40 0c             	mov    0xc(%eax),%eax
f010acb4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010acb7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acba:	8b 40 08             	mov    0x8(%eax),%eax
f010acbd:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010acc0:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010acc7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010acca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010accd:	01 c2                	add    %eax,%edx
f010accf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010acd2:	01 d0                	add    %edx,%eax
f010acd4:	48                   	dec    %eax
f010acd5:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010acd8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010acdb:	ba 00 00 00 00       	mov    $0x0,%edx
f010ace0:	f7 75 dc             	divl   -0x24(%ebp)
f010ace3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ace6:	29 d0                	sub    %edx,%eax
f010ace8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010aceb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010acee:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010acf1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010acf4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010acf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010acfc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010ad03:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)

	*allocated_pages = 0;
f010ad0a:	8b 45 10             	mov    0x10(%ebp),%eax
f010ad0d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010ad13:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010ad1a:	0f 85 35 06 00 00    	jne    f010b355 <program_segment_alloc_map_copy_workingset+0x6ae>
f010ad20:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad23:	83 c0 20             	add    $0x20,%eax
f010ad26:	83 ec 08             	sub    $0x8,%esp
f010ad29:	68 c8 7f 12 f0       	push   $0xf0127fc8
f010ad2e:	50                   	push   %eax
f010ad2f:	e8 ad 79 01 00       	call   f01226e1 <strcmp>
f010ad34:	83 c4 10             	add    $0x10,%esp
f010ad37:	85 c0                	test   %eax,%eax
f010ad39:	0f 84 16 06 00 00    	je     f010b355 <program_segment_alloc_map_copy_workingset+0x6ae>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010ad3f:	8b 45 14             	mov    0x14(%ebp),%eax
f010ad42:	83 f8 06             	cmp    $0x6,%eax
f010ad45:	76 05                	jbe    f010ad4c <program_segment_alloc_map_copy_workingset+0xa5>
f010ad47:	b8 06 00 00 00       	mov    $0x6,%eax
f010ad4c:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010ad4f:	e9 01 06 00 00       	jmp    f010b355 <program_segment_alloc_map_copy_workingset+0x6ae>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010ad54:	83 ec 0c             	sub    $0xc,%esp
f010ad57:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010ad5a:	50                   	push   %eax
f010ad5b:	e8 70 d4 ff ff       	call   f01081d0 <allocate_frame>
f010ad60:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010ad63:	8b 55 c0             	mov    -0x40(%ebp),%edx
f010ad66:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad69:	8b 40 64             	mov    0x64(%eax),%eax
f010ad6c:	6a 06                	push   $0x6
f010ad6e:	ff 75 f4             	pushl  -0xc(%ebp)
f010ad71:	52                   	push   %edx
f010ad72:	50                   	push   %eax
f010ad73:	e8 6c da ff ff       	call   f01087e4 <loadtime_map_frame>
f010ad78:	83 c4 10             	add    $0x10,%esp
		wse->time_stamp = 0;
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);

#else
		LOG_STATMENT(cprintf("Updating working set entry # %d",e->page_last_WS_index));
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
f010ad7b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad7e:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad84:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad87:	89 d0                	mov    %edx,%eax
f010ad89:	01 c0                	add    %eax,%eax
f010ad8b:	01 d0                	add    %edx,%eax
f010ad8d:	c1 e0 03             	shl    $0x3,%eax
f010ad90:	01 c8                	add    %ecx,%eax
f010ad92:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010ad98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad9b:	89 02                	mov    %eax,(%edx)
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
f010ad9d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ada0:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ada6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ada9:	89 d0                	mov    %edx,%eax
f010adab:	01 c0                	add    %eax,%eax
f010adad:	01 d0                	add    %edx,%eax
f010adaf:	c1 e0 03             	shl    $0x3,%eax
f010adb2:	01 c8                	add    %ecx,%eax
f010adb4:	05 8c 00 00 00       	add    $0x8c,%eax
f010adb9:	c6 00 00             	movb   $0x0,(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
f010adbc:	8b 45 08             	mov    0x8(%ebp),%eax
f010adbf:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010adc5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010adc8:	89 d0                	mov    %edx,%eax
f010adca:	01 c0                	add    %eax,%eax
f010adcc:	01 d0                	add    %edx,%eax
f010adce:	c1 e0 03             	shl    $0x3,%eax
f010add1:	01 c8                	add    %ecx,%eax
f010add3:	05 90 00 00 00       	add    $0x90,%eax
f010add8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010adde:	83 ec 0c             	sub    $0xc,%esp
f010ade1:	6a 02                	push   $0x2
f010ade3:	e8 28 39 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f010ade8:	83 c4 10             	add    $0x10,%esp
f010adeb:	85 c0                	test   %eax,%eax
f010aded:	0f 84 2c 04 00 00    	je     f010b21f <program_segment_alloc_map_copy_workingset+0x578>
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
			}
#else

			LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010adf3:	8b 45 08             	mov    0x8(%ebp),%eax
f010adf6:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010adfc:	89 d0                	mov    %edx,%eax
f010adfe:	01 c0                	add    %eax,%eax
f010ae00:	01 d0                	add    %edx,%eax
f010ae02:	c1 e0 03             	shl    $0x3,%eax
f010ae05:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ae0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae0e:	01 d0                	add    %edx,%eax
f010ae10:	83 c0 08             	add    $0x8,%eax
f010ae13:	85 c0                	test   %eax,%eax
f010ae15:	75 17                	jne    f010ae2e <program_segment_alloc_map_copy_workingset+0x187>
f010ae17:	83 ec 04             	sub    $0x4,%esp
f010ae1a:	68 9d 7e 12 f0       	push   $0xf0127e9d
f010ae1f:	68 00 03 00 00       	push   $0x300
f010ae24:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010ae29:	e8 ec 54 ff ff       	call   f010031a <_panic>
f010ae2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae31:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae37:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae3a:	89 d0                	mov    %edx,%eax
f010ae3c:	01 c0                	add    %eax,%eax
f010ae3e:	01 d0                	add    %edx,%eax
f010ae40:	c1 e0 03             	shl    $0x3,%eax
f010ae43:	01 c8                	add    %ecx,%eax
f010ae45:	05 98 00 00 00       	add    $0x98,%eax
f010ae4a:	8b 00                	mov    (%eax),%eax
f010ae4c:	85 c0                	test   %eax,%eax
f010ae4e:	74 41                	je     f010ae91 <program_segment_alloc_map_copy_workingset+0x1ea>
f010ae50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae53:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae59:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae5c:	89 d0                	mov    %edx,%eax
f010ae5e:	01 c0                	add    %eax,%eax
f010ae60:	01 d0                	add    %edx,%eax
f010ae62:	c1 e0 03             	shl    $0x3,%eax
f010ae65:	01 c8                	add    %ecx,%eax
f010ae67:	05 98 00 00 00       	add    $0x98,%eax
f010ae6c:	8b 10                	mov    (%eax),%edx
f010ae6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae71:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ae77:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ae7a:	89 c8                	mov    %ecx,%eax
f010ae7c:	01 c0                	add    %eax,%eax
f010ae7e:	01 c8                	add    %ecx,%eax
f010ae80:	c1 e0 03             	shl    $0x3,%eax
f010ae83:	01 d8                	add    %ebx,%eax
f010ae85:	05 9c 00 00 00       	add    $0x9c,%eax
f010ae8a:	8b 00                	mov    (%eax),%eax
f010ae8c:	89 42 14             	mov    %eax,0x14(%edx)
f010ae8f:	eb 27                	jmp    f010aeb8 <program_segment_alloc_map_copy_workingset+0x211>
f010ae91:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae94:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae9d:	89 d0                	mov    %edx,%eax
f010ae9f:	01 c0                	add    %eax,%eax
f010aea1:	01 d0                	add    %edx,%eax
f010aea3:	c1 e0 03             	shl    $0x3,%eax
f010aea6:	01 c8                	add    %ecx,%eax
f010aea8:	05 9c 00 00 00       	add    $0x9c,%eax
f010aead:	8b 10                	mov    (%eax),%edx
f010aeaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeb2:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010aeb8:	8b 45 08             	mov    0x8(%ebp),%eax
f010aebb:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aec1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aec4:	89 d0                	mov    %edx,%eax
f010aec6:	01 c0                	add    %eax,%eax
f010aec8:	01 d0                	add    %edx,%eax
f010aeca:	c1 e0 03             	shl    $0x3,%eax
f010aecd:	01 c8                	add    %ecx,%eax
f010aecf:	05 9c 00 00 00       	add    $0x9c,%eax
f010aed4:	8b 00                	mov    (%eax),%eax
f010aed6:	85 c0                	test   %eax,%eax
f010aed8:	74 41                	je     f010af1b <program_segment_alloc_map_copy_workingset+0x274>
f010aeda:	8b 45 08             	mov    0x8(%ebp),%eax
f010aedd:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aee3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aee6:	89 d0                	mov    %edx,%eax
f010aee8:	01 c0                	add    %eax,%eax
f010aeea:	01 d0                	add    %edx,%eax
f010aeec:	c1 e0 03             	shl    $0x3,%eax
f010aeef:	01 c8                	add    %ecx,%eax
f010aef1:	05 9c 00 00 00       	add    $0x9c,%eax
f010aef6:	8b 10                	mov    (%eax),%edx
f010aef8:	8b 45 08             	mov    0x8(%ebp),%eax
f010aefb:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010af01:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010af04:	89 c8                	mov    %ecx,%eax
f010af06:	01 c0                	add    %eax,%eax
f010af08:	01 c8                	add    %ecx,%eax
f010af0a:	c1 e0 03             	shl    $0x3,%eax
f010af0d:	01 d8                	add    %ebx,%eax
f010af0f:	05 98 00 00 00       	add    $0x98,%eax
f010af14:	8b 00                	mov    (%eax),%eax
f010af16:	89 42 10             	mov    %eax,0x10(%edx)
f010af19:	eb 27                	jmp    f010af42 <program_segment_alloc_map_copy_workingset+0x29b>
f010af1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010af1e:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af24:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af27:	89 d0                	mov    %edx,%eax
f010af29:	01 c0                	add    %eax,%eax
f010af2b:	01 d0                	add    %edx,%eax
f010af2d:	c1 e0 03             	shl    $0x3,%eax
f010af30:	01 c8                	add    %ecx,%eax
f010af32:	05 98 00 00 00       	add    $0x98,%eax
f010af37:	8b 10                	mov    (%eax),%edx
f010af39:	8b 45 08             	mov    0x8(%ebp),%eax
f010af3c:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010af42:	8b 45 08             	mov    0x8(%ebp),%eax
f010af45:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af4b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af4e:	89 d0                	mov    %edx,%eax
f010af50:	01 c0                	add    %eax,%eax
f010af52:	01 d0                	add    %edx,%eax
f010af54:	c1 e0 03             	shl    $0x3,%eax
f010af57:	01 c8                	add    %ecx,%eax
f010af59:	05 98 00 00 00       	add    $0x98,%eax
f010af5e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010af64:	8b 45 08             	mov    0x8(%ebp),%eax
f010af67:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af6d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af70:	89 d0                	mov    %edx,%eax
f010af72:	01 c0                	add    %eax,%eax
f010af74:	01 d0                	add    %edx,%eax
f010af76:	c1 e0 03             	shl    $0x3,%eax
f010af79:	01 c8                	add    %ecx,%eax
f010af7b:	05 9c 00 00 00       	add    $0x9c,%eax
f010af80:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010af86:	8b 45 08             	mov    0x8(%ebp),%eax
f010af89:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010af8f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010af92:	8b 45 08             	mov    0x8(%ebp),%eax
f010af95:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010af9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010af9e:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010afa4:	8b 45 08             	mov    0x8(%ebp),%eax
f010afa7:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010afad:	48                   	dec    %eax
f010afae:	39 c2                	cmp    %eax,%edx
f010afb0:	0f 83 37 01 00 00    	jae    f010b0ed <program_segment_alloc_map_copy_workingset+0x446>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010afb6:	8b 45 08             	mov    0x8(%ebp),%eax
f010afb9:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010afbf:	89 d0                	mov    %edx,%eax
f010afc1:	01 c0                	add    %eax,%eax
f010afc3:	01 d0                	add    %edx,%eax
f010afc5:	c1 e0 03             	shl    $0x3,%eax
f010afc8:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010afce:	8b 45 08             	mov    0x8(%ebp),%eax
f010afd1:	01 d0                	add    %edx,%eax
f010afd3:	83 c0 08             	add    $0x8,%eax
f010afd6:	85 c0                	test   %eax,%eax
f010afd8:	75 17                	jne    f010aff1 <program_segment_alloc_map_copy_workingset+0x34a>
f010afda:	83 ec 04             	sub    $0x4,%esp
f010afdd:	68 e8 7d 12 f0       	push   $0xf0127de8
f010afe2:	68 04 03 00 00       	push   $0x304
f010afe7:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010afec:	e8 29 53 ff ff       	call   f010031a <_panic>
f010aff1:	8b 45 08             	mov    0x8(%ebp),%eax
f010aff4:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010affa:	8b 45 08             	mov    0x8(%ebp),%eax
f010affd:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010b003:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b006:	89 d0                	mov    %edx,%eax
f010b008:	01 c0                	add    %eax,%eax
f010b00a:	01 d0                	add    %edx,%eax
f010b00c:	c1 e0 03             	shl    $0x3,%eax
f010b00f:	01 d8                	add    %ebx,%eax
f010b011:	05 98 00 00 00       	add    $0x98,%eax
f010b016:	89 08                	mov    %ecx,(%eax)
f010b018:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b01b:	89 d0                	mov    %edx,%eax
f010b01d:	01 c0                	add    %eax,%eax
f010b01f:	01 d0                	add    %edx,%eax
f010b021:	c1 e0 03             	shl    $0x3,%eax
f010b024:	01 c8                	add    %ecx,%eax
f010b026:	05 98 00 00 00       	add    $0x98,%eax
f010b02b:	8b 00                	mov    (%eax),%eax
f010b02d:	85 c0                	test   %eax,%eax
f010b02f:	74 2e                	je     f010b05f <program_segment_alloc_map_copy_workingset+0x3b8>
f010b031:	8b 45 08             	mov    0x8(%ebp),%eax
f010b034:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010b03a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b03d:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010b043:	89 c8                	mov    %ecx,%eax
f010b045:	01 c0                	add    %eax,%eax
f010b047:	01 c8                	add    %ecx,%eax
f010b049:	c1 e0 03             	shl    $0x3,%eax
f010b04c:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b052:	8b 45 08             	mov    0x8(%ebp),%eax
f010b055:	01 c8                	add    %ecx,%eax
f010b057:	83 c0 08             	add    $0x8,%eax
f010b05a:	89 42 14             	mov    %eax,0x14(%edx)
f010b05d:	eb 29                	jmp    f010b088 <program_segment_alloc_map_copy_workingset+0x3e1>
f010b05f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b062:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b068:	89 d0                	mov    %edx,%eax
f010b06a:	01 c0                	add    %eax,%eax
f010b06c:	01 d0                	add    %edx,%eax
f010b06e:	c1 e0 03             	shl    $0x3,%eax
f010b071:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b077:	8b 45 08             	mov    0x8(%ebp),%eax
f010b07a:	01 d0                	add    %edx,%eax
f010b07c:	8d 50 08             	lea    0x8(%eax),%edx
f010b07f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b082:	89 90 14 da 01 00    	mov    %edx,0x1da14(%eax)
f010b088:	8b 45 08             	mov    0x8(%ebp),%eax
f010b08b:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b091:	89 d0                	mov    %edx,%eax
f010b093:	01 c0                	add    %eax,%eax
f010b095:	01 d0                	add    %edx,%eax
f010b097:	c1 e0 03             	shl    $0x3,%eax
f010b09a:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b0a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0a3:	01 d0                	add    %edx,%eax
f010b0a5:	8d 50 08             	lea    0x8(%eax),%edx
f010b0a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0ab:	89 90 10 da 01 00    	mov    %edx,0x1da10(%eax)
f010b0b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0b4:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b0ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b0bd:	89 d0                	mov    %edx,%eax
f010b0bf:	01 c0                	add    %eax,%eax
f010b0c1:	01 d0                	add    %edx,%eax
f010b0c3:	c1 e0 03             	shl    $0x3,%eax
f010b0c6:	01 c8                	add    %ecx,%eax
f010b0c8:	05 9c 00 00 00       	add    $0x9c,%eax
f010b0cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b0d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0d6:	8b 80 1c da 01 00    	mov    0x1da1c(%eax),%eax
f010b0dc:	8d 50 01             	lea    0x1(%eax),%edx
f010b0df:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0e2:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010b0e8:	e9 32 01 00 00       	jmp    f010b21f <program_segment_alloc_map_copy_workingset+0x578>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010b0ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0f0:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b0f6:	89 d0                	mov    %edx,%eax
f010b0f8:	01 c0                	add    %eax,%eax
f010b0fa:	01 d0                	add    %edx,%eax
f010b0fc:	c1 e0 03             	shl    $0x3,%eax
f010b0ff:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b105:	8b 45 08             	mov    0x8(%ebp),%eax
f010b108:	01 d0                	add    %edx,%eax
f010b10a:	83 c0 08             	add    $0x8,%eax
f010b10d:	85 c0                	test   %eax,%eax
f010b10f:	75 17                	jne    f010b128 <program_segment_alloc_map_copy_workingset+0x481>
f010b111:	83 ec 04             	sub    $0x4,%esp
f010b114:	68 e8 7d 12 f0       	push   $0xf0127de8
f010b119:	68 09 03 00 00       	push   $0x309
f010b11e:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010b123:	e8 f2 51 ff ff       	call   f010031a <_panic>
f010b128:	8b 45 08             	mov    0x8(%ebp),%eax
f010b12b:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b131:	8b 45 08             	mov    0x8(%ebp),%eax
f010b134:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010b13a:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b13d:	89 d0                	mov    %edx,%eax
f010b13f:	01 c0                	add    %eax,%eax
f010b141:	01 d0                	add    %edx,%eax
f010b143:	c1 e0 03             	shl    $0x3,%eax
f010b146:	01 d8                	add    %ebx,%eax
f010b148:	05 98 00 00 00       	add    $0x98,%eax
f010b14d:	89 08                	mov    %ecx,(%eax)
f010b14f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b152:	89 d0                	mov    %edx,%eax
f010b154:	01 c0                	add    %eax,%eax
f010b156:	01 d0                	add    %edx,%eax
f010b158:	c1 e0 03             	shl    $0x3,%eax
f010b15b:	01 c8                	add    %ecx,%eax
f010b15d:	05 98 00 00 00       	add    $0x98,%eax
f010b162:	8b 00                	mov    (%eax),%eax
f010b164:	85 c0                	test   %eax,%eax
f010b166:	74 2e                	je     f010b196 <program_segment_alloc_map_copy_workingset+0x4ef>
f010b168:	8b 45 08             	mov    0x8(%ebp),%eax
f010b16b:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010b171:	8b 45 08             	mov    0x8(%ebp),%eax
f010b174:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010b17a:	89 c8                	mov    %ecx,%eax
f010b17c:	01 c0                	add    %eax,%eax
f010b17e:	01 c8                	add    %ecx,%eax
f010b180:	c1 e0 03             	shl    $0x3,%eax
f010b183:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b189:	8b 45 08             	mov    0x8(%ebp),%eax
f010b18c:	01 c8                	add    %ecx,%eax
f010b18e:	83 c0 08             	add    $0x8,%eax
f010b191:	89 42 14             	mov    %eax,0x14(%edx)
f010b194:	eb 29                	jmp    f010b1bf <program_segment_alloc_map_copy_workingset+0x518>
f010b196:	8b 45 08             	mov    0x8(%ebp),%eax
f010b199:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b19f:	89 d0                	mov    %edx,%eax
f010b1a1:	01 c0                	add    %eax,%eax
f010b1a3:	01 d0                	add    %edx,%eax
f010b1a5:	c1 e0 03             	shl    $0x3,%eax
f010b1a8:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b1ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1b1:	01 d0                	add    %edx,%eax
f010b1b3:	8d 50 08             	lea    0x8(%eax),%edx
f010b1b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1b9:	89 90 24 da 01 00    	mov    %edx,0x1da24(%eax)
f010b1bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1c2:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b1c8:	89 d0                	mov    %edx,%eax
f010b1ca:	01 c0                	add    %eax,%eax
f010b1cc:	01 d0                	add    %edx,%eax
f010b1ce:	c1 e0 03             	shl    $0x3,%eax
f010b1d1:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b1d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1da:	01 d0                	add    %edx,%eax
f010b1dc:	8d 50 08             	lea    0x8(%eax),%edx
f010b1df:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1e2:	89 90 20 da 01 00    	mov    %edx,0x1da20(%eax)
f010b1e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1eb:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b1f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b1f4:	89 d0                	mov    %edx,%eax
f010b1f6:	01 c0                	add    %eax,%eax
f010b1f8:	01 d0                	add    %edx,%eax
f010b1fa:	c1 e0 03             	shl    $0x3,%eax
f010b1fd:	01 c8                	add    %ecx,%eax
f010b1ff:	05 9c 00 00 00       	add    $0x9c,%eax
f010b204:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b20a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b20d:	8b 80 2c da 01 00    	mov    0x1da2c(%eax),%eax
f010b213:	8d 50 01             	lea    0x1(%eax),%edx
f010b216:	8b 45 08             	mov    0x8(%ebp),%eax
f010b219:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)
		else
		{
			e->page_last_WS_element = NULL;
		}
#else
		e->page_last_WS_index ++;
f010b21f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b222:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010b228:	8d 50 01             	lea    0x1(%eax),%edx
f010b22b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b22e:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
		e->page_last_WS_index %= (e->page_WS_max_size);
f010b234:	8b 45 08             	mov    0x8(%ebp),%eax
f010b237:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010b23d:	8b 55 08             	mov    0x8(%ebp),%edx
f010b240:	8b 8a 84 00 00 00    	mov    0x84(%edx),%ecx
f010b246:	ba 00 00 00 00       	mov    $0x0,%edx
f010b24b:	f7 f1                	div    %ecx
f010b24d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b250:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010b256:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b259:	c1 e8 16             	shr    $0x16,%eax
f010b25c:	89 c2                	mov    %eax,%edx
f010b25e:	8b 45 18             	mov    0x18(%ebp),%eax
f010b261:	8b 00                	mov    (%eax),%eax
f010b263:	39 c2                	cmp    %eax,%edx
f010b265:	0f 84 d3 00 00 00    	je     f010b33e <program_segment_alloc_map_copy_workingset+0x697>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010b26b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b26e:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010b274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b277:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b27a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b27d:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010b282:	89 c1                	mov    %eax,%ecx
f010b284:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b287:	89 d0                	mov    %edx,%eax
f010b289:	01 c0                	add    %eax,%eax
f010b28b:	01 d0                	add    %edx,%eax
f010b28d:	c1 e0 03             	shl    $0x3,%eax
f010b290:	01 d8                	add    %ebx,%eax
f010b292:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010b297:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010b299:	8b 45 08             	mov    0x8(%ebp),%eax
f010b29c:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010b2a2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b2a5:	89 d0                	mov    %edx,%eax
f010b2a7:	01 c0                	add    %eax,%eax
f010b2a9:	01 d0                	add    %edx,%eax
f010b2ab:	c1 e0 03             	shl    $0x3,%eax
f010b2ae:	01 c8                	add    %ecx,%eax
f010b2b0:	05 60 d5 01 00       	add    $0x1d560,%eax
f010b2b5:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010b2b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2bb:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010b2c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b2c4:	89 d0                	mov    %edx,%eax
f010b2c6:	01 c0                	add    %eax,%eax
f010b2c8:	01 d0                	add    %edx,%eax
f010b2ca:	c1 e0 03             	shl    $0x3,%eax
f010b2cd:	01 c8                	add    %ecx,%eax
f010b2cf:	05 64 d5 01 00       	add    $0x1d564,%eax
f010b2d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010b2da:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2dd:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b2e3:	8d 50 01             	lea    0x1(%eax),%edx
f010b2e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2e9:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010b2ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2f2:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b2f8:	b9 32 00 00 00       	mov    $0x32,%ecx
f010b2fd:	ba 00 00 00 00       	mov    $0x0,%edx
f010b302:	f7 f1                	div    %ecx
f010b304:	8b 45 08             	mov    0x8(%ebp),%eax
f010b307:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			if (e->table_last_WS_index == 0)
f010b30d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b310:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b316:	85 c0                	test   %eax,%eax
f010b318:	75 17                	jne    f010b331 <program_segment_alloc_map_copy_workingset+0x68a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b31a:	83 ec 04             	sub    $0x4,%esp
f010b31d:	68 cc 7f 12 f0       	push   $0xf0127fcc
f010b322:	68 24 03 00 00       	push   $0x324
f010b327:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010b32c:	e8 e9 4f ff ff       	call   f010031a <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b334:	c1 e8 16             	shr    $0x16,%eax
f010b337:	89 c2                	mov    %eax,%edx
f010b339:	8b 45 18             	mov    0x18(%ebp),%eax
f010b33c:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b33e:	8b 45 10             	mov    0x10(%ebp),%eax
f010b341:	8b 00                	mov    (%eax),%eax
f010b343:	8d 50 01             	lea    0x1(%eax),%edx
f010b346:	8b 45 10             	mov    0x10(%ebp),%eax
f010b349:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b34b:	ff 45 f0             	incl   -0x10(%ebp)
f010b34e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b355:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b358:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b35b:	73 0c                	jae    f010b369 <program_segment_alloc_map_copy_workingset+0x6c2>
f010b35d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b360:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b363:	0f 82 eb f9 ff ff    	jb     f010ad54 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b369:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b36c:	8b 00                	mov    (%eax),%eax
f010b36e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b371:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b374:	8b 40 0c             	mov    0xc(%eax),%eax
f010b377:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b37a:	eb 10                	jmp    f010b38c <program_segment_alloc_map_copy_workingset+0x6e5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b37c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b37f:	8a 10                	mov    (%eax),%dl
f010b381:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b384:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b386:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b389:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b38c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b38f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b392:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b395:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b39a:	89 c2                	mov    %eax,%edx
f010b39c:	8b 45 10             	mov    0x10(%ebp),%eax
f010b39f:	8b 00                	mov    (%eax),%eax
f010b3a1:	c1 e0 0c             	shl    $0xc,%eax
f010b3a4:	01 c2                	add    %eax,%edx
f010b3a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3a9:	39 c2                	cmp    %eax,%edx
f010b3ab:	76 1d                	jbe    f010b3ca <program_segment_alloc_map_copy_workingset+0x723>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b3ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b3b0:	8b 50 04             	mov    0x4(%eax),%edx
f010b3b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b3b6:	01 c2                	add    %eax,%edx
f010b3b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b3bb:	39 c2                	cmp    %eax,%edx
f010b3bd:	77 bd                	ja     f010b37c <program_segment_alloc_map_copy_workingset+0x6d5>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b3bf:	eb 09                	jmp    f010b3ca <program_segment_alloc_map_copy_workingset+0x723>
	{
		*dst_ptr = 0;
f010b3c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3c4:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b3c7:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b3ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b3cd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b3d0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b3d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b3d8:	89 c2                	mov    %eax,%edx
f010b3da:	8b 45 10             	mov    0x10(%ebp),%eax
f010b3dd:	8b 00                	mov    (%eax),%eax
f010b3df:	c1 e0 0c             	shl    $0xc,%eax
f010b3e2:	01 c2                	add    %eax,%edx
f010b3e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3e7:	39 c2                	cmp    %eax,%edx
f010b3e9:	77 d6                	ja     f010b3c1 <program_segment_alloc_map_copy_workingset+0x71a>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b3eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b3f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b3f3:	c9                   	leave  
f010b3f4:	c3                   	ret    

f010b3f5 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b3f5:	55                   	push   %ebp
f010b3f6:	89 e5                	mov    %esp,%ebp
f010b3f8:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b3fb:	83 ec 0c             	sub    $0xc,%esp
f010b3fe:	68 00 10 00 00       	push   $0x1000
f010b403:	e8 ae d6 ff ff       	call   f0108ab6 <kmalloc>
f010b408:	83 c4 10             	add    $0x10,%esp
f010b40b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b40e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b412:	75 17                	jne    f010b42b <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b414:	83 ec 04             	sub    $0x4,%esp
f010b417:	68 6f 80 12 f0       	push   $0xf012806f
f010b41c:	68 54 03 00 00       	push   $0x354
f010b421:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010b426:	e8 ef 4e ff ff       	call   f010031a <_panic>
	}
	return ptr_user_page_directory;
f010b42b:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b42e:	c9                   	leave  
f010b42f:	c3                   	ret    

f010b430 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b430:	55                   	push   %ebp
f010b431:	89 e5                	mov    %esp,%ebp
f010b433:	83 ec 18             	sub    $0x18,%esp
	//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
	//return a pointer to the start of the allocated space (including the GUARD PAGE)


#else
	if (KERNEL_HEAP_MAX - __cur_k_stk < KERNEL_STACK_SIZE)
f010b436:	a1 5c f9 17 f0       	mov    0xf017f95c,%eax
f010b43b:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
f010b440:	29 c2                	sub    %eax,%edx
f010b442:	89 d0                	mov    %edx,%eax
f010b444:	3d ff 7f 00 00       	cmp    $0x7fff,%eax
f010b449:	77 17                	ja     f010b462 <create_user_kern_stack+0x32>
		panic("Run out of kernel heap!! Unable to create a kernel stack for the process. Can't create more processes!");
f010b44b:	83 ec 04             	sub    $0x4,%esp
f010b44e:	68 8c 80 12 f0       	push   $0xf012808c
f010b453:	68 6d 03 00 00       	push   $0x36d
f010b458:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010b45d:	e8 b8 4e ff ff       	call   f010031a <_panic>
	void* kstack = (void*) __cur_k_stk;
f010b462:	a1 5c f9 17 f0       	mov    0xf017f95c,%eax
f010b467:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__cur_k_stk += KERNEL_STACK_SIZE;
f010b46a:	a1 5c f9 17 f0       	mov    0xf017f95c,%eax
f010b46f:	05 00 80 00 00       	add    $0x8000,%eax
f010b474:	a3 5c f9 17 f0       	mov    %eax,0xf017f95c
	return kstack ;
f010b479:	8b 45 f4             	mov    -0xc(%ebp),%eax
//	panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010b47c:	c9                   	leave  
f010b47d:	c3                   	ret    

f010b47e <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b47e:	55                   	push   %ebp
f010b47f:	89 e5                	mov    %esp,%ebp
f010b481:	83 ec 08             	sub    $0x8,%esp
	panic("delete_user_kern_stack() is not implemented yet...!!");

	//Delete the allocated space for the user kernel stack of this process "e"
	//remember to delete the bottom GUARD PAGE (i.e. not mapped)
#else
	panic("KERNEL HEAP is OFF! user kernel stack can't be deleted");
f010b484:	83 ec 04             	sub    $0x4,%esp
f010b487:	68 f4 80 12 f0       	push   $0xf01280f4
f010b48c:	68 83 03 00 00       	push   $0x383
f010b491:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010b496:	e8 7f 4e ff ff       	call   f010031a <_panic>

f010b49b <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b49b:	55                   	push   %ebp
f010b49c:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2] Initialize the dynamic allocator of the user heap
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b49e:	90                   	nop
f010b49f:	5d                   	pop    %ebp
f010b4a0:	c3                   	ret    

f010b4a1 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b4a1:	55                   	push   %ebp
f010b4a2:	89 e5                	mov    %esp,%ebp
f010b4a4:	53                   	push   %ebx
f010b4a5:	83 ec 14             	sub    $0x14,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b4a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4ab:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b4ae:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b4b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4b4:	8b 55 10             	mov    0x10(%ebp),%edx
f010b4b7:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b4ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b4c1:	eb 17                	jmp    f010b4da <initialize_environment+0x39>
	{
		e->env_page_directory[i] = 0 ;
f010b4c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4c6:	8b 40 64             	mov    0x64(%eax),%eax
f010b4c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4cc:	c1 e2 02             	shl    $0x2,%edx
f010b4cf:	01 d0                	add    %edx,%eax
f010b4d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b4d7:	ff 45 f4             	incl   -0xc(%ebp)
f010b4da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4dd:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b4e2:	76 df                	jbe    f010b4c3 <initialize_environment+0x22>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b4e4:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b4eb:	eb 22                	jmp    f010b50f <initialize_environment+0x6e>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b4ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4f0:	8b 40 64             	mov    0x64(%eax),%eax
f010b4f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4f6:	c1 e2 02             	shl    $0x2,%edx
f010b4f9:	01 c2                	add    %eax,%edx
f010b4fb:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f010b500:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b503:	c1 e1 02             	shl    $0x2,%ecx
f010b506:	01 c8                	add    %ecx,%eax
f010b508:	8b 00                	mov    (%eax),%eax
f010b50a:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b50c:	ff 45 f4             	incl   -0xc(%ebp)
f010b50f:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b516:	7e d5                	jle    f010b4ed <initialize_environment+0x4c>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b518:	8b 45 08             	mov    0x8(%ebp),%eax
f010b51b:	8b 40 64             	mov    0x64(%eax),%eax
f010b51e:	83 ec 0c             	sub    $0xc,%esp
f010b521:	50                   	push   %eax
f010b522:	e8 09 ff ff ff       	call   f010b430 <create_user_kern_stack>
f010b527:	83 c4 10             	add    $0x10,%esp
f010b52a:	89 c2                	mov    %eax,%edx
f010b52c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b52f:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b532:	8b 45 08             	mov    0x8(%ebp),%eax
f010b535:	8b 40 70             	mov    0x70(%eax),%eax
f010b538:	05 00 80 00 00       	add    $0x8000,%eax
f010b53d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		sp -= sizeof(struct Trapframe);
f010b540:	83 6d ec 44          	subl   $0x44,-0x14(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b544:	8b 45 08             	mov    0x8(%ebp),%eax
f010b547:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b54a:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b54c:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b550:	ba 84 d7 10 f0       	mov    $0xf010d784,%edx
f010b555:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b558:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b55a:	83 6d ec 20          	subl   $0x20,-0x14(%ebp)
		e->context = (struct Context *) sp;
f010b55e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b561:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b564:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b567:	8b 45 08             	mov    0x8(%ebp),%eax
f010b56a:	8b 40 04             	mov    0x4(%eax),%eax
f010b56d:	83 ec 04             	sub    $0x4,%esp
f010b570:	6a 20                	push   $0x20
f010b572:	6a 00                	push   $0x0
f010b574:	50                   	push   %eax
f010b575:	e8 49 72 01 00       	call   f01227c3 <memset>
f010b57a:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b57d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b580:	8b 40 04             	mov    0x4(%eax),%eax
f010b583:	ba d6 a6 10 f0       	mov    $0xf010a6d6,%edx
f010b588:	89 50 1c             	mov    %edx,0x1c(%eax)
	{
		LIST_INIT(&(e->page_WS_list));
	}
#else
	{
		uint32 env_index = (uint32)(e-envs);
f010b58b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b58e:	8b 15 b0 03 5a f0    	mov    0xf05a03b0,%edx
f010b594:	29 d0                	sub    %edx,%eax
f010b596:	c1 f8 02             	sar    $0x2,%eax
f010b599:	89 c2                	mov    %eax,%edx
f010b59b:	89 d0                	mov    %edx,%eax
f010b59d:	c1 e0 02             	shl    $0x2,%eax
f010b5a0:	01 d0                	add    %edx,%eax
f010b5a2:	c1 e0 02             	shl    $0x2,%eax
f010b5a5:	01 d0                	add    %edx,%eax
f010b5a7:	c1 e0 02             	shl    $0x2,%eax
f010b5aa:	01 d0                	add    %edx,%eax
f010b5ac:	c1 e0 02             	shl    $0x2,%eax
f010b5af:	01 d0                	add    %edx,%eax
f010b5b1:	c1 e0 08             	shl    $0x8,%eax
f010b5b4:	29 d0                	sub    %edx,%eax
f010b5b6:	c1 e0 08             	shl    $0x8,%eax
f010b5b9:	29 d0                	sub    %edx,%eax
f010b5bb:	c1 e0 03             	shl    $0x3,%eax
f010b5be:	01 d0                	add    %edx,%eax
f010b5c0:	c1 e0 03             	shl    $0x3,%eax
f010b5c3:	01 d0                	add    %edx,%eax
f010b5c5:	01 c0                	add    %eax,%eax
f010b5c7:	01 d0                	add    %edx,%eax
f010b5c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		e->__uptr_pws = (struct WorkingSetElement*) ( ((struct Env*)(UENVS+sizeof(struct Env)*env_index))->ptr_pageWorkingSet );
f010b5cc:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b5cf:	89 d0                	mov    %edx,%eax
f010b5d1:	c1 e0 06             	shl    $0x6,%eax
f010b5d4:	29 d0                	sub    %edx,%eax
f010b5d6:	c1 e0 02             	shl    $0x2,%eax
f010b5d9:	01 d0                	add    %edx,%eax
f010b5db:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010b5e2:	01 c8                	add    %ecx,%eax
f010b5e4:	c1 e0 03             	shl    $0x3,%eax
f010b5e7:	01 d0                	add    %edx,%eax
f010b5e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b5f0:	29 c2                	sub    %eax,%edx
f010b5f2:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010b5f9:	89 c2                	mov    %eax,%edx
f010b5fb:	89 d0                	mov    %edx,%eax
f010b5fd:	2d 00 00 40 11       	sub    $0x11400000,%eax
f010b602:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010b608:	8b 45 08             	mov    0x8(%ebp),%eax
f010b60b:	89 90 38 da 01 00    	mov    %edx,0x1da38(%eax)
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b611:	83 ec 0c             	sub    $0xc,%esp
f010b614:	6a 02                	push   $0x2
f010b616:	e8 f5 30 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f010b61b:	83 c4 10             	add    $0x10,%esp
f010b61e:	85 c0                	test   %eax,%eax
f010b620:	0f 84 34 01 00 00    	je     f010b75a <initialize_environment+0x2b9>
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b626:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010b62d:	e9 14 01 00 00       	jmp    f010b746 <initialize_environment+0x2a5>
		{
			LIST_INSERT_HEAD(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[i]));
f010b632:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b635:	89 d0                	mov    %edx,%eax
f010b637:	01 c0                	add    %eax,%eax
f010b639:	01 d0                	add    %edx,%eax
f010b63b:	c1 e0 03             	shl    $0x3,%eax
f010b63e:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b644:	8b 45 08             	mov    0x8(%ebp),%eax
f010b647:	01 d0                	add    %edx,%eax
f010b649:	83 c0 08             	add    $0x8,%eax
f010b64c:	85 c0                	test   %eax,%eax
f010b64e:	75 17                	jne    f010b667 <initialize_environment+0x1c6>
f010b650:	83 ec 04             	sub    $0x4,%esp
f010b653:	68 e8 7d 12 f0       	push   $0xf0127de8
f010b658:	68 e6 03 00 00       	push   $0x3e6
f010b65d:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010b662:	e8 b3 4c ff ff       	call   f010031a <_panic>
f010b667:	8b 45 08             	mov    0x8(%ebp),%eax
f010b66a:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b670:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b673:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b676:	89 c8                	mov    %ecx,%eax
f010b678:	01 c0                	add    %eax,%eax
f010b67a:	01 c8                	add    %ecx,%eax
f010b67c:	c1 e0 03             	shl    $0x3,%eax
f010b67f:	01 d8                	add    %ebx,%eax
f010b681:	05 98 00 00 00       	add    $0x98,%eax
f010b686:	89 10                	mov    %edx,(%eax)
f010b688:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b68b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b68e:	89 d0                	mov    %edx,%eax
f010b690:	01 c0                	add    %eax,%eax
f010b692:	01 d0                	add    %edx,%eax
f010b694:	c1 e0 03             	shl    $0x3,%eax
f010b697:	01 c8                	add    %ecx,%eax
f010b699:	05 98 00 00 00       	add    $0x98,%eax
f010b69e:	8b 00                	mov    (%eax),%eax
f010b6a0:	85 c0                	test   %eax,%eax
f010b6a2:	74 28                	je     f010b6cc <initialize_environment+0x22b>
f010b6a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6a7:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b6ad:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b6b0:	89 c8                	mov    %ecx,%eax
f010b6b2:	01 c0                	add    %eax,%eax
f010b6b4:	01 c8                	add    %ecx,%eax
f010b6b6:	c1 e0 03             	shl    $0x3,%eax
f010b6b9:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b6bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6c2:	01 c8                	add    %ecx,%eax
f010b6c4:	83 c0 08             	add    $0x8,%eax
f010b6c7:	89 42 14             	mov    %eax,0x14(%edx)
f010b6ca:	eb 23                	jmp    f010b6ef <initialize_environment+0x24e>
f010b6cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b6cf:	89 d0                	mov    %edx,%eax
f010b6d1:	01 c0                	add    %eax,%eax
f010b6d3:	01 d0                	add    %edx,%eax
f010b6d5:	c1 e0 03             	shl    $0x3,%eax
f010b6d8:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b6de:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6e1:	01 d0                	add    %edx,%eax
f010b6e3:	8d 50 08             	lea    0x8(%eax),%edx
f010b6e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6e9:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010b6ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b6f2:	89 d0                	mov    %edx,%eax
f010b6f4:	01 c0                	add    %eax,%eax
f010b6f6:	01 d0                	add    %edx,%eax
f010b6f8:	c1 e0 03             	shl    $0x3,%eax
f010b6fb:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b701:	8b 45 08             	mov    0x8(%ebp),%eax
f010b704:	01 d0                	add    %edx,%eax
f010b706:	8d 50 08             	lea    0x8(%eax),%edx
f010b709:	8b 45 08             	mov    0x8(%ebp),%eax
f010b70c:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010b712:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b715:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b718:	89 d0                	mov    %edx,%eax
f010b71a:	01 c0                	add    %eax,%eax
f010b71c:	01 d0                	add    %edx,%eax
f010b71e:	c1 e0 03             	shl    $0x3,%eax
f010b721:	01 c8                	add    %ecx,%eax
f010b723:	05 9c 00 00 00       	add    $0x9c,%eax
f010b728:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b72e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b731:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010b737:	8d 50 01             	lea    0x1(%eax),%edx
f010b73a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b73d:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b743:	ff 45 f0             	incl   -0x10(%ebp)
f010b746:	8b 45 08             	mov    0x8(%ebp),%eax
f010b749:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b74f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b752:	39 c2                	cmp    %eax,%edx
f010b754:	0f 87 d8 fe ff ff    	ja     f010b632 <initialize_environment+0x191>
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b75a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b761:	eb 54                	jmp    f010b7b7 <initialize_environment+0x316>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
f010b763:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b766:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b769:	89 d0                	mov    %edx,%eax
f010b76b:	01 c0                	add    %eax,%eax
f010b76d:	01 d0                	add    %edx,%eax
f010b76f:	c1 e0 03             	shl    $0x3,%eax
f010b772:	01 c8                	add    %ecx,%eax
f010b774:	05 88 00 00 00       	add    $0x88,%eax
f010b779:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].empty = 1;
f010b77f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b782:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b785:	89 d0                	mov    %edx,%eax
f010b787:	01 c0                	add    %eax,%eax
f010b789:	01 d0                	add    %edx,%eax
f010b78b:	c1 e0 03             	shl    $0x3,%eax
f010b78e:	01 c8                	add    %ecx,%eax
f010b790:	05 8c 00 00 00       	add    $0x8c,%eax
f010b795:	c6 00 01             	movb   $0x1,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
f010b798:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b79b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b79e:	89 d0                	mov    %edx,%eax
f010b7a0:	01 c0                	add    %eax,%eax
f010b7a2:	01 d0                	add    %edx,%eax
f010b7a4:	c1 e0 03             	shl    $0x3,%eax
f010b7a7:	01 c8                	add    %ecx,%eax
f010b7a9:	05 90 00 00 00       	add    $0x90,%eax
f010b7ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b7b4:	ff 45 f4             	incl   -0xc(%ebp)
f010b7b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7ba:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b7c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7c3:	39 c2                	cmp    %eax,%edx
f010b7c5:	77 9c                	ja     f010b763 <initialize_environment+0x2c2>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
		e->ptr_pageWorkingSet[i].empty = 1;
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
f010b7c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7ca:	c7 80 58 d5 01 00 00 	movl   $0x0,0x1d558(%eax)
f010b7d1:	00 00 00 
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b7d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b7db:	eb 54                	jmp    f010b831 <initialize_environment+0x390>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b7dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7e3:	89 d0                	mov    %edx,%eax
f010b7e5:	01 c0                	add    %eax,%eax
f010b7e7:	01 d0                	add    %edx,%eax
f010b7e9:	c1 e0 03             	shl    $0x3,%eax
f010b7ec:	01 c8                	add    %ecx,%eax
f010b7ee:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010b7f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b7f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7ff:	89 d0                	mov    %edx,%eax
f010b801:	01 c0                	add    %eax,%eax
f010b803:	01 d0                	add    %edx,%eax
f010b805:	c1 e0 03             	shl    $0x3,%eax
f010b808:	01 c8                	add    %ecx,%eax
f010b80a:	05 60 d5 01 00       	add    $0x1d560,%eax
f010b80f:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b812:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b815:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b818:	89 d0                	mov    %edx,%eax
f010b81a:	01 c0                	add    %eax,%eax
f010b81c:	01 d0                	add    %edx,%eax
f010b81e:	c1 e0 03             	shl    $0x3,%eax
f010b821:	01 c8                	add    %ecx,%eax
f010b823:	05 64 d5 01 00       	add    $0x1d564,%eax
f010b828:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b82e:	ff 45 f4             	incl   -0xc(%ebp)
f010b831:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b835:	7e a6                	jle    f010b7dd <initialize_environment+0x33c>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b837:	8b 45 08             	mov    0x8(%ebp),%eax
f010b83a:	c7 80 0c da 01 00 00 	movl   $0x0,0x1da0c(%eax)
f010b841:	00 00 00 

	e->pageFaultsCounter=0;
f010b844:	8b 45 08             	mov    0x8(%ebp),%eax
f010b847:	c7 80 40 da 01 00 00 	movl   $0x0,0x1da40(%eax)
f010b84e:	00 00 00 
	e->tableFaultsCounter=0;
f010b851:	8b 45 08             	mov    0x8(%ebp),%eax
f010b854:	c7 80 44 da 01 00 00 	movl   $0x0,0x1da44(%eax)
f010b85b:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b85e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b861:	c7 80 48 da 01 00 00 	movl   $0x0,0x1da48(%eax)
f010b868:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b86b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b86e:	c7 80 4c da 01 00 00 	movl   $0x0,0x1da4c(%eax)
f010b875:	00 00 00 

	e->nModifiedPages=0;
f010b878:	8b 45 08             	mov    0x8(%ebp),%eax
f010b87b:	c7 80 50 da 01 00 00 	movl   $0x0,0x1da50(%eax)
f010b882:	00 00 00 
	e->nNotModifiedPages=0;
f010b885:	8b 45 08             	mov    0x8(%ebp),%eax
f010b888:	c7 80 54 da 01 00 00 	movl   $0x0,0x1da54(%eax)
f010b88f:	00 00 00 
	e->nClocks = 0;
f010b892:	8b 45 08             	mov    0x8(%ebp),%eax
f010b895:	c7 80 68 da 01 00 00 	movl   $0x0,0x1da68(%eax)
f010b89c:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b89f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8a2:	c7 80 5c da 01 00 00 	movl   $0x0,0x1da5c(%eax)
f010b8a9:	00 00 00 
	e->nPageOut = 0;
f010b8ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8af:	c7 80 60 da 01 00 00 	movl   $0x0,0x1da60(%eax)
f010b8b6:	00 00 00 
	e->nNewPageAdded = 0;
f010b8b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8bc:	c7 80 64 da 01 00 00 	movl   $0x0,0x1da64(%eax)
f010b8c3:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b8c6:	83 ec 04             	sub    $0x4,%esp
f010b8c9:	68 00 00 00 82       	push   $0x82000000
f010b8ce:	68 00 00 00 80       	push   $0x80000000
f010b8d3:	ff 75 08             	pushl  0x8(%ebp)
f010b8d6:	e8 c0 fb ff ff       	call   f010b49b <initialize_uheap_dynamic_allocator>
f010b8db:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b8de:	83 ec 0c             	sub    $0xc,%esp
f010b8e1:	ff 75 08             	pushl  0x8(%ebp)
f010b8e4:	e8 09 00 00 00       	call   f010b8f2 <complete_environment_initialization>
f010b8e9:	83 c4 10             	add    $0x10,%esp
}
f010b8ec:	90                   	nop
f010b8ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b8f0:	c9                   	leave  
f010b8f1:	c3                   	ret    

f010b8f2 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b8f2:	55                   	push   %ebp
f010b8f3:	89 e5                	mov    %esp,%ebp
f010b8f5:	53                   	push   %ebx
f010b8f6:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b8f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8fc:	8b 40 64             	mov    0x64(%eax),%eax
f010b8ff:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b905:	8b 45 08             	mov    0x8(%ebp),%eax
f010b908:	8b 40 68             	mov    0x68(%eax),%eax
f010b90b:	83 c8 03             	or     $0x3,%eax
f010b90e:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b910:	8b 45 08             	mov    0x8(%ebp),%eax
f010b913:	8b 40 64             	mov    0x64(%eax),%eax
f010b916:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b91c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b91f:	8b 40 68             	mov    0x68(%eax),%eax
f010b922:	83 c8 05             	or     $0x5,%eax
f010b925:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b927:	8b 45 08             	mov    0x8(%ebp),%eax
f010b92a:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b931:	8b 45 08             	mov    0x8(%ebp),%eax
f010b934:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b93b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b93e:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b945:	8b 45 08             	mov    0x8(%ebp),%eax
f010b948:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b94f:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b952:	8b 45 08             	mov    0x8(%ebp),%eax
f010b955:	8b 58 10             	mov    0x10(%eax),%ebx
f010b958:	83 ec 0c             	sub    $0xc,%esp
f010b95b:	6a 08                	push   $0x8
f010b95d:	e8 00 53 01 00       	call   f0120c62 <log2_ceil>
f010b962:	83 c4 10             	add    $0x10,%esp
f010b965:	ba 01 00 00 00       	mov    $0x1,%edx
f010b96a:	88 c1                	mov    %al,%cl
f010b96c:	d3 e2                	shl    %cl,%edx
f010b96e:	89 d0                	mov    %edx,%eax
f010b970:	01 d8                	add    %ebx,%eax
f010b972:	89 c3                	mov    %eax,%ebx
f010b974:	83 ec 0c             	sub    $0xc,%esp
f010b977:	6a 08                	push   $0x8
f010b979:	e8 af 52 01 00       	call   f0120c2d <nearest_pow2_ceil>
f010b97e:	83 c4 10             	add    $0x10,%esp
f010b981:	f7 d8                	neg    %eax
f010b983:	21 d8                	and    %ebx,%eax
f010b985:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b988:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b98c:	7f 1b                	jg     f010b9a9 <complete_environment_initialization+0xb7>
		generation = 1 << ENVGENSHIFT;
f010b98e:	83 ec 0c             	sub    $0xc,%esp
f010b991:	6a 08                	push   $0x8
f010b993:	e8 ca 52 01 00       	call   f0120c62 <log2_ceil>
f010b998:	83 c4 10             	add    $0x10,%esp
f010b99b:	ba 01 00 00 00       	mov    $0x1,%edx
f010b9a0:	88 c1                	mov    %al,%cl
f010b9a2:	d3 e2                	shl    %cl,%edx
f010b9a4:	89 d0                	mov    %edx,%eax
f010b9a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b9a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9ac:	8b 15 b0 03 5a f0    	mov    0xf05a03b0,%edx
f010b9b2:	29 d0                	sub    %edx,%eax
f010b9b4:	c1 f8 02             	sar    $0x2,%eax
f010b9b7:	89 c2                	mov    %eax,%edx
f010b9b9:	89 d0                	mov    %edx,%eax
f010b9bb:	c1 e0 02             	shl    $0x2,%eax
f010b9be:	01 d0                	add    %edx,%eax
f010b9c0:	c1 e0 02             	shl    $0x2,%eax
f010b9c3:	01 d0                	add    %edx,%eax
f010b9c5:	c1 e0 02             	shl    $0x2,%eax
f010b9c8:	01 d0                	add    %edx,%eax
f010b9ca:	c1 e0 02             	shl    $0x2,%eax
f010b9cd:	01 d0                	add    %edx,%eax
f010b9cf:	c1 e0 08             	shl    $0x8,%eax
f010b9d2:	29 d0                	sub    %edx,%eax
f010b9d4:	c1 e0 08             	shl    $0x8,%eax
f010b9d7:	29 d0                	sub    %edx,%eax
f010b9d9:	c1 e0 03             	shl    $0x3,%eax
f010b9dc:	01 d0                	add    %edx,%eax
f010b9de:	c1 e0 03             	shl    $0x3,%eax
f010b9e1:	01 d0                	add    %edx,%eax
f010b9e3:	01 c0                	add    %eax,%eax
f010b9e5:	01 d0                	add    %edx,%eax
f010b9e7:	0b 45 f4             	or     -0xc(%ebp),%eax
f010b9ea:	89 c2                	mov    %eax,%edx
f010b9ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9ef:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010b9f2:	e8 79 ed ff ff       	call   f010a770 <get_cpu_proc>
f010b9f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010b9fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010b9fe:	75 0c                	jne    f010ba0c <complete_environment_initialization+0x11a>
		e->env_parent_id = 0;//no parent;
f010ba00:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba03:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba0a:	eb 0c                	jmp    f010ba18 <complete_environment_initialization+0x126>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010ba0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba0f:	8b 50 10             	mov    0x10(%eax),%edx
f010ba12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba15:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010ba18:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba1b:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010ba22:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba25:	c7 80 58 da 01 00 00 	movl   $0x0,0x1da58(%eax)
f010ba2c:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010ba2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba32:	8b 00                	mov    (%eax),%eax
f010ba34:	83 ec 04             	sub    $0x4,%esp
f010ba37:	6a 44                	push   $0x44
f010ba39:	6a 00                	push   $0x0
f010ba3b:	50                   	push   %eax
f010ba3c:	e8 82 6d 01 00       	call   f01227c3 <memset>
f010ba41:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010ba44:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba47:	8b 00                	mov    (%eax),%eax
f010ba49:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010ba4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba52:	8b 00                	mov    (%eax),%eax
f010ba54:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010ba5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba5d:	8b 00                	mov    (%eax),%eax
f010ba5f:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010ba65:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba68:	8b 00                	mov    (%eax),%eax
f010ba6a:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010ba71:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba74:	8b 00                	mov    (%eax),%eax
f010ba76:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010ba7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba7f:	8b 00                	mov    (%eax),%eax
f010ba81:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba84:	8b 12                	mov    (%edx),%edx
f010ba86:	8b 52 38             	mov    0x38(%edx),%edx
f010ba89:	80 ce 02             	or     $0x2,%dh
f010ba8c:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ba8f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ba93:	75 17                	jne    f010baac <complete_environment_initialization+0x1ba>
f010ba95:	83 ec 04             	sub    $0x4,%esp
f010ba98:	68 9d 7e 12 f0       	push   $0xf0127e9d
f010ba9d:	68 52 04 00 00       	push   $0x452
f010baa2:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010baa7:	e8 6e 48 ff ff       	call   f010031a <_panic>
f010baac:	8b 45 08             	mov    0x8(%ebp),%eax
f010baaf:	8b 40 08             	mov    0x8(%eax),%eax
f010bab2:	85 c0                	test   %eax,%eax
f010bab4:	74 11                	je     f010bac7 <complete_environment_initialization+0x1d5>
f010bab6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bab9:	8b 40 08             	mov    0x8(%eax),%eax
f010babc:	8b 55 08             	mov    0x8(%ebp),%edx
f010babf:	8b 52 0c             	mov    0xc(%edx),%edx
f010bac2:	89 50 0c             	mov    %edx,0xc(%eax)
f010bac5:	eb 0b                	jmp    f010bad2 <complete_environment_initialization+0x1e0>
f010bac7:	8b 45 08             	mov    0x8(%ebp),%eax
f010baca:	8b 40 0c             	mov    0xc(%eax),%eax
f010bacd:	a3 b8 03 5a f0       	mov    %eax,0xf05a03b8
f010bad2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bad5:	8b 40 0c             	mov    0xc(%eax),%eax
f010bad8:	85 c0                	test   %eax,%eax
f010bada:	74 11                	je     f010baed <complete_environment_initialization+0x1fb>
f010badc:	8b 45 08             	mov    0x8(%ebp),%eax
f010badf:	8b 40 0c             	mov    0xc(%eax),%eax
f010bae2:	8b 55 08             	mov    0x8(%ebp),%edx
f010bae5:	8b 52 08             	mov    0x8(%edx),%edx
f010bae8:	89 50 08             	mov    %edx,0x8(%eax)
f010baeb:	eb 0b                	jmp    f010baf8 <complete_environment_initialization+0x206>
f010baed:	8b 45 08             	mov    0x8(%ebp),%eax
f010baf0:	8b 40 08             	mov    0x8(%eax),%eax
f010baf3:	a3 b4 03 5a f0       	mov    %eax,0xf05a03b4
f010baf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bafb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010bb02:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb05:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bb0c:	a1 c0 03 5a f0       	mov    0xf05a03c0,%eax
f010bb11:	48                   	dec    %eax
f010bb12:	a3 c0 03 5a f0       	mov    %eax,0xf05a03c0
	return ;
f010bb17:	90                   	nop
}
f010bb18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb1b:	c9                   	leave  
f010bb1c:	c3                   	ret    

f010bb1d <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010bb1d:	55                   	push   %ebp
f010bb1e:	89 e5                	mov    %esp,%ebp
f010bb20:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bb23:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb26:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bb29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb2c:	8b 00                	mov    (%eax),%eax
f010bb2e:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb33:	74 17                	je     f010bb4c <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010bb35:	83 ec 04             	sub    $0x4,%esp
f010bb38:	68 2b 81 12 f0       	push   $0xf012812b
f010bb3d:	68 5e 04 00 00       	push   $0x45e
f010bb42:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010bb47:	e8 ce 47 ff ff       	call   f010031a <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010bb4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb4f:	8b 00                	mov    (%eax),%eax
f010bb51:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb54:	8b 52 18             	mov    0x18(%edx),%edx
f010bb57:	89 50 30             	mov    %edx,0x30(%eax)
}
f010bb5a:	90                   	nop
f010bb5b:	c9                   	leave  
f010bb5c:	c3                   	ret    

f010bb5d <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010bb5d:	55                   	push   %ebp
f010bb5e:	89 e5                	mov    %esp,%ebp
f010bb60:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010bb63:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb66:	8b 40 10             	mov    0x10(%eax),%eax
f010bb69:	8d 48 01             	lea    0x1(%eax),%ecx
f010bb6c:	8b 55 08             	mov    0x8(%ebp),%edx
f010bb6f:	89 4a 10             	mov    %ecx,0x10(%edx)
f010bb72:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bb75:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb78:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bb7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb7e:	8b 00                	mov    (%eax),%eax
f010bb80:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb85:	74 17                	je     f010bb9e <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010bb87:	83 ec 04             	sub    $0x4,%esp
f010bb8a:	68 2b 81 12 f0       	push   $0xf012812b
f010bb8f:	68 6c 04 00 00       	push   $0x46c
f010bb94:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010bb99:	e8 7c 47 ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bb9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bba1:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bba4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bba7:	01 d0                	add    %edx,%eax
f010bba9:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010bbac:	eb 0f                	jmp    f010bbbd <PROGRAM_SEGMENT_NEXT+0x60>
f010bbae:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbb1:	8b 40 10             	mov    0x10(%eax),%eax
f010bbb4:	8d 50 01             	lea    0x1(%eax),%edx
f010bbb7:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbba:	89 50 10             	mov    %edx,0x10(%eax)
f010bbbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbc0:	8b 40 10             	mov    0x10(%eax),%eax
f010bbc3:	c1 e0 05             	shl    $0x5,%eax
f010bbc6:	89 c2                	mov    %eax,%edx
f010bbc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bbcb:	01 d0                	add    %edx,%eax
f010bbcd:	8b 00                	mov    (%eax),%eax
f010bbcf:	83 f8 01             	cmp    $0x1,%eax
f010bbd2:	74 13                	je     f010bbe7 <PROGRAM_SEGMENT_NEXT+0x8a>
f010bbd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbd7:	8b 50 10             	mov    0x10(%eax),%edx
f010bbda:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbdd:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bbe0:	0f b7 c0             	movzwl %ax,%eax
f010bbe3:	39 c2                	cmp    %eax,%edx
f010bbe5:	72 c7                	jb     f010bbae <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010bbe7:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbea:	8b 40 10             	mov    0x10(%eax),%eax
f010bbed:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010bbf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbf3:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bbf6:	0f b7 c0             	movzwl %ax,%eax
f010bbf9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010bbfc:	7e 63                	jle    f010bc61 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bbfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc01:	c1 e0 05             	shl    $0x5,%eax
f010bc04:	89 c2                	mov    %eax,%edx
f010bc06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc09:	01 d0                	add    %edx,%eax
f010bc0b:	8b 50 04             	mov    0x4(%eax),%edx
f010bc0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc11:	01 c2                	add    %eax,%edx
f010bc13:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc16:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010bc18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc1b:	c1 e0 05             	shl    $0x5,%eax
f010bc1e:	89 c2                	mov    %eax,%edx
f010bc20:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc23:	01 d0                	add    %edx,%eax
f010bc25:	8b 50 14             	mov    0x14(%eax),%edx
f010bc28:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc2b:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010bc2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc31:	c1 e0 05             	shl    $0x5,%eax
f010bc34:	89 c2                	mov    %eax,%edx
f010bc36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc39:	01 d0                	add    %edx,%eax
f010bc3b:	8b 50 10             	mov    0x10(%eax),%edx
f010bc3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc41:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010bc44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc47:	c1 e0 05             	shl    $0x5,%eax
f010bc4a:	89 c2                	mov    %eax,%edx
f010bc4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc4f:	01 d0                	add    %edx,%eax
f010bc51:	8b 40 08             	mov    0x8(%eax),%eax
f010bc54:	89 c2                	mov    %eax,%edx
f010bc56:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc59:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010bc5c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc5f:	eb 05                	jmp    f010bc66 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010bc61:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bc66:	c9                   	leave  
f010bc67:	c3                   	ret    

f010bc68 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010bc68:	55                   	push   %ebp
f010bc69:	89 e5                	mov    %esp,%ebp
f010bc6b:	57                   	push   %edi
f010bc6c:	56                   	push   %esi
f010bc6d:	53                   	push   %ebx
f010bc6e:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010bc71:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bc78:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bc7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc81:	8b 00                	mov    (%eax),%eax
f010bc83:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bc88:	74 17                	je     f010bca1 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010bc8a:	83 ec 04             	sub    $0x4,%esp
f010bc8d:	68 2b 81 12 f0       	push   $0xf012812b
f010bc92:	68 88 04 00 00       	push   $0x488
f010bc97:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010bc9c:	e8 79 46 ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bca1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bca4:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bca7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bcaa:	01 d0                	add    %edx,%eax
f010bcac:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010bcaf:	eb 07                	jmp    f010bcb8 <PROGRAM_SEGMENT_FIRST+0x50>
f010bcb1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bcb4:	40                   	inc    %eax
f010bcb5:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bcb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bcbb:	c1 e0 05             	shl    $0x5,%eax
f010bcbe:	89 c2                	mov    %eax,%edx
f010bcc0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bcc3:	01 d0                	add    %edx,%eax
f010bcc5:	8b 00                	mov    (%eax),%eax
f010bcc7:	83 f8 01             	cmp    $0x1,%eax
f010bcca:	74 10                	je     f010bcdc <PROGRAM_SEGMENT_FIRST+0x74>
f010bccc:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010bccf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bcd2:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bcd5:	0f b7 c0             	movzwl %ax,%eax
f010bcd8:	39 c2                	cmp    %eax,%edx
f010bcda:	72 d5                	jb     f010bcb1 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010bcdc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bcdf:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010bce2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bce5:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bce8:	0f b7 c0             	movzwl %ax,%eax
f010bceb:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010bcee:	7e 68                	jle    f010bd58 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bcf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bcf3:	c1 e0 05             	shl    $0x5,%eax
f010bcf6:	89 c2                	mov    %eax,%edx
f010bcf8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bcfb:	01 d0                	add    %edx,%eax
f010bcfd:	8b 50 04             	mov    0x4(%eax),%edx
f010bd00:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd03:	01 d0                	add    %edx,%eax
f010bd05:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010bd08:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd0b:	c1 e0 05             	shl    $0x5,%eax
f010bd0e:	89 c2                	mov    %eax,%edx
f010bd10:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd13:	01 d0                	add    %edx,%eax
f010bd15:	8b 40 14             	mov    0x14(%eax),%eax
f010bd18:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010bd1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd1e:	c1 e0 05             	shl    $0x5,%eax
f010bd21:	89 c2                	mov    %eax,%edx
f010bd23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd26:	01 d0                	add    %edx,%eax
f010bd28:	8b 40 10             	mov    0x10(%eax),%eax
f010bd2b:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010bd2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd31:	c1 e0 05             	shl    $0x5,%eax
f010bd34:	89 c2                	mov    %eax,%edx
f010bd36:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd39:	01 d0                	add    %edx,%eax
f010bd3b:	8b 40 08             	mov    0x8(%eax),%eax
f010bd3e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010bd41:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd44:	89 c3                	mov    %eax,%ebx
f010bd46:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd49:	ba 05 00 00 00       	mov    $0x5,%edx
f010bd4e:	89 df                	mov    %ebx,%edi
f010bd50:	89 c6                	mov    %eax,%esi
f010bd52:	89 d1                	mov    %edx,%ecx
f010bd54:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010bd56:	eb 1c                	jmp    f010bd74 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010bd58:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010bd5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd62:	89 c3                	mov    %eax,%ebx
f010bd64:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd67:	ba 05 00 00 00       	mov    $0x5,%edx
f010bd6c:	89 df                	mov    %ebx,%edi
f010bd6e:	89 c6                	mov    %eax,%esi
f010bd70:	89 d1                	mov    %edx,%ecx
f010bd72:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010bd74:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd77:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010bd7a:	5b                   	pop    %ebx
f010bd7b:	5e                   	pop    %esi
f010bd7c:	5f                   	pop    %edi
f010bd7d:	5d                   	pop    %ebp
f010bd7e:	c2 04 00             	ret    $0x4

f010bd81 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010bd81:	55                   	push   %ebp
f010bd82:	89 e5                	mov    %esp,%ebp
f010bd84:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010bd87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010bd8e:	83 ec 0c             	sub    $0xc,%esp
f010bd91:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f010bd96:	e8 86 2d 00 00       	call   f010eb21 <acquire_spinlock>
f010bd9b:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bd9e:	a1 d0 0e 5a f0       	mov    0xf05a0ed0,%eax
f010bda3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bda6:	e9 c3 00 00 00       	jmp    f010be6e <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010bdab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdae:	8b 40 0c             	mov    0xc(%eax),%eax
f010bdb1:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bdb4:	0f 85 ac 00 00 00    	jne    f010be66 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010bdba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdbd:	8b 50 10             	mov    0x10(%eax),%edx
f010bdc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc3:	8b 40 0c             	mov    0xc(%eax),%eax
f010bdc6:	8b 40 64             	mov    0x64(%eax),%eax
f010bdc9:	83 ec 08             	sub    $0x8,%esp
f010bdcc:	52                   	push   %edx
f010bdcd:	50                   	push   %eax
f010bdce:	e8 62 ce ff ff       	call   f0108c35 <pt_clear_page_table_entry>
f010bdd3:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010bdd6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bdda:	75 17                	jne    f010bdf3 <cleanup_buffers+0x72>
f010bddc:	83 ec 04             	sub    $0x4,%esp
f010bddf:	68 9d 7e 12 f0       	push   $0xf0127e9d
f010bde4:	68 b1 04 00 00       	push   $0x4b1
f010bde9:	68 0b 7e 12 f0       	push   $0xf0127e0b
f010bdee:	e8 27 45 ff ff       	call   f010031a <_panic>
f010bdf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf6:	8b 00                	mov    (%eax),%eax
f010bdf8:	85 c0                	test   %eax,%eax
f010bdfa:	74 10                	je     f010be0c <cleanup_buffers+0x8b>
f010bdfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdff:	8b 00                	mov    (%eax),%eax
f010be01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be04:	8b 52 04             	mov    0x4(%edx),%edx
f010be07:	89 50 04             	mov    %edx,0x4(%eax)
f010be0a:	eb 0b                	jmp    f010be17 <cleanup_buffers+0x96>
f010be0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be0f:	8b 40 04             	mov    0x4(%eax),%eax
f010be12:	a3 d4 0e 5a f0       	mov    %eax,0xf05a0ed4
f010be17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be1a:	8b 40 04             	mov    0x4(%eax),%eax
f010be1d:	85 c0                	test   %eax,%eax
f010be1f:	74 0f                	je     f010be30 <cleanup_buffers+0xaf>
f010be21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be24:	8b 40 04             	mov    0x4(%eax),%eax
f010be27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be2a:	8b 12                	mov    (%edx),%edx
f010be2c:	89 10                	mov    %edx,(%eax)
f010be2e:	eb 0a                	jmp    f010be3a <cleanup_buffers+0xb9>
f010be30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be33:	8b 00                	mov    (%eax),%eax
f010be35:	a3 d0 0e 5a f0       	mov    %eax,0xf05a0ed0
f010be3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be3d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010be43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be46:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010be4d:	a1 dc 0e 5a f0       	mov    0xf05a0edc,%eax
f010be52:	48                   	dec    %eax
f010be53:	a3 dc 0e 5a f0       	mov    %eax,0xf05a0edc

				free_frame(ptr_fi);
f010be58:	83 ec 0c             	sub    $0xc,%esp
f010be5b:	ff 75 f4             	pushl  -0xc(%ebp)
f010be5e:	e8 c1 c4 ff ff       	call   f0108324 <free_frame>
f010be63:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010be66:	a1 d8 0e 5a f0       	mov    0xf05a0ed8,%eax
f010be6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010be6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be72:	74 07                	je     f010be7b <cleanup_buffers+0xfa>
f010be74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be77:	8b 00                	mov    (%eax),%eax
f010be79:	eb 05                	jmp    f010be80 <cleanup_buffers+0xff>
f010be7b:	b8 00 00 00 00       	mov    $0x0,%eax
f010be80:	a3 d8 0e 5a f0       	mov    %eax,0xf05a0ed8
f010be85:	a1 d8 0e 5a f0       	mov    0xf05a0ed8,%eax
f010be8a:	85 c0                	test   %eax,%eax
f010be8c:	0f 85 19 ff ff ff    	jne    f010bdab <cleanup_buffers+0x2a>
f010be92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be96:	0f 85 0f ff ff ff    	jne    f010bdab <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010be9c:	83 ec 0c             	sub    $0xc,%esp
f010be9f:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f010bea4:	e8 ff 2c 00 00       	call   f010eba8 <release_spinlock>
f010bea9:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010beac:	90                   	nop
f010bead:	c9                   	leave  
f010beae:	c3                   	ret    

f010beaf <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010beaf:	55                   	push   %ebp
f010beb0:	89 e5                	mov    %esp,%ebp
f010beb2:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010beb5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010beb9:	7e 06                	jle    f010bec1 <set_program_priority+0x12>
f010bebb:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bebf:	7e 14                	jle    f010bed5 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010bec1:	83 ec 04             	sub    $0x4,%esp
f010bec4:	68 44 81 12 f0       	push   $0xf0128144
f010bec9:	6a 10                	push   $0x10
f010becb:	68 68 81 12 f0       	push   $0xf0128168
f010bed0:	e8 45 44 ff ff       	call   f010031a <_panic>
		return;
	}
	if(env == NULL)
f010bed5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bed9:	74 78                	je     f010bf53 <set_program_priority+0xa4>
		return;
	switch(priority)
f010bedb:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bedf:	77 56                	ja     f010bf37 <set_program_priority+0x88>
f010bee1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bee4:	c1 e0 02             	shl    $0x2,%eax
f010bee7:	05 a4 81 12 f0       	add    $0xf01281a4,%eax
f010beec:	8b 00                	mov    (%eax),%eax
f010beee:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bef0:	83 ec 08             	sub    $0x8,%esp
f010bef3:	6a 01                	push   $0x1
f010bef5:	ff 75 08             	pushl  0x8(%ebp)
f010bef8:	e8 b6 d7 ff ff       	call   f01096b3 <half_WS_Size>
f010befd:	83 c4 10             	add    $0x10,%esp
			break;
f010bf00:	eb 35                	jmp    f010bf37 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bf02:	83 ec 08             	sub    $0x8,%esp
f010bf05:	6a 00                	push   $0x0
f010bf07:	ff 75 08             	pushl  0x8(%ebp)
f010bf0a:	e8 a4 d7 ff ff       	call   f01096b3 <half_WS_Size>
f010bf0f:	83 c4 10             	add    $0x10,%esp
			break;
f010bf12:	eb 23                	jmp    f010bf37 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bf14:	83 ec 08             	sub    $0x8,%esp
f010bf17:	6a 01                	push   $0x1
f010bf19:	ff 75 08             	pushl  0x8(%ebp)
f010bf1c:	e8 75 d7 ff ff       	call   f0109696 <double_WS_Size>
f010bf21:	83 c4 10             	add    $0x10,%esp
			break;
f010bf24:	eb 11                	jmp    f010bf37 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010bf26:	83 ec 08             	sub    $0x8,%esp
f010bf29:	6a 00                	push   $0x0
f010bf2b:	ff 75 08             	pushl  0x8(%ebp)
f010bf2e:	e8 63 d7 ff ff       	call   f0109696 <double_WS_Size>
f010bf33:	83 c4 10             	add    $0x10,%esp
			break;
f010bf36:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bf37:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf3a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bf40:	83 ec 08             	sub    $0x8,%esp
f010bf43:	50                   	push   %eax
f010bf44:	68 85 81 12 f0       	push   $0xf0128185
f010bf49:	e8 1e 50 ff ff       	call   f0100f6c <cprintf>
f010bf4e:	83 c4 10             	add    $0x10,%esp
f010bf51:	eb 01                	jmp    f010bf54 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bf53:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bf54:	c9                   	leave  
f010bf55:	c3                   	ret    

f010bf56 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bf56:	55                   	push   %ebp
f010bf57:	89 e5                	mov    %esp,%ebp
f010bf59:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bf5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf63:	eb 29                	jmp    f010bf8e <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bf65:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf68:	89 d0                	mov    %edx,%eax
f010bf6a:	01 c0                	add    %eax,%eax
f010bf6c:	01 d0                	add    %edx,%eax
f010bf6e:	c1 e0 02             	shl    $0x2,%eax
f010bf71:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010bf76:	8b 00                	mov    (%eax),%eax
f010bf78:	83 ec 08             	sub    $0x8,%esp
f010bf7b:	50                   	push   %eax
f010bf7c:	ff 75 08             	pushl  0x8(%ebp)
f010bf7f:	e8 5d 67 01 00       	call   f01226e1 <strcmp>
f010bf84:	83 c4 10             	add    $0x10,%esp
f010bf87:	85 c0                	test   %eax,%eax
f010bf89:	74 0f                	je     f010bf9a <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bf8b:	ff 45 f4             	incl   -0xc(%ebp)
f010bf8e:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010bf93:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bf96:	7c cd                	jl     f010bf65 <get_user_program_info+0xf>
f010bf98:	eb 01                	jmp    f010bf9b <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bf9a:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bf9b:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010bfa0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bfa3:	75 1a                	jne    f010bfbf <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bfa5:	83 ec 08             	sub    $0x8,%esp
f010bfa8:	ff 75 08             	pushl  0x8(%ebp)
f010bfab:	68 09 8f 12 f0       	push   $0xf0128f09
f010bfb0:	e8 b7 4f ff ff       	call   f0100f6c <cprintf>
f010bfb5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bfb8:	b8 00 00 00 00       	mov    $0x0,%eax
f010bfbd:	eb 11                	jmp    f010bfd0 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010bfbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfc2:	89 d0                	mov    %edx,%eax
f010bfc4:	01 c0                	add    %eax,%eax
f010bfc6:	01 d0                	add    %edx,%eax
f010bfc8:	c1 e0 02             	shl    $0x2,%eax
f010bfcb:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010bfd0:	c9                   	leave  
f010bfd1:	c3                   	ret    

f010bfd2 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010bfd2:	55                   	push   %ebp
f010bfd3:	89 e5                	mov    %esp,%ebp
f010bfd5:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bfd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bfdf:	eb 2d                	jmp    f010c00e <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010bfe1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfe4:	89 d0                	mov    %edx,%eax
f010bfe6:	01 c0                	add    %eax,%eax
f010bfe8:	01 d0                	add    %edx,%eax
f010bfea:	c1 e0 02             	shl    $0x2,%eax
f010bfed:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010bff2:	8b 00                	mov    (%eax),%eax
f010bff4:	8b 55 08             	mov    0x8(%ebp),%edx
f010bff7:	83 c2 20             	add    $0x20,%edx
f010bffa:	83 ec 08             	sub    $0x8,%esp
f010bffd:	50                   	push   %eax
f010bffe:	52                   	push   %edx
f010bfff:	e8 dd 66 01 00       	call   f01226e1 <strcmp>
f010c004:	83 c4 10             	add    $0x10,%esp
f010c007:	85 c0                	test   %eax,%eax
f010c009:	74 0f                	je     f010c01a <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c00b:	ff 45 f4             	incl   -0xc(%ebp)
f010c00e:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010c013:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c016:	7c c9                	jl     f010bfe1 <get_user_program_info_by_env+0xf>
f010c018:	eb 01                	jmp    f010c01b <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010c01a:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c01b:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010c020:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c023:	75 17                	jne    f010c03c <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010c025:	83 ec 0c             	sub    $0xc,%esp
f010c028:	68 24 8f 12 f0       	push   $0xf0128f24
f010c02d:	e8 3a 4f ff ff       	call   f0100f6c <cprintf>
f010c032:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c035:	b8 00 00 00 00       	mov    $0x0,%eax
f010c03a:	eb 11                	jmp    f010c04d <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c03c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c03f:	89 d0                	mov    %edx,%eax
f010c041:	01 c0                	add    %eax,%eax
f010c043:	01 d0                	add    %edx,%eax
f010c045:	c1 e0 02             	shl    $0x2,%eax
f010c048:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010c04d:	c9                   	leave  
f010c04e:	c3                   	ret    

f010c04f <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c04f:	55                   	push   %ebp
f010c050:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c052:	8b 45 08             	mov    0x8(%ebp),%eax
f010c055:	83 f8 13             	cmp    $0x13,%eax
f010c058:	77 0c                	ja     f010c066 <trapname+0x17>
		return excnames[trapno];
f010c05a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c05d:	8b 04 85 00 93 12 f0 	mov    -0xfed6d00(,%eax,4),%eax
f010c064:	eb 2c                	jmp    f010c092 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c066:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c06a:	75 07                	jne    f010c073 <trapname+0x24>
		return "System call";
f010c06c:	b8 40 8f 12 f0       	mov    $0xf0128f40,%eax
f010c071:	eb 1f                	jmp    f010c092 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c073:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c077:	75 07                	jne    f010c080 <trapname+0x31>
		return "Clock Interrupt";
f010c079:	b8 4c 8f 12 f0       	mov    $0xf0128f4c,%eax
f010c07e:	eb 12                	jmp    f010c092 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c080:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c084:	75 07                	jne    f010c08d <trapname+0x3e>
		return "Keyboard Interrupt";
f010c086:	b8 5c 8f 12 f0       	mov    $0xf0128f5c,%eax
f010c08b:	eb 05                	jmp    f010c092 <trapname+0x43>
	return "(unknown trap)";
f010c08d:	b8 6f 8f 12 f0       	mov    $0xf0128f6f,%eax
}
f010c092:	5d                   	pop    %ebp
f010c093:	c3                   	ret    

f010c094 <ts_init>:


void ts_init(void)
{
f010c094:	55                   	push   %ebp
f010c095:	89 e5                	mov    %esp,%ebp
f010c097:	53                   	push   %ebx
f010c098:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c09b:	e8 20 b1 ff ff       	call   f01071c0 <pushcli>

	struct cpu* c = mycpu();
f010c0a0:	e8 58 b0 ff ff       	call   f01070fd <mycpu>
f010c0a5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c0a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0ab:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c0b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0b5:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c0bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0be:	83 c0 0c             	add    $0xc,%eax
f010c0c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0c4:	83 c2 0c             	add    $0xc,%edx
f010c0c7:	c1 ea 10             	shr    $0x10,%edx
f010c0ca:	88 d3                	mov    %dl,%bl
f010c0cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0cf:	83 c2 0c             	add    $0xc,%edx
f010c0d2:	c1 ea 18             	shr    $0x18,%edx
f010c0d5:	88 d1                	mov    %dl,%cl
f010c0d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0da:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c0e1:	68 00 
f010c0e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0e6:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c0ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0f0:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c0f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0f9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0ff:	83 e2 f0             	and    $0xfffffff0,%edx
f010c102:	83 ca 09             	or     $0x9,%edx
f010c105:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c10b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c10e:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c114:	83 ca 10             	or     $0x10,%edx
f010c117:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c11d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c120:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c126:	83 e2 9f             	and    $0xffffff9f,%edx
f010c129:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c12f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c132:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c138:	83 ca 80             	or     $0xffffff80,%edx
f010c13b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c141:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c144:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c14a:	83 e2 f0             	and    $0xfffffff0,%edx
f010c14d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c156:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c15c:	83 e2 ef             	and    $0xffffffef,%edx
f010c15f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c165:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c168:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c16e:	83 e2 df             	and    $0xffffffdf,%edx
f010c171:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c177:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c17a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c180:	83 ca 40             	or     $0x40,%edx
f010c183:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c189:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c18c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c192:	83 e2 7f             	and    $0x7f,%edx
f010c195:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c19b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c19e:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c1a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1a7:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c1ad:	83 e2 ef             	and    $0xffffffef,%edx
f010c1b0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010c1b6:	e8 57 b0 ff ff       	call   f0107212 <popcli>
f010c1bb:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c1c1:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c1c5:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010c1c8:	90                   	nop
f010c1c9:	83 c4 14             	add    $0x14,%esp
f010c1cc:	5b                   	pop    %ebx
f010c1cd:	5d                   	pop    %ebp
f010c1ce:	c3                   	ret    

f010c1cf <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010c1cf:	55                   	push   %ebp
f010c1d0:	89 e5                	mov    %esp,%ebp
f010c1d2:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010c1d5:	b8 7e d6 10 f0       	mov    $0xf010d67e,%eax
f010c1da:	66 a3 20 04 5a f0    	mov    %ax,0xf05a0420
f010c1e0:	66 c7 05 22 04 5a f0 	movw   $0x8,0xf05a0422
f010c1e7:	08 00 
f010c1e9:	a0 24 04 5a f0       	mov    0xf05a0424,%al
f010c1ee:	83 e0 e0             	and    $0xffffffe0,%eax
f010c1f1:	a2 24 04 5a f0       	mov    %al,0xf05a0424
f010c1f6:	a0 24 04 5a f0       	mov    0xf05a0424,%al
f010c1fb:	83 e0 1f             	and    $0x1f,%eax
f010c1fe:	a2 24 04 5a f0       	mov    %al,0xf05a0424
f010c203:	a0 25 04 5a f0       	mov    0xf05a0425,%al
f010c208:	83 e0 f0             	and    $0xfffffff0,%eax
f010c20b:	83 c8 0e             	or     $0xe,%eax
f010c20e:	a2 25 04 5a f0       	mov    %al,0xf05a0425
f010c213:	a0 25 04 5a f0       	mov    0xf05a0425,%al
f010c218:	83 e0 ef             	and    $0xffffffef,%eax
f010c21b:	a2 25 04 5a f0       	mov    %al,0xf05a0425
f010c220:	a0 25 04 5a f0       	mov    0xf05a0425,%al
f010c225:	83 e0 9f             	and    $0xffffff9f,%eax
f010c228:	a2 25 04 5a f0       	mov    %al,0xf05a0425
f010c22d:	a0 25 04 5a f0       	mov    0xf05a0425,%al
f010c232:	83 c8 80             	or     $0xffffff80,%eax
f010c235:	a2 25 04 5a f0       	mov    %al,0xf05a0425
f010c23a:	b8 7e d6 10 f0       	mov    $0xf010d67e,%eax
f010c23f:	c1 e8 10             	shr    $0x10,%eax
f010c242:	66 a3 26 04 5a f0    	mov    %ax,0xf05a0426
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010c248:	b8 86 d6 10 f0       	mov    $0xf010d686,%eax
f010c24d:	66 a3 50 04 5a f0    	mov    %ax,0xf05a0450
f010c253:	66 c7 05 52 04 5a f0 	movw   $0x8,0xf05a0452
f010c25a:	08 00 
f010c25c:	a0 54 04 5a f0       	mov    0xf05a0454,%al
f010c261:	83 e0 e0             	and    $0xffffffe0,%eax
f010c264:	a2 54 04 5a f0       	mov    %al,0xf05a0454
f010c269:	a0 54 04 5a f0       	mov    0xf05a0454,%al
f010c26e:	83 e0 1f             	and    $0x1f,%eax
f010c271:	a2 54 04 5a f0       	mov    %al,0xf05a0454
f010c276:	a0 55 04 5a f0       	mov    0xf05a0455,%al
f010c27b:	83 e0 f0             	and    $0xfffffff0,%eax
f010c27e:	83 c8 0e             	or     $0xe,%eax
f010c281:	a2 55 04 5a f0       	mov    %al,0xf05a0455
f010c286:	a0 55 04 5a f0       	mov    0xf05a0455,%al
f010c28b:	83 e0 ef             	and    $0xffffffef,%eax
f010c28e:	a2 55 04 5a f0       	mov    %al,0xf05a0455
f010c293:	a0 55 04 5a f0       	mov    0xf05a0455,%al
f010c298:	83 e0 9f             	and    $0xffffff9f,%eax
f010c29b:	a2 55 04 5a f0       	mov    %al,0xf05a0455
f010c2a0:	a0 55 04 5a f0       	mov    0xf05a0455,%al
f010c2a5:	83 c8 80             	or     $0xffffff80,%eax
f010c2a8:	a2 55 04 5a f0       	mov    %al,0xf05a0455
f010c2ad:	b8 86 d6 10 f0       	mov    $0xf010d686,%eax
f010c2b2:	c1 e8 10             	shr    $0x10,%eax
f010c2b5:	66 a3 56 04 5a f0    	mov    %ax,0xf05a0456
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010c2bb:	b8 8e d6 10 f0       	mov    $0xf010d68e,%eax
f010c2c0:	66 a3 e0 04 5a f0    	mov    %ax,0xf05a04e0
f010c2c6:	66 c7 05 e2 04 5a f0 	movw   $0x8,0xf05a04e2
f010c2cd:	08 00 
f010c2cf:	a0 e4 04 5a f0       	mov    0xf05a04e4,%al
f010c2d4:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2d7:	a2 e4 04 5a f0       	mov    %al,0xf05a04e4
f010c2dc:	a0 e4 04 5a f0       	mov    0xf05a04e4,%al
f010c2e1:	83 e0 1f             	and    $0x1f,%eax
f010c2e4:	a2 e4 04 5a f0       	mov    %al,0xf05a04e4
f010c2e9:	a0 e5 04 5a f0       	mov    0xf05a04e5,%al
f010c2ee:	83 e0 f0             	and    $0xfffffff0,%eax
f010c2f1:	83 c8 0e             	or     $0xe,%eax
f010c2f4:	a2 e5 04 5a f0       	mov    %al,0xf05a04e5
f010c2f9:	a0 e5 04 5a f0       	mov    0xf05a04e5,%al
f010c2fe:	83 e0 ef             	and    $0xffffffef,%eax
f010c301:	a2 e5 04 5a f0       	mov    %al,0xf05a04e5
f010c306:	a0 e5 04 5a f0       	mov    0xf05a04e5,%al
f010c30b:	83 c8 60             	or     $0x60,%eax
f010c30e:	a2 e5 04 5a f0       	mov    %al,0xf05a04e5
f010c313:	a0 e5 04 5a f0       	mov    0xf05a04e5,%al
f010c318:	83 c8 80             	or     $0xffffff80,%eax
f010c31b:	a2 e5 04 5a f0       	mov    %al,0xf05a04e5
f010c320:	b8 8e d6 10 f0       	mov    $0xf010d68e,%eax
f010c325:	c1 e8 10             	shr    $0x10,%eax
f010c328:	66 a3 e6 04 5a f0    	mov    %ax,0xf05a04e6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c32e:	b8 98 d6 10 f0       	mov    $0xf010d698,%eax
f010c333:	66 a3 e8 04 5a f0    	mov    %ax,0xf05a04e8
f010c339:	66 c7 05 ea 04 5a f0 	movw   $0x8,0xf05a04ea
f010c340:	08 00 
f010c342:	a0 ec 04 5a f0       	mov    0xf05a04ec,%al
f010c347:	83 e0 e0             	and    $0xffffffe0,%eax
f010c34a:	a2 ec 04 5a f0       	mov    %al,0xf05a04ec
f010c34f:	a0 ec 04 5a f0       	mov    0xf05a04ec,%al
f010c354:	83 e0 1f             	and    $0x1f,%eax
f010c357:	a2 ec 04 5a f0       	mov    %al,0xf05a04ec
f010c35c:	a0 ed 04 5a f0       	mov    0xf05a04ed,%al
f010c361:	83 e0 f0             	and    $0xfffffff0,%eax
f010c364:	83 c8 0e             	or     $0xe,%eax
f010c367:	a2 ed 04 5a f0       	mov    %al,0xf05a04ed
f010c36c:	a0 ed 04 5a f0       	mov    0xf05a04ed,%al
f010c371:	83 e0 ef             	and    $0xffffffef,%eax
f010c374:	a2 ed 04 5a f0       	mov    %al,0xf05a04ed
f010c379:	a0 ed 04 5a f0       	mov    0xf05a04ed,%al
f010c37e:	83 c8 60             	or     $0x60,%eax
f010c381:	a2 ed 04 5a f0       	mov    %al,0xf05a04ed
f010c386:	a0 ed 04 5a f0       	mov    0xf05a04ed,%al
f010c38b:	83 c8 80             	or     $0xffffff80,%eax
f010c38e:	a2 ed 04 5a f0       	mov    %al,0xf05a04ed
f010c393:	b8 98 d6 10 f0       	mov    $0xf010d698,%eax
f010c398:	c1 e8 10             	shr    $0x10,%eax
f010c39b:	66 a3 ee 04 5a f0    	mov    %ax,0xf05a04ee
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c3a1:	b8 a2 d6 10 f0       	mov    $0xf010d6a2,%eax
f010c3a6:	66 a3 60 05 5a f0    	mov    %ax,0xf05a0560
f010c3ac:	66 c7 05 62 05 5a f0 	movw   $0x8,0xf05a0562
f010c3b3:	08 00 
f010c3b5:	a0 64 05 5a f0       	mov    0xf05a0564,%al
f010c3ba:	83 e0 e0             	and    $0xffffffe0,%eax
f010c3bd:	a2 64 05 5a f0       	mov    %al,0xf05a0564
f010c3c2:	a0 64 05 5a f0       	mov    0xf05a0564,%al
f010c3c7:	83 e0 1f             	and    $0x1f,%eax
f010c3ca:	a2 64 05 5a f0       	mov    %al,0xf05a0564
f010c3cf:	a0 65 05 5a f0       	mov    0xf05a0565,%al
f010c3d4:	83 e0 f0             	and    $0xfffffff0,%eax
f010c3d7:	83 c8 0e             	or     $0xe,%eax
f010c3da:	a2 65 05 5a f0       	mov    %al,0xf05a0565
f010c3df:	a0 65 05 5a f0       	mov    0xf05a0565,%al
f010c3e4:	83 e0 ef             	and    $0xffffffef,%eax
f010c3e7:	a2 65 05 5a f0       	mov    %al,0xf05a0565
f010c3ec:	a0 65 05 5a f0       	mov    0xf05a0565,%al
f010c3f1:	83 c8 60             	or     $0x60,%eax
f010c3f4:	a2 65 05 5a f0       	mov    %al,0xf05a0565
f010c3f9:	a0 65 05 5a f0       	mov    0xf05a0565,%al
f010c3fe:	83 c8 80             	or     $0xffffff80,%eax
f010c401:	a2 65 05 5a f0       	mov    %al,0xf05a0565
f010c406:	b8 a2 d6 10 f0       	mov    $0xf010d6a2,%eax
f010c40b:	c1 e8 10             	shr    $0x10,%eax
f010c40e:	66 a3 66 05 5a f0    	mov    %ax,0xf05a0566

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c414:	b8 ac d6 10 f0       	mov    $0xf010d6ac,%eax
f010c419:	66 a3 e0 03 5a f0    	mov    %ax,0xf05a03e0
f010c41f:	66 c7 05 e2 03 5a f0 	movw   $0x8,0xf05a03e2
f010c426:	08 00 
f010c428:	a0 e4 03 5a f0       	mov    0xf05a03e4,%al
f010c42d:	83 e0 e0             	and    $0xffffffe0,%eax
f010c430:	a2 e4 03 5a f0       	mov    %al,0xf05a03e4
f010c435:	a0 e4 03 5a f0       	mov    0xf05a03e4,%al
f010c43a:	83 e0 1f             	and    $0x1f,%eax
f010c43d:	a2 e4 03 5a f0       	mov    %al,0xf05a03e4
f010c442:	a0 e5 03 5a f0       	mov    0xf05a03e5,%al
f010c447:	83 e0 f0             	and    $0xfffffff0,%eax
f010c44a:	83 c8 0e             	or     $0xe,%eax
f010c44d:	a2 e5 03 5a f0       	mov    %al,0xf05a03e5
f010c452:	a0 e5 03 5a f0       	mov    0xf05a03e5,%al
f010c457:	83 e0 ef             	and    $0xffffffef,%eax
f010c45a:	a2 e5 03 5a f0       	mov    %al,0xf05a03e5
f010c45f:	a0 e5 03 5a f0       	mov    0xf05a03e5,%al
f010c464:	83 c8 60             	or     $0x60,%eax
f010c467:	a2 e5 03 5a f0       	mov    %al,0xf05a03e5
f010c46c:	a0 e5 03 5a f0       	mov    0xf05a03e5,%al
f010c471:	83 c8 80             	or     $0xffffff80,%eax
f010c474:	a2 e5 03 5a f0       	mov    %al,0xf05a03e5
f010c479:	b8 ac d6 10 f0       	mov    $0xf010d6ac,%eax
f010c47e:	c1 e8 10             	shr    $0x10,%eax
f010c481:	66 a3 e6 03 5a f0    	mov    %ax,0xf05a03e6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c487:	b8 b6 d6 10 f0       	mov    $0xf010d6b6,%eax
f010c48c:	66 a3 e8 03 5a f0    	mov    %ax,0xf05a03e8
f010c492:	66 c7 05 ea 03 5a f0 	movw   $0x8,0xf05a03ea
f010c499:	08 00 
f010c49b:	a0 ec 03 5a f0       	mov    0xf05a03ec,%al
f010c4a0:	83 e0 e0             	and    $0xffffffe0,%eax
f010c4a3:	a2 ec 03 5a f0       	mov    %al,0xf05a03ec
f010c4a8:	a0 ec 03 5a f0       	mov    0xf05a03ec,%al
f010c4ad:	83 e0 1f             	and    $0x1f,%eax
f010c4b0:	a2 ec 03 5a f0       	mov    %al,0xf05a03ec
f010c4b5:	a0 ed 03 5a f0       	mov    0xf05a03ed,%al
f010c4ba:	83 c8 0f             	or     $0xf,%eax
f010c4bd:	a2 ed 03 5a f0       	mov    %al,0xf05a03ed
f010c4c2:	a0 ed 03 5a f0       	mov    0xf05a03ed,%al
f010c4c7:	83 e0 ef             	and    $0xffffffef,%eax
f010c4ca:	a2 ed 03 5a f0       	mov    %al,0xf05a03ed
f010c4cf:	a0 ed 03 5a f0       	mov    0xf05a03ed,%al
f010c4d4:	83 c8 60             	or     $0x60,%eax
f010c4d7:	a2 ed 03 5a f0       	mov    %al,0xf05a03ed
f010c4dc:	a0 ed 03 5a f0       	mov    0xf05a03ed,%al
f010c4e1:	83 c8 80             	or     $0xffffff80,%eax
f010c4e4:	a2 ed 03 5a f0       	mov    %al,0xf05a03ed
f010c4e9:	b8 b6 d6 10 f0       	mov    $0xf010d6b6,%eax
f010c4ee:	c1 e8 10             	shr    $0x10,%eax
f010c4f1:	66 a3 ee 03 5a f0    	mov    %ax,0xf05a03ee
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c4f7:	b8 c0 d6 10 f0       	mov    $0xf010d6c0,%eax
f010c4fc:	66 a3 f0 03 5a f0    	mov    %ax,0xf05a03f0
f010c502:	66 c7 05 f2 03 5a f0 	movw   $0x8,0xf05a03f2
f010c509:	08 00 
f010c50b:	a0 f4 03 5a f0       	mov    0xf05a03f4,%al
f010c510:	83 e0 e0             	and    $0xffffffe0,%eax
f010c513:	a2 f4 03 5a f0       	mov    %al,0xf05a03f4
f010c518:	a0 f4 03 5a f0       	mov    0xf05a03f4,%al
f010c51d:	83 e0 1f             	and    $0x1f,%eax
f010c520:	a2 f4 03 5a f0       	mov    %al,0xf05a03f4
f010c525:	a0 f5 03 5a f0       	mov    0xf05a03f5,%al
f010c52a:	83 e0 f0             	and    $0xfffffff0,%eax
f010c52d:	83 c8 0e             	or     $0xe,%eax
f010c530:	a2 f5 03 5a f0       	mov    %al,0xf05a03f5
f010c535:	a0 f5 03 5a f0       	mov    0xf05a03f5,%al
f010c53a:	83 e0 ef             	and    $0xffffffef,%eax
f010c53d:	a2 f5 03 5a f0       	mov    %al,0xf05a03f5
f010c542:	a0 f5 03 5a f0       	mov    0xf05a03f5,%al
f010c547:	83 c8 60             	or     $0x60,%eax
f010c54a:	a2 f5 03 5a f0       	mov    %al,0xf05a03f5
f010c54f:	a0 f5 03 5a f0       	mov    0xf05a03f5,%al
f010c554:	83 c8 80             	or     $0xffffff80,%eax
f010c557:	a2 f5 03 5a f0       	mov    %al,0xf05a03f5
f010c55c:	b8 c0 d6 10 f0       	mov    $0xf010d6c0,%eax
f010c561:	c1 e8 10             	shr    $0x10,%eax
f010c564:	66 a3 f6 03 5a f0    	mov    %ax,0xf05a03f6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c56a:	b8 ca d6 10 f0       	mov    $0xf010d6ca,%eax
f010c56f:	66 a3 f8 03 5a f0    	mov    %ax,0xf05a03f8
f010c575:	66 c7 05 fa 03 5a f0 	movw   $0x8,0xf05a03fa
f010c57c:	08 00 
f010c57e:	a0 fc 03 5a f0       	mov    0xf05a03fc,%al
f010c583:	83 e0 e0             	and    $0xffffffe0,%eax
f010c586:	a2 fc 03 5a f0       	mov    %al,0xf05a03fc
f010c58b:	a0 fc 03 5a f0       	mov    0xf05a03fc,%al
f010c590:	83 e0 1f             	and    $0x1f,%eax
f010c593:	a2 fc 03 5a f0       	mov    %al,0xf05a03fc
f010c598:	a0 fd 03 5a f0       	mov    0xf05a03fd,%al
f010c59d:	83 c8 0f             	or     $0xf,%eax
f010c5a0:	a2 fd 03 5a f0       	mov    %al,0xf05a03fd
f010c5a5:	a0 fd 03 5a f0       	mov    0xf05a03fd,%al
f010c5aa:	83 e0 ef             	and    $0xffffffef,%eax
f010c5ad:	a2 fd 03 5a f0       	mov    %al,0xf05a03fd
f010c5b2:	a0 fd 03 5a f0       	mov    0xf05a03fd,%al
f010c5b7:	83 c8 60             	or     $0x60,%eax
f010c5ba:	a2 fd 03 5a f0       	mov    %al,0xf05a03fd
f010c5bf:	a0 fd 03 5a f0       	mov    0xf05a03fd,%al
f010c5c4:	83 c8 80             	or     $0xffffff80,%eax
f010c5c7:	a2 fd 03 5a f0       	mov    %al,0xf05a03fd
f010c5cc:	b8 ca d6 10 f0       	mov    $0xf010d6ca,%eax
f010c5d1:	c1 e8 10             	shr    $0x10,%eax
f010c5d4:	66 a3 fe 03 5a f0    	mov    %ax,0xf05a03fe
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c5da:	b8 d4 d6 10 f0       	mov    $0xf010d6d4,%eax
f010c5df:	66 a3 00 04 5a f0    	mov    %ax,0xf05a0400
f010c5e5:	66 c7 05 02 04 5a f0 	movw   $0x8,0xf05a0402
f010c5ec:	08 00 
f010c5ee:	a0 04 04 5a f0       	mov    0xf05a0404,%al
f010c5f3:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5f6:	a2 04 04 5a f0       	mov    %al,0xf05a0404
f010c5fb:	a0 04 04 5a f0       	mov    0xf05a0404,%al
f010c600:	83 e0 1f             	and    $0x1f,%eax
f010c603:	a2 04 04 5a f0       	mov    %al,0xf05a0404
f010c608:	a0 05 04 5a f0       	mov    0xf05a0405,%al
f010c60d:	83 c8 0f             	or     $0xf,%eax
f010c610:	a2 05 04 5a f0       	mov    %al,0xf05a0405
f010c615:	a0 05 04 5a f0       	mov    0xf05a0405,%al
f010c61a:	83 e0 ef             	and    $0xffffffef,%eax
f010c61d:	a2 05 04 5a f0       	mov    %al,0xf05a0405
f010c622:	a0 05 04 5a f0       	mov    0xf05a0405,%al
f010c627:	83 c8 60             	or     $0x60,%eax
f010c62a:	a2 05 04 5a f0       	mov    %al,0xf05a0405
f010c62f:	a0 05 04 5a f0       	mov    0xf05a0405,%al
f010c634:	83 c8 80             	or     $0xffffff80,%eax
f010c637:	a2 05 04 5a f0       	mov    %al,0xf05a0405
f010c63c:	b8 d4 d6 10 f0       	mov    $0xf010d6d4,%eax
f010c641:	c1 e8 10             	shr    $0x10,%eax
f010c644:	66 a3 06 04 5a f0    	mov    %ax,0xf05a0406
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c64a:	b8 de d6 10 f0       	mov    $0xf010d6de,%eax
f010c64f:	66 a3 08 04 5a f0    	mov    %ax,0xf05a0408
f010c655:	66 c7 05 0a 04 5a f0 	movw   $0x8,0xf05a040a
f010c65c:	08 00 
f010c65e:	a0 0c 04 5a f0       	mov    0xf05a040c,%al
f010c663:	83 e0 e0             	and    $0xffffffe0,%eax
f010c666:	a2 0c 04 5a f0       	mov    %al,0xf05a040c
f010c66b:	a0 0c 04 5a f0       	mov    0xf05a040c,%al
f010c670:	83 e0 1f             	and    $0x1f,%eax
f010c673:	a2 0c 04 5a f0       	mov    %al,0xf05a040c
f010c678:	a0 0d 04 5a f0       	mov    0xf05a040d,%al
f010c67d:	83 e0 f0             	and    $0xfffffff0,%eax
f010c680:	83 c8 0e             	or     $0xe,%eax
f010c683:	a2 0d 04 5a f0       	mov    %al,0xf05a040d
f010c688:	a0 0d 04 5a f0       	mov    0xf05a040d,%al
f010c68d:	83 e0 ef             	and    $0xffffffef,%eax
f010c690:	a2 0d 04 5a f0       	mov    %al,0xf05a040d
f010c695:	a0 0d 04 5a f0       	mov    0xf05a040d,%al
f010c69a:	83 c8 60             	or     $0x60,%eax
f010c69d:	a2 0d 04 5a f0       	mov    %al,0xf05a040d
f010c6a2:	a0 0d 04 5a f0       	mov    0xf05a040d,%al
f010c6a7:	83 c8 80             	or     $0xffffff80,%eax
f010c6aa:	a2 0d 04 5a f0       	mov    %al,0xf05a040d
f010c6af:	b8 de d6 10 f0       	mov    $0xf010d6de,%eax
f010c6b4:	c1 e8 10             	shr    $0x10,%eax
f010c6b7:	66 a3 0e 04 5a f0    	mov    %ax,0xf05a040e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c6bd:	b8 e8 d6 10 f0       	mov    $0xf010d6e8,%eax
f010c6c2:	66 a3 10 04 5a f0    	mov    %ax,0xf05a0410
f010c6c8:	66 c7 05 12 04 5a f0 	movw   $0x8,0xf05a0412
f010c6cf:	08 00 
f010c6d1:	a0 14 04 5a f0       	mov    0xf05a0414,%al
f010c6d6:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6d9:	a2 14 04 5a f0       	mov    %al,0xf05a0414
f010c6de:	a0 14 04 5a f0       	mov    0xf05a0414,%al
f010c6e3:	83 e0 1f             	and    $0x1f,%eax
f010c6e6:	a2 14 04 5a f0       	mov    %al,0xf05a0414
f010c6eb:	a0 15 04 5a f0       	mov    0xf05a0415,%al
f010c6f0:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6f3:	83 c8 0e             	or     $0xe,%eax
f010c6f6:	a2 15 04 5a f0       	mov    %al,0xf05a0415
f010c6fb:	a0 15 04 5a f0       	mov    0xf05a0415,%al
f010c700:	83 e0 ef             	and    $0xffffffef,%eax
f010c703:	a2 15 04 5a f0       	mov    %al,0xf05a0415
f010c708:	a0 15 04 5a f0       	mov    0xf05a0415,%al
f010c70d:	83 c8 60             	or     $0x60,%eax
f010c710:	a2 15 04 5a f0       	mov    %al,0xf05a0415
f010c715:	a0 15 04 5a f0       	mov    0xf05a0415,%al
f010c71a:	83 c8 80             	or     $0xffffff80,%eax
f010c71d:	a2 15 04 5a f0       	mov    %al,0xf05a0415
f010c722:	b8 e8 d6 10 f0       	mov    $0xf010d6e8,%eax
f010c727:	c1 e8 10             	shr    $0x10,%eax
f010c72a:	66 a3 16 04 5a f0    	mov    %ax,0xf05a0416
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c730:	b8 f2 d6 10 f0       	mov    $0xf010d6f2,%eax
f010c735:	66 a3 18 04 5a f0    	mov    %ax,0xf05a0418
f010c73b:	66 c7 05 1a 04 5a f0 	movw   $0x8,0xf05a041a
f010c742:	08 00 
f010c744:	a0 1c 04 5a f0       	mov    0xf05a041c,%al
f010c749:	83 e0 e0             	and    $0xffffffe0,%eax
f010c74c:	a2 1c 04 5a f0       	mov    %al,0xf05a041c
f010c751:	a0 1c 04 5a f0       	mov    0xf05a041c,%al
f010c756:	83 e0 1f             	and    $0x1f,%eax
f010c759:	a2 1c 04 5a f0       	mov    %al,0xf05a041c
f010c75e:	a0 1d 04 5a f0       	mov    0xf05a041d,%al
f010c763:	83 e0 f0             	and    $0xfffffff0,%eax
f010c766:	83 c8 0e             	or     $0xe,%eax
f010c769:	a2 1d 04 5a f0       	mov    %al,0xf05a041d
f010c76e:	a0 1d 04 5a f0       	mov    0xf05a041d,%al
f010c773:	83 e0 ef             	and    $0xffffffef,%eax
f010c776:	a2 1d 04 5a f0       	mov    %al,0xf05a041d
f010c77b:	a0 1d 04 5a f0       	mov    0xf05a041d,%al
f010c780:	83 c8 60             	or     $0x60,%eax
f010c783:	a2 1d 04 5a f0       	mov    %al,0xf05a041d
f010c788:	a0 1d 04 5a f0       	mov    0xf05a041d,%al
f010c78d:	83 c8 80             	or     $0xffffff80,%eax
f010c790:	a2 1d 04 5a f0       	mov    %al,0xf05a041d
f010c795:	b8 f2 d6 10 f0       	mov    $0xf010d6f2,%eax
f010c79a:	c1 e8 10             	shr    $0x10,%eax
f010c79d:	66 a3 1e 04 5a f0    	mov    %ax,0xf05a041e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c7a3:	b8 f8 d6 10 f0       	mov    $0xf010d6f8,%eax
f010c7a8:	66 a3 30 04 5a f0    	mov    %ax,0xf05a0430
f010c7ae:	66 c7 05 32 04 5a f0 	movw   $0x8,0xf05a0432
f010c7b5:	08 00 
f010c7b7:	a0 34 04 5a f0       	mov    0xf05a0434,%al
f010c7bc:	83 e0 e0             	and    $0xffffffe0,%eax
f010c7bf:	a2 34 04 5a f0       	mov    %al,0xf05a0434
f010c7c4:	a0 34 04 5a f0       	mov    0xf05a0434,%al
f010c7c9:	83 e0 1f             	and    $0x1f,%eax
f010c7cc:	a2 34 04 5a f0       	mov    %al,0xf05a0434
f010c7d1:	a0 35 04 5a f0       	mov    0xf05a0435,%al
f010c7d6:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7d9:	83 c8 0e             	or     $0xe,%eax
f010c7dc:	a2 35 04 5a f0       	mov    %al,0xf05a0435
f010c7e1:	a0 35 04 5a f0       	mov    0xf05a0435,%al
f010c7e6:	83 e0 ef             	and    $0xffffffef,%eax
f010c7e9:	a2 35 04 5a f0       	mov    %al,0xf05a0435
f010c7ee:	a0 35 04 5a f0       	mov    0xf05a0435,%al
f010c7f3:	83 c8 60             	or     $0x60,%eax
f010c7f6:	a2 35 04 5a f0       	mov    %al,0xf05a0435
f010c7fb:	a0 35 04 5a f0       	mov    0xf05a0435,%al
f010c800:	83 c8 80             	or     $0xffffff80,%eax
f010c803:	a2 35 04 5a f0       	mov    %al,0xf05a0435
f010c808:	b8 f8 d6 10 f0       	mov    $0xf010d6f8,%eax
f010c80d:	c1 e8 10             	shr    $0x10,%eax
f010c810:	66 a3 36 04 5a f0    	mov    %ax,0xf05a0436
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c816:	b8 fc d6 10 f0       	mov    $0xf010d6fc,%eax
f010c81b:	66 a3 38 04 5a f0    	mov    %ax,0xf05a0438
f010c821:	66 c7 05 3a 04 5a f0 	movw   $0x8,0xf05a043a
f010c828:	08 00 
f010c82a:	a0 3c 04 5a f0       	mov    0xf05a043c,%al
f010c82f:	83 e0 e0             	and    $0xffffffe0,%eax
f010c832:	a2 3c 04 5a f0       	mov    %al,0xf05a043c
f010c837:	a0 3c 04 5a f0       	mov    0xf05a043c,%al
f010c83c:	83 e0 1f             	and    $0x1f,%eax
f010c83f:	a2 3c 04 5a f0       	mov    %al,0xf05a043c
f010c844:	a0 3d 04 5a f0       	mov    0xf05a043d,%al
f010c849:	83 e0 f0             	and    $0xfffffff0,%eax
f010c84c:	83 c8 0e             	or     $0xe,%eax
f010c84f:	a2 3d 04 5a f0       	mov    %al,0xf05a043d
f010c854:	a0 3d 04 5a f0       	mov    0xf05a043d,%al
f010c859:	83 e0 ef             	and    $0xffffffef,%eax
f010c85c:	a2 3d 04 5a f0       	mov    %al,0xf05a043d
f010c861:	a0 3d 04 5a f0       	mov    0xf05a043d,%al
f010c866:	83 c8 60             	or     $0x60,%eax
f010c869:	a2 3d 04 5a f0       	mov    %al,0xf05a043d
f010c86e:	a0 3d 04 5a f0       	mov    0xf05a043d,%al
f010c873:	83 c8 80             	or     $0xffffff80,%eax
f010c876:	a2 3d 04 5a f0       	mov    %al,0xf05a043d
f010c87b:	b8 fc d6 10 f0       	mov    $0xf010d6fc,%eax
f010c880:	c1 e8 10             	shr    $0x10,%eax
f010c883:	66 a3 3e 04 5a f0    	mov    %ax,0xf05a043e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c889:	b8 00 d7 10 f0       	mov    $0xf010d700,%eax
f010c88e:	66 a3 40 04 5a f0    	mov    %ax,0xf05a0440
f010c894:	66 c7 05 42 04 5a f0 	movw   $0x8,0xf05a0442
f010c89b:	08 00 
f010c89d:	a0 44 04 5a f0       	mov    0xf05a0444,%al
f010c8a2:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8a5:	a2 44 04 5a f0       	mov    %al,0xf05a0444
f010c8aa:	a0 44 04 5a f0       	mov    0xf05a0444,%al
f010c8af:	83 e0 1f             	and    $0x1f,%eax
f010c8b2:	a2 44 04 5a f0       	mov    %al,0xf05a0444
f010c8b7:	a0 45 04 5a f0       	mov    0xf05a0445,%al
f010c8bc:	83 e0 f0             	and    $0xfffffff0,%eax
f010c8bf:	83 c8 0e             	or     $0xe,%eax
f010c8c2:	a2 45 04 5a f0       	mov    %al,0xf05a0445
f010c8c7:	a0 45 04 5a f0       	mov    0xf05a0445,%al
f010c8cc:	83 e0 ef             	and    $0xffffffef,%eax
f010c8cf:	a2 45 04 5a f0       	mov    %al,0xf05a0445
f010c8d4:	a0 45 04 5a f0       	mov    0xf05a0445,%al
f010c8d9:	83 c8 60             	or     $0x60,%eax
f010c8dc:	a2 45 04 5a f0       	mov    %al,0xf05a0445
f010c8e1:	a0 45 04 5a f0       	mov    0xf05a0445,%al
f010c8e6:	83 c8 80             	or     $0xffffff80,%eax
f010c8e9:	a2 45 04 5a f0       	mov    %al,0xf05a0445
f010c8ee:	b8 00 d7 10 f0       	mov    $0xf010d700,%eax
f010c8f3:	c1 e8 10             	shr    $0x10,%eax
f010c8f6:	66 a3 46 04 5a f0    	mov    %ax,0xf05a0446
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c8fc:	b8 04 d7 10 f0       	mov    $0xf010d704,%eax
f010c901:	66 a3 48 04 5a f0    	mov    %ax,0xf05a0448
f010c907:	66 c7 05 4a 04 5a f0 	movw   $0x8,0xf05a044a
f010c90e:	08 00 
f010c910:	a0 4c 04 5a f0       	mov    0xf05a044c,%al
f010c915:	83 e0 e0             	and    $0xffffffe0,%eax
f010c918:	a2 4c 04 5a f0       	mov    %al,0xf05a044c
f010c91d:	a0 4c 04 5a f0       	mov    0xf05a044c,%al
f010c922:	83 e0 1f             	and    $0x1f,%eax
f010c925:	a2 4c 04 5a f0       	mov    %al,0xf05a044c
f010c92a:	a0 4d 04 5a f0       	mov    0xf05a044d,%al
f010c92f:	83 e0 f0             	and    $0xfffffff0,%eax
f010c932:	83 c8 0e             	or     $0xe,%eax
f010c935:	a2 4d 04 5a f0       	mov    %al,0xf05a044d
f010c93a:	a0 4d 04 5a f0       	mov    0xf05a044d,%al
f010c93f:	83 e0 ef             	and    $0xffffffef,%eax
f010c942:	a2 4d 04 5a f0       	mov    %al,0xf05a044d
f010c947:	a0 4d 04 5a f0       	mov    0xf05a044d,%al
f010c94c:	83 c8 60             	or     $0x60,%eax
f010c94f:	a2 4d 04 5a f0       	mov    %al,0xf05a044d
f010c954:	a0 4d 04 5a f0       	mov    0xf05a044d,%al
f010c959:	83 c8 80             	or     $0xffffff80,%eax
f010c95c:	a2 4d 04 5a f0       	mov    %al,0xf05a044d
f010c961:	b8 04 d7 10 f0       	mov    $0xf010d704,%eax
f010c966:	c1 e8 10             	shr    $0x10,%eax
f010c969:	66 a3 4e 04 5a f0    	mov    %ax,0xf05a044e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c96f:	b8 08 d7 10 f0       	mov    $0xf010d708,%eax
f010c974:	66 a3 60 04 5a f0    	mov    %ax,0xf05a0460
f010c97a:	66 c7 05 62 04 5a f0 	movw   $0x8,0xf05a0462
f010c981:	08 00 
f010c983:	a0 64 04 5a f0       	mov    0xf05a0464,%al
f010c988:	83 e0 e0             	and    $0xffffffe0,%eax
f010c98b:	a2 64 04 5a f0       	mov    %al,0xf05a0464
f010c990:	a0 64 04 5a f0       	mov    0xf05a0464,%al
f010c995:	83 e0 1f             	and    $0x1f,%eax
f010c998:	a2 64 04 5a f0       	mov    %al,0xf05a0464
f010c99d:	a0 65 04 5a f0       	mov    0xf05a0465,%al
f010c9a2:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9a5:	83 c8 0e             	or     $0xe,%eax
f010c9a8:	a2 65 04 5a f0       	mov    %al,0xf05a0465
f010c9ad:	a0 65 04 5a f0       	mov    0xf05a0465,%al
f010c9b2:	83 e0 ef             	and    $0xffffffef,%eax
f010c9b5:	a2 65 04 5a f0       	mov    %al,0xf05a0465
f010c9ba:	a0 65 04 5a f0       	mov    0xf05a0465,%al
f010c9bf:	83 c8 60             	or     $0x60,%eax
f010c9c2:	a2 65 04 5a f0       	mov    %al,0xf05a0465
f010c9c7:	a0 65 04 5a f0       	mov    0xf05a0465,%al
f010c9cc:	83 c8 80             	or     $0xffffff80,%eax
f010c9cf:	a2 65 04 5a f0       	mov    %al,0xf05a0465
f010c9d4:	b8 08 d7 10 f0       	mov    $0xf010d708,%eax
f010c9d9:	c1 e8 10             	shr    $0x10,%eax
f010c9dc:	66 a3 66 04 5a f0    	mov    %ax,0xf05a0466
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010c9e2:	b8 0e d7 10 f0       	mov    $0xf010d70e,%eax
f010c9e7:	66 a3 68 04 5a f0    	mov    %ax,0xf05a0468
f010c9ed:	66 c7 05 6a 04 5a f0 	movw   $0x8,0xf05a046a
f010c9f4:	08 00 
f010c9f6:	a0 6c 04 5a f0       	mov    0xf05a046c,%al
f010c9fb:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9fe:	a2 6c 04 5a f0       	mov    %al,0xf05a046c
f010ca03:	a0 6c 04 5a f0       	mov    0xf05a046c,%al
f010ca08:	83 e0 1f             	and    $0x1f,%eax
f010ca0b:	a2 6c 04 5a f0       	mov    %al,0xf05a046c
f010ca10:	a0 6d 04 5a f0       	mov    0xf05a046d,%al
f010ca15:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca18:	83 c8 0e             	or     $0xe,%eax
f010ca1b:	a2 6d 04 5a f0       	mov    %al,0xf05a046d
f010ca20:	a0 6d 04 5a f0       	mov    0xf05a046d,%al
f010ca25:	83 e0 ef             	and    $0xffffffef,%eax
f010ca28:	a2 6d 04 5a f0       	mov    %al,0xf05a046d
f010ca2d:	a0 6d 04 5a f0       	mov    0xf05a046d,%al
f010ca32:	83 c8 60             	or     $0x60,%eax
f010ca35:	a2 6d 04 5a f0       	mov    %al,0xf05a046d
f010ca3a:	a0 6d 04 5a f0       	mov    0xf05a046d,%al
f010ca3f:	83 c8 80             	or     $0xffffff80,%eax
f010ca42:	a2 6d 04 5a f0       	mov    %al,0xf05a046d
f010ca47:	b8 0e d7 10 f0       	mov    $0xf010d70e,%eax
f010ca4c:	c1 e8 10             	shr    $0x10,%eax
f010ca4f:	66 a3 6e 04 5a f0    	mov    %ax,0xf05a046e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010ca55:	b8 12 d7 10 f0       	mov    $0xf010d712,%eax
f010ca5a:	66 a3 70 04 5a f0    	mov    %ax,0xf05a0470
f010ca60:	66 c7 05 72 04 5a f0 	movw   $0x8,0xf05a0472
f010ca67:	08 00 
f010ca69:	a0 74 04 5a f0       	mov    0xf05a0474,%al
f010ca6e:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca71:	a2 74 04 5a f0       	mov    %al,0xf05a0474
f010ca76:	a0 74 04 5a f0       	mov    0xf05a0474,%al
f010ca7b:	83 e0 1f             	and    $0x1f,%eax
f010ca7e:	a2 74 04 5a f0       	mov    %al,0xf05a0474
f010ca83:	a0 75 04 5a f0       	mov    0xf05a0475,%al
f010ca88:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca8b:	83 c8 0e             	or     $0xe,%eax
f010ca8e:	a2 75 04 5a f0       	mov    %al,0xf05a0475
f010ca93:	a0 75 04 5a f0       	mov    0xf05a0475,%al
f010ca98:	83 e0 ef             	and    $0xffffffef,%eax
f010ca9b:	a2 75 04 5a f0       	mov    %al,0xf05a0475
f010caa0:	a0 75 04 5a f0       	mov    0xf05a0475,%al
f010caa5:	83 c8 60             	or     $0x60,%eax
f010caa8:	a2 75 04 5a f0       	mov    %al,0xf05a0475
f010caad:	a0 75 04 5a f0       	mov    0xf05a0475,%al
f010cab2:	83 c8 80             	or     $0xffffff80,%eax
f010cab5:	a2 75 04 5a f0       	mov    %al,0xf05a0475
f010caba:	b8 12 d7 10 f0       	mov    $0xf010d712,%eax
f010cabf:	c1 e8 10             	shr    $0x10,%eax
f010cac2:	66 a3 76 04 5a f0    	mov    %ax,0xf05a0476
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010cac8:	b8 18 d7 10 f0       	mov    $0xf010d718,%eax
f010cacd:	66 a3 78 04 5a f0    	mov    %ax,0xf05a0478
f010cad3:	66 c7 05 7a 04 5a f0 	movw   $0x8,0xf05a047a
f010cada:	08 00 
f010cadc:	a0 7c 04 5a f0       	mov    0xf05a047c,%al
f010cae1:	83 e0 e0             	and    $0xffffffe0,%eax
f010cae4:	a2 7c 04 5a f0       	mov    %al,0xf05a047c
f010cae9:	a0 7c 04 5a f0       	mov    0xf05a047c,%al
f010caee:	83 e0 1f             	and    $0x1f,%eax
f010caf1:	a2 7c 04 5a f0       	mov    %al,0xf05a047c
f010caf6:	a0 7d 04 5a f0       	mov    0xf05a047d,%al
f010cafb:	83 e0 f0             	and    $0xfffffff0,%eax
f010cafe:	83 c8 0e             	or     $0xe,%eax
f010cb01:	a2 7d 04 5a f0       	mov    %al,0xf05a047d
f010cb06:	a0 7d 04 5a f0       	mov    0xf05a047d,%al
f010cb0b:	83 e0 ef             	and    $0xffffffef,%eax
f010cb0e:	a2 7d 04 5a f0       	mov    %al,0xf05a047d
f010cb13:	a0 7d 04 5a f0       	mov    0xf05a047d,%al
f010cb18:	83 c8 60             	or     $0x60,%eax
f010cb1b:	a2 7d 04 5a f0       	mov    %al,0xf05a047d
f010cb20:	a0 7d 04 5a f0       	mov    0xf05a047d,%al
f010cb25:	83 c8 80             	or     $0xffffff80,%eax
f010cb28:	a2 7d 04 5a f0       	mov    %al,0xf05a047d
f010cb2d:	b8 18 d7 10 f0       	mov    $0xf010d718,%eax
f010cb32:	c1 e8 10             	shr    $0x10,%eax
f010cb35:	66 a3 7e 04 5a f0    	mov    %ax,0xf05a047e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010cb3b:	b8 1e d7 10 f0       	mov    $0xf010d71e,%eax
f010cb40:	66 a3 f0 04 5a f0    	mov    %ax,0xf05a04f0
f010cb46:	66 c7 05 f2 04 5a f0 	movw   $0x8,0xf05a04f2
f010cb4d:	08 00 
f010cb4f:	a0 f4 04 5a f0       	mov    0xf05a04f4,%al
f010cb54:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb57:	a2 f4 04 5a f0       	mov    %al,0xf05a04f4
f010cb5c:	a0 f4 04 5a f0       	mov    0xf05a04f4,%al
f010cb61:	83 e0 1f             	and    $0x1f,%eax
f010cb64:	a2 f4 04 5a f0       	mov    %al,0xf05a04f4
f010cb69:	a0 f5 04 5a f0       	mov    0xf05a04f5,%al
f010cb6e:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb71:	83 c8 0e             	or     $0xe,%eax
f010cb74:	a2 f5 04 5a f0       	mov    %al,0xf05a04f5
f010cb79:	a0 f5 04 5a f0       	mov    0xf05a04f5,%al
f010cb7e:	83 e0 ef             	and    $0xffffffef,%eax
f010cb81:	a2 f5 04 5a f0       	mov    %al,0xf05a04f5
f010cb86:	a0 f5 04 5a f0       	mov    0xf05a04f5,%al
f010cb8b:	83 c8 60             	or     $0x60,%eax
f010cb8e:	a2 f5 04 5a f0       	mov    %al,0xf05a04f5
f010cb93:	a0 f5 04 5a f0       	mov    0xf05a04f5,%al
f010cb98:	83 c8 80             	or     $0xffffff80,%eax
f010cb9b:	a2 f5 04 5a f0       	mov    %al,0xf05a04f5
f010cba0:	b8 1e d7 10 f0       	mov    $0xf010d71e,%eax
f010cba5:	c1 e8 10             	shr    $0x10,%eax
f010cba8:	66 a3 f6 04 5a f0    	mov    %ax,0xf05a04f6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010cbae:	b8 24 d7 10 f0       	mov    $0xf010d724,%eax
f010cbb3:	66 a3 f8 04 5a f0    	mov    %ax,0xf05a04f8
f010cbb9:	66 c7 05 fa 04 5a f0 	movw   $0x8,0xf05a04fa
f010cbc0:	08 00 
f010cbc2:	a0 fc 04 5a f0       	mov    0xf05a04fc,%al
f010cbc7:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbca:	a2 fc 04 5a f0       	mov    %al,0xf05a04fc
f010cbcf:	a0 fc 04 5a f0       	mov    0xf05a04fc,%al
f010cbd4:	83 e0 1f             	and    $0x1f,%eax
f010cbd7:	a2 fc 04 5a f0       	mov    %al,0xf05a04fc
f010cbdc:	a0 fd 04 5a f0       	mov    0xf05a04fd,%al
f010cbe1:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbe4:	83 c8 0e             	or     $0xe,%eax
f010cbe7:	a2 fd 04 5a f0       	mov    %al,0xf05a04fd
f010cbec:	a0 fd 04 5a f0       	mov    0xf05a04fd,%al
f010cbf1:	83 e0 ef             	and    $0xffffffef,%eax
f010cbf4:	a2 fd 04 5a f0       	mov    %al,0xf05a04fd
f010cbf9:	a0 fd 04 5a f0       	mov    0xf05a04fd,%al
f010cbfe:	83 c8 60             	or     $0x60,%eax
f010cc01:	a2 fd 04 5a f0       	mov    %al,0xf05a04fd
f010cc06:	a0 fd 04 5a f0       	mov    0xf05a04fd,%al
f010cc0b:	83 c8 80             	or     $0xffffff80,%eax
f010cc0e:	a2 fd 04 5a f0       	mov    %al,0xf05a04fd
f010cc13:	b8 24 d7 10 f0       	mov    $0xf010d724,%eax
f010cc18:	c1 e8 10             	shr    $0x10,%eax
f010cc1b:	66 a3 fe 04 5a f0    	mov    %ax,0xf05a04fe
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010cc21:	b8 2a d7 10 f0       	mov    $0xf010d72a,%eax
f010cc26:	66 a3 00 05 5a f0    	mov    %ax,0xf05a0500
f010cc2c:	66 c7 05 02 05 5a f0 	movw   $0x8,0xf05a0502
f010cc33:	08 00 
f010cc35:	a0 04 05 5a f0       	mov    0xf05a0504,%al
f010cc3a:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc3d:	a2 04 05 5a f0       	mov    %al,0xf05a0504
f010cc42:	a0 04 05 5a f0       	mov    0xf05a0504,%al
f010cc47:	83 e0 1f             	and    $0x1f,%eax
f010cc4a:	a2 04 05 5a f0       	mov    %al,0xf05a0504
f010cc4f:	a0 05 05 5a f0       	mov    0xf05a0505,%al
f010cc54:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc57:	83 c8 0e             	or     $0xe,%eax
f010cc5a:	a2 05 05 5a f0       	mov    %al,0xf05a0505
f010cc5f:	a0 05 05 5a f0       	mov    0xf05a0505,%al
f010cc64:	83 e0 ef             	and    $0xffffffef,%eax
f010cc67:	a2 05 05 5a f0       	mov    %al,0xf05a0505
f010cc6c:	a0 05 05 5a f0       	mov    0xf05a0505,%al
f010cc71:	83 c8 60             	or     $0x60,%eax
f010cc74:	a2 05 05 5a f0       	mov    %al,0xf05a0505
f010cc79:	a0 05 05 5a f0       	mov    0xf05a0505,%al
f010cc7e:	83 c8 80             	or     $0xffffff80,%eax
f010cc81:	a2 05 05 5a f0       	mov    %al,0xf05a0505
f010cc86:	b8 2a d7 10 f0       	mov    $0xf010d72a,%eax
f010cc8b:	c1 e8 10             	shr    $0x10,%eax
f010cc8e:	66 a3 06 05 5a f0    	mov    %ax,0xf05a0506
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010cc94:	b8 30 d7 10 f0       	mov    $0xf010d730,%eax
f010cc99:	66 a3 08 05 5a f0    	mov    %ax,0xf05a0508
f010cc9f:	66 c7 05 0a 05 5a f0 	movw   $0x8,0xf05a050a
f010cca6:	08 00 
f010cca8:	a0 0c 05 5a f0       	mov    0xf05a050c,%al
f010ccad:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccb0:	a2 0c 05 5a f0       	mov    %al,0xf05a050c
f010ccb5:	a0 0c 05 5a f0       	mov    0xf05a050c,%al
f010ccba:	83 e0 1f             	and    $0x1f,%eax
f010ccbd:	a2 0c 05 5a f0       	mov    %al,0xf05a050c
f010ccc2:	a0 0d 05 5a f0       	mov    0xf05a050d,%al
f010ccc7:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccca:	83 c8 0e             	or     $0xe,%eax
f010cccd:	a2 0d 05 5a f0       	mov    %al,0xf05a050d
f010ccd2:	a0 0d 05 5a f0       	mov    0xf05a050d,%al
f010ccd7:	83 e0 ef             	and    $0xffffffef,%eax
f010ccda:	a2 0d 05 5a f0       	mov    %al,0xf05a050d
f010ccdf:	a0 0d 05 5a f0       	mov    0xf05a050d,%al
f010cce4:	83 c8 60             	or     $0x60,%eax
f010cce7:	a2 0d 05 5a f0       	mov    %al,0xf05a050d
f010ccec:	a0 0d 05 5a f0       	mov    0xf05a050d,%al
f010ccf1:	83 c8 80             	or     $0xffffff80,%eax
f010ccf4:	a2 0d 05 5a f0       	mov    %al,0xf05a050d
f010ccf9:	b8 30 d7 10 f0       	mov    $0xf010d730,%eax
f010ccfe:	c1 e8 10             	shr    $0x10,%eax
f010cd01:	66 a3 0e 05 5a f0    	mov    %ax,0xf05a050e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010cd07:	b8 36 d7 10 f0       	mov    $0xf010d736,%eax
f010cd0c:	66 a3 10 05 5a f0    	mov    %ax,0xf05a0510
f010cd12:	66 c7 05 12 05 5a f0 	movw   $0x8,0xf05a0512
f010cd19:	08 00 
f010cd1b:	a0 14 05 5a f0       	mov    0xf05a0514,%al
f010cd20:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd23:	a2 14 05 5a f0       	mov    %al,0xf05a0514
f010cd28:	a0 14 05 5a f0       	mov    0xf05a0514,%al
f010cd2d:	83 e0 1f             	and    $0x1f,%eax
f010cd30:	a2 14 05 5a f0       	mov    %al,0xf05a0514
f010cd35:	a0 15 05 5a f0       	mov    0xf05a0515,%al
f010cd3a:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd3d:	83 c8 0e             	or     $0xe,%eax
f010cd40:	a2 15 05 5a f0       	mov    %al,0xf05a0515
f010cd45:	a0 15 05 5a f0       	mov    0xf05a0515,%al
f010cd4a:	83 e0 ef             	and    $0xffffffef,%eax
f010cd4d:	a2 15 05 5a f0       	mov    %al,0xf05a0515
f010cd52:	a0 15 05 5a f0       	mov    0xf05a0515,%al
f010cd57:	83 c8 60             	or     $0x60,%eax
f010cd5a:	a2 15 05 5a f0       	mov    %al,0xf05a0515
f010cd5f:	a0 15 05 5a f0       	mov    0xf05a0515,%al
f010cd64:	83 c8 80             	or     $0xffffff80,%eax
f010cd67:	a2 15 05 5a f0       	mov    %al,0xf05a0515
f010cd6c:	b8 36 d7 10 f0       	mov    $0xf010d736,%eax
f010cd71:	c1 e8 10             	shr    $0x10,%eax
f010cd74:	66 a3 16 05 5a f0    	mov    %ax,0xf05a0516
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010cd7a:	b8 3c d7 10 f0       	mov    $0xf010d73c,%eax
f010cd7f:	66 a3 18 05 5a f0    	mov    %ax,0xf05a0518
f010cd85:	66 c7 05 1a 05 5a f0 	movw   $0x8,0xf05a051a
f010cd8c:	08 00 
f010cd8e:	a0 1c 05 5a f0       	mov    0xf05a051c,%al
f010cd93:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd96:	a2 1c 05 5a f0       	mov    %al,0xf05a051c
f010cd9b:	a0 1c 05 5a f0       	mov    0xf05a051c,%al
f010cda0:	83 e0 1f             	and    $0x1f,%eax
f010cda3:	a2 1c 05 5a f0       	mov    %al,0xf05a051c
f010cda8:	a0 1d 05 5a f0       	mov    0xf05a051d,%al
f010cdad:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdb0:	83 c8 0e             	or     $0xe,%eax
f010cdb3:	a2 1d 05 5a f0       	mov    %al,0xf05a051d
f010cdb8:	a0 1d 05 5a f0       	mov    0xf05a051d,%al
f010cdbd:	83 e0 ef             	and    $0xffffffef,%eax
f010cdc0:	a2 1d 05 5a f0       	mov    %al,0xf05a051d
f010cdc5:	a0 1d 05 5a f0       	mov    0xf05a051d,%al
f010cdca:	83 c8 60             	or     $0x60,%eax
f010cdcd:	a2 1d 05 5a f0       	mov    %al,0xf05a051d
f010cdd2:	a0 1d 05 5a f0       	mov    0xf05a051d,%al
f010cdd7:	83 c8 80             	or     $0xffffff80,%eax
f010cdda:	a2 1d 05 5a f0       	mov    %al,0xf05a051d
f010cddf:	b8 3c d7 10 f0       	mov    $0xf010d73c,%eax
f010cde4:	c1 e8 10             	shr    $0x10,%eax
f010cde7:	66 a3 1e 05 5a f0    	mov    %ax,0xf05a051e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010cded:	b8 42 d7 10 f0       	mov    $0xf010d742,%eax
f010cdf2:	66 a3 20 05 5a f0    	mov    %ax,0xf05a0520
f010cdf8:	66 c7 05 22 05 5a f0 	movw   $0x8,0xf05a0522
f010cdff:	08 00 
f010ce01:	a0 24 05 5a f0       	mov    0xf05a0524,%al
f010ce06:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce09:	a2 24 05 5a f0       	mov    %al,0xf05a0524
f010ce0e:	a0 24 05 5a f0       	mov    0xf05a0524,%al
f010ce13:	83 e0 1f             	and    $0x1f,%eax
f010ce16:	a2 24 05 5a f0       	mov    %al,0xf05a0524
f010ce1b:	a0 25 05 5a f0       	mov    0xf05a0525,%al
f010ce20:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce23:	83 c8 0e             	or     $0xe,%eax
f010ce26:	a2 25 05 5a f0       	mov    %al,0xf05a0525
f010ce2b:	a0 25 05 5a f0       	mov    0xf05a0525,%al
f010ce30:	83 e0 ef             	and    $0xffffffef,%eax
f010ce33:	a2 25 05 5a f0       	mov    %al,0xf05a0525
f010ce38:	a0 25 05 5a f0       	mov    0xf05a0525,%al
f010ce3d:	83 c8 60             	or     $0x60,%eax
f010ce40:	a2 25 05 5a f0       	mov    %al,0xf05a0525
f010ce45:	a0 25 05 5a f0       	mov    0xf05a0525,%al
f010ce4a:	83 c8 80             	or     $0xffffff80,%eax
f010ce4d:	a2 25 05 5a f0       	mov    %al,0xf05a0525
f010ce52:	b8 42 d7 10 f0       	mov    $0xf010d742,%eax
f010ce57:	c1 e8 10             	shr    $0x10,%eax
f010ce5a:	66 a3 26 05 5a f0    	mov    %ax,0xf05a0526
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010ce60:	b8 48 d7 10 f0       	mov    $0xf010d748,%eax
f010ce65:	66 a3 28 05 5a f0    	mov    %ax,0xf05a0528
f010ce6b:	66 c7 05 2a 05 5a f0 	movw   $0x8,0xf05a052a
f010ce72:	08 00 
f010ce74:	a0 2c 05 5a f0       	mov    0xf05a052c,%al
f010ce79:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce7c:	a2 2c 05 5a f0       	mov    %al,0xf05a052c
f010ce81:	a0 2c 05 5a f0       	mov    0xf05a052c,%al
f010ce86:	83 e0 1f             	and    $0x1f,%eax
f010ce89:	a2 2c 05 5a f0       	mov    %al,0xf05a052c
f010ce8e:	a0 2d 05 5a f0       	mov    0xf05a052d,%al
f010ce93:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce96:	83 c8 0e             	or     $0xe,%eax
f010ce99:	a2 2d 05 5a f0       	mov    %al,0xf05a052d
f010ce9e:	a0 2d 05 5a f0       	mov    0xf05a052d,%al
f010cea3:	83 e0 ef             	and    $0xffffffef,%eax
f010cea6:	a2 2d 05 5a f0       	mov    %al,0xf05a052d
f010ceab:	a0 2d 05 5a f0       	mov    0xf05a052d,%al
f010ceb0:	83 c8 60             	or     $0x60,%eax
f010ceb3:	a2 2d 05 5a f0       	mov    %al,0xf05a052d
f010ceb8:	a0 2d 05 5a f0       	mov    0xf05a052d,%al
f010cebd:	83 c8 80             	or     $0xffffff80,%eax
f010cec0:	a2 2d 05 5a f0       	mov    %al,0xf05a052d
f010cec5:	b8 48 d7 10 f0       	mov    $0xf010d748,%eax
f010ceca:	c1 e8 10             	shr    $0x10,%eax
f010cecd:	66 a3 2e 05 5a f0    	mov    %ax,0xf05a052e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010ced3:	b8 4e d7 10 f0       	mov    $0xf010d74e,%eax
f010ced8:	66 a3 30 05 5a f0    	mov    %ax,0xf05a0530
f010cede:	66 c7 05 32 05 5a f0 	movw   $0x8,0xf05a0532
f010cee5:	08 00 
f010cee7:	a0 34 05 5a f0       	mov    0xf05a0534,%al
f010ceec:	83 e0 e0             	and    $0xffffffe0,%eax
f010ceef:	a2 34 05 5a f0       	mov    %al,0xf05a0534
f010cef4:	a0 34 05 5a f0       	mov    0xf05a0534,%al
f010cef9:	83 e0 1f             	and    $0x1f,%eax
f010cefc:	a2 34 05 5a f0       	mov    %al,0xf05a0534
f010cf01:	a0 35 05 5a f0       	mov    0xf05a0535,%al
f010cf06:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf09:	83 c8 0e             	or     $0xe,%eax
f010cf0c:	a2 35 05 5a f0       	mov    %al,0xf05a0535
f010cf11:	a0 35 05 5a f0       	mov    0xf05a0535,%al
f010cf16:	83 e0 ef             	and    $0xffffffef,%eax
f010cf19:	a2 35 05 5a f0       	mov    %al,0xf05a0535
f010cf1e:	a0 35 05 5a f0       	mov    0xf05a0535,%al
f010cf23:	83 c8 60             	or     $0x60,%eax
f010cf26:	a2 35 05 5a f0       	mov    %al,0xf05a0535
f010cf2b:	a0 35 05 5a f0       	mov    0xf05a0535,%al
f010cf30:	83 c8 80             	or     $0xffffff80,%eax
f010cf33:	a2 35 05 5a f0       	mov    %al,0xf05a0535
f010cf38:	b8 4e d7 10 f0       	mov    $0xf010d74e,%eax
f010cf3d:	c1 e8 10             	shr    $0x10,%eax
f010cf40:	66 a3 36 05 5a f0    	mov    %ax,0xf05a0536
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cf46:	b8 54 d7 10 f0       	mov    $0xf010d754,%eax
f010cf4b:	66 a3 38 05 5a f0    	mov    %ax,0xf05a0538
f010cf51:	66 c7 05 3a 05 5a f0 	movw   $0x8,0xf05a053a
f010cf58:	08 00 
f010cf5a:	a0 3c 05 5a f0       	mov    0xf05a053c,%al
f010cf5f:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf62:	a2 3c 05 5a f0       	mov    %al,0xf05a053c
f010cf67:	a0 3c 05 5a f0       	mov    0xf05a053c,%al
f010cf6c:	83 e0 1f             	and    $0x1f,%eax
f010cf6f:	a2 3c 05 5a f0       	mov    %al,0xf05a053c
f010cf74:	a0 3d 05 5a f0       	mov    0xf05a053d,%al
f010cf79:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf7c:	83 c8 0e             	or     $0xe,%eax
f010cf7f:	a2 3d 05 5a f0       	mov    %al,0xf05a053d
f010cf84:	a0 3d 05 5a f0       	mov    0xf05a053d,%al
f010cf89:	83 e0 ef             	and    $0xffffffef,%eax
f010cf8c:	a2 3d 05 5a f0       	mov    %al,0xf05a053d
f010cf91:	a0 3d 05 5a f0       	mov    0xf05a053d,%al
f010cf96:	83 c8 60             	or     $0x60,%eax
f010cf99:	a2 3d 05 5a f0       	mov    %al,0xf05a053d
f010cf9e:	a0 3d 05 5a f0       	mov    0xf05a053d,%al
f010cfa3:	83 c8 80             	or     $0xffffff80,%eax
f010cfa6:	a2 3d 05 5a f0       	mov    %al,0xf05a053d
f010cfab:	b8 54 d7 10 f0       	mov    $0xf010d754,%eax
f010cfb0:	c1 e8 10             	shr    $0x10,%eax
f010cfb3:	66 a3 3e 05 5a f0    	mov    %ax,0xf05a053e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010cfb9:	b8 5a d7 10 f0       	mov    $0xf010d75a,%eax
f010cfbe:	66 a3 40 05 5a f0    	mov    %ax,0xf05a0540
f010cfc4:	66 c7 05 42 05 5a f0 	movw   $0x8,0xf05a0542
f010cfcb:	08 00 
f010cfcd:	a0 44 05 5a f0       	mov    0xf05a0544,%al
f010cfd2:	83 e0 e0             	and    $0xffffffe0,%eax
f010cfd5:	a2 44 05 5a f0       	mov    %al,0xf05a0544
f010cfda:	a0 44 05 5a f0       	mov    0xf05a0544,%al
f010cfdf:	83 e0 1f             	and    $0x1f,%eax
f010cfe2:	a2 44 05 5a f0       	mov    %al,0xf05a0544
f010cfe7:	a0 45 05 5a f0       	mov    0xf05a0545,%al
f010cfec:	83 e0 f0             	and    $0xfffffff0,%eax
f010cfef:	83 c8 0e             	or     $0xe,%eax
f010cff2:	a2 45 05 5a f0       	mov    %al,0xf05a0545
f010cff7:	a0 45 05 5a f0       	mov    0xf05a0545,%al
f010cffc:	83 e0 ef             	and    $0xffffffef,%eax
f010cfff:	a2 45 05 5a f0       	mov    %al,0xf05a0545
f010d004:	a0 45 05 5a f0       	mov    0xf05a0545,%al
f010d009:	83 c8 60             	or     $0x60,%eax
f010d00c:	a2 45 05 5a f0       	mov    %al,0xf05a0545
f010d011:	a0 45 05 5a f0       	mov    0xf05a0545,%al
f010d016:	83 c8 80             	or     $0xffffff80,%eax
f010d019:	a2 45 05 5a f0       	mov    %al,0xf05a0545
f010d01e:	b8 5a d7 10 f0       	mov    $0xf010d75a,%eax
f010d023:	c1 e8 10             	shr    $0x10,%eax
f010d026:	66 a3 46 05 5a f0    	mov    %ax,0xf05a0546
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d02c:	b8 60 d7 10 f0       	mov    $0xf010d760,%eax
f010d031:	66 a3 48 05 5a f0    	mov    %ax,0xf05a0548
f010d037:	66 c7 05 4a 05 5a f0 	movw   $0x8,0xf05a054a
f010d03e:	08 00 
f010d040:	a0 4c 05 5a f0       	mov    0xf05a054c,%al
f010d045:	83 e0 e0             	and    $0xffffffe0,%eax
f010d048:	a2 4c 05 5a f0       	mov    %al,0xf05a054c
f010d04d:	a0 4c 05 5a f0       	mov    0xf05a054c,%al
f010d052:	83 e0 1f             	and    $0x1f,%eax
f010d055:	a2 4c 05 5a f0       	mov    %al,0xf05a054c
f010d05a:	a0 4d 05 5a f0       	mov    0xf05a054d,%al
f010d05f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d062:	83 c8 0e             	or     $0xe,%eax
f010d065:	a2 4d 05 5a f0       	mov    %al,0xf05a054d
f010d06a:	a0 4d 05 5a f0       	mov    0xf05a054d,%al
f010d06f:	83 e0 ef             	and    $0xffffffef,%eax
f010d072:	a2 4d 05 5a f0       	mov    %al,0xf05a054d
f010d077:	a0 4d 05 5a f0       	mov    0xf05a054d,%al
f010d07c:	83 c8 60             	or     $0x60,%eax
f010d07f:	a2 4d 05 5a f0       	mov    %al,0xf05a054d
f010d084:	a0 4d 05 5a f0       	mov    0xf05a054d,%al
f010d089:	83 c8 80             	or     $0xffffff80,%eax
f010d08c:	a2 4d 05 5a f0       	mov    %al,0xf05a054d
f010d091:	b8 60 d7 10 f0       	mov    $0xf010d760,%eax
f010d096:	c1 e8 10             	shr    $0x10,%eax
f010d099:	66 a3 4e 05 5a f0    	mov    %ax,0xf05a054e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d09f:	b8 66 d7 10 f0       	mov    $0xf010d766,%eax
f010d0a4:	66 a3 50 05 5a f0    	mov    %ax,0xf05a0550
f010d0aa:	66 c7 05 52 05 5a f0 	movw   $0x8,0xf05a0552
f010d0b1:	08 00 
f010d0b3:	a0 54 05 5a f0       	mov    0xf05a0554,%al
f010d0b8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0bb:	a2 54 05 5a f0       	mov    %al,0xf05a0554
f010d0c0:	a0 54 05 5a f0       	mov    0xf05a0554,%al
f010d0c5:	83 e0 1f             	and    $0x1f,%eax
f010d0c8:	a2 54 05 5a f0       	mov    %al,0xf05a0554
f010d0cd:	a0 55 05 5a f0       	mov    0xf05a0555,%al
f010d0d2:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0d5:	83 c8 0e             	or     $0xe,%eax
f010d0d8:	a2 55 05 5a f0       	mov    %al,0xf05a0555
f010d0dd:	a0 55 05 5a f0       	mov    0xf05a0555,%al
f010d0e2:	83 e0 ef             	and    $0xffffffef,%eax
f010d0e5:	a2 55 05 5a f0       	mov    %al,0xf05a0555
f010d0ea:	a0 55 05 5a f0       	mov    0xf05a0555,%al
f010d0ef:	83 c8 60             	or     $0x60,%eax
f010d0f2:	a2 55 05 5a f0       	mov    %al,0xf05a0555
f010d0f7:	a0 55 05 5a f0       	mov    0xf05a0555,%al
f010d0fc:	83 c8 80             	or     $0xffffff80,%eax
f010d0ff:	a2 55 05 5a f0       	mov    %al,0xf05a0555
f010d104:	b8 66 d7 10 f0       	mov    $0xf010d766,%eax
f010d109:	c1 e8 10             	shr    $0x10,%eax
f010d10c:	66 a3 56 05 5a f0    	mov    %ax,0xf05a0556
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d112:	b8 6c d7 10 f0       	mov    $0xf010d76c,%eax
f010d117:	66 a3 58 05 5a f0    	mov    %ax,0xf05a0558
f010d11d:	66 c7 05 5a 05 5a f0 	movw   $0x8,0xf05a055a
f010d124:	08 00 
f010d126:	a0 5c 05 5a f0       	mov    0xf05a055c,%al
f010d12b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d12e:	a2 5c 05 5a f0       	mov    %al,0xf05a055c
f010d133:	a0 5c 05 5a f0       	mov    0xf05a055c,%al
f010d138:	83 e0 1f             	and    $0x1f,%eax
f010d13b:	a2 5c 05 5a f0       	mov    %al,0xf05a055c
f010d140:	a0 5d 05 5a f0       	mov    0xf05a055d,%al
f010d145:	83 e0 f0             	and    $0xfffffff0,%eax
f010d148:	83 c8 0e             	or     $0xe,%eax
f010d14b:	a2 5d 05 5a f0       	mov    %al,0xf05a055d
f010d150:	a0 5d 05 5a f0       	mov    0xf05a055d,%al
f010d155:	83 e0 ef             	and    $0xffffffef,%eax
f010d158:	a2 5d 05 5a f0       	mov    %al,0xf05a055d
f010d15d:	a0 5d 05 5a f0       	mov    0xf05a055d,%al
f010d162:	83 c8 60             	or     $0x60,%eax
f010d165:	a2 5d 05 5a f0       	mov    %al,0xf05a055d
f010d16a:	a0 5d 05 5a f0       	mov    0xf05a055d,%al
f010d16f:	83 c8 80             	or     $0xffffff80,%eax
f010d172:	a2 5d 05 5a f0       	mov    %al,0xf05a055d
f010d177:	b8 6c d7 10 f0       	mov    $0xf010d76c,%eax
f010d17c:	c1 e8 10             	shr    $0x10,%eax
f010d17f:	66 a3 5e 05 5a f0    	mov    %ax,0xf05a055e
f010d185:	c7 45 fc e0 03 5a f0 	movl   $0xf05a03e0,-0x4(%ebp)
f010d18c:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010d193:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010d196:	48                   	dec    %eax
f010d197:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010d19b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d19e:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010d1a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d1a5:	c1 e8 10             	shr    $0x10,%eax
f010d1a8:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010d1ac:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010d1af:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010d1b2:	90                   	nop
f010d1b3:	c9                   	leave  
f010d1b4:	c3                   	ret    

f010d1b5 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010d1b5:	55                   	push   %ebp
f010d1b6:	89 e5                	mov    %esp,%ebp
f010d1b8:	53                   	push   %ebx
f010d1b9:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010d1bc:	83 ec 08             	sub    $0x8,%esp
f010d1bf:	ff 75 08             	pushl  0x8(%ebp)
f010d1c2:	68 7e 8f 12 f0       	push   $0xf0128f7e
f010d1c7:	e8 a0 3d ff ff       	call   f0100f6c <cprintf>
f010d1cc:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010d1cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1d2:	83 ec 0c             	sub    $0xc,%esp
f010d1d5:	50                   	push   %eax
f010d1d6:	e8 fd 00 00 00       	call   f010d2d8 <print_regs>
f010d1db:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010d1de:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1e1:	8b 40 20             	mov    0x20(%eax),%eax
f010d1e4:	0f b7 c0             	movzwl %ax,%eax
f010d1e7:	83 ec 08             	sub    $0x8,%esp
f010d1ea:	50                   	push   %eax
f010d1eb:	68 90 8f 12 f0       	push   $0xf0128f90
f010d1f0:	e8 77 3d ff ff       	call   f0100f6c <cprintf>
f010d1f5:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010d1f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1fb:	8b 40 24             	mov    0x24(%eax),%eax
f010d1fe:	0f b7 c0             	movzwl %ax,%eax
f010d201:	83 ec 08             	sub    $0x8,%esp
f010d204:	50                   	push   %eax
f010d205:	68 a3 8f 12 f0       	push   $0xf0128fa3
f010d20a:	e8 5d 3d ff ff       	call   f0100f6c <cprintf>
f010d20f:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010d212:	8b 45 08             	mov    0x8(%ebp),%eax
f010d215:	8b 58 28             	mov    0x28(%eax),%ebx
f010d218:	8b 45 08             	mov    0x8(%ebp),%eax
f010d21b:	8b 40 28             	mov    0x28(%eax),%eax
f010d21e:	83 ec 0c             	sub    $0xc,%esp
f010d221:	50                   	push   %eax
f010d222:	e8 28 ee ff ff       	call   f010c04f <trapname>
f010d227:	83 c4 10             	add    $0x10,%esp
f010d22a:	89 c2                	mov    %eax,%edx
f010d22c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d22f:	8b 40 28             	mov    0x28(%eax),%eax
f010d232:	53                   	push   %ebx
f010d233:	52                   	push   %edx
f010d234:	50                   	push   %eax
f010d235:	68 b6 8f 12 f0       	push   $0xf0128fb6
f010d23a:	e8 2d 3d ff ff       	call   f0100f6c <cprintf>
f010d23f:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010d242:	8b 45 08             	mov    0x8(%ebp),%eax
f010d245:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d248:	83 ec 08             	sub    $0x8,%esp
f010d24b:	50                   	push   %eax
f010d24c:	68 cd 8f 12 f0       	push   $0xf0128fcd
f010d251:	e8 16 3d ff ff       	call   f0100f6c <cprintf>
f010d256:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010d259:	8b 45 08             	mov    0x8(%ebp),%eax
f010d25c:	8b 40 30             	mov    0x30(%eax),%eax
f010d25f:	83 ec 08             	sub    $0x8,%esp
f010d262:	50                   	push   %eax
f010d263:	68 dc 8f 12 f0       	push   $0xf0128fdc
f010d268:	e8 ff 3c ff ff       	call   f0100f6c <cprintf>
f010d26d:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010d270:	8b 45 08             	mov    0x8(%ebp),%eax
f010d273:	8b 40 34             	mov    0x34(%eax),%eax
f010d276:	0f b7 c0             	movzwl %ax,%eax
f010d279:	83 ec 08             	sub    $0x8,%esp
f010d27c:	50                   	push   %eax
f010d27d:	68 eb 8f 12 f0       	push   $0xf0128feb
f010d282:	e8 e5 3c ff ff       	call   f0100f6c <cprintf>
f010d287:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010d28a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d28d:	8b 40 38             	mov    0x38(%eax),%eax
f010d290:	83 ec 08             	sub    $0x8,%esp
f010d293:	50                   	push   %eax
f010d294:	68 fe 8f 12 f0       	push   $0xf0128ffe
f010d299:	e8 ce 3c ff ff       	call   f0100f6c <cprintf>
f010d29e:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010d2a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2a4:	8b 40 3c             	mov    0x3c(%eax),%eax
f010d2a7:	83 ec 08             	sub    $0x8,%esp
f010d2aa:	50                   	push   %eax
f010d2ab:	68 0d 90 12 f0       	push   $0xf012900d
f010d2b0:	e8 b7 3c ff ff       	call   f0100f6c <cprintf>
f010d2b5:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010d2b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2bb:	8b 40 40             	mov    0x40(%eax),%eax
f010d2be:	0f b7 c0             	movzwl %ax,%eax
f010d2c1:	83 ec 08             	sub    $0x8,%esp
f010d2c4:	50                   	push   %eax
f010d2c5:	68 1c 90 12 f0       	push   $0xf012901c
f010d2ca:	e8 9d 3c ff ff       	call   f0100f6c <cprintf>
f010d2cf:	83 c4 10             	add    $0x10,%esp
}
f010d2d2:	90                   	nop
f010d2d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010d2d6:	c9                   	leave  
f010d2d7:	c3                   	ret    

f010d2d8 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010d2d8:	55                   	push   %ebp
f010d2d9:	89 e5                	mov    %esp,%ebp
f010d2db:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010d2de:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2e1:	8b 00                	mov    (%eax),%eax
f010d2e3:	83 ec 08             	sub    $0x8,%esp
f010d2e6:	50                   	push   %eax
f010d2e7:	68 2f 90 12 f0       	push   $0xf012902f
f010d2ec:	e8 7b 3c ff ff       	call   f0100f6c <cprintf>
f010d2f1:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010d2f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2f7:	8b 40 04             	mov    0x4(%eax),%eax
f010d2fa:	83 ec 08             	sub    $0x8,%esp
f010d2fd:	50                   	push   %eax
f010d2fe:	68 3e 90 12 f0       	push   $0xf012903e
f010d303:	e8 64 3c ff ff       	call   f0100f6c <cprintf>
f010d308:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010d30b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d30e:	8b 40 08             	mov    0x8(%eax),%eax
f010d311:	83 ec 08             	sub    $0x8,%esp
f010d314:	50                   	push   %eax
f010d315:	68 4d 90 12 f0       	push   $0xf012904d
f010d31a:	e8 4d 3c ff ff       	call   f0100f6c <cprintf>
f010d31f:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010d322:	8b 45 08             	mov    0x8(%ebp),%eax
f010d325:	8b 40 0c             	mov    0xc(%eax),%eax
f010d328:	83 ec 08             	sub    $0x8,%esp
f010d32b:	50                   	push   %eax
f010d32c:	68 5c 90 12 f0       	push   $0xf012905c
f010d331:	e8 36 3c ff ff       	call   f0100f6c <cprintf>
f010d336:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d339:	8b 45 08             	mov    0x8(%ebp),%eax
f010d33c:	8b 40 10             	mov    0x10(%eax),%eax
f010d33f:	83 ec 08             	sub    $0x8,%esp
f010d342:	50                   	push   %eax
f010d343:	68 6b 90 12 f0       	push   $0xf012906b
f010d348:	e8 1f 3c ff ff       	call   f0100f6c <cprintf>
f010d34d:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d350:	8b 45 08             	mov    0x8(%ebp),%eax
f010d353:	8b 40 14             	mov    0x14(%eax),%eax
f010d356:	83 ec 08             	sub    $0x8,%esp
f010d359:	50                   	push   %eax
f010d35a:	68 7a 90 12 f0       	push   $0xf012907a
f010d35f:	e8 08 3c ff ff       	call   f0100f6c <cprintf>
f010d364:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d367:	8b 45 08             	mov    0x8(%ebp),%eax
f010d36a:	8b 40 18             	mov    0x18(%eax),%eax
f010d36d:	83 ec 08             	sub    $0x8,%esp
f010d370:	50                   	push   %eax
f010d371:	68 89 90 12 f0       	push   $0xf0129089
f010d376:	e8 f1 3b ff ff       	call   f0100f6c <cprintf>
f010d37b:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d37e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d381:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d384:	83 ec 08             	sub    $0x8,%esp
f010d387:	50                   	push   %eax
f010d388:	68 98 90 12 f0       	push   $0xf0129098
f010d38d:	e8 da 3b ff ff       	call   f0100f6c <cprintf>
f010d392:	83 c4 10             	add    $0x10,%esp
}
f010d395:	90                   	nop
f010d396:	c9                   	leave  
f010d397:	c3                   	ret    

f010d398 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d398:	55                   	push   %ebp
f010d399:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d39b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d39e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d3a1:	89 14 85 e0 0b 5a f0 	mov    %edx,-0xfa5f420(,%eax,4)
}
f010d3a8:	90                   	nop
f010d3a9:	5d                   	pop    %ebp
f010d3aa:	c3                   	ret    

f010d3ab <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d3ab:	55                   	push   %ebp
f010d3ac:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d3ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3b1:	c7 04 85 e0 0b 5a f0 	movl   $0x0,-0xfa5f420(,%eax,4)
f010d3b8:	00 00 00 00 
}
f010d3bc:	90                   	nop
f010d3bd:	5d                   	pop    %ebp
f010d3be:	c3                   	ret    

f010d3bf <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d3bf:	55                   	push   %ebp
f010d3c0:	89 e5                	mov    %esp,%ebp
f010d3c2:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d3c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3c8:	8b 40 28             	mov    0x28(%eax),%eax
f010d3cb:	83 e8 20             	sub    $0x20,%eax
f010d3ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d3d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3d4:	8b 04 85 e0 0b 5a f0 	mov    -0xfa5f420(,%eax,4),%eax
f010d3db:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d3de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d3e2:	74 0e                	je     f010d3f2 <irq_dispatch+0x33>
	{
		handler(tf);
f010d3e4:	83 ec 0c             	sub    $0xc,%esp
f010d3e7:	ff 75 08             	pushl  0x8(%ebp)
f010d3ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d3ed:	ff d0                	call   *%eax
f010d3ef:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d3f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3f5:	0f b6 c0             	movzbl %al,%eax
f010d3f8:	83 ec 0c             	sub    $0xc,%esp
f010d3fb:	50                   	push   %eax
f010d3fc:	e8 c3 9c ff ff       	call   f01070c4 <pic_sendEOI>
f010d401:	83 c4 10             	add    $0x10,%esp
}
f010d404:	90                   	nop
f010d405:	c9                   	leave  
f010d406:	c3                   	ret    

f010d407 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d407:	55                   	push   %ebp
f010d408:	89 e5                	mov    %esp,%ebp
f010d40a:	57                   	push   %edi
f010d40b:	56                   	push   %esi
f010d40c:	53                   	push   %ebx
f010d40d:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d410:	8b 45 08             	mov    0x8(%ebp),%eax
f010d413:	8b 40 28             	mov    0x28(%eax),%eax
f010d416:	83 f8 0e             	cmp    $0xe,%eax
f010d419:	75 51                	jne    f010d46c <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d41b:	a0 20 0c 5a f0       	mov    0xf05a0c20,%al
f010d420:	84 c0                	test   %al,%al
f010d422:	74 1f                	je     f010d443 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d424:	8b 45 08             	mov    0x8(%ebp),%eax
f010d427:	8b 40 30             	mov    0x30(%eax),%eax
f010d42a:	89 c2                	mov    %eax,%edx
f010d42c:	a0 20 0c 5a f0       	mov    0xf05a0c20,%al
f010d431:	0f b6 c0             	movzbl %al,%eax
f010d434:	01 d0                	add    %edx,%eax
f010d436:	89 c2                	mov    %eax,%edx
f010d438:	8b 45 08             	mov    0x8(%ebp),%eax
f010d43b:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d43e:	e9 0c 01 00 00       	jmp    f010d54f <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d443:	83 ec 0c             	sub    $0xc,%esp
f010d446:	6a 01                	push   $0x1
f010d448:	e8 c3 12 00 00       	call   f010e710 <isPageReplacmentAlgorithmLRU>
f010d44d:	83 c4 10             	add    $0x10,%esp
f010d450:	85 c0                	test   %eax,%eax
f010d452:	74 05                	je     f010d459 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d454:	e8 de 97 ff ff       	call   f0106c37 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d459:	83 ec 0c             	sub    $0xc,%esp
f010d45c:	ff 75 08             	pushl  0x8(%ebp)
f010d45f:	e8 91 13 00 00       	call   f010e7f5 <fault_handler>
f010d464:	83 c4 10             	add    $0x10,%esp
f010d467:	e9 e3 00 00 00       	jmp    f010d54f <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d46c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d46f:	8b 40 28             	mov    0x28(%eax),%eax
f010d472:	83 f8 30             	cmp    $0x30,%eax
f010d475:	75 6e                	jne    f010d4e5 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d477:	8b 45 08             	mov    0x8(%ebp),%eax
f010d47a:	8b 40 38             	mov    0x38(%eax),%eax
f010d47d:	25 00 02 00 00       	and    $0x200,%eax
f010d482:	85 c0                	test   %eax,%eax
f010d484:	74 06                	je     f010d48c <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d486:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d487:	e8 24 78 ff ff       	call   f0104cb0 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d48c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d48f:	8b 78 04             	mov    0x4(%eax),%edi
f010d492:	8b 45 08             	mov    0x8(%ebp),%eax
f010d495:	8b 30                	mov    (%eax),%esi
f010d497:	8b 45 08             	mov    0x8(%ebp),%eax
f010d49a:	8b 58 10             	mov    0x10(%eax),%ebx
f010d49d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4a0:	8b 48 18             	mov    0x18(%eax),%ecx
f010d4a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4a6:	8b 50 14             	mov    0x14(%eax),%edx
f010d4a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4ac:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d4af:	83 ec 08             	sub    $0x8,%esp
f010d4b2:	57                   	push   %edi
f010d4b3:	56                   	push   %esi
f010d4b4:	53                   	push   %ebx
f010d4b5:	51                   	push   %ecx
f010d4b6:	52                   	push   %edx
f010d4b7:	50                   	push   %eax
f010d4b8:	e8 7a 09 00 00       	call   f010de37 <syscall>
f010d4bd:	83 c4 20             	add    $0x20,%esp
f010d4c0:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d4c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4c6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d4c9:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d4cc:	9c                   	pushf  
f010d4cd:	58                   	pop    %eax
f010d4ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d4d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d4d4:	25 00 02 00 00       	and    $0x200,%eax
f010d4d9:	85 c0                	test   %eax,%eax
f010d4db:	74 72                	je     f010d54f <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d4dd:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d4de:	e8 a5 77 ff ff       	call   f0104c88 <kclock_stop>
f010d4e3:	eb 6a                	jmp    f010d54f <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d4e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4e8:	8b 40 28             	mov    0x28(%eax),%eax
f010d4eb:	83 f8 08             	cmp    $0x8,%eax
f010d4ee:	75 17                	jne    f010d507 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d4f0:	83 ec 04             	sub    $0x4,%esp
f010d4f3:	68 a7 90 12 f0       	push   $0xf01290a7
f010d4f8:	68 22 01 00 00       	push   $0x122
f010d4fd:	68 b6 90 12 f0       	push   $0xf01290b6
f010d502:	e8 13 2e ff ff       	call   f010031a <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d507:	83 ec 0c             	sub    $0xc,%esp
f010d50a:	ff 75 08             	pushl  0x8(%ebp)
f010d50d:	e8 a3 fc ff ff       	call   f010d1b5 <print_trapframe>
f010d512:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d515:	8b 45 08             	mov    0x8(%ebp),%eax
f010d518:	8b 40 34             	mov    0x34(%eax),%eax
f010d51b:	66 83 f8 08          	cmp    $0x8,%ax
f010d51f:	75 17                	jne    f010d538 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d521:	83 ec 04             	sub    $0x4,%esp
f010d524:	68 c7 90 12 f0       	push   $0xf01290c7
f010d529:	68 2a 01 00 00       	push   $0x12a
f010d52e:	68 b6 90 12 f0       	push   $0xf01290b6
f010d533:	e8 e2 2d ff ff       	call   f010031a <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d538:	83 ec 04             	sub    $0x4,%esp
f010d53b:	68 e0 90 12 f0       	push   $0xf01290e0
f010d540:	68 2f 01 00 00       	push   $0x12f
f010d545:	68 b6 90 12 f0       	push   $0xf01290b6
f010d54a:	e8 cb 2d ff ff       	call   f010031a <_panic>
		}
	}
}
f010d54f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d552:	5b                   	pop    %ebx
f010d553:	5e                   	pop    %esi
f010d554:	5f                   	pop    %edi
f010d555:	5d                   	pop    %ebp
f010d556:	c3                   	ret    

f010d557 <trap>:

void trap(struct Trapframe *tf)
{
f010d557:	55                   	push   %ebp
f010d558:	89 e5                	mov    %esp,%ebp
f010d55a:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d55d:	e8 26 77 ff ff       	call   f0104c88 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d562:	9c                   	pushf  
f010d563:	58                   	pop    %eax
f010d564:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d567:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d56a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d56d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d570:	25 00 02 00 00       	and    $0x200,%eax
f010d575:	85 c0                	test   %eax,%eax
f010d577:	74 25                	je     f010d59e <trap+0x47>
	{
		print_trapframe(tf);
f010d579:	83 ec 0c             	sub    $0xc,%esp
f010d57c:	ff 75 08             	pushl  0x8(%ebp)
f010d57f:	e8 31 fc ff ff       	call   f010d1b5 <print_trapframe>
f010d584:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d587:	83 ec 04             	sub    $0x4,%esp
f010d58a:	68 00 91 12 f0       	push   $0xf0129100
f010d58f:	68 45 01 00 00       	push   $0x145
f010d594:	68 b6 90 12 f0       	push   $0xf01290b6
f010d599:	e8 7c 2d ff ff       	call   f010031a <_panic>
	}

	int userTrap = 0;
f010d59e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d5a5:	e8 c6 d1 ff ff       	call   f010a770 <get_cpu_proc>
f010d5aa:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d5ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5b0:	8b 40 34             	mov    0x34(%eax),%eax
f010d5b3:	0f b7 c0             	movzwl %ax,%eax
f010d5b6:	83 e0 03             	and    $0x3,%eax
f010d5b9:	83 f8 03             	cmp    $0x3,%eax
f010d5bc:	75 54                	jne    f010d612 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d5be:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d5c2:	74 0b                	je     f010d5cf <trap+0x78>
f010d5c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d5c7:	8b 40 18             	mov    0x18(%eax),%eax
f010d5ca:	83 f8 02             	cmp    $0x2,%eax
f010d5cd:	74 19                	je     f010d5e8 <trap+0x91>
f010d5cf:	68 44 91 12 f0       	push   $0xf0129144
f010d5d4:	68 72 91 12 f0       	push   $0xf0129172
f010d5d9:	68 4d 01 00 00       	push   $0x14d
f010d5de:	68 b6 90 12 f0       	push   $0xf01290b6
f010d5e3:	e8 32 2d ff ff       	call   f010031a <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d5e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d5eb:	8b 00                	mov    (%eax),%eax
f010d5ed:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d5f0:	74 19                	je     f010d60b <trap+0xb4>
f010d5f2:	68 87 91 12 f0       	push   $0xf0129187
f010d5f7:	68 72 91 12 f0       	push   $0xf0129172
f010d5fc:	68 4f 01 00 00       	push   $0x14f
f010d601:	68 b6 90 12 f0       	push   $0xf01290b6
f010d606:	e8 0f 2d ff ff       	call   f010031a <_panic>
		userTrap = 1;
f010d60b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d612:	8b 45 08             	mov    0x8(%ebp),%eax
f010d615:	8b 40 28             	mov    0x28(%eax),%eax
f010d618:	83 f8 1f             	cmp    $0x1f,%eax
f010d61b:	76 1b                	jbe    f010d638 <trap+0xe1>
f010d61d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d620:	8b 40 28             	mov    0x28(%eax),%eax
f010d623:	83 f8 2f             	cmp    $0x2f,%eax
f010d626:	77 10                	ja     f010d638 <trap+0xe1>
	{
		irq_dispatch(tf);
f010d628:	83 ec 0c             	sub    $0xc,%esp
f010d62b:	ff 75 08             	pushl  0x8(%ebp)
f010d62e:	e8 8c fd ff ff       	call   f010d3bf <irq_dispatch>
f010d633:	83 c4 10             	add    $0x10,%esp
f010d636:	eb 0e                	jmp    f010d646 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d638:	83 ec 0c             	sub    $0xc,%esp
f010d63b:	ff 75 08             	pushl  0x8(%ebp)
f010d63e:	e8 c4 fd ff ff       	call   f010d407 <trap_dispatch>
f010d643:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d646:	9c                   	pushf  
f010d647:	58                   	pop    %eax
f010d648:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d64b:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d64e:	25 00 02 00 00       	and    $0x200,%eax
f010d653:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d656:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d65a:	74 19                	je     f010d675 <trap+0x11e>
f010d65c:	68 9d 91 12 f0       	push   $0xf012919d
f010d661:	68 72 91 12 f0       	push   $0xf0129172
f010d666:	68 66 01 00 00       	push   $0x166
f010d66b:	68 b6 90 12 f0       	push   $0xf01290b6
f010d670:	e8 a5 2c ff ff       	call   f010031a <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d675:	e8 36 76 ff ff       	call   f0104cb0 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d67a:	90                   	nop
f010d67b:	c9                   	leave  
f010d67c:	c3                   	ret    
f010d67d:	90                   	nop

f010d67e <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d67e:	6a 08                	push   $0x8
f010d680:	e9 ed 00 00 00       	jmp    f010d772 <_alltraps>
f010d685:	90                   	nop

f010d686 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d686:	6a 0e                	push   $0xe
f010d688:	e9 e5 00 00 00       	jmp    f010d772 <_alltraps>
f010d68d:	90                   	nop

f010d68e <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d68e:	6a 00                	push   $0x0
f010d690:	6a 20                	push   $0x20
f010d692:	e9 db 00 00 00       	jmp    f010d772 <_alltraps>
f010d697:	90                   	nop

f010d698 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d698:	6a 00                	push   $0x0
f010d69a:	6a 21                	push   $0x21
f010d69c:	e9 d1 00 00 00       	jmp    f010d772 <_alltraps>
f010d6a1:	90                   	nop

f010d6a2 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d6a2:	6a 00                	push   $0x0
f010d6a4:	6a 30                	push   $0x30
f010d6a6:	e9 c7 00 00 00       	jmp    f010d772 <_alltraps>
f010d6ab:	90                   	nop

f010d6ac <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d6ac:	6a 00                	push   $0x0
f010d6ae:	6a 00                	push   $0x0
f010d6b0:	e9 bd 00 00 00       	jmp    f010d772 <_alltraps>
f010d6b5:	90                   	nop

f010d6b6 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d6b6:	6a 00                	push   $0x0
f010d6b8:	6a 01                	push   $0x1
f010d6ba:	e9 b3 00 00 00       	jmp    f010d772 <_alltraps>
f010d6bf:	90                   	nop

f010d6c0 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d6c0:	6a 00                	push   $0x0
f010d6c2:	6a 02                	push   $0x2
f010d6c4:	e9 a9 00 00 00       	jmp    f010d772 <_alltraps>
f010d6c9:	90                   	nop

f010d6ca <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d6ca:	6a 00                	push   $0x0
f010d6cc:	6a 03                	push   $0x3
f010d6ce:	e9 9f 00 00 00       	jmp    f010d772 <_alltraps>
f010d6d3:	90                   	nop

f010d6d4 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d6d4:	6a 00                	push   $0x0
f010d6d6:	6a 04                	push   $0x4
f010d6d8:	e9 95 00 00 00       	jmp    f010d772 <_alltraps>
f010d6dd:	90                   	nop

f010d6de <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d6de:	6a 00                	push   $0x0
f010d6e0:	6a 05                	push   $0x5
f010d6e2:	e9 8b 00 00 00       	jmp    f010d772 <_alltraps>
f010d6e7:	90                   	nop

f010d6e8 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d6e8:	6a 00                	push   $0x0
f010d6ea:	6a 06                	push   $0x6
f010d6ec:	e9 81 00 00 00       	jmp    f010d772 <_alltraps>
f010d6f1:	90                   	nop

f010d6f2 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d6f2:	6a 00                	push   $0x0
f010d6f4:	6a 07                	push   $0x7
f010d6f6:	eb 7a                	jmp    f010d772 <_alltraps>

f010d6f8 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d6f8:	6a 0a                	push   $0xa
f010d6fa:	eb 76                	jmp    f010d772 <_alltraps>

f010d6fc <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d6fc:	6a 0b                	push   $0xb
f010d6fe:	eb 72                	jmp    f010d772 <_alltraps>

f010d700 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d700:	6a 0c                	push   $0xc
f010d702:	eb 6e                	jmp    f010d772 <_alltraps>

f010d704 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d704:	6a 0d                	push   $0xd
f010d706:	eb 6a                	jmp    f010d772 <_alltraps>

f010d708 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d708:	6a 00                	push   $0x0
f010d70a:	6a 10                	push   $0x10
f010d70c:	eb 64                	jmp    f010d772 <_alltraps>

f010d70e <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d70e:	6a 11                	push   $0x11
f010d710:	eb 60                	jmp    f010d772 <_alltraps>

f010d712 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d712:	6a 00                	push   $0x0
f010d714:	6a 12                	push   $0x12
f010d716:	eb 5a                	jmp    f010d772 <_alltraps>

f010d718 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d718:	6a 00                	push   $0x0
f010d71a:	6a 13                	push   $0x13
f010d71c:	eb 54                	jmp    f010d772 <_alltraps>

f010d71e <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d71e:	6a 00                	push   $0x0
f010d720:	6a 22                	push   $0x22
f010d722:	eb 4e                	jmp    f010d772 <_alltraps>

f010d724 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d724:	6a 00                	push   $0x0
f010d726:	6a 23                	push   $0x23
f010d728:	eb 48                	jmp    f010d772 <_alltraps>

f010d72a <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d72a:	6a 00                	push   $0x0
f010d72c:	6a 24                	push   $0x24
f010d72e:	eb 42                	jmp    f010d772 <_alltraps>

f010d730 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d730:	6a 00                	push   $0x0
f010d732:	6a 25                	push   $0x25
f010d734:	eb 3c                	jmp    f010d772 <_alltraps>

f010d736 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d736:	6a 00                	push   $0x0
f010d738:	6a 26                	push   $0x26
f010d73a:	eb 36                	jmp    f010d772 <_alltraps>

f010d73c <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d73c:	6a 00                	push   $0x0
f010d73e:	6a 27                	push   $0x27
f010d740:	eb 30                	jmp    f010d772 <_alltraps>

f010d742 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d742:	6a 00                	push   $0x0
f010d744:	6a 28                	push   $0x28
f010d746:	eb 2a                	jmp    f010d772 <_alltraps>

f010d748 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d748:	6a 00                	push   $0x0
f010d74a:	6a 29                	push   $0x29
f010d74c:	eb 24                	jmp    f010d772 <_alltraps>

f010d74e <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d74e:	6a 00                	push   $0x0
f010d750:	6a 2a                	push   $0x2a
f010d752:	eb 1e                	jmp    f010d772 <_alltraps>

f010d754 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d754:	6a 00                	push   $0x0
f010d756:	6a 2b                	push   $0x2b
f010d758:	eb 18                	jmp    f010d772 <_alltraps>

f010d75a <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d75a:	6a 00                	push   $0x0
f010d75c:	6a 2c                	push   $0x2c
f010d75e:	eb 12                	jmp    f010d772 <_alltraps>

f010d760 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d760:	6a 00                	push   $0x0
f010d762:	6a 2d                	push   $0x2d
f010d764:	eb 0c                	jmp    f010d772 <_alltraps>

f010d766 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d766:	6a 00                	push   $0x0
f010d768:	6a 2e                	push   $0x2e
f010d76a:	eb 06                	jmp    f010d772 <_alltraps>

f010d76c <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d76c:	6a 00                	push   $0x0
f010d76e:	6a 2f                	push   $0x2f
f010d770:	eb 00                	jmp    f010d772 <_alltraps>

f010d772 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d772:	1e                   	push   %ds
push 	%es
f010d773:	06                   	push   %es
pushal
f010d774:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d775:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d779:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d77b:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d77d:	54                   	push   %esp
call 	trap
f010d77e:	e8 d4 fd ff ff       	call   f010d557 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d783:	59                   	pop    %ecx

f010d784 <trapret>:
.globl trapret
trapret:
popal
f010d784:	61                   	popa   
pop 	%es
f010d785:	07                   	pop    %es
pop 	%ds
f010d786:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d787:	83 c4 08             	add    $0x8,%esp
iret
f010d78a:	cf                   	iret   

f010d78b <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d78b:	55                   	push   %ebp
f010d78c:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d78e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d791:	8b 15 c0 38 5a f0    	mov    0xf05a38c0,%edx
f010d797:	29 d0                	sub    %edx,%eax
f010d799:	c1 f8 03             	sar    $0x3,%eax
f010d79c:	89 c2                	mov    %eax,%edx
f010d79e:	89 d0                	mov    %edx,%eax
f010d7a0:	c1 e0 02             	shl    $0x2,%eax
f010d7a3:	01 d0                	add    %edx,%eax
f010d7a5:	c1 e0 02             	shl    $0x2,%eax
f010d7a8:	01 d0                	add    %edx,%eax
f010d7aa:	c1 e0 02             	shl    $0x2,%eax
f010d7ad:	01 d0                	add    %edx,%eax
f010d7af:	89 c1                	mov    %eax,%ecx
f010d7b1:	c1 e1 08             	shl    $0x8,%ecx
f010d7b4:	01 c8                	add    %ecx,%eax
f010d7b6:	89 c1                	mov    %eax,%ecx
f010d7b8:	c1 e1 10             	shl    $0x10,%ecx
f010d7bb:	01 c8                	add    %ecx,%eax
f010d7bd:	01 c0                	add    %eax,%eax
f010d7bf:	01 d0                	add    %edx,%eax
}
f010d7c1:	5d                   	pop    %ebp
f010d7c2:	c3                   	ret    

f010d7c3 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d7c3:	55                   	push   %ebp
f010d7c4:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d7c6:	ff 75 08             	pushl  0x8(%ebp)
f010d7c9:	e8 bd ff ff ff       	call   f010d78b <to_frame_number>
f010d7ce:	83 c4 04             	add    $0x4,%esp
f010d7d1:	c1 e0 0c             	shl    $0xc,%eax
}
f010d7d4:	c9                   	leave  
f010d7d5:	c3                   	ret    

f010d7d6 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d7d6:	55                   	push   %ebp
f010d7d7:	89 e5                	mov    %esp,%ebp
f010d7d9:	83 ec 18             	sub    $0x18,%esp
f010d7dc:	8b 45 10             	mov    0x10(%ebp),%eax
f010d7df:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d7e2:	e8 d9 99 ff ff       	call   f01071c0 <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d7e7:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d7eb:	74 23                	je     f010d810 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d7ed:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010d7f2:	8b 40 10             	mov    0x10(%eax),%eax
f010d7f5:	8b 15 64 20 5c f0    	mov    0xf05c2064,%edx
f010d7fb:	83 c2 20             	add    $0x20,%edx
f010d7fe:	83 ec 04             	sub    $0x4,%esp
f010d801:	50                   	push   %eax
f010d802:	52                   	push   %edx
f010d803:	68 50 93 12 f0       	push   $0xf0129350
f010d808:	e8 5f 37 ff ff       	call   f0100f6c <cprintf>
f010d80d:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d810:	83 ec 04             	sub    $0x4,%esp
f010d813:	ff 75 08             	pushl  0x8(%ebp)
f010d816:	ff 75 0c             	pushl  0xc(%ebp)
f010d819:	68 59 93 12 f0       	push   $0xf0129359
f010d81e:	e8 49 37 ff ff       	call   f0100f6c <cprintf>
f010d823:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d826:	e8 e7 99 ff ff       	call   f0107212 <popcli>
}
f010d82b:	90                   	nop
f010d82c:	c9                   	leave  
f010d82d:	c3                   	ret    

f010d82e <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d82e:	55                   	push   %ebp
f010d82f:	89 e5                	mov    %esp,%ebp
f010d831:	83 ec 18             	sub    $0x18,%esp
f010d834:	8b 45 08             	mov    0x8(%ebp),%eax
f010d837:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d83a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d83e:	83 ec 08             	sub    $0x8,%esp
f010d841:	50                   	push   %eax
f010d842:	68 5e 93 12 f0       	push   $0xf012935e
f010d847:	e8 20 37 ff ff       	call   f0100f6c <cprintf>
f010d84c:	83 c4 10             	add    $0x10,%esp
}
f010d84f:	90                   	nop
f010d850:	c9                   	leave  
f010d851:	c3                   	ret    

f010d852 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d852:	55                   	push   %ebp
f010d853:	89 e5                	mov    %esp,%ebp
f010d855:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d858:	9c                   	pushf  
f010d859:	58                   	pop    %eax
f010d85a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d85d:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d860:	25 00 02 00 00       	and    $0x200,%eax
f010d865:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d868:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d86c:	74 10                	je     f010d87e <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d86e:	e8 32 35 ff ff       	call   f0100da5 <cons_getc2>
f010d873:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d876:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d87a:	74 f2                	je     f010d86e <sys_cgetc+0x1c>
f010d87c:	eb 0e                	jmp    f010d88c <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d87e:	e8 c7 34 ff ff       	call   f0100d4a <cons_getc>
f010d883:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d886:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d88a:	74 f2                	je     f010d87e <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d88c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d88f:	c9                   	leave  
f010d890:	c3                   	ret    

f010d891 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d891:	55                   	push   %ebp
f010d892:	89 e5                	mov    %esp,%ebp
f010d894:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d897:	e8 f5 35 ff ff       	call   f0100e91 <cons_lock>
}
f010d89c:	90                   	nop
f010d89d:	c9                   	leave  
f010d89e:	c3                   	ret    

f010d89f <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d89f:	55                   	push   %ebp
f010d8a0:	89 e5                	mov    %esp,%ebp
f010d8a2:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d8a5:	e8 2e 36 ff ff       	call   f0100ed8 <cons_unlock>
}
f010d8aa:	90                   	nop
f010d8ab:	c9                   	leave  
f010d8ac:	c3                   	ret    

f010d8ad <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d8ad:	55                   	push   %ebp
f010d8ae:	89 e5                	mov    %esp,%ebp
f010d8b0:	83 ec 28             	sub    $0x28,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d8b3:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010d8b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d8bb:	83 ec 0c             	sub    $0xc,%esp
f010d8be:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010d8c1:	50                   	push   %eax
f010d8c2:	e8 09 a9 ff ff       	call   f01081d0 <allocate_frame>
f010d8c7:	83 c4 10             	add    $0x10,%esp
f010d8ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d8cd:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d8d1:	75 08                	jne    f010d8db <__sys_allocate_page+0x2e>
		return r ;
f010d8d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d8d6:	e9 d0 00 00 00       	jmp    f010d9ab <__sys_allocate_page+0xfe>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d8db:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8de:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d8e3:	77 0c                	ja     f010d8f1 <__sys_allocate_page+0x44>
f010d8e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8e8:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d8ed:	85 c0                	test   %eax,%eax
f010d8ef:	74 0a                	je     f010d8fb <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d8f1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d8f6:	e9 b0 00 00 00       	jmp    f010d9ab <__sys_allocate_page+0xfe>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d8fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d8fe:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d903:	83 f8 04             	cmp    $0x4,%eax
f010d906:	74 0a                	je     f010d912 <__sys_allocate_page+0x65>
		return E_INVAL;
f010d908:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d90d:	e9 99 00 00 00       	jmp    f010d9ab <__sys_allocate_page+0xfe>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d912:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d915:	83 ec 0c             	sub    $0xc,%esp
f010d918:	50                   	push   %eax
f010d919:	e8 a5 fe ff ff       	call   f010d7c3 <to_physical_address>
f010d91e:	83 c4 10             	add    $0x10,%esp
f010d921:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//return it to the original status
		ptr_frame_info->references -= 1;
	}
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
f010d924:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d927:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010d92a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d92d:	c1 e8 0c             	shr    $0xc,%eax
f010d930:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010d933:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f010d938:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010d93b:	72 17                	jb     f010d954 <__sys_allocate_page+0xa7>
f010d93d:	ff 75 e8             	pushl  -0x18(%ebp)
f010d940:	68 64 93 12 f0       	push   $0xf0129364
f010d945:	68 b5 00 00 00       	push   $0xb5
f010d94a:	68 93 93 12 f0       	push   $0xf0129393
f010d94f:	e8 c6 29 ff ff       	call   f010031a <_panic>
f010d954:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d957:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010d95c:	83 ec 04             	sub    $0x4,%esp
f010d95f:	68 00 10 00 00       	push   $0x1000
f010d964:	6a 00                	push   $0x0
f010d966:	50                   	push   %eax
f010d967:	e8 57 4e 01 00       	call   f01227c3 <memset>
f010d96c:	83 c4 10             	add    $0x10,%esp
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d96f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d972:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d975:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d978:	8b 40 64             	mov    0x64(%eax),%eax
f010d97b:	ff 75 0c             	pushl  0xc(%ebp)
f010d97e:	51                   	push   %ecx
f010d97f:	52                   	push   %edx
f010d980:	50                   	push   %eax
f010d981:	e8 60 ac ff ff       	call   f01085e6 <map_frame>
f010d986:	83 c4 10             	add    $0x10,%esp
f010d989:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d98c:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d990:	75 14                	jne    f010d9a6 <__sys_allocate_page+0xf9>
	{
		decrement_references(ptr_frame_info);
f010d992:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d995:	83 ec 0c             	sub    $0xc,%esp
f010d998:	50                   	push   %eax
f010d999:	e8 3f aa ff ff       	call   f01083dd <decrement_references>
f010d99e:	83 c4 10             	add    $0x10,%esp
		return r;
f010d9a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d9a4:	eb 05                	jmp    f010d9ab <__sys_allocate_page+0xfe>
	}
	return 0 ;
f010d9a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d9ab:	c9                   	leave  
f010d9ac:	c3                   	ret    

f010d9ad <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010d9ad:	55                   	push   %ebp
f010d9ae:	89 e5                	mov    %esp,%ebp
f010d9b0:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010d9b3:	83 ec 04             	sub    $0x4,%esp
f010d9b6:	68 a7 93 12 f0       	push   $0xf01293a7
f010d9bb:	68 dc 00 00 00       	push   $0xdc
f010d9c0:	68 93 93 12 f0       	push   $0xf0129393
f010d9c5:	e8 50 29 ff ff       	call   f010031a <_panic>

f010d9ca <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010d9ca:	55                   	push   %ebp
f010d9cb:	89 e5                	mov    %esp,%ebp
f010d9cd:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010d9d0:	83 ec 04             	sub    $0x4,%esp
f010d9d3:	68 c8 93 12 f0       	push   $0xf01293c8
f010d9d8:	68 ed 00 00 00       	push   $0xed
f010d9dd:	68 93 93 12 f0       	push   $0xf0129393
f010d9e2:	e8 33 29 ff ff       	call   f010031a <_panic>

f010d9e7 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010d9e7:	55                   	push   %ebp
f010d9e8:	89 e5                	mov    %esp,%ebp
f010d9ea:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010d9ed:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010d9f2:	8b 40 64             	mov    0x64(%eax),%eax
f010d9f5:	83 ec 04             	sub    $0x4,%esp
f010d9f8:	ff 75 0c             	pushl  0xc(%ebp)
f010d9fb:	ff 75 08             	pushl  0x8(%ebp)
f010d9fe:	50                   	push   %eax
f010d9ff:	e8 4e bd ff ff       	call   f0109752 <calculate_required_frames>
f010da04:	83 c4 10             	add    $0x10,%esp
}
f010da07:	c9                   	leave  
f010da08:	c3                   	ret    

f010da09 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010da09:	55                   	push   %ebp
f010da0a:	89 e5                	mov    %esp,%ebp
f010da0c:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da0f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da12:	83 ec 0c             	sub    $0xc,%esp
f010da15:	50                   	push   %eax
f010da16:	e8 83 ae ff ff       	call   f010889e <calculate_available_frames>
f010da1b:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010da1e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010da21:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da24:	01 d0                	add    %edx,%eax
}
f010da26:	c9                   	leave  
f010da27:	c3                   	ret    

f010da28 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010da28:	55                   	push   %ebp
f010da29:	89 e5                	mov    %esp,%ebp
f010da2b:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da2e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da31:	83 ec 0c             	sub    $0xc,%esp
f010da34:	50                   	push   %eax
f010da35:	e8 64 ae ff ff       	call   f010889e <calculate_available_frames>
f010da3a:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010da3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010da40:	c9                   	leave  
f010da41:	c3                   	ret    

f010da42 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010da42:	55                   	push   %ebp
f010da43:	89 e5                	mov    %esp,%ebp
f010da45:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da48:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da4b:	83 ec 0c             	sub    $0xc,%esp
f010da4e:	50                   	push   %eax
f010da4f:	e8 4a ae ff ff       	call   f010889e <calculate_available_frames>
f010da54:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010da57:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010da5a:	c9                   	leave  
f010da5b:	c3                   	ret    

f010da5c <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010da5c:	55                   	push   %ebp
f010da5d:	89 e5                	mov    %esp,%ebp
f010da5f:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010da62:	83 ec 0c             	sub    $0xc,%esp
f010da65:	ff 75 08             	pushl  0x8(%ebp)
f010da68:	e8 e1 38 01 00       	call   f012134e <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010da6d:	83 c4 10             	add    $0x10,%esp
}
f010da70:	c9                   	leave  
f010da71:	c3                   	ret    

f010da72 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010da72:	55                   	push   %ebp
f010da73:	89 e5                	mov    %esp,%ebp
f010da75:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010da78:	e8 fc 37 01 00       	call   f0121279 <scarce_memory>
}
f010da7d:	90                   	nop
f010da7e:	c9                   	leave  
f010da7f:	c3                   	ret    

f010da80 <sys_clearFFL>:

void sys_clearFFL()
{
f010da80:	55                   	push   %ebp
f010da81:	89 e5                	mov    %esp,%ebp
f010da83:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010da86:	83 ec 0c             	sub    $0xc,%esp
f010da89:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f010da8e:	e8 8e 10 00 00       	call   f010eb21 <acquire_spinlock>
f010da93:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010da96:	a1 cc 0e 5a f0       	mov    0xf05a0ecc,%eax
f010da9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010da9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010daa5:	eb 12                	jmp    f010dab9 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010daa7:	83 ec 0c             	sub    $0xc,%esp
f010daaa:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010daad:	50                   	push   %eax
f010daae:	e8 1d a7 ff ff       	call   f01081d0 <allocate_frame>
f010dab3:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010dab6:	ff 45 f4             	incl   -0xc(%ebp)
f010dab9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dabc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010dabf:	7c e6                	jl     f010daa7 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010dac1:	83 ec 0c             	sub    $0xc,%esp
f010dac4:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f010dac9:	e8 da 10 00 00       	call   f010eba8 <release_spinlock>
f010dace:	83 c4 10             	add    $0x10,%esp
}
f010dad1:	90                   	nop
f010dad2:	c9                   	leave  
f010dad3:	c3                   	ret    

f010dad4 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010dad4:	55                   	push   %ebp
f010dad5:	89 e5                	mov    %esp,%ebp
f010dad7:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010dada:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dadf:	83 ec 0c             	sub    $0xc,%esp
f010dae2:	50                   	push   %eax
f010dae3:	e8 87 6c ff ff       	call   f010476f <pf_calculate_allocated_pages>
f010dae8:	83 c4 10             	add    $0x10,%esp
}
f010daeb:	c9                   	leave  
f010daec:	c3                   	ret    

f010daed <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010daed:	55                   	push   %ebp
f010daee:	89 e5                	mov    %esp,%ebp
f010daf0:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010daf3:	e8 db 0c 00 00       	call   f010e7d3 <isBufferingEnabled>
f010daf8:	84 c0                	test   %al,%al
f010dafa:	74 19                	je     f010db15 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010dafc:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010db01:	83 ec 04             	sub    $0x4,%esp
f010db04:	ff 75 0c             	pushl  0xc(%ebp)
f010db07:	ff 75 08             	pushl  0x8(%ebp)
f010db0a:	50                   	push   %eax
f010db0b:	e8 8d bc ff ff       	call   f010979d <__free_user_mem_with_buffering>
f010db10:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010db13:	eb 18                	jmp    f010db2d <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010db15:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010db1a:	83 ec 04             	sub    $0x4,%esp
f010db1d:	ff 75 0c             	pushl  0xc(%ebp)
f010db20:	ff 75 08             	pushl  0x8(%ebp)
f010db23:	50                   	push   %eax
f010db24:	e8 66 bc ff ff       	call   f010978f <free_user_mem>
f010db29:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010db2c:	90                   	nop
}
f010db2d:	c9                   	leave  
f010db2e:	c3                   	ret    

f010db2f <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010db2f:	55                   	push   %ebp
f010db30:	89 e5                	mov    %esp,%ebp
f010db32:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010db35:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010db39:	75 07                	jne    f010db42 <check_Param+0x13>
	{
		env_exit();
f010db3b:	e8 ee cb ff ff       	call   f010a72e <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010db40:	eb 25                	jmp    f010db67 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010db42:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010db49:	77 07                	ja     f010db52 <check_Param+0x23>
f010db4b:	8b 45 08             	mov    0x8(%ebp),%eax
f010db4e:	85 c0                	test   %eax,%eax
f010db50:	78 07                	js     f010db59 <check_Param+0x2a>
	{
		env_exit();
f010db52:	e8 d7 cb ff ff       	call   f010a72e <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010db57:	eb 0e                	jmp    f010db67 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010db59:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010db60:	76 05                	jbe    f010db67 <check_Param+0x38>
	{
		env_exit();
f010db62:	e8 c7 cb ff ff       	call   f010a72e <env_exit>
	}
}
f010db67:	90                   	nop
f010db68:	c9                   	leave  
f010db69:	c3                   	ret    

f010db6a <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010db6a:	55                   	push   %ebp
f010db6b:	89 e5                	mov    %esp,%ebp
f010db6d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010db70:	83 ec 0c             	sub    $0xc,%esp
f010db73:	ff 75 08             	pushl  0x8(%ebp)
f010db76:	e8 b4 ff ff ff       	call   f010db2f <check_Param>
f010db7b:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010db7e:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010db83:	83 ec 04             	sub    $0x4,%esp
f010db86:	ff 75 0c             	pushl  0xc(%ebp)
f010db89:	ff 75 08             	pushl  0x8(%ebp)
f010db8c:	50                   	push   %eax
f010db8d:	e8 ef bb ff ff       	call   f0109781 <allocate_user_mem>
f010db92:	83 c4 10             	add    $0x10,%esp
	return;
f010db95:	90                   	nop
}
f010db96:	c9                   	leave  
f010db97:	c3                   	ret    

f010db98 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010db98:	55                   	push   %ebp
f010db99:	89 e5                	mov    %esp,%ebp
f010db9b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010db9e:	83 ec 0c             	sub    $0xc,%esp
f010dba1:	ff 75 08             	pushl  0x8(%ebp)
f010dba4:	e8 86 ff ff ff       	call   f010db2f <check_Param>
f010dba9:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010dbac:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dbb1:	8b 40 64             	mov    0x64(%eax),%eax
f010dbb4:	ff 75 10             	pushl  0x10(%ebp)
f010dbb7:	ff 75 0c             	pushl  0xc(%ebp)
f010dbba:	ff 75 08             	pushl  0x8(%ebp)
f010dbbd:	50                   	push   %eax
f010dbbe:	e8 5b bb ff ff       	call   f010971e <allocate_chunk>
f010dbc3:	83 c4 10             	add    $0x10,%esp
	return;
f010dbc6:	90                   	nop
}
f010dbc7:	c9                   	leave  
f010dbc8:	c3                   	ret    

f010dbc9 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010dbc9:	55                   	push   %ebp
f010dbca:	89 e5                	mov    %esp,%ebp
f010dbcc:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010dbcf:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dbd4:	ff 75 10             	pushl  0x10(%ebp)
f010dbd7:	ff 75 0c             	pushl  0xc(%ebp)
f010dbda:	ff 75 08             	pushl  0x8(%ebp)
f010dbdd:	50                   	push   %eax
f010dbde:	e8 d7 bb ff ff       	call   f01097ba <move_user_mem>
f010dbe3:	83 c4 10             	add    $0x10,%esp
	return;
f010dbe6:	90                   	nop
}
f010dbe7:	c9                   	leave  
f010dbe8:	c3                   	ret    

f010dbe9 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010dbe9:	55                   	push   %ebp
f010dbea:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010dbec:	a1 a4 38 5a f0       	mov    0xf05a38a4,%eax
}
f010dbf1:	5d                   	pop    %ebp
f010dbf2:	c3                   	ret    

f010dbf3 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010dbf3:	55                   	push   %ebp
f010dbf4:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010dbf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbf9:	a3 a4 38 5a f0       	mov    %eax,0xf05a38a4
}
f010dbfe:	90                   	nop
f010dbff:	5d                   	pop    %ebp
f010dc00:	c3                   	ret    

f010dc01 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010dc01:	55                   	push   %ebp
f010dc02:	89 e5                	mov    %esp,%ebp
f010dc04:	83 ec 18             	sub    $0x18,%esp
f010dc07:	8b 45 10             	mov    0x10(%ebp),%eax
f010dc0a:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010dc0d:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010dc11:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dc16:	8b 40 10             	mov    0x10(%eax),%eax
f010dc19:	83 ec 0c             	sub    $0xc,%esp
f010dc1c:	ff 75 14             	pushl  0x14(%ebp)
f010dc1f:	52                   	push   %edx
f010dc20:	ff 75 0c             	pushl  0xc(%ebp)
f010dc23:	ff 75 08             	pushl  0x8(%ebp)
f010dc26:	50                   	push   %eax
f010dc27:	e8 dd ad ff ff       	call   f0108a09 <createSharedObject>
f010dc2c:	83 c4 20             	add    $0x20,%esp
}
f010dc2f:	c9                   	leave  
f010dc30:	c3                   	ret    

f010dc31 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010dc31:	55                   	push   %ebp
f010dc32:	89 e5                	mov    %esp,%ebp
f010dc34:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010dc37:	83 ec 08             	sub    $0x8,%esp
f010dc3a:	ff 75 0c             	pushl  0xc(%ebp)
f010dc3d:	ff 75 08             	pushl  0x8(%ebp)
f010dc40:	e8 e4 ad ff ff       	call   f0108a29 <getSizeOfSharedObject>
f010dc45:	83 c4 10             	add    $0x10,%esp
}
f010dc48:	c9                   	leave  
f010dc49:	c3                   	ret    

f010dc4a <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010dc4a:	55                   	push   %ebp
f010dc4b:	89 e5                	mov    %esp,%ebp
f010dc4d:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010dc50:	83 ec 04             	sub    $0x4,%esp
f010dc53:	ff 75 10             	pushl  0x10(%ebp)
f010dc56:	ff 75 0c             	pushl  0xc(%ebp)
f010dc59:	ff 75 08             	pushl  0x8(%ebp)
f010dc5c:	e8 f7 ad ff ff       	call   f0108a58 <getSharedObject>
f010dc61:	83 c4 10             	add    $0x10,%esp
}
f010dc64:	c9                   	leave  
f010dc65:	c3                   	ret    

f010dc66 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010dc66:	55                   	push   %ebp
f010dc67:	89 e5                	mov    %esp,%ebp
f010dc69:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010dc6c:	83 ec 08             	sub    $0x8,%esp
f010dc6f:	ff 75 0c             	pushl  0xc(%ebp)
f010dc72:	ff 75 08             	pushl  0x8(%ebp)
f010dc75:	e8 fb ad ff ff       	call   f0108a75 <freeSharedObject>
f010dc7a:	83 c4 10             	add    $0x10,%esp
}
f010dc7d:	c9                   	leave  
f010dc7e:	c3                   	ret    

f010dc7f <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010dc7f:	55                   	push   %ebp
f010dc80:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010dc82:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dc87:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dc8a:	5d                   	pop    %ebp
f010dc8b:	c3                   	ret    

f010dc8c <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010dc8c:	55                   	push   %ebp
f010dc8d:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010dc8f:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dc94:	89 c2                	mov    %eax,%edx
f010dc96:	a1 b0 03 5a f0       	mov    0xf05a03b0,%eax
f010dc9b:	29 c2                	sub    %eax,%edx
f010dc9d:	89 d0                	mov    %edx,%eax
f010dc9f:	c1 f8 02             	sar    $0x2,%eax
f010dca2:	89 c2                	mov    %eax,%edx
f010dca4:	89 d0                	mov    %edx,%eax
f010dca6:	c1 e0 02             	shl    $0x2,%eax
f010dca9:	01 d0                	add    %edx,%eax
f010dcab:	c1 e0 02             	shl    $0x2,%eax
f010dcae:	01 d0                	add    %edx,%eax
f010dcb0:	c1 e0 02             	shl    $0x2,%eax
f010dcb3:	01 d0                	add    %edx,%eax
f010dcb5:	c1 e0 02             	shl    $0x2,%eax
f010dcb8:	01 d0                	add    %edx,%eax
f010dcba:	c1 e0 08             	shl    $0x8,%eax
f010dcbd:	29 d0                	sub    %edx,%eax
f010dcbf:	c1 e0 08             	shl    $0x8,%eax
f010dcc2:	29 d0                	sub    %edx,%eax
f010dcc4:	c1 e0 03             	shl    $0x3,%eax
f010dcc7:	01 d0                	add    %edx,%eax
f010dcc9:	c1 e0 03             	shl    $0x3,%eax
f010dccc:	01 d0                	add    %edx,%eax
f010dcce:	01 c0                	add    %eax,%eax
f010dcd0:	01 d0                	add    %edx,%eax
}
f010dcd2:	5d                   	pop    %ebp
f010dcd3:	c3                   	ret    

f010dcd4 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010dcd4:	55                   	push   %ebp
f010dcd5:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010dcd7:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dcdc:	8b 40 14             	mov    0x14(%eax),%eax
}
f010dcdf:	5d                   	pop    %ebp
f010dce0:	c3                   	ret    

f010dce1 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010dce1:	55                   	push   %ebp
f010dce2:	89 e5                	mov    %esp,%ebp
f010dce4:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010dce7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010dceb:	75 0a                	jne    f010dcf7 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010dced:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dcf2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010dcf5:	eb 22                	jmp    f010dd19 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010dcf7:	83 ec 04             	sub    $0x4,%esp
f010dcfa:	6a 00                	push   $0x0
f010dcfc:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010dcff:	50                   	push   %eax
f010dd00:	ff 75 08             	pushl  0x8(%ebp)
f010dd03:	e8 b8 ca ff ff       	call   f010a7c0 <envid2env>
f010dd08:	83 c4 10             	add    $0x10,%esp
f010dd0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010dd0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dd12:	79 05                	jns    f010dd19 <sys_destroy_env+0x38>
	{
		return r;
f010dd14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd17:	eb 5e                	jmp    f010dd77 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010dd19:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dd1c:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dd21:	39 c2                	cmp    %eax,%edx
f010dd23:	75 1b                	jne    f010dd40 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010dd25:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dd2a:	8b 40 10             	mov    0x10(%eax),%eax
f010dd2d:	83 ec 08             	sub    $0x8,%esp
f010dd30:	50                   	push   %eax
f010dd31:	68 e7 93 12 f0       	push   $0xf01293e7
f010dd36:	e8 31 32 ff ff       	call   f0100f6c <cprintf>
f010dd3b:	83 c4 10             	add    $0x10,%esp
f010dd3e:	eb 20                	jmp    f010dd60 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010dd40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd43:	8b 50 10             	mov    0x10(%eax),%edx
f010dd46:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010dd4b:	8b 40 10             	mov    0x10(%eax),%eax
f010dd4e:	83 ec 04             	sub    $0x4,%esp
f010dd51:	52                   	push   %edx
f010dd52:	50                   	push   %eax
f010dd53:	68 02 94 12 f0       	push   $0xf0129402
f010dd58:	e8 0f 32 ff ff       	call   f0100f6c <cprintf>
f010dd5d:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010dd60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd63:	8b 40 10             	mov    0x10(%eax),%eax
f010dd66:	83 ec 0c             	sub    $0xc,%esp
f010dd69:	50                   	push   %eax
f010dd6a:	e8 f4 7c ff ff       	call   f0105a63 <sched_kill_env>
f010dd6f:	83 c4 10             	add    $0x10,%esp

	return 0;
f010dd72:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010dd77:	c9                   	leave  
f010dd78:	c3                   	ret    

f010dd79 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010dd79:	55                   	push   %ebp
f010dd7a:	89 e5                	mov    %esp,%ebp
f010dd7c:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010dd7f:	e8 aa c9 ff ff       	call   f010a72e <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010dd84:	90                   	nop
f010dd85:	c9                   	leave  
f010dd86:	c3                   	ret    

f010dd87 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010dd87:	55                   	push   %ebp
f010dd88:	89 e5                	mov    %esp,%ebp
f010dd8a:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010dd8d:	ff 75 14             	pushl  0x14(%ebp)
f010dd90:	ff 75 10             	pushl  0x10(%ebp)
f010dd93:	ff 75 0c             	pushl  0xc(%ebp)
f010dd96:	ff 75 08             	pushl  0x8(%ebp)
f010dd99:	e8 d2 bc ff ff       	call   f0109a70 <env_create>
f010dd9e:	83 c4 10             	add    $0x10,%esp
f010dda1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010dda4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dda8:	75 07                	jne    f010ddb1 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ddaa:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ddaf:	eb 14                	jmp    f010ddc5 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ddb1:	83 ec 0c             	sub    $0xc,%esp
f010ddb4:	ff 75 f4             	pushl  -0xc(%ebp)
f010ddb7:	e8 e9 78 ff ff       	call   f01056a5 <sched_new_env>
f010ddbc:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ddbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ddc2:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ddc5:	c9                   	leave  
f010ddc6:	c3                   	ret    

f010ddc7 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ddc7:	55                   	push   %ebp
f010ddc8:	89 e5                	mov    %esp,%ebp
f010ddca:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ddcd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddd0:	83 ec 0c             	sub    $0xc,%esp
f010ddd3:	50                   	push   %eax
f010ddd4:	e8 22 79 ff ff       	call   f01056fb <sched_run_env>
f010ddd9:	83 c4 10             	add    $0x10,%esp
}
f010dddc:	90                   	nop
f010dddd:	c9                   	leave  
f010ddde:	c3                   	ret    

f010dddf <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010dddf:	55                   	push   %ebp
f010dde0:	89 e5                	mov    %esp,%ebp
f010dde2:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010dde5:	0f 31                	rdtsc  
f010dde7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ddea:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010dded:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ddf0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ddf3:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ddf6:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ddf9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ddfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ddff:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010de02:	89 01                	mov    %eax,(%ecx)
f010de04:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010de07:	8b 45 08             	mov    0x8(%ebp),%eax
f010de0a:	c9                   	leave  
f010de0b:	c2 04 00             	ret    $0x4

f010de0e <sys_rcr2>:

uint32 sys_rcr2()
{
f010de0e:	55                   	push   %ebp
f010de0f:	89 e5                	mov    %esp,%ebp
f010de11:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010de14:	0f 20 d0             	mov    %cr2,%eax
f010de17:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010de1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010de1d:	90                   	nop
}
f010de1e:	c9                   	leave  
f010de1f:	c3                   	ret    

f010de20 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010de20:	55                   	push   %ebp
f010de21:	89 e5                	mov    %esp,%ebp
f010de23:	83 ec 04             	sub    $0x4,%esp
f010de26:	8b 45 08             	mov    0x8(%ebp),%eax
f010de29:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010de2c:	8a 45 fc             	mov    -0x4(%ebp),%al
f010de2f:	a2 20 0c 5a f0       	mov    %al,0xf05a0c20
}
f010de34:	90                   	nop
f010de35:	c9                   	leave  
f010de36:	c3                   	ret    

f010de37 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010de37:	55                   	push   %ebp
f010de38:	89 e5                	mov    %esp,%ebp
f010de3a:	56                   	push   %esi
f010de3b:	53                   	push   %ebx
f010de3c:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010de3f:	e8 2c c9 ff ff       	call   f010a770 <get_cpu_proc>
f010de44:	a3 64 20 5c f0       	mov    %eax,0xf05c2064
	assert(cur_env != NULL);
f010de49:	a1 64 20 5c f0       	mov    0xf05c2064,%eax
f010de4e:	85 c0                	test   %eax,%eax
f010de50:	75 19                	jne    f010de6b <syscall+0x34>
f010de52:	68 1a 94 12 f0       	push   $0xf012941a
f010de57:	68 2a 94 12 f0       	push   $0xf012942a
f010de5c:	68 05 02 00 00       	push   $0x205
f010de61:	68 93 93 12 f0       	push   $0xf0129393
f010de66:	e8 af 24 ff ff       	call   f010031a <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010de6b:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010de6f:	0f 87 06 04 00 00    	ja     f010e27b <syscall+0x444>
f010de75:	8b 45 08             	mov    0x8(%ebp),%eax
f010de78:	c1 e0 02             	shl    $0x2,%eax
f010de7b:	05 40 94 12 f0       	add    $0xf0129440,%eax
f010de80:	8b 00                	mov    (%eax),%eax
f010de82:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010de84:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de87:	83 ec 0c             	sub    $0xc,%esp
f010de8a:	50                   	push   %eax
f010de8b:	e8 dc b8 ff ff       	call   f010976c <sys_sbrk>
f010de90:	83 c4 10             	add    $0x10,%esp
f010de93:	e9 e8 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010de98:	83 ec 08             	sub    $0x8,%esp
f010de9b:	ff 75 10             	pushl  0x10(%ebp)
f010de9e:	ff 75 0c             	pushl  0xc(%ebp)
f010dea1:	e8 47 fc ff ff       	call   f010daed <sys_free_user_mem>
f010dea6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dea9:	b8 00 00 00 00       	mov    $0x0,%eax
f010deae:	e9 cd 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010deb3:	83 ec 08             	sub    $0x8,%esp
f010deb6:	ff 75 10             	pushl  0x10(%ebp)
f010deb9:	ff 75 0c             	pushl  0xc(%ebp)
f010debc:	e8 a9 fc ff ff       	call   f010db6a <sys_allocate_user_mem>
f010dec1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dec4:	b8 00 00 00 00       	mov    $0x0,%eax
f010dec9:	e9 b2 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010dece:	8b 45 14             	mov    0x14(%ebp),%eax
f010ded1:	0f b6 d0             	movzbl %al,%edx
f010ded4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ded7:	83 ec 04             	sub    $0x4,%esp
f010deda:	52                   	push   %edx
f010dedb:	ff 75 10             	pushl  0x10(%ebp)
f010dede:	50                   	push   %eax
f010dedf:	e8 f2 f8 ff ff       	call   f010d7d6 <sys_cputs>
f010dee4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dee7:	b8 00 00 00 00       	mov    $0x0,%eax
f010deec:	e9 8f 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010def1:	e8 5c f9 ff ff       	call   f010d852 <sys_cgetc>
f010def6:	e9 85 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010defb:	e8 91 f9 ff ff       	call   f010d891 <sys_lock_cons>
		return 0;
f010df00:	b8 00 00 00 00       	mov    $0x0,%eax
f010df05:	e9 76 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010df0a:	e8 90 f9 ff ff       	call   f010d89f <sys_unlock_cons>
		return 0;
f010df0f:	b8 00 00 00 00       	mov    $0x0,%eax
f010df14:	e9 67 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010df19:	83 ec 08             	sub    $0x8,%esp
f010df1c:	ff 75 10             	pushl  0x10(%ebp)
f010df1f:	ff 75 0c             	pushl  0xc(%ebp)
f010df22:	e8 c0 fa ff ff       	call   f010d9e7 <sys_calculate_required_frames>
f010df27:	83 c4 10             	add    $0x10,%esp
f010df2a:	e9 51 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010df2f:	e8 d5 fa ff ff       	call   f010da09 <sys_calculate_free_frames>
f010df34:	e9 47 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010df39:	e8 ea fa ff ff       	call   f010da28 <sys_calculate_modified_frames>
f010df3e:	e9 3d 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010df43:	e8 fa fa ff ff       	call   f010da42 <sys_calculate_notmod_frames>
f010df48:	e9 33 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010df4d:	e8 82 fb ff ff       	call   f010dad4 <sys_pf_calculate_allocated_pages>
f010df52:	e9 29 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010df57:	83 ec 0c             	sub    $0xc,%esp
f010df5a:	ff 75 0c             	pushl  0xc(%ebp)
f010df5d:	e8 fa fa ff ff       	call   f010da5c <sys_calculate_pages_tobe_removed_ready_exit>
f010df62:	83 c4 10             	add    $0x10,%esp
f010df65:	e9 16 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010df6a:	e8 03 fb ff ff       	call   f010da72 <sys_scarce_memory>
		return 0;
f010df6f:	b8 00 00 00 00       	mov    $0x0,%eax
f010df74:	e9 07 03 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010df79:	83 ec 04             	sub    $0x4,%esp
f010df7c:	ff 75 14             	pushl  0x14(%ebp)
f010df7f:	ff 75 10             	pushl  0x10(%ebp)
f010df82:	ff 75 0c             	pushl  0xc(%ebp)
f010df85:	e8 0e fc ff ff       	call   f010db98 <sys_allocate_chunk>
f010df8a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010df8d:	b8 00 00 00 00       	mov    $0x0,%eax
f010df92:	e9 e9 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010df97:	8b 55 10             	mov    0x10(%ebp),%edx
f010df9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df9d:	83 ec 08             	sub    $0x8,%esp
f010dfa0:	52                   	push   %edx
f010dfa1:	50                   	push   %eax
f010dfa2:	e8 06 f9 ff ff       	call   f010d8ad <__sys_allocate_page>
f010dfa7:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dfaa:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfaf:	e9 cc 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010dfb4:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010dfb7:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010dfba:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dfbd:	8b 55 10             	mov    0x10(%ebp),%edx
f010dfc0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfc3:	83 ec 0c             	sub    $0xc,%esp
f010dfc6:	56                   	push   %esi
f010dfc7:	53                   	push   %ebx
f010dfc8:	51                   	push   %ecx
f010dfc9:	52                   	push   %edx
f010dfca:	50                   	push   %eax
f010dfcb:	e8 dd f9 ff ff       	call   f010d9ad <__sys_map_frame>
f010dfd0:	83 c4 20             	add    $0x20,%esp
		return 0;
f010dfd3:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfd8:	e9 a3 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010dfdd:	8b 55 10             	mov    0x10(%ebp),%edx
f010dfe0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfe3:	83 ec 08             	sub    $0x8,%esp
f010dfe6:	52                   	push   %edx
f010dfe7:	50                   	push   %eax
f010dfe8:	e8 dd f9 ff ff       	call   f010d9ca <__sys_unmap_frame>
f010dfed:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dff0:	b8 00 00 00 00       	mov    $0x0,%eax
f010dff5:	e9 86 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010dffa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dffd:	0f be c0             	movsbl %al,%eax
f010e000:	83 ec 0c             	sub    $0xc,%esp
f010e003:	50                   	push   %eax
f010e004:	e8 25 f8 ff ff       	call   f010d82e <sys_cputc>
f010e009:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e00c:	b8 00 00 00 00       	mov    $0x0,%eax
f010e011:	e9 6a 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010e016:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e019:	0f be c0             	movsbl %al,%eax
f010e01c:	83 ec 0c             	sub    $0xc,%esp
f010e01f:	50                   	push   %eax
f010e020:	e8 5b fa ff ff       	call   f010da80 <sys_clearFFL>
f010e025:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e028:	b8 00 00 00 00       	mov    $0x0,%eax
f010e02d:	e9 4e 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e032:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e035:	8b 45 14             	mov    0x14(%ebp),%eax
f010e038:	0f b6 d0             	movzbl %al,%edx
f010e03b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e03e:	51                   	push   %ecx
f010e03f:	52                   	push   %edx
f010e040:	ff 75 10             	pushl  0x10(%ebp)
f010e043:	50                   	push   %eax
f010e044:	e8 b8 fb ff ff       	call   f010dc01 <sys_createSharedObject>
f010e049:	83 c4 10             	add    $0x10,%esp
f010e04c:	e9 2f 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e051:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e054:	8b 55 10             	mov    0x10(%ebp),%edx
f010e057:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e05a:	83 ec 04             	sub    $0x4,%esp
f010e05d:	51                   	push   %ecx
f010e05e:	52                   	push   %edx
f010e05f:	50                   	push   %eax
f010e060:	e8 e5 fb ff ff       	call   f010dc4a <sys_getSharedObject>
f010e065:	83 c4 10             	add    $0x10,%esp
f010e068:	e9 13 02 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e06d:	8b 55 10             	mov    0x10(%ebp),%edx
f010e070:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e073:	83 ec 08             	sub    $0x8,%esp
f010e076:	52                   	push   %edx
f010e077:	50                   	push   %eax
f010e078:	e8 e9 fb ff ff       	call   f010dc66 <sys_freeSharedObject>
f010e07d:	83 c4 10             	add    $0x10,%esp
f010e080:	e9 fb 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e085:	8b 55 10             	mov    0x10(%ebp),%edx
f010e088:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e08b:	83 ec 08             	sub    $0x8,%esp
f010e08e:	52                   	push   %edx
f010e08f:	50                   	push   %eax
f010e090:	e8 9c fb ff ff       	call   f010dc31 <sys_getSizeOfSharedObject>
f010e095:	83 c4 10             	add    $0x10,%esp
f010e098:	e9 e3 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e09d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0a0:	ff 75 18             	pushl  0x18(%ebp)
f010e0a3:	ff 75 14             	pushl  0x14(%ebp)
f010e0a6:	ff 75 10             	pushl  0x10(%ebp)
f010e0a9:	50                   	push   %eax
f010e0aa:	e8 d8 fc ff ff       	call   f010dd87 <sys_create_env>
f010e0af:	83 c4 10             	add    $0x10,%esp
f010e0b2:	e9 c9 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e0b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0ba:	83 ec 0c             	sub    $0xc,%esp
f010e0bd:	50                   	push   %eax
f010e0be:	e8 04 fd ff ff       	call   f010ddc7 <sys_run_env>
f010e0c3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e0c6:	b8 00 00 00 00       	mov    $0x0,%eax
f010e0cb:	e9 b0 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e0d0:	e8 b7 fb ff ff       	call   f010dc8c <sys_getenvindex>
f010e0d5:	e9 a6 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e0da:	e8 a0 fb ff ff       	call   f010dc7f <sys_getenvid>
f010e0df:	e9 9c 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e0e4:	e8 eb fb ff ff       	call   f010dcd4 <sys_getparentenvid>
f010e0e9:	e9 92 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e0ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0f1:	83 ec 0c             	sub    $0xc,%esp
f010e0f4:	50                   	push   %eax
f010e0f5:	e8 e7 fb ff ff       	call   f010dce1 <sys_destroy_env>
f010e0fa:	83 c4 10             	add    $0x10,%esp
f010e0fd:	e9 7e 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e102:	e8 72 fc ff ff       	call   f010dd79 <sys_exit_env>
		return 0;
f010e107:	b8 00 00 00 00       	mov    $0x0,%eax
f010e10c:	e9 6f 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e111:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e114:	83 ec 0c             	sub    $0xc,%esp
f010e117:	50                   	push   %eax
f010e118:	e8 c2 fc ff ff       	call   f010dddf <sys_get_virtual_time>
f010e11d:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e120:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e123:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e126:	8b 45 10             	mov    0x10(%ebp),%eax
f010e129:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e12c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e12f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e132:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010e134:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e137:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e13a:	89 10                	mov    %edx,(%eax)
		return 0;
f010e13c:	b8 00 00 00 00       	mov    $0x0,%eax
f010e141:	e9 3a 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010e146:	83 ec 04             	sub    $0x4,%esp
f010e149:	ff 75 14             	pushl  0x14(%ebp)
f010e14c:	ff 75 10             	pushl  0x10(%ebp)
f010e14f:	ff 75 0c             	pushl  0xc(%ebp)
f010e152:	e8 72 fa ff ff       	call   f010dbc9 <sys_move_user_mem>
f010e157:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e15a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e15f:	e9 1c 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010e164:	e8 a5 fc ff ff       	call   f010de0e <sys_rcr2>
f010e169:	e9 12 01 00 00       	jmp    f010e280 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010e16e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e171:	0f b6 c0             	movzbl %al,%eax
f010e174:	83 ec 0c             	sub    $0xc,%esp
f010e177:	50                   	push   %eax
f010e178:	e8 a3 fc ff ff       	call   f010de20 <sys_bypassPageFault>
f010e17d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e180:	b8 00 00 00 00       	mov    $0x0,%eax
f010e185:	e9 f6 00 00 00       	jmp    f010e280 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010e18a:	e8 b6 28 01 00       	call   f0120a45 <rsttst>
		return 0;
f010e18f:	b8 00 00 00 00       	mov    $0x0,%eax
f010e194:	e9 e7 00 00 00       	jmp    f010e280 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010e199:	e8 ef 28 01 00       	call   f0120a8d <inctst>
		return 0;
f010e19e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1a3:	e9 d8 00 00 00       	jmp    f010e280 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010e1a8:	83 ec 0c             	sub    $0xc,%esp
f010e1ab:	ff 75 0c             	pushl  0xc(%ebp)
f010e1ae:	e8 1c 2a 01 00       	call   f0120bcf <chktst>
f010e1b3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e1b6:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1bb:	e9 c0 00 00 00       	jmp    f010e280 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010e1c0:	e8 fc 28 01 00       	call   f0120ac1 <gettst>
f010e1c5:	e9 b6 00 00 00       	jmp    f010e280 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010e1ca:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010e1cd:	8b 45 18             	mov    0x18(%ebp),%eax
f010e1d0:	0f be c0             	movsbl %al,%eax
f010e1d3:	83 ec 0c             	sub    $0xc,%esp
f010e1d6:	52                   	push   %edx
f010e1d7:	50                   	push   %eax
f010e1d8:	ff 75 14             	pushl  0x14(%ebp)
f010e1db:	ff 75 10             	pushl  0x10(%ebp)
f010e1de:	ff 75 0c             	pushl  0xc(%ebp)
f010e1e1:	e8 e5 28 01 00       	call   f0120acb <tst>
f010e1e6:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e1e9:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1ee:	e9 8d 00 00 00       	jmp    f010e280 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010e1f3:	e8 f1 f9 ff ff       	call   f010dbe9 <sys_get_heap_strategy>
f010e1f8:	e9 83 00 00 00       	jmp    f010e280 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010e1fd:	83 ec 0c             	sub    $0xc,%esp
f010e200:	ff 75 0c             	pushl  0xc(%ebp)
f010e203:	e8 eb f9 ff ff       	call   f010dbf3 <sys_set_uheap_strategy>
f010e208:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e20b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e210:	eb 6e                	jmp    f010e280 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010e212:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e215:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e218:	8b 55 10             	mov    0x10(%ebp),%edx
f010e21b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e21e:	53                   	push   %ebx
f010e21f:	51                   	push   %ecx
f010e220:	52                   	push   %edx
f010e221:	50                   	push   %eax
f010e222:	e8 35 4d 00 00       	call   f0112f5c <sys_check_LRU_lists>
f010e227:	83 c4 10             	add    $0x10,%esp
f010e22a:	eb 54                	jmp    f010e280 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010e22c:	8b 55 10             	mov    0x10(%ebp),%edx
f010e22f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e232:	83 ec 08             	sub    $0x8,%esp
f010e235:	52                   	push   %edx
f010e236:	50                   	push   %eax
f010e237:	e8 e2 4e 00 00       	call   f011311e <sys_check_LRU_lists_free>
f010e23c:	83 c4 10             	add    $0x10,%esp
f010e23f:	eb 3f                	jmp    f010e280 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010e241:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e244:	8b 55 10             	mov    0x10(%ebp),%edx
f010e247:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e24a:	51                   	push   %ecx
f010e24b:	ff 75 14             	pushl  0x14(%ebp)
f010e24e:	52                   	push   %edx
f010e24f:	50                   	push   %eax
f010e250:	e8 56 50 00 00       	call   f01132ab <sys_check_WS_list>
f010e255:	83 c4 10             	add    $0x10,%esp
f010e258:	eb 26                	jmp    f010e280 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010e25a:	8b 55 10             	mov    0x10(%ebp),%edx
f010e25d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e260:	83 ec 08             	sub    $0x8,%esp
f010e263:	52                   	push   %edx
f010e264:	50                   	push   %eax
f010e265:	e8 66 2b 01 00       	call   f0120dd0 <sys_utilities>
f010e26a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e26d:	b8 00 00 00 00       	mov    $0x0,%eax
f010e272:	eb 0c                	jmp    f010e280 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010e274:	b8 03 00 00 00       	mov    $0x3,%eax
f010e279:	eb 05                	jmp    f010e280 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010e27b:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010e280:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e283:	5b                   	pop    %ebx
f010e284:	5e                   	pop    %esi
f010e285:	5d                   	pop    %ebp
f010e286:	c3                   	ret    

f010e287 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010e287:	55                   	push   %ebp
f010e288:	89 e5                	mov    %esp,%ebp
f010e28a:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010e28d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e290:	8b 00                	mov    (%eax),%eax
f010e292:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e295:	8b 45 10             	mov    0x10(%ebp),%eax
f010e298:	8b 00                	mov    (%eax),%eax
f010e29a:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e29d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010e2a4:	e9 ca 00 00 00       	jmp    f010e373 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010e2a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e2ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e2af:	01 d0                	add    %edx,%eax
f010e2b1:	89 c2                	mov    %eax,%edx
f010e2b3:	c1 ea 1f             	shr    $0x1f,%edx
f010e2b6:	01 d0                	add    %edx,%eax
f010e2b8:	d1 f8                	sar    %eax
f010e2ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010e2bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e2c0:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e2c3:	eb 03                	jmp    f010e2c8 <stab_binsearch+0x41>
			m--;
f010e2c5:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e2c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2cb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e2ce:	7c 1e                	jl     f010e2ee <stab_binsearch+0x67>
f010e2d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e2d3:	89 d0                	mov    %edx,%eax
f010e2d5:	01 c0                	add    %eax,%eax
f010e2d7:	01 d0                	add    %edx,%eax
f010e2d9:	c1 e0 02             	shl    $0x2,%eax
f010e2dc:	89 c2                	mov    %eax,%edx
f010e2de:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2e1:	01 d0                	add    %edx,%eax
f010e2e3:	8a 40 04             	mov    0x4(%eax),%al
f010e2e6:	0f b6 c0             	movzbl %al,%eax
f010e2e9:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e2ec:	75 d7                	jne    f010e2c5 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010e2ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2f1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e2f4:	7d 09                	jge    f010e2ff <stab_binsearch+0x78>
			l = true_m + 1;
f010e2f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e2f9:	40                   	inc    %eax
f010e2fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010e2fd:	eb 74                	jmp    f010e373 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010e2ff:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010e306:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e309:	89 d0                	mov    %edx,%eax
f010e30b:	01 c0                	add    %eax,%eax
f010e30d:	01 d0                	add    %edx,%eax
f010e30f:	c1 e0 02             	shl    $0x2,%eax
f010e312:	89 c2                	mov    %eax,%edx
f010e314:	8b 45 08             	mov    0x8(%ebp),%eax
f010e317:	01 d0                	add    %edx,%eax
f010e319:	8b 40 08             	mov    0x8(%eax),%eax
f010e31c:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e31f:	73 11                	jae    f010e332 <stab_binsearch+0xab>
			*region_left = m;
f010e321:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e324:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e327:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010e329:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e32c:	40                   	inc    %eax
f010e32d:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e330:	eb 41                	jmp    f010e373 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010e332:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e335:	89 d0                	mov    %edx,%eax
f010e337:	01 c0                	add    %eax,%eax
f010e339:	01 d0                	add    %edx,%eax
f010e33b:	c1 e0 02             	shl    $0x2,%eax
f010e33e:	89 c2                	mov    %eax,%edx
f010e340:	8b 45 08             	mov    0x8(%ebp),%eax
f010e343:	01 d0                	add    %edx,%eax
f010e345:	8b 40 08             	mov    0x8(%eax),%eax
f010e348:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e34b:	76 14                	jbe    f010e361 <stab_binsearch+0xda>
			*region_right = m - 1;
f010e34d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e350:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e353:	8b 45 10             	mov    0x10(%ebp),%eax
f010e356:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010e358:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e35b:	48                   	dec    %eax
f010e35c:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e35f:	eb 12                	jmp    f010e373 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010e361:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e364:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e367:	89 10                	mov    %edx,(%eax)
			l = m;
f010e369:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e36c:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010e36f:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010e373:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e376:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010e379:	0f 8e 2a ff ff ff    	jle    f010e2a9 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010e37f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e383:	75 0f                	jne    f010e394 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010e385:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e388:	8b 00                	mov    (%eax),%eax
f010e38a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e38d:	8b 45 10             	mov    0x10(%ebp),%eax
f010e390:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010e392:	eb 3d                	jmp    f010e3d1 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e394:	8b 45 10             	mov    0x10(%ebp),%eax
f010e397:	8b 00                	mov    (%eax),%eax
f010e399:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e39c:	eb 03                	jmp    f010e3a1 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010e39e:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e3a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3a4:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e3a6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e3a9:	7d 1e                	jge    f010e3c9 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e3ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e3ae:	89 d0                	mov    %edx,%eax
f010e3b0:	01 c0                	add    %eax,%eax
f010e3b2:	01 d0                	add    %edx,%eax
f010e3b4:	c1 e0 02             	shl    $0x2,%eax
f010e3b7:	89 c2                	mov    %eax,%edx
f010e3b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3bc:	01 d0                	add    %edx,%eax
f010e3be:	8a 40 04             	mov    0x4(%eax),%al
f010e3c1:	0f b6 c0             	movzbl %al,%eax
f010e3c4:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e3c7:	75 d5                	jne    f010e39e <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e3c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e3cf:	89 10                	mov    %edx,(%eax)
	}
}
f010e3d1:	90                   	nop
f010e3d2:	c9                   	leave  
f010e3d3:	c3                   	ret    

f010e3d4 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e3d4:	55                   	push   %ebp
f010e3d5:	89 e5                	mov    %esp,%ebp
f010e3d7:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e3da:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3dd:	c7 00 fc 94 12 f0    	movl   $0xf01294fc,(%eax)
	info->eip_line = 0;
f010e3e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3e6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e3ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3f0:	c7 40 08 fc 94 12 f0 	movl   $0xf01294fc,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e3f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3fa:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e401:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e404:	8b 55 08             	mov    0x8(%ebp),%edx
f010e407:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e40a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e40d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e414:	8b 45 08             	mov    0x8(%ebp),%eax
f010e417:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e41c:	76 1e                	jbe    f010e43c <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e41e:	c7 45 f4 40 08 13 f0 	movl   $0xf0130840,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e425:	c7 45 f0 e8 47 16 f0 	movl   $0xf01647e8,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e42c:	c7 45 ec e9 47 16 f0 	movl   $0xf01647e9,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e433:	c7 45 e8 5e 60 17 f0 	movl   $0xf017605e,-0x18(%ebp)
f010e43a:	eb 2a                	jmp    f010e466 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e43c:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e443:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e446:	8b 00                	mov    (%eax),%eax
f010e448:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e44b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e44e:	8b 40 04             	mov    0x4(%eax),%eax
f010e451:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e454:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e457:	8b 40 08             	mov    0x8(%eax),%eax
f010e45a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e45d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e460:	8b 40 0c             	mov    0xc(%eax),%eax
f010e463:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e466:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e469:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e46c:	76 0a                	jbe    f010e478 <debuginfo_eip+0xa4>
f010e46e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e471:	48                   	dec    %eax
f010e472:	8a 00                	mov    (%eax),%al
f010e474:	84 c0                	test   %al,%al
f010e476:	74 0a                	je     f010e482 <debuginfo_eip+0xae>
		return -1;
f010e478:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e47d:	e9 01 02 00 00       	jmp    f010e683 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e482:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e489:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e48c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e48f:	29 c2                	sub    %eax,%edx
f010e491:	89 d0                	mov    %edx,%eax
f010e493:	c1 f8 02             	sar    $0x2,%eax
f010e496:	89 c2                	mov    %eax,%edx
f010e498:	89 d0                	mov    %edx,%eax
f010e49a:	c1 e0 02             	shl    $0x2,%eax
f010e49d:	01 d0                	add    %edx,%eax
f010e49f:	c1 e0 02             	shl    $0x2,%eax
f010e4a2:	01 d0                	add    %edx,%eax
f010e4a4:	c1 e0 02             	shl    $0x2,%eax
f010e4a7:	01 d0                	add    %edx,%eax
f010e4a9:	89 c1                	mov    %eax,%ecx
f010e4ab:	c1 e1 08             	shl    $0x8,%ecx
f010e4ae:	01 c8                	add    %ecx,%eax
f010e4b0:	89 c1                	mov    %eax,%ecx
f010e4b2:	c1 e1 10             	shl    $0x10,%ecx
f010e4b5:	01 c8                	add    %ecx,%eax
f010e4b7:	01 c0                	add    %eax,%eax
f010e4b9:	01 d0                	add    %edx,%eax
f010e4bb:	48                   	dec    %eax
f010e4bc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e4bf:	ff 75 08             	pushl  0x8(%ebp)
f010e4c2:	6a 64                	push   $0x64
f010e4c4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e4c7:	50                   	push   %eax
f010e4c8:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e4cb:	50                   	push   %eax
f010e4cc:	ff 75 f4             	pushl  -0xc(%ebp)
f010e4cf:	e8 b3 fd ff ff       	call   f010e287 <stab_binsearch>
f010e4d4:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e4d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4da:	85 c0                	test   %eax,%eax
f010e4dc:	75 0a                	jne    f010e4e8 <debuginfo_eip+0x114>
		return -1;
f010e4de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e4e3:	e9 9b 01 00 00       	jmp    f010e683 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e4e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e4ee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e4f1:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e4f4:	ff 75 08             	pushl  0x8(%ebp)
f010e4f7:	6a 24                	push   $0x24
f010e4f9:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e4fc:	50                   	push   %eax
f010e4fd:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e500:	50                   	push   %eax
f010e501:	ff 75 f4             	pushl  -0xc(%ebp)
f010e504:	e8 7e fd ff ff       	call   f010e287 <stab_binsearch>
f010e509:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e50c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e50f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e512:	39 c2                	cmp    %eax,%edx
f010e514:	0f 8f 86 00 00 00    	jg     f010e5a0 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e51a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e51d:	89 c2                	mov    %eax,%edx
f010e51f:	89 d0                	mov    %edx,%eax
f010e521:	01 c0                	add    %eax,%eax
f010e523:	01 d0                	add    %edx,%eax
f010e525:	c1 e0 02             	shl    $0x2,%eax
f010e528:	89 c2                	mov    %eax,%edx
f010e52a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e52d:	01 d0                	add    %edx,%eax
f010e52f:	8b 00                	mov    (%eax),%eax
f010e531:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e534:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e537:	29 d1                	sub    %edx,%ecx
f010e539:	89 ca                	mov    %ecx,%edx
f010e53b:	39 d0                	cmp    %edx,%eax
f010e53d:	73 22                	jae    f010e561 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e53f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e542:	89 c2                	mov    %eax,%edx
f010e544:	89 d0                	mov    %edx,%eax
f010e546:	01 c0                	add    %eax,%eax
f010e548:	01 d0                	add    %edx,%eax
f010e54a:	c1 e0 02             	shl    $0x2,%eax
f010e54d:	89 c2                	mov    %eax,%edx
f010e54f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e552:	01 d0                	add    %edx,%eax
f010e554:	8b 10                	mov    (%eax),%edx
f010e556:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e559:	01 c2                	add    %eax,%edx
f010e55b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e55e:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e561:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e564:	89 c2                	mov    %eax,%edx
f010e566:	89 d0                	mov    %edx,%eax
f010e568:	01 c0                	add    %eax,%eax
f010e56a:	01 d0                	add    %edx,%eax
f010e56c:	c1 e0 02             	shl    $0x2,%eax
f010e56f:	89 c2                	mov    %eax,%edx
f010e571:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e574:	01 d0                	add    %edx,%eax
f010e576:	8b 50 08             	mov    0x8(%eax),%edx
f010e579:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e57c:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e57f:	8b 55 08             	mov    0x8(%ebp),%edx
f010e582:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e585:	8b 40 10             	mov    0x10(%eax),%eax
f010e588:	29 c2                	sub    %eax,%edx
f010e58a:	89 d0                	mov    %edx,%eax
f010e58c:	c1 f8 02             	sar    $0x2,%eax
f010e58f:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e592:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e595:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e598:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e59b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e59e:	eb 15                	jmp    f010e5b5 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e5a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5a3:	8b 55 08             	mov    0x8(%ebp),%edx
f010e5a6:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e5a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e5af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e5b2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e5b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5b8:	8b 40 08             	mov    0x8(%eax),%eax
f010e5bb:	83 ec 08             	sub    $0x8,%esp
f010e5be:	6a 3a                	push   $0x3a
f010e5c0:	50                   	push   %eax
f010e5c1:	e8 d1 41 01 00       	call   f0122797 <strfind>
f010e5c6:	83 c4 10             	add    $0x10,%esp
f010e5c9:	89 c2                	mov    %eax,%edx
f010e5cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5ce:	8b 40 08             	mov    0x8(%eax),%eax
f010e5d1:	29 c2                	sub    %eax,%edx
f010e5d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5d6:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e5d9:	eb 03                	jmp    f010e5de <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e5db:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e5de:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5e1:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e5e4:	7c 4e                	jl     f010e634 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e5e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e5e9:	89 d0                	mov    %edx,%eax
f010e5eb:	01 c0                	add    %eax,%eax
f010e5ed:	01 d0                	add    %edx,%eax
f010e5ef:	c1 e0 02             	shl    $0x2,%eax
f010e5f2:	89 c2                	mov    %eax,%edx
f010e5f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5f7:	01 d0                	add    %edx,%eax
f010e5f9:	8a 40 04             	mov    0x4(%eax),%al
f010e5fc:	3c 84                	cmp    $0x84,%al
f010e5fe:	74 34                	je     f010e634 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e600:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e603:	89 d0                	mov    %edx,%eax
f010e605:	01 c0                	add    %eax,%eax
f010e607:	01 d0                	add    %edx,%eax
f010e609:	c1 e0 02             	shl    $0x2,%eax
f010e60c:	89 c2                	mov    %eax,%edx
f010e60e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e611:	01 d0                	add    %edx,%eax
f010e613:	8a 40 04             	mov    0x4(%eax),%al
f010e616:	3c 64                	cmp    $0x64,%al
f010e618:	75 c1                	jne    f010e5db <debuginfo_eip+0x207>
f010e61a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e61d:	89 d0                	mov    %edx,%eax
f010e61f:	01 c0                	add    %eax,%eax
f010e621:	01 d0                	add    %edx,%eax
f010e623:	c1 e0 02             	shl    $0x2,%eax
f010e626:	89 c2                	mov    %eax,%edx
f010e628:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e62b:	01 d0                	add    %edx,%eax
f010e62d:	8b 40 08             	mov    0x8(%eax),%eax
f010e630:	85 c0                	test   %eax,%eax
f010e632:	74 a7                	je     f010e5db <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e634:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e637:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e63a:	7c 42                	jl     f010e67e <debuginfo_eip+0x2aa>
f010e63c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e63f:	89 d0                	mov    %edx,%eax
f010e641:	01 c0                	add    %eax,%eax
f010e643:	01 d0                	add    %edx,%eax
f010e645:	c1 e0 02             	shl    $0x2,%eax
f010e648:	89 c2                	mov    %eax,%edx
f010e64a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e64d:	01 d0                	add    %edx,%eax
f010e64f:	8b 00                	mov    (%eax),%eax
f010e651:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e654:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e657:	29 d1                	sub    %edx,%ecx
f010e659:	89 ca                	mov    %ecx,%edx
f010e65b:	39 d0                	cmp    %edx,%eax
f010e65d:	73 1f                	jae    f010e67e <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e65f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e662:	89 d0                	mov    %edx,%eax
f010e664:	01 c0                	add    %eax,%eax
f010e666:	01 d0                	add    %edx,%eax
f010e668:	c1 e0 02             	shl    $0x2,%eax
f010e66b:	89 c2                	mov    %eax,%edx
f010e66d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e670:	01 d0                	add    %edx,%eax
f010e672:	8b 10                	mov    (%eax),%edx
f010e674:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e677:	01 c2                	add    %eax,%edx
f010e679:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e67c:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e67e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e683:	c9                   	leave  
f010e684:	c3                   	ret    

f010e685 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e685:	55                   	push   %ebp
f010e686:	89 e5                	mov    %esp,%ebp
f010e688:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e68b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e68f:	74 1c                	je     f010e6ad <setPageReplacmentAlgorithmLRU+0x28>
f010e691:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e695:	74 16                	je     f010e6ad <setPageReplacmentAlgorithmLRU+0x28>
f010e697:	68 08 95 12 f0       	push   $0xf0129508
f010e69c:	68 52 95 12 f0       	push   $0xf0129552
f010e6a1:	6a 19                	push   $0x19
f010e6a3:	68 67 95 12 f0       	push   $0xf0129567
f010e6a8:	e8 6d 1c ff ff       	call   f010031a <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e6ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6b0:	a3 08 3b 5a f0       	mov    %eax,0xf05a3b08
}
f010e6b5:	90                   	nop
f010e6b6:	c9                   	leave  
f010e6b7:	c3                   	ret    

f010e6b8 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e6b8:	55                   	push   %ebp
f010e6b9:	89 e5                	mov    %esp,%ebp
f010e6bb:	c7 05 08 3b 5a f0 03 	movl   $0x3,0xf05a3b08
f010e6c2:	00 00 00 
f010e6c5:	90                   	nop
f010e6c6:	5d                   	pop    %ebp
f010e6c7:	c3                   	ret    

f010e6c8 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e6c8:	55                   	push   %ebp
f010e6c9:	89 e5                	mov    %esp,%ebp
f010e6cb:	c7 05 08 3b 5a f0 04 	movl   $0x4,0xf05a3b08
f010e6d2:	00 00 00 
f010e6d5:	90                   	nop
f010e6d6:	5d                   	pop    %ebp
f010e6d7:	c3                   	ret    

f010e6d8 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e6d8:	55                   	push   %ebp
f010e6d9:	89 e5                	mov    %esp,%ebp
f010e6db:	c7 05 08 3b 5a f0 05 	movl   $0x5,0xf05a3b08
f010e6e2:	00 00 00 
f010e6e5:	90                   	nop
f010e6e6:	5d                   	pop    %ebp
f010e6e7:	c3                   	ret    

f010e6e8 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e6e8:	55                   	push   %ebp
f010e6e9:	89 e5                	mov    %esp,%ebp
f010e6eb:	c7 05 08 3b 5a f0 07 	movl   $0x7,0xf05a3b08
f010e6f2:	00 00 00 
f010e6f5:	90                   	nop
f010e6f6:	5d                   	pop    %ebp
f010e6f7:	c3                   	ret    

f010e6f8 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e6f8:	55                   	push   %ebp
f010e6f9:	89 e5                	mov    %esp,%ebp
f010e6fb:	c7 05 08 3b 5a f0 06 	movl   $0x6,0xf05a3b08
f010e702:	00 00 00 
f010e705:	8b 45 08             	mov    0x8(%ebp),%eax
f010e708:	a3 a0 0e 5a f0       	mov    %eax,0xf05a0ea0
f010e70d:	90                   	nop
f010e70e:	5d                   	pop    %ebp
f010e70f:	c3                   	ret    

f010e710 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e710:	55                   	push   %ebp
f010e711:	89 e5                	mov    %esp,%ebp
f010e713:	8b 15 08 3b 5a f0    	mov    0xf05a3b08,%edx
f010e719:	8b 45 08             	mov    0x8(%ebp),%eax
f010e71c:	39 c2                	cmp    %eax,%edx
f010e71e:	0f 94 c0             	sete   %al
f010e721:	0f b6 c0             	movzbl %al,%eax
f010e724:	5d                   	pop    %ebp
f010e725:	c3                   	ret    

f010e726 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e726:	55                   	push   %ebp
f010e727:	89 e5                	mov    %esp,%ebp
f010e729:	a1 08 3b 5a f0       	mov    0xf05a3b08,%eax
f010e72e:	83 f8 03             	cmp    $0x3,%eax
f010e731:	75 07                	jne    f010e73a <isPageReplacmentAlgorithmCLOCK+0x14>
f010e733:	b8 01 00 00 00       	mov    $0x1,%eax
f010e738:	eb 05                	jmp    f010e73f <isPageReplacmentAlgorithmCLOCK+0x19>
f010e73a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e73f:	5d                   	pop    %ebp
f010e740:	c3                   	ret    

f010e741 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e741:	55                   	push   %ebp
f010e742:	89 e5                	mov    %esp,%ebp
f010e744:	a1 08 3b 5a f0       	mov    0xf05a3b08,%eax
f010e749:	83 f8 04             	cmp    $0x4,%eax
f010e74c:	75 07                	jne    f010e755 <isPageReplacmentAlgorithmFIFO+0x14>
f010e74e:	b8 01 00 00 00       	mov    $0x1,%eax
f010e753:	eb 05                	jmp    f010e75a <isPageReplacmentAlgorithmFIFO+0x19>
f010e755:	b8 00 00 00 00       	mov    $0x0,%eax
f010e75a:	5d                   	pop    %ebp
f010e75b:	c3                   	ret    

f010e75c <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e75c:	55                   	push   %ebp
f010e75d:	89 e5                	mov    %esp,%ebp
f010e75f:	a1 08 3b 5a f0       	mov    0xf05a3b08,%eax
f010e764:	83 f8 05             	cmp    $0x5,%eax
f010e767:	75 07                	jne    f010e770 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e769:	b8 01 00 00 00       	mov    $0x1,%eax
f010e76e:	eb 05                	jmp    f010e775 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e770:	b8 00 00 00 00       	mov    $0x0,%eax
f010e775:	5d                   	pop    %ebp
f010e776:	c3                   	ret    

f010e777 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e777:	55                   	push   %ebp
f010e778:	89 e5                	mov    %esp,%ebp
f010e77a:	a1 08 3b 5a f0       	mov    0xf05a3b08,%eax
f010e77f:	83 f8 07             	cmp    $0x7,%eax
f010e782:	75 07                	jne    f010e78b <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e784:	b8 01 00 00 00       	mov    $0x1,%eax
f010e789:	eb 05                	jmp    f010e790 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e78b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e790:	5d                   	pop    %ebp
f010e791:	c3                   	ret    

f010e792 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e792:	55                   	push   %ebp
f010e793:	89 e5                	mov    %esp,%ebp
f010e795:	a1 08 3b 5a f0       	mov    0xf05a3b08,%eax
f010e79a:	83 f8 06             	cmp    $0x6,%eax
f010e79d:	75 07                	jne    f010e7a6 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e79f:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7a4:	eb 05                	jmp    f010e7ab <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e7a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7ab:	5d                   	pop    %ebp
f010e7ac:	c3                   	ret    

f010e7ad <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e7ad:	55                   	push   %ebp
f010e7ae:	89 e5                	mov    %esp,%ebp
f010e7b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7b3:	a3 b8 38 5a f0       	mov    %eax,0xf05a38b8
f010e7b8:	90                   	nop
f010e7b9:	5d                   	pop    %ebp
f010e7ba:	c3                   	ret    

f010e7bb <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e7bb:	55                   	push   %ebp
f010e7bc:	89 e5                	mov    %esp,%ebp
f010e7be:	a1 b8 38 5a f0       	mov    0xf05a38b8,%eax
f010e7c3:	5d                   	pop    %ebp
f010e7c4:	c3                   	ret    

f010e7c5 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e7c5:	55                   	push   %ebp
f010e7c6:	89 e5                	mov    %esp,%ebp
f010e7c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7cb:	a3 74 3b 5a f0       	mov    %eax,0xf05a3b74
f010e7d0:	90                   	nop
f010e7d1:	5d                   	pop    %ebp
f010e7d2:	c3                   	ret    

f010e7d3 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e7d3:	55                   	push   %ebp
f010e7d4:	89 e5                	mov    %esp,%ebp
f010e7d6:	a1 74 3b 5a f0       	mov    0xf05a3b74,%eax
f010e7db:	5d                   	pop    %ebp
f010e7dc:	c3                   	ret    

f010e7dd <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e7dd:	55                   	push   %ebp
f010e7de:	89 e5                	mov    %esp,%ebp
f010e7e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7e3:	a3 10 3c 5a f0       	mov    %eax,0xf05a3c10
f010e7e8:	90                   	nop
f010e7e9:	5d                   	pop    %ebp
f010e7ea:	c3                   	ret    

f010e7eb <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e7eb:	55                   	push   %ebp
f010e7ec:	89 e5                	mov    %esp,%ebp
f010e7ee:	a1 10 3c 5a f0       	mov    0xf05a3c10,%eax
f010e7f3:	5d                   	pop    %ebp
f010e7f4:	c3                   	ret    

f010e7f5 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e7f5:	55                   	push   %ebp
f010e7f6:	89 e5                	mov    %esp,%ebp
f010e7f8:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e7fb:	0f 20 d0             	mov    %cr2,%eax
f010e7fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e801:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e804:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e807:	e8 64 bf ff ff       	call   f010a770 <get_cpu_proc>
f010e80c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e80f:	a1 2c 0c 5a f0       	mov    0xf05a0c2c,%eax
f010e814:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e817:	75 50                	jne    f010e869 <fault_handler+0x74>
f010e819:	a1 38 0c 5a f0       	mov    0xf05a0c38,%eax
f010e81e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e821:	75 46                	jne    f010e869 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e823:	a0 34 0c 5a f0       	mov    0xf05a0c34,%al
f010e828:	40                   	inc    %eax
f010e829:	a2 34 0c 5a f0       	mov    %al,0xf05a0c34
		if (num_repeated_fault == 3)
f010e82e:	a0 34 0c 5a f0       	mov    0xf05a0c34,%al
f010e833:	3c 03                	cmp    $0x3,%al
f010e835:	75 4d                	jne    f010e884 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e837:	83 ec 0c             	sub    $0xc,%esp
f010e83a:	ff 75 08             	pushl  0x8(%ebp)
f010e83d:	e8 73 e9 ff ff       	call   f010d1b5 <print_trapframe>
f010e842:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e845:	8b 15 28 0c 5a f0    	mov    0xf05a0c28,%edx
f010e84b:	a1 30 0c 5a f0       	mov    0xf05a0c30,%eax
f010e850:	83 ec 08             	sub    $0x8,%esp
f010e853:	ff 75 ec             	pushl  -0x14(%ebp)
f010e856:	52                   	push   %edx
f010e857:	50                   	push   %eax
f010e858:	68 84 95 12 f0       	push   $0xf0129584
f010e85d:	6a 57                	push   $0x57
f010e85f:	68 67 95 12 f0       	push   $0xf0129567
f010e864:	e8 b1 1a ff ff       	call   f010031a <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e869:	a1 2c 0c 5a f0       	mov    0xf05a0c2c,%eax
f010e86e:	a3 30 0c 5a f0       	mov    %eax,0xf05a0c30
		before_last_eip = last_eip;
f010e873:	a1 24 0c 5a f0       	mov    0xf05a0c24,%eax
f010e878:	a3 28 0c 5a f0       	mov    %eax,0xf05a0c28
		num_repeated_fault = 0;
f010e87d:	c6 05 34 0c 5a f0 00 	movb   $0x0,0xf05a0c34
	}
	last_eip = (uint32)tf->tf_eip;
f010e884:	8b 45 08             	mov    0x8(%ebp),%eax
f010e887:	8b 40 30             	mov    0x30(%eax),%eax
f010e88a:	a3 24 0c 5a f0       	mov    %eax,0xf05a0c24
	last_fault_va = fault_va ;
f010e88f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e892:	a3 2c 0c 5a f0       	mov    %eax,0xf05a0c2c
	last_faulted_env = cur_env;
f010e897:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e89a:	a3 38 0c 5a f0       	mov    %eax,0xf05a0c38
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e89f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e8a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8a9:	8b 40 34             	mov    0x34(%eax),%eax
f010e8ac:	0f b7 c0             	movzwl %ax,%eax
f010e8af:	83 e0 03             	and    $0x3,%eax
f010e8b2:	83 f8 03             	cmp    $0x3,%eax
f010e8b5:	75 07                	jne    f010e8be <fault_handler+0xc9>
		userTrap = 1;
f010e8b7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e8be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e8c2:	0f 85 a9 00 00 00    	jne    f010e971 <fault_handler+0x17c>
	{
		struct cpu* c = mycpu();
f010e8c8:	e8 30 88 ff ff       	call   f01070fd <mycpu>
f010e8cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e8d0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e8d4:	74 2f                	je     f010e905 <fault_handler+0x110>
f010e8d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8d9:	8b 40 70             	mov    0x70(%eax),%eax
f010e8dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8df:	77 24                	ja     f010e905 <fault_handler+0x110>
f010e8e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8e4:	8b 40 70             	mov    0x70(%eax),%eax
f010e8e7:	05 00 10 00 00       	add    $0x1000,%eax
f010e8ec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8ef:	76 14                	jbe    f010e905 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e8f1:	83 ec 04             	sub    $0x4,%esp
f010e8f4:	68 f4 95 12 f0       	push   $0xf01295f4
f010e8f9:	6a 6e                	push   $0x6e
f010e8fb:	68 67 95 12 f0       	push   $0xf0129567
f010e900:	e8 15 1a ff ff       	call   f010031a <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e905:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e908:	8b 40 08             	mov    0x8(%eax),%eax
f010e90b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e90e:	0f 87 83 00 00 00    	ja     f010e997 <fault_handler+0x1a2>
f010e914:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e917:	8b 40 08             	mov    0x8(%eax),%eax
f010e91a:	05 00 10 00 00       	add    $0x1000,%eax
f010e91f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e922:	76 73                	jbe    f010e997 <fault_handler+0x1a2>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e924:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e927:	ba a0 35 5a f0       	mov    $0xf05a35a0,%edx
f010e92c:	29 d0                	sub    %edx,%eax
f010e92e:	c1 f8 03             	sar    $0x3,%eax
f010e931:	89 c2                	mov    %eax,%edx
f010e933:	89 d0                	mov    %edx,%eax
f010e935:	c1 e0 02             	shl    $0x2,%eax
f010e938:	01 d0                	add    %edx,%eax
f010e93a:	01 c0                	add    %eax,%eax
f010e93c:	01 d0                	add    %edx,%eax
f010e93e:	c1 e0 03             	shl    $0x3,%eax
f010e941:	01 d0                	add    %edx,%eax
f010e943:	89 c1                	mov    %eax,%ecx
f010e945:	c1 e1 0b             	shl    $0xb,%ecx
f010e948:	01 c8                	add    %ecx,%eax
f010e94a:	c1 e0 05             	shl    $0x5,%eax
f010e94d:	01 d0                	add    %edx,%eax
f010e94f:	c1 e0 02             	shl    $0x2,%eax
f010e952:	01 d0                	add    %edx,%eax
f010e954:	01 c0                	add    %eax,%eax
f010e956:	01 d0                	add    %edx,%eax
f010e958:	c1 e0 03             	shl    $0x3,%eax
f010e95b:	01 d0                	add    %edx,%eax
f010e95d:	f7 d8                	neg    %eax
f010e95f:	50                   	push   %eax
f010e960:	68 1c 96 12 f0       	push   $0xf012961c
f010e965:	6a 70                	push   $0x70
f010e967:	68 67 95 12 f0       	push   $0xf0129567
f010e96c:	e8 a9 19 ff ff       	call   f010031a <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e971:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e978:	76 1d                	jbe    f010e997 <fault_handler+0x1a2>
f010e97a:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e981:	77 14                	ja     f010e997 <fault_handler+0x1a2>
			panic("User: stack underflow exception!");
f010e983:	83 ec 04             	sub    $0x4,%esp
f010e986:	68 50 96 12 f0       	push   $0xf0129650
f010e98b:	6a 7b                	push   $0x7b
f010e98d:	68 67 95 12 f0       	push   $0xf0129567
f010e992:	e8 83 19 ff ff       	call   f010031a <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e997:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e99a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010e99d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e9a1:	75 25                	jne    f010e9c8 <fault_handler+0x1d3>
	{
		print_trapframe(tf);
f010e9a3:	83 ec 0c             	sub    $0xc,%esp
f010e9a6:	ff 75 08             	pushl  0x8(%ebp)
f010e9a9:	e8 07 e8 ff ff       	call   f010d1b5 <print_trapframe>
f010e9ae:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010e9b1:	83 ec 04             	sub    $0x4,%esp
f010e9b4:	68 71 96 12 f0       	push   $0xf0129671
f010e9b9:	68 84 00 00 00       	push   $0x84
f010e9be:	68 67 95 12 f0       	push   $0xf0129567
f010e9c3:	e8 52 19 ff ff       	call   f010031a <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010e9c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9cb:	8b 40 64             	mov    0x64(%eax),%eax
f010e9ce:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e9d1:	c1 ea 16             	shr    $0x16,%edx
f010e9d4:	c1 e2 02             	shl    $0x2,%edx
f010e9d7:	01 d0                	add    %edx,%eax
f010e9d9:	8b 00                	mov    (%eax),%eax
f010e9db:	83 e0 01             	and    $0x1,%eax
f010e9de:	85 c0                	test   %eax,%eax
f010e9e0:	75 28                	jne    f010ea0a <fault_handler+0x215>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010e9e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9e5:	8b 80 44 da 01 00    	mov    0x1da44(%eax),%eax
f010e9eb:	8d 50 01             	lea    0x1(%eax),%edx
f010e9ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9f1:	89 90 44 da 01 00    	mov    %edx,0x1da44(%eax)

		table_fault_handler(faulted_env, fault_va);
f010e9f7:	83 ec 08             	sub    $0x8,%esp
f010e9fa:	ff 75 ec             	pushl  -0x14(%ebp)
f010e9fd:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea00:	e8 8f 00 00 00       	call   f010ea94 <table_fault_handler>
f010ea05:	83 c4 10             	add    $0x10,%esp
f010ea08:	eb 7b                	jmp    f010ea85 <fault_handler+0x290>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010ea0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea0d:	8b 40 64             	mov    0x64(%eax),%eax
f010ea10:	83 ec 08             	sub    $0x8,%esp
f010ea13:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea16:	50                   	push   %eax
f010ea17:	e8 d0 a1 ff ff       	call   f0108bec <pt_get_page_permissions>
f010ea1c:	83 c4 10             	add    $0x10,%esp
f010ea1f:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010ea22:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ea25:	83 e0 01             	and    $0x1,%eax
f010ea28:	85 c0                	test   %eax,%eax
f010ea2a:	74 17                	je     f010ea43 <fault_handler+0x24e>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010ea2c:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea2f:	68 88 96 12 f0       	push   $0xf0129688
f010ea34:	68 a1 00 00 00       	push   $0xa1
f010ea39:	68 67 95 12 f0       	push   $0xf0129567
f010ea3e:	e8 d7 18 ff ff       	call   f010031a <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010ea43:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea46:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f010ea4c:	8d 50 01             	lea    0x1(%eax),%edx
f010ea4f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea52:	89 90 40 da 01 00    	mov    %edx,0x1da40(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010ea58:	e8 76 fd ff ff       	call   f010e7d3 <isBufferingEnabled>
f010ea5d:	84 c0                	test   %al,%al
f010ea5f:	74 13                	je     f010ea74 <fault_handler+0x27f>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010ea61:	83 ec 08             	sub    $0x8,%esp
f010ea64:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea67:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea6a:	e8 64 00 00 00       	call   f010ead3 <__page_fault_handler_with_buffering>
f010ea6f:	83 c4 10             	add    $0x10,%esp
f010ea72:	eb 11                	jmp    f010ea85 <fault_handler+0x290>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010ea74:	83 ec 08             	sub    $0x8,%esp
f010ea77:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea7a:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea7d:	e8 34 00 00 00       	call   f010eab6 <page_fault_handler>
f010ea82:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010ea85:	0f 20 d8             	mov    %cr3,%eax
f010ea88:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010ea8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ea8e:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010ea91:	90                   	nop
f010ea92:	c9                   	leave  
f010ea93:	c3                   	ret    

f010ea94 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010ea94:	55                   	push   %ebp
f010ea95:	89 e5                	mov    %esp,%ebp
f010ea97:	83 ec 18             	sub    $0x18,%esp
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
	}
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
f010ea9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea9d:	8b 40 64             	mov    0x64(%eax),%eax
f010eaa0:	83 ec 04             	sub    $0x4,%esp
f010eaa3:	8d 55 f4             	lea    -0xc(%ebp),%edx
f010eaa6:	52                   	push   %edx
f010eaa7:	ff 75 0c             	pushl  0xc(%ebp)
f010eaaa:	50                   	push   %eax
f010eaab:	e8 83 9a ff ff       	call   f0108533 <__static_cpt>
f010eab0:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f010eab3:	90                   	nop
f010eab4:	c9                   	leave  
f010eab5:	c3                   	ret    

f010eab6 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010eab6:	55                   	push   %ebp
f010eab7:	89 e5                	mov    %esp,%ebp
f010eab9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24] [3] PAGE FAULT HANDLER
	// Write your code here, remove the panic and write your code
	panic("page_fault_handler() is not implemented yet...!!");
f010eabc:	83 ec 04             	sub    $0x4,%esp
f010eabf:	68 cc 96 12 f0       	push   $0xf01296cc
f010eac4:	68 db 00 00 00       	push   $0xdb
f010eac9:	68 67 95 12 f0       	push   $0xf0129567
f010eace:	e8 47 18 ff ff       	call   f010031a <_panic>

f010ead3 <__page_fault_handler_with_buffering>:
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010ead3:	55                   	push   %ebp
f010ead4:	89 e5                	mov    %esp,%ebp
f010ead6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010ead9:	83 ec 04             	sub    $0x4,%esp
f010eadc:	68 00 97 12 f0       	push   $0xf0129700
f010eae1:	68 fc 00 00 00       	push   $0xfc
f010eae6:	68 67 95 12 f0       	push   $0xf0129567
f010eaeb:	e8 2a 18 ff ff       	call   f010031a <_panic>

f010eaf0 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010eaf0:	55                   	push   %ebp
f010eaf1:	89 e5                	mov    %esp,%ebp
f010eaf3:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010eaf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf9:	83 c0 04             	add    $0x4,%eax
f010eafc:	83 ec 08             	sub    $0x8,%esp
f010eaff:	ff 75 0c             	pushl  0xc(%ebp)
f010eb02:	50                   	push   %eax
f010eb03:	e8 1c 3b 01 00       	call   f0122624 <strcpy>
f010eb08:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010eb0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb0e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010eb14:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb17:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010eb1e:	90                   	nop
f010eb1f:	c9                   	leave  
f010eb20:	c3                   	ret    

f010eb21 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010eb21:	55                   	push   %ebp
f010eb22:	89 e5                	mov    %esp,%ebp
f010eb24:	53                   	push   %ebx
f010eb25:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010eb28:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb2b:	83 ec 0c             	sub    $0xc,%esp
f010eb2e:	50                   	push   %eax
f010eb2f:	e8 06 02 00 00       	call   f010ed3a <holding_spinlock>
f010eb34:	83 c4 10             	add    $0x10,%esp
f010eb37:	85 c0                	test   %eax,%eax
f010eb39:	74 18                	je     f010eb53 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010eb3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb3e:	83 c0 04             	add    $0x4,%eax
f010eb41:	50                   	push   %eax
f010eb42:	68 44 97 12 f0       	push   $0xf0129744
f010eb47:	6a 1f                	push   $0x1f
f010eb49:	68 81 97 12 f0       	push   $0xf0129781
f010eb4e:	e8 c7 17 ff ff       	call   f010031a <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010eb53:	e8 68 86 ff ff       	call   f01071c0 <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010eb58:	90                   	nop
f010eb59:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eb5f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010eb66:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010eb69:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb6c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010eb6f:	f0 87 02             	lock xchg %eax,(%edx)
f010eb72:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010eb75:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eb78:	85 c0                	test   %eax,%eax
f010eb7a:	75 dd                	jne    f010eb59 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010eb7c:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010eb81:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010eb84:	e8 74 85 ff ff       	call   f01070fd <mycpu>
f010eb89:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010eb8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb8f:	83 c0 48             	add    $0x48,%eax
f010eb92:	83 ec 08             	sub    $0x8,%esp
f010eb95:	50                   	push   %eax
f010eb96:	8d 45 08             	lea    0x8(%ebp),%eax
f010eb99:	50                   	push   %eax
f010eb9a:	e8 74 00 00 00       	call   f010ec13 <getcallerpcs>
f010eb9f:	83 c4 10             	add    $0x10,%esp

}
f010eba2:	90                   	nop
f010eba3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010eba6:	c9                   	leave  
f010eba7:	c3                   	ret    

f010eba8 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010eba8:	55                   	push   %ebp
f010eba9:	89 e5                	mov    %esp,%ebp
f010ebab:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010ebae:	83 ec 0c             	sub    $0xc,%esp
f010ebb1:	ff 75 08             	pushl  0x8(%ebp)
f010ebb4:	e8 81 01 00 00       	call   f010ed3a <holding_spinlock>
f010ebb9:	83 c4 10             	add    $0x10,%esp
f010ebbc:	85 c0                	test   %eax,%eax
f010ebbe:	75 26                	jne    f010ebe6 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010ebc0:	83 ec 0c             	sub    $0xc,%esp
f010ebc3:	ff 75 08             	pushl  0x8(%ebp)
f010ebc6:	e8 08 01 00 00       	call   f010ecd3 <printcallstack>
f010ebcb:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010ebce:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebd1:	83 c0 04             	add    $0x4,%eax
f010ebd4:	50                   	push   %eax
f010ebd5:	68 98 97 12 f0       	push   $0xf0129798
f010ebda:	6a 3c                	push   $0x3c
f010ebdc:	68 81 97 12 f0       	push   $0xf0129781
f010ebe1:	e8 34 17 ff ff       	call   f010031a <_panic>
	}
	lk->pcs[0] = 0;
f010ebe6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebe9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010ebf0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebf3:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010ebfa:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010ebff:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec02:	8b 55 08             	mov    0x8(%ebp),%edx
f010ec05:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010ec0b:	e8 02 86 ff ff       	call   f0107212 <popcli>
}
f010ec10:	90                   	nop
f010ec11:	c9                   	leave  
f010ec12:	c3                   	ret    

f010ec13 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010ec13:	55                   	push   %ebp
f010ec14:	89 e5                	mov    %esp,%ebp
f010ec16:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010ec19:	e8 52 bb ff ff       	call   f010a770 <get_cpu_proc>
f010ec1e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010ec21:	e8 d7 84 ff ff       	call   f01070fd <mycpu>
f010ec26:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010ec29:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec2c:	83 e8 08             	sub    $0x8,%eax
f010ec2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010ec32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010ec39:	eb 67                	jmp    f010eca2 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ec3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec3f:	74 67                	je     f010eca8 <getcallerpcs+0x95>
f010ec41:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010ec48:	76 5e                	jbe    f010eca8 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ec4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ec4d:	8b 40 08             	mov    0x8(%eax),%eax
f010ec50:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ec55:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec58:	77 10                	ja     f010ec6a <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ec5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ec5d:	8b 40 08             	mov    0x8(%eax),%eax
f010ec60:	05 00 90 00 00       	add    $0x9000,%eax
f010ec65:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec68:	77 3e                	ja     f010eca8 <getcallerpcs+0x95>
f010ec6a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ec6e:	74 10                	je     f010ec80 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010ec70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ec73:	8b 40 70             	mov    0x70(%eax),%eax
f010ec76:	05 00 80 00 00       	add    $0x8000,%eax
f010ec7b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec7e:	76 28                	jbe    f010eca8 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010ec80:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ec8a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec8d:	01 c2                	add    %eax,%edx
f010ec8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec92:	8b 40 04             	mov    0x4(%eax),%eax
f010ec95:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010ec97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec9a:	8b 00                	mov    (%eax),%eax
f010ec9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010ec9f:	ff 45 f0             	incl   -0x10(%ebp)
f010eca2:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010eca6:	7e 93                	jle    f010ec3b <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010eca8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ecab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010ecae:	eb 18                	jmp    f010ecc8 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010ecb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ecb3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ecba:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecbd:	01 d0                	add    %edx,%eax
f010ecbf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ecc5:	ff 45 f0             	incl   -0x10(%ebp)
f010ecc8:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010eccc:	7e e2                	jle    f010ecb0 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010ecce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010ecd1:	c9                   	leave  
f010ecd2:	c3                   	ret    

f010ecd3 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010ecd3:	55                   	push   %ebp
f010ecd4:	89 e5                	mov    %esp,%ebp
f010ecd6:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ecd9:	83 ec 0c             	sub    $0xc,%esp
f010ecdc:	68 d6 97 12 f0       	push   $0xf01297d6
f010ece1:	e8 86 22 ff ff       	call   f0100f6c <cprintf>
f010ece6:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ece9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecec:	83 c0 48             	add    $0x48,%eax
f010ecef:	83 ec 08             	sub    $0x8,%esp
f010ecf2:	50                   	push   %eax
f010ecf3:	8d 45 08             	lea    0x8(%ebp),%eax
f010ecf6:	50                   	push   %eax
f010ecf7:	e8 17 ff ff ff       	call   f010ec13 <getcallerpcs>
f010ecfc:	83 c4 10             	add    $0x10,%esp
f010ecff:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ed02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ed09:	eb 24                	jmp    f010ed2f <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ed0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ed11:	83 c2 10             	add    $0x10,%edx
f010ed14:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ed18:	83 ec 04             	sub    $0x4,%esp
f010ed1b:	50                   	push   %eax
f010ed1c:	ff 75 f4             	pushl  -0xc(%ebp)
f010ed1f:	68 e6 97 12 f0       	push   $0xf01297e6
f010ed24:	e8 43 22 ff ff       	call   f0100f6c <cprintf>
f010ed29:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ed2c:	ff 45 f4             	incl   -0xc(%ebp)
f010ed2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed32:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ed35:	7c d4                	jl     f010ed0b <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010ed37:	90                   	nop
f010ed38:	c9                   	leave  
f010ed39:	c3                   	ret    

f010ed3a <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010ed3a:	55                   	push   %ebp
f010ed3b:	89 e5                	mov    %esp,%ebp
f010ed3d:	53                   	push   %ebx
f010ed3e:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010ed41:	e8 7a 84 ff ff       	call   f01071c0 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ed46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed49:	8b 00                	mov    (%eax),%eax
f010ed4b:	85 c0                	test   %eax,%eax
f010ed4d:	74 16                	je     f010ed65 <holding_spinlock+0x2b>
f010ed4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed52:	8b 58 44             	mov    0x44(%eax),%ebx
f010ed55:	e8 a3 83 ff ff       	call   f01070fd <mycpu>
f010ed5a:	39 c3                	cmp    %eax,%ebx
f010ed5c:	75 07                	jne    f010ed65 <holding_spinlock+0x2b>
f010ed5e:	b8 01 00 00 00       	mov    $0x1,%eax
f010ed63:	eb 05                	jmp    f010ed6a <holding_spinlock+0x30>
f010ed65:	b8 00 00 00 00       	mov    $0x0,%eax
f010ed6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010ed6d:	e8 a0 84 ff ff       	call   f0107212 <popcli>
	return r;
f010ed72:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ed75:	83 c4 14             	add    $0x14,%esp
f010ed78:	5b                   	pop    %ebx
f010ed79:	5d                   	pop    %ebp
f010ed7a:	c3                   	ret    

f010ed7b <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010ed7b:	55                   	push   %ebp
f010ed7c:	89 e5                	mov    %esp,%ebp
f010ed7e:	83 ec 08             	sub    $0x8,%esp
//	cprintf("17\n");
	init_channel(&(lk->chan), "sleep lock channel");
f010ed81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed84:	83 c0 74             	add    $0x74,%eax
f010ed87:	83 ec 08             	sub    $0x8,%esp
f010ed8a:	68 f5 97 12 f0       	push   $0xf01297f5
f010ed8f:	50                   	push   %eax
f010ed90:	e8 4c 01 00 00       	call   f010eee1 <init_channel>
f010ed95:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ed98:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed9b:	83 c0 04             	add    $0x4,%eax
f010ed9e:	83 ec 08             	sub    $0x8,%esp
f010eda1:	68 08 98 12 f0       	push   $0xf0129808
f010eda6:	50                   	push   %eax
f010eda7:	e8 44 fd ff ff       	call   f010eaf0 <init_spinlock>
f010edac:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010edaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010edb2:	05 c4 00 00 00       	add    $0xc4,%eax
f010edb7:	83 ec 08             	sub    $0x8,%esp
f010edba:	ff 75 0c             	pushl  0xc(%ebp)
f010edbd:	50                   	push   %eax
f010edbe:	e8 61 38 01 00       	call   f0122624 <strcpy>
f010edc3:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010edc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010edc9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010edcf:	8b 45 08             	mov    0x8(%ebp),%eax
f010edd2:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010edd9:	00 00 00 
}
f010eddc:	90                   	nop
f010eddd:	c9                   	leave  
f010edde:	c3                   	ret    

f010eddf <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010eddf:	55                   	push   %ebp
f010ede0:	89 e5                	mov    %esp,%ebp
f010ede2:	53                   	push   %ebx
f010ede3:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ede6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ede9:	83 c0 04             	add    $0x4,%eax
f010edec:	83 ec 0c             	sub    $0xc,%esp
f010edef:	50                   	push   %eax
f010edf0:	e8 2c fd ff ff       	call   f010eb21 <acquire_spinlock>
f010edf5:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010edf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010edfb:	8b 00                	mov    (%eax),%eax
f010edfd:	85 c0                	test   %eax,%eax
f010edff:	74 1c                	je     f010ee1d <holding_sleeplock+0x3e>
f010ee01:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee04:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ee0a:	e8 61 b9 ff ff       	call   f010a770 <get_cpu_proc>
f010ee0f:	8b 40 10             	mov    0x10(%eax),%eax
f010ee12:	39 c3                	cmp    %eax,%ebx
f010ee14:	75 07                	jne    f010ee1d <holding_sleeplock+0x3e>
f010ee16:	b8 01 00 00 00       	mov    $0x1,%eax
f010ee1b:	eb 05                	jmp    f010ee22 <holding_sleeplock+0x43>
f010ee1d:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010ee25:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee28:	83 c0 04             	add    $0x4,%eax
f010ee2b:	83 ec 0c             	sub    $0xc,%esp
f010ee2e:	50                   	push   %eax
f010ee2f:	e8 74 fd ff ff       	call   f010eba8 <release_spinlock>
f010ee34:	83 c4 10             	add    $0x10,%esp
	return r;
f010ee37:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ee3a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ee3d:	c9                   	leave  
f010ee3e:	c3                   	ret    

f010ee3f <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010ee3f:	55                   	push   %ebp
f010ee40:	89 e5                	mov    %esp,%ebp
f010ee42:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");
//	cprintf("38\n");
//	cprintf("Proccess ID: %d\n", lk->pid);
	 acquire_spinlock(&(lk->lk));
f010ee45:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee48:	83 c0 04             	add    $0x4,%eax
f010ee4b:	83 ec 0c             	sub    $0xc,%esp
f010ee4e:	50                   	push   %eax
f010ee4f:	e8 cd fc ff ff       	call   f010eb21 <acquire_spinlock>
f010ee54:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010ee57:	eb 19                	jmp    f010ee72 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010ee59:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee5c:	8d 50 04             	lea    0x4(%eax),%edx
f010ee5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee62:	83 c0 74             	add    $0x74,%eax
f010ee65:	83 ec 08             	sub    $0x8,%esp
f010ee68:	52                   	push   %edx
f010ee69:	50                   	push   %eax
f010ee6a:	e8 9f 00 00 00       	call   f010ef0e <sleep>
f010ee6f:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");
//	cprintf("38\n");
//	cprintf("Proccess ID: %d\n", lk->pid);
	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010ee72:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee75:	8b 00                	mov    (%eax),%eax
f010ee77:	85 c0                	test   %eax,%eax
f010ee79:	75 de                	jne    f010ee59 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010ee7b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee7e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	    //lk->pid = get_cpu_proc()->env_id;
	  release_spinlock(&(lk->lk));
f010ee84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee87:	83 c0 04             	add    $0x4,%eax
f010ee8a:	83 ec 0c             	sub    $0xc,%esp
f010ee8d:	50                   	push   %eax
f010ee8e:	e8 15 fd ff ff       	call   f010eba8 <release_spinlock>
f010ee93:	83 c4 10             	add    $0x10,%esp

}
f010ee96:	90                   	nop
f010ee97:	c9                   	leave  
f010ee98:	c3                   	ret    

f010ee99 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010ee99:	55                   	push   %ebp
f010ee9a:	89 e5                	mov    %esp,%ebp
f010ee9c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");
//	cprintf("57\n");
	 acquire_spinlock(&(lk->lk));
f010ee9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010eea2:	83 c0 04             	add    $0x4,%eax
f010eea5:	83 ec 0c             	sub    $0xc,%esp
f010eea8:	50                   	push   %eax
f010eea9:	e8 73 fc ff ff       	call   f010eb21 <acquire_spinlock>
f010eeae:	83 c4 10             	add    $0x10,%esp
	//cprintf("sleep_lock 59");
	 wakeup_all(&(lk->chan));
f010eeb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010eeb4:	83 c0 74             	add    $0x74,%eax
f010eeb7:	83 ec 0c             	sub    $0xc,%esp
f010eeba:	50                   	push   %eax
f010eebb:	e8 3f 01 00 00       	call   f010efff <wakeup_all>
f010eec0:	83 c4 10             	add    $0x10,%esp
	 //cprintf("sleep_lock 61");
	 lk->locked = 0;
f010eec3:	8b 45 08             	mov    0x8(%ebp),%eax
f010eec6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    //lk->pid = get_cpu_proc()->env_id;
	 release_spinlock(&(lk->lk));
f010eecc:	8b 45 08             	mov    0x8(%ebp),%eax
f010eecf:	83 c0 04             	add    $0x4,%eax
f010eed2:	83 ec 0c             	sub    $0xc,%esp
f010eed5:	50                   	push   %eax
f010eed6:	e8 cd fc ff ff       	call   f010eba8 <release_spinlock>
f010eedb:	83 c4 10             	add    $0x10,%esp
}
f010eede:	90                   	nop
f010eedf:	c9                   	leave  
f010eee0:	c3                   	ret    

f010eee1 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010eee1:	55                   	push   %ebp
f010eee2:	89 e5                	mov    %esp,%ebp
f010eee4:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010eee7:	8b 45 08             	mov    0x8(%ebp),%eax
f010eeea:	83 c0 10             	add    $0x10,%eax
f010eeed:	83 ec 08             	sub    $0x8,%esp
f010eef0:	ff 75 0c             	pushl  0xc(%ebp)
f010eef3:	50                   	push   %eax
f010eef4:	e8 2b 37 01 00       	call   f0122624 <strcpy>
f010eef9:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010eefc:	8b 45 08             	mov    0x8(%ebp),%eax
f010eeff:	83 ec 0c             	sub    $0xc,%esp
f010ef02:	50                   	push   %eax
f010ef03:	e8 2f 60 ff ff       	call   f0104f37 <init_queue>
f010ef08:	83 c4 10             	add    $0x10,%esp
}
f010ef0b:	90                   	nop
f010ef0c:	c9                   	leave  
f010ef0d:	c3                   	ret    

f010ef0e <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010ef0e:	55                   	push   %ebp
f010ef0f:	89 e5                	mov    %esp,%ebp
f010ef11:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...
//	cprintf("35\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010ef14:	83 ec 0c             	sub    $0xc,%esp
f010ef17:	68 00 0e 5a f0       	push   $0xf05a0e00
f010ef1c:	e8 00 fc ff ff       	call   f010eb21 <acquire_spinlock>
f010ef21:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f010ef24:	e8 47 b8 ff ff       	call   f010a770 <get_cpu_proc>
f010ef29:	89 c2                	mov    %eax,%edx
f010ef2b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef2e:	83 ec 08             	sub    $0x8,%esp
f010ef31:	52                   	push   %edx
f010ef32:	50                   	push   %eax
f010ef33:	e8 40 60 ff ff       	call   f0104f78 <enqueue>
f010ef38:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f010ef3b:	e8 30 b8 ff ff       	call   f010a770 <get_cpu_proc>
f010ef40:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f010ef47:	83 ec 0c             	sub    $0xc,%esp
f010ef4a:	ff 75 0c             	pushl  0xc(%ebp)
f010ef4d:	e8 56 fc ff ff       	call   f010eba8 <release_spinlock>
f010ef52:	83 c4 10             	add    $0x10,%esp
	sched();
f010ef55:	e8 a3 b9 ff ff       	call   f010a8fd <sched>
	release_spinlock(&(ProcessQueues.qlock));
f010ef5a:	83 ec 0c             	sub    $0xc,%esp
f010ef5d:	68 00 0e 5a f0       	push   $0xf05a0e00
f010ef62:	e8 41 fc ff ff       	call   f010eba8 <release_spinlock>
f010ef67:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010ef6a:	83 ec 0c             	sub    $0xc,%esp
f010ef6d:	ff 75 0c             	pushl  0xc(%ebp)
f010ef70:	e8 ac fb ff ff       	call   f010eb21 <acquire_spinlock>
f010ef75:	83 c4 10             	add    $0x10,%esp
}
f010ef78:	90                   	nop
f010ef79:	c9                   	leave  
f010ef7a:	c3                   	ret    

f010ef7b <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010ef7b:	55                   	push   %ebp
f010ef7c:	89 e5                	mov    %esp,%ebp
f010ef7e:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...
//	cprintf("57\n");
	if(queue_size(&chan->queue)){
f010ef81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef84:	83 ec 0c             	sub    $0xc,%esp
f010ef87:	50                   	push   %eax
f010ef88:	e8 d3 5f ff ff       	call   f0104f60 <queue_size>
f010ef8d:	83 c4 10             	add    $0x10,%esp
f010ef90:	85 c0                	test   %eax,%eax
f010ef92:	74 68                	je     f010effc <wakeup_one+0x81>
		bool locked_by_me = 0;
f010ef94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f010ef9b:	83 ec 0c             	sub    $0xc,%esp
f010ef9e:	68 00 0e 5a f0       	push   $0xf05a0e00
f010efa3:	e8 92 fd ff ff       	call   f010ed3a <holding_spinlock>
f010efa8:	83 c4 10             	add    $0x10,%esp
f010efab:	85 c0                	test   %eax,%eax
f010efad:	75 17                	jne    f010efc6 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f010efaf:	83 ec 0c             	sub    $0xc,%esp
f010efb2:	68 00 0e 5a f0       	push   $0xf05a0e00
f010efb7:	e8 65 fb ff ff       	call   f010eb21 <acquire_spinlock>
f010efbc:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f010efbf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f010efc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010efc9:	83 ec 0c             	sub    $0xc,%esp
f010efcc:	50                   	push   %eax
f010efcd:	e8 37 60 ff ff       	call   f0105009 <dequeue>
f010efd2:	83 c4 10             	add    $0x10,%esp
f010efd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f010efd8:	83 ec 0c             	sub    $0xc,%esp
f010efdb:	ff 75 f0             	pushl  -0x10(%ebp)
f010efde:	e8 0a 62 ff ff       	call   f01051ed <sched_insert_ready0>
f010efe3:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f010efe6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010efea:	74 10                	je     f010effc <wakeup_one+0x81>
f010efec:	83 ec 0c             	sub    $0xc,%esp
f010efef:	68 00 0e 5a f0       	push   $0xf05a0e00
f010eff4:	e8 af fb ff ff       	call   f010eba8 <release_spinlock>
f010eff9:	83 c4 10             	add    $0x10,%esp
	}
}
f010effc:	90                   	nop
f010effd:	c9                   	leave  
f010effe:	c3                   	ret    

f010efff <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010efff:	55                   	push   %ebp
f010f000:	89 e5                	mov    %esp,%ebp
f010f002:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010f005:	83 ec 0c             	sub    $0xc,%esp
f010f008:	68 00 0e 5a f0       	push   $0xf05a0e00
f010f00d:	e8 0f fb ff ff       	call   f010eb21 <acquire_spinlock>
f010f012:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f010f015:	eb 0e                	jmp    f010f025 <wakeup_all+0x26>
		wakeup_one(chan);
f010f017:	83 ec 0c             	sub    $0xc,%esp
f010f01a:	ff 75 08             	pushl  0x8(%ebp)
f010f01d:	e8 59 ff ff ff       	call   f010ef7b <wakeup_one>
f010f022:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f010f025:	8b 45 08             	mov    0x8(%ebp),%eax
f010f028:	83 ec 0c             	sub    $0xc,%esp
f010f02b:	50                   	push   %eax
f010f02c:	e8 2f 5f ff ff       	call   f0104f60 <queue_size>
f010f031:	83 c4 10             	add    $0x10,%esp
f010f034:	85 c0                	test   %eax,%eax
f010f036:	75 df                	jne    f010f017 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f010f038:	83 ec 0c             	sub    $0xc,%esp
f010f03b:	68 00 0e 5a f0       	push   $0xf05a0e00
f010f040:	e8 63 fb ff ff       	call   f010eba8 <release_spinlock>
f010f045:	83 c4 10             	add    $0x10,%esp
}
f010f048:	90                   	nop
f010f049:	c9                   	leave  
f010f04a:	c3                   	ret    

f010f04b <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010f04b:	55                   	push   %ebp
f010f04c:	89 e5                	mov    %esp,%ebp
f010f04e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010f051:	83 ec 04             	sub    $0x4,%esp
f010f054:	68 1c 98 12 f0       	push   $0xf012981c
f010f059:	6a 13                	push   $0x13
f010f05b:	68 43 98 12 f0       	push   $0xf0129843
f010f060:	e8 b5 12 ff ff       	call   f010031a <_panic>

f010f065 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010f065:	55                   	push   %ebp
f010f066:	89 e5                	mov    %esp,%ebp
f010f068:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010f06b:	83 ec 04             	sub    $0x4,%esp
f010f06e:	68 5c 98 12 f0       	push   $0xf012985c
f010f073:	6a 1b                	push   $0x1b
f010f075:	68 43 98 12 f0       	push   $0xf0129843
f010f07a:	e8 9b 12 ff ff       	call   f010031a <_panic>

f010f07f <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010f07f:	55                   	push   %ebp
f010f080:	89 e5                	mov    %esp,%ebp
f010f082:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010f085:	83 ec 04             	sub    $0x4,%esp
f010f088:	68 84 98 12 f0       	push   $0xf0129884
f010f08d:	6a 24                	push   $0x24
f010f08f:	68 43 98 12 f0       	push   $0xf0129843
f010f094:	e8 81 12 ff ff       	call   f010031a <_panic>

f010f099 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010f099:	55                   	push   %ebp
f010f09a:	89 e5                	mov    %esp,%ebp
f010f09c:	c7 05 50 39 5a f0 01 	movl   $0x1,0xf05a3950
f010f0a3:	00 00 00 
f010f0a6:	90                   	nop
f010f0a7:	5d                   	pop    %ebp
f010f0a8:	c3                   	ret    

f010f0a9 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010f0a9:	55                   	push   %ebp
f010f0aa:	89 e5                	mov    %esp,%ebp
f010f0ac:	c7 05 50 39 5a f0 02 	movl   $0x2,0xf05a3950
f010f0b3:	00 00 00 
f010f0b6:	90                   	nop
f010f0b7:	5d                   	pop    %ebp
f010f0b8:	c3                   	ret    

f010f0b9 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010f0b9:	55                   	push   %ebp
f010f0ba:	89 e5                	mov    %esp,%ebp
f010f0bc:	c7 05 50 39 5a f0 03 	movl   $0x3,0xf05a3950
f010f0c3:	00 00 00 
f010f0c6:	90                   	nop
f010f0c7:	5d                   	pop    %ebp
f010f0c8:	c3                   	ret    

f010f0c9 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010f0c9:	55                   	push   %ebp
f010f0ca:	89 e5                	mov    %esp,%ebp
f010f0cc:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f010f0d1:	83 f8 01             	cmp    $0x1,%eax
f010f0d4:	75 04                	jne    f010f0da <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010f0d6:	b0 01                	mov    $0x1,%al
f010f0d8:	eb 02                	jmp    f010f0dc <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010f0da:	b0 00                	mov    $0x0,%al
f010f0dc:	5d                   	pop    %ebp
f010f0dd:	c3                   	ret    

f010f0de <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010f0de:	55                   	push   %ebp
f010f0df:	89 e5                	mov    %esp,%ebp
f010f0e1:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f010f0e6:	83 f8 02             	cmp    $0x2,%eax
f010f0e9:	75 04                	jne    f010f0ef <isKHeapPlacementStrategyBESTFIT+0x11>
f010f0eb:	b0 01                	mov    $0x1,%al
f010f0ed:	eb 02                	jmp    f010f0f1 <isKHeapPlacementStrategyBESTFIT+0x13>
f010f0ef:	b0 00                	mov    $0x0,%al
f010f0f1:	5d                   	pop    %ebp
f010f0f2:	c3                   	ret    

f010f0f3 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010f0f3:	55                   	push   %ebp
f010f0f4:	89 e5                	mov    %esp,%ebp
f010f0f6:	a1 50 39 5a f0       	mov    0xf05a3950,%eax
f010f0fb:	83 f8 03             	cmp    $0x3,%eax
f010f0fe:	75 04                	jne    f010f104 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010f100:	b0 01                	mov    $0x1,%al
f010f102:	eb 02                	jmp    f010f106 <isKHeapPlacementStrategyNEXTFIT+0x13>
f010f104:	b0 00                	mov    $0x0,%al
f010f106:	5d                   	pop    %ebp
f010f107:	c3                   	ret    

f010f108 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010f108:	55                   	push   %ebp
f010f109:	89 e5                	mov    %esp,%ebp
f010f10b:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010f10e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010f115:	eb 26                	jmp    f010f13d <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010f117:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f11a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f121:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f124:	01 c2                	add    %eax,%edx
f010f126:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f129:	40                   	inc    %eax
f010f12a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010f131:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f134:	01 c8                	add    %ecx,%eax
f010f136:	8b 00                	mov    (%eax),%eax
f010f138:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010f13a:	ff 45 f4             	incl   -0xc(%ebp)
f010f13d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f140:	48                   	dec    %eax
f010f141:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f144:	7f d1                	jg     f010f117 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010f146:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010f149:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f150:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010f157:	eb 35                	jmp    f010f18e <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010f159:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f15c:	89 d0                	mov    %edx,%eax
f010f15e:	01 c0                	add    %eax,%eax
f010f160:	01 d0                	add    %edx,%eax
f010f162:	c1 e0 02             	shl    $0x2,%eax
f010f165:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f010f16a:	8b 10                	mov    (%eax),%edx
f010f16c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f16f:	8b 00                	mov    (%eax),%eax
f010f171:	83 ec 08             	sub    $0x8,%esp
f010f174:	52                   	push   %edx
f010f175:	50                   	push   %eax
f010f176:	e8 66 35 01 00       	call   f01226e1 <strcmp>
f010f17b:	83 c4 10             	add    $0x10,%esp
f010f17e:	85 c0                	test   %eax,%eax
f010f180:	75 09                	jne    f010f18b <tst_handler+0x83>
		{
			test_found = 1;
f010f182:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010f189:	eb 0f                	jmp    f010f19a <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f18b:	ff 45 ec             	incl   -0x14(%ebp)
f010f18e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f191:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f010f196:	39 c2                	cmp    %eax,%edx
f010f198:	72 bf                	jb     f010f159 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010f19a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f19e:	74 29                	je     f010f1c9 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010f1a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f1a3:	89 d0                	mov    %edx,%eax
f010f1a5:	01 c0                	add    %eax,%eax
f010f1a7:	01 d0                	add    %edx,%eax
f010f1a9:	c1 e0 02             	shl    $0x2,%eax
f010f1ac:	05 08 fd 17 f0       	add    $0xf017fd08,%eax
f010f1b1:	8b 00                	mov    (%eax),%eax
f010f1b3:	83 ec 08             	sub    $0x8,%esp
f010f1b6:	ff 75 0c             	pushl  0xc(%ebp)
f010f1b9:	ff 75 08             	pushl  0x8(%ebp)
f010f1bc:	ff d0                	call   *%eax
f010f1be:	83 c4 10             	add    $0x10,%esp
f010f1c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010f1c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f1c7:	eb 1b                	jmp    f010f1e4 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010f1c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1cc:	8b 00                	mov    (%eax),%eax
f010f1ce:	83 ec 08             	sub    $0x8,%esp
f010f1d1:	50                   	push   %eax
f010f1d2:	68 c4 9b 12 f0       	push   $0xf0129bc4
f010f1d7:	e8 90 1d ff ff       	call   f0100f6c <cprintf>
f010f1dc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1df:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010f1e4:	c9                   	leave  
f010f1e5:	c3                   	ret    

f010f1e6 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010f1e6:	55                   	push   %ebp
f010f1e7:	89 e5                	mov    %esp,%ebp
f010f1e9:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010f1ec:	e8 74 0b 01 00       	call   f011fd65 <test_three_creation_functions>
	return 0;
f010f1f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f1f6:	c9                   	leave  
f010f1f7:	c3                   	ret    

f010f1f8 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010f1f8:	55                   	push   %ebp
f010f1f9:	89 e5                	mov    %esp,%ebp
f010f1fb:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010f1fe:	e8 b6 9a 00 00       	call   f0118cb9 <test_priority_normal_and_higher>
	return 0;
f010f203:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f208:	c9                   	leave  
f010f209:	c3                   	ret    

f010f20a <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010f20a:	55                   	push   %ebp
f010f20b:	89 e5                	mov    %esp,%ebp
f010f20d:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010f210:	e8 0e a5 00 00       	call   f0119723 <test_priority_normal_and_lower>
	return 0;
f010f215:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f21a:	c9                   	leave  
f010f21b:	c3                   	ret    

f010f21c <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010f21c:	55                   	push   %ebp
f010f21d:	89 e5                	mov    %esp,%ebp
f010f21f:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010f222:	e8 f6 0c 01 00       	call   f011ff1d <test_kfreeall>
	return 0;
f010f227:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f22c:	c9                   	leave  
f010f22d:	c3                   	ret    

f010f22e <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010f22e:	55                   	push   %ebp
f010f22f:	89 e5                	mov    %esp,%ebp
f010f231:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010f234:	e8 01 0d 01 00       	call   f011ff3a <test_kexpand>
	return 0;
f010f239:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f23e:	c9                   	leave  
f010f23f:	c3                   	ret    

f010f240 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010f240:	55                   	push   %ebp
f010f241:	89 e5                	mov    %esp,%ebp
f010f243:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010f246:	e8 0c 0d 01 00       	call   f011ff57 <test_kshrink>
	return 0;
f010f24b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f250:	c9                   	leave  
f010f251:	c3                   	ret    

f010f252 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010f252:	55                   	push   %ebp
f010f253:	89 e5                	mov    %esp,%ebp
f010f255:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010f258:	e8 17 0d 01 00       	call   f011ff74 <test_kfreelast>
	return 0;
f010f25d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f262:	c9                   	leave  
f010f263:	c3                   	ret    

f010f264 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010f264:	55                   	push   %ebp
f010f265:	89 e5                	mov    %esp,%ebp
f010f267:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010f26a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f26d:	83 c0 04             	add    $0x4,%eax
f010f270:	8b 00                	mov    (%eax),%eax
f010f272:	83 ec 04             	sub    $0x4,%esp
f010f275:	6a 0a                	push   $0xa
f010f277:	6a 00                	push   $0x0
f010f279:	50                   	push   %eax
f010f27a:	e8 b6 36 01 00       	call   f0122935 <strtol>
f010f27f:	83 c4 10             	add    $0x10,%esp
f010f282:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010f285:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010f28c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010f293:	83 ec 0c             	sub    $0xc,%esp
f010f296:	68 00 0e 5a f0       	push   $0xf05a0e00
f010f29b:	e8 81 f8 ff ff       	call   f010eb21 <acquire_spinlock>
f010f2a0:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f2a3:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f010f2a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f2ab:	eb 3b                	jmp    f010f2e8 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010f2ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f2b0:	83 c0 20             	add    $0x20,%eax
f010f2b3:	83 ec 08             	sub    $0x8,%esp
f010f2b6:	68 d7 9b 12 f0       	push   $0xf0129bd7
f010f2bb:	50                   	push   %eax
f010f2bc:	e8 20 34 01 00       	call   f01226e1 <strcmp>
f010f2c1:	83 c4 10             	add    $0x10,%esp
f010f2c4:	85 c0                	test   %eax,%eax
f010f2c6:	75 12                	jne    f010f2da <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010f2c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f2cc:	74 07                	je     f010f2d5 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010f2ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010f2d5:	ff 45 f4             	incl   -0xc(%ebp)
f010f2d8:	eb 06                	jmp    f010f2e0 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010f2da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f2de:	74 31                	je     f010f311 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f2e0:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f010f2e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f2e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f2ec:	74 08                	je     f010f2f6 <tst_sc_MLFQ+0x92>
f010f2ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f2f1:	8b 40 08             	mov    0x8(%eax),%eax
f010f2f4:	eb 05                	jmp    f010f2fb <tst_sc_MLFQ+0x97>
f010f2f6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2fb:	a3 88 0e 5a f0       	mov    %eax,0xf05a0e88
f010f300:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f010f305:	85 c0                	test   %eax,%eax
f010f307:	75 a4                	jne    f010f2ad <tst_sc_MLFQ+0x49>
f010f309:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f30d:	75 9e                	jne    f010f2ad <tst_sc_MLFQ+0x49>
f010f30f:	eb 01                	jmp    f010f312 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010f311:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010f312:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f315:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f318:	75 12                	jne    f010f32c <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010f31a:	83 ec 0c             	sub    $0xc,%esp
f010f31d:	68 e0 9b 12 f0       	push   $0xf0129be0
f010f322:	e8 45 1c ff ff       	call   f0100f6c <cprintf>
f010f327:	83 c4 10             	add    $0x10,%esp
f010f32a:	eb 17                	jmp    f010f343 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010f32c:	83 ec 04             	sub    $0x4,%esp
f010f32f:	68 19 9c 12 f0       	push   $0xf0129c19
f010f334:	68 9b 00 00 00       	push   $0x9b
f010f339:	68 2f 9c 12 f0       	push   $0xf0129c2f
f010f33e:	e8 d7 0f ff ff       	call   f010031a <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010f343:	83 ec 0c             	sub    $0xc,%esp
f010f346:	68 00 0e 5a f0       	push   $0xf05a0e00
f010f34b:	e8 58 f8 ff ff       	call   f010eba8 <release_spinlock>
f010f350:	83 c4 10             	add    $0x10,%esp
	return 0;
f010f353:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f358:	c9                   	leave  
f010f359:	c3                   	ret    

f010f35a <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010f35a:	55                   	push   %ebp
f010f35b:	89 e5                	mov    %esp,%ebp
f010f35d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010f360:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f364:	74 17                	je     f010f37d <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010f366:	83 ec 0c             	sub    $0xc,%esp
f010f369:	68 48 9c 12 f0       	push   $0xf0129c48
f010f36e:	e8 f9 1b ff ff       	call   f0100f6c <cprintf>
f010f373:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f376:	b8 00 00 00 00       	mov    $0x0,%eax
f010f37b:	eb 45                	jmp    f010f3c2 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010f37d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f380:	83 c0 04             	add    $0x4,%eax
f010f383:	8b 00                	mov    (%eax),%eax
f010f385:	83 ec 04             	sub    $0x4,%esp
f010f388:	6a 0a                	push   $0xa
f010f38a:	6a 00                	push   $0x0
f010f38c:	50                   	push   %eax
f010f38d:	e8 a3 35 01 00       	call   f0122935 <strtol>
f010f392:	83 c4 10             	add    $0x10,%esp
f010f395:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010f398:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f39b:	83 f8 01             	cmp    $0x1,%eax
f010f39e:	74 10                	je     f010f3b0 <tst_bsd_nice+0x56>
f010f3a0:	83 f8 02             	cmp    $0x2,%eax
f010f3a3:	74 12                	je     f010f3b7 <tst_bsd_nice+0x5d>
f010f3a5:	85 c0                	test   %eax,%eax
f010f3a7:	75 14                	jne    f010f3bd <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010f3a9:	e8 b9 0e 01 00       	call   f0120267 <test_bsd_nice_0>
		break;
f010f3ae:	eb 0d                	jmp    f010f3bd <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010f3b0:	e8 3c 11 01 00       	call   f01204f1 <test_bsd_nice_1>
		break;
f010f3b5:	eb 06                	jmp    f010f3bd <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010f3b7:	e8 49 13 01 00       	call   f0120705 <test_bsd_nice_2>
		break;
f010f3bc:	90                   	nop
	}
	return 0;
f010f3bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f3c2:	c9                   	leave  
f010f3c3:	c3                   	ret    

f010f3c4 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010f3c4:	55                   	push   %ebp
f010f3c5:	89 e5                	mov    %esp,%ebp
f010f3c7:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010f3ca:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f3ce:	74 17                	je     f010f3e7 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010f3d0:	83 ec 0c             	sub    $0xc,%esp
f010f3d3:	68 88 9c 12 f0       	push   $0xf0129c88
f010f3d8:	e8 8f 1b ff ff       	call   f0100f6c <cprintf>
f010f3dd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3e0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3e5:	eb 0a                	jmp    f010f3f1 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010f3e7:	e8 a7 43 00 00       	call   f0113793 <test_str2lower_function>
	return 0;
f010f3ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f3f1:	c9                   	leave  
f010f3f2:	c3                   	ret    

f010f3f3 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010f3f3:	55                   	push   %ebp
f010f3f4:	89 e5                	mov    %esp,%ebp
f010f3f6:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010f3f9:	e8 cb 3f 00 00       	call   f01133c9 <TestAutoCompleteCommand>
f010f3fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010f401:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f406:	c9                   	leave  
f010f407:	c3                   	ret    

f010f408 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010f408:	55                   	push   %ebp
f010f409:	89 e5                	mov    %esp,%ebp
f010f40b:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f40e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f412:	74 1a                	je     f010f42e <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010f414:	83 ec 0c             	sub    $0xc,%esp
f010f417:	68 bc 9c 12 f0       	push   $0xf0129cbc
f010f41c:	e8 4b 1b ff ff       	call   f0100f6c <cprintf>
f010f421:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f424:	b8 00 00 00 00       	mov    $0x0,%eax
f010f429:	e9 2f 01 00 00       	jmp    f010f55d <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010f42e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f431:	83 c0 04             	add    $0x4,%eax
f010f434:	8b 00                	mov    (%eax),%eax
f010f436:	83 ec 08             	sub    $0x8,%esp
f010f439:	68 f9 9c 12 f0       	push   $0xf0129cf9
f010f43e:	50                   	push   %eax
f010f43f:	e8 9d 32 01 00       	call   f01226e1 <strcmp>
f010f444:	83 c4 10             	add    $0x10,%esp
f010f447:	85 c0                	test   %eax,%eax
f010f449:	75 0a                	jne    f010f455 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010f44b:	e8 f4 07 00 00       	call   f010fc44 <test_initialize_dynamic_allocator>
f010f450:	e9 03 01 00 00       	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010f455:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f458:	83 c0 04             	add    $0x4,%eax
f010f45b:	8b 00                	mov    (%eax),%eax
f010f45d:	83 ec 08             	sub    $0x8,%esp
f010f460:	68 fe 9c 12 f0       	push   $0xf0129cfe
f010f465:	50                   	push   %eax
f010f466:	e8 76 32 01 00       	call   f01226e1 <strcmp>
f010f46b:	83 c4 10             	add    $0x10,%esp
f010f46e:	85 c0                	test   %eax,%eax
f010f470:	75 0a                	jne    f010f47c <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010f472:	e8 9d 0c 00 00       	call   f0110114 <test_alloc_block_FF>
f010f477:	e9 dc 00 00 00       	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010f47c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f47f:	83 c0 04             	add    $0x4,%eax
f010f482:	8b 00                	mov    (%eax),%eax
f010f484:	83 ec 08             	sub    $0x8,%esp
f010f487:	68 06 9d 12 f0       	push   $0xf0129d06
f010f48c:	50                   	push   %eax
f010f48d:	e8 4f 32 01 00       	call   f01226e1 <strcmp>
f010f492:	83 c4 10             	add    $0x10,%esp
f010f495:	85 c0                	test   %eax,%eax
f010f497:	75 0a                	jne    f010f4a3 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010f499:	e8 d3 11 00 00       	call   f0110671 <test_alloc_block_BF>
f010f49e:	e9 b5 00 00 00       	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010f4a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4a6:	83 c0 04             	add    $0x4,%eax
f010f4a9:	8b 00                	mov    (%eax),%eax
f010f4ab:	83 ec 08             	sub    $0x8,%esp
f010f4ae:	68 0e 9d 12 f0       	push   $0xf0129d0e
f010f4b3:	50                   	push   %eax
f010f4b4:	e8 28 32 01 00       	call   f01226e1 <strcmp>
f010f4b9:	83 c4 10             	add    $0x10,%esp
f010f4bc:	85 c0                	test   %eax,%eax
f010f4be:	75 0a                	jne    f010f4ca <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010f4c0:	e8 eb 16 00 00       	call   f0110bb0 <test_alloc_block_NF>
f010f4c5:	e9 8e 00 00 00       	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010f4ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4cd:	83 c0 04             	add    $0x4,%eax
f010f4d0:	8b 00                	mov    (%eax),%eax
f010f4d2:	83 ec 08             	sub    $0x8,%esp
f010f4d5:	68 16 9d 12 f0       	push   $0xf0129d16
f010f4da:	50                   	push   %eax
f010f4db:	e8 01 32 01 00       	call   f01226e1 <strcmp>
f010f4e0:	83 c4 10             	add    $0x10,%esp
f010f4e3:	85 c0                	test   %eax,%eax
f010f4e5:	75 07                	jne    f010f4ee <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010f4e7:	e8 ca 16 00 00       	call   f0110bb6 <test_free_block_FF>
f010f4ec:	eb 6a                	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010f4ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f1:	83 c0 04             	add    $0x4,%eax
f010f4f4:	8b 00                	mov    (%eax),%eax
f010f4f6:	83 ec 08             	sub    $0x8,%esp
f010f4f9:	68 1d 9d 12 f0       	push   $0xf0129d1d
f010f4fe:	50                   	push   %eax
f010f4ff:	e8 dd 31 01 00       	call   f01226e1 <strcmp>
f010f504:	83 c4 10             	add    $0x10,%esp
f010f507:	85 c0                	test   %eax,%eax
f010f509:	75 07                	jne    f010f512 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f50b:	e8 0d 23 00 00       	call   f011181d <test_free_block_BF>
f010f510:	eb 46                	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f512:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f515:	83 c0 04             	add    $0x4,%eax
f010f518:	8b 00                	mov    (%eax),%eax
f010f51a:	83 ec 08             	sub    $0x8,%esp
f010f51d:	68 24 9d 12 f0       	push   $0xf0129d24
f010f522:	50                   	push   %eax
f010f523:	e8 b9 31 01 00       	call   f01226e1 <strcmp>
f010f528:	83 c4 10             	add    $0x10,%esp
f010f52b:	85 c0                	test   %eax,%eax
f010f52d:	75 07                	jne    f010f536 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f52f:	e8 60 2f 00 00       	call   f0112494 <test_free_block_NF>
f010f534:	eb 22                	jmp    f010f558 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f536:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f539:	83 c0 04             	add    $0x4,%eax
f010f53c:	8b 00                	mov    (%eax),%eax
f010f53e:	83 ec 08             	sub    $0x8,%esp
f010f541:	68 2b 9d 12 f0       	push   $0xf0129d2b
f010f546:	50                   	push   %eax
f010f547:	e8 95 31 01 00       	call   f01226e1 <strcmp>
f010f54c:	83 c4 10             	add    $0x10,%esp
f010f54f:	85 c0                	test   %eax,%eax
f010f551:	75 05                	jne    f010f558 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f553:	e8 59 2f 00 00       	call   f01124b1 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f558:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f55d:	c9                   	leave  
f010f55e:	c3                   	ret    

f010f55f <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f55f:	55                   	push   %ebp
f010f560:	89 e5                	mov    %esp,%ebp
f010f562:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f565:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f569:	74 1a                	je     f010f585 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f56b:	83 ec 0c             	sub    $0xc,%esp
f010f56e:	68 38 9d 12 f0       	push   $0xf0129d38
f010f573:	e8 f4 19 ff ff       	call   f0100f6c <cprintf>
f010f578:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f57b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f580:	e9 e1 00 00 00       	jmp    f010f666 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f585:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f588:	83 c0 04             	add    $0x4,%eax
f010f58b:	8b 00                	mov    (%eax),%eax
f010f58d:	83 ec 08             	sub    $0x8,%esp
f010f590:	68 71 9d 12 f0       	push   $0xf0129d71
f010f595:	50                   	push   %eax
f010f596:	e8 46 31 01 00       	call   f01226e1 <strcmp>
f010f59b:	83 c4 10             	add    $0x10,%esp
f010f59e:	85 c0                	test   %eax,%eax
f010f5a0:	75 0a                	jne    f010f5ac <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f5a2:	e8 ff 4a 00 00       	call   f01140a6 <test_cut_paste_pages>
f010f5a7:	e9 b5 00 00 00       	jmp    f010f661 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f5ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5af:	83 c0 04             	add    $0x4,%eax
f010f5b2:	8b 00                	mov    (%eax),%eax
f010f5b4:	83 ec 08             	sub    $0x8,%esp
f010f5b7:	68 7a 9d 12 f0       	push   $0xf0129d7a
f010f5bc:	50                   	push   %eax
f010f5bd:	e8 1f 31 01 00       	call   f01226e1 <strcmp>
f010f5c2:	83 c4 10             	add    $0x10,%esp
f010f5c5:	85 c0                	test   %eax,%eax
f010f5c7:	75 0a                	jne    f010f5d3 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f5c9:	e8 23 55 00 00       	call   f0114af1 <test_copy_paste_chunk>
f010f5ce:	e9 8e 00 00 00       	jmp    f010f661 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f5d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d6:	83 c0 04             	add    $0x4,%eax
f010f5d9:	8b 00                	mov    (%eax),%eax
f010f5db:	83 ec 08             	sub    $0x8,%esp
f010f5de:	68 84 9d 12 f0       	push   $0xf0129d84
f010f5e3:	50                   	push   %eax
f010f5e4:	e8 f8 30 01 00       	call   f01226e1 <strcmp>
f010f5e9:	83 c4 10             	add    $0x10,%esp
f010f5ec:	85 c0                	test   %eax,%eax
f010f5ee:	75 07                	jne    f010f5f7 <tst_chunks+0x98>
	{
		test_share_chunk();
f010f5f0:	e8 fa 65 00 00       	call   f0115bef <test_share_chunk>
f010f5f5:	eb 6a                	jmp    f010f661 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f5f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5fa:	83 c0 04             	add    $0x4,%eax
f010f5fd:	8b 00                	mov    (%eax),%eax
f010f5ff:	83 ec 08             	sub    $0x8,%esp
f010f602:	68 8a 9d 12 f0       	push   $0xf0129d8a
f010f607:	50                   	push   %eax
f010f608:	e8 d4 30 01 00       	call   f01226e1 <strcmp>
f010f60d:	83 c4 10             	add    $0x10,%esp
f010f610:	85 c0                	test   %eax,%eax
f010f612:	75 07                	jne    f010f61b <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f614:	e8 fe 6f 00 00       	call   f0116617 <test_allocate_chunk>
f010f619:	eb 46                	jmp    f010f661 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f61b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f61e:	83 c0 04             	add    $0x4,%eax
f010f621:	8b 00                	mov    (%eax),%eax
f010f623:	83 ec 08             	sub    $0x8,%esp
f010f626:	68 93 9d 12 f0       	push   $0xf0129d93
f010f62b:	50                   	push   %eax
f010f62c:	e8 b0 30 01 00       	call   f01226e1 <strcmp>
f010f631:	83 c4 10             	add    $0x10,%esp
f010f634:	85 c0                	test   %eax,%eax
f010f636:	75 07                	jne    f010f63f <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f638:	e8 e1 78 00 00       	call   f0116f1e <test_calculate_required_frames>
f010f63d:	eb 22                	jmp    f010f661 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f63f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f642:	83 c0 04             	add    $0x4,%eax
f010f645:	8b 00                	mov    (%eax),%eax
f010f647:	83 ec 08             	sub    $0x8,%esp
f010f64a:	68 a2 9d 12 f0       	push   $0xf0129da2
f010f64f:	50                   	push   %eax
f010f650:	e8 8c 30 01 00       	call   f01226e1 <strcmp>
f010f655:	83 c4 10             	add    $0x10,%esp
f010f658:	85 c0                	test   %eax,%eax
f010f65a:	75 05                	jne    f010f661 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f65c:	e8 31 81 00 00       	call   f0117792 <test_calculate_allocated_space>
	}
	return 0;
f010f661:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f666:	c9                   	leave  
f010f667:	c3                   	ret    

f010f668 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f668:	55                   	push   %ebp
f010f669:	89 e5                	mov    %esp,%ebp
f010f66b:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f66e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f672:	74 1a                	je     f010f68e <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f674:	83 ec 0c             	sub    $0xc,%esp
f010f677:	68 b4 9d 12 f0       	push   $0xf0129db4
f010f67c:	e8 eb 18 ff ff       	call   f0100f6c <cprintf>
f010f681:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f684:	b8 00 00 00 00       	mov    $0x0,%eax
f010f689:	e9 ba 00 00 00       	jmp    f010f748 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f68e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f691:	83 c0 04             	add    $0x4,%eax
f010f694:	8b 00                	mov    (%eax),%eax
f010f696:	83 ec 08             	sub    $0x8,%esp
f010f699:	68 ea 9d 12 f0       	push   $0xf0129dea
f010f69e:	50                   	push   %eax
f010f69f:	e8 3d 30 01 00       	call   f01226e1 <strcmp>
f010f6a4:	83 c4 10             	add    $0x10,%esp
f010f6a7:	85 c0                	test   %eax,%eax
f010f6a9:	75 0a                	jne    f010f6b5 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f6ab:	e8 69 44 00 00       	call   f0113b19 <test_pt_set_page_permissions>
f010f6b0:	e9 8e 00 00 00       	jmp    f010f743 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f6b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6b8:	83 c0 04             	add    $0x4,%eax
f010f6bb:	8b 00                	mov    (%eax),%eax
f010f6bd:	83 ec 08             	sub    $0x8,%esp
f010f6c0:	68 f2 9d 12 f0       	push   $0xf0129df2
f010f6c5:	50                   	push   %eax
f010f6c6:	e8 16 30 01 00       	call   f01226e1 <strcmp>
f010f6cb:	83 c4 10             	add    $0x10,%esp
f010f6ce:	85 c0                	test   %eax,%eax
f010f6d0:	75 07                	jne    f010f6d9 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f6d2:	e8 b1 46 00 00       	call   f0113d88 <test_pt_set_page_permissions_invalid_va>
f010f6d7:	eb 6a                	jmp    f010f743 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f6d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6dc:	83 c0 04             	add    $0x4,%eax
f010f6df:	8b 00                	mov    (%eax),%eax
f010f6e1:	83 ec 08             	sub    $0x8,%esp
f010f6e4:	68 fa 9d 12 f0       	push   $0xf0129dfa
f010f6e9:	50                   	push   %eax
f010f6ea:	e8 f2 2f 01 00       	call   f01226e1 <strcmp>
f010f6ef:	83 c4 10             	add    $0x10,%esp
f010f6f2:	85 c0                	test   %eax,%eax
f010f6f4:	75 07                	jne    f010f6fd <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f6f6:	e8 d6 46 00 00       	call   f0113dd1 <test_pt_get_page_permissions>
f010f6fb:	eb 46                	jmp    f010f743 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f6fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f700:	83 c0 04             	add    $0x4,%eax
f010f703:	8b 00                	mov    (%eax),%eax
f010f705:	83 ec 08             	sub    $0x8,%esp
f010f708:	68 02 9e 12 f0       	push   $0xf0129e02
f010f70d:	50                   	push   %eax
f010f70e:	e8 ce 2f 01 00       	call   f01226e1 <strcmp>
f010f713:	83 c4 10             	add    $0x10,%esp
f010f716:	85 c0                	test   %eax,%eax
f010f718:	75 07                	jne    f010f721 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f71a:	e8 f6 47 00 00       	call   f0113f15 <test_pt_clear_page_table_entry>
f010f71f:	eb 22                	jmp    f010f743 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f721:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f724:	83 c0 04             	add    $0x4,%eax
f010f727:	8b 00                	mov    (%eax),%eax
f010f729:	83 ec 08             	sub    $0x8,%esp
f010f72c:	68 09 9e 12 f0       	push   $0xf0129e09
f010f731:	50                   	push   %eax
f010f732:	e8 aa 2f 01 00       	call   f01226e1 <strcmp>
f010f737:	83 c4 10             	add    $0x10,%esp
f010f73a:	85 c0                	test   %eax,%eax
f010f73c:	75 05                	jne    f010f743 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f73e:	e8 2b 49 00 00       	call   f011406e <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f743:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f748:	c9                   	leave  
f010f749:	c3                   	ret    

f010f74a <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f74a:	55                   	push   %ebp
f010f74b:	89 e5                	mov    %esp,%ebp
f010f74d:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f750:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f753:	83 c0 08             	add    $0x8,%eax
f010f756:	8b 00                	mov    (%eax),%eax
f010f758:	83 ec 08             	sub    $0x8,%esp
f010f75b:	68 10 9e 12 f0       	push   $0xf0129e10
f010f760:	50                   	push   %eax
f010f761:	e8 7b 2f 01 00       	call   f01226e1 <strcmp>
f010f766:	83 c4 10             	add    $0x10,%esp
f010f769:	85 c0                	test   %eax,%eax
f010f76b:	75 20                	jne    f010f78d <tst_kheap+0x43>
f010f76d:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f771:	74 1a                	je     f010f78d <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f773:	83 ec 0c             	sub    $0xc,%esp
f010f776:	68 18 9e 12 f0       	push   $0xf0129e18
f010f77b:	e8 ec 17 ff ff       	call   f0100f6c <cprintf>
f010f780:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f783:	b8 00 00 00 00       	mov    $0x0,%eax
f010f788:	e9 f6 03 00 00       	jmp    f010fb83 <tst_kheap+0x439>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f78d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f790:	83 c0 08             	add    $0x8,%eax
f010f793:	8b 00                	mov    (%eax),%eax
f010f795:	83 ec 08             	sub    $0x8,%esp
f010f798:	68 10 9e 12 f0       	push   $0xf0129e10
f010f79d:	50                   	push   %eax
f010f79e:	e8 3e 2f 01 00       	call   f01226e1 <strcmp>
f010f7a3:	83 c4 10             	add    $0x10,%esp
f010f7a6:	85 c0                	test   %eax,%eax
f010f7a8:	74 43                	je     f010f7ed <tst_kheap+0xa3>
f010f7aa:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f7ae:	74 3d                	je     f010f7ed <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f7b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7b3:	83 c0 08             	add    $0x8,%eax
f010f7b6:	8b 00                	mov    (%eax),%eax
f010f7b8:	83 ec 08             	sub    $0x8,%esp
f010f7bb:	68 68 9e 12 f0       	push   $0xf0129e68
f010f7c0:	50                   	push   %eax
f010f7c1:	e8 1b 2f 01 00       	call   f01226e1 <strcmp>
f010f7c6:	83 c4 10             	add    $0x10,%esp
f010f7c9:	85 c0                	test   %eax,%eax
f010f7cb:	74 20                	je     f010f7ed <tst_kheap+0xa3>
f010f7cd:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f7d1:	74 1a                	je     f010f7ed <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f7d3:	83 ec 0c             	sub    $0xc,%esp
f010f7d6:	68 74 9e 12 f0       	push   $0xf0129e74
f010f7db:	e8 8c 17 ff ff       	call   f0100f6c <cprintf>
f010f7e0:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f7e3:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7e8:	e9 96 03 00 00       	jmp    f010fb83 <tst_kheap+0x439>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f7ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7f0:	83 c0 04             	add    $0x4,%eax
f010f7f3:	8b 00                	mov    (%eax),%eax
f010f7f5:	83 ec 08             	sub    $0x8,%esp
f010f7f8:	68 b9 9e 12 f0       	push   $0xf0129eb9
f010f7fd:	50                   	push   %eax
f010f7fe:	e8 de 2e 01 00       	call   f01226e1 <strcmp>
f010f803:	83 c4 10             	add    $0x10,%esp
f010f806:	85 c0                	test   %eax,%eax
f010f808:	74 1d                	je     f010f827 <tst_kheap+0xdd>
f010f80a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f80d:	83 c0 04             	add    $0x4,%eax
f010f810:	8b 00                	mov    (%eax),%eax
f010f812:	83 ec 08             	sub    $0x8,%esp
f010f815:	68 bc 9e 12 f0       	push   $0xf0129ebc
f010f81a:	50                   	push   %eax
f010f81b:	e8 c1 2e 01 00       	call   f01226e1 <strcmp>
f010f820:	83 c4 10             	add    $0x10,%esp
f010f823:	85 c0                	test   %eax,%eax
f010f825:	75 1a                	jne    f010f841 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f827:	e8 6d f8 ff ff       	call   f010f099 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f82c:	83 ec 0c             	sub    $0xc,%esp
f010f82f:	68 c0 9e 12 f0       	push   $0xf0129ec0
f010f834:	e8 33 17 ff ff       	call   f0100f6c <cprintf>
f010f839:	83 c4 10             	add    $0x10,%esp
f010f83c:	e9 a0 00 00 00       	jmp    f010f8e1 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f841:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f844:	83 c0 04             	add    $0x4,%eax
f010f847:	8b 00                	mov    (%eax),%eax
f010f849:	83 ec 08             	sub    $0x8,%esp
f010f84c:	68 ed 9e 12 f0       	push   $0xf0129eed
f010f851:	50                   	push   %eax
f010f852:	e8 8a 2e 01 00       	call   f01226e1 <strcmp>
f010f857:	83 c4 10             	add    $0x10,%esp
f010f85a:	85 c0                	test   %eax,%eax
f010f85c:	74 1d                	je     f010f87b <tst_kheap+0x131>
f010f85e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f861:	83 c0 04             	add    $0x4,%eax
f010f864:	8b 00                	mov    (%eax),%eax
f010f866:	83 ec 08             	sub    $0x8,%esp
f010f869:	68 f0 9e 12 f0       	push   $0xf0129ef0
f010f86e:	50                   	push   %eax
f010f86f:	e8 6d 2e 01 00       	call   f01226e1 <strcmp>
f010f874:	83 c4 10             	add    $0x10,%esp
f010f877:	85 c0                	test   %eax,%eax
f010f879:	75 17                	jne    f010f892 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f87b:	e8 29 f8 ff ff       	call   f010f0a9 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f880:	83 ec 0c             	sub    $0xc,%esp
f010f883:	68 f4 9e 12 f0       	push   $0xf0129ef4
f010f888:	e8 df 16 ff ff       	call   f0100f6c <cprintf>
f010f88d:	83 c4 10             	add    $0x10,%esp
f010f890:	eb 4f                	jmp    f010f8e1 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f892:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f895:	83 c0 04             	add    $0x4,%eax
f010f898:	8b 00                	mov    (%eax),%eax
f010f89a:	83 ec 08             	sub    $0x8,%esp
f010f89d:	68 20 9f 12 f0       	push   $0xf0129f20
f010f8a2:	50                   	push   %eax
f010f8a3:	e8 39 2e 01 00       	call   f01226e1 <strcmp>
f010f8a8:	83 c4 10             	add    $0x10,%esp
f010f8ab:	85 c0                	test   %eax,%eax
f010f8ad:	74 1d                	je     f010f8cc <tst_kheap+0x182>
f010f8af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8b2:	83 c0 04             	add    $0x4,%eax
f010f8b5:	8b 00                	mov    (%eax),%eax
f010f8b7:	83 ec 08             	sub    $0x8,%esp
f010f8ba:	68 23 9f 12 f0       	push   $0xf0129f23
f010f8bf:	50                   	push   %eax
f010f8c0:	e8 1c 2e 01 00       	call   f01226e1 <strcmp>
f010f8c5:	83 c4 10             	add    $0x10,%esp
f010f8c8:	85 c0                	test   %eax,%eax
f010f8ca:	75 15                	jne    f010f8e1 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f8cc:	e8 e8 f7 ff ff       	call   f010f0b9 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f8d1:	83 ec 0c             	sub    $0xc,%esp
f010f8d4:	68 28 9f 12 f0       	push   $0xf0129f28
f010f8d9:	e8 8e 16 ff ff       	call   f0100f6c <cprintf>
f010f8de:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f8e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8e4:	83 c0 08             	add    $0x8,%eax
f010f8e7:	8b 00                	mov    (%eax),%eax
f010f8e9:	83 ec 08             	sub    $0x8,%esp
f010f8ec:	68 10 9e 12 f0       	push   $0xf0129e10
f010f8f1:	50                   	push   %eax
f010f8f2:	e8 ea 2d 01 00       	call   f01226e1 <strcmp>
f010f8f7:	83 c4 10             	add    $0x10,%esp
f010f8fa:	85 c0                	test   %eax,%eax
f010f8fc:	0f 85 13 01 00 00    	jne    f010fa15 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f902:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f905:	83 c0 0c             	add    $0xc,%eax
f010f908:	8b 00                	mov    (%eax),%eax
f010f90a:	83 ec 04             	sub    $0x4,%esp
f010f90d:	6a 0a                	push   $0xa
f010f90f:	6a 00                	push   $0x0
f010f911:	50                   	push   %eax
f010f912:	e8 1e 30 01 00       	call   f0122935 <strtol>
f010f917:	83 c4 10             	add    $0x10,%esp
f010f91a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f91d:	e8 a7 f7 ff ff       	call   f010f0c9 <isKHeapPlacementStrategyFIRSTFIT>
f010f922:	84 c0                	test   %al,%al
f010f924:	74 54                	je     f010f97a <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f926:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f92a:	75 1a                	jne    f010f946 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f92c:	83 ec 0c             	sub    $0xc,%esp
f010f92f:	68 54 9f 12 f0       	push   $0xf0129f54
f010f934:	e8 33 16 ff ff       	call   f0100f6c <cprintf>
f010f939:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f93c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f941:	e9 3d 02 00 00       	jmp    f010fb83 <tst_kheap+0x439>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f946:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f94a:	75 0a                	jne    f010f956 <tst_kheap+0x20c>
				test_kmalloc();
f010f94c:	e8 1f a8 00 00       	call   f011a170 <test_kmalloc>
f010f951:	e9 b5 00 00 00       	jmp    f010fa0b <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f956:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f95a:	75 0a                	jne    f010f966 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f95c:	e8 29 b3 00 00       	call   f011ac8a <test_kmalloc_firstfit1>
f010f961:	e9 a5 00 00 00       	jmp    f010fa0b <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f966:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f96a:	0f 85 9b 00 00 00    	jne    f010fa0b <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010f970:	e8 a9 bd 00 00       	call   f011b71e <test_kmalloc_firstfit2>
f010f975:	e9 91 00 00 00       	jmp    f010fa0b <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010f97a:	e8 5f f7 ff ff       	call   f010f0de <isKHeapPlacementStrategyBESTFIT>
f010f97f:	84 c0                	test   %al,%al
f010f981:	74 47                	je     f010f9ca <tst_kheap+0x280>
		{
			if (testNum == 0)
f010f983:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f987:	75 1a                	jne    f010f9a3 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010f989:	83 ec 0c             	sub    $0xc,%esp
f010f98c:	68 a4 9f 12 f0       	push   $0xf0129fa4
f010f991:	e8 d6 15 ff ff       	call   f0100f6c <cprintf>
f010f996:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f999:	b8 00 00 00 00       	mov    $0x0,%eax
f010f99e:	e9 e0 01 00 00       	jmp    f010fb83 <tst_kheap+0x439>
			}
			if (testNum == 1)
f010f9a3:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f9a7:	75 07                	jne    f010f9b0 <tst_kheap+0x266>
				test_kmalloc();
f010f9a9:	e8 c2 a7 00 00       	call   f011a170 <test_kmalloc>
f010f9ae:	eb 5b                	jmp    f010fa0b <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f9b0:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f9b4:	75 07                	jne    f010f9bd <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010f9b6:	e8 30 03 01 00       	call   f011fceb <test_kmalloc_bestfit1>
f010f9bb:	eb 4e                	jmp    f010fa0b <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f9bd:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f9c1:	75 48                	jne    f010fa0b <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010f9c3:	e8 40 03 01 00       	call   f011fd08 <test_kmalloc_bestfit2>
f010f9c8:	eb 41                	jmp    f010fa0b <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010f9ca:	e8 24 f7 ff ff       	call   f010f0f3 <isKHeapPlacementStrategyNEXTFIT>
f010f9cf:	84 c0                	test   %al,%al
f010f9d1:	74 38                	je     f010fa0b <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010f9d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f9d7:	75 1a                	jne    f010f9f3 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010f9d9:	83 ec 0c             	sub    $0xc,%esp
f010f9dc:	68 f4 9f 12 f0       	push   $0xf0129ff4
f010f9e1:	e8 86 15 ff ff       	call   f0100f6c <cprintf>
f010f9e6:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f9e9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9ee:	e9 90 01 00 00       	jmp    f010fb83 <tst_kheap+0x439>
			}
			//Test cont. allocation
			if (testNum == 1)
f010f9f3:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f9f7:	75 07                	jne    f010fa00 <tst_kheap+0x2b6>
				test_kmalloc();
f010f9f9:	e8 72 a7 00 00       	call   f011a170 <test_kmalloc>
f010f9fe:	eb 0b                	jmp    f010fa0b <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010fa00:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010fa04:	75 05                	jne    f010fa0b <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010fa06:	e8 c0 02 01 00       	call   f011fccb <test_kmalloc_nextfit>
		}
		return 0;
f010fa0b:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa10:	e9 6e 01 00 00       	jmp    f010fb83 <tst_kheap+0x439>
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010fa15:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa18:	83 c0 08             	add    $0x8,%eax
f010fa1b:	8b 00                	mov    (%eax),%eax
f010fa1d:	83 ec 08             	sub    $0x8,%esp
f010fa20:	68 42 a0 12 f0       	push   $0xf012a042
f010fa25:	50                   	push   %eax
f010fa26:	e8 b6 2c 01 00       	call   f01226e1 <strcmp>
f010fa2b:	83 c4 10             	add    $0x10,%esp
f010fa2e:	85 c0                	test   %eax,%eax
f010fa30:	75 28                	jne    f010fa5a <tst_kheap+0x310>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010fa32:	e8 a7 f6 ff ff       	call   f010f0de <isKHeapPlacementStrategyBESTFIT>
f010fa37:	84 c0                	test   %al,%al
f010fa39:	75 09                	jne    f010fa44 <tst_kheap+0x2fa>
f010fa3b:	e8 89 f6 ff ff       	call   f010f0c9 <isKHeapPlacementStrategyFIRSTFIT>
f010fa40:	84 c0                	test   %al,%al
f010fa42:	74 07                	je     f010fa4b <tst_kheap+0x301>
		{
			test_kfree_bestfirstfit();
f010fa44:	e8 8e c7 00 00       	call   f011c1d7 <test_kfree_bestfirstfit>
f010fa49:	eb 05                	jmp    f010fa50 <tst_kheap+0x306>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010fa4b:	e8 f5 02 01 00       	call   f011fd45 <test_kfree>
		}
		return 0;
f010fa50:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa55:	e9 29 01 00 00       	jmp    f010fb83 <tst_kheap+0x439>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010fa5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa5d:	83 c0 08             	add    $0x8,%eax
f010fa60:	8b 00                	mov    (%eax),%eax
f010fa62:	83 ec 08             	sub    $0x8,%esp
f010fa65:	68 48 a0 12 f0       	push   $0xf012a048
f010fa6a:	50                   	push   %eax
f010fa6b:	e8 71 2c 01 00       	call   f01226e1 <strcmp>
f010fa70:	83 c4 10             	add    $0x10,%esp
f010fa73:	85 c0                	test   %eax,%eax
f010fa75:	75 0f                	jne    f010fa86 <tst_kheap+0x33c>
	{
		test_kheap_phys_addr();
f010fa77:	e8 66 dd 00 00       	call   f011d7e2 <test_kheap_phys_addr>
		return 0;
f010fa7c:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa81:	e9 fd 00 00 00       	jmp    f010fb83 <tst_kheap+0x439>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010fa86:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa89:	83 c0 08             	add    $0x8,%eax
f010fa8c:	8b 00                	mov    (%eax),%eax
f010fa8e:	83 ec 08             	sub    $0x8,%esp
f010fa91:	68 52 a0 12 f0       	push   $0xf012a052
f010fa96:	50                   	push   %eax
f010fa97:	e8 45 2c 01 00       	call   f01226e1 <strcmp>
f010fa9c:	83 c4 10             	add    $0x10,%esp
f010fa9f:	85 c0                	test   %eax,%eax
f010faa1:	75 0f                	jne    f010fab2 <tst_kheap+0x368>
	{
		test_kheap_virt_addr();
f010faa3:	e8 b4 ea 00 00       	call   f011e55c <test_kheap_virt_addr>
		return 0;
f010faa8:	b8 00 00 00 00       	mov    $0x0,%eax
f010faad:	e9 d1 00 00 00       	jmp    f010fb83 <tst_kheap+0x439>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010fab2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fab5:	83 c0 08             	add    $0x8,%eax
f010fab8:	8b 00                	mov    (%eax),%eax
f010faba:	83 ec 08             	sub    $0x8,%esp
f010fabd:	68 68 9e 12 f0       	push   $0xf0129e68
f010fac2:	50                   	push   %eax
f010fac3:	e8 19 2c 01 00       	call   f01226e1 <strcmp>
f010fac8:	83 c4 10             	add    $0x10,%esp
f010facb:	85 c0                	test   %eax,%eax
f010facd:	0f 85 89 00 00 00    	jne    f010fb5c <tst_kheap+0x412>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010fad3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fad6:	83 c0 0c             	add    $0xc,%eax
f010fad9:	8b 00                	mov    (%eax),%eax
f010fadb:	83 ec 04             	sub    $0x4,%esp
f010fade:	6a 0a                	push   $0xa
f010fae0:	6a 00                	push   $0x0
f010fae2:	50                   	push   %eax
f010fae3:	e8 4d 2e 01 00       	call   f0122935 <strtol>
f010fae8:	83 c4 10             	add    $0x10,%esp
f010faeb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010faee:	e8 d6 f5 ff ff       	call   f010f0c9 <isKHeapPlacementStrategyFIRSTFIT>
f010faf3:	84 c0                	test   %al,%al
f010faf5:	74 42                	je     f010fb39 <tst_kheap+0x3ef>
		{
			if (testNum == 0)
f010faf7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fafb:	75 17                	jne    f010fb14 <tst_kheap+0x3ca>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010fafd:	83 ec 0c             	sub    $0xc,%esp
f010fb00:	68 54 9f 12 f0       	push   $0xf0129f54
f010fb05:	e8 62 14 ff ff       	call   f0100f6c <cprintf>
f010fb0a:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fb0d:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb12:	eb 6f                	jmp    f010fb83 <tst_kheap+0x439>
			}
			if (testNum==1)
f010fb14:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010fb18:	75 07                	jne    f010fb21 <tst_kheap+0x3d7>
				test_krealloc_FF1();
f010fb1a:	e8 0c 05 01 00       	call   f012002b <test_krealloc_FF1>
f010fb1f:	eb 18                	jmp    f010fb39 <tst_kheap+0x3ef>
			else if (testNum==2)
f010fb21:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010fb25:	75 07                	jne    f010fb2e <tst_kheap+0x3e4>
				test_krealloc_FF2();
f010fb27:	e8 4c 05 01 00       	call   f0120078 <test_krealloc_FF2>
f010fb2c:	eb 0b                	jmp    f010fb39 <tst_kheap+0x3ef>
			else if (testNum==3)
f010fb2e:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010fb32:	75 05                	jne    f010fb39 <tst_kheap+0x3ef>
				test_krealloc_FF3();
f010fb34:	e8 8c 05 01 00       	call   f01200c5 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010fb39:	e8 b5 f5 ff ff       	call   f010f0f3 <isKHeapPlacementStrategyNEXTFIT>
f010fb3e:	84 c0                	test   %al,%al
f010fb40:	74 05                	je     f010fb47 <tst_kheap+0x3fd>
		{
			test_krealloc();
f010fb42:	e8 4a 04 01 00       	call   f011ff91 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010fb47:	e8 92 f5 ff ff       	call   f010f0de <isKHeapPlacementStrategyBESTFIT>
f010fb4c:	84 c0                	test   %al,%al
f010fb4e:	74 05                	je     f010fb55 <tst_kheap+0x40b>
		{
			test_krealloc_BF();
f010fb50:	e8 89 04 01 00       	call   f011ffde <test_krealloc_BF>
		}
		return 0;
f010fb55:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb5a:	eb 27                	jmp    f010fb83 <tst_kheap+0x439>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010fb5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb5f:	83 c0 08             	add    $0x8,%eax
f010fb62:	8b 00                	mov    (%eax),%eax
f010fb64:	83 ec 08             	sub    $0x8,%esp
f010fb67:	68 5c a0 12 f0       	push   $0xf012a05c
f010fb6c:	50                   	push   %eax
f010fb6d:	e8 6f 2b 01 00       	call   f01226e1 <strcmp>
f010fb72:	83 c4 10             	add    $0x10,%esp
f010fb75:	85 c0                	test   %eax,%eax
f010fb77:	75 05                	jne    f010fb7e <tst_kheap+0x434>
	{
		test_ksbrk();
f010fb79:	e8 78 f6 00 00       	call   f011f1f6 <test_ksbrk>
	}
	return 0;
f010fb7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fb83:	c9                   	leave  
f010fb84:	c3                   	ret    

f010fb85 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f010fb85:	55                   	push   %ebp
f010fb86:	89 e5                	mov    %esp,%ebp
f010fb88:	83 ec 28             	sub    $0x28,%esp
f010fb8b:	8b 45 14             	mov    0x14(%ebp),%eax
f010fb8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f010fb91:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb94:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fb97:	74 1d                	je     f010fbb6 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f010fb99:	83 ec 04             	sub    $0x4,%esp
f010fb9c:	ff 75 08             	pushl  0x8(%ebp)
f010fb9f:	ff 75 0c             	pushl  0xc(%ebp)
f010fba2:	68 64 a0 12 f0       	push   $0xf012a064
f010fba7:	e8 c0 13 ff ff       	call   f0100f6c <cprintf>
f010fbac:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fbaf:	b8 00 00 00 00       	mov    $0x0,%eax
f010fbb4:	eb 55                	jmp    f010fc0b <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f010fbb6:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbb9:	8b 40 fc             	mov    -0x4(%eax),%eax
f010fbbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f010fbbf:	8b 45 10             	mov    0x10(%ebp),%eax
f010fbc2:	8d 50 f8             	lea    -0x8(%eax),%edx
f010fbc5:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbc8:	01 d0                	add    %edx,%eax
f010fbca:	8b 00                	mov    (%eax),%eax
f010fbcc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f010fbcf:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f010fbd3:	0b 45 10             	or     0x10(%ebp),%eax
f010fbd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f010fbd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fbdc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fbdf:	75 08                	jne    f010fbe9 <check_block+0x64>
f010fbe1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fbe4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fbe7:	74 1d                	je     f010fc06 <check_block+0x81>
	{

		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f010fbe9:	ff 75 f0             	pushl  -0x10(%ebp)
f010fbec:	ff 75 f4             	pushl  -0xc(%ebp)
f010fbef:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbf2:	68 94 a0 12 f0       	push   $0xf012a094
f010fbf7:	e8 70 13 ff ff       	call   f0100f6c <cprintf>
f010fbfc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fbff:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc04:	eb 05                	jmp    f010fc0b <check_block+0x86>
	}
	return 1;
f010fc06:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fc0b:	c9                   	leave  
f010fc0c:	c3                   	ret    

f010fc0d <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f010fc0d:	55                   	push   %ebp
f010fc0e:	89 e5                	mov    %esp,%ebp
f010fc10:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f010fc13:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f010fc18:	3b 45 08             	cmp    0x8(%ebp),%eax
f010fc1b:	74 20                	je     f010fc3d <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f010fc1d:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f010fc22:	83 ec 04             	sub    $0x4,%esp
f010fc25:	50                   	push   %eax
f010fc26:	ff 75 08             	pushl  0x8(%ebp)
f010fc29:	68 d0 a0 12 f0       	push   $0xf012a0d0
f010fc2e:	e8 39 13 ff ff       	call   f0100f6c <cprintf>
f010fc33:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fc36:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc3b:	eb 05                	jmp    f010fc42 <check_list_size+0x35>
	}
	return 1;
f010fc3d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fc42:	c9                   	leave  
f010fc43:	c3                   	ret    

f010fc44 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f010fc44:	55                   	push   %ebp
f010fc45:	89 e5                	mov    %esp,%ebp
f010fc47:	83 ec 28             	sub    $0x28,%esp
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
	return;
#endif

	//write initial data at the start (for checking)
	int* tmp_ptr = (int*)KERNEL_HEAP_START;
f010fc4a:	c7 45 f4 00 00 00 f6 	movl   $0xf6000000,-0xc(%ebp)
	*tmp_ptr = -1 ;
f010fc51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc54:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	*(tmp_ptr+1) = 1 ;
f010fc5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc5d:	83 c0 04             	add    $0x4,%eax
f010fc60:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	uint32 initAllocatedSpace = 2*Mega;
f010fc66:	c7 45 f0 00 00 20 00 	movl   $0x200000,-0x10(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010fc6d:	83 ec 08             	sub    $0x8,%esp
f010fc70:	ff 75 f0             	pushl  -0x10(%ebp)
f010fc73:	68 00 00 00 f6       	push   $0xf6000000
f010fc78:	e8 27 35 01 00       	call   f01231a4 <initialize_dynamic_allocator>
f010fc7d:	83 c4 10             	add    $0x10,%esp


	//Check#1: Metadata
	uint32* daBeg = (uint32*) KERNEL_HEAP_START ;
f010fc80:	c7 45 ec 00 00 00 f6 	movl   $0xf6000000,-0x14(%ebp)
	uint32* daEnd = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - sizeof(int));
f010fc87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fc8a:	2d 04 00 00 0a       	sub    $0xa000004,%eax
f010fc8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32* blkHeader = (uint32*) (KERNEL_HEAP_START + sizeof(int));
f010fc92:	c7 45 e4 04 00 00 f6 	movl   $0xf6000004,-0x1c(%ebp)
	uint32* blkFooter = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - 2*sizeof(int));
f010fc99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fc9c:	2d 08 00 00 0a       	sub    $0xa000008,%eax
f010fca1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (*daBeg != 1 || *daEnd != 1 || (*blkHeader != initAllocatedSpace - 2*sizeof(int))|| (*blkFooter != initAllocatedSpace - 2*sizeof(int)))
f010fca4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fca7:	8b 00                	mov    (%eax),%eax
f010fca9:	83 f8 01             	cmp    $0x1,%eax
f010fcac:	75 28                	jne    f010fcd6 <test_initialize_dynamic_allocator+0x92>
f010fcae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fcb1:	8b 00                	mov    (%eax),%eax
f010fcb3:	83 f8 01             	cmp    $0x1,%eax
f010fcb6:	75 1e                	jne    f010fcd6 <test_initialize_dynamic_allocator+0x92>
f010fcb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fcbb:	8b 00                	mov    (%eax),%eax
f010fcbd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010fcc0:	83 ea 08             	sub    $0x8,%edx
f010fcc3:	39 d0                	cmp    %edx,%eax
f010fcc5:	75 0f                	jne    f010fcd6 <test_initialize_dynamic_allocator+0x92>
f010fcc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fcca:	8b 00                	mov    (%eax),%eax
f010fccc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010fccf:	83 ea 08             	sub    $0x8,%edx
f010fcd2:	39 d0                	cmp    %edx,%eax
f010fcd4:	74 14                	je     f010fcea <test_initialize_dynamic_allocator+0xa6>
	{
		panic("Content of header/footer and/or DA begin/end are not set correctly");
f010fcd6:	83 ec 04             	sub    $0x4,%esp
f010fcd9:	68 04 a1 12 f0       	push   $0xf012a104
f010fcde:	6a 54                	push   $0x54
f010fce0:	68 48 a1 12 f0       	push   $0xf012a148
f010fce5:	e8 30 06 ff ff       	call   f010031a <_panic>
	}
	if (LIST_SIZE(&freeBlocksList) != 1 || (uint32)LIST_FIRST(&freeBlocksList) != KERNEL_HEAP_START + 2*sizeof(int))
f010fcea:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f010fcef:	83 f8 01             	cmp    $0x1,%eax
f010fcf2:	75 0c                	jne    f010fd00 <test_initialize_dynamic_allocator+0xbc>
f010fcf4:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f010fcf9:	3d 08 00 00 f6       	cmp    $0xf6000008,%eax
f010fcfe:	74 14                	je     f010fd14 <test_initialize_dynamic_allocator+0xd0>
	{
		panic("free block is not added correctly");
f010fd00:	83 ec 04             	sub    $0x4,%esp
f010fd03:	68 6c a1 12 f0       	push   $0xf012a16c
f010fd08:	6a 58                	push   $0x58
f010fd0a:	68 48 a1 12 f0       	push   $0xf012a148
f010fd0f:	e8 06 06 ff ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
f010fd14:	83 ec 0c             	sub    $0xc,%esp
f010fd17:	68 90 a1 12 f0       	push   $0xf012a190
f010fd1c:	e8 4b 12 ff ff       	call   f0100f6c <cprintf>
f010fd21:	83 c4 10             	add    $0x10,%esp
}
f010fd24:	90                   	nop
f010fd25:	c9                   	leave  
f010fd26:	c3                   	ret    

f010fd27 <test_initial_alloc>:


int test_initial_alloc(int ALLOC_STRATEGY)
{
f010fd27:	55                   	push   %ebp
f010fd28:	89 e5                	mov    %esp,%ebp
f010fd2a:	83 ec 48             	sub    $0x48,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return 0;
#endif

	int eval = 0;
f010fd2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct = 1;
f010fd34:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int initAllocatedSpace = 3*Mega;
f010fd3b:	c7 45 d0 00 00 30 00 	movl   $0x300000,-0x30(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010fd42:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd45:	83 ec 08             	sub    $0x8,%esp
f010fd48:	50                   	push   %eax
f010fd49:	68 00 00 00 f6       	push   $0xf6000000
f010fd4e:	e8 51 34 01 00       	call   f01231a4 <initialize_dynamic_allocator>
f010fd53:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/*INITIAL ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f010fd56:	83 ec 0c             	sub    $0xc,%esp
f010fd59:	68 e0 a1 12 f0       	push   $0xf012a1e0
f010fd5e:	e8 09 12 ff ff       	call   f0100f6c <cprintf>
f010fd63:	83 c4 10             	add    $0x10,%esp

	is_correct = 1;
f010fd66:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	va = alloc_block(3*initAllocatedSpace, ALLOC_STRATEGY);
f010fd6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd70:	89 c2                	mov    %eax,%edx
f010fd72:	01 d2                	add    %edx,%edx
f010fd74:	01 d0                	add    %edx,%eax
f010fd76:	83 ec 08             	sub    $0x8,%esp
f010fd79:	ff 75 08             	pushl  0x8(%ebp)
f010fd7c:	50                   	push   %eax
f010fd7d:	e8 f5 32 01 00       	call   f0123077 <alloc_block>
f010fd82:	83 c4 10             	add    $0x10,%esp
f010fd85:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010fd88:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010fd8c:	74 17                	je     f010fda5 <test_initial_alloc+0x7e>
	{
		is_correct = 0;
f010fd8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #1: should not be allocated.\n");
f010fd95:	83 ec 0c             	sub    $0xc,%esp
f010fd98:	68 1c a2 12 f0       	push   $0xf012a21c
f010fd9d:	e8 ca 11 ff ff       	call   f0100f6c <cprintf>
f010fda2:	83 c4 10             	add    $0x10,%esp
	}
	va = alloc_block(initAllocatedSpace, ALLOC_STRATEGY);
f010fda5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fda8:	83 ec 08             	sub    $0x8,%esp
f010fdab:	ff 75 08             	pushl  0x8(%ebp)
f010fdae:	50                   	push   %eax
f010fdaf:	e8 c3 32 01 00       	call   f0123077 <alloc_block>
f010fdb4:	83 c4 10             	add    $0x10,%esp
f010fdb7:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010fdba:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010fdbe:	74 17                	je     f010fdd7 <test_initial_alloc+0xb0>
	{
		is_correct = 0;
f010fdc0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #2: should not be allocated.\n");
f010fdc7:	83 ec 0c             	sub    $0xc,%esp
f010fdca:	68 4c a2 12 f0       	push   $0xf012a24c
f010fdcf:	e8 98 11 ff ff       	call   f0100f6c <cprintf>
f010fdd4:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f010fdd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fddb:	74 04                	je     f010fde1 <test_initial_alloc+0xba>
	{
		eval += 5;
f010fddd:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 2: Try to allocate set of blocks with different sizes*/
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
f010fde1:	83 ec 0c             	sub    $0xc,%esp
f010fde4:	68 7c a2 12 f0       	push   $0xf012a27c
f010fde9:	e8 7e 11 ff ff       	call   f0100f6c <cprintf>
f010fdee:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fdf1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	int totalSizes = 0;
f010fdf8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f010fdff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010fe06:	eb 2a                	jmp    f010fe32 <test_initial_alloc+0x10b>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f010fe08:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe0b:	8b 14 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%edx
f010fe12:	89 d0                	mov    %edx,%eax
f010fe14:	c1 e0 02             	shl    $0x2,%eax
f010fe17:	01 d0                	add    %edx,%eax
f010fe19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fe20:	01 d0                	add    %edx,%eax
f010fe22:	c1 e0 03             	shl    $0x3,%eax
f010fe25:	89 c2                	mov    %eax,%edx
f010fe27:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fe2a:	01 d0                	add    %edx,%eax
f010fe2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
	is_correct = 1;
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f010fe2f:	ff 45 e8             	incl   -0x18(%ebp)
f010fe32:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f010fe36:	7e d0                	jle    f010fe08 <test_initial_alloc+0xe1>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;

	}

	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ;
f010fe38:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fe3b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f010fe3e:	83 e8 08             	sub    $0x8,%eax
f010fe41:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//exclude size of "DA Begin & End" blocks
	//cprintf("\n********* Remaining size = %d\n", remainSize);
	if (remainSize <= 0)
f010fe44:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010fe48:	7f 17                	jg     f010fe61 <test_initial_alloc+0x13a>
	{
		is_correct = 0;
f010fe4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
f010fe51:	83 ec 0c             	sub    $0xc,%esp
f010fe54:	68 c8 a2 12 f0       	push   $0xf012a2c8
f010fe59:	e8 0e 11 ff ff       	call   f0100f6c <cprintf>
f010fe5e:	83 c4 10             	add    $0x10,%esp
	}
	int idx = 0;
f010fe61:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f010fe68:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010fe6f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010fe76:	e9 f3 00 00 00       	jmp    f010ff6e <test_initial_alloc+0x247>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010fe7b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010fe82:	e9 d7 00 00 00       	jmp    f010ff5e <test_initial_alloc+0x237>
		{

			actualSize = allocSizes[i] - sizeOfMetaData;
f010fe87:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fe8a:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f010fe91:	83 e8 08             	sub    $0x8,%eax
f010fe94:	89 45 c4             	mov    %eax,-0x3c(%ebp)

			va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010fe97:	83 ec 08             	sub    $0x8,%esp
f010fe9a:	ff 75 08             	pushl  0x8(%ebp)
f010fe9d:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fea0:	e8 d2 31 01 00       	call   f0123077 <alloc_block>
f010fea5:	83 c4 10             	add    $0x10,%esp
f010fea8:	89 c2                	mov    %eax,%edx
f010feaa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fead:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f010feb4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010feb7:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f010febe:	89 45 cc             	mov    %eax,-0x34(%ebp)

			midVAs[idx] = va + actualSize/2 ;
f010fec1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fec4:	d1 e8                	shr    %eax
f010fec6:	89 c2                	mov    %eax,%edx
f010fec8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fecb:	01 c2                	add    %eax,%edx
f010fecd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fed0:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f010fed7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010feda:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fedd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fee0:	01 c2                	add    %eax,%edx
f010fee2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fee5:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
			//Check block
			expectedVA = (curVA + sizeOfMetaData/2);
f010feec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010feef:	83 c0 04             	add    $0x4,%eax
f010fef2:	89 45 c0             	mov    %eax,-0x40(%ebp)

			if (check_block(va, expectedVA, allocSizes[i], 1) == 0)
f010fef5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fef8:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f010feff:	6a 01                	push   $0x1
f010ff01:	50                   	push   %eax
f010ff02:	ff 75 c0             	pushl  -0x40(%ebp)
f010ff05:	ff 75 cc             	pushl  -0x34(%ebp)
f010ff08:	e8 78 fc ff ff       	call   f010fb85 <check_block>
f010ff0d:	83 c4 10             	add    $0x10,%esp
f010ff10:	85 c0                	test   %eax,%eax
f010ff12:	75 07                	jne    f010ff1b <test_initial_alloc+0x1f4>
			{

				is_correct = 0;
f010ff14:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			}

			curVA += allocSizes[i] ;
f010ff1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff1e:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f010ff25:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f010ff28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff2b:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f010ff32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff35:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f010ff38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff3b:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f010ff42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff45:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f010ff48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff4b:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f010ff52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff55:	66 89 02             	mov    %ax,(%edx)
			idx++;
f010ff58:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010ff5b:	ff 45 d8             	incl   -0x28(%ebp)
f010ff5e:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f010ff65:	0f 8e 1c ff ff ff    	jle    f010fe87 <test_initial_alloc+0x160>
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
	}
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010ff6b:	ff 45 dc             	incl   -0x24(%ebp)
f010ff6e:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f010ff72:	0f 8e 03 ff ff ff    	jle    f010fe7b <test_initial_alloc+0x154>
			idx++;
		}
		//if (is_correct == 0)
		//break;
	}
	if (is_correct)
f010ff78:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ff7c:	74 04                	je     f010ff82 <test_initial_alloc+0x25b>
	{
		eval += 15;
f010ff7e:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}
	if (check_list_size(1))
f010ff82:	83 ec 0c             	sub    $0xc,%esp
f010ff85:	6a 01                	push   $0x1
f010ff87:	e8 81 fc ff ff       	call   f010fc0d <check_list_size>
f010ff8c:	83 c4 10             	add    $0x10,%esp
f010ff8f:	85 c0                	test   %eax,%eax
f010ff91:	74 04                	je     f010ff97 <test_initial_alloc+0x270>
	{
		eval += 5;
f010ff93:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f010ff97:	83 ec 0c             	sub    $0xc,%esp
f010ff9a:	68 44 a3 12 f0       	push   $0xf012a344
f010ff9f:	e8 c8 0f ff ff       	call   f0100f6c <cprintf>
f010ffa4:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010ffa7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	actualSize = remainSize - sizeOfMetaData;
f010ffae:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010ffb1:	83 e8 08             	sub    $0x8,%eax
f010ffb4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010ffb7:	83 ec 08             	sub    $0x8,%esp
f010ffba:	ff 75 08             	pushl  0x8(%ebp)
f010ffbd:	ff 75 c4             	pushl  -0x3c(%ebp)
f010ffc0:	e8 b2 30 01 00       	call   f0123077 <alloc_block>
f010ffc5:	83 c4 10             	add    $0x10,%esp
f010ffc8:	89 c2                	mov    %eax,%edx
f010ffca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ffcd:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f010ffd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ffd7:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f010ffde:	89 45 cc             	mov    %eax,-0x34(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f010ffe1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ffe4:	d1 e8                	shr    %eax
f010ffe6:	89 c2                	mov    %eax,%edx
f010ffe8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ffeb:	01 c2                	add    %eax,%edx
f010ffed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fff0:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f010fff7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fffa:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fffd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110000:	01 c2                	add    %eax,%edx
f0110002:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110005:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
	//Check block
	expectedVA = (curVA + sizeOfMetaData/2);
f011000c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011000f:	83 c0 04             	add    $0x4,%eax
f0110012:	89 45 c0             	mov    %eax,-0x40(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, remainSize, 1) ;
f0110015:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110019:	74 17                	je     f0110032 <test_initial_alloc+0x30b>
f011001b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011001e:	6a 01                	push   $0x1
f0110020:	50                   	push   %eax
f0110021:	ff 75 c0             	pushl  -0x40(%ebp)
f0110024:	ff 75 cc             	pushl  -0x34(%ebp)
f0110027:	e8 59 fb ff ff       	call   f010fb85 <check_block>
f011002c:	83 c4 10             	add    $0x10,%esp
f011002f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct) is_correct = check_list_size(0);
f0110032:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110036:	74 10                	je     f0110048 <test_initial_alloc+0x321>
f0110038:	83 ec 0c             	sub    $0xc,%esp
f011003b:	6a 00                	push   $0x0
f011003d:	e8 cb fb ff ff       	call   f010fc0d <check_list_size>
f0110042:	83 c4 10             	add    $0x10,%esp
f0110045:	89 45 f0             	mov    %eax,-0x10(%ebp)

	*(startVAs[idx]) = idx ;
f0110048:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011004b:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0110052:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110055:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f0110058:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011005b:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f0110062:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110065:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f0110068:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011006b:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f0110072:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110075:	66 89 02             	mov    %ax,(%edx)
	if (is_correct)
f0110078:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011007c:	74 04                	je     f0110082 <test_initial_alloc+0x35b>
	{
		eval += 5;
f011007e:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
f0110082:	83 ec 0c             	sub    $0xc,%esp
f0110085:	68 90 a3 12 f0       	push   $0xf012a390
f011008a:	e8 dd 0e ff ff       	call   f0100f6c <cprintf>
f011008f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110092:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f0110099:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f01100a0:	eb 5b                	jmp    f01100fd <test_initial_alloc+0x3d6>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f01100a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01100a5:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01100ac:	66 8b 00             	mov    (%eax),%ax
f01100af:	98                   	cwtl   
f01100b0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01100b3:	75 26                	jne    f01100db <test_initial_alloc+0x3b4>
f01100b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01100b8:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f01100bf:	66 8b 00             	mov    (%eax),%ax
f01100c2:	98                   	cwtl   
f01100c3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01100c6:	75 13                	jne    f01100db <test_initial_alloc+0x3b4>
f01100c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01100cb:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f01100d2:	66 8b 00             	mov    (%eax),%ax
f01100d5:	98                   	cwtl   
f01100d6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01100d9:	74 1f                	je     f01100fa <test_initial_alloc+0x3d3>
		{
			is_correct = 0;
f01100db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f01100e2:	83 ec 04             	sub    $0x4,%esp
f01100e5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01100e8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01100eb:	68 c4 a3 12 f0       	push   $0xf012a3c4
f01100f0:	e8 77 0e ff ff       	call   f0100f6c <cprintf>
f01100f5:	83 c4 10             	add    $0x10,%esp
			break;
f01100f8:	eb 0b                	jmp    f0110105 <test_initial_alloc+0x3de>
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f01100fa:	ff 45 d4             	incl   -0x2c(%ebp)
f01100fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110100:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110103:	7c 9d                	jl     f01100a2 <test_initial_alloc+0x37b>
			is_correct = 0;
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
			break;
		}
	}
	if (is_correct)
f0110105:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110109:	74 04                	je     f011010f <test_initial_alloc+0x3e8>
	{
		eval += 10;
f011010b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}
	return eval;
f011010f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110112:	c9                   	leave  
f0110113:	c3                   	ret    

f0110114 <test_alloc_block_FF>:

void test_alloc_block_FF()
{
f0110114:	55                   	push   %ebp
f0110115:	89 e5                	mov    %esp,%ebp
f0110117:	57                   	push   %edi
f0110118:	56                   	push   %esi
f0110119:	53                   	push   %ebx
f011011a:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	int eval = 0;
f0110120:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_correct;
	void* va = NULL;
f0110127:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 actualSize = 0;
f011012e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)

	cprintf("=======================================================\n") ;
f0110135:	83 ec 0c             	sub    $0xc,%esp
f0110138:	68 14 a4 12 f0       	push   $0xf012a414
f011013d:	e8 2a 0e ff ff       	call   f0100f6c <cprintf>
f0110142:	83 c4 10             	add    $0x10,%esp
	cprintf("FIRST: Tests depend on the Allocate Function ONLY [40%]\n") ;
f0110145:	83 ec 0c             	sub    $0xc,%esp
f0110148:	68 50 a4 12 f0       	push   $0xf012a450
f011014d:	e8 1a 0e ff ff       	call   f0100f6c <cprintf>
f0110152:	83 c4 10             	add    $0x10,%esp
	cprintf("=======================================================\n") ;
f0110155:	83 ec 0c             	sub    $0xc,%esp
f0110158:	68 14 a4 12 f0       	push   $0xf012a414
f011015d:	e8 0a 0e ff ff       	call   f0100f6c <cprintf>
f0110162:	83 c4 10             	add    $0x10,%esp
	eval = test_initial_alloc(DA_FF);
f0110165:	83 ec 0c             	sub    $0xc,%esp
f0110168:	6a 01                	push   $0x1
f011016a:	e8 b8 fb ff ff       	call   f010fd27 <test_initial_alloc>
f011016f:	83 c4 10             	add    $0x10,%esp
f0110172:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cprintf("====================================================\n") ;
f0110175:	83 ec 0c             	sub    $0xc,%esp
f0110178:	68 8c a4 12 f0       	push   $0xf012a48c
f011017d:	e8 ea 0d ff ff       	call   f0100f6c <cprintf>
f0110182:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
f0110185:	83 ec 0c             	sub    $0xc,%esp
f0110188:	68 c4 a4 12 f0       	push   $0xf012a4c4
f011018d:	e8 da 0d ff ff       	call   f0100f6c <cprintf>
f0110192:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
f0110195:	83 ec 0c             	sub    $0xc,%esp
f0110198:	68 8c a4 12 f0       	push   $0xf012a48c
f011019d:	e8 ca 0d ff ff       	call   f0100f6c <cprintf>
f01101a2:	83 c4 10             	add    $0x10,%esp

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f01101a5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01101ac:	eb 2c                	jmp    f01101da <test_alloc_block_FF+0xc6>
	{
		free_block(startVAs[i*allocCntPerSize]);
f01101ae:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01101b1:	89 d0                	mov    %edx,%eax
f01101b3:	c1 e0 02             	shl    $0x2,%eax
f01101b6:	01 d0                	add    %edx,%eax
f01101b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01101bf:	01 d0                	add    %edx,%eax
f01101c1:	c1 e0 03             	shl    $0x3,%eax
f01101c4:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01101cb:	83 ec 0c             	sub    $0xc,%esp
f01101ce:	50                   	push   %eax
f01101cf:	e8 bb 39 01 00       	call   f0123b8f <free_block>
f01101d4:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
	cprintf("====================================================\n") ;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f01101d7:	ff 45 dc             	incl   -0x24(%ebp)
f01101da:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f01101de:	7e ce                	jle    f01101ae <test_alloc_block_FF+0x9a>
	{
		free_block(startVAs[i*allocCntPerSize]);
	}
	//Check number of freed blocks
	is_correct = check_list_size(numOfAllocs);
f01101e0:	83 ec 0c             	sub    $0xc,%esp
f01101e3:	6a 07                	push   $0x7
f01101e5:	e8 23 fa ff ff       	call   f010fc0d <check_list_size>
f01101ea:	83 c4 10             	add    $0x10,%esp
f01101ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f01101f0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01101f4:	74 04                	je     f01101fa <test_alloc_block_FF+0xe6>
	{
		eval += 10;
f01101f6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f01101fa:	83 ec 0c             	sub    $0xc,%esp
f01101fd:	68 e0 a1 12 f0       	push   $0xf012a1e0
f0110202:	e8 65 0d ff ff       	call   f0100f6c <cprintf>
f0110207:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011020a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	uint32 maxSize = 0 ;
f0110211:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f0110218:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011021f:	eb 1f                	jmp    f0110240 <test_alloc_block_FF+0x12c>
	{
		if (allocSizes[i] > maxSize)
f0110221:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110224:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f011022b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011022e:	76 0d                	jbe    f011023d <test_alloc_block_FF+0x129>
			maxSize = allocSizes[i] ;
f0110230:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110233:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f011023a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
	is_correct = 1;

	uint32 maxSize = 0 ;
	for (int i = 0; i < numOfAllocs; ++i)
f011023d:	ff 45 d4             	incl   -0x2c(%ebp)
f0110240:	83 7d d4 06          	cmpl   $0x6,-0x2c(%ebp)
f0110244:	7e db                	jle    f0110221 <test_alloc_block_FF+0x10d>
	{
		if (allocSizes[i] > maxSize)
			maxSize = allocSizes[i] ;
	}
	va = alloc_block(maxSize, DA_FF);
f0110246:	83 ec 08             	sub    $0x8,%esp
f0110249:	6a 01                	push   $0x1
f011024b:	ff 75 d8             	pushl  -0x28(%ebp)
f011024e:	e8 24 2e 01 00       	call   f0123077 <alloc_block>
f0110253:	83 c4 10             	add    $0x10,%esp
f0110256:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//Check returned va
	if(va != NULL)
f0110259:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f011025d:	74 17                	je     f0110276 <test_alloc_block_FF+0x162>
	{
		is_correct = 0;
f011025f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #5: WRONG FF ALLOC - alloc_block_FF find a block instead no existing free blocks with the given size.\n");
f0110266:	83 ec 0c             	sub    $0xc,%esp
f0110269:	68 fc a4 12 f0       	push   $0xf012a4fc
f011026e:	e8 f9 0c ff ff       	call   f0100f6c <cprintf>
f0110273:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f0110276:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011027a:	74 04                	je     f0110280 <test_alloc_block_FF+0x16c>
	{
		eval += 5;
f011027c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 2: Try to allocate blocks with sizes smaller than existing free blocks*/
	cprintf("	2: Try to allocate set of blocks with different sizes smaller than existing free blocks\n\n") ;
f0110280:	83 ec 0c             	sub    $0xc,%esp
f0110283:	68 74 a5 12 f0       	push   $0xf012a574
f0110288:	e8 df 0c ff ff       	call   f0100f6c <cprintf>
f011028d:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110290:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* expectedVA;
	uint32 expectedNumFreeBlks;
#define numOfFFTests 3
	uint32 startVA = KERNEL_HEAP_START + sizeof(int); //just after the DA Begin block
f0110297:	c7 45 c0 04 00 00 f6 	movl   $0xf6000004,-0x40(%ebp)
	uint32 testSizes[numOfFFTests] = {1*kilo + kilo/2, 3*kilo, kilo/2} ;
f011029e:	8d 45 ac             	lea    -0x54(%ebp),%eax
f01102a1:	bb 14 a7 12 f0       	mov    $0xf012a714,%ebx
f01102a6:	ba 03 00 00 00       	mov    $0x3,%edx
f01102ab:	89 c7                	mov    %eax,%edi
f01102ad:	89 de                	mov    %ebx,%esi
f01102af:	89 d1                	mov    %edx,%ecx
f01102b1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
f01102b3:	a1 40 33 5c f0       	mov    0xf05c3340,%eax
f01102b8:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
f01102bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01102be:	83 c0 04             	add    $0x4,%eax
f01102c1:	89 45 a0             	mov    %eax,-0x60(%ebp)
f01102c4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01102c7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01102ca:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01102cd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01102d0:	01 d0                	add    %edx,%eax
f01102d2:	83 c0 04             	add    $0x4,%eax
f01102d5:	89 45 a8             	mov    %eax,-0x58(%ebp)
	short* tstStartVAs[numOfFFTests+2] ;
	short* tstMidVAs[numOfFFTests+2] ;
	short* tstEndVAs[numOfFFTests+2] ;
	for (int i = 0; i < numOfFFTests; ++i)
f01102d8:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01102df:	e9 08 01 00 00       	jmp    f01103ec <test_alloc_block_FF+0x2d8>
	{
		actualSize = testSizes[i] - sizeOfMetaData;
f01102e4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01102e7:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
f01102eb:	83 e8 08             	sub    $0x8,%eax
f01102ee:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		cprintf("311\n");
f01102f1:	83 ec 0c             	sub    $0xc,%esp
f01102f4:	68 cf a5 12 f0       	push   $0xf012a5cf
f01102f9:	e8 6e 0c ff ff       	call   f0100f6c <cprintf>
f01102fe:	83 c4 10             	add    $0x10,%esp
		va = tstStartVAs[i] = alloc_block(actualSize, DA_FF);
f0110301:	83 ec 08             	sub    $0x8,%esp
f0110304:	6a 01                	push   $0x1
f0110306:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110309:	e8 69 2d 01 00       	call   f0123077 <alloc_block>
f011030e:	83 c4 10             	add    $0x10,%esp
f0110311:	89 c2                	mov    %eax,%edx
f0110313:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110316:	89 54 85 8c          	mov    %edx,-0x74(%ebp,%eax,4)
f011031a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011031d:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f0110321:	89 45 c8             	mov    %eax,-0x38(%ebp)
		cprintf("313\n");
f0110324:	83 ec 0c             	sub    $0xc,%esp
f0110327:	68 d4 a5 12 f0       	push   $0xf012a5d4
f011032c:	e8 3b 0c ff ff       	call   f0100f6c <cprintf>
f0110331:	83 c4 10             	add    $0x10,%esp
		tstMidVAs[i] = va + actualSize/2 ;
f0110334:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110337:	d1 e8                	shr    %eax
f0110339:	89 c2                	mov    %eax,%edx
f011033b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011033e:	01 c2                	add    %eax,%edx
f0110340:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110343:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
		tstEndVAs[i] = va + actualSize - sizeof(short);
f011034a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011034d:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110350:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110353:	01 c2                	add    %eax,%edx
f0110355:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110358:	89 94 85 64 ff ff ff 	mov    %edx,-0x9c(%ebp,%eax,4)
		//Check block
		cprintf("test#%d\n",i);
f011035f:	83 ec 08             	sub    $0x8,%esp
f0110362:	ff 75 d0             	pushl  -0x30(%ebp)
f0110365:	68 d9 a5 12 f0       	push   $0xf012a5d9
f011036a:	e8 fd 0b ff ff       	call   f0100f6c <cprintf>
f011036f:	83 c4 10             	add    $0x10,%esp
		expectedVA = (void*)expectedVAs[i];
f0110372:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110375:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f0110379:	89 45 b8             	mov    %eax,-0x48(%ebp)
		cprintf("319\n");
f011037c:	83 ec 0c             	sub    $0xc,%esp
f011037f:	68 e2 a5 12 f0       	push   $0xf012a5e2
f0110384:	e8 e3 0b ff ff       	call   f0100f6c <cprintf>
f0110389:	83 c4 10             	add    $0x10,%esp
		if (check_block(va, expectedVA, testSizes[i], 1) == 0)
f011038c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011038f:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
f0110393:	6a 01                	push   $0x1
f0110395:	50                   	push   %eax
f0110396:	ff 75 b8             	pushl  -0x48(%ebp)
f0110399:	ff 75 c8             	pushl  -0x38(%ebp)
f011039c:	e8 e4 f7 ff ff       	call   f010fb85 <check_block>
f01103a1:	83 c4 10             	add    $0x10,%esp
f01103a4:	85 c0                	test   %eax,%eax
f01103a6:	75 07                	jne    f01103af <test_alloc_block_FF+0x29b>
		{
			is_correct = 0;
f01103a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		cprintf("324\n");
f01103af:	83 ec 0c             	sub    $0xc,%esp
f01103b2:	68 e7 a5 12 f0       	push   $0xf012a5e7
f01103b7:	e8 b0 0b ff ff       	call   f0100f6c <cprintf>
f01103bc:	83 c4 10             	add    $0x10,%esp
		*(tstStartVAs[i]) = 353;
f01103bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01103c2:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f01103c6:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstMidVAs[i]) = 353;
f01103cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01103ce:	8b 84 85 78 ff ff ff 	mov    -0x88(%ebp,%eax,4),%eax
f01103d5:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstEndVAs[i]) = 353;
f01103da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01103dd:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f01103e4:	66 c7 00 61 01       	movw   $0x161,(%eax)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
	short* tstStartVAs[numOfFFTests+2] ;
	short* tstMidVAs[numOfFFTests+2] ;
	short* tstEndVAs[numOfFFTests+2] ;
	for (int i = 0; i < numOfFFTests; ++i)
f01103e9:	ff 45 d0             	incl   -0x30(%ebp)
f01103ec:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
f01103f0:	0f 8e ee fe ff ff    	jle    f01102e4 <test_alloc_block_FF+0x1d0>
		cprintf("324\n");
		*(tstStartVAs[i]) = 353;
		*(tstMidVAs[i]) = 353;
		*(tstEndVAs[i]) = 353;
	}
	if (is_correct) is_correct = check_list_size(numOfAllocs);
f01103f6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01103fa:	74 10                	je     f011040c <test_alloc_block_FF+0x2f8>
f01103fc:	83 ec 0c             	sub    $0xc,%esp
f01103ff:	6a 07                	push   $0x7
f0110401:	e8 07 f8 ff ff       	call   f010fc0d <check_list_size>
f0110406:	83 c4 10             	add    $0x10,%esp
f0110409:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f011040c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110410:	74 04                	je     f0110416 <test_alloc_block_FF+0x302>
	{
		eval += 15;
f0110412:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f0110416:	83 ec 0c             	sub    $0xc,%esp
f0110419:	68 44 a3 12 f0       	push   $0xf012a344
f011041e:	e8 49 0b ff ff       	call   f0100f6c <cprintf>
f0110423:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110426:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = 2*kilo - sizeOfMetaData;
f011042d:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	va = tstStartVAs[numOfFFTests] = alloc_block(actualSize, DA_FF);
f0110434:	83 ec 08             	sub    $0x8,%esp
f0110437:	6a 01                	push   $0x1
f0110439:	ff 75 c4             	pushl  -0x3c(%ebp)
f011043c:	e8 36 2c 01 00       	call   f0123077 <alloc_block>
f0110441:	83 c4 10             	add    $0x10,%esp
f0110444:	89 45 98             	mov    %eax,-0x68(%ebp)
f0110447:	8b 45 98             	mov    -0x68(%ebp),%eax
f011044a:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfFFTests] = va + actualSize/2 ;
f011044d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110450:	d1 e8                	shr    %eax
f0110452:	89 c2                	mov    %eax,%edx
f0110454:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110457:	01 d0                	add    %edx,%eax
f0110459:	89 45 84             	mov    %eax,-0x7c(%ebp)
	tstEndVAs[numOfFFTests] = va + actualSize - sizeof(short);
f011045c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011045f:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110462:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110465:	01 d0                	add    %edx,%eax
f0110467:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
	//Check block
	expectedVA = (void*)(startVA + testSizes[0] + testSizes[2] + sizeOfMetaData/2) ;
f011046d:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0110470:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110473:	01 c2                	add    %eax,%edx
f0110475:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110478:	01 d0                	add    %edx,%eax
f011047a:	83 c0 04             	add    $0x4,%eax
f011047d:	89 45 b8             	mov    %eax,-0x48(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, 2*kilo, 1);
f0110480:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110484:	74 18                	je     f011049e <test_alloc_block_FF+0x38a>
f0110486:	6a 01                	push   $0x1
f0110488:	68 00 08 00 00       	push   $0x800
f011048d:	ff 75 b8             	pushl  -0x48(%ebp)
f0110490:	ff 75 c8             	pushl  -0x38(%ebp)
f0110493:	e8 ed f6 ff ff       	call   f010fb85 <check_block>
f0110498:	83 c4 10             	add    $0x10,%esp
f011049b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs - 1);
f011049e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01104a2:	74 10                	je     f01104b4 <test_alloc_block_FF+0x3a0>
f01104a4:	83 ec 0c             	sub    $0xc,%esp
f01104a7:	6a 06                	push   $0x6
f01104a9:	e8 5f f7 ff ff       	call   f010fc0d <check_list_size>
f01104ae:	83 c4 10             	add    $0x10,%esp
f01104b1:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfFFTests]) = 353 ;
f01104b4:	8b 45 98             	mov    -0x68(%ebp),%eax
f01104b7:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfFFTests]) = 353 ;
f01104bc:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01104bf:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfFFTests]) = 353 ;
f01104c4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01104ca:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f01104cf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01104d3:	74 04                	je     f01104d9 <test_alloc_block_FF+0x3c5>
	{
		eval += 10;
f01104d5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 4: Try to allocate a block with a bit smaller size [internal fragmentation case]*/
	cprintf("	4: Try to allocate a block with a bit smaller size [internal fragmentation case]\n\n") ;
f01104d9:	83 ec 0c             	sub    $0xc,%esp
f01104dc:	68 ec a5 12 f0       	push   $0xf012a5ec
f01104e1:	e8 86 0a ff ff       	call   f0100f6c <cprintf>
f01104e6:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01104e9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = allocSizes[1] - sizeOfMetaData - 10;
f01104f0:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f01104f5:	83 e8 12             	sub    $0x12,%eax
f01104f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = tstStartVAs[numOfFFTests+1] = alloc_block(actualSize, DA_FF);
f01104fb:	83 ec 08             	sub    $0x8,%esp
f01104fe:	6a 01                	push   $0x1
f0110500:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110503:	e8 6f 2b 01 00       	call   f0123077 <alloc_block>
f0110508:	83 c4 10             	add    $0x10,%esp
f011050b:	89 45 9c             	mov    %eax,-0x64(%ebp)
f011050e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110511:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfFFTests+1] = va + actualSize/2 ;
f0110514:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110517:	d1 e8                	shr    %eax
f0110519:	89 c2                	mov    %eax,%edx
f011051b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011051e:	01 d0                	add    %edx,%eax
f0110520:	89 45 88             	mov    %eax,-0x78(%ebp)
	tstEndVAs[numOfFFTests+1] = va + actualSize - sizeof(short);
f0110523:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110526:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110529:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011052c:	01 d0                	add    %edx,%eax
f011052e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
	//Check block
	expectedVA = startVAs[1*allocCntPerSize];
f0110534:	a1 a0 23 5c f0       	mov    0xf05c23a0,%eax
f0110539:	89 45 b8             	mov    %eax,-0x48(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, allocSizes[1], 1);
f011053c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110540:	74 19                	je     f011055b <test_alloc_block_FF+0x447>
f0110542:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f0110547:	6a 01                	push   $0x1
f0110549:	50                   	push   %eax
f011054a:	ff 75 b8             	pushl  -0x48(%ebp)
f011054d:	ff 75 c8             	pushl  -0x38(%ebp)
f0110550:	e8 30 f6 ff ff       	call   f010fb85 <check_block>
f0110555:	83 c4 10             	add    $0x10,%esp
f0110558:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs - 2);
f011055b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011055f:	74 10                	je     f0110571 <test_alloc_block_FF+0x45d>
f0110561:	83 ec 0c             	sub    $0xc,%esp
f0110564:	6a 05                	push   $0x5
f0110566:	e8 a2 f6 ff ff       	call   f010fc0d <check_list_size>
f011056b:	83 c4 10             	add    $0x10,%esp
f011056e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfFFTests+1]) = 353 ;
f0110571:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110574:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfFFTests+1]) = 353 ;
f0110579:	8b 45 88             	mov    -0x78(%ebp),%eax
f011057c:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfFFTests+1]) = 353 ;
f0110581:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0110587:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f011058c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110590:	74 04                	je     f0110596 <test_alloc_block_FF+0x482>
	{
		eval += 10;
f0110592:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
f0110596:	83 ec 0c             	sub    $0xc,%esp
f0110599:	68 40 a6 12 f0       	push   $0xf012a640
f011059e:	e8 c9 09 ff ff       	call   f0100f6c <cprintf>
f01105a3:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01105a6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	for (int i = 0; i < numOfFFTests + 2; ++i)
f01105ad:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01105b4:	e9 88 00 00 00       	jmp    f0110641 <test_alloc_block_FF+0x52d>
	{
		//cprintf("startVA = %x, mid = %x, last = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
		if (*(tstStartVAs[i]) != 353 || *(tstMidVAs[i]) != 353 || *(tstEndVAs[i]) != 353)
f01105b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01105bc:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f01105c0:	66 8b 00             	mov    (%eax),%ax
f01105c3:	66 3d 61 01          	cmp    $0x161,%ax
f01105c7:	75 26                	jne    f01105ef <test_alloc_block_FF+0x4db>
f01105c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01105cc:	8b 84 85 78 ff ff ff 	mov    -0x88(%ebp,%eax,4),%eax
f01105d3:	66 8b 00             	mov    (%eax),%ax
f01105d6:	66 3d 61 01          	cmp    $0x161,%ax
f01105da:	75 13                	jne    f01105ef <test_alloc_block_FF+0x4db>
f01105dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01105df:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f01105e6:	66 8b 00             	mov    (%eax),%ax
f01105e9:	66 3d 61 01          	cmp    $0x161,%ax
f01105ed:	74 4f                	je     f011063e <test_alloc_block_FF+0x52a>
		{
			is_correct = 0;
f01105ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
f01105f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01105f9:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f0110600:	66 8b 00             	mov    (%eax),%ax
f0110603:	0f bf c8             	movswl %ax,%ecx
f0110606:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110609:	8b 84 85 78 ff ff ff 	mov    -0x88(%ebp,%eax,4),%eax
f0110610:	66 8b 00             	mov    (%eax),%ax
f0110613:	0f bf d0             	movswl %ax,%edx
f0110616:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110619:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f011061d:	66 8b 00             	mov    (%eax),%ax
f0110620:	98                   	cwtl   
f0110621:	83 ec 08             	sub    $0x8,%esp
f0110624:	51                   	push   %ecx
f0110625:	52                   	push   %edx
f0110626:	50                   	push   %eax
f0110627:	68 61 01 00 00       	push   $0x161
f011062c:	ff 75 cc             	pushl  -0x34(%ebp)
f011062f:	68 74 a6 12 f0       	push   $0xf012a674
f0110634:	e8 33 09 ff ff       	call   f0100f6c <cprintf>
f0110639:	83 c4 20             	add    $0x20,%esp
			break;
f011063c:	eb 0d                	jmp    f011064b <test_alloc_block_FF+0x537>
	//====================================================================//
	/*FF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < numOfFFTests + 2; ++i)
f011063e:	ff 45 cc             	incl   -0x34(%ebp)
f0110641:	83 7d cc 04          	cmpl   $0x4,-0x34(%ebp)
f0110645:	0f 8e 6e ff ff ff    	jle    f01105b9 <test_alloc_block_FF+0x4a5>
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
			break;
		}
	}

	if (is_correct)
f011064b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011064f:	74 04                	je     f0110655 <test_alloc_block_FF+0x541>
	{
		eval += 10;
f0110651:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
f0110655:	83 ec 08             	sub    $0x8,%esp
f0110658:	ff 75 e4             	pushl  -0x1c(%ebp)
f011065b:	68 e0 a6 12 f0       	push   $0xf012a6e0
f0110660:	e8 07 09 ff ff       	call   f0100f6c <cprintf>
f0110665:	83 c4 10             	add    $0x10,%esp
}
f0110668:	90                   	nop
f0110669:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011066c:	5b                   	pop    %ebx
f011066d:	5e                   	pop    %esi
f011066e:	5f                   	pop    %edi
f011066f:	5d                   	pop    %ebp
f0110670:	c3                   	ret    

f0110671 <test_alloc_block_BF>:

void test_alloc_block_BF()
{
f0110671:	55                   	push   %ebp
f0110672:	89 e5                	mov    %esp,%ebp
f0110674:	57                   	push   %edi
f0110675:	56                   	push   %esi
f0110676:	53                   	push   %ebx
f0110677:	81 ec bc 00 00 00    	sub    $0xbc,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	int eval = 0;
f011067d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_correct;
	void* va = NULL;
f0110684:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 actualSize = 0;
f011068b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)

	cprintf("=======================================================\n") ;
f0110692:	83 ec 0c             	sub    $0xc,%esp
f0110695:	68 14 a4 12 f0       	push   $0xf012a414
f011069a:	e8 cd 08 ff ff       	call   f0100f6c <cprintf>
f011069f:	83 c4 10             	add    $0x10,%esp
	cprintf("FIRST: Tests depend on the Allocate Function ONLY [40%]\n") ;
f01106a2:	83 ec 0c             	sub    $0xc,%esp
f01106a5:	68 50 a4 12 f0       	push   $0xf012a450
f01106aa:	e8 bd 08 ff ff       	call   f0100f6c <cprintf>
f01106af:	83 c4 10             	add    $0x10,%esp
	cprintf("=======================================================\n") ;
f01106b2:	83 ec 0c             	sub    $0xc,%esp
f01106b5:	68 14 a4 12 f0       	push   $0xf012a414
f01106ba:	e8 ad 08 ff ff       	call   f0100f6c <cprintf>
f01106bf:	83 c4 10             	add    $0x10,%esp
	eval = test_initial_alloc(DA_BF);
f01106c2:	83 ec 0c             	sub    $0xc,%esp
f01106c5:	6a 03                	push   $0x3
f01106c7:	e8 5b f6 ff ff       	call   f010fd27 <test_initial_alloc>
f01106cc:	83 c4 10             	add    $0x10,%esp
f01106cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cprintf("====================================================\n") ;
f01106d2:	83 ec 0c             	sub    $0xc,%esp
f01106d5:	68 8c a4 12 f0       	push   $0xf012a48c
f01106da:	e8 8d 08 ff ff       	call   f0100f6c <cprintf>
f01106df:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
f01106e2:	83 ec 0c             	sub    $0xc,%esp
f01106e5:	68 c4 a4 12 f0       	push   $0xf012a4c4
f01106ea:	e8 7d 08 ff ff       	call   f0100f6c <cprintf>
f01106ef:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
f01106f2:	83 ec 0c             	sub    $0xc,%esp
f01106f5:	68 8c a4 12 f0       	push   $0xf012a48c
f01106fa:	e8 6d 08 ff ff       	call   f0100f6c <cprintf>
f01106ff:	83 c4 10             	add    $0x10,%esp
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110702:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0110709:	eb 2c                	jmp    f0110737 <test_alloc_block_BF+0xc6>
	{
		free_block(startVAs[i*allocCntPerSize]);
f011070b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011070e:	89 d0                	mov    %edx,%eax
f0110710:	c1 e0 02             	shl    $0x2,%eax
f0110713:	01 d0                	add    %edx,%eax
f0110715:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011071c:	01 d0                	add    %edx,%eax
f011071e:	c1 e0 03             	shl    $0x3,%eax
f0110721:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0110728:	83 ec 0c             	sub    $0xc,%esp
f011072b:	50                   	push   %eax
f011072c:	e8 5e 34 01 00       	call   f0123b8f <free_block>
f0110731:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
	cprintf("====================================================\n") ;
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110734:	ff 45 dc             	incl   -0x24(%ebp)
f0110737:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f011073b:	7e ce                	jle    f011070b <test_alloc_block_BF+0x9a>
	{
		free_block(startVAs[i*allocCntPerSize]);
	}
	//Check number of freed blocks
	is_correct = check_list_size(numOfAllocs);
f011073d:	83 ec 0c             	sub    $0xc,%esp
f0110740:	6a 07                	push   $0x7
f0110742:	e8 c6 f4 ff ff       	call   f010fc0d <check_list_size>
f0110747:	83 c4 10             	add    $0x10,%esp
f011074a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f011074d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110751:	74 04                	je     f0110757 <test_alloc_block_BF+0xe6>
	{
		eval += 10;
f0110753:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f0110757:	83 ec 0c             	sub    $0xc,%esp
f011075a:	68 e0 a1 12 f0       	push   $0xf012a1e0
f011075f:	e8 08 08 ff ff       	call   f0100f6c <cprintf>
f0110764:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110767:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	uint32 maxSize = 0 ;
f011076e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f0110775:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011077c:	eb 1f                	jmp    f011079d <test_alloc_block_BF+0x12c>
	{
		if (allocSizes[i] > maxSize)
f011077e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110781:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f0110788:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011078b:	76 0d                	jbe    f011079a <test_alloc_block_BF+0x129>
			maxSize = allocSizes[i] ;
f011078d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110790:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f0110797:	89 45 d8             	mov    %eax,-0x28(%ebp)
	/*BF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
	is_correct = 1;

	uint32 maxSize = 0 ;
	for (int i = 0; i < numOfAllocs; ++i)
f011079a:	ff 45 d4             	incl   -0x2c(%ebp)
f011079d:	83 7d d4 06          	cmpl   $0x6,-0x2c(%ebp)
f01107a1:	7e db                	jle    f011077e <test_alloc_block_BF+0x10d>
	{
		if (allocSizes[i] > maxSize)
			maxSize = allocSizes[i] ;
	}
	va = alloc_block(maxSize, DA_BF);
f01107a3:	83 ec 08             	sub    $0x8,%esp
f01107a6:	6a 03                	push   $0x3
f01107a8:	ff 75 d8             	pushl  -0x28(%ebp)
f01107ab:	e8 c7 28 01 00       	call   f0123077 <alloc_block>
f01107b0:	83 c4 10             	add    $0x10,%esp
f01107b3:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//Check returned va
	if(va != NULL)
f01107b6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01107ba:	74 17                	je     f01107d3 <test_alloc_block_BF+0x162>
	{
		is_correct = 0;
f01107bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_BF #5: WRONG BF ALLOC - alloc_block_BF find a block instead no existing free blocks with the given size.\n");
f01107c3:	83 ec 0c             	sub    $0xc,%esp
f01107c6:	68 20 a7 12 f0       	push   $0xf012a720
f01107cb:	e8 9c 07 ff ff       	call   f0100f6c <cprintf>
f01107d0:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f01107d3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01107d7:	74 04                	je     f01107dd <test_alloc_block_BF+0x16c>
	{
		eval += 5;
f01107d9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 2: Try to allocate blocks with sizes smaller than existing free blocks*/
	cprintf("	2: Try to allocate set of blocks with different sizes smaller than existing free blocks\n\n") ;
f01107dd:	83 ec 0c             	sub    $0xc,%esp
f01107e0:	68 74 a5 12 f0       	push   $0xf012a574
f01107e5:	e8 82 07 ff ff       	call   f0100f6c <cprintf>
f01107ea:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01107ed:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

#define numOfBFTests 5
	uint32 testSizes[numOfBFTests] = {
f01107f4:	8d 45 a0             	lea    -0x60(%ebp),%eax
f01107f7:	bb 7c a8 12 f0       	mov    $0xf012a87c,%ebx
f01107fc:	ba 05 00 00 00       	mov    $0x5,%edx
f0110801:	89 c7                	mov    %eax,%edi
f0110803:	89 de                	mov    %ebx,%esi
f0110805:	89 d1                	mov    %edx,%ecx
f0110807:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			/*only 1 can fit*/4*kilo + kilo/2,
			/*many can fit*/ 1*kilo + kilo/4,
			/*many can fit*/kilo/2,
			/*many can fit*/kilo/2,
			/*only 1 can fit (@head)*/3*kilo } ;
	uint32 startOf1st1KB = (uint32)startVAs[2*allocCntPerSize];
f0110809:	a1 c0 26 5c f0       	mov    0xf05c26c0,%eax
f011080e:	89 45 c0             	mov    %eax,-0x40(%ebp)
	uint32 startOf1st2KB = (uint32)startVAs[4*allocCntPerSize];
f0110811:	a1 00 2d 5c f0       	mov    0xf05c2d00,%eax
f0110816:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
f0110819:	a1 40 33 5c f0       	mov    0xf05c3340,%eax
f011081e:	89 45 b8             	mov    %eax,-0x48(%ebp)

	uint32 expectedVAs[numOfBFTests] = {startOf1st7KB, startOf1st2KB, startOf1st2KB + testSizes[1],startOf1st1KB, KERNEL_HEAP_START + 2*sizeof(int)};
f0110821:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0110824:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0110827:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011082a:	89 45 90             	mov    %eax,-0x70(%ebp)
f011082d:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0110830:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110833:	01 d0                	add    %edx,%eax
f0110835:	89 45 94             	mov    %eax,-0x6c(%ebp)
f0110838:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011083b:	89 45 98             	mov    %eax,-0x68(%ebp)
f011083e:	c7 45 9c 08 00 00 f6 	movl   $0xf6000008,-0x64(%ebp)
	short* tstStartVAs[numOfBFTests+2] ;
	short* tstMidVAs[numOfBFTests+2] ;
	short* tstEndVAs[numOfBFTests+2] ;
	for (int i = 0; i < numOfBFTests; ++i)
f0110845:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f011084c:	e9 d1 00 00 00       	jmp    f0110922 <test_alloc_block_BF+0x2b1>
	{
		actualSize = testSizes[i] - sizeOfMetaData;
f0110851:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110854:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f0110858:	83 e8 08             	sub    $0x8,%eax
f011085b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		va = tstStartVAs[i] = alloc_block(actualSize, DA_BF);
f011085e:	83 ec 08             	sub    $0x8,%esp
f0110861:	6a 03                	push   $0x3
f0110863:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110866:	e8 0c 28 01 00       	call   f0123077 <alloc_block>
f011086b:	83 c4 10             	add    $0x10,%esp
f011086e:	89 c2                	mov    %eax,%edx
f0110870:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110873:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
f011087a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011087d:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f0110884:	89 45 c8             	mov    %eax,-0x38(%ebp)
		tstMidVAs[i] = va + actualSize/2 ;
f0110887:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011088a:	d1 e8                	shr    %eax
f011088c:	89 c2                	mov    %eax,%edx
f011088e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110891:	01 c2                	add    %eax,%edx
f0110893:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110896:	89 94 85 54 ff ff ff 	mov    %edx,-0xac(%ebp,%eax,4)
		tstEndVAs[i] = va + actualSize - sizeof(short);
f011089d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01108a0:	8d 50 fe             	lea    -0x2(%eax),%edx
f01108a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01108a6:	01 c2                	add    %eax,%edx
f01108a8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01108ab:	89 94 85 38 ff ff ff 	mov    %edx,-0xc8(%ebp,%eax,4)

		//Check block
		cprintf("test#%d\n",i);
f01108b2:	83 ec 08             	sub    $0x8,%esp
f01108b5:	ff 75 d0             	pushl  -0x30(%ebp)
f01108b8:	68 d9 a5 12 f0       	push   $0xf012a5d9
f01108bd:	e8 aa 06 ff ff       	call   f0100f6c <cprintf>
f01108c2:	83 c4 10             	add    $0x10,%esp
		expectedVA = (void*)expectedVAs[i];
f01108c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01108c8:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f01108cc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if (check_block(va, expectedVA, testSizes[i], 1) == 0)
f01108cf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01108d2:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f01108d6:	6a 01                	push   $0x1
f01108d8:	50                   	push   %eax
f01108d9:	ff 75 b4             	pushl  -0x4c(%ebp)
f01108dc:	ff 75 c8             	pushl  -0x38(%ebp)
f01108df:	e8 a1 f2 ff ff       	call   f010fb85 <check_block>
f01108e4:	83 c4 10             	add    $0x10,%esp
f01108e7:	85 c0                	test   %eax,%eax
f01108e9:	75 07                	jne    f01108f2 <test_alloc_block_BF+0x281>
		{
			is_correct = 0;
f01108eb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		*(tstStartVAs[i]) = 353;
f01108f2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01108f5:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f01108fc:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstMidVAs[i]) = 353;
f0110901:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110904:	8b 84 85 54 ff ff ff 	mov    -0xac(%ebp,%eax,4),%eax
f011090b:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstEndVAs[i]) = 353;
f0110910:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110913:	8b 84 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%eax
f011091a:	66 c7 00 61 01       	movw   $0x161,(%eax)

	uint32 expectedVAs[numOfBFTests] = {startOf1st7KB, startOf1st2KB, startOf1st2KB + testSizes[1],startOf1st1KB, KERNEL_HEAP_START + 2*sizeof(int)};
	short* tstStartVAs[numOfBFTests+2] ;
	short* tstMidVAs[numOfBFTests+2] ;
	short* tstEndVAs[numOfBFTests+2] ;
	for (int i = 0; i < numOfBFTests; ++i)
f011091f:	ff 45 d0             	incl   -0x30(%ebp)
f0110922:	83 7d d0 04          	cmpl   $0x4,-0x30(%ebp)
f0110926:	0f 8e 25 ff ff ff    	jle    f0110851 <test_alloc_block_BF+0x1e0>
		*(tstStartVAs[i]) = 353;
		*(tstMidVAs[i]) = 353;
		*(tstEndVAs[i]) = 353;
	}

	if (is_correct) is_correct = check_list_size(numOfAllocs);
f011092c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110930:	74 10                	je     f0110942 <test_alloc_block_BF+0x2d1>
f0110932:	83 ec 0c             	sub    $0xc,%esp
f0110935:	6a 07                	push   $0x7
f0110937:	e8 d1 f2 ff ff       	call   f010fc0d <check_list_size>
f011093c:	83 c4 10             	add    $0x10,%esp
f011093f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f0110942:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110946:	74 04                	je     f011094c <test_alloc_block_BF+0x2db>
	{
		eval += 15;
f0110948:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 3: Try to allocate a block with a size equal to the size of an existing free block*/
	cprintf("	3: Try to allocate a block with equal to an existing free block\n\n") ;
f011094c:	83 ec 0c             	sub    $0xc,%esp
f011094f:	68 98 a7 12 f0       	push   $0xf012a798
f0110954:	e8 13 06 ff ff       	call   f0100f6c <cprintf>
f0110959:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011095c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = kilo/4 - sizeOfMetaData;
f0110963:	c7 45 c4 f8 00 00 00 	movl   $0xf8,-0x3c(%ebp)
	va = tstStartVAs[numOfBFTests] = alloc_block(actualSize, DA_BF);
f011096a:	83 ec 08             	sub    $0x8,%esp
f011096d:	6a 03                	push   $0x3
f011096f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110972:	e8 00 27 01 00       	call   f0123077 <alloc_block>
f0110977:	83 c4 10             	add    $0x10,%esp
f011097a:	89 45 84             	mov    %eax,-0x7c(%ebp)
f011097d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0110980:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfBFTests] = va + actualSize/2 ;
f0110983:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110986:	d1 e8                	shr    %eax
f0110988:	89 c2                	mov    %eax,%edx
f011098a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011098d:	01 d0                	add    %edx,%eax
f011098f:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
	tstEndVAs[numOfBFTests] = va + actualSize - sizeof(short);
f0110995:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110998:	8d 50 fe             	lea    -0x2(%eax),%edx
f011099b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011099e:	01 d0                	add    %edx,%eax
f01109a0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
	//Check returned va
	expectedVA = (void*)(startOf1st2KB + testSizes[1] + testSizes[3]) ;
f01109a6:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f01109a9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01109ac:	01 c2                	add    %eax,%edx
f01109ae:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01109b1:	01 d0                	add    %edx,%eax
f01109b3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (is_correct) is_correct = check_block(va, expectedVA, kilo/4, 1);
f01109b6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01109ba:	74 18                	je     f01109d4 <test_alloc_block_BF+0x363>
f01109bc:	6a 01                	push   $0x1
f01109be:	68 00 01 00 00       	push   $0x100
f01109c3:	ff 75 b4             	pushl  -0x4c(%ebp)
f01109c6:	ff 75 c8             	pushl  -0x38(%ebp)
f01109c9:	e8 b7 f1 ff ff       	call   f010fb85 <check_block>
f01109ce:	83 c4 10             	add    $0x10,%esp
f01109d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs-1);
f01109d4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01109d8:	74 10                	je     f01109ea <test_alloc_block_BF+0x379>
f01109da:	83 ec 0c             	sub    $0xc,%esp
f01109dd:	6a 06                	push   $0x6
f01109df:	e8 29 f2 ff ff       	call   f010fc0d <check_list_size>
f01109e4:	83 c4 10             	add    $0x10,%esp
f01109e7:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfBFTests]) = 353 ;
f01109ea:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01109ed:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfBFTests]) = 353 ;
f01109f2:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f01109f8:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfBFTests]) = 353 ;
f01109fd:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0110a03:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f0110a08:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110a0c:	74 04                	je     f0110a12 <test_alloc_block_BF+0x3a1>
	{
		eval += 10;
f0110a0e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 4: Try to allocate a block with a bit smaller size [internal fragmentation case]*/
	cprintf("	4: Try to allocate a block with a bit smaller size [internal fragmentation case]\n\n") ;
f0110a12:	83 ec 0c             	sub    $0xc,%esp
f0110a15:	68 ec a5 12 f0       	push   $0xf012a5ec
f0110a1a:	e8 4d 05 ff ff       	call   f0100f6c <cprintf>
f0110a1f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110a22:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = allocSizes[5] - sizeOfMetaData - 2;
f0110a29:	a1 cc fd 17 f0       	mov    0xf017fdcc,%eax
f0110a2e:	83 e8 0a             	sub    $0xa,%eax
f0110a31:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = tstStartVAs[numOfBFTests+1] = alloc_block(actualSize, DA_BF);
f0110a34:	83 ec 08             	sub    $0x8,%esp
f0110a37:	6a 03                	push   $0x3
f0110a39:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110a3c:	e8 36 26 01 00       	call   f0123077 <alloc_block>
f0110a41:	83 c4 10             	add    $0x10,%esp
f0110a44:	89 45 88             	mov    %eax,-0x78(%ebp)
f0110a47:	8b 45 88             	mov    -0x78(%ebp),%eax
f0110a4a:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfBFTests+1] = va + 2 ;
f0110a4d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110a50:	83 c0 02             	add    $0x2,%eax
f0110a53:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
	tstEndVAs[numOfBFTests+1] = va + actualSize - sizeof(short);
f0110a59:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110a5c:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110a5f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110a62:	01 d0                	add    %edx,%eax
f0110a64:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
	//Check block
	expectedVA = startVAs[5*allocCntPerSize];
f0110a6a:	a1 20 30 5c f0       	mov    0xf05c3020,%eax
f0110a6f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, allocSizes[5], 1);
f0110a72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110a76:	74 19                	je     f0110a91 <test_alloc_block_BF+0x420>
f0110a78:	a1 cc fd 17 f0       	mov    0xf017fdcc,%eax
f0110a7d:	6a 01                	push   $0x1
f0110a7f:	50                   	push   %eax
f0110a80:	ff 75 b4             	pushl  -0x4c(%ebp)
f0110a83:	ff 75 c8             	pushl  -0x38(%ebp)
f0110a86:	e8 fa f0 ff ff       	call   f010fb85 <check_block>
f0110a8b:	83 c4 10             	add    $0x10,%esp
f0110a8e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs - 2);
f0110a91:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110a95:	74 10                	je     f0110aa7 <test_alloc_block_BF+0x436>
f0110a97:	83 ec 0c             	sub    $0xc,%esp
f0110a9a:	6a 05                	push   $0x5
f0110a9c:	e8 6c f1 ff ff       	call   f010fc0d <check_list_size>
f0110aa1:	83 c4 10             	add    $0x10,%esp
f0110aa4:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfBFTests+1]) = 353 ;
f0110aa7:	8b 45 88             	mov    -0x78(%ebp),%eax
f0110aaa:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfBFTests+1]) = 353 ;
f0110aaf:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0110ab5:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfBFTests+1]) = 353 ;
f0110aba:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0110ac0:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f0110ac5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110ac9:	74 04                	je     f0110acf <test_alloc_block_BF+0x45e>
	{
		eval += 10;
f0110acb:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
f0110acf:	83 ec 0c             	sub    $0xc,%esp
f0110ad2:	68 40 a6 12 f0       	push   $0xf012a640
f0110ad7:	e8 90 04 ff ff       	call   f0100f6c <cprintf>
f0110adc:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110adf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	for (int i = 0; i < numOfBFTests+2; ++i)
f0110ae6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0110aed:	e9 8e 00 00 00       	jmp    f0110b80 <test_alloc_block_BF+0x50f>
	{
		//cprintf("startVA = %x, mid = %x, last = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
		if (*(tstStartVAs[i]) != 353 || *(tstMidVAs[i]) != 353 || *(tstEndVAs[i]) != 353)
f0110af2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110af5:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f0110afc:	66 8b 00             	mov    (%eax),%ax
f0110aff:	66 3d 61 01          	cmp    $0x161,%ax
f0110b03:	75 26                	jne    f0110b2b <test_alloc_block_BF+0x4ba>
f0110b05:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b08:	8b 84 85 54 ff ff ff 	mov    -0xac(%ebp,%eax,4),%eax
f0110b0f:	66 8b 00             	mov    (%eax),%ax
f0110b12:	66 3d 61 01          	cmp    $0x161,%ax
f0110b16:	75 13                	jne    f0110b2b <test_alloc_block_BF+0x4ba>
f0110b18:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b1b:	8b 84 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%eax
f0110b22:	66 8b 00             	mov    (%eax),%ax
f0110b25:	66 3d 61 01          	cmp    $0x161,%ax
f0110b29:	74 52                	je     f0110b7d <test_alloc_block_BF+0x50c>
		{
			//cprintf("start VA = %x, mid VA = %x, end VA = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
			is_correct = 0;
f0110b2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_BF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
f0110b32:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b35:	8b 84 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%eax
f0110b3c:	66 8b 00             	mov    (%eax),%ax
f0110b3f:	0f bf c8             	movswl %ax,%ecx
f0110b42:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b45:	8b 84 85 54 ff ff ff 	mov    -0xac(%ebp,%eax,4),%eax
f0110b4c:	66 8b 00             	mov    (%eax),%ax
f0110b4f:	0f bf d0             	movswl %ax,%edx
f0110b52:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b55:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f0110b5c:	66 8b 00             	mov    (%eax),%ax
f0110b5f:	98                   	cwtl   
f0110b60:	83 ec 08             	sub    $0x8,%esp
f0110b63:	51                   	push   %ecx
f0110b64:	52                   	push   %edx
f0110b65:	50                   	push   %eax
f0110b66:	68 61 01 00 00       	push   $0x161
f0110b6b:	ff 75 cc             	pushl  -0x34(%ebp)
f0110b6e:	68 dc a7 12 f0       	push   $0xf012a7dc
f0110b73:	e8 f4 03 ff ff       	call   f0100f6c <cprintf>
f0110b78:	83 c4 20             	add    $0x20,%esp
			break;
f0110b7b:	eb 0d                	jmp    f0110b8a <test_alloc_block_BF+0x519>
	//====================================================================//
	/*BF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < numOfBFTests+2; ++i)
f0110b7d:	ff 45 cc             	incl   -0x34(%ebp)
f0110b80:	83 7d cc 06          	cmpl   $0x6,-0x34(%ebp)
f0110b84:	0f 8e 68 ff ff ff    	jle    f0110af2 <test_alloc_block_BF+0x481>
			cprintf("alloc_block_BF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
			break;
		}
	}

	if (is_correct)
f0110b8a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110b8e:	74 04                	je     f0110b94 <test_alloc_block_BF+0x523>
	{
		eval += 10;
f0110b90:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
f0110b94:	83 ec 08             	sub    $0x8,%esp
f0110b97:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110b9a:	68 48 a8 12 f0       	push   $0xf012a848
f0110b9f:	e8 c8 03 ff ff       	call   f0100f6c <cprintf>
f0110ba4:	83 c4 10             	add    $0x10,%esp
}
f0110ba7:	90                   	nop
f0110ba8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0110bab:	5b                   	pop    %ebx
f0110bac:	5e                   	pop    %esi
f0110bad:	5f                   	pop    %edi
f0110bae:	5d                   	pop    %ebp
f0110baf:	c3                   	ret    

f0110bb0 <test_alloc_block_NF>:

void test_alloc_block_NF()
{
f0110bb0:	55                   	push   %ebp
f0110bb1:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0110bb3:	90                   	nop
f0110bb4:	5d                   	pop    %ebp
f0110bb5:	c3                   	ret    

f0110bb6 <test_free_block_FF>:

void test_free_block_FF()
{
f0110bb6:	55                   	push   %ebp
f0110bb7:	89 e5                	mov    %esp,%ebp
f0110bb9:	53                   	push   %ebx
f0110bba:	81 ec 94 00 00 00    	sub    $0x94,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f0110bc0:	83 ec 0c             	sub    $0xc,%esp
f0110bc3:	68 90 a8 12 f0       	push   $0xf012a890
f0110bc8:	e8 9f 03 ff ff       	call   f0100f6c <cprintf>
f0110bcd:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f0110bd0:	83 ec 0c             	sub    $0xc,%esp
f0110bd3:	68 d0 a8 12 f0       	push   $0xf012a8d0
f0110bd8:	e8 8f 03 ff ff       	call   f0100f6c <cprintf>
f0110bdd:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0110be0:	83 ec 0c             	sub    $0xc,%esp
f0110be3:	68 90 a8 12 f0       	push   $0xf012a890
f0110be8:	e8 7f 03 ff ff       	call   f0100f6c <cprintf>
f0110bed:	83 c4 10             	add    $0x10,%esp
	void*expected_va ;

	int eval = 0;
f0110bf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct;
	int initAllocatedSpace = 3*Mega;
f0110bf7:	c7 45 cc 00 00 30 00 	movl   $0x300000,-0x34(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f0110bfe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c01:	83 ec 08             	sub    $0x8,%esp
f0110c04:	50                   	push   %eax
f0110c05:	68 00 00 00 f6       	push   $0xf6000000
f0110c0a:	e8 95 25 01 00       	call   f01231a4 <initialize_dynamic_allocator>
f0110c0f:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;
f0110c12:	83 ec 0c             	sub    $0xc,%esp
f0110c15:	68 10 a9 12 f0       	push   $0xf012a910
f0110c1a:	e8 4d 03 ff ff       	call   f0100f6c <cprintf>
f0110c1f:	83 c4 10             	add    $0x10,%esp

	int totalSizes = 0;
f0110c22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f0110c29:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110c30:	eb 2a                	jmp    f0110c5c <test_free_block_FF+0xa6>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f0110c32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110c35:	8b 14 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%edx
f0110c3c:	89 d0                	mov    %edx,%eax
f0110c3e:	c1 e0 02             	shl    $0x2,%eax
f0110c41:	01 d0                	add    %edx,%eax
f0110c43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110c4a:	01 d0                	add    %edx,%eax
f0110c4c:	c1 e0 03             	shl    $0x3,%eax
f0110c4f:	89 c2                	mov    %eax,%edx
f0110c51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110c54:	01 d0                	add    %edx,%eax
f0110c56:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f0110c59:	ff 45 e8             	incl   -0x18(%ebp)
f0110c5c:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f0110c60:	7e d0                	jle    f0110c32 <test_free_block_FF+0x7c>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f0110c62:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c65:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0110c68:	83 e8 08             	sub    $0x8,%eax
f0110c6b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	if (remainSize <= 0)
f0110c6e:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0110c72:	7f 17                	jg     f0110c8b <test_free_block_FF+0xd5>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f0110c74:	83 ec 04             	sub    $0x4,%esp
f0110c77:	68 68 a9 12 f0       	push   $0xf012a968
f0110c7c:	68 76 02 00 00       	push   $0x276
f0110c81:	68 48 a1 12 f0       	push   $0xf012a148
f0110c86:	e8 8f f6 fe ff       	call   f010031a <_panic>

	int idx = 0;
f0110c8b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f0110c92:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f0110c99:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0110ca0:	e9 0b 01 00 00       	jmp    f0110db0 <test_free_block_FF+0x1fa>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0110ca5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110cac:	e9 ef 00 00 00       	jmp    f0110da0 <test_free_block_FF+0x1ea>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f0110cb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110cb4:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f0110cbb:	83 e8 08             	sub    $0x8,%eax
f0110cbe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f0110cc1:	83 ec 08             	sub    $0x8,%esp
f0110cc4:	6a 01                	push   $0x1
f0110cc6:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110cc9:	e8 a9 23 01 00       	call   f0123077 <alloc_block>
f0110cce:	83 c4 10             	add    $0x10,%esp
f0110cd1:	89 c2                	mov    %eax,%edx
f0110cd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110cd6:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f0110cdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110ce0:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0110ce7:	89 45 c0             	mov    %eax,-0x40(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f0110cea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110ced:	d1 e8                	shr    %eax
f0110cef:	89 c2                	mov    %eax,%edx
f0110cf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110cf4:	01 c2                	add    %eax,%edx
f0110cf6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110cf9:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0110d00:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110d03:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110d06:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110d09:	01 c2                	add    %eax,%edx
f0110d0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d0e:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
			//Check returned va
			expected_va = curVA + sizeOfMetaData/2;
f0110d15:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110d18:	83 c0 04             	add    $0x4,%eax
f0110d1b:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (check_block(va, expected_va, allocSizes[i], 1) == 0)
f0110d1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110d21:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f0110d28:	6a 01                	push   $0x1
f0110d2a:	50                   	push   %eax
f0110d2b:	ff 75 bc             	pushl  -0x44(%ebp)
f0110d2e:	ff 75 c0             	pushl  -0x40(%ebp)
f0110d31:	e8 4f ee ff ff       	call   f010fb85 <check_block>
f0110d36:	83 c4 10             	add    $0x10,%esp
f0110d39:	85 c0                	test   %eax,%eax
f0110d3b:	75 20                	jne    f0110d5d <test_free_block_FF+0x1a7>
				//			if(va != (curVA + sizeOfMetaData/2))
				panic("test_free_block #1.%d: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x", idx, expected_va ,va);
f0110d3d:	83 ec 08             	sub    $0x8,%esp
f0110d40:	ff 75 c0             	pushl  -0x40(%ebp)
f0110d43:	ff 75 bc             	pushl  -0x44(%ebp)
f0110d46:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110d49:	68 e0 a9 12 f0       	push   $0xf012a9e0
f0110d4e:	68 87 02 00 00       	push   $0x287
f0110d53:	68 48 a1 12 f0       	push   $0xf012a148
f0110d58:	e8 bd f5 fe ff       	call   f010031a <_panic>
			curVA += allocSizes[i] ;
f0110d5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110d60:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f0110d67:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f0110d6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d6d:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0110d74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d77:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f0110d7a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d7d:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f0110d84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d87:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f0110d8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d8d:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f0110d94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110d97:	66 89 02             	mov    %ax,(%edx)
			idx++;
f0110d9a:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0110d9d:	ff 45 d8             	incl   -0x28(%ebp)
f0110da0:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f0110da7:	0f 8e 04 ff ff ff    	jle    f0110cb1 <test_free_block_FF+0xfb>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");

	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f0110dad:	ff 45 dc             	incl   -0x24(%ebp)
f0110db0:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f0110db4:	0f 8e eb fe ff ff    	jle    f0110ca5 <test_free_block_FF+0xef>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f0110dba:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110dbd:	83 e8 08             	sub    $0x8,%eax
f0110dc0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f0110dc3:	83 ec 08             	sub    $0x8,%esp
f0110dc6:	6a 01                	push   $0x1
f0110dc8:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110dcb:	e8 a7 22 01 00       	call   f0123077 <alloc_block>
f0110dd0:	83 c4 10             	add    $0x10,%esp
f0110dd3:	89 c2                	mov    %eax,%edx
f0110dd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110dd8:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f0110ddf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110de2:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0110de9:	89 45 c0             	mov    %eax,-0x40(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f0110dec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110def:	d1 e8                	shr    %eax
f0110df1:	89 c2                	mov    %eax,%edx
f0110df3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110df6:	01 c2                	add    %eax,%edx
f0110df8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110dfb:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f0110e02:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110e05:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110e08:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110e0b:	01 c2                	add    %eax,%edx
f0110e0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e10:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
	//Check returned va
	expected_va = curVA + sizeOfMetaData/2;
f0110e17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110e1a:	83 c0 04             	add    $0x4,%eax
f0110e1d:	89 45 bc             	mov    %eax,-0x44(%ebp)
	if (check_block(va, expected_va, remainSize, 1) == 0)
f0110e20:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110e23:	6a 01                	push   $0x1
f0110e25:	50                   	push   %eax
f0110e26:	ff 75 bc             	pushl  -0x44(%ebp)
f0110e29:	ff 75 c0             	pushl  -0x40(%ebp)
f0110e2c:	e8 54 ed ff ff       	call   f010fb85 <check_block>
f0110e31:	83 c4 10             	add    $0x10,%esp
f0110e34:	85 c0                	test   %eax,%eax
f0110e36:	75 1d                	jne    f0110e55 <test_free_block_FF+0x29f>
		//			if(va != (curVA + sizeOfMetaData/2))
		panic("test_free_block #2: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x",  expected_va ,va);
f0110e38:	83 ec 0c             	sub    $0xc,%esp
f0110e3b:	ff 75 c0             	pushl  -0x40(%ebp)
f0110e3e:	ff 75 bc             	pushl  -0x44(%ebp)
f0110e41:	68 44 aa 12 f0       	push   $0xf012aa44
f0110e46:	68 9a 02 00 00       	push   $0x29a
f0110e4b:	68 48 a1 12 f0       	push   $0xf012a148
f0110e50:	e8 c5 f4 fe ff       	call   f010031a <_panic>
	*(startVAs[idx]) = idx ;
f0110e55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e58:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0110e5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e62:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f0110e65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e68:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f0110e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e72:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f0110e75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e78:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f0110e7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110e82:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
f0110e85:	83 ec 0c             	sub    $0xc,%esp
f0110e88:	68 a4 aa 12 f0       	push   $0xf012aaa4
f0110e8d:	e8 da 00 ff ff       	call   f0100f6c <cprintf>
f0110e92:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110e95:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f0110e9c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0110ea3:	eb 5b                	jmp    f0110f00 <test_free_block_FF+0x34a>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f0110ea5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110ea8:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0110eaf:	66 8b 00             	mov    (%eax),%ax
f0110eb2:	98                   	cwtl   
f0110eb3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110eb6:	75 26                	jne    f0110ede <test_free_block_FF+0x328>
f0110eb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110ebb:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0110ec2:	66 8b 00             	mov    (%eax),%ax
f0110ec5:	98                   	cwtl   
f0110ec6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110ec9:	75 13                	jne    f0110ede <test_free_block_FF+0x328>
f0110ecb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110ece:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f0110ed5:	66 8b 00             	mov    (%eax),%ax
f0110ed8:	98                   	cwtl   
f0110ed9:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110edc:	74 1f                	je     f0110efd <test_free_block_FF+0x347>
		{
			is_correct = 0;
f0110ede:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_free_block #3.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f0110ee5:	83 ec 04             	sub    $0x4,%esp
f0110ee8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110eeb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110eee:	68 d8 aa 12 f0       	push   $0xf012aad8
f0110ef3:	e8 74 00 ff ff       	call   f0100f6c <cprintf>
f0110ef8:	83 c4 10             	add    $0x10,%esp
			break;
f0110efb:	eb 0b                	jmp    f0110f08 <test_free_block_FF+0x352>
	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f0110efd:	ff 45 d4             	incl   -0x2c(%ebp)
f0110f00:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110f03:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110f06:	7c 9d                	jl     f0110ea5 <test_free_block_FF+0x2ef>
		}
	}

	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
f0110f08:	83 ec 0c             	sub    $0xc,%esp
f0110f0b:	68 28 ab 12 f0       	push   $0xf012ab28
f0110f10:	e8 57 00 ff ff       	call   f0100f6c <cprintf>
f0110f15:	83 c4 10             	add    $0x10,%esp
	uint32 block_size, block_status, expected_size, *blk_header, *blk_footer;
	is_correct = 1;
f0110f18:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110f1f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0110f26:	e9 9b 00 00 00       	jmp    f0110fc6 <test_free_block_FF+0x410>
	{
		cprintf("test#%d\n",i);
f0110f2b:	83 ec 08             	sub    $0x8,%esp
f0110f2e:	ff 75 d0             	pushl  -0x30(%ebp)
f0110f31:	68 d9 a5 12 f0       	push   $0xf012a5d9
f0110f36:	e8 31 00 ff ff       	call   f0100f6c <cprintf>
f0110f3b:	83 c4 10             	add    $0x10,%esp
		free_block(startVAs[i*allocCntPerSize]);
f0110f3e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110f41:	89 d0                	mov    %edx,%eax
f0110f43:	c1 e0 02             	shl    $0x2,%eax
f0110f46:	01 d0                	add    %edx,%eax
f0110f48:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110f4f:	01 d0                	add    %edx,%eax
f0110f51:	c1 e0 03             	shl    $0x3,%eax
f0110f54:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0110f5b:	83 ec 0c             	sub    $0xc,%esp
f0110f5e:	50                   	push   %eax
f0110f5f:	e8 2b 2c 01 00       	call   f0123b8f <free_block>
f0110f64:	83 c4 10             	add    $0x10,%esp
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
f0110f67:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110f6a:	8b 0c 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%ecx
f0110f71:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110f74:	89 d0                	mov    %edx,%eax
f0110f76:	c1 e0 02             	shl    $0x2,%eax
f0110f79:	01 d0                	add    %edx,%eax
f0110f7b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110f82:	01 d0                	add    %edx,%eax
f0110f84:	c1 e0 03             	shl    $0x3,%eax
f0110f87:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0110f8e:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f0110f91:	89 d8                	mov    %ebx,%eax
f0110f93:	c1 e0 02             	shl    $0x2,%eax
f0110f96:	01 d8                	add    %ebx,%eax
f0110f98:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0110f9f:	01 d8                	add    %ebx,%eax
f0110fa1:	c1 e0 03             	shl    $0x3,%eax
f0110fa4:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0110fab:	6a 00                	push   $0x0
f0110fad:	51                   	push   %ecx
f0110fae:	52                   	push   %edx
f0110faf:	50                   	push   %eax
f0110fb0:	e8 d0 eb ff ff       	call   f010fb85 <check_block>
f0110fb5:	83 c4 10             	add    $0x10,%esp
f0110fb8:	85 c0                	test   %eax,%eax
f0110fba:	75 07                	jne    f0110fc3 <test_free_block_FF+0x40d>
		{
			is_correct = 0;
f0110fbc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
	uint32 block_size, block_status, expected_size, *blk_header, *blk_footer;
	is_correct = 1;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110fc3:	ff 45 d0             	incl   -0x30(%ebp)
f0110fc6:	83 7d d0 06          	cmpl   $0x6,-0x30(%ebp)
f0110fca:	0f 8e 5b ff ff ff    	jle    f0110f2b <test_free_block_FF+0x375>
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
		{
			is_correct = 0;
		}
	}
	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0110fd0:	c7 45 b8 07 00 00 00 	movl   $0x7,-0x48(%ebp)
	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0110fd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110fdb:	74 11                	je     f0110fee <test_free_block_FF+0x438>
f0110fdd:	83 ec 0c             	sub    $0xc,%esp
f0110fe0:	ff 75 b8             	pushl  -0x48(%ebp)
f0110fe3:	e8 25 ec ff ff       	call   f010fc0d <check_list_size>
f0110fe8:	83 c4 10             	add    $0x10,%esp
f0110feb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct)
f0110fee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110ff2:	74 04                	je     f0110ff8 <test_free_block_FF+0x442>
	{
		eval += 10;
f0110ff4:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	is_correct = 1;
f0110ff8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block
	free_block(startVAs[numOfAllocs*allocCntPerSize]);
f0110fff:	a1 60 36 5c f0       	mov    0xf05c3660,%eax
f0111004:	83 ec 0c             	sub    $0xc,%esp
f0111007:	50                   	push   %eax
f0111008:	e8 82 2b 01 00       	call   f0123b8f <free_block>
f011100d:	83 c4 10             	add    $0x10,%esp
	if (is_correct) is_correct = check_block(startVAs[numOfAllocs*allocCntPerSize], startVAs[numOfAllocs*allocCntPerSize], remainSize, 0);
f0111010:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111014:	74 1e                	je     f0111034 <test_free_block_FF+0x47e>
f0111016:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f0111019:	8b 15 60 36 5c f0    	mov    0xf05c3660,%edx
f011101f:	a1 60 36 5c f0       	mov    0xf05c3660,%eax
f0111024:	6a 00                	push   $0x0
f0111026:	51                   	push   %ecx
f0111027:	52                   	push   %edx
f0111028:	50                   	push   %eax
f0111029:	e8 57 eb ff ff       	call   f010fb85 <check_block>
f011102e:	83 c4 10             	add    $0x10,%esp
f0111031:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Reallocate last block
	actualSize = remainSize - sizeOfMetaData;
f0111034:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111037:	83 e8 08             	sub    $0x8,%eax
f011103a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f011103d:	83 ec 08             	sub    $0x8,%esp
f0111040:	6a 01                	push   $0x1
f0111042:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111045:	e8 2d 20 01 00       	call   f0123077 <alloc_block>
f011104a:	83 c4 10             	add    $0x10,%esp
f011104d:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check block
	expected_va = (curVA + sizeOfMetaData/2);
f0111050:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111053:	83 c0 04             	add    $0x4,%eax
f0111056:	89 45 bc             	mov    %eax,-0x44(%ebp)
	if (is_correct) is_correct = check_block(va, expected_va, remainSize, 1);
f0111059:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011105d:	74 17                	je     f0111076 <test_free_block_FF+0x4c0>
f011105f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111062:	6a 01                	push   $0x1
f0111064:	50                   	push   %eax
f0111065:	ff 75 bc             	pushl  -0x44(%ebp)
f0111068:	ff 75 c0             	pushl  -0x40(%ebp)
f011106b:	e8 15 eb ff ff       	call   f010fb85 <check_block>
f0111070:	83 c4 10             	add    $0x10,%esp
f0111073:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Free block before last
	free_block(startVAs[numOfAllocs*allocCntPerSize - 1]);
f0111076:	a1 5c 36 5c f0       	mov    0xf05c365c,%eax
f011107b:	83 ec 0c             	sub    $0xc,%esp
f011107e:	50                   	push   %eax
f011107f:	e8 0b 2b 01 00       	call   f0123b8f <free_block>
f0111084:	83 c4 10             	add    $0x10,%esp
	if (is_correct) is_correct = check_block(startVAs[numOfAllocs*allocCntPerSize-1], startVAs[numOfAllocs*allocCntPerSize-1], allocSizes[numOfAllocs-1], 0);
f0111087:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011108b:	74 21                	je     f01110ae <test_free_block_FF+0x4f8>
f011108d:	8b 0d d0 fd 17 f0    	mov    0xf017fdd0,%ecx
f0111093:	8b 15 5c 36 5c f0    	mov    0xf05c365c,%edx
f0111099:	a1 5c 36 5c f0       	mov    0xf05c365c,%eax
f011109e:	6a 00                	push   $0x0
f01110a0:	51                   	push   %ecx
f01110a1:	52                   	push   %edx
f01110a2:	50                   	push   %eax
f01110a3:	e8 dd ea ff ff       	call   f010fb85 <check_block>
f01110a8:	83 c4 10             	add    $0x10,%esp
f01110ab:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Reallocate first block
	actualSize = allocSizes[0] - sizeOfMetaData;
f01110ae:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f01110b3:	83 e8 08             	sub    $0x8,%eax
f01110b6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01110b9:	83 ec 08             	sub    $0x8,%esp
f01110bc:	6a 01                	push   $0x1
f01110be:	ff 75 c4             	pushl  -0x3c(%ebp)
f01110c1:	e8 b1 1f 01 00       	call   f0123077 <alloc_block>
f01110c6:	83 c4 10             	add    $0x10,%esp
f01110c9:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected_va = (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2);
f01110cc:	c7 45 bc 08 00 00 f6 	movl   $0xf6000008,-0x44(%ebp)
	if (is_correct) is_correct = check_block(va, expected_va, allocSizes[0], 1);
f01110d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01110d7:	74 19                	je     f01110f2 <test_free_block_FF+0x53c>
f01110d9:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f01110de:	6a 01                	push   $0x1
f01110e0:	50                   	push   %eax
f01110e1:	ff 75 bc             	pushl  -0x44(%ebp)
f01110e4:	ff 75 c0             	pushl  -0x40(%ebp)
f01110e7:	e8 99 ea ff ff       	call   f010fb85 <check_block>
f01110ec:	83 c4 10             	add    $0x10,%esp
f01110ef:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Free 2nd block
	free_block(startVAs[1]);
f01110f2:	a1 84 20 5c f0       	mov    0xf05c2084,%eax
f01110f7:	83 ec 0c             	sub    $0xc,%esp
f01110fa:	50                   	push   %eax
f01110fb:	e8 8f 2a 01 00       	call   f0123b8f <free_block>
f0111100:	83 c4 10             	add    $0x10,%esp
	if (is_correct) is_correct = check_block(startVAs[1], startVAs[1], allocSizes[0], 0);
f0111103:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111107:	74 21                	je     f011112a <test_free_block_FF+0x574>
f0111109:	8b 0d b8 fd 17 f0    	mov    0xf017fdb8,%ecx
f011110f:	8b 15 84 20 5c f0    	mov    0xf05c2084,%edx
f0111115:	a1 84 20 5c f0       	mov    0xf05c2084,%eax
f011111a:	6a 00                	push   $0x0
f011111c:	51                   	push   %ecx
f011111d:	52                   	push   %edx
f011111e:	50                   	push   %eax
f011111f:	e8 61 ea ff ff       	call   f010fb85 <check_block>
f0111124:	83 c4 10             	add    $0x10,%esp
f0111127:	89 45 f0             	mov    %eax,-0x10(%ebp)

	expectedNumOfFreeBlks++ ;
f011112a:	ff 45 b8             	incl   -0x48(%ebp)
	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f011112d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111131:	74 11                	je     f0111144 <test_free_block_FF+0x58e>
f0111133:	83 ec 0c             	sub    $0xc,%esp
f0111136:	ff 75 b8             	pushl  -0x48(%ebp)
f0111139:	e8 cf ea ff ff       	call   f010fc0d <check_list_size>
f011113e:	83 c4 10             	add    $0x10,%esp
f0111141:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct)
f0111144:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111148:	74 04                	je     f011114e <test_free_block_FF+0x598>
	{
		eval += 10;
f011114a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 2: Merge with previous ONLY (AT the tail)*/
	cprintf("	4: Free some allocated blocks [Merge with previous ONLY]\n\n") ;
f011114e:	83 ec 0c             	sub    $0xc,%esp
f0111151:	68 58 ab 12 f0       	push   $0xf012ab58
f0111156:	e8 11 fe fe ff       	call   f0100f6c <cprintf>
f011115b:	83 c4 10             	add    $0x10,%esp
	cprintf("		4.1: at the tail\n\n") ;
f011115e:	83 ec 0c             	sub    $0xc,%esp
f0111161:	68 94 ab 12 f0       	push   $0xf012ab94
f0111166:	e8 01 fe fe ff       	call   f0100f6c <cprintf>
f011116b:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011116e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block (coalesce with previous)
	uint32 blockIndex = numOfAllocs*allocCntPerSize;
f0111175:	c7 45 b4 78 05 00 00 	movl   $0x578,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f011117c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011117f:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111186:	83 ec 0c             	sub    $0xc,%esp
f0111189:	50                   	push   %eax
f011118a:	e8 00 2a 01 00       	call   f0123b8f <free_block>
f011118f:	83 c4 10             	add    $0x10,%esp
	expected_size = remainSize + allocSizes[numOfAllocs-1];
f0111192:	8b 15 d0 fd 17 f0    	mov    0xf017fdd0,%edx
f0111198:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011119b:	01 d0                	add    %edx,%eax
f011119d:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f01111a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01111a3:	48                   	dec    %eax
f01111a4:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f01111ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01111ae:	48                   	dec    %eax
f01111af:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01111b6:	6a 00                	push   $0x0
f01111b8:	ff 75 b0             	pushl  -0x50(%ebp)
f01111bb:	52                   	push   %edx
f01111bc:	50                   	push   %eax
f01111bd:	e8 c3 e9 ff ff       	call   f010fb85 <check_block>
f01111c2:	83 c4 10             	add    $0x10,%esp
f01111c5:	85 c0                	test   %eax,%eax
f01111c7:	75 07                	jne    f01111d0 <test_free_block_FF+0x61a>
	{
		is_correct = 0;
f01111c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	//====================================================================//
	/*free_block Scenario 3: Merge with previous ONLY (between 2 blocks)*/
	cprintf("		4.2: between 2 blocks\n\n") ;
f01111d0:	83 ec 0c             	sub    $0xc,%esp
f01111d3:	68 a9 ab 12 f0       	push   $0xf012aba9
f01111d8:	e8 8f fd fe ff       	call   f0100f6c <cprintf>
f01111dd:	83 c4 10             	add    $0x10,%esp
	blockIndex = 2*allocCntPerSize+1 ;
f01111e0:	c7 45 b4 91 01 00 00 	movl   $0x191,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f01111e7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01111ea:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01111f1:	83 ec 0c             	sub    $0xc,%esp
f01111f4:	50                   	push   %eax
f01111f5:	e8 95 29 01 00       	call   f0123b8f <free_block>
f01111fa:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[2]+allocSizes[2];
f01111fd:	8b 15 c0 fd 17 f0    	mov    0xf017fdc0,%edx
f0111203:	a1 c0 fd 17 f0       	mov    0xf017fdc0,%eax
f0111208:	01 d0                	add    %edx,%eax
f011120a:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f011120d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111210:	48                   	dec    %eax
f0111211:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111218:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011121b:	48                   	dec    %eax
f011121c:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111223:	6a 00                	push   $0x0
f0111225:	ff 75 b0             	pushl  -0x50(%ebp)
f0111228:	52                   	push   %edx
f0111229:	50                   	push   %eax
f011122a:	e8 56 e9 ff ff       	call   f010fb85 <check_block>
f011122f:	83 c4 10             	add    $0x10,%esp
f0111232:	85 c0                	test   %eax,%eax
f0111234:	75 07                	jne    f011123d <test_free_block_FF+0x687>
	{
		is_correct = 0;
f0111236:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f011123d:	83 ec 0c             	sub    $0xc,%esp
f0111240:	ff 75 b8             	pushl  -0x48(%ebp)
f0111243:	e8 c5 e9 ff ff       	call   f010fc0d <check_list_size>
f0111248:	83 c4 10             	add    $0x10,%esp
f011124b:	85 c0                	test   %eax,%eax
f011124d:	75 07                	jne    f0111256 <test_free_block_FF+0x6a0>
	{
		is_correct = 0;
f011124f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	if (is_correct)
f0111256:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011125a:	74 04                	je     f0111260 <test_free_block_FF+0x6aa>
	{
		eval += 15;
f011125c:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 4: Merge with next ONLY (AT the head)*/
	cprintf("	5: Free some allocated blocks [Merge with next ONLY]\n\n") ;
f0111260:	83 ec 0c             	sub    $0xc,%esp
f0111263:	68 c4 ab 12 f0       	push   $0xf012abc4
f0111268:	e8 ff fc fe ff       	call   f0100f6c <cprintf>
f011126d:	83 c4 10             	add    $0x10,%esp
	cprintf("		5.1: at the head\n\n") ;
f0111270:	83 ec 0c             	sub    $0xc,%esp
f0111273:	68 fc ab 12 f0       	push   $0xf012abfc
f0111278:	e8 ef fc fe ff       	call   f0100f6c <cprintf>
f011127d:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0111280:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 0 ;
f0111287:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f011128e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111291:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111298:	83 ec 0c             	sub    $0xc,%esp
f011129b:	50                   	push   %eax
f011129c:	e8 ee 28 01 00       	call   f0123b8f <free_block>
f01112a1:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[0]+allocSizes[0];
f01112a4:	8b 15 b8 fd 17 f0    	mov    0xf017fdb8,%edx
f01112aa:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f01112af:	01 d0                	add    %edx,%eax
f01112b1:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f01112b4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01112b7:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f01112be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01112c1:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01112c8:	6a 00                	push   $0x0
f01112ca:	ff 75 b0             	pushl  -0x50(%ebp)
f01112cd:	52                   	push   %edx
f01112ce:	50                   	push   %eax
f01112cf:	e8 b1 e8 ff ff       	call   f010fb85 <check_block>
f01112d4:	83 c4 10             	add    $0x10,%esp
f01112d7:	85 c0                	test   %eax,%eax
f01112d9:	75 07                	jne    f01112e2 <test_free_block_FF+0x72c>
	{
		is_correct = 0;
f01112db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 5: Merge with next ONLY (between 2 blocks)*/
	cprintf("		5.2: between 2 blocks\n\n") ;
f01112e2:	83 ec 0c             	sub    $0xc,%esp
f01112e5:	68 11 ac 12 f0       	push   $0xf012ac11
f01112ea:	e8 7d fc fe ff       	call   f0100f6c <cprintf>
f01112ef:	83 c4 10             	add    $0x10,%esp
	blockIndex = 1*allocCntPerSize - 1 ;
f01112f2:	c7 45 b4 c7 00 00 00 	movl   $0xc7,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f01112f9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01112fc:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111303:	83 ec 0c             	sub    $0xc,%esp
f0111306:	50                   	push   %eax
f0111307:	e8 83 28 01 00       	call   f0123b8f <free_block>
f011130c:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex]) ;
f011130f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111312:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111319:	83 ec 0c             	sub    $0xc,%esp
f011131c:	50                   	push   %eax
f011131d:	e8 1e 1d 01 00       	call   f0123040 <get_block_size>
f0111322:	83 c4 10             	add    $0x10,%esp
f0111325:	89 45 ac             	mov    %eax,-0x54(%ebp)
	expected_size = allocSizes[0]+allocSizes[1];
f0111328:	8b 15 b8 fd 17 f0    	mov    0xf017fdb8,%edx
f011132e:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f0111333:	01 d0                	add    %edx,%eax
f0111335:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f0111338:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011133b:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111342:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111345:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f011134c:	6a 00                	push   $0x0
f011134e:	ff 75 b0             	pushl  -0x50(%ebp)
f0111351:	52                   	push   %edx
f0111352:	50                   	push   %eax
f0111353:	e8 2d e8 ff ff       	call   f010fb85 <check_block>
f0111358:	83 c4 10             	add    $0x10,%esp
f011135b:	85 c0                	test   %eax,%eax
f011135d:	75 07                	jne    f0111366 <test_free_block_FF+0x7b0>
	{
		is_correct = 0;
f011135f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}

	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0111366:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011136a:	74 11                	je     f011137d <test_free_block_FF+0x7c7>
f011136c:	83 ec 0c             	sub    $0xc,%esp
f011136f:	ff 75 b8             	pushl  -0x48(%ebp)
f0111372:	e8 96 e8 ff ff       	call   f010fc0d <check_list_size>
f0111377:	83 c4 10             	add    $0x10,%esp
f011137a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct)
f011137d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111381:	74 04                	je     f0111387 <test_free_block_FF+0x7d1>
	{
		eval += 15;
f0111383:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 6: Merge with prev & next */
	cprintf("	6: Free some allocated blocks [Merge with previous & next]\n\n") ;
f0111387:	83 ec 0c             	sub    $0xc,%esp
f011138a:	68 2c ac 12 f0       	push   $0xf012ac2c
f011138f:	e8 d8 fb fe ff       	call   f0100f6c <cprintf>
f0111394:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0111397:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 4*allocCntPerSize - 2 ;
f011139e:	c7 45 b4 1e 03 00 00 	movl   $0x31e,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);	//no merge
f01113a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01113a8:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01113af:	83 ec 0c             	sub    $0xc,%esp
f01113b2:	50                   	push   %eax
f01113b3:	e8 d7 27 01 00       	call   f0123b8f <free_block>
f01113b8:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks++;
f01113bb:	ff 45 b8             	incl   -0x48(%ebp)

	blockIndex = 4*allocCntPerSize - 1 ;
f01113be:	c7 45 b4 1f 03 00 00 	movl   $0x31f,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);	//merge with prev & next
f01113c5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01113c8:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01113cf:	83 ec 0c             	sub    $0xc,%esp
f01113d2:	50                   	push   %eax
f01113d3:	e8 b7 27 01 00       	call   f0123b8f <free_block>
f01113d8:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks--;
f01113db:	ff 4d b8             	decl   -0x48(%ebp)

	block_size = get_block_size(startVAs[blockIndex-1]) ;
f01113de:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01113e1:	48                   	dec    %eax
f01113e2:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01113e9:	83 ec 0c             	sub    $0xc,%esp
f01113ec:	50                   	push   %eax
f01113ed:	e8 4e 1c 01 00       	call   f0123040 <get_block_size>
f01113f2:	83 c4 10             	add    $0x10,%esp
f01113f5:	89 45 ac             	mov    %eax,-0x54(%ebp)
	expected_size = allocSizes[3]+allocSizes[3]+allocSizes[4];
f01113f8:	8b 15 c4 fd 17 f0    	mov    0xf017fdc4,%edx
f01113fe:	a1 c4 fd 17 f0       	mov    0xf017fdc4,%eax
f0111403:	01 c2                	add    %eax,%edx
f0111405:	a1 c8 fd 17 f0       	mov    0xf017fdc8,%eax
f011140a:	01 d0                	add    %edx,%eax
f011140c:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f011140f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111412:	48                   	dec    %eax
f0111413:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f011141a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011141d:	48                   	dec    %eax
f011141e:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111425:	6a 00                	push   $0x0
f0111427:	ff 75 b0             	pushl  -0x50(%ebp)
f011142a:	52                   	push   %edx
f011142b:	50                   	push   %eax
f011142c:	e8 54 e7 ff ff       	call   f010fb85 <check_block>
f0111431:	83 c4 10             	add    $0x10,%esp
f0111434:	85 c0                	test   %eax,%eax
f0111436:	75 07                	jne    f011143f <test_free_block_FF+0x889>
	{
		is_correct = 0;
f0111438:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}

	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f011143f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111443:	74 11                	je     f0111456 <test_free_block_FF+0x8a0>
f0111445:	83 ec 0c             	sub    $0xc,%esp
f0111448:	ff 75 b8             	pushl  -0x48(%ebp)
f011144b:	e8 bd e7 ff ff       	call   f010fc0d <check_list_size>
f0111450:	83 c4 10             	add    $0x10,%esp
f0111453:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (is_correct)
f0111456:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011145a:	74 04                	je     f0111460 <test_free_block_FF+0x8aa>
	{
		eval += 20;
f011145c:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
	}

	//====================================================================//
	/*Allocate After Free Scenarios */
	cprintf("	7: Allocate After Free [should be placed in coalesced blocks]\n\n") ;
f0111460:	83 ec 0c             	sub    $0xc,%esp
f0111463:	68 6c ac 12 f0       	push   $0xf012ac6c
f0111468:	e8 ff fa fe ff       	call   f0100f6c <cprintf>
f011146d:	83 c4 10             	add    $0x10,%esp

	cprintf("		7.1: in block coalesces with NEXT\n\n") ;
f0111470:	83 ec 0c             	sub    $0xc,%esp
f0111473:	68 b0 ac 12 f0       	push   $0xf012acb0
f0111478:	e8 ef fa fe ff       	call   f0100f6c <cprintf>
f011147d:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0111480:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 5*kilo - sizeOfMetaData;
f0111487:	c7 45 c4 f8 13 00 00 	movl   $0x13f8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f011148e:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
f0111495:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111498:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011149b:	01 d0                	add    %edx,%eax
f011149d:	83 c0 07             	add    $0x7,%eax
f01114a0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01114a3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01114a6:	ba 00 00 00 00       	mov    $0x0,%edx
f01114ab:	f7 75 a8             	divl   -0x58(%ebp)
f01114ae:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01114b1:	29 d0                	sub    %edx,%eax
f01114b3:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01114b6:	83 ec 08             	sub    $0x8,%esp
f01114b9:	6a 01                	push   $0x1
f01114bb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01114be:	e8 b4 1b 01 00       	call   f0123077 <alloc_block>
f01114c3:	83 c4 10             	add    $0x10,%esp
f01114c6:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	void* expected = (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2);
f01114c9:	c7 45 a0 08 00 00 f6 	movl   $0xf6000008,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01114d0:	6a 01                	push   $0x1
f01114d2:	ff 75 b0             	pushl  -0x50(%ebp)
f01114d5:	ff 75 a0             	pushl  -0x60(%ebp)
f01114d8:	ff 75 c0             	pushl  -0x40(%ebp)
f01114db:	e8 a5 e6 ff ff       	call   f010fb85 <check_block>
f01114e0:	83 c4 10             	add    $0x10,%esp
f01114e3:	85 c0                	test   %eax,%eax
f01114e5:	75 17                	jne    f01114fe <test_free_block_FF+0x948>
	{
		is_correct = 0;
f01114e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.1: Failed\n");
f01114ee:	83 ec 0c             	sub    $0xc,%esp
f01114f1:	68 d6 ac 12 f0       	push   $0xf012acd6
f01114f6:	e8 71 fa fe ff       	call   f0100f6c <cprintf>
f01114fb:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 3*kilo - sizeOfMetaData;
f01114fe:	c7 45 c4 f8 0b 00 00 	movl   $0xbf8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f0111505:	c7 45 9c 02 00 00 00 	movl   $0x2,-0x64(%ebp)
f011150c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011150f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111512:	01 d0                	add    %edx,%eax
f0111514:	83 c0 07             	add    $0x7,%eax
f0111517:	89 45 98             	mov    %eax,-0x68(%ebp)
f011151a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011151d:	ba 00 00 00 00       	mov    $0x0,%edx
f0111522:	f7 75 9c             	divl   -0x64(%ebp)
f0111525:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111528:	29 d0                	sub    %edx,%eax
f011152a:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f011152d:	83 ec 08             	sub    $0x8,%esp
f0111530:	6a 01                	push   $0x1
f0111532:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111535:	e8 3d 1b 01 00       	call   f0123077 <alloc_block>
f011153a:	83 c4 10             	add    $0x10,%esp
f011153d:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + sizeof(int) + 5*kilo + sizeOfMetaData/2);
f0111540:	c7 45 a0 08 14 00 f6 	movl   $0xf6001408,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0111547:	6a 01                	push   $0x1
f0111549:	ff 75 b0             	pushl  -0x50(%ebp)
f011154c:	ff 75 a0             	pushl  -0x60(%ebp)
f011154f:	ff 75 c0             	pushl  -0x40(%ebp)
f0111552:	e8 2e e6 ff ff       	call   f010fb85 <check_block>
f0111557:	83 c4 10             	add    $0x10,%esp
f011155a:	85 c0                	test   %eax,%eax
f011155c:	75 17                	jne    f0111575 <test_free_block_FF+0x9bf>
	{
		is_correct = 0;
f011155e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.2: Failed\n");
f0111565:	83 ec 0c             	sub    $0xc,%esp
f0111568:	68 f4 ac 12 f0       	push   $0xf012acf4
f011156d:	e8 fa f9 fe ff       	call   f0100f6c <cprintf>
f0111572:	83 c4 10             	add    $0x10,%esp
	}

	expectedNumOfFreeBlks--;
f0111575:	ff 4d b8             	decl   -0x48(%ebp)

	/*INTERNAL FRAGMENTATION CASE*/
	actualSize = 4*kilo + 10 ;
f0111578:	c7 45 c4 0a 10 00 00 	movl   $0x100a,-0x3c(%ebp)
	expected_size = MAX(ROUNDUP(actualSize + sizeOfMetaData, 2), allocSizes[0]+allocSizes[1]) ;
f011157f:	c7 45 94 02 00 00 00 	movl   $0x2,-0x6c(%ebp)
f0111586:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111589:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011158c:	01 d0                	add    %edx,%eax
f011158e:	83 c0 07             	add    $0x7,%eax
f0111591:	89 45 90             	mov    %eax,-0x70(%ebp)
f0111594:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111597:	ba 00 00 00 00       	mov    $0x0,%edx
f011159c:	f7 75 94             	divl   -0x6c(%ebp)
f011159f:	8b 45 90             	mov    -0x70(%ebp),%eax
f01115a2:	29 d0                	sub    %edx,%eax
f01115a4:	89 45 8c             	mov    %eax,-0x74(%ebp)
f01115a7:	8b 15 b8 fd 17 f0    	mov    0xf017fdb8,%edx
f01115ad:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f01115b2:	01 d0                	add    %edx,%eax
f01115b4:	89 45 88             	mov    %eax,-0x78(%ebp)
f01115b7:	8b 55 88             	mov    -0x78(%ebp),%edx
f01115ba:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01115bd:	39 d0                	cmp    %edx,%eax
f01115bf:	73 02                	jae    f01115c3 <test_free_block_FF+0xa0d>
f01115c1:	89 d0                	mov    %edx,%eax
f01115c3:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01115c6:	83 ec 08             	sub    $0x8,%esp
f01115c9:	6a 01                	push   $0x1
f01115cb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01115ce:	e8 a4 1a 01 00       	call   f0123077 <alloc_block>
f01115d3:	83 c4 10             	add    $0x10,%esp
f01115d6:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[1*allocCntPerSize - 1];
f01115d9:	a1 9c 23 5c f0       	mov    0xf05c239c,%eax
f01115de:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01115e1:	6a 01                	push   $0x1
f01115e3:	ff 75 b0             	pushl  -0x50(%ebp)
f01115e6:	ff 75 a0             	pushl  -0x60(%ebp)
f01115e9:	ff 75 c0             	pushl  -0x40(%ebp)
f01115ec:	e8 94 e5 ff ff       	call   f010fb85 <check_block>
f01115f1:	83 c4 10             	add    $0x10,%esp
f01115f4:	85 c0                	test   %eax,%eax
f01115f6:	75 17                	jne    f011160f <test_free_block_FF+0xa59>
	{
		is_correct = 0;
f01115f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.3: Failed INTERNAL FRAGMENTATION CASE\n");
f01115ff:	83 ec 0c             	sub    $0xc,%esp
f0111602:	68 14 ad 12 f0       	push   $0xf012ad14
f0111607:	e8 60 f9 fe ff       	call   f0100f6c <cprintf>
f011160c:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f011160f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111613:	74 04                	je     f0111619 <test_free_block_FF+0xa63>
	{
		eval += 10;
f0111615:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	expectedNumOfFreeBlks--;
f0111619:	ff 4d b8             	decl   -0x48(%ebp)

	cprintf("		7.2: in block coalesces with PREV & NEXT\n\n") ;
f011161c:	83 ec 0c             	sub    $0xc,%esp
f011161f:	68 50 ad 12 f0       	push   $0xf012ad50
f0111624:	e8 43 f9 fe ff       	call   f0100f6c <cprintf>
f0111629:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011162c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo + 1;
f0111633:	c7 45 c4 01 08 00 00 	movl   $0x801,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f011163a:	c7 45 84 02 00 00 00 	movl   $0x2,-0x7c(%ebp)
f0111641:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111644:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111647:	01 d0                	add    %edx,%eax
f0111649:	83 c0 07             	add    $0x7,%eax
f011164c:	89 45 80             	mov    %eax,-0x80(%ebp)
f011164f:	8b 45 80             	mov    -0x80(%ebp),%eax
f0111652:	ba 00 00 00 00       	mov    $0x0,%edx
f0111657:	f7 75 84             	divl   -0x7c(%ebp)
f011165a:	8b 45 80             	mov    -0x80(%ebp),%eax
f011165d:	29 d0                	sub    %edx,%eax
f011165f:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0111662:	83 ec 08             	sub    $0x8,%esp
f0111665:	6a 01                	push   $0x1
f0111667:	ff 75 c4             	pushl  -0x3c(%ebp)
f011166a:	e8 08 1a 01 00       	call   f0123077 <alloc_block>
f011166f:	83 c4 10             	add    $0x10,%esp
f0111672:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[4*allocCntPerSize - 2];
f0111675:	a1 f8 2c 5c f0       	mov    0xf05c2cf8,%eax
f011167a:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f011167d:	6a 01                	push   $0x1
f011167f:	ff 75 b0             	pushl  -0x50(%ebp)
f0111682:	ff 75 a0             	pushl  -0x60(%ebp)
f0111685:	ff 75 c0             	pushl  -0x40(%ebp)
f0111688:	e8 f8 e4 ff ff       	call   f010fb85 <check_block>
f011168d:	83 c4 10             	add    $0x10,%esp
f0111690:	85 c0                	test   %eax,%eax
f0111692:	75 17                	jne    f01116ab <test_free_block_FF+0xaf5>
	{
		is_correct = 0;
f0111694:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.4: Failed\n");
f011169b:	83 ec 0c             	sub    $0xc,%esp
f011169e:	68 7d ad 12 f0       	push   $0xf012ad7d
f01116a3:	e8 c4 f8 fe ff       	call   f0100f6c <cprintf>
f01116a8:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f01116ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01116af:	74 04                	je     f01116b5 <test_free_block_FF+0xaff>
	{
		eval += 10;
f01116b1:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("		7.3: in block coalesces with PREV\n\n") ;
f01116b5:	83 ec 0c             	sub    $0xc,%esp
f01116b8:	68 9c ad 12 f0       	push   $0xf012ad9c
f01116bd:	e8 aa f8 fe ff       	call   f0100f6c <cprintf>
f01116c2:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01116c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo - sizeOfMetaData;
f01116cc:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f01116d3:	c7 85 7c ff ff ff 02 	movl   $0x2,-0x84(%ebp)
f01116da:	00 00 00 
f01116dd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01116e0:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01116e6:	01 d0                	add    %edx,%eax
f01116e8:	83 c0 07             	add    $0x7,%eax
f01116eb:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01116f1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01116f7:	ba 00 00 00 00       	mov    $0x0,%edx
f01116fc:	f7 b5 7c ff ff ff    	divl   -0x84(%ebp)
f0111702:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0111708:	29 d0                	sub    %edx,%eax
f011170a:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f011170d:	83 ec 08             	sub    $0x8,%esp
f0111710:	6a 01                	push   $0x1
f0111712:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111715:	e8 5d 19 01 00       	call   f0123077 <alloc_block>
f011171a:	83 c4 10             	add    $0x10,%esp
f011171d:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[2*allocCntPerSize];
f0111720:	a1 c0 26 5c f0       	mov    0xf05c26c0,%eax
f0111725:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0111728:	6a 01                	push   $0x1
f011172a:	ff 75 b0             	pushl  -0x50(%ebp)
f011172d:	ff 75 a0             	pushl  -0x60(%ebp)
f0111730:	ff 75 c0             	pushl  -0x40(%ebp)
f0111733:	e8 4d e4 ff ff       	call   f010fb85 <check_block>
f0111738:	83 c4 10             	add    $0x10,%esp
f011173b:	85 c0                	test   %eax,%eax
f011173d:	75 17                	jne    f0111756 <test_free_block_FF+0xba0>
	{
		is_correct = 0;
f011173f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.5: Failed\n");
f0111746:	83 ec 0c             	sub    $0xc,%esp
f0111749:	68 c2 ad 12 f0       	push   $0xf012adc2
f011174e:	e8 19 f8 fe ff       	call   f0100f6c <cprintf>
f0111753:	83 c4 10             	add    $0x10,%esp
	}

	expectedNumOfFreeBlks--;
f0111756:	ff 4d b8             	decl   -0x48(%ebp)

	actualSize = 8*kilo - sizeOfMetaData;
f0111759:	c7 45 c4 f8 1f 00 00 	movl   $0x1ff8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f0111760:	c7 85 74 ff ff ff 02 	movl   $0x2,-0x8c(%ebp)
f0111767:	00 00 00 
f011176a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011176d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0111773:	01 d0                	add    %edx,%eax
f0111775:	83 c0 07             	add    $0x7,%eax
f0111778:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f011177e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111784:	ba 00 00 00 00       	mov    $0x0,%edx
f0111789:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f011178f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111795:	29 d0                	sub    %edx,%eax
f0111797:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f011179a:	83 ec 08             	sub    $0x8,%esp
f011179d:	6a 01                	push   $0x1
f011179f:	ff 75 c4             	pushl  -0x3c(%ebp)
f01117a2:	e8 d0 18 01 00       	call   f0123077 <alloc_block>
f01117a7:	83 c4 10             	add    $0x10,%esp
f01117aa:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[numOfAllocs*allocCntPerSize-1];
f01117ad:	a1 5c 36 5c f0       	mov    0xf05c365c,%eax
f01117b2:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01117b5:	6a 01                	push   $0x1
f01117b7:	ff 75 b0             	pushl  -0x50(%ebp)
f01117ba:	ff 75 a0             	pushl  -0x60(%ebp)
f01117bd:	ff 75 c0             	pushl  -0x40(%ebp)
f01117c0:	e8 c0 e3 ff ff       	call   f010fb85 <check_block>
f01117c5:	83 c4 10             	add    $0x10,%esp
f01117c8:	85 c0                	test   %eax,%eax
f01117ca:	75 17                	jne    f01117e3 <test_free_block_FF+0xc2d>
	{
		is_correct = 0;
f01117cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.6: Failed\n");
f01117d3:	83 ec 0c             	sub    $0xc,%esp
f01117d6:	68 e0 ad 12 f0       	push   $0xf012ade0
f01117db:	e8 8c f7 fe ff       	call   f0100f6c <cprintf>
f01117e0:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f01117e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117e7:	74 11                	je     f01117fa <test_free_block_FF+0xc44>
f01117e9:	83 ec 0c             	sub    $0xc,%esp
f01117ec:	ff 75 b8             	pushl  -0x48(%ebp)
f01117ef:	e8 19 e4 ff ff       	call   f010fc0d <check_list_size>
f01117f4:	83 c4 10             	add    $0x10,%esp
f01117f7:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (is_correct)
f01117fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117fe:	74 04                	je     f0111804 <test_free_block_FF+0xc4e>
	{
		eval += 10;
f0111800:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);
f0111804:	83 ec 08             	sub    $0x8,%esp
f0111807:	ff 75 f4             	pushl  -0xc(%ebp)
f011180a:	68 00 ae 12 f0       	push   $0xf012ae00
f011180f:	e8 58 f7 fe ff       	call   f0100f6c <cprintf>
f0111814:	83 c4 10             	add    $0x10,%esp

}
f0111817:	90                   	nop
f0111818:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011181b:	c9                   	leave  
f011181c:	c3                   	ret    

f011181d <test_free_block_BF>:

void test_free_block_BF()
{
f011181d:	55                   	push   %ebp
f011181e:	89 e5                	mov    %esp,%ebp
f0111820:	53                   	push   %ebx
f0111821:	81 ec 84 00 00 00    	sub    $0x84,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f0111827:	83 ec 0c             	sub    $0xc,%esp
f011182a:	68 90 a8 12 f0       	push   $0xf012a890
f011182f:	e8 38 f7 fe ff       	call   f0100f6c <cprintf>
f0111834:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f0111837:	83 ec 0c             	sub    $0xc,%esp
f011183a:	68 d0 a8 12 f0       	push   $0xf012a8d0
f011183f:	e8 28 f7 fe ff       	call   f0100f6c <cprintf>
f0111844:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0111847:	83 ec 0c             	sub    $0xc,%esp
f011184a:	68 90 a8 12 f0       	push   $0xf012a890
f011184f:	e8 18 f7 fe ff       	call   f0100f6c <cprintf>
f0111854:	83 c4 10             	add    $0x10,%esp

	int initAllocatedSpace = 3*Mega;
f0111857:	c7 45 d4 00 00 30 00 	movl   $0x300000,-0x2c(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f011185e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111861:	83 ec 08             	sub    $0x8,%esp
f0111864:	50                   	push   %eax
f0111865:	68 00 00 00 f6       	push   $0xf6000000
f011186a:	e8 35 19 01 00       	call   f01231a4 <initialize_dynamic_allocator>
f011186f:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;
f0111872:	83 ec 0c             	sub    $0xc,%esp
f0111875:	68 10 a9 12 f0       	push   $0xf012a910
f011187a:	e8 ed f6 fe ff       	call   f0100f6c <cprintf>
f011187f:	83 c4 10             	add    $0x10,%esp

	int totalSizes = 0;
f0111882:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f0111889:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0111890:	eb 2a                	jmp    f01118bc <test_free_block_BF+0x9f>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f0111892:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111895:	8b 14 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%edx
f011189c:	89 d0                	mov    %edx,%eax
f011189e:	c1 e0 02             	shl    $0x2,%eax
f01118a1:	01 d0                	add    %edx,%eax
f01118a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01118aa:	01 d0                	add    %edx,%eax
f01118ac:	c1 e0 03             	shl    $0x3,%eax
f01118af:	89 c2                	mov    %eax,%edx
f01118b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01118b4:	01 d0                	add    %edx,%eax
f01118b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f01118b9:	ff 45 f0             	incl   -0x10(%ebp)
f01118bc:	83 7d f0 06          	cmpl   $0x6,-0x10(%ebp)
f01118c0:	7e d0                	jle    f0111892 <test_free_block_BF+0x75>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f01118c2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01118c5:	2b 45 f4             	sub    -0xc(%ebp),%eax
f01118c8:	83 e8 08             	sub    $0x8,%eax
f01118cb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (remainSize <= 0)
f01118ce:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01118d2:	7f 17                	jg     f01118eb <test_free_block_BF+0xce>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f01118d4:	83 ec 04             	sub    $0x4,%esp
f01118d7:	68 68 a9 12 f0       	push   $0xf012a968
f01118dc:	68 bf 03 00 00       	push   $0x3bf
f01118e1:	68 48 a1 12 f0       	push   $0xf012a148
f01118e6:	e8 2f ea fe ff       	call   f010031a <_panic>

	int idx = 0;
f01118eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f01118f2:	c7 45 e8 04 00 00 f6 	movl   $0xf6000004,-0x18(%ebp)

	uint32 actualSize, expected_size;
	void* expected_va;
	for (int i = 0; i < numOfAllocs; ++i)
f01118f9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111900:	e9 0f 01 00 00       	jmp    f0111a14 <test_free_block_BF+0x1f7>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0111905:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011190c:	e9 f3 00 00 00       	jmp    f0111a04 <test_free_block_BF+0x1e7>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f0111911:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111914:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f011191b:	83 e8 08             	sub    $0x8,%eax
f011191e:	89 45 cc             	mov    %eax,-0x34(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, DA_BF);
f0111921:	83 ec 08             	sub    $0x8,%esp
f0111924:	6a 03                	push   $0x3
f0111926:	ff 75 cc             	pushl  -0x34(%ebp)
f0111929:	e8 49 17 01 00       	call   f0123077 <alloc_block>
f011192e:	83 c4 10             	add    $0x10,%esp
f0111931:	89 c2                	mov    %eax,%edx
f0111933:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111936:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f011193d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111940:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111947:	89 45 c8             	mov    %eax,-0x38(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f011194a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011194d:	d1 e8                	shr    %eax
f011194f:	89 c2                	mov    %eax,%edx
f0111951:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111954:	01 c2                	add    %eax,%edx
f0111956:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111959:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0111960:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111963:	8d 50 fe             	lea    -0x2(%eax),%edx
f0111966:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111969:	01 c2                	add    %eax,%edx
f011196b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011196e:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
			//Check returned va
			expected_va = curVA + sizeOfMetaData/2;
f0111975:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111978:	83 c0 04             	add    $0x4,%eax
f011197b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if (check_block(va, expected_va, allocSizes[i], 1) == 0)
f011197e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111981:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f0111988:	6a 01                	push   $0x1
f011198a:	50                   	push   %eax
f011198b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011198e:	ff 75 c8             	pushl  -0x38(%ebp)
f0111991:	e8 ef e1 ff ff       	call   f010fb85 <check_block>
f0111996:	83 c4 10             	add    $0x10,%esp
f0111999:	85 c0                	test   %eax,%eax
f011199b:	75 24                	jne    f01119c1 <test_free_block_BF+0x1a4>
				panic("test_free_block #1.%d: WRONG ALLOC - alloc_block_BF return wrong address. Expected %x, Actual %x", idx, curVA + sizeOfMetaData ,va);
f011199d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01119a0:	83 c0 08             	add    $0x8,%eax
f01119a3:	83 ec 08             	sub    $0x8,%esp
f01119a6:	ff 75 c8             	pushl  -0x38(%ebp)
f01119a9:	50                   	push   %eax
f01119aa:	ff 75 ec             	pushl  -0x14(%ebp)
f01119ad:	68 3c ae 12 f0       	push   $0xf012ae3c
f01119b2:	68 d1 03 00 00       	push   $0x3d1
f01119b7:	68 48 a1 12 f0       	push   $0xf012a148
f01119bc:	e8 59 e9 fe ff       	call   f010031a <_panic>
			curVA += allocSizes[i] ;
f01119c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01119c4:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f01119cb:	01 45 e8             	add    %eax,-0x18(%ebp)
			*(startVAs[idx]) = idx ;
f01119ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01119d1:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f01119d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01119db:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f01119de:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01119e1:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f01119e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01119eb:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f01119ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01119f1:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f01119f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01119fb:	66 89 02             	mov    %ax,(%edx)
			idx++;
f01119fe:	ff 45 ec             	incl   -0x14(%ebp)

	uint32 actualSize, expected_size;
	void* expected_va;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0111a01:	ff 45 e0             	incl   -0x20(%ebp)
f0111a04:	81 7d e0 c7 00 00 00 	cmpl   $0xc7,-0x20(%ebp)
f0111a0b:	0f 8e 00 ff ff ff    	jle    f0111911 <test_free_block_BF+0xf4>
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block

	uint32 actualSize, expected_size;
	void* expected_va;
	for (int i = 0; i < numOfAllocs; ++i)
f0111a11:	ff 45 e4             	incl   -0x1c(%ebp)
f0111a14:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
f0111a18:	0f 8e e7 fe ff ff    	jle    f0111905 <test_free_block_BF+0xe8>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f0111a1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111a21:	83 e8 08             	sub    $0x8,%eax
f0111a24:	89 45 cc             	mov    %eax,-0x34(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, DA_BF);
f0111a27:	83 ec 08             	sub    $0x8,%esp
f0111a2a:	6a 03                	push   $0x3
f0111a2c:	ff 75 cc             	pushl  -0x34(%ebp)
f0111a2f:	e8 43 16 01 00       	call   f0123077 <alloc_block>
f0111a34:	83 c4 10             	add    $0x10,%esp
f0111a37:	89 c2                	mov    %eax,%edx
f0111a39:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111a3c:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f0111a43:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111a46:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111a4d:	89 45 c8             	mov    %eax,-0x38(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f0111a50:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111a53:	d1 e8                	shr    %eax
f0111a55:	89 c2                	mov    %eax,%edx
f0111a57:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111a5a:	01 c2                	add    %eax,%edx
f0111a5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111a5f:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f0111a66:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111a69:	8d 50 fe             	lea    -0x2(%eax),%edx
f0111a6c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111a6f:	01 c2                	add    %eax,%edx
f0111a71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111a74:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
	//Check returned va
	expected_va = curVA + sizeOfMetaData/2;
f0111a7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111a7e:	83 c0 04             	add    $0x4,%eax
f0111a81:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (check_block(va, expected_va, remainSize, 1) == 0)
f0111a84:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111a87:	6a 01                	push   $0x1
f0111a89:	50                   	push   %eax
f0111a8a:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111a8d:	ff 75 c8             	pushl  -0x38(%ebp)
f0111a90:	e8 f0 e0 ff ff       	call   f010fb85 <check_block>
f0111a95:	83 c4 10             	add    $0x10,%esp
f0111a98:	85 c0                	test   %eax,%eax
f0111a9a:	75 17                	jne    f0111ab3 <test_free_block_BF+0x296>
		panic("test_free_block #1: WRONG ALLOC - alloc_block_BF return wrong address.");
f0111a9c:	83 ec 04             	sub    $0x4,%esp
f0111a9f:	68 a0 ae 12 f0       	push   $0xf012aea0
f0111aa4:	68 e3 03 00 00       	push   $0x3e3
f0111aa9:	68 48 a1 12 f0       	push   $0xf012a148
f0111aae:	e8 67 e8 fe ff       	call   f010031a <_panic>
	*(startVAs[idx]) = idx ;
f0111ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ab6:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111abd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ac0:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f0111ac3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ac6:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f0111acd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ad0:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f0111ad3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ad6:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f0111add:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ae0:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
f0111ae3:	83 ec 0c             	sub    $0xc,%esp
f0111ae6:	68 a4 aa 12 f0       	push   $0xf012aaa4
f0111aeb:	e8 7c f4 fe ff       	call   f0100f6c <cprintf>
f0111af0:	83 c4 10             	add    $0x10,%esp

	for (int i = 0; i < idx; ++i)
f0111af3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0111afa:	eb 59                	jmp    f0111b55 <test_free_block_BF+0x338>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f0111afc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111aff:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111b06:	66 8b 00             	mov    (%eax),%ax
f0111b09:	98                   	cwtl   
f0111b0a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0111b0d:	75 26                	jne    f0111b35 <test_free_block_BF+0x318>
f0111b0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b12:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0111b19:	66 8b 00             	mov    (%eax),%ax
f0111b1c:	98                   	cwtl   
f0111b1d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0111b20:	75 13                	jne    f0111b35 <test_free_block_BF+0x318>
f0111b22:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b25:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f0111b2c:	66 8b 00             	mov    (%eax),%ax
f0111b2f:	98                   	cwtl   
f0111b30:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0111b33:	74 1d                	je     f0111b52 <test_free_block_BF+0x335>
			panic("test_free_block #2.%d: WRONG! content of the block is not correct. Expected %d",i, i);
f0111b35:	83 ec 0c             	sub    $0xc,%esp
f0111b38:	ff 75 dc             	pushl  -0x24(%ebp)
f0111b3b:	ff 75 dc             	pushl  -0x24(%ebp)
f0111b3e:	68 e8 ae 12 f0       	push   $0xf012aee8
f0111b43:	68 ef 03 00 00       	push   $0x3ef
f0111b48:	68 48 a1 12 f0       	push   $0xf012a148
f0111b4d:	e8 c8 e7 fe ff       	call   f010031a <_panic>

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;

	for (int i = 0; i < idx; ++i)
f0111b52:	ff 45 dc             	incl   -0x24(%ebp)
f0111b55:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b58:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111b5b:	7c 9f                	jl     f0111afc <test_free_block_BF+0x2df>
			panic("test_free_block #2.%d: WRONG! content of the block is not correct. Expected %d",i, i);
	}

	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
f0111b5d:	83 ec 0c             	sub    $0xc,%esp
f0111b60:	68 28 ab 12 f0       	push   $0xf012ab28
f0111b65:	e8 02 f4 fe ff       	call   f0100f6c <cprintf>
f0111b6a:	83 c4 10             	add    $0x10,%esp

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0111b6d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0111b74:	e9 98 00 00 00       	jmp    f0111c11 <test_free_block_BF+0x3f4>
	{
		free_block(startVAs[i*allocCntPerSize]);
f0111b79:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0111b7c:	89 d0                	mov    %edx,%eax
f0111b7e:	c1 e0 02             	shl    $0x2,%eax
f0111b81:	01 d0                	add    %edx,%eax
f0111b83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111b8a:	01 d0                	add    %edx,%eax
f0111b8c:	c1 e0 03             	shl    $0x3,%eax
f0111b8f:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111b96:	83 ec 0c             	sub    $0xc,%esp
f0111b99:	50                   	push   %eax
f0111b9a:	e8 f0 1f 01 00       	call   f0123b8f <free_block>
f0111b9f:	83 c4 10             	add    $0x10,%esp
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
f0111ba2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111ba5:	8b 0c 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%ecx
f0111bac:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0111baf:	89 d0                	mov    %edx,%eax
f0111bb1:	c1 e0 02             	shl    $0x2,%eax
f0111bb4:	01 d0                	add    %edx,%eax
f0111bb6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111bbd:	01 d0                	add    %edx,%eax
f0111bbf:	c1 e0 03             	shl    $0x3,%eax
f0111bc2:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111bc9:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0111bcc:	89 d8                	mov    %ebx,%eax
f0111bce:	c1 e0 02             	shl    $0x2,%eax
f0111bd1:	01 d8                	add    %ebx,%eax
f0111bd3:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0111bda:	01 d8                	add    %ebx,%eax
f0111bdc:	c1 e0 03             	shl    $0x3,%eax
f0111bdf:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111be6:	6a 00                	push   $0x0
f0111be8:	51                   	push   %ecx
f0111be9:	52                   	push   %edx
f0111bea:	50                   	push   %eax
f0111beb:	e8 95 df ff ff       	call   f010fb85 <check_block>
f0111bf0:	83 c4 10             	add    $0x10,%esp
f0111bf3:	85 c0                	test   %eax,%eax
f0111bf5:	75 17                	jne    f0111c0e <test_free_block_BF+0x3f1>
		{
			panic("3.1 Failed");
f0111bf7:	83 ec 04             	sub    $0x4,%esp
f0111bfa:	68 37 af 12 f0       	push   $0xf012af37
f0111bff:	68 fc 03 00 00       	push   $0x3fc
f0111c04:	68 48 a1 12 f0       	push   $0xf012a148
f0111c09:	e8 0c e7 fe ff       	call   f010031a <_panic>
	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0111c0e:	ff 45 d8             	incl   -0x28(%ebp)
f0111c11:	83 7d d8 06          	cmpl   $0x6,-0x28(%ebp)
f0111c15:	0f 8e 5e ff ff ff    	jle    f0111b79 <test_free_block_BF+0x35c>
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
		{
			panic("3.1 Failed");
		}
	}
	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0111c1b:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0111c22:	83 ec 0c             	sub    $0xc,%esp
f0111c25:	ff 75 c0             	pushl  -0x40(%ebp)
f0111c28:	e8 e0 df ff ff       	call   f010fc0d <check_list_size>
f0111c2d:	83 c4 10             	add    $0x10,%esp
f0111c30:	85 c0                	test   %eax,%eax
f0111c32:	75 17                	jne    f0111c4b <test_free_block_BF+0x42e>
	{
		panic("3.2 Failed");
f0111c34:	83 ec 04             	sub    $0x4,%esp
f0111c37:	68 42 af 12 f0       	push   $0xf012af42
f0111c3c:	68 02 04 00 00       	push   $0x402
f0111c41:	68 48 a1 12 f0       	push   $0xf012a148
f0111c46:	e8 cf e6 fe ff       	call   f010031a <_panic>
	}

	//Free last block
	free_block(startVAs[numOfAllocs*allocCntPerSize]);
f0111c4b:	a1 60 36 5c f0       	mov    0xf05c3660,%eax
f0111c50:	83 ec 0c             	sub    $0xc,%esp
f0111c53:	50                   	push   %eax
f0111c54:	e8 36 1f 01 00       	call   f0123b8f <free_block>
f0111c59:	83 c4 10             	add    $0x10,%esp
	if (check_block(startVAs[numOfAllocs*allocCntPerSize], startVAs[numOfAllocs*allocCntPerSize], remainSize, 0) == 0)
f0111c5c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f0111c5f:	8b 15 60 36 5c f0    	mov    0xf05c3660,%edx
f0111c65:	a1 60 36 5c f0       	mov    0xf05c3660,%eax
f0111c6a:	6a 00                	push   $0x0
f0111c6c:	51                   	push   %ecx
f0111c6d:	52                   	push   %edx
f0111c6e:	50                   	push   %eax
f0111c6f:	e8 11 df ff ff       	call   f010fb85 <check_block>
f0111c74:	83 c4 10             	add    $0x10,%esp
f0111c77:	85 c0                	test   %eax,%eax
f0111c79:	75 17                	jne    f0111c92 <test_free_block_BF+0x475>
		panic("3.3 Failed");
f0111c7b:	83 ec 04             	sub    $0x4,%esp
f0111c7e:	68 4d af 12 f0       	push   $0xf012af4d
f0111c83:	68 08 04 00 00       	push   $0x408
f0111c88:	68 48 a1 12 f0       	push   $0xf012a148
f0111c8d:	e8 88 e6 fe ff       	call   f010031a <_panic>

	//Reallocate last block
	actualSize = remainSize - sizeOfMetaData;
f0111c92:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111c95:	83 e8 08             	sub    $0x8,%eax
f0111c98:	89 45 cc             	mov    %eax,-0x34(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0111c9b:	83 ec 08             	sub    $0x8,%esp
f0111c9e:	6a 03                	push   $0x3
f0111ca0:	ff 75 cc             	pushl  -0x34(%ebp)
f0111ca3:	e8 cf 13 01 00       	call   f0123077 <alloc_block>
f0111ca8:	83 c4 10             	add    $0x10,%esp
f0111cab:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected_va = (curVA + sizeOfMetaData/2);
f0111cae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111cb1:	83 c0 04             	add    $0x4,%eax
f0111cb4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(check_block(va, expected_va, remainSize, 1) == 0)
f0111cb7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111cba:	6a 01                	push   $0x1
f0111cbc:	50                   	push   %eax
f0111cbd:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111cc0:	ff 75 c8             	pushl  -0x38(%ebp)
f0111cc3:	e8 bd de ff ff       	call   f010fb85 <check_block>
f0111cc8:	83 c4 10             	add    $0x10,%esp
f0111ccb:	85 c0                	test   %eax,%eax
f0111ccd:	75 17                	jne    f0111ce6 <test_free_block_BF+0x4c9>
		panic("3.4 Failed");
f0111ccf:	83 ec 04             	sub    $0x4,%esp
f0111cd2:	68 58 af 12 f0       	push   $0xf012af58
f0111cd7:	68 10 04 00 00       	push   $0x410
f0111cdc:	68 48 a1 12 f0       	push   $0xf012a148
f0111ce1:	e8 34 e6 fe ff       	call   f010031a <_panic>

	//Free block before last
	free_block(startVAs[numOfAllocs*allocCntPerSize - 1]);
f0111ce6:	a1 5c 36 5c f0       	mov    0xf05c365c,%eax
f0111ceb:	83 ec 0c             	sub    $0xc,%esp
f0111cee:	50                   	push   %eax
f0111cef:	e8 9b 1e 01 00       	call   f0123b8f <free_block>
f0111cf4:	83 c4 10             	add    $0x10,%esp
	if (check_block(startVAs[numOfAllocs*allocCntPerSize-1], startVAs[numOfAllocs*allocCntPerSize-1], allocSizes[numOfAllocs-1], 0) == 0)
f0111cf7:	8b 0d d0 fd 17 f0    	mov    0xf017fdd0,%ecx
f0111cfd:	8b 15 5c 36 5c f0    	mov    0xf05c365c,%edx
f0111d03:	a1 5c 36 5c f0       	mov    0xf05c365c,%eax
f0111d08:	6a 00                	push   $0x0
f0111d0a:	51                   	push   %ecx
f0111d0b:	52                   	push   %edx
f0111d0c:	50                   	push   %eax
f0111d0d:	e8 73 de ff ff       	call   f010fb85 <check_block>
f0111d12:	83 c4 10             	add    $0x10,%esp
f0111d15:	85 c0                	test   %eax,%eax
f0111d17:	75 17                	jne    f0111d30 <test_free_block_BF+0x513>
		panic("3.5 Failed");
f0111d19:	83 ec 04             	sub    $0x4,%esp
f0111d1c:	68 63 af 12 f0       	push   $0xf012af63
f0111d21:	68 15 04 00 00       	push   $0x415
f0111d26:	68 48 a1 12 f0       	push   $0xf012a148
f0111d2b:	e8 ea e5 fe ff       	call   f010031a <_panic>

	//Reallocate first block
	actualSize = allocSizes[0] - sizeOfMetaData;
f0111d30:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f0111d35:	83 e8 08             	sub    $0x8,%eax
f0111d38:	89 45 cc             	mov    %eax,-0x34(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0111d3b:	83 ec 08             	sub    $0x8,%esp
f0111d3e:	6a 03                	push   $0x3
f0111d40:	ff 75 cc             	pushl  -0x34(%ebp)
f0111d43:	e8 2f 13 01 00       	call   f0123077 <alloc_block>
f0111d48:	83 c4 10             	add    $0x10,%esp
f0111d4b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected_va = (void*)(KERNEL_HEAP_START + 2*sizeof(int));
f0111d4e:	c7 45 c4 08 00 00 f6 	movl   $0xf6000008,-0x3c(%ebp)
	if(check_block(va, expected_va, allocSizes[0], 1) == 0)
f0111d55:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f0111d5a:	6a 01                	push   $0x1
f0111d5c:	50                   	push   %eax
f0111d5d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111d60:	ff 75 c8             	pushl  -0x38(%ebp)
f0111d63:	e8 1d de ff ff       	call   f010fb85 <check_block>
f0111d68:	83 c4 10             	add    $0x10,%esp
f0111d6b:	85 c0                	test   %eax,%eax
f0111d6d:	75 17                	jne    f0111d86 <test_free_block_BF+0x569>
		panic("3.6 Failed");
f0111d6f:	83 ec 04             	sub    $0x4,%esp
f0111d72:	68 6e af 12 f0       	push   $0xf012af6e
f0111d77:	68 1d 04 00 00       	push   $0x41d
f0111d7c:	68 48 a1 12 f0       	push   $0xf012a148
f0111d81:	e8 94 e5 fe ff       	call   f010031a <_panic>

	//Free 2nd block
	free_block(startVAs[1]);
f0111d86:	a1 84 20 5c f0       	mov    0xf05c2084,%eax
f0111d8b:	83 ec 0c             	sub    $0xc,%esp
f0111d8e:	50                   	push   %eax
f0111d8f:	e8 fb 1d 01 00       	call   f0123b8f <free_block>
f0111d94:	83 c4 10             	add    $0x10,%esp
	if (check_block(startVAs[1], startVAs[1], allocSizes[0], 0) == 0)
f0111d97:	8b 0d b8 fd 17 f0    	mov    0xf017fdb8,%ecx
f0111d9d:	8b 15 84 20 5c f0    	mov    0xf05c2084,%edx
f0111da3:	a1 84 20 5c f0       	mov    0xf05c2084,%eax
f0111da8:	6a 00                	push   $0x0
f0111daa:	51                   	push   %ecx
f0111dab:	52                   	push   %edx
f0111dac:	50                   	push   %eax
f0111dad:	e8 d3 dd ff ff       	call   f010fb85 <check_block>
f0111db2:	83 c4 10             	add    $0x10,%esp
f0111db5:	85 c0                	test   %eax,%eax
f0111db7:	75 17                	jne    f0111dd0 <test_free_block_BF+0x5b3>
		panic("3.7 Failed");
f0111db9:	83 ec 04             	sub    $0x4,%esp
f0111dbc:	68 79 af 12 f0       	push   $0xf012af79
f0111dc1:	68 22 04 00 00       	push   $0x422
f0111dc6:	68 48 a1 12 f0       	push   $0xf012a148
f0111dcb:	e8 4a e5 fe ff       	call   f010031a <_panic>

	expectedNumOfFreeBlks++ ;
f0111dd0:	ff 45 c0             	incl   -0x40(%ebp)
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0111dd3:	83 ec 0c             	sub    $0xc,%esp
f0111dd6:	ff 75 c0             	pushl  -0x40(%ebp)
f0111dd9:	e8 2f de ff ff       	call   f010fc0d <check_list_size>
f0111dde:	83 c4 10             	add    $0x10,%esp
f0111de1:	85 c0                	test   %eax,%eax
f0111de3:	75 17                	jne    f0111dfc <test_free_block_BF+0x5df>
	{
		panic("3.8 Failed");
f0111de5:	83 ec 04             	sub    $0x4,%esp
f0111de8:	68 84 af 12 f0       	push   $0xf012af84
f0111ded:	68 27 04 00 00       	push   $0x427
f0111df2:	68 48 a1 12 f0       	push   $0xf012a148
f0111df7:	e8 1e e5 fe ff       	call   f010031a <_panic>
	}

	uint32 block_size, block_status;
	//====================================================================//
	/*free_block Scenario 2: Merge with previous ONLY (AT the tail)*/
	cprintf("	4: Free some allocated blocks [Merge with previous ONLY]\n\n") ;
f0111dfc:	83 ec 0c             	sub    $0xc,%esp
f0111dff:	68 58 ab 12 f0       	push   $0xf012ab58
f0111e04:	e8 63 f1 fe ff       	call   f0100f6c <cprintf>
f0111e09:	83 c4 10             	add    $0x10,%esp
	cprintf("		4.1: at the tail\n\n") ;
f0111e0c:	83 ec 0c             	sub    $0xc,%esp
f0111e0f:	68 94 ab 12 f0       	push   $0xf012ab94
f0111e14:	e8 53 f1 fe ff       	call   f0100f6c <cprintf>
f0111e19:	83 c4 10             	add    $0x10,%esp
	//Free last block (coalesce with previous)
	uint32 blockIndex = numOfAllocs*allocCntPerSize;
f0111e1c:	c7 45 bc 78 05 00 00 	movl   $0x578,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111e23:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e26:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111e2d:	83 ec 0c             	sub    $0xc,%esp
f0111e30:	50                   	push   %eax
f0111e31:	e8 59 1d 01 00       	call   f0123b8f <free_block>
f0111e36:	83 c4 10             	add    $0x10,%esp
	expected_size = remainSize + allocSizes[numOfAllocs-1];
f0111e39:	8b 15 d0 fd 17 f0    	mov    0xf017fdd0,%edx
f0111e3f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111e42:	01 d0                	add    %edx,%eax
f0111e44:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111e47:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e4a:	48                   	dec    %eax
f0111e4b:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111e52:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e55:	48                   	dec    %eax
f0111e56:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111e5d:	6a 00                	push   $0x0
f0111e5f:	ff 75 b8             	pushl  -0x48(%ebp)
f0111e62:	52                   	push   %edx
f0111e63:	50                   	push   %eax
f0111e64:	e8 1c dd ff ff       	call   f010fb85 <check_block>
f0111e69:	83 c4 10             	add    $0x10,%esp
f0111e6c:	85 c0                	test   %eax,%eax
f0111e6e:	75 17                	jne    f0111e87 <test_free_block_BF+0x66a>
	{
		panic("4.1 Failed");
f0111e70:	83 ec 04             	sub    $0x4,%esp
f0111e73:	68 8f af 12 f0       	push   $0xf012af8f
f0111e78:	68 35 04 00 00       	push   $0x435
f0111e7d:	68 48 a1 12 f0       	push   $0xf012a148
f0111e82:	e8 93 e4 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 3: Merge with previous ONLY (between 2 blocks)*/
	cprintf("		4.2: between 2 blocks\n\n") ;
f0111e87:	83 ec 0c             	sub    $0xc,%esp
f0111e8a:	68 a9 ab 12 f0       	push   $0xf012aba9
f0111e8f:	e8 d8 f0 fe ff       	call   f0100f6c <cprintf>
f0111e94:	83 c4 10             	add    $0x10,%esp
	blockIndex = 2*allocCntPerSize+1 ;
f0111e97:	c7 45 bc 91 01 00 00 	movl   $0x191,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111e9e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111ea1:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111ea8:	83 ec 0c             	sub    $0xc,%esp
f0111eab:	50                   	push   %eax
f0111eac:	e8 de 1c 01 00       	call   f0123b8f <free_block>
f0111eb1:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[2]+allocSizes[2];
f0111eb4:	8b 15 c0 fd 17 f0    	mov    0xf017fdc0,%edx
f0111eba:	a1 c0 fd 17 f0       	mov    0xf017fdc0,%eax
f0111ebf:	01 d0                	add    %edx,%eax
f0111ec1:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111ec4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111ec7:	48                   	dec    %eax
f0111ec8:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111ecf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111ed2:	48                   	dec    %eax
f0111ed3:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111eda:	6a 00                	push   $0x0
f0111edc:	ff 75 b8             	pushl  -0x48(%ebp)
f0111edf:	52                   	push   %edx
f0111ee0:	50                   	push   %eax
f0111ee1:	e8 9f dc ff ff       	call   f010fb85 <check_block>
f0111ee6:	83 c4 10             	add    $0x10,%esp
f0111ee9:	85 c0                	test   %eax,%eax
f0111eeb:	75 17                	jne    f0111f04 <test_free_block_BF+0x6e7>
	{
		panic("4.2 Failed");
f0111eed:	83 ec 04             	sub    $0x4,%esp
f0111ef0:	68 9a af 12 f0       	push   $0xf012af9a
f0111ef5:	68 3f 04 00 00       	push   $0x43f
f0111efa:	68 48 a1 12 f0       	push   $0xf012a148
f0111eff:	e8 16 e4 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 4: Merge with next ONLY (AT the head)*/
	cprintf("	5: Free some allocated blocks [Merge with next ONLY]\n\n") ;
f0111f04:	83 ec 0c             	sub    $0xc,%esp
f0111f07:	68 c4 ab 12 f0       	push   $0xf012abc4
f0111f0c:	e8 5b f0 fe ff       	call   f0100f6c <cprintf>
f0111f11:	83 c4 10             	add    $0x10,%esp
	cprintf("		5.1: at the head\n\n") ;
f0111f14:	83 ec 0c             	sub    $0xc,%esp
f0111f17:	68 fc ab 12 f0       	push   $0xf012abfc
f0111f1c:	e8 4b f0 fe ff       	call   f0100f6c <cprintf>
f0111f21:	83 c4 10             	add    $0x10,%esp
	blockIndex = 0 ;
f0111f24:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111f2b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f2e:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111f35:	83 ec 0c             	sub    $0xc,%esp
f0111f38:	50                   	push   %eax
f0111f39:	e8 51 1c 01 00       	call   f0123b8f <free_block>
f0111f3e:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[0]+allocSizes[0];
f0111f41:	8b 15 b8 fd 17 f0    	mov    0xf017fdb8,%edx
f0111f47:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f0111f4c:	01 d0                	add    %edx,%eax
f0111f4e:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f0111f51:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f54:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111f5b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f5e:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111f65:	6a 00                	push   $0x0
f0111f67:	ff 75 b8             	pushl  -0x48(%ebp)
f0111f6a:	52                   	push   %edx
f0111f6b:	50                   	push   %eax
f0111f6c:	e8 14 dc ff ff       	call   f010fb85 <check_block>
f0111f71:	83 c4 10             	add    $0x10,%esp
f0111f74:	85 c0                	test   %eax,%eax
f0111f76:	75 17                	jne    f0111f8f <test_free_block_BF+0x772>
	{
		panic("5.1 Failed");
f0111f78:	83 ec 04             	sub    $0x4,%esp
f0111f7b:	68 a5 af 12 f0       	push   $0xf012afa5
f0111f80:	68 4a 04 00 00       	push   $0x44a
f0111f85:	68 48 a1 12 f0       	push   $0xf012a148
f0111f8a:	e8 8b e3 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 5: Merge with next ONLY (between 2 blocks)*/
	cprintf("		5.2: between 2 blocks\n\n") ;
f0111f8f:	83 ec 0c             	sub    $0xc,%esp
f0111f92:	68 11 ac 12 f0       	push   $0xf012ac11
f0111f97:	e8 d0 ef fe ff       	call   f0100f6c <cprintf>
f0111f9c:	83 c4 10             	add    $0x10,%esp
	blockIndex = 1*allocCntPerSize - 1 ;
f0111f9f:	c7 45 bc c7 00 00 00 	movl   $0xc7,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111fa6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111fa9:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111fb0:	83 ec 0c             	sub    $0xc,%esp
f0111fb3:	50                   	push   %eax
f0111fb4:	e8 d6 1b 01 00       	call   f0123b8f <free_block>
f0111fb9:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[0]+allocSizes[1];
f0111fbc:	8b 15 b8 fd 17 f0    	mov    0xf017fdb8,%edx
f0111fc2:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f0111fc7:	01 d0                	add    %edx,%eax
f0111fc9:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f0111fcc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111fcf:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0111fd6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111fd9:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0111fe0:	6a 00                	push   $0x0
f0111fe2:	ff 75 b8             	pushl  -0x48(%ebp)
f0111fe5:	52                   	push   %edx
f0111fe6:	50                   	push   %eax
f0111fe7:	e8 99 db ff ff       	call   f010fb85 <check_block>
f0111fec:	83 c4 10             	add    $0x10,%esp
f0111fef:	85 c0                	test   %eax,%eax
f0111ff1:	75 17                	jne    f011200a <test_free_block_BF+0x7ed>
	{
		panic("5.2 Failed");
f0111ff3:	83 ec 04             	sub    $0x4,%esp
f0111ff6:	68 b0 af 12 f0       	push   $0xf012afb0
f0111ffb:	68 54 04 00 00       	push   $0x454
f0112000:	68 48 a1 12 f0       	push   $0xf012a148
f0112005:	e8 10 e3 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 6: Merge with prev & next */
	cprintf("	6: Free some allocated blocks [Merge with previous & next]\n\n") ;
f011200a:	83 ec 0c             	sub    $0xc,%esp
f011200d:	68 2c ac 12 f0       	push   $0xf012ac2c
f0112012:	e8 55 ef fe ff       	call   f0100f6c <cprintf>
f0112017:	83 c4 10             	add    $0x10,%esp
	blockIndex = 4*allocCntPerSize - 2 ;
f011201a:	c7 45 bc 1e 03 00 00 	movl   $0x31e,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0112021:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112024:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f011202b:	83 ec 0c             	sub    $0xc,%esp
f011202e:	50                   	push   %eax
f011202f:	e8 5b 1b 01 00       	call   f0123b8f <free_block>
f0112034:	83 c4 10             	add    $0x10,%esp

	blockIndex = 4*allocCntPerSize - 1 ;
f0112037:	c7 45 bc 1f 03 00 00 	movl   $0x31f,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f011203e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112041:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112048:	83 ec 0c             	sub    $0xc,%esp
f011204b:	50                   	push   %eax
f011204c:	e8 3e 1b 01 00       	call   f0123b8f <free_block>
f0112051:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[3]+allocSizes[3]+allocSizes[4];
f0112054:	8b 15 c4 fd 17 f0    	mov    0xf017fdc4,%edx
f011205a:	a1 c4 fd 17 f0       	mov    0xf017fdc4,%eax
f011205f:	01 c2                	add    %eax,%edx
f0112061:	a1 c8 fd 17 f0       	mov    0xf017fdc8,%eax
f0112066:	01 d0                	add    %edx,%eax
f0112068:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f011206b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011206e:	48                   	dec    %eax
f011206f:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f0112076:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112079:	48                   	dec    %eax
f011207a:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112081:	6a 00                	push   $0x0
f0112083:	ff 75 b8             	pushl  -0x48(%ebp)
f0112086:	52                   	push   %edx
f0112087:	50                   	push   %eax
f0112088:	e8 f8 da ff ff       	call   f010fb85 <check_block>
f011208d:	83 c4 10             	add    $0x10,%esp
f0112090:	85 c0                	test   %eax,%eax
f0112092:	75 17                	jne    f01120ab <test_free_block_BF+0x88e>
	{
		panic("6.1 Failed");
f0112094:	83 ec 04             	sub    $0x4,%esp
f0112097:	68 bb af 12 f0       	push   $0xf012afbb
f011209c:	68 61 04 00 00       	push   $0x461
f01120a1:	68 48 a1 12 f0       	push   $0xf012a148
f01120a6:	e8 6f e2 fe ff       	call   f010031a <_panic>
	}
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f01120ab:	83 ec 0c             	sub    $0xc,%esp
f01120ae:	ff 75 c0             	pushl  -0x40(%ebp)
f01120b1:	e8 57 db ff ff       	call   f010fc0d <check_list_size>
f01120b6:	83 c4 10             	add    $0x10,%esp
f01120b9:	85 c0                	test   %eax,%eax
f01120bb:	75 17                	jne    f01120d4 <test_free_block_BF+0x8b7>
	{
		panic("6.2 Failed");
f01120bd:	83 ec 04             	sub    $0x4,%esp
f01120c0:	68 c6 af 12 f0       	push   $0xf012afc6
f01120c5:	68 65 04 00 00       	push   $0x465
f01120ca:	68 48 a1 12 f0       	push   $0xf012a148
f01120cf:	e8 46 e2 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*Allocate After Free Scenarios */
	void* expected = NULL;
f01120d4:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	{
		//Consume 1st 7KB Block
		actualSize = 7*kilo - sizeOfMetaData ;
f01120db:	c7 45 cc f8 1b 00 00 	movl   $0x1bf8,-0x34(%ebp)
		expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f01120e2:	c7 45 b0 02 00 00 00 	movl   $0x2,-0x50(%ebp)
f01120e9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01120ec:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01120ef:	01 d0                	add    %edx,%eax
f01120f1:	83 c0 07             	add    $0x7,%eax
f01120f4:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01120f7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01120fa:	ba 00 00 00 00       	mov    $0x0,%edx
f01120ff:	f7 75 b0             	divl   -0x50(%ebp)
f0112102:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112105:	29 d0                	sub    %edx,%eax
f0112107:	89 45 b8             	mov    %eax,-0x48(%ebp)
		va = alloc_block(actualSize, DA_BF);
f011210a:	83 ec 08             	sub    $0x8,%esp
f011210d:	6a 03                	push   $0x3
f011210f:	ff 75 cc             	pushl  -0x34(%ebp)
f0112112:	e8 60 0f 01 00       	call   f0123077 <alloc_block>
f0112117:	83 c4 10             	add    $0x10,%esp
f011211a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		//Check returned va
		expected = (void*)(startVAs[6*allocCntPerSize]);
f011211d:	a1 40 33 5c f0       	mov    0xf05c3340,%eax
f0112122:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if (check_block(va, expected, expected_size, 1) == 0)
f0112125:	6a 01                	push   $0x1
f0112127:	ff 75 b8             	pushl  -0x48(%ebp)
f011212a:	ff 75 b4             	pushl  -0x4c(%ebp)
f011212d:	ff 75 c8             	pushl  -0x38(%ebp)
f0112130:	e8 50 da ff ff       	call   f010fb85 <check_block>
f0112135:	83 c4 10             	add    $0x10,%esp
f0112138:	85 c0                	test   %eax,%eax
f011213a:	75 17                	jne    f0112153 <test_free_block_BF+0x936>
		{
			panic("6.3 Failed");
f011213c:	83 ec 04             	sub    $0x4,%esp
f011213f:	68 d1 af 12 f0       	push   $0xf012afd1
f0112144:	68 73 04 00 00       	push   $0x473
f0112149:	68 48 a1 12 f0       	push   $0xf012a148
f011214e:	e8 c7 e1 fe ff       	call   f010031a <_panic>
		}
		expectedNumOfFreeBlks--;
f0112153:	ff 4d c0             	decl   -0x40(%ebp)
	}

	cprintf("	7: Allocate After Free [should be placed in coalesced blocks]\n\n") ;
f0112156:	83 ec 0c             	sub    $0xc,%esp
f0112159:	68 6c ac 12 f0       	push   $0xf012ac6c
f011215e:	e8 09 ee fe ff       	call   f0100f6c <cprintf>
f0112163:	83 c4 10             	add    $0x10,%esp

	cprintf("		7.1: in block coalesces with PREV\n\n") ;
f0112166:	83 ec 0c             	sub    $0xc,%esp
f0112169:	68 dc af 12 f0       	push   $0xf012afdc
f011216e:	e8 f9 ed fe ff       	call   f0100f6c <cprintf>
f0112173:	83 c4 10             	add    $0x10,%esp
	actualSize = 2*kilo - sizeOfMetaData;
f0112176:	c7 45 cc f8 07 00 00 	movl   $0x7f8,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f011217d:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
f0112184:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0112187:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011218a:	01 d0                	add    %edx,%eax
f011218c:	83 c0 07             	add    $0x7,%eax
f011218f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0112192:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112195:	ba 00 00 00 00       	mov    $0x0,%edx
f011219a:	f7 75 a8             	divl   -0x58(%ebp)
f011219d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01121a0:	29 d0                	sub    %edx,%eax
f01121a2:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f01121a5:	83 ec 08             	sub    $0x8,%esp
f01121a8:	6a 03                	push   $0x3
f01121aa:	ff 75 cc             	pushl  -0x34(%ebp)
f01121ad:	e8 c5 0e 01 00       	call   f0123077 <alloc_block>
f01121b2:	83 c4 10             	add    $0x10,%esp
f01121b5:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[2*allocCntPerSize];
f01121b8:	a1 c0 26 5c f0       	mov    0xf05c26c0,%eax
f01121bd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01121c0:	6a 01                	push   $0x1
f01121c2:	ff 75 b8             	pushl  -0x48(%ebp)
f01121c5:	ff 75 b4             	pushl  -0x4c(%ebp)
f01121c8:	ff 75 c8             	pushl  -0x38(%ebp)
f01121cb:	e8 b5 d9 ff ff       	call   f010fb85 <check_block>
f01121d0:	83 c4 10             	add    $0x10,%esp
f01121d3:	85 c0                	test   %eax,%eax
f01121d5:	75 17                	jne    f01121ee <test_free_block_BF+0x9d1>
	{
		panic("7.1 Failed");
f01121d7:	83 ec 04             	sub    $0x4,%esp
f01121da:	68 02 b0 12 f0       	push   $0xf012b002
f01121df:	68 82 04 00 00       	push   $0x482
f01121e4:	68 48 a1 12 f0       	push   $0xf012a148
f01121e9:	e8 2c e1 fe ff       	call   f010031a <_panic>
	}

	expectedNumOfFreeBlks--;
f01121ee:	ff 4d c0             	decl   -0x40(%ebp)

	actualSize = 8*kilo;
f01121f1:	c7 45 cc 00 20 00 00 	movl   $0x2000,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f01121f8:	c7 45 a0 02 00 00 00 	movl   $0x2,-0x60(%ebp)
f01121ff:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0112202:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112205:	01 d0                	add    %edx,%eax
f0112207:	83 c0 07             	add    $0x7,%eax
f011220a:	89 45 9c             	mov    %eax,-0x64(%ebp)
f011220d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112210:	ba 00 00 00 00       	mov    $0x0,%edx
f0112215:	f7 75 a0             	divl   -0x60(%ebp)
f0112218:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011221b:	29 d0                	sub    %edx,%eax
f011221d:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0112220:	83 ec 08             	sub    $0x8,%esp
f0112223:	6a 03                	push   $0x3
f0112225:	ff 75 cc             	pushl  -0x34(%ebp)
f0112228:	e8 4a 0e 01 00       	call   f0123077 <alloc_block>
f011222d:	83 c4 10             	add    $0x10,%esp
f0112230:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[numOfAllocs*allocCntPerSize-1];
f0112233:	a1 5c 36 5c f0       	mov    0xf05c365c,%eax
f0112238:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f011223b:	6a 01                	push   $0x1
f011223d:	ff 75 b8             	pushl  -0x48(%ebp)
f0112240:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112243:	ff 75 c8             	pushl  -0x38(%ebp)
f0112246:	e8 3a d9 ff ff       	call   f010fb85 <check_block>
f011224b:	83 c4 10             	add    $0x10,%esp
f011224e:	85 c0                	test   %eax,%eax
f0112250:	75 17                	jne    f0112269 <test_free_block_BF+0xa4c>
	{
		panic("7.2 Failed");
f0112252:	83 ec 04             	sub    $0x4,%esp
f0112255:	68 0d b0 12 f0       	push   $0xf012b00d
f011225a:	68 8e 04 00 00       	push   $0x48e
f011225f:	68 48 a1 12 f0       	push   $0xf012a148
f0112264:	e8 b1 e0 fe ff       	call   f010031a <_panic>
	}

	cprintf("		7.2: in block coalesces with PREV & NEXT\n\n") ;
f0112269:	83 ec 0c             	sub    $0xc,%esp
f011226c:	68 50 ad 12 f0       	push   $0xf012ad50
f0112271:	e8 f6 ec fe ff       	call   f0100f6c <cprintf>
f0112276:	83 c4 10             	add    $0x10,%esp
	actualSize = 2*kilo + 1;
f0112279:	c7 45 cc 01 08 00 00 	movl   $0x801,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f0112280:	c7 45 98 02 00 00 00 	movl   $0x2,-0x68(%ebp)
f0112287:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011228a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011228d:	01 d0                	add    %edx,%eax
f011228f:	83 c0 07             	add    $0x7,%eax
f0112292:	89 45 94             	mov    %eax,-0x6c(%ebp)
f0112295:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112298:	ba 00 00 00 00       	mov    $0x0,%edx
f011229d:	f7 75 98             	divl   -0x68(%ebp)
f01122a0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01122a3:	29 d0                	sub    %edx,%eax
f01122a5:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f01122a8:	83 ec 08             	sub    $0x8,%esp
f01122ab:	6a 03                	push   $0x3
f01122ad:	ff 75 cc             	pushl  -0x34(%ebp)
f01122b0:	e8 c2 0d 01 00       	call   f0123077 <alloc_block>
f01122b5:	83 c4 10             	add    $0x10,%esp
f01122b8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[4*allocCntPerSize - 2];
f01122bb:	a1 f8 2c 5c f0       	mov    0xf05c2cf8,%eax
f01122c0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01122c3:	6a 01                	push   $0x1
f01122c5:	ff 75 b8             	pushl  -0x48(%ebp)
f01122c8:	ff 75 b4             	pushl  -0x4c(%ebp)
f01122cb:	ff 75 c8             	pushl  -0x38(%ebp)
f01122ce:	e8 b2 d8 ff ff       	call   f010fb85 <check_block>
f01122d3:	83 c4 10             	add    $0x10,%esp
f01122d6:	85 c0                	test   %eax,%eax
f01122d8:	75 17                	jne    f01122f1 <test_free_block_BF+0xad4>
	{
		panic("7.3 Failed");
f01122da:	83 ec 04             	sub    $0x4,%esp
f01122dd:	68 18 b0 12 f0       	push   $0xf012b018
f01122e2:	68 99 04 00 00       	push   $0x499
f01122e7:	68 48 a1 12 f0       	push   $0xf012a148
f01122ec:	e8 29 e0 fe ff       	call   f010031a <_panic>
	}

	cprintf("		7.3: in block coalesces with NEXT [INTERNAL FRAGMENTATION]\n\n") ;
f01122f1:	83 ec 0c             	sub    $0xc,%esp
f01122f4:	68 24 b0 12 f0       	push   $0xf012b024
f01122f9:	e8 6e ec fe ff       	call   f0100f6c <cprintf>
f01122fe:	83 c4 10             	add    $0x10,%esp
	actualSize = 4*kilo + 10;
f0112301:	c7 45 cc 0a 10 00 00 	movl   $0x100a,-0x34(%ebp)
	expected_size = allocSizes[0]+allocSizes[1]; //ROUNDUP(actualSize + sizeOfMetaData,2) ;
f0112308:	8b 15 b8 fd 17 f0    	mov    0xf017fdb8,%edx
f011230e:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f0112313:	01 d0                	add    %edx,%eax
f0112315:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0112318:	83 ec 08             	sub    $0x8,%esp
f011231b:	6a 03                	push   $0x3
f011231d:	ff 75 cc             	pushl  -0x34(%ebp)
f0112320:	e8 52 0d 01 00       	call   f0123077 <alloc_block>
f0112325:	83 c4 10             	add    $0x10,%esp
f0112328:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[1*allocCntPerSize - 1];
f011232b:	a1 9c 23 5c f0       	mov    0xf05c239c,%eax
f0112330:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0112333:	6a 01                	push   $0x1
f0112335:	ff 75 b8             	pushl  -0x48(%ebp)
f0112338:	ff 75 b4             	pushl  -0x4c(%ebp)
f011233b:	ff 75 c8             	pushl  -0x38(%ebp)
f011233e:	e8 42 d8 ff ff       	call   f010fb85 <check_block>
f0112343:	83 c4 10             	add    $0x10,%esp
f0112346:	85 c0                	test   %eax,%eax
f0112348:	75 17                	jne    f0112361 <test_free_block_BF+0xb44>
	{
		panic("7.4 Failed");
f011234a:	83 ec 04             	sub    $0x4,%esp
f011234d:	68 63 b0 12 f0       	push   $0xf012b063
f0112352:	68 a4 04 00 00       	push   $0x4a4
f0112357:	68 48 a1 12 f0       	push   $0xf012a148
f011235c:	e8 b9 df fe ff       	call   f010031a <_panic>
	}
	expectedNumOfFreeBlks--;
f0112361:	ff 4d c0             	decl   -0x40(%ebp)

	actualSize = 5*kilo - sizeOfMetaData;
f0112364:	c7 45 cc f8 13 00 00 	movl   $0x13f8,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f011236b:	c7 45 90 02 00 00 00 	movl   $0x2,-0x70(%ebp)
f0112372:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0112375:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112378:	01 d0                	add    %edx,%eax
f011237a:	83 c0 07             	add    $0x7,%eax
f011237d:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0112380:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112383:	ba 00 00 00 00       	mov    $0x0,%edx
f0112388:	f7 75 90             	divl   -0x70(%ebp)
f011238b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011238e:	29 d0                	sub    %edx,%eax
f0112390:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0112393:	83 ec 08             	sub    $0x8,%esp
f0112396:	6a 03                	push   $0x3
f0112398:	ff 75 cc             	pushl  -0x34(%ebp)
f011239b:	e8 d7 0c 01 00       	call   f0123077 <alloc_block>
f01123a0:	83 c4 10             	add    $0x10,%esp
f01123a3:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + sizeOfMetaData);
f01123a6:	c7 45 b4 08 00 00 f6 	movl   $0xf6000008,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01123ad:	6a 01                	push   $0x1
f01123af:	ff 75 b8             	pushl  -0x48(%ebp)
f01123b2:	ff 75 b4             	pushl  -0x4c(%ebp)
f01123b5:	ff 75 c8             	pushl  -0x38(%ebp)
f01123b8:	e8 c8 d7 ff ff       	call   f010fb85 <check_block>
f01123bd:	83 c4 10             	add    $0x10,%esp
f01123c0:	85 c0                	test   %eax,%eax
f01123c2:	75 17                	jne    f01123db <test_free_block_BF+0xbbe>
	{
		panic("7.5 Failed");
f01123c4:	83 ec 04             	sub    $0x4,%esp
f01123c7:	68 6e b0 12 f0       	push   $0xf012b06e
f01123cc:	68 af 04 00 00       	push   $0x4af
f01123d1:	68 48 a1 12 f0       	push   $0xf012a148
f01123d6:	e8 3f df fe ff       	call   f010031a <_panic>
	}

	actualSize = 3*kilo - sizeOfMetaData;
f01123db:	c7 45 cc f8 0b 00 00 	movl   $0xbf8,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f01123e2:	c7 45 88 02 00 00 00 	movl   $0x2,-0x78(%ebp)
f01123e9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01123ec:	8b 45 88             	mov    -0x78(%ebp),%eax
f01123ef:	01 d0                	add    %edx,%eax
f01123f1:	83 c0 07             	add    $0x7,%eax
f01123f4:	89 45 84             	mov    %eax,-0x7c(%ebp)
f01123f7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01123fa:	ba 00 00 00 00       	mov    $0x0,%edx
f01123ff:	f7 75 88             	divl   -0x78(%ebp)
f0112402:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0112405:	29 d0                	sub    %edx,%eax
f0112407:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f011240a:	83 ec 08             	sub    $0x8,%esp
f011240d:	6a 03                	push   $0x3
f011240f:	ff 75 cc             	pushl  -0x34(%ebp)
f0112412:	e8 60 0c 01 00       	call   f0123077 <alloc_block>
f0112417:	83 c4 10             	add    $0x10,%esp
f011241a:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + 5*kilo + sizeOfMetaData);
f011241d:	c7 45 b4 08 14 00 f6 	movl   $0xf6001408,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0112424:	6a 01                	push   $0x1
f0112426:	ff 75 b8             	pushl  -0x48(%ebp)
f0112429:	ff 75 b4             	pushl  -0x4c(%ebp)
f011242c:	ff 75 c8             	pushl  -0x38(%ebp)
f011242f:	e8 51 d7 ff ff       	call   f010fb85 <check_block>
f0112434:	83 c4 10             	add    $0x10,%esp
f0112437:	85 c0                	test   %eax,%eax
f0112439:	75 17                	jne    f0112452 <test_free_block_BF+0xc35>
	{
		panic("7.6 Failed");
f011243b:	83 ec 04             	sub    $0x4,%esp
f011243e:	68 79 b0 12 f0       	push   $0xf012b079
f0112443:	68 b9 04 00 00       	push   $0x4b9
f0112448:	68 48 a1 12 f0       	push   $0xf012a148
f011244d:	e8 c8 de fe ff       	call   f010031a <_panic>
	}
	expectedNumOfFreeBlks--;
f0112452:	ff 4d c0             	decl   -0x40(%ebp)

	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0112455:	83 ec 0c             	sub    $0xc,%esp
f0112458:	ff 75 c0             	pushl  -0x40(%ebp)
f011245b:	e8 ad d7 ff ff       	call   f010fc0d <check_list_size>
f0112460:	83 c4 10             	add    $0x10,%esp
f0112463:	85 c0                	test   %eax,%eax
f0112465:	75 17                	jne    f011247e <test_free_block_BF+0xc61>
	{
		panic("7.7 Failed");
f0112467:	83 ec 04             	sub    $0x4,%esp
f011246a:	68 84 b0 12 f0       	push   $0xf012b084
f011246f:	68 bf 04 00 00       	push   $0x4bf
f0112474:	68 48 a1 12 f0       	push   $0xf012a148
f0112479:	e8 9c de fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");
f011247e:	83 ec 0c             	sub    $0xc,%esp
f0112481:	68 90 b0 12 f0       	push   $0xf012b090
f0112486:	e8 e1 ea fe ff       	call   f0100f6c <cprintf>
f011248b:	83 c4 10             	add    $0x10,%esp

}
f011248e:	90                   	nop
f011248f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0112492:	c9                   	leave  
f0112493:	c3                   	ret    

f0112494 <test_free_block_NF>:

void test_free_block_NF()
{
f0112494:	55                   	push   %ebp
f0112495:	89 e5                	mov    %esp,%ebp
f0112497:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011249a:	83 ec 04             	sub    $0x4,%esp
f011249d:	68 d9 b0 12 f0       	push   $0xf012b0d9
f01124a2:	68 c8 04 00 00       	push   $0x4c8
f01124a7:	68 48 a1 12 f0       	push   $0xf012a148
f01124ac:	e8 69 de fe ff       	call   f010031a <_panic>

f01124b1 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f01124b1:	55                   	push   %ebp
f01124b2:	89 e5                	mov    %esp,%ebp
f01124b4:	81 ec 98 00 00 00    	sub    $0x98,%esp
#endif

	//TODO: [PROJECT'24.MS1 - #09] [3] DYNAMIC ALLOCATOR - test_realloc_block_FF()
	//CHECK MISSING CASES AND TRY TO TEST THEM !

	cprintf("===================================================\n");
f01124ba:	83 ec 0c             	sub    $0xc,%esp
f01124bd:	68 ec b0 12 f0       	push   $0xf012b0ec
f01124c2:	e8 a5 ea fe ff       	call   f0100f6c <cprintf>
f01124c7:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A PARTIAL TEST FOR REALLOC******\n") ;
f01124ca:	83 ec 0c             	sub    $0xc,%esp
f01124cd:	68 24 b1 12 f0       	push   $0xf012b124
f01124d2:	e8 95 ea fe ff       	call   f0100f6c <cprintf>
f01124d7:	83 c4 10             	add    $0x10,%esp
	cprintf("You need to pick-up the missing tests and test them\n") ;
f01124da:	83 ec 0c             	sub    $0xc,%esp
f01124dd:	68 5c b1 12 f0       	push   $0xf012b15c
f01124e2:	e8 85 ea fe ff       	call   f0100f6c <cprintf>
f01124e7:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f01124ea:	83 ec 0c             	sub    $0xc,%esp
f01124ed:	68 ec b0 12 f0       	push   $0xf012b0ec
f01124f2:	e8 75 ea fe ff       	call   f0100f6c <cprintf>
f01124f7:	83 c4 10             	add    $0x10,%esp

	int eval = 0;
f01124fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct;

	int initAllocatedSpace = 3*Mega;
f0112501:	c7 45 c8 00 00 30 00 	movl   $0x300000,-0x38(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f0112508:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011250b:	83 ec 08             	sub    $0x8,%esp
f011250e:	50                   	push   %eax
f011250f:	68 00 00 00 f6       	push   $0xf6000000
f0112514:	e8 8b 0c 01 00       	call   f01231a4 <initialize_dynamic_allocator>
f0112519:	83 c4 10             	add    $0x10,%esp
	void * va, *expectedVA ;
	//====================================================================//
	//[1] Test calling realloc with VA = NULL. It should call malloc
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("1: Test calling realloc with VA = NULL.[10%]\n\n") ;
f011251c:	83 ec 0c             	sub    $0xc,%esp
f011251f:	68 94 b1 12 f0       	push   $0xf012b194
f0112524:	e8 43 ea fe ff       	call   f0100f6c <cprintf>
f0112529:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011252c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	int totalSizes = 0;
f0112533:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f011253a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0112541:	eb 2a                	jmp    f011256d <test_realloc_block_FF+0xbc>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f0112543:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0112546:	8b 14 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%edx
f011254d:	89 d0                	mov    %edx,%eax
f011254f:	c1 e0 02             	shl    $0x2,%eax
f0112552:	01 d0                	add    %edx,%eax
f0112554:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011255b:	01 d0                	add    %edx,%eax
f011255d:	c1 e0 03             	shl    $0x3,%eax
f0112560:	89 c2                	mov    %eax,%edx
f0112562:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112565:	01 d0                	add    %edx,%eax
f0112567:	89 45 ec             	mov    %eax,-0x14(%ebp)
	/* Try to allocate set of blocks with different sizes*/
	cprintf("1: Test calling realloc with VA = NULL.[10%]\n\n") ;
	is_correct = 1;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f011256a:	ff 45 e8             	incl   -0x18(%ebp)
f011256d:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f0112571:	7e d0                	jle    f0112543 <test_realloc_block_FF+0x92>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f0112573:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0112576:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0112579:	83 e8 08             	sub    $0x8,%eax
f011257c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (remainSize <= 0)
f011257f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0112583:	7f 17                	jg     f011259c <test_realloc_block_FF+0xeb>
		panic("test_realloc_block_FF is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f0112585:	83 ec 04             	sub    $0x4,%esp
f0112588:	68 c4 b1 12 f0       	push   $0xf012b1c4
f011258d:	68 ef 04 00 00       	push   $0x4ef
f0112592:	68 48 a1 12 f0       	push   $0xf012a148
f0112597:	e8 7e dd fe ff       	call   f010031a <_panic>

	int idx = 0;
f011259c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) /*BEG block*/ ;
f01125a3:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize, expectedSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01125aa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01125b1:	e9 2f 01 00 00       	jmp    f01126e5 <test_realloc_block_FF+0x234>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01125b6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01125bd:	e9 13 01 00 00       	jmp    f01126d5 <test_realloc_block_FF+0x224>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f01125c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01125c5:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f01125cc:	83 e8 08             	sub    $0x8,%eax
f01125cf:	89 45 c0             	mov    %eax,-0x40(%ebp)
			expectedSize = ROUNDUP(actualSize + sizeOfMetaData, 2);
f01125d2:	c7 45 bc 02 00 00 00 	movl   $0x2,-0x44(%ebp)
f01125d9:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01125dc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01125df:	01 d0                	add    %edx,%eax
f01125e1:	83 c0 07             	add    $0x7,%eax
f01125e4:	89 45 b8             	mov    %eax,-0x48(%ebp)
f01125e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01125ea:	ba 00 00 00 00       	mov    $0x0,%edx
f01125ef:	f7 75 bc             	divl   -0x44(%ebp)
f01125f2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01125f5:	29 d0                	sub    %edx,%eax
f01125f7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			expectedVA = (curVA + sizeOfMetaData/2);
f01125fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01125fd:	83 c0 04             	add    $0x4,%eax
f0112600:	89 45 b0             	mov    %eax,-0x50(%ebp)
			va = startVAs[idx] = realloc_block_FF(NULL, actualSize);
f0112603:	83 ec 08             	sub    $0x8,%esp
f0112606:	ff 75 c0             	pushl  -0x40(%ebp)
f0112609:	6a 00                	push   $0x0
f011260b:	e8 40 16 01 00       	call   f0123c50 <realloc_block_FF>
f0112610:	83 c4 10             	add    $0x10,%esp
f0112613:	89 c2                	mov    %eax,%edx
f0112615:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112618:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f011261f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112622:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112629:	89 45 ac             	mov    %eax,-0x54(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f011262c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011262f:	d1 e8                	shr    %eax
f0112631:	89 c2                	mov    %eax,%edx
f0112633:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112636:	01 c2                	add    %eax,%edx
f0112638:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011263b:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0112642:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112645:	8d 50 fe             	lea    -0x2(%eax),%edx
f0112648:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011264b:	01 c2                	add    %eax,%edx
f011264d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112650:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
			if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112657:	6a 01                	push   $0x1
f0112659:	ff 75 b4             	pushl  -0x4c(%ebp)
f011265c:	ff 75 b0             	pushl  -0x50(%ebp)
f011265f:	ff 75 ac             	pushl  -0x54(%ebp)
f0112662:	e8 1e d5 ff ff       	call   f010fb85 <check_block>
f0112667:	83 c4 10             	add    $0x10,%esp
f011266a:	85 c0                	test   %eax,%eax
f011266c:	75 24                	jne    f0112692 <test_realloc_block_FF+0x1e1>
			{
				panic("test_realloc_block_FF #1.1.%d: WRONG ALLOC - it return wrong address. Expected %x, Actual %x", idx, curVA + sizeOfMetaData ,va);
f011266e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112671:	83 c0 08             	add    $0x8,%eax
f0112674:	83 ec 08             	sub    $0x8,%esp
f0112677:	ff 75 ac             	pushl  -0x54(%ebp)
f011267a:	50                   	push   %eax
f011267b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011267e:	68 44 b2 12 f0       	push   $0xf012b244
f0112683:	68 00 05 00 00       	push   $0x500
f0112688:	68 48 a1 12 f0       	push   $0xf012a148
f011268d:	e8 88 dc fe ff       	call   f010031a <_panic>
			}
			curVA += allocSizes[i] ;
f0112692:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112695:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f011269c:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f011269f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01126a2:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f01126a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01126ac:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f01126af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01126b2:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f01126b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01126bc:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f01126bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01126c2:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f01126c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01126cc:	66 89 02             	mov    %ax,(%edx)
			idx++;
f01126cf:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) /*BEG block*/ ;
	uint32 actualSize, expectedSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01126d2:	ff 45 d8             	incl   -0x28(%ebp)
f01126d5:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f01126dc:	0f 8e e0 fe ff ff    	jle    f01125c2 <test_realloc_block_FF+0x111>
		panic("test_realloc_block_FF is not configured correctly. Consider updating the initial allocated space OR the required allocations");

	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) /*BEG block*/ ;
	uint32 actualSize, expectedSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01126e2:	ff 45 dc             	incl   -0x24(%ebp)
f01126e5:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f01126e9:	0f 8e c7 fe ff ff    	jle    f01125b6 <test_realloc_block_FF+0x105>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f01126ef:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01126f2:	83 e8 08             	sub    $0x8,%eax
f01126f5:	89 45 c0             	mov    %eax,-0x40(%ebp)
	expectedSize = ROUNDUP(actualSize + sizeOfMetaData, 2);
f01126f8:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
f01126ff:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0112702:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112705:	01 d0                	add    %edx,%eax
f0112707:	83 c0 07             	add    $0x7,%eax
f011270a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f011270d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112710:	ba 00 00 00 00       	mov    $0x0,%edx
f0112715:	f7 75 a8             	divl   -0x58(%ebp)
f0112718:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011271b:	29 d0                	sub    %edx,%eax
f011271d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	expectedVA = (curVA + sizeOfMetaData/2);
f0112720:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112723:	83 c0 04             	add    $0x4,%eax
f0112726:	89 45 b0             	mov    %eax,-0x50(%ebp)

	va = startVAs[idx] = realloc_block_FF(NULL, actualSize);
f0112729:	83 ec 08             	sub    $0x8,%esp
f011272c:	ff 75 c0             	pushl  -0x40(%ebp)
f011272f:	6a 00                	push   $0x0
f0112731:	e8 1a 15 01 00       	call   f0123c50 <realloc_block_FF>
f0112736:	83 c4 10             	add    $0x10,%esp
f0112739:	89 c2                	mov    %eax,%edx
f011273b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011273e:	89 14 85 80 20 5c f0 	mov    %edx,-0xfa3df80(,%eax,4)
f0112745:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112748:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f011274f:	89 45 ac             	mov    %eax,-0x54(%ebp)

	midVAs[idx] = va + actualSize/2 ;
f0112752:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112755:	d1 e8                	shr    %eax
f0112757:	89 c2                	mov    %eax,%edx
f0112759:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011275c:	01 c2                	add    %eax,%edx
f011275e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112761:	89 14 85 80 4c 5c f0 	mov    %edx,-0xfa3b380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f0112768:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011276b:	8d 50 fe             	lea    -0x2(%eax),%edx
f011276e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112771:	01 c2                	add    %eax,%edx
f0112773:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112776:	89 14 85 80 36 5c f0 	mov    %edx,-0xfa3c980(,%eax,4)
	//Check returned va
	if (check_block(va, expectedVA, expectedSize, 1) == 0)
f011277d:	6a 01                	push   $0x1
f011277f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112782:	ff 75 b0             	pushl  -0x50(%ebp)
f0112785:	ff 75 ac             	pushl  -0x54(%ebp)
f0112788:	e8 f8 d3 ff ff       	call   f010fb85 <check_block>
f011278d:	83 c4 10             	add    $0x10,%esp
f0112790:	85 c0                	test   %eax,%eax
f0112792:	75 17                	jne    f01127ab <test_realloc_block_FF+0x2fa>
	{
		panic("test_realloc_block_FF #1.2.0: WRONG ALLOC - it return wrong address.");
f0112794:	83 ec 04             	sub    $0x4,%esp
f0112797:	68 a4 b2 12 f0       	push   $0xf012b2a4
f011279c:	68 17 05 00 00       	push   $0x517
f01127a1:	68 48 a1 12 f0       	push   $0xf012a148
f01127a6:	e8 6f db fe ff       	call   f010031a <_panic>
	}
	*(startVAs[idx]) = idx ;
f01127ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01127ae:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f01127b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01127b8:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f01127bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01127be:	8b 14 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%edx
f01127c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01127c8:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f01127cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01127ce:	8b 14 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%edx
f01127d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01127d8:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f01127db:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f01127e2:	eb 59                	jmp    f011283d <test_realloc_block_FF+0x38c>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f01127e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01127e7:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01127ee:	66 8b 00             	mov    (%eax),%ax
f01127f1:	98                   	cwtl   
f01127f2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01127f5:	75 26                	jne    f011281d <test_realloc_block_FF+0x36c>
f01127f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01127fa:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0112801:	66 8b 00             	mov    (%eax),%ax
f0112804:	98                   	cwtl   
f0112805:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0112808:	75 13                	jne    f011281d <test_realloc_block_FF+0x36c>
f011280a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011280d:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f0112814:	66 8b 00             	mov    (%eax),%ax
f0112817:	98                   	cwtl   
f0112818:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011281b:	74 1d                	je     f011283a <test_realloc_block_FF+0x389>
			panic("test_realloc_block_FF #1.3.%d: WRONG! content of the block is not correct. Expected %d",i, i);
f011281d:	83 ec 0c             	sub    $0xc,%esp
f0112820:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112823:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112826:	68 ec b2 12 f0       	push   $0xf012b2ec
f011282b:	68 22 05 00 00       	push   $0x522
f0112830:	68 48 a1 12 f0       	push   $0xf012a148
f0112835:	e8 e0 da fe ff       	call   f010031a <_panic>
	*(midVAs[idx]) = idx ;
	*(endVAs[idx]) = idx ;

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f011283a:	ff 45 d4             	incl   -0x2c(%ebp)
f011283d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0112840:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112843:	7c 9f                	jl     f01127e4 <test_realloc_block_FF+0x333>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
			panic("test_realloc_block_FF #1.3.%d: WRONG! content of the block is not correct. Expected %d",i, i);
	}

	if (is_correct)
f0112845:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112849:	74 04                	je     f011284f <test_realloc_block_FF+0x39e>
	{
		eval += 10;
f011284b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	//[2] Test krealloc by passing size = 0. It should call free
	//====================================================================//
	cprintf("2: Test calling realloc with SIZE = 0.[10%]\n\n") ;
f011284f:	83 ec 0c             	sub    $0xc,%esp
f0112852:	68 44 b3 12 f0       	push   $0xf012b344
f0112857:	e8 10 e7 fe ff       	call   f0100f6c <cprintf>
f011285c:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011285f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0112866:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f011286d:	e9 f1 00 00 00       	jmp    f0112963 <test_realloc_block_FF+0x4b2>
	{
		va = realloc_block_FF(startVAs[i*allocCntPerSize], 0);
f0112872:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0112875:	89 d0                	mov    %edx,%eax
f0112877:	c1 e0 02             	shl    $0x2,%eax
f011287a:	01 d0                	add    %edx,%eax
f011287c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0112883:	01 d0                	add    %edx,%eax
f0112885:	c1 e0 03             	shl    $0x3,%eax
f0112888:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f011288f:	83 ec 08             	sub    $0x8,%esp
f0112892:	6a 00                	push   $0x0
f0112894:	50                   	push   %eax
f0112895:	e8 b6 13 01 00       	call   f0123c50 <realloc_block_FF>
f011289a:	83 c4 10             	add    $0x10,%esp
f011289d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		uint32 block_size = get_block_size(startVAs[i*allocCntPerSize]) ;
f01128a0:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01128a3:	89 d0                	mov    %edx,%eax
f01128a5:	c1 e0 02             	shl    $0x2,%eax
f01128a8:	01 d0                	add    %edx,%eax
f01128aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01128b1:	01 d0                	add    %edx,%eax
f01128b3:	c1 e0 03             	shl    $0x3,%eax
f01128b6:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01128bd:	83 ec 0c             	sub    $0xc,%esp
f01128c0:	50                   	push   %eax
f01128c1:	e8 7a 07 01 00       	call   f0123040 <get_block_size>
f01128c6:	83 c4 10             	add    $0x10,%esp
f01128c9:	89 45 a0             	mov    %eax,-0x60(%ebp)
		expectedSize = allocSizes[i];
f01128cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01128cf:	8b 04 85 b8 fd 17 f0 	mov    -0xfe80248(,%eax,4),%eax
f01128d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = va;
f01128d9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01128dc:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], expectedSize, 0) == 0)
f01128df:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01128e2:	89 d0                	mov    %edx,%eax
f01128e4:	c1 e0 02             	shl    $0x2,%eax
f01128e7:	01 d0                	add    %edx,%eax
f01128e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01128f0:	01 d0                	add    %edx,%eax
f01128f2:	c1 e0 03             	shl    $0x3,%eax
f01128f5:	8b 14 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%edx
f01128fc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f01128ff:	89 c8                	mov    %ecx,%eax
f0112901:	c1 e0 02             	shl    $0x2,%eax
f0112904:	01 c8                	add    %ecx,%eax
f0112906:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011290d:	01 c8                	add    %ecx,%eax
f011290f:	c1 e0 03             	shl    $0x3,%eax
f0112912:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112919:	6a 00                	push   $0x0
f011291b:	ff 75 b4             	pushl  -0x4c(%ebp)
f011291e:	52                   	push   %edx
f011291f:	50                   	push   %eax
f0112920:	e8 60 d2 ff ff       	call   f010fb85 <check_block>
f0112925:	83 c4 10             	add    $0x10,%esp
f0112928:	85 c0                	test   %eax,%eax
f011292a:	75 17                	jne    f0112943 <test_realloc_block_FF+0x492>
		{
			panic("test_realloc_block_FF #2.1.%d: Failed.", i);
f011292c:	ff 75 d0             	pushl  -0x30(%ebp)
f011292f:	68 74 b3 12 f0       	push   $0xf012b374
f0112934:	68 3a 05 00 00       	push   $0x53a
f0112939:	68 48 a1 12 f0       	push   $0xf012a148
f011293e:	e8 d7 d9 fe ff       	call   f010031a <_panic>
		}
		if(va != NULL)
f0112943:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f0112947:	74 17                	je     f0112960 <test_realloc_block_FF+0x4af>
			panic("test_realloc_block_FF #2.2.%d: it should return NULL.", i);
f0112949:	ff 75 d0             	pushl  -0x30(%ebp)
f011294c:	68 9c b3 12 f0       	push   $0xf012b39c
f0112951:	68 3d 05 00 00       	push   $0x53d
f0112956:	68 48 a1 12 f0       	push   $0xf012a148
f011295b:	e8 ba d9 fe ff       	call   f010031a <_panic>
	//====================================================================//
	cprintf("2: Test calling realloc with SIZE = 0.[10%]\n\n") ;
	is_correct = 1;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0112960:	ff 45 d0             	incl   -0x30(%ebp)
f0112963:	83 7d d0 06          	cmpl   $0x6,-0x30(%ebp)
f0112967:	0f 8e 05 ff ff ff    	jle    f0112872 <test_realloc_block_FF+0x3c1>
		if(va != NULL)
			panic("test_realloc_block_FF #2.2.%d: it should return NULL.", i);
	}

	//test calling it with NULL & ZERO
	va = realloc_block_FF(NULL, 0);
f011296d:	83 ec 08             	sub    $0x8,%esp
f0112970:	6a 00                	push   $0x0
f0112972:	6a 00                	push   $0x0
f0112974:	e8 d7 12 01 00       	call   f0123c50 <realloc_block_FF>
f0112979:	83 c4 10             	add    $0x10,%esp
f011297c:	89 45 ac             	mov    %eax,-0x54(%ebp)
	if(va != NULL)
f011297f:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f0112983:	74 17                	je     f011299c <test_realloc_block_FF+0x4eb>
		panic("test_realloc_block_FF #2.3.0: it should return NULL.");
f0112985:	83 ec 04             	sub    $0x4,%esp
f0112988:	68 d4 b3 12 f0       	push   $0xf012b3d4
f011298d:	68 43 05 00 00       	push   $0x543
f0112992:	68 48 a1 12 f0       	push   $0xf012a148
f0112997:	e8 7e d9 fe ff       	call   f010031a <_panic>

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f011299c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01129a3:	eb 6b                	jmp    f0112a10 <test_realloc_block_FF+0x55f>
	{
		if (i % allocCntPerSize == 0)
f01129a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01129a8:	b9 c8 00 00 00       	mov    $0xc8,%ecx
f01129ad:	99                   	cltd   
f01129ae:	f7 f9                	idiv   %ecx
f01129b0:	89 d0                	mov    %edx,%eax
f01129b2:	85 c0                	test   %eax,%eax
f01129b4:	74 56                	je     f0112a0c <test_realloc_block_FF+0x55b>
			continue;
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f01129b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01129b9:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f01129c0:	66 8b 00             	mov    (%eax),%ax
f01129c3:	98                   	cwtl   
f01129c4:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f01129c7:	75 26                	jne    f01129ef <test_realloc_block_FF+0x53e>
f01129c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01129cc:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f01129d3:	66 8b 00             	mov    (%eax),%ax
f01129d6:	98                   	cwtl   
f01129d7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f01129da:	75 13                	jne    f01129ef <test_realloc_block_FF+0x53e>
f01129dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01129df:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f01129e6:	66 8b 00             	mov    (%eax),%ax
f01129e9:	98                   	cwtl   
f01129ea:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f01129ed:	74 1e                	je     f0112a0d <test_realloc_block_FF+0x55c>
			panic("test_realloc_block_FF #2.4.%d: WRONG! content of the block is not correct. Expected %d",i, i);
f01129ef:	83 ec 0c             	sub    $0xc,%esp
f01129f2:	ff 75 cc             	pushl  -0x34(%ebp)
f01129f5:	ff 75 cc             	pushl  -0x34(%ebp)
f01129f8:	68 0c b4 12 f0       	push   $0xf012b40c
f01129fd:	68 4c 05 00 00       	push   $0x54c
f0112a02:	68 48 a1 12 f0       	push   $0xf012a148
f0112a07:	e8 0e d9 fe ff       	call   f010031a <_panic>
	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
	{
		if (i % allocCntPerSize == 0)
			continue;
f0112a0c:	90                   	nop
	if(va != NULL)
		panic("test_realloc_block_FF #2.3.0: it should return NULL.");

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f0112a0d:	ff 45 cc             	incl   -0x34(%ebp)
f0112a10:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112a13:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112a16:	7c 8d                	jl     f01129a5 <test_realloc_block_FF+0x4f4>
			continue;
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
			panic("test_realloc_block_FF #2.4.%d: WRONG! content of the block is not correct. Expected %d",i, i);
	}

	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0112a18:	c7 45 9c 07 00 00 00 	movl   $0x7,-0x64(%ebp)
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0112a1f:	83 ec 0c             	sub    $0xc,%esp
f0112a22:	ff 75 9c             	pushl  -0x64(%ebp)
f0112a25:	e8 e3 d1 ff ff       	call   f010fc0d <check_list_size>
f0112a2a:	83 c4 10             	add    $0x10,%esp
f0112a2d:	85 c0                	test   %eax,%eax
f0112a2f:	75 17                	jne    f0112a48 <test_realloc_block_FF+0x597>
	{
		panic("2.5 Failed");
f0112a31:	83 ec 04             	sub    $0x4,%esp
f0112a34:	68 63 b4 12 f0       	push   $0xf012b463
f0112a39:	68 52 05 00 00       	push   $0x552
f0112a3e:	68 48 a1 12 f0       	push   $0xf012a148
f0112a43:	e8 d2 d8 fe ff       	call   f010031a <_panic>
	}

	if (is_correct)
f0112a48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112a4c:	74 04                	je     f0112a52 <test_realloc_block_FF+0x5a1>
	{
		eval += 10;
f0112a4e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	//[3] Test realloc with increased sizes
	//====================================================================//
	cprintf("3: Test calling realloc with increased sizes [50%].\n\n") ;
f0112a52:	83 ec 0c             	sub    $0xc,%esp
f0112a55:	68 70 b4 12 f0       	push   $0xf012b470
f0112a5a:	e8 0d e5 fe ff       	call   f0100f6c <cprintf>
f0112a5f:	83 c4 10             	add    $0x10,%esp
	int blockIndex, block_size, block_status, old_size, new_size, newBlockIndex;
	//[3.1] reallocate in same place (NO relocate - split)
	cprintf("	3.1: reallocate in same place (NO relocate - split)\n\n") ;
f0112a62:	83 ec 0c             	sub    $0xc,%esp
f0112a65:	68 a8 b4 12 f0       	push   $0xf012b4a8
f0112a6a:	e8 fd e4 fe ff       	call   f0100f6c <cprintf>
f0112a6f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0112a72:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 4*allocCntPerSize - 1 ;
f0112a79:	c7 45 98 1f 03 00 00 	movl   $0x31f,-0x68(%ebp)
		new_size = allocSizes[3] /*12+16 B*/ + allocSizes[4]/2 /*2KB/2*/ - sizeOfMetaData;
f0112a80:	a1 c4 fd 17 f0       	mov    0xf017fdc4,%eax
f0112a85:	8b 15 c8 fd 17 f0    	mov    0xf017fdc8,%edx
f0112a8b:	d1 ea                	shr    %edx
f0112a8d:	01 d0                	add    %edx,%eax
f0112a8f:	83 e8 08             	sub    $0x8,%eax
f0112a92:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = ROUNDUP(new_size + sizeOfMetaData, 2);
f0112a95:	c7 45 90 02 00 00 00 	movl   $0x2,-0x70(%ebp)
f0112a9c:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112a9f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112aa2:	01 d0                	add    %edx,%eax
f0112aa4:	83 c0 07             	add    $0x7,%eax
f0112aa7:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0112aaa:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112aad:	ba 00 00 00 00       	mov    $0x0,%edx
f0112ab2:	f7 75 90             	divl   -0x70(%ebp)
f0112ab5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112ab8:	29 d0                	sub    %edx,%eax
f0112aba:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112abd:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ac0:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112ac7:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112aca:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112acd:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ad0:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112ad7:	83 ec 08             	sub    $0x8,%esp
f0112ada:	52                   	push   %edx
f0112adb:	50                   	push   %eax
f0112adc:	e8 6f 11 01 00       	call   f0123c50 <realloc_block_FF>
f0112ae1:	83 c4 10             	add    $0x10,%esp
f0112ae4:	89 45 ac             	mov    %eax,-0x54(%ebp)

		//check return address
		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112ae7:	6a 01                	push   $0x1
f0112ae9:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112aec:	ff 75 b0             	pushl  -0x50(%ebp)
f0112aef:	ff 75 ac             	pushl  -0x54(%ebp)
f0112af2:	e8 8e d0 ff ff       	call   f010fb85 <check_block>
f0112af7:	83 c4 10             	add    $0x10,%esp
f0112afa:	85 c0                	test   %eax,%eax
f0112afc:	75 17                	jne    f0112b15 <test_realloc_block_FF+0x664>
		{
			is_correct = 0;
f0112afe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.1.1: Failed\n");
f0112b05:	83 ec 0c             	sub    $0xc,%esp
f0112b08:	68 e0 b4 12 f0       	push   $0xf012b4e0
f0112b0d:	e8 5a e4 fe ff       	call   f0100f6c <cprintf>
f0112b12:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex ||	*(endVAs[blockIndex]) != blockIndex)
f0112b15:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b18:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112b1f:	66 8b 00             	mov    (%eax),%ax
f0112b22:	98                   	cwtl   
f0112b23:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112b26:	75 26                	jne    f0112b4e <test_realloc_block_FF+0x69d>
f0112b28:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b2b:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0112b32:	66 8b 00             	mov    (%eax),%ax
f0112b35:	98                   	cwtl   
f0112b36:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112b39:	75 13                	jne    f0112b4e <test_realloc_block_FF+0x69d>
f0112b3b:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b3e:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f0112b45:	66 8b 00             	mov    (%eax),%ax
f0112b48:	98                   	cwtl   
f0112b49:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112b4c:	74 1a                	je     f0112b68 <test_realloc_block_FF+0x6b7>
		{
			is_correct = 0;
f0112b4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.1.2: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112b55:	83 ec 08             	sub    $0x8,%esp
f0112b58:	ff 75 98             	pushl  -0x68(%ebp)
f0112b5b:	68 08 b5 12 f0       	push   $0xf012b508
f0112b60:	e8 07 e4 fe ff       	call   f0100f6c <cprintf>
f0112b65:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (is_correct)
f0112b68:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112b6c:	74 04                	je     f0112b72 <test_realloc_block_FF+0x6c1>
	{
		eval += 25;
f0112b6e:	83 45 f4 19          	addl   $0x19,-0xc(%ebp)
	}

	//[3.2] reallocate in same place (NO relocate - NO split)
	cprintf("	3.2: reallocate in same place (NO relocate - NO split)\n\n") ;
f0112b72:	83 ec 0c             	sub    $0xc,%esp
f0112b75:	68 68 b5 12 f0       	push   $0xf012b568
f0112b7a:	e8 ed e3 fe ff       	call   f0100f6c <cprintf>
f0112b7f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0112b82:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 4*allocCntPerSize - 1 ;
f0112b89:	c7 45 98 1f 03 00 00 	movl   $0x31f,-0x68(%ebp)
		//new_size = allocSizes[3] /*12+16B + 2KB/2*/ + allocSizes[4]/2 /*2KB/2*/ - sizeOfMetaData;
		new_size = allocSizes[3] + allocSizes[4] - sizeOfMetaData;
f0112b90:	8b 15 c4 fd 17 f0    	mov    0xf017fdc4,%edx
f0112b96:	a1 c8 fd 17 f0       	mov    0xf017fdc8,%eax
f0112b9b:	01 d0                	add    %edx,%eax
f0112b9d:	83 e8 08             	sub    $0x8,%eax
f0112ba0:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = ROUNDUP(new_size + sizeOfMetaData, 2);
f0112ba3:	c7 45 88 02 00 00 00 	movl   $0x2,-0x78(%ebp)
f0112baa:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112bad:	8b 45 88             	mov    -0x78(%ebp),%eax
f0112bb0:	01 d0                	add    %edx,%eax
f0112bb2:	83 c0 07             	add    $0x7,%eax
f0112bb5:	89 45 84             	mov    %eax,-0x7c(%ebp)
f0112bb8:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0112bbb:	ba 00 00 00 00       	mov    $0x0,%edx
f0112bc0:	f7 75 88             	divl   -0x78(%ebp)
f0112bc3:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0112bc6:	29 d0                	sub    %edx,%eax
f0112bc8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112bcb:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112bce:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112bd5:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112bd8:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112bdb:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112bde:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112be5:	83 ec 08             	sub    $0x8,%esp
f0112be8:	52                   	push   %edx
f0112be9:	50                   	push   %eax
f0112bea:	e8 61 10 01 00       	call   f0123c50 <realloc_block_FF>
f0112bef:	83 c4 10             	add    $0x10,%esp
f0112bf2:	89 45 ac             	mov    %eax,-0x54(%ebp)

		expectedNumOfFreeBlks--;
f0112bf5:	ff 4d 9c             	decl   -0x64(%ebp)

		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112bf8:	6a 01                	push   $0x1
f0112bfa:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112bfd:	ff 75 b0             	pushl  -0x50(%ebp)
f0112c00:	ff 75 ac             	pushl  -0x54(%ebp)
f0112c03:	e8 7d cf ff ff       	call   f010fb85 <check_block>
f0112c08:	83 c4 10             	add    $0x10,%esp
f0112c0b:	85 c0                	test   %eax,%eax
f0112c0d:	75 17                	jne    f0112c26 <test_realloc_block_FF+0x775>
		{
			is_correct = 0;
f0112c0f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.2.1: Failed\n");
f0112c16:	83 ec 0c             	sub    $0xc,%esp
f0112c19:	68 a4 b5 12 f0       	push   $0xf012b5a4
f0112c1e:	e8 49 e3 fe ff       	call   f0100f6c <cprintf>
f0112c23:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex ||	*(endVAs[blockIndex]) != blockIndex)
f0112c26:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112c29:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112c30:	66 8b 00             	mov    (%eax),%ax
f0112c33:	98                   	cwtl   
f0112c34:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112c37:	75 26                	jne    f0112c5f <test_realloc_block_FF+0x7ae>
f0112c39:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112c3c:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0112c43:	66 8b 00             	mov    (%eax),%ax
f0112c46:	98                   	cwtl   
f0112c47:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112c4a:	75 13                	jne    f0112c5f <test_realloc_block_FF+0x7ae>
f0112c4c:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112c4f:	8b 04 85 80 36 5c f0 	mov    -0xfa3c980(,%eax,4),%eax
f0112c56:	66 8b 00             	mov    (%eax),%ax
f0112c59:	98                   	cwtl   
f0112c5a:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112c5d:	74 1a                	je     f0112c79 <test_realloc_block_FF+0x7c8>
		{
			is_correct = 0;
f0112c5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.2.2: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112c66:	83 ec 08             	sub    $0x8,%esp
f0112c69:	ff 75 98             	pushl  -0x68(%ebp)
f0112c6c:	68 cc b5 12 f0       	push   $0xf012b5cc
f0112c71:	e8 f6 e2 fe ff       	call   f0100f6c <cprintf>
f0112c76:	83 c4 10             	add    $0x10,%esp
		}

		if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0112c79:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112c7d:	74 11                	je     f0112c90 <test_realloc_block_FF+0x7df>
f0112c7f:	83 ec 0c             	sub    $0xc,%esp
f0112c82:	ff 75 9c             	pushl  -0x64(%ebp)
f0112c85:	e8 83 cf ff ff       	call   f010fc0d <check_list_size>
f0112c8a:	83 c4 10             	add    $0x10,%esp
f0112c8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}
	if (is_correct)
f0112c90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112c94:	74 04                	je     f0112c9a <test_realloc_block_FF+0x7e9>
	{
		eval += 25;
f0112c96:	83 45 f4 19          	addl   $0x19,-0xc(%ebp)
	}

	//====================================================================//
	//[4] Test realloc with decreased sizes
	//====================================================================//
	cprintf("4: Test calling realloc with decreased sizes.[30%]\n\n") ;
f0112c9a:	83 ec 0c             	sub    $0xc,%esp
f0112c9d:	68 2c b6 12 f0       	push   $0xf012b62c
f0112ca2:	e8 c5 e2 fe ff       	call   f0100f6c <cprintf>
f0112ca7:	83 c4 10             	add    $0x10,%esp
	//[4.1] next block is full (NO coalesce)
	cprintf("	4.1: next block is full (NO coalesce)\n\n") ;
f0112caa:	83 ec 0c             	sub    $0xc,%esp
f0112cad:	68 64 b6 12 f0       	push   $0xf012b664
f0112cb2:	e8 b5 e2 fe ff       	call   f0100f6c <cprintf>
f0112cb7:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0112cba:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 0*allocCntPerSize + 1; /*4KB*/
f0112cc1:	c7 45 98 01 00 00 00 	movl   $0x1,-0x68(%ebp)
		old_size = allocSizes[0] - sizeOfMetaData; /*4KB - sizeOfMetaData*/;
f0112cc8:	a1 b8 fd 17 f0       	mov    0xf017fdb8,%eax
f0112ccd:	83 e8 08             	sub    $0x8,%eax
f0112cd0:	89 45 80             	mov    %eax,-0x80(%ebp)
		new_size = old_size - 1*kilo ;
f0112cd3:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112cd6:	2d 00 04 00 00       	sub    $0x400,%eax
f0112cdb:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = ROUNDUP(new_size + sizeOfMetaData, 2);
f0112cde:	c7 85 7c ff ff ff 02 	movl   $0x2,-0x84(%ebp)
f0112ce5:	00 00 00 
f0112ce8:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112ceb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0112cf1:	01 d0                	add    %edx,%eax
f0112cf3:	83 c0 07             	add    $0x7,%eax
f0112cf6:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0112cfc:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0112d02:	ba 00 00 00 00       	mov    $0x0,%edx
f0112d07:	f7 b5 7c ff ff ff    	divl   -0x84(%ebp)
f0112d0d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0112d13:	29 d0                	sub    %edx,%eax
f0112d15:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112d18:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112d1b:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112d22:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112d25:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112d28:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112d2b:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112d32:	83 ec 08             	sub    $0x8,%esp
f0112d35:	52                   	push   %edx
f0112d36:	50                   	push   %eax
f0112d37:	e8 14 0f 01 00       	call   f0123c50 <realloc_block_FF>
f0112d3c:	83 c4 10             	add    $0x10,%esp
f0112d3f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		expectedNumOfFreeBlks++;
f0112d42:	ff 45 9c             	incl   -0x64(%ebp)

		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112d45:	6a 01                	push   $0x1
f0112d47:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112d4a:	ff 75 b0             	pushl  -0x50(%ebp)
f0112d4d:	ff 75 ac             	pushl  -0x54(%ebp)
f0112d50:	e8 30 ce ff ff       	call   f010fb85 <check_block>
f0112d55:	83 c4 10             	add    $0x10,%esp
f0112d58:	85 c0                	test   %eax,%eax
f0112d5a:	75 17                	jne    f0112d73 <test_realloc_block_FF+0x8c2>
		{
			is_correct = 0;
f0112d5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.1.1: Failed\n");
f0112d63:	83 ec 0c             	sub    $0xc,%esp
f0112d66:	68 90 b6 12 f0       	push   $0xf012b690
f0112d6b:	e8 fc e1 fe ff       	call   f0100f6c <cprintf>
f0112d70:	83 c4 10             	add    $0x10,%esp
		}
		//check new free block
		struct BlockElement *newBlkAddr = (struct BlockElement *)(va + new_size + 2*sizeof(int));
f0112d73:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112d76:	8d 50 08             	lea    0x8(%eax),%edx
f0112d79:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112d7c:	01 d0                	add    %edx,%eax
f0112d7e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		cprintf("\nrealloc Test: newBlkAddr @va %x\n", newBlkAddr);
f0112d84:	83 ec 08             	sub    $0x8,%esp
f0112d87:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
f0112d8d:	68 b8 b6 12 f0       	push   $0xf012b6b8
f0112d92:	e8 d5 e1 fe ff       	call   f0100f6c <cprintf>
f0112d97:	83 c4 10             	add    $0x10,%esp
		expectedSize = 1*kilo ;
f0112d9a:	c7 45 b4 00 04 00 00 	movl   $0x400,-0x4c(%ebp)
		if (check_block(newBlkAddr, newBlkAddr, expectedSize, 0) == 0)
f0112da1:	6a 00                	push   $0x0
f0112da3:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112da6:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
f0112dac:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
f0112db2:	e8 ce cd ff ff       	call   f010fb85 <check_block>
f0112db7:	83 c4 10             	add    $0x10,%esp
f0112dba:	85 c0                	test   %eax,%eax
f0112dbc:	75 17                	jne    f0112dd5 <test_realloc_block_FF+0x924>
		{
			is_correct = 0;
f0112dbe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.1.2: Failed\n");
f0112dc5:	83 ec 0c             	sub    $0xc,%esp
f0112dc8:	68 dc b6 12 f0       	push   $0xf012b6dc
f0112dcd:	e8 9a e1 fe ff       	call   f0100f6c <cprintf>
f0112dd2:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex)
f0112dd5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112dd8:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112ddf:	66 8b 00             	mov    (%eax),%ax
f0112de2:	98                   	cwtl   
f0112de3:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112de6:	75 13                	jne    f0112dfb <test_realloc_block_FF+0x94a>
f0112de8:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112deb:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0112df2:	66 8b 00             	mov    (%eax),%ax
f0112df5:	98                   	cwtl   
f0112df6:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112df9:	74 1a                	je     f0112e15 <test_realloc_block_FF+0x964>
		{
			is_correct = 0;
f0112dfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.1.3: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112e02:	83 ec 08             	sub    $0x8,%esp
f0112e05:	ff 75 98             	pushl  -0x68(%ebp)
f0112e08:	68 04 b7 12 f0       	push   $0xf012b704
f0112e0d:	e8 5a e1 fe ff       	call   f0100f6c <cprintf>
f0112e12:	83 c4 10             	add    $0x10,%esp
		}

		//Check # free blocks
		if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0112e15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112e19:	74 11                	je     f0112e2c <test_realloc_block_FF+0x97b>
f0112e1b:	83 ec 0c             	sub    $0xc,%esp
f0112e1e:	ff 75 9c             	pushl  -0x64(%ebp)
f0112e21:	e8 e7 cd ff ff       	call   f010fc0d <check_list_size>
f0112e26:	83 c4 10             	add    $0x10,%esp
f0112e29:	89 45 f0             	mov    %eax,-0x10(%ebp)

	}
	if (is_correct)
f0112e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112e30:	74 04                	je     f0112e36 <test_realloc_block_FF+0x985>
	{
		eval += 15;
f0112e32:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}
	cprintf("	4.2: next block is full (NO coalesce) [Internal Fragmentation]\n\n") ;
f0112e36:	83 ec 0c             	sub    $0xc,%esp
f0112e39:	68 64 b7 12 f0       	push   $0xf012b764
f0112e3e:	e8 29 e1 fe ff       	call   f0100f6c <cprintf>
f0112e43:	83 c4 10             	add    $0x10,%esp

	is_correct = 1;
f0112e46:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 1*allocCntPerSize + 1;
f0112e4d:	c7 45 98 c9 00 00 00 	movl   $0xc9,-0x68(%ebp)
		old_size = allocSizes[1] - sizeOfMetaData;/*20 B*/
f0112e54:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f0112e59:	83 e8 08             	sub    $0x8,%eax
f0112e5c:	89 45 80             	mov    %eax,-0x80(%ebp)
		new_size = old_size - 6;
f0112e5f:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112e62:	83 e8 06             	sub    $0x6,%eax
f0112e65:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = allocSizes[1]; /*Same block size [Internal Framgmentation]*/
f0112e68:	a1 bc fd 17 f0       	mov    0xf017fdbc,%eax
f0112e6d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112e70:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112e73:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112e7a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112e7d:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112e80:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112e83:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112e8a:	83 ec 08             	sub    $0x8,%esp
f0112e8d:	52                   	push   %edx
f0112e8e:	50                   	push   %eax
f0112e8f:	e8 bc 0d 01 00       	call   f0123c50 <realloc_block_FF>
f0112e94:	83 c4 10             	add    $0x10,%esp
f0112e97:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112e9a:	6a 01                	push   $0x1
f0112e9c:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112e9f:	ff 75 b0             	pushl  -0x50(%ebp)
f0112ea2:	ff 75 ac             	pushl  -0x54(%ebp)
f0112ea5:	e8 db cc ff ff       	call   f010fb85 <check_block>
f0112eaa:	83 c4 10             	add    $0x10,%esp
f0112ead:	85 c0                	test   %eax,%eax
f0112eaf:	75 17                	jne    f0112ec8 <test_realloc_block_FF+0xa17>
		{
			is_correct = 0;
f0112eb1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.2.1: Failed\n");
f0112eb8:	83 ec 0c             	sub    $0xc,%esp
f0112ebb:	68 a8 b7 12 f0       	push   $0xf012b7a8
f0112ec0:	e8 a7 e0 fe ff       	call   f0100f6c <cprintf>
f0112ec5:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex)
f0112ec8:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ecb:	8b 04 85 80 20 5c f0 	mov    -0xfa3df80(,%eax,4),%eax
f0112ed2:	66 8b 00             	mov    (%eax),%ax
f0112ed5:	98                   	cwtl   
f0112ed6:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112ed9:	75 13                	jne    f0112eee <test_realloc_block_FF+0xa3d>
f0112edb:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ede:	8b 04 85 80 4c 5c f0 	mov    -0xfa3b380(,%eax,4),%eax
f0112ee5:	66 8b 00             	mov    (%eax),%ax
f0112ee8:	98                   	cwtl   
f0112ee9:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112eec:	74 1a                	je     f0112f08 <test_realloc_block_FF+0xa57>
		{
			is_correct = 0;
f0112eee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.2.2: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112ef5:	83 ec 08             	sub    $0x8,%esp
f0112ef8:	ff 75 98             	pushl  -0x68(%ebp)
f0112efb:	68 d0 b7 12 f0       	push   $0xf012b7d0
f0112f00:	e8 67 e0 fe ff       	call   f0100f6c <cprintf>
f0112f05:	83 c4 10             	add    $0x10,%esp
		}

		//Check # free blocks
		if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0112f08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112f0c:	74 11                	je     f0112f1f <test_realloc_block_FF+0xa6e>
f0112f0e:	83 ec 0c             	sub    $0xc,%esp
f0112f11:	ff 75 9c             	pushl  -0x64(%ebp)
f0112f14:	e8 f4 cc ff ff       	call   f010fc0d <check_list_size>
f0112f19:	83 c4 10             	add    $0x10,%esp
f0112f1c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	}
	if (is_correct)
f0112f1f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112f23:	74 04                	je     f0112f29 <test_realloc_block_FF+0xa78>
	{
		eval += 15;
f0112f25:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	cprintf("[PARTIAL] test realloc_block with FIRST FIT completed. Evaluation = %d%\n", eval);
f0112f29:	83 ec 08             	sub    $0x8,%esp
f0112f2c:	ff 75 f4             	pushl  -0xc(%ebp)
f0112f2f:	68 30 b8 12 f0       	push   $0xf012b830
f0112f34:	e8 33 e0 fe ff       	call   f0100f6c <cprintf>
f0112f39:	83 c4 10             	add    $0x10,%esp

}
f0112f3c:	90                   	nop
f0112f3d:	c9                   	leave  
f0112f3e:	c3                   	ret    

f0112f3f <test_realloc_block_FF_COMPLETE>:


void test_realloc_block_FF_COMPLETE()
{
f0112f3f:	55                   	push   %ebp
f0112f40:	89 e5                	mov    %esp,%ebp
f0112f42:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	panic("this is UNSEEN test");
f0112f45:	83 ec 04             	sub    $0x4,%esp
f0112f48:	68 79 b8 12 f0       	push   $0xf012b879
f0112f4d:	68 f9 05 00 00       	push   $0x5f9
f0112f52:	68 48 a1 12 f0       	push   $0xf012a148
f0112f57:	e8 be d3 fe ff       	call   f010031a <_panic>

f0112f5c <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0112f5c:	55                   	push   %ebp
f0112f5d:	89 e5                	mov    %esp,%ebp
f0112f5f:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0112f62:	e8 09 78 ff ff       	call   f010a770 <get_cpu_proc>
f0112f67:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0112f6a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112f6e:	75 16                	jne    f0112f86 <sys_check_LRU_lists+0x2a>
f0112f70:	68 90 b8 12 f0       	push   $0xf012b890
f0112f75:	68 a0 b8 12 f0       	push   $0xf012b8a0
f0112f7a:	6a 10                	push   $0x10
f0112f7c:	68 b5 b8 12 f0       	push   $0xf012b8b5
f0112f81:	e8 94 d3 fe ff       	call   f010031a <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0112f86:	83 ec 0c             	sub    $0xc,%esp
f0112f89:	68 d4 b8 12 f0       	push   $0xf012b8d4
f0112f8e:	e8 d9 df fe ff       	call   f0100f6c <cprintf>
f0112f93:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0112f96:	83 ec 0c             	sub    $0xc,%esp
f0112f99:	ff 75 e0             	pushl  -0x20(%ebp)
f0112f9c:	e8 67 60 ff ff       	call   f0109008 <env_page_ws_print>
f0112fa1:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0112fa4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112fa7:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0112faa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0112fb1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0112fb8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0112fbc:	0f 84 a5 00 00 00    	je     f0113067 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0112fc2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0112fc9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112fcc:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0112fd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0112fd5:	eb 4a                	jmp    f0113021 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0112fd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112fda:	8b 00                	mov    (%eax),%eax
f0112fdc:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0112fdf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112fe2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112fe7:	89 c2                	mov    %eax,%edx
f0112fe9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0112fec:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0112ff3:	8b 45 08             	mov    0x8(%ebp),%eax
f0112ff6:	01 c8                	add    %ecx,%eax
f0112ff8:	8b 00                	mov    (%eax),%eax
f0112ffa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0112ffd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0113000:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0113005:	39 c2                	cmp    %eax,%edx
f0113007:	74 09                	je     f0113012 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0113009:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0113010:	eb 3e                	jmp    f0113050 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0113012:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0113015:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113018:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f011301e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0113021:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0113025:	74 08                	je     f011302f <sys_check_LRU_lists+0xd3>
f0113027:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011302a:	8b 40 10             	mov    0x10(%eax),%eax
f011302d:	eb 05                	jmp    f0113034 <sys_check_LRU_lists+0xd8>
f011302f:	b8 00 00 00 00       	mov    $0x0,%eax
f0113034:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0113037:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f011303d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113040:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0113046:	85 c0                	test   %eax,%eax
f0113048:	75 8d                	jne    f0112fd7 <sys_check_LRU_lists+0x7b>
f011304a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011304e:	75 87                	jne    f0112fd7 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0113050:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113053:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f0113059:	8b 45 10             	mov    0x10(%ebp),%eax
f011305c:	39 c2                	cmp    %eax,%edx
f011305e:	74 07                	je     f0113067 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0113060:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0113067:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011306b:	0f 84 a5 00 00 00    	je     f0113116 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0113071:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0113078:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011307b:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f0113081:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0113084:	eb 4a                	jmp    f01130d0 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0113086:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0113089:	8b 00                	mov    (%eax),%eax
f011308b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011308e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113091:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0113096:	89 c2                	mov    %eax,%edx
f0113098:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011309b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01130a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01130a5:	01 c8                	add    %ecx,%eax
f01130a7:	8b 00                	mov    (%eax),%eax
f01130a9:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01130ac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01130af:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01130b4:	39 c2                	cmp    %eax,%edx
f01130b6:	74 09                	je     f01130c1 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01130b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01130bf:	eb 3e                	jmp    f01130ff <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01130c1:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01130c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01130c7:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01130cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01130d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01130d4:	74 08                	je     f01130de <sys_check_LRU_lists+0x182>
f01130d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01130d9:	8b 40 10             	mov    0x10(%eax),%eax
f01130dc:	eb 05                	jmp    f01130e3 <sys_check_LRU_lists+0x187>
f01130de:	b8 00 00 00 00       	mov    $0x0,%eax
f01130e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01130e6:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f01130ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01130ef:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01130f5:	85 c0                	test   %eax,%eax
f01130f7:	75 8d                	jne    f0113086 <sys_check_LRU_lists+0x12a>
f01130f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01130fd:	75 87                	jne    f0113086 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f01130ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113102:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f0113108:	8b 45 14             	mov    0x14(%ebp),%eax
f011310b:	39 c2                	cmp    %eax,%edx
f011310d:	74 07                	je     f0113116 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f011310f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0113116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113119:	23 45 f0             	and    -0x10(%ebp),%eax
}
f011311c:	c9                   	leave  
f011311d:	c3                   	ret    

f011311e <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f011311e:	55                   	push   %ebp
f011311f:	89 e5                	mov    %esp,%ebp
f0113121:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0113124:	e8 47 76 ff ff       	call   f010a770 <get_cpu_proc>
f0113129:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f011312c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0113130:	75 16                	jne    f0113148 <sys_check_LRU_lists_free+0x2a>
f0113132:	68 90 b8 12 f0       	push   $0xf012b890
f0113137:	68 a0 b8 12 f0       	push   $0xf012b8a0
f011313c:	6a 45                	push   $0x45
f011313e:	68 b5 b8 12 f0       	push   $0xf012b8b5
f0113143:	e8 d2 d1 fe ff       	call   f010031a <_panic>
	struct Env* env = cur_env;
f0113148:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011314b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f011314e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0113155:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0113158:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f011315e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0113161:	eb 65                	jmp    f01131c8 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0113163:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011316a:	eb 3a                	jmp    f01131a6 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011316c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011316f:	8b 00                	mov    (%eax),%eax
f0113171:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0113174:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0113177:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011317c:	89 c2                	mov    %eax,%edx
f011317e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0113181:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0113188:	8b 45 08             	mov    0x8(%ebp),%eax
f011318b:	01 c8                	add    %ecx,%eax
f011318d:	8b 00                	mov    (%eax),%eax
f011318f:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113192:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113195:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011319a:	39 c2                	cmp    %eax,%edx
f011319c:	75 05                	jne    f01131a3 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f011319e:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01131a1:	eb 0b                	jmp    f01131ae <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01131a3:	ff 45 ec             	incl   -0x14(%ebp)
f01131a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01131a9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01131ac:	7c be                	jl     f011316c <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01131ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01131b2:	7e 08                	jle    f01131bc <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01131b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01131b7:	e9 ed 00 00 00       	jmp    f01132a9 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01131bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01131bf:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f01131c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01131c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01131cc:	74 08                	je     f01131d6 <sys_check_LRU_lists_free+0xb8>
f01131ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01131d1:	8b 40 10             	mov    0x10(%eax),%eax
f01131d4:	eb 05                	jmp    f01131db <sys_check_LRU_lists_free+0xbd>
f01131d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01131db:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01131de:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f01131e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01131e7:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f01131ed:	85 c0                	test   %eax,%eax
f01131ef:	0f 85 6e ff ff ff    	jne    f0113163 <sys_check_LRU_lists_free+0x45>
f01131f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01131f9:	0f 85 64 ff ff ff    	jne    f0113163 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01131ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0113202:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f0113208:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011320b:	eb 62                	jmp    f011326f <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f011320d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0113214:	eb 3a                	jmp    f0113250 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0113216:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113219:	8b 00                	mov    (%eax),%eax
f011321b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011321e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113221:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0113226:	89 c2                	mov    %eax,%edx
f0113228:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011322b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0113232:	8b 45 08             	mov    0x8(%ebp),%eax
f0113235:	01 c8                	add    %ecx,%eax
f0113237:	8b 00                	mov    (%eax),%eax
f0113239:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011323c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011323f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0113244:	39 c2                	cmp    %eax,%edx
f0113246:	75 05                	jne    f011324d <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0113248:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011324b:	eb 0b                	jmp    f0113258 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f011324d:	ff 45 e8             	incl   -0x18(%ebp)
f0113250:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0113253:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0113256:	7c be                	jl     f0113216 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0113258:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011325c:	7e 05                	jle    f0113263 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f011325e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113261:	eb 46                	jmp    f01132a9 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0113263:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0113266:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f011326c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011326f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113273:	74 08                	je     f011327d <sys_check_LRU_lists_free+0x15f>
f0113275:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113278:	8b 40 10             	mov    0x10(%eax),%eax
f011327b:	eb 05                	jmp    f0113282 <sys_check_LRU_lists_free+0x164>
f011327d:	b8 00 00 00 00       	mov    $0x0,%eax
f0113282:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0113285:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f011328b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011328e:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0113294:	85 c0                	test   %eax,%eax
f0113296:	0f 85 71 ff ff ff    	jne    f011320d <sys_check_LRU_lists_free+0xef>
f011329c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01132a0:	0f 85 67 ff ff ff    	jne    f011320d <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01132a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01132a9:	c9                   	leave  
f01132aa:	c3                   	ret    

f01132ab <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01132ab:	55                   	push   %ebp
f01132ac:	89 e5                	mov    %esp,%ebp
f01132ae:	83 ec 08             	sub    $0x8,%esp
		}
	}

	return WS_list_validation;
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
f01132b1:	83 ec 04             	sub    $0x4,%esp
f01132b4:	68 fc b8 12 f0       	push   $0xf012b8fc
f01132b9:	68 ea 00 00 00       	push   $0xea
f01132be:	68 b5 b8 12 f0       	push   $0xf012b8b5
f01132c3:	e8 52 d0 fe ff       	call   f010031a <_panic>

f01132c8 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01132c8:	55                   	push   %ebp
f01132c9:	89 e5                	mov    %esp,%ebp
f01132cb:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01132ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f01132d5:	8b 15 18 3b 5a f0    	mov    0xf05a3b18,%edx
f01132db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01132de:	39 c2                	cmp    %eax,%edx
f01132e0:	74 0a                	je     f01132ec <hasExpectedCommands+0x24>
		return 0;
f01132e2:	b8 00 00 00 00       	mov    $0x0,%eax
f01132e7:	e9 8b 00 00 00       	jmp    f0113377 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f01132ec:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f01132f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01132f4:	eb 55                	jmp    f011334b <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01132f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01132fd:	eb 2a                	jmp    f0113329 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f01132ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113302:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0113309:	8b 45 08             	mov    0x8(%ebp),%eax
f011330c:	01 d0                	add    %edx,%eax
f011330e:	8b 10                	mov    (%eax),%edx
f0113310:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113313:	8b 00                	mov    (%eax),%eax
f0113315:	83 ec 08             	sub    $0x8,%esp
f0113318:	52                   	push   %edx
f0113319:	50                   	push   %eax
f011331a:	e8 c2 f3 00 00       	call   f01226e1 <strcmp>
f011331f:	83 c4 10             	add    $0x10,%esp
f0113322:	85 c0                	test   %eax,%eax
f0113324:	74 0d                	je     f0113333 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0113326:	ff 45 f0             	incl   -0x10(%ebp)
f0113329:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011332c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011332f:	7c ce                	jl     f01132ff <hasExpectedCommands+0x37>
f0113331:	eb 01                	jmp    f0113334 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0113333:	90                   	nop
		if (i == commandsCount)
f0113334:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113337:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011333a:	75 07                	jne    f0113343 <hasExpectedCommands+0x7b>
			return 0;
f011333c:	b8 00 00 00 00       	mov    $0x0,%eax
f0113341:	eb 34                	jmp    f0113377 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0113343:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0113348:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011334b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011334f:	74 08                	je     f0113359 <hasExpectedCommands+0x91>
f0113351:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113354:	8b 40 10             	mov    0x10(%eax),%eax
f0113357:	eb 05                	jmp    f011335e <hasExpectedCommands+0x96>
f0113359:	b8 00 00 00 00       	mov    $0x0,%eax
f011335e:	a3 14 3b 5a f0       	mov    %eax,0xf05a3b14
f0113363:	a1 14 3b 5a f0       	mov    0xf05a3b14,%eax
f0113368:	85 c0                	test   %eax,%eax
f011336a:	75 8a                	jne    f01132f6 <hasExpectedCommands+0x2e>
f011336c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0113370:	75 84                	jne    f01132f6 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0113372:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0113377:	c9                   	leave  
f0113378:	c3                   	ret    

f0113379 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0113379:	55                   	push   %ebp
f011337a:	89 e5                	mov    %esp,%ebp
f011337c:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011337f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0113386:	eb 2e                	jmp    f01133b6 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0113388:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011338b:	89 d0                	mov    %edx,%eax
f011338d:	01 c0                	add    %eax,%eax
f011338f:	01 d0                	add    %edx,%eax
f0113391:	c1 e0 03             	shl    $0x3,%eax
f0113394:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0113399:	8b 00                	mov    (%eax),%eax
f011339b:	83 ec 08             	sub    $0x8,%esp
f011339e:	ff 75 08             	pushl  0x8(%ebp)
f01133a1:	50                   	push   %eax
f01133a2:	e8 3a f3 00 00       	call   f01226e1 <strcmp>
f01133a7:	83 c4 10             	add    $0x10,%esp
f01133aa:	85 c0                	test   %eax,%eax
f01133ac:	75 05                	jne    f01133b3 <getIndexOfCommand+0x3a>
			return i;
f01133ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01133b1:	eb 14                	jmp    f01133c7 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01133b3:	ff 45 f4             	incl   -0xc(%ebp)
f01133b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01133b9:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01133be:	39 c2                	cmp    %eax,%edx
f01133c0:	72 c6                	jb     f0113388 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01133c2:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01133c7:	c9                   	leave  
f01133c8:	c3                   	ret    

f01133c9 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01133c9:	55                   	push   %ebp
f01133ca:	89 e5                	mov    %esp,%ebp
f01133cc:	57                   	push   %edi
f01133cd:	56                   	push   %esi
f01133ce:	53                   	push   %ebx
f01133cf:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f01133d5:	83 ec 0c             	sub    $0xc,%esp
f01133d8:	68 60 b9 12 f0       	push   $0xf012b960
f01133dd:	e8 8a db fe ff       	call   f0100f6c <cprintf>
f01133e2:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01133e5:	83 ec 0c             	sub    $0xc,%esp
f01133e8:	68 84 b9 12 f0       	push   $0xf012b984
f01133ed:	e8 7a db fe ff       	call   f0100f6c <cprintf>
f01133f2:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f01133f5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f01133fc:	c7 45 8c 9f b9 12 f0 	movl   $0xf012b99f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0113403:	83 ec 08             	sub    $0x8,%esp
f0113406:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0113409:	50                   	push   %eax
f011340a:	6a 01                	push   $0x1
f011340c:	e8 a0 ed fe ff       	call   f01021b1 <process_command>
f0113411:	83 c4 10             	add    $0x10,%esp
f0113414:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0113417:	83 ec 0c             	sub    $0xc,%esp
f011341a:	68 ac b9 12 f0       	push   $0xf012b9ac
f011341f:	e8 48 db fe ff       	call   f0100f6c <cprintf>
f0113424:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0113427:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011342a:	83 ec 0c             	sub    $0xc,%esp
f011342d:	50                   	push   %eax
f011342e:	e8 46 ff ff ff       	call   f0113379 <getIndexOfCommand>
f0113433:	83 c4 10             	add    $0x10,%esp
f0113436:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0113439:	75 0f                	jne    f011344a <TestAutoCompleteCommand+0x81>
f011343b:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f0113440:	85 c0                	test   %eax,%eax
f0113442:	75 06                	jne    f011344a <TestAutoCompleteCommand+0x81>
		eval += 15;
f0113444:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0113448:	eb 10                	jmp    f011345a <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011344a:	83 ec 0c             	sub    $0xc,%esp
f011344d:	68 dc b9 12 f0       	push   $0xf012b9dc
f0113452:	e8 15 db fe ff       	call   f0100f6c <cprintf>
f0113457:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f011345a:	83 ec 0c             	sub    $0xc,%esp
f011345d:	68 2c ba 12 f0       	push   $0xf012ba2c
f0113462:	e8 05 db fe ff       	call   f0100f6c <cprintf>
f0113467:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f011346a:	c7 45 88 52 ba 12 f0 	movl   $0xf012ba52,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0113471:	83 ec 08             	sub    $0x8,%esp
f0113474:	8d 45 88             	lea    -0x78(%ebp),%eax
f0113477:	50                   	push   %eax
f0113478:	6a 01                	push   $0x1
f011347a:	e8 32 ed fe ff       	call   f01021b1 <process_command>
f011347f:	83 c4 10             	add    $0x10,%esp
f0113482:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0113485:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0113489:	75 30                	jne    f01134bb <TestAutoCompleteCommand+0xf2>
f011348b:	8d 45 90             	lea    -0x70(%ebp),%eax
f011348e:	bb 30 be 12 f0       	mov    $0xf012be30,%ebx
f0113493:	ba 03 00 00 00       	mov    $0x3,%edx
f0113498:	89 c7                	mov    %eax,%edi
f011349a:	89 de                	mov    %ebx,%esi
f011349c:	89 d1                	mov    %edx,%ecx
f011349e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01134a0:	83 ec 08             	sub    $0x8,%esp
f01134a3:	6a 03                	push   $0x3
f01134a5:	8d 45 90             	lea    -0x70(%ebp),%eax
f01134a8:	50                   	push   %eax
f01134a9:	e8 1a fe ff ff       	call   f01132c8 <hasExpectedCommands>
f01134ae:	83 c4 10             	add    $0x10,%esp
f01134b1:	85 c0                	test   %eax,%eax
f01134b3:	74 06                	je     f01134bb <TestAutoCompleteCommand+0xf2>
		eval += 15;
f01134b5:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01134b9:	eb 10                	jmp    f01134cb <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01134bb:	83 ec 0c             	sub    $0xc,%esp
f01134be:	68 58 ba 12 f0       	push   $0xf012ba58
f01134c3:	e8 a4 da fe ff       	call   f0100f6c <cprintf>
f01134c8:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f01134cb:	83 ec 0c             	sub    $0xc,%esp
f01134ce:	68 a8 ba 12 f0       	push   $0xf012baa8
f01134d3:	e8 94 da fe ff       	call   f0100f6c <cprintf>
f01134d8:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f01134db:	c7 45 84 cd ba 12 f0 	movl   $0xf012bacd,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f01134e2:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01134e5:	83 ec 04             	sub    $0x4,%esp
f01134e8:	50                   	push   %eax
f01134e9:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01134ec:	50                   	push   %eax
f01134ed:	68 d0 ba 12 f0       	push   $0xf012bad0
f01134f2:	e8 75 da fe ff       	call   f0100f6c <cprintf>
f01134f7:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f01134fa:	83 ec 08             	sub    $0x8,%esp
f01134fd:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0113500:	50                   	push   %eax
f0113501:	6a 01                	push   $0x1
f0113503:	e8 a9 ec fe ff       	call   f01021b1 <process_command>
f0113508:	83 c4 10             	add    $0x10,%esp
f011350b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f011350e:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0113512:	75 1b                	jne    f011352f <TestAutoCompleteCommand+0x166>
f0113514:	83 ec 08             	sub    $0x8,%esp
f0113517:	6a 01                	push   $0x1
f0113519:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011351c:	50                   	push   %eax
f011351d:	e8 a6 fd ff ff       	call   f01132c8 <hasExpectedCommands>
f0113522:	83 c4 10             	add    $0x10,%esp
f0113525:	85 c0                	test   %eax,%eax
f0113527:	74 06                	je     f011352f <TestAutoCompleteCommand+0x166>
		eval += 15;
f0113529:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011352d:	eb 10                	jmp    f011353f <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f011352f:	83 ec 0c             	sub    $0xc,%esp
f0113532:	68 f0 ba 12 f0       	push   $0xf012baf0
f0113537:	e8 30 da fe ff       	call   f0100f6c <cprintf>
f011353c:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f011353f:	83 ec 0c             	sub    $0xc,%esp
f0113542:	68 48 bb 12 f0       	push   $0xf012bb48
f0113547:	e8 20 da fe ff       	call   f0100f6c <cprintf>
f011354c:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f011354f:	c7 45 80 6e bb 12 f0 	movl   $0xf012bb6e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0113556:	83 ec 08             	sub    $0x8,%esp
f0113559:	8d 45 80             	lea    -0x80(%ebp),%eax
f011355c:	50                   	push   %eax
f011355d:	6a 01                	push   $0x1
f011355f:	e8 4d ec fe ff       	call   f01021b1 <process_command>
f0113564:	83 c4 10             	add    $0x10,%esp
f0113567:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f011356a:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f011356e:	75 0f                	jne    f011357f <TestAutoCompleteCommand+0x1b6>
f0113570:	a1 18 3b 5a f0       	mov    0xf05a3b18,%eax
f0113575:	85 c0                	test   %eax,%eax
f0113577:	75 06                	jne    f011357f <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0113579:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011357d:	eb 10                	jmp    f011358f <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011357f:	83 ec 0c             	sub    $0xc,%esp
f0113582:	68 74 bb 12 f0       	push   $0xf012bb74
f0113587:	e8 e0 d9 fe ff       	call   f0100f6c <cprintf>
f011358c:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011358f:	83 ec 0c             	sub    $0xc,%esp
f0113592:	68 c4 bb 12 f0       	push   $0xf012bbc4
f0113597:	e8 d0 d9 fe ff       	call   f0100f6c <cprintf>
f011359c:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011359f:	c7 85 7c ff ff ff e9 	movl   $0xf012bbe9,-0x84(%ebp)
f01135a6:	bb 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f01135a9:	83 ec 08             	sub    $0x8,%esp
f01135ac:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f01135b2:	50                   	push   %eax
f01135b3:	6a 01                	push   $0x1
f01135b5:	e8 f7 eb fe ff       	call   f01021b1 <process_command>
f01135ba:	83 c4 10             	add    $0x10,%esp
f01135bd:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f01135c0:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01135c4:	75 30                	jne    f01135f6 <TestAutoCompleteCommand+0x22d>
f01135c6:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01135c9:	bb c0 be 12 f0       	mov    $0xf012bec0,%ebx
f01135ce:	ba 0c 00 00 00       	mov    $0xc,%edx
f01135d3:	89 c7                	mov    %eax,%edi
f01135d5:	89 de                	mov    %ebx,%esi
f01135d7:	89 d1                	mov    %edx,%ecx
f01135d9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01135db:	83 ec 08             	sub    $0x8,%esp
f01135de:	6a 0c                	push   $0xc
f01135e0:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01135e3:	50                   	push   %eax
f01135e4:	e8 df fc ff ff       	call   f01132c8 <hasExpectedCommands>
f01135e9:	83 c4 10             	add    $0x10,%esp
f01135ec:	85 c0                	test   %eax,%eax
f01135ee:	74 06                	je     f01135f6 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f01135f0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01135f4:	eb 10                	jmp    f0113606 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f01135f6:	83 ec 0c             	sub    $0xc,%esp
f01135f9:	68 ec bb 12 f0       	push   $0xf012bbec
f01135fe:	e8 69 d9 fe ff       	call   f0100f6c <cprintf>
f0113603:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0113606:	83 ec 0c             	sub    $0xc,%esp
f0113609:	68 44 bc 12 f0       	push   $0xf012bc44
f011360e:	e8 59 d9 fe ff       	call   f0100f6c <cprintf>
f0113613:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0113616:	c7 85 78 ff ff ff 69 	movl   $0xf012bc69,-0x88(%ebp)
f011361d:	bc 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0113620:	83 ec 08             	sub    $0x8,%esp
f0113623:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0113629:	50                   	push   %eax
f011362a:	6a 01                	push   $0x1
f011362c:	e8 80 eb fe ff       	call   f01021b1 <process_command>
f0113631:	83 c4 10             	add    $0x10,%esp
f0113634:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0113637:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011363b:	75 30                	jne    f011366d <TestAutoCompleteCommand+0x2a4>
f011363d:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0113640:	bb 08 bf 12 f0       	mov    $0xf012bf08,%ebx
f0113645:	ba 05 00 00 00       	mov    $0x5,%edx
f011364a:	89 c7                	mov    %eax,%edi
f011364c:	89 de                	mov    %ebx,%esi
f011364e:	89 d1                	mov    %edx,%ecx
f0113650:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0113652:	83 ec 08             	sub    $0x8,%esp
f0113655:	6a 05                	push   $0x5
f0113657:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011365a:	50                   	push   %eax
f011365b:	e8 68 fc ff ff       	call   f01132c8 <hasExpectedCommands>
f0113660:	83 c4 10             	add    $0x10,%esp
f0113663:	85 c0                	test   %eax,%eax
f0113665:	74 06                	je     f011366d <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0113667:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011366b:	eb 10                	jmp    f011367d <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f011366d:	83 ec 0c             	sub    $0xc,%esp
f0113670:	68 6c bc 12 f0       	push   $0xf012bc6c
f0113675:	e8 f2 d8 fe ff       	call   f0100f6c <cprintf>
f011367a:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f011367d:	83 ec 0c             	sub    $0xc,%esp
f0113680:	68 c4 bc 12 f0       	push   $0xf012bcc4
f0113685:	e8 e2 d8 fe ff       	call   f0100f6c <cprintf>
f011368a:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f011368d:	c7 85 70 ff ff ff f0 	movl   $0xf012bcf0,-0x90(%ebp)
f0113694:	bc 12 f0 
f0113697:	c7 85 74 ff ff ff f5 	movl   $0xf012bcf5,-0x8c(%ebp)
f011369e:	bc 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f01136a1:	83 ec 08             	sub    $0x8,%esp
f01136a4:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01136aa:	50                   	push   %eax
f01136ab:	6a 02                	push   $0x2
f01136ad:	e8 ff ea fe ff       	call   f01021b1 <process_command>
f01136b2:	83 c4 10             	add    $0x10,%esp
f01136b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f01136b8:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01136be:	83 ec 0c             	sub    $0xc,%esp
f01136c1:	50                   	push   %eax
f01136c2:	e8 b2 fc ff ff       	call   f0113379 <getIndexOfCommand>
f01136c7:	83 c4 10             	add    $0x10,%esp
f01136ca:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01136cd:	75 0f                	jne    f01136de <TestAutoCompleteCommand+0x315>
f01136cf:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f01136d4:	85 c0                	test   %eax,%eax
f01136d6:	75 06                	jne    f01136de <TestAutoCompleteCommand+0x315>
		eval += 10;
f01136d8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01136dc:	eb 10                	jmp    f01136ee <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01136de:	83 ec 0c             	sub    $0xc,%esp
f01136e1:	68 fc bc 12 f0       	push   $0xf012bcfc
f01136e6:	e8 81 d8 fe ff       	call   f0100f6c <cprintf>
f01136eb:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f01136ee:	83 ec 0c             	sub    $0xc,%esp
f01136f1:	68 4c bd 12 f0       	push   $0xf012bd4c
f01136f6:	e8 71 d8 fe ff       	call   f0100f6c <cprintf>
f01136fb:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f01136fe:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0113704:	bb 30 bf 12 f0       	mov    $0xf012bf30,%ebx
f0113709:	ba 03 00 00 00       	mov    $0x3,%edx
f011370e:	89 c7                	mov    %eax,%edi
f0113710:	89 de                	mov    %ebx,%esi
f0113712:	89 d1                	mov    %edx,%ecx
f0113714:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0113716:	83 ec 08             	sub    $0x8,%esp
f0113719:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f011371f:	50                   	push   %eax
f0113720:	6a 03                	push   $0x3
f0113722:	e8 8a ea fe ff       	call   f01021b1 <process_command>
f0113727:	83 c4 10             	add    $0x10,%esp
f011372a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f011372d:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0113733:	83 ec 0c             	sub    $0xc,%esp
f0113736:	50                   	push   %eax
f0113737:	e8 3d fc ff ff       	call   f0113379 <getIndexOfCommand>
f011373c:	83 c4 10             	add    $0x10,%esp
f011373f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0113742:	75 0f                	jne    f0113753 <TestAutoCompleteCommand+0x38a>
f0113744:	a1 0c 3b 5a f0       	mov    0xf05a3b0c,%eax
f0113749:	85 c0                	test   %eax,%eax
f011374b:	75 06                	jne    f0113753 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f011374d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0113751:	eb 10                	jmp    f0113763 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0113753:	83 ec 0c             	sub    $0xc,%esp
f0113756:	68 80 bd 12 f0       	push   $0xf012bd80
f011375b:	e8 0c d8 fe ff       	call   f0100f6c <cprintf>
f0113760:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0113763:	83 ec 08             	sub    $0x8,%esp
f0113766:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113769:	68 d0 bd 12 f0       	push   $0xf012bdd0
f011376e:	e8 f9 d7 fe ff       	call   f0100f6c <cprintf>
f0113773:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0113776:	83 ec 0c             	sub    $0xc,%esp
f0113779:	68 00 be 12 f0       	push   $0xf012be00
f011377e:	e8 e9 d7 fe ff       	call   f0100f6c <cprintf>
f0113783:	83 c4 10             	add    $0x10,%esp

	return 0;
f0113786:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011378b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011378e:	5b                   	pop    %ebx
f011378f:	5e                   	pop    %esi
f0113790:	5f                   	pop    %edi
f0113791:	5d                   	pop    %ebp
f0113792:	c3                   	ret    

f0113793 <test_str2lower_function>:

int test_str2lower_function()
{
f0113793:	55                   	push   %ebp
f0113794:	89 e5                	mov    %esp,%ebp
f0113796:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f011379c:	83 ec 0c             	sub    $0xc,%esp
f011379f:	68 3c bf 12 f0       	push   $0xf012bf3c
f01137a4:	e8 c3 d7 fe ff       	call   f0100f6c <cprintf>
f01137a9:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f01137ac:	83 ec 0c             	sub    $0xc,%esp
f01137af:	68 5d bf 12 f0       	push   $0xf012bf5d
f01137b4:	e8 b3 d7 fe ff       	call   f0100f6c <cprintf>
f01137b9:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f01137bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f01137c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f01137ca:	c7 45 ec 77 bf 12 f0 	movl   $0xf012bf77,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f01137d1:	83 ec 08             	sub    $0x8,%esp
f01137d4:	ff 75 ec             	pushl  -0x14(%ebp)
f01137d7:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f01137dd:	50                   	push   %eax
f01137de:	e8 db f4 00 00       	call   f0122cbe <str2lower>
f01137e3:	83 c4 10             	add    $0x10,%esp
f01137e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f01137e9:	83 ec 0c             	sub    $0xc,%esp
f01137ec:	ff 75 e8             	pushl  -0x18(%ebp)
f01137ef:	e8 e1 ed 00 00       	call   f01225d5 <strlen>
f01137f4:	83 c4 10             	add    $0x10,%esp
f01137f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f01137fa:	83 ec 08             	sub    $0x8,%esp
f01137fd:	68 82 bf 12 f0       	push   $0xf012bf82
f0113802:	ff 75 e8             	pushl  -0x18(%ebp)
f0113805:	e8 d7 ee 00 00       	call   f01226e1 <strcmp>
f011380a:	83 c4 10             	add    $0x10,%esp
f011380d:	85 c0                	test   %eax,%eax
f011380f:	75 13                	jne    f0113824 <test_str2lower_function+0x91>
f0113811:	83 ec 0c             	sub    $0xc,%esp
f0113814:	ff 75 ec             	pushl  -0x14(%ebp)
f0113817:	e8 b9 ed 00 00       	call   f01225d5 <strlen>
f011381c:	83 c4 10             	add    $0x10,%esp
f011381f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113822:	74 15                	je     f0113839 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0113824:	83 ec 08             	sub    $0x8,%esp
f0113827:	ff 75 e8             	pushl  -0x18(%ebp)
f011382a:	68 90 bf 12 f0       	push   $0xf012bf90
f011382f:	e8 38 d7 fe ff       	call   f0100f6c <cprintf>
f0113834:	83 c4 10             	add    $0x10,%esp
f0113837:	eb 04                	jmp    f011383d <test_str2lower_function+0xaa>
	else
		eval += 10;
f0113839:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f011383d:	c7 45 e0 f2 bf 12 f0 	movl   $0xf012bff2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0113844:	83 ec 08             	sub    $0x8,%esp
f0113847:	ff 75 e0             	pushl  -0x20(%ebp)
f011384a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113850:	50                   	push   %eax
f0113851:	e8 68 f4 00 00       	call   f0122cbe <str2lower>
f0113856:	83 c4 10             	add    $0x10,%esp
f0113859:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011385c:	83 ec 0c             	sub    $0xc,%esp
f011385f:	ff 75 e8             	pushl  -0x18(%ebp)
f0113862:	e8 6e ed 00 00       	call   f01225d5 <strlen>
f0113867:	83 c4 10             	add    $0x10,%esp
f011386a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f011386d:	83 ec 08             	sub    $0x8,%esp
f0113870:	68 f2 bf 12 f0       	push   $0xf012bff2
f0113875:	ff 75 e8             	pushl  -0x18(%ebp)
f0113878:	e8 64 ee 00 00       	call   f01226e1 <strcmp>
f011387d:	83 c4 10             	add    $0x10,%esp
f0113880:	85 c0                	test   %eax,%eax
f0113882:	75 13                	jne    f0113897 <test_str2lower_function+0x104>
f0113884:	83 ec 0c             	sub    $0xc,%esp
f0113887:	ff 75 e0             	pushl  -0x20(%ebp)
f011388a:	e8 46 ed 00 00       	call   f01225d5 <strlen>
f011388f:	83 c4 10             	add    $0x10,%esp
f0113892:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113895:	74 15                	je     f01138ac <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0113897:	83 ec 08             	sub    $0x8,%esp
f011389a:	ff 75 e8             	pushl  -0x18(%ebp)
f011389d:	68 f4 bf 12 f0       	push   $0xf012bff4
f01138a2:	e8 c5 d6 fe ff       	call   f0100f6c <cprintf>
f01138a7:	83 c4 10             	add    $0x10,%esp
f01138aa:	eb 04                	jmp    f01138b0 <test_str2lower_function+0x11d>
	else
		eval += 10;
f01138ac:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f01138b0:	c7 45 dc 4c c0 12 f0 	movl   $0xf012c04c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f01138b7:	83 ec 08             	sub    $0x8,%esp
f01138ba:	ff 75 dc             	pushl  -0x24(%ebp)
f01138bd:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f01138c3:	50                   	push   %eax
f01138c4:	e8 f5 f3 00 00       	call   f0122cbe <str2lower>
f01138c9:	83 c4 10             	add    $0x10,%esp
f01138cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01138cf:	83 ec 0c             	sub    $0xc,%esp
f01138d2:	ff 75 e8             	pushl  -0x18(%ebp)
f01138d5:	e8 fb ec 00 00       	call   f01225d5 <strlen>
f01138da:	83 c4 10             	add    $0x10,%esp
f01138dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f01138e0:	83 ec 08             	sub    $0x8,%esp
f01138e3:	68 4c c0 12 f0       	push   $0xf012c04c
f01138e8:	ff 75 e8             	pushl  -0x18(%ebp)
f01138eb:	e8 f1 ed 00 00       	call   f01226e1 <strcmp>
f01138f0:	83 c4 10             	add    $0x10,%esp
f01138f3:	85 c0                	test   %eax,%eax
f01138f5:	75 13                	jne    f011390a <test_str2lower_function+0x177>
f01138f7:	83 ec 0c             	sub    $0xc,%esp
f01138fa:	ff 75 dc             	pushl  -0x24(%ebp)
f01138fd:	e8 d3 ec 00 00       	call   f01225d5 <strlen>
f0113902:	83 c4 10             	add    $0x10,%esp
f0113905:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113908:	74 15                	je     f011391f <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f011390a:	83 ec 08             	sub    $0x8,%esp
f011390d:	ff 75 e8             	pushl  -0x18(%ebp)
f0113910:	68 58 c0 12 f0       	push   $0xf012c058
f0113915:	e8 52 d6 fe ff       	call   f0100f6c <cprintf>
f011391a:	83 c4 10             	add    $0x10,%esp
f011391d:	eb 04                	jmp    f0113923 <test_str2lower_function+0x190>
	else
		eval += 15;
f011391f:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0113923:	c7 45 d8 bb c0 12 f0 	movl   $0xf012c0bb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f011392a:	83 ec 08             	sub    $0x8,%esp
f011392d:	ff 75 d8             	pushl  -0x28(%ebp)
f0113930:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0113936:	50                   	push   %eax
f0113937:	e8 82 f3 00 00       	call   f0122cbe <str2lower>
f011393c:	83 c4 10             	add    $0x10,%esp
f011393f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0113942:	83 ec 0c             	sub    $0xc,%esp
f0113945:	ff 75 e8             	pushl  -0x18(%ebp)
f0113948:	e8 88 ec 00 00       	call   f01225d5 <strlen>
f011394d:	83 c4 10             	add    $0x10,%esp
f0113950:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0113953:	83 ec 08             	sub    $0x8,%esp
f0113956:	68 bb c0 12 f0       	push   $0xf012c0bb
f011395b:	ff 75 e8             	pushl  -0x18(%ebp)
f011395e:	e8 7e ed 00 00       	call   f01226e1 <strcmp>
f0113963:	83 c4 10             	add    $0x10,%esp
f0113966:	85 c0                	test   %eax,%eax
f0113968:	75 13                	jne    f011397d <test_str2lower_function+0x1ea>
f011396a:	83 ec 0c             	sub    $0xc,%esp
f011396d:	ff 75 d8             	pushl  -0x28(%ebp)
f0113970:	e8 60 ec 00 00       	call   f01225d5 <strlen>
f0113975:	83 c4 10             	add    $0x10,%esp
f0113978:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011397b:	74 15                	je     f0113992 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f011397d:	83 ec 08             	sub    $0x8,%esp
f0113980:	ff 75 e8             	pushl  -0x18(%ebp)
f0113983:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0113988:	e8 df d5 fe ff       	call   f0100f6c <cprintf>
f011398d:	83 c4 10             	add    $0x10,%esp
f0113990:	eb 04                	jmp    f0113996 <test_str2lower_function+0x203>
	else
		eval += 15;
f0113992:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0113996:	c7 45 d4 2a c1 12 f0 	movl   $0xf012c12a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f011399d:	83 ec 08             	sub    $0x8,%esp
f01139a0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01139a3:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f01139a9:	50                   	push   %eax
f01139aa:	e8 0f f3 00 00       	call   f0122cbe <str2lower>
f01139af:	83 c4 10             	add    $0x10,%esp
f01139b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01139b5:	83 ec 0c             	sub    $0xc,%esp
f01139b8:	ff 75 e8             	pushl  -0x18(%ebp)
f01139bb:	e8 15 ec 00 00       	call   f01225d5 <strlen>
f01139c0:	83 c4 10             	add    $0x10,%esp
f01139c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f01139c6:	83 ec 08             	sub    $0x8,%esp
f01139c9:	68 40 c1 12 f0       	push   $0xf012c140
f01139ce:	ff 75 e8             	pushl  -0x18(%ebp)
f01139d1:	e8 0b ed 00 00       	call   f01226e1 <strcmp>
f01139d6:	83 c4 10             	add    $0x10,%esp
f01139d9:	85 c0                	test   %eax,%eax
f01139db:	75 13                	jne    f01139f0 <test_str2lower_function+0x25d>
f01139dd:	83 ec 0c             	sub    $0xc,%esp
f01139e0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01139e3:	e8 ed eb 00 00       	call   f01225d5 <strlen>
f01139e8:	83 c4 10             	add    $0x10,%esp
f01139eb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01139ee:	74 15                	je     f0113a05 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f01139f0:	83 ec 08             	sub    $0x8,%esp
f01139f3:	ff 75 e8             	pushl  -0x18(%ebp)
f01139f6:	68 58 c1 12 f0       	push   $0xf012c158
f01139fb:	e8 6c d5 fe ff       	call   f0100f6c <cprintf>
f0113a00:	83 c4 10             	add    $0x10,%esp
f0113a03:	eb 04                	jmp    f0113a09 <test_str2lower_function+0x276>
	else
		eval += 15;
f0113a05:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0113a09:	c7 45 d0 c5 c1 12 f0 	movl   $0xf012c1c5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0113a10:	83 ec 08             	sub    $0x8,%esp
f0113a13:	ff 75 d0             	pushl  -0x30(%ebp)
f0113a16:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0113a1c:	50                   	push   %eax
f0113a1d:	e8 9c f2 00 00       	call   f0122cbe <str2lower>
f0113a22:	83 c4 10             	add    $0x10,%esp
f0113a25:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0113a28:	83 ec 0c             	sub    $0xc,%esp
f0113a2b:	ff 75 e8             	pushl  -0x18(%ebp)
f0113a2e:	e8 a2 eb 00 00       	call   f01225d5 <strlen>
f0113a33:	83 c4 10             	add    $0x10,%esp
f0113a36:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0113a39:	83 ec 08             	sub    $0x8,%esp
f0113a3c:	68 d1 c1 12 f0       	push   $0xf012c1d1
f0113a41:	ff 75 e8             	pushl  -0x18(%ebp)
f0113a44:	e8 98 ec 00 00       	call   f01226e1 <strcmp>
f0113a49:	83 c4 10             	add    $0x10,%esp
f0113a4c:	85 c0                	test   %eax,%eax
f0113a4e:	75 13                	jne    f0113a63 <test_str2lower_function+0x2d0>
f0113a50:	83 ec 0c             	sub    $0xc,%esp
f0113a53:	ff 75 d0             	pushl  -0x30(%ebp)
f0113a56:	e8 7a eb 00 00       	call   f01225d5 <strlen>
f0113a5b:	83 c4 10             	add    $0x10,%esp
f0113a5e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113a61:	74 15                	je     f0113a78 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0113a63:	83 ec 08             	sub    $0x8,%esp
f0113a66:	ff 75 e8             	pushl  -0x18(%ebp)
f0113a69:	68 e0 c1 12 f0       	push   $0xf012c1e0
f0113a6e:	e8 f9 d4 fe ff       	call   f0100f6c <cprintf>
f0113a73:	83 c4 10             	add    $0x10,%esp
f0113a76:	eb 04                	jmp    f0113a7c <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0113a78:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0113a7c:	c7 45 cc 43 c2 12 f0 	movl   $0xf012c243,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0113a83:	83 ec 08             	sub    $0x8,%esp
f0113a86:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a89:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0113a8f:	50                   	push   %eax
f0113a90:	e8 29 f2 00 00       	call   f0122cbe <str2lower>
f0113a95:	83 c4 10             	add    $0x10,%esp
f0113a98:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0113a9b:	83 ec 0c             	sub    $0xc,%esp
f0113a9e:	ff 75 e8             	pushl  -0x18(%ebp)
f0113aa1:	e8 2f eb 00 00       	call   f01225d5 <strlen>
f0113aa6:	83 c4 10             	add    $0x10,%esp
f0113aa9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0113aac:	83 ec 08             	sub    $0x8,%esp
f0113aaf:	68 5e c2 12 f0       	push   $0xf012c25e
f0113ab4:	ff 75 e8             	pushl  -0x18(%ebp)
f0113ab7:	e8 25 ec 00 00       	call   f01226e1 <strcmp>
f0113abc:	83 c4 10             	add    $0x10,%esp
f0113abf:	85 c0                	test   %eax,%eax
f0113ac1:	75 13                	jne    f0113ad6 <test_str2lower_function+0x343>
f0113ac3:	83 ec 0c             	sub    $0xc,%esp
f0113ac6:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ac9:	e8 07 eb 00 00       	call   f01225d5 <strlen>
f0113ace:	83 c4 10             	add    $0x10,%esp
f0113ad1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113ad4:	74 15                	je     f0113aeb <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0113ad6:	83 ec 08             	sub    $0x8,%esp
f0113ad9:	ff 75 e8             	pushl  -0x18(%ebp)
f0113adc:	68 7c c2 12 f0       	push   $0xf012c27c
f0113ae1:	e8 86 d4 fe ff       	call   f0100f6c <cprintf>
f0113ae6:	83 c4 10             	add    $0x10,%esp
f0113ae9:	eb 04                	jmp    f0113aef <test_str2lower_function+0x35c>
	else
		eval += 20;
f0113aeb:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0113aef:	83 ec 08             	sub    $0x8,%esp
f0113af2:	ff 75 f4             	pushl  -0xc(%ebp)
f0113af5:	68 f0 c2 12 f0       	push   $0xf012c2f0
f0113afa:	e8 6d d4 fe ff       	call   f0100f6c <cprintf>
f0113aff:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0113b02:	83 ec 0c             	sub    $0xc,%esp
f0113b05:	68 00 be 12 f0       	push   $0xf012be00
f0113b0a:	e8 5d d4 fe ff       	call   f0100f6c <cprintf>
f0113b0f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113b12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113b17:	c9                   	leave  
f0113b18:	c3                   	ret    

f0113b19 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0113b19:	55                   	push   %ebp
f0113b1a:	89 e5                	mov    %esp,%ebp
f0113b1c:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0113b1f:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0113b26:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0113b2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113b34:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113b39:	ff 75 ec             	pushl  -0x14(%ebp)
f0113b3c:	ff 75 f0             	pushl  -0x10(%ebp)
f0113b3f:	ff 75 f4             	pushl  -0xc(%ebp)
f0113b42:	50                   	push   %eax
f0113b43:	e8 e0 4f ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113b48:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113b4b:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113b50:	ff 75 ec             	pushl  -0x14(%ebp)
f0113b53:	ff 75 f0             	pushl  -0x10(%ebp)
f0113b56:	ff 75 f4             	pushl  -0xc(%ebp)
f0113b59:	50                   	push   %eax
f0113b5a:	e8 a0 4d 00 00       	call   f01188ff <CP>
f0113b5f:	83 c4 10             	add    $0x10,%esp
f0113b62:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113b65:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113b69:	74 17                	je     f0113b82 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0113b6b:	83 ec 04             	sub    $0x4,%esp
f0113b6e:	68 20 c3 12 f0       	push   $0xf012c320
f0113b73:	68 23 01 00 00       	push   $0x123
f0113b78:	68 42 c3 12 f0       	push   $0xf012c342
f0113b7d:	e8 98 c7 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0113b82:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0113b89:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0113b90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113b97:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113b9c:	ff 75 ec             	pushl  -0x14(%ebp)
f0113b9f:	ff 75 f0             	pushl  -0x10(%ebp)
f0113ba2:	ff 75 f4             	pushl  -0xc(%ebp)
f0113ba5:	50                   	push   %eax
f0113ba6:	e8 7d 4f ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113bab:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113bae:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113bb3:	ff 75 ec             	pushl  -0x14(%ebp)
f0113bb6:	ff 75 f0             	pushl  -0x10(%ebp)
f0113bb9:	ff 75 f4             	pushl  -0xc(%ebp)
f0113bbc:	50                   	push   %eax
f0113bbd:	e8 3d 4d 00 00       	call   f01188ff <CP>
f0113bc2:	83 c4 10             	add    $0x10,%esp
f0113bc5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113bc8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113bcc:	74 17                	je     f0113be5 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0113bce:	83 ec 04             	sub    $0x4,%esp
f0113bd1:	68 60 c3 12 f0       	push   $0xf012c360
f0113bd6:	68 2f 01 00 00       	push   $0x12f
f0113bdb:	68 42 c3 12 f0       	push   $0xf012c342
f0113be0:	e8 35 c7 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0113be5:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0113bec:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0113bf3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113bfa:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113bff:	ff 75 ec             	pushl  -0x14(%ebp)
f0113c02:	ff 75 f0             	pushl  -0x10(%ebp)
f0113c05:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c08:	50                   	push   %eax
f0113c09:	e8 1a 4f ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113c0e:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113c11:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113c16:	ff 75 ec             	pushl  -0x14(%ebp)
f0113c19:	ff 75 f0             	pushl  -0x10(%ebp)
f0113c1c:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c1f:	50                   	push   %eax
f0113c20:	e8 da 4c 00 00       	call   f01188ff <CP>
f0113c25:	83 c4 10             	add    $0x10,%esp
f0113c28:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113c2b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113c2f:	74 17                	je     f0113c48 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0113c31:	83 ec 04             	sub    $0x4,%esp
f0113c34:	68 84 c3 12 f0       	push   $0xf012c384
f0113c39:	68 3a 01 00 00       	push   $0x13a
f0113c3e:	68 42 c3 12 f0       	push   $0xf012c342
f0113c43:	e8 d2 c6 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0113c48:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0113c4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0113c56:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113c5d:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113c62:	ff 75 ec             	pushl  -0x14(%ebp)
f0113c65:	ff 75 f0             	pushl  -0x10(%ebp)
f0113c68:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c6b:	50                   	push   %eax
f0113c6c:	e8 b7 4e ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113c71:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113c74:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113c79:	ff 75 ec             	pushl  -0x14(%ebp)
f0113c7c:	ff 75 f0             	pushl  -0x10(%ebp)
f0113c7f:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c82:	50                   	push   %eax
f0113c83:	e8 77 4c 00 00       	call   f01188ff <CP>
f0113c88:	83 c4 10             	add    $0x10,%esp
f0113c8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113c8e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113c92:	74 17                	je     f0113cab <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0113c94:	83 ec 04             	sub    $0x4,%esp
f0113c97:	68 a8 c3 12 f0       	push   $0xf012c3a8
f0113c9c:	68 46 01 00 00       	push   $0x146
f0113ca1:	68 42 c3 12 f0       	push   $0xf012c342
f0113ca6:	e8 6f c6 fe ff       	call   f010031a <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0113cab:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0113cb2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0113cb9:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113cc0:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113cc5:	ff 75 ec             	pushl  -0x14(%ebp)
f0113cc8:	ff 75 f0             	pushl  -0x10(%ebp)
f0113ccb:	ff 75 f4             	pushl  -0xc(%ebp)
f0113cce:	50                   	push   %eax
f0113ccf:	e8 54 4e ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113cd4:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113cd7:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113cdc:	ff 75 ec             	pushl  -0x14(%ebp)
f0113cdf:	ff 75 f0             	pushl  -0x10(%ebp)
f0113ce2:	ff 75 f4             	pushl  -0xc(%ebp)
f0113ce5:	50                   	push   %eax
f0113ce6:	e8 14 4c 00 00       	call   f01188ff <CP>
f0113ceb:	83 c4 10             	add    $0x10,%esp
f0113cee:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113cf1:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113cf5:	74 17                	je     f0113d0e <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0113cf7:	83 ec 04             	sub    $0x4,%esp
f0113cfa:	68 cc c3 12 f0       	push   $0xf012c3cc
f0113cff:	68 52 01 00 00       	push   $0x152
f0113d04:	68 42 c3 12 f0       	push   $0xf012c342
f0113d09:	e8 0c c6 fe ff       	call   f010031a <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0113d0e:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0113d15:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0113d1c:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113d23:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113d28:	ff 75 ec             	pushl  -0x14(%ebp)
f0113d2b:	ff 75 f0             	pushl  -0x10(%ebp)
f0113d2e:	ff 75 f4             	pushl  -0xc(%ebp)
f0113d31:	50                   	push   %eax
f0113d32:	e8 f1 4d ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113d37:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113d3a:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113d3f:	ff 75 ec             	pushl  -0x14(%ebp)
f0113d42:	ff 75 f0             	pushl  -0x10(%ebp)
f0113d45:	ff 75 f4             	pushl  -0xc(%ebp)
f0113d48:	50                   	push   %eax
f0113d49:	e8 b1 4b 00 00       	call   f01188ff <CP>
f0113d4e:	83 c4 10             	add    $0x10,%esp
f0113d51:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113d54:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113d58:	74 17                	je     f0113d71 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0113d5a:	83 ec 04             	sub    $0x4,%esp
f0113d5d:	68 f0 c3 12 f0       	push   $0xf012c3f0
f0113d62:	68 5e 01 00 00       	push   $0x15e
f0113d67:	68 42 c3 12 f0       	push   $0xf012c342
f0113d6c:	e8 a9 c5 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0113d71:	83 ec 0c             	sub    $0xc,%esp
f0113d74:	68 1c c4 12 f0       	push   $0xf012c41c
f0113d79:	e8 ee d1 fe ff       	call   f0100f6c <cprintf>
f0113d7e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113d81:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d86:	c9                   	leave  
f0113d87:	c3                   	ret    

f0113d88 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0113d88:	55                   	push   %ebp
f0113d89:	89 e5                	mov    %esp,%ebp
f0113d8b:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0113d8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0113d95:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0113d9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113da3:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113da8:	ff 75 ec             	pushl  -0x14(%ebp)
f0113dab:	ff 75 f0             	pushl  -0x10(%ebp)
f0113dae:	ff 75 f4             	pushl  -0xc(%ebp)
f0113db1:	50                   	push   %eax
f0113db2:	e8 71 4d ff ff       	call   f0108b28 <pt_set_page_permissions>
f0113db7:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0113dba:	83 ec 04             	sub    $0x4,%esp
f0113dbd:	68 6c c4 12 f0       	push   $0xf012c46c
f0113dc2:	68 6b 01 00 00       	push   $0x16b
f0113dc7:	68 42 c3 12 f0       	push   $0xf012c342
f0113dcc:	e8 49 c5 fe ff       	call   f010031a <_panic>

f0113dd1 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0113dd1:	55                   	push   %ebp
f0113dd2:	89 e5                	mov    %esp,%ebp
f0113dd4:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0113dd7:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0113dde:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113de3:	83 ec 08             	sub    $0x8,%esp
f0113de6:	ff 75 f4             	pushl  -0xc(%ebp)
f0113de9:	50                   	push   %eax
f0113dea:	e8 fd 4d ff ff       	call   f0108bec <pt_get_page_permissions>
f0113def:	83 c4 10             	add    $0x10,%esp
f0113df2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0113df5:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0113df9:	74 17                	je     f0113e12 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0113dfb:	83 ec 04             	sub    $0x4,%esp
f0113dfe:	68 08 c5 12 f0       	push   $0xf012c508
f0113e03:	68 79 01 00 00       	push   $0x179
f0113e08:	68 42 c3 12 f0       	push   $0xf012c342
f0113e0d:	e8 08 c5 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0113e12:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113e19:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113e1e:	83 ec 08             	sub    $0x8,%esp
f0113e21:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e24:	50                   	push   %eax
f0113e25:	e8 c2 4d ff ff       	call   f0108bec <pt_get_page_permissions>
f0113e2a:	83 c4 10             	add    $0x10,%esp
f0113e2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0113e30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113e34:	74 17                	je     f0113e4d <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0113e36:	83 ec 04             	sub    $0x4,%esp
f0113e39:	68 2c c5 12 f0       	push   $0xf012c52c
f0113e3e:	68 81 01 00 00       	push   $0x181
f0113e43:	68 42 c3 12 f0       	push   $0xf012c342
f0113e48:	e8 cd c4 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0113e4d:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113e54:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113e59:	83 ec 08             	sub    $0x8,%esp
f0113e5c:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e5f:	50                   	push   %eax
f0113e60:	e8 87 4d ff ff       	call   f0108bec <pt_get_page_permissions>
f0113e65:	83 c4 10             	add    $0x10,%esp
f0113e68:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0113e6b:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0113e6f:	74 17                	je     f0113e88 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0113e71:	83 ec 04             	sub    $0x4,%esp
f0113e74:	68 50 c5 12 f0       	push   $0xf012c550
f0113e79:	68 89 01 00 00       	push   $0x189
f0113e7e:	68 42 c3 12 f0       	push   $0xf012c342
f0113e83:	e8 92 c4 fe ff       	call   f010031a <_panic>
	}

	va = 0xF1000000;
f0113e88:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113e8f:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113e94:	83 ec 08             	sub    $0x8,%esp
f0113e97:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e9a:	50                   	push   %eax
f0113e9b:	e8 4c 4d ff ff       	call   f0108bec <pt_get_page_permissions>
f0113ea0:	83 c4 10             	add    $0x10,%esp
f0113ea3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0113ea6:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0113eaa:	74 17                	je     f0113ec3 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0113eac:	83 ec 04             	sub    $0x4,%esp
f0113eaf:	68 74 c5 12 f0       	push   $0xf012c574
f0113eb4:	68 90 01 00 00       	push   $0x190
f0113eb9:	68 42 c3 12 f0       	push   $0xf012c342
f0113ebe:	e8 57 c4 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0113ec3:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113eca:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113ecf:	83 ec 08             	sub    $0x8,%esp
f0113ed2:	ff 75 f4             	pushl  -0xc(%ebp)
f0113ed5:	50                   	push   %eax
f0113ed6:	e8 11 4d ff ff       	call   f0108bec <pt_get_page_permissions>
f0113edb:	83 c4 10             	add    $0x10,%esp
f0113ede:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0113ee1:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0113ee5:	74 17                	je     f0113efe <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0113ee7:	83 ec 04             	sub    $0x4,%esp
f0113eea:	68 98 c5 12 f0       	push   $0xf012c598
f0113eef:	68 97 01 00 00       	push   $0x197
f0113ef4:	68 42 c3 12 f0       	push   $0xf012c342
f0113ef9:	e8 1c c4 fe ff       	call   f010031a <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0113efe:	83 ec 0c             	sub    $0xc,%esp
f0113f01:	68 bc c5 12 f0       	push   $0xf012c5bc
f0113f06:	e8 61 d0 fe ff       	call   f0100f6c <cprintf>
f0113f0b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113f0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113f13:	c9                   	leave  
f0113f14:	c3                   	ret    

f0113f15 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0113f15:	55                   	push   %ebp
f0113f16:	89 e5                	mov    %esp,%ebp
f0113f18:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0113f1b:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113f22:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113f27:	83 ec 08             	sub    $0x8,%esp
f0113f2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0113f2d:	50                   	push   %eax
f0113f2e:	e8 02 4d ff ff       	call   f0108c35 <pt_clear_page_table_entry>
f0113f33:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0113f36:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113f3b:	83 ec 08             	sub    $0x8,%esp
f0113f3e:	ff 75 f4             	pushl  -0xc(%ebp)
f0113f41:	50                   	push   %eax
f0113f42:	e8 14 49 00 00       	call   f011885b <CE>
f0113f47:	83 c4 10             	add    $0x10,%esp
f0113f4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113f4d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113f51:	74 17                	je     f0113f6a <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0113f53:	83 ec 04             	sub    $0x4,%esp
f0113f56:	68 04 c6 12 f0       	push   $0xf012c604
f0113f5b:	68 a7 01 00 00       	push   $0x1a7
f0113f60:	68 42 c3 12 f0       	push   $0xf012c342
f0113f65:	e8 b0 c3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0113f6a:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113f71:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113f76:	83 ec 08             	sub    $0x8,%esp
f0113f79:	ff 75 f4             	pushl  -0xc(%ebp)
f0113f7c:	50                   	push   %eax
f0113f7d:	e8 b3 4c ff ff       	call   f0108c35 <pt_clear_page_table_entry>
f0113f82:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0113f85:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113f8a:	83 ec 08             	sub    $0x8,%esp
f0113f8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0113f90:	50                   	push   %eax
f0113f91:	e8 c5 48 00 00       	call   f011885b <CE>
f0113f96:	83 c4 10             	add    $0x10,%esp
f0113f99:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113f9c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113fa0:	74 17                	je     f0113fb9 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0113fa2:	83 ec 04             	sub    $0x4,%esp
f0113fa5:	68 30 c6 12 f0       	push   $0xf012c630
f0113faa:	68 af 01 00 00       	push   $0x1af
f0113faf:	68 42 c3 12 f0       	push   $0xf012c342
f0113fb4:	e8 61 c3 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0113fb9:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113fc0:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113fc5:	83 ec 08             	sub    $0x8,%esp
f0113fc8:	ff 75 f4             	pushl  -0xc(%ebp)
f0113fcb:	50                   	push   %eax
f0113fcc:	e8 64 4c ff ff       	call   f0108c35 <pt_clear_page_table_entry>
f0113fd1:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0113fd4:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0113fd9:	83 ec 08             	sub    $0x8,%esp
f0113fdc:	ff 75 f4             	pushl  -0xc(%ebp)
f0113fdf:	50                   	push   %eax
f0113fe0:	e8 76 48 00 00       	call   f011885b <CE>
f0113fe5:	83 c4 10             	add    $0x10,%esp
f0113fe8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113feb:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113fef:	74 17                	je     f0114008 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0113ff1:	83 ec 04             	sub    $0x4,%esp
f0113ff4:	68 5c c6 12 f0       	push   $0xf012c65c
f0113ff9:	68 b7 01 00 00       	push   $0x1b7
f0113ffe:	68 42 c3 12 f0       	push   $0xf012c342
f0114003:	e8 12 c3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0000000;
f0114008:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011400f:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0114014:	83 ec 08             	sub    $0x8,%esp
f0114017:	ff 75 f4             	pushl  -0xc(%ebp)
f011401a:	50                   	push   %eax
f011401b:	e8 15 4c ff ff       	call   f0108c35 <pt_clear_page_table_entry>
f0114020:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0114023:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0114028:	83 ec 08             	sub    $0x8,%esp
f011402b:	ff 75 f4             	pushl  -0xc(%ebp)
f011402e:	50                   	push   %eax
f011402f:	e8 27 48 00 00       	call   f011885b <CE>
f0114034:	83 c4 10             	add    $0x10,%esp
f0114037:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011403a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011403e:	74 17                	je     f0114057 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0114040:	83 ec 04             	sub    $0x4,%esp
f0114043:	68 88 c6 12 f0       	push   $0xf012c688
f0114048:	68 bf 01 00 00       	push   $0x1bf
f011404d:	68 42 c3 12 f0       	push   $0xf012c342
f0114052:	e8 c3 c2 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0114057:	83 ec 0c             	sub    $0xc,%esp
f011405a:	68 b4 c6 12 f0       	push   $0xf012c6b4
f011405f:	e8 08 cf fe ff       	call   f0100f6c <cprintf>
f0114064:	83 c4 10             	add    $0x10,%esp
	return 0;
f0114067:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011406c:	c9                   	leave  
f011406d:	c3                   	ret    

f011406e <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011406e:	55                   	push   %ebp
f011406f:	89 e5                	mov    %esp,%ebp
f0114071:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0114074:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011407b:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0114080:	83 ec 08             	sub    $0x8,%esp
f0114083:	ff 75 f4             	pushl  -0xc(%ebp)
f0114086:	50                   	push   %eax
f0114087:	e8 a9 4b ff ff       	call   f0108c35 <pt_clear_page_table_entry>
f011408c:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f011408f:	83 ec 04             	sub    $0x4,%esp
f0114092:	68 00 c7 12 f0       	push   $0xf012c700
f0114097:	68 ca 01 00 00       	push   $0x1ca
f011409c:	68 42 c3 12 f0       	push   $0xf012c342
f01140a1:	e8 74 c2 fe ff       	call   f010031a <_panic>

f01140a6 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01140a6:	55                   	push   %ebp
f01140a7:	89 e5                	mov    %esp,%ebp
f01140a9:	57                   	push   %edi
f01140aa:	56                   	push   %esi
f01140ab:	53                   	push   %ebx
f01140ac:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01140b2:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01140b8:	bb 44 ca 12 f0       	mov    $0xf012ca44,%ebx
f01140bd:	ba 0f 00 00 00       	mov    $0xf,%edx
f01140c2:	89 c7                	mov    %eax,%edi
f01140c4:	89 de                	mov    %ebx,%esi
f01140c6:	89 d1                	mov    %edx,%ecx
f01140c8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01140ca:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01140d0:	b9 23 00 00 00       	mov    $0x23,%ecx
f01140d5:	b0 00                	mov    $0x0,%al
f01140d7:	89 d7                	mov    %edx,%edi
f01140d9:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01140db:	6a 00                	push   $0x0
f01140dd:	6a 0a                	push   $0xa
f01140df:	6a 14                	push   $0x14
f01140e1:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01140e7:	50                   	push   %eax
f01140e8:	e8 83 59 ff ff       	call   f0109a70 <env_create>
f01140ed:	83 c4 10             	add    $0x10,%esp
f01140f0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01140f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01140f6:	8b 40 64             	mov    0x64(%eax),%eax
f01140f9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01140fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01140ff:	8b 40 68             	mov    0x68(%eax),%eax
f0114102:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0114105:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114108:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011410b:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0114112:	75 70 20 
f0114115:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f011411c:	00 00 00 
f011411f:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0114125:	b9 03 00 00 00       	mov    $0x3,%ecx
f011412a:	b8 00 00 00 00       	mov    $0x0,%eax
f011412f:	89 d7                	mov    %edx,%edi
f0114131:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114133:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114136:	8b 40 10             	mov    0x10(%eax),%eax
f0114139:	83 ec 08             	sub    $0x8,%esp
f011413c:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0114142:	52                   	push   %edx
f0114143:	50                   	push   %eax
f0114144:	e8 32 e9 00 00       	call   f0122a7b <ltostr>
f0114149:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011414c:	83 ec 04             	sub    $0x4,%esp
f011414f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0114155:	50                   	push   %eax
f0114156:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f011415c:	50                   	push   %eax
f011415d:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0114163:	50                   	push   %eax
f0114164:	e8 eb e9 00 00       	call   f0122b54 <strcconcat>
f0114169:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f011416c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0114173:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f011417a:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0114181:	83 ec 0c             	sub    $0xc,%esp
f0114184:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114187:	e8 d0 48 00 00       	call   f0118a5c <ClearUserSpace>
f011418c:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f011418f:	83 ec 04             	sub    $0x4,%esp
f0114192:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0114198:	50                   	push   %eax
f0114199:	68 96 c7 12 f0       	push   $0xf012c796
f011419e:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01141a4:	50                   	push   %eax
f01141a5:	e8 aa e9 00 00       	call   f0122b54 <strcconcat>
f01141aa:	83 c4 10             	add    $0x10,%esp
f01141ad:	83 ec 0c             	sub    $0xc,%esp
f01141b0:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01141b6:	50                   	push   %eax
f01141b7:	e8 20 dd fe ff       	call   f0101edc <execute_command>
f01141bc:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01141bf:	83 ec 04             	sub    $0x4,%esp
f01141c2:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01141c8:	50                   	push   %eax
f01141c9:	68 a1 c7 12 f0       	push   $0xf012c7a1
f01141ce:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01141d4:	50                   	push   %eax
f01141d5:	e8 7a e9 00 00       	call   f0122b54 <strcconcat>
f01141da:	83 c4 10             	add    $0x10,%esp
f01141dd:	83 ec 0c             	sub    $0xc,%esp
f01141e0:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01141e6:	50                   	push   %eax
f01141e7:	e8 f0 dc fe ff       	call   f0101edc <execute_command>
f01141ec:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01141ef:	83 ec 04             	sub    $0x4,%esp
f01141f2:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01141f8:	50                   	push   %eax
f01141f9:	68 ac c7 12 f0       	push   $0xf012c7ac
f01141fe:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0114204:	50                   	push   %eax
f0114205:	e8 4a e9 00 00       	call   f0122b54 <strcconcat>
f011420a:	83 c4 10             	add    $0x10,%esp
f011420d:	83 ec 0c             	sub    $0xc,%esp
f0114210:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0114216:	50                   	push   %eax
f0114217:	e8 c0 dc fe ff       	call   f0101edc <execute_command>
f011421c:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f011421f:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0114226:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114229:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f011422c:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0114233:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114236:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0114239:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0114240:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114243:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0114246:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114249:	83 ec 08             	sub    $0x8,%esp
f011424c:	50                   	push   %eax
f011424d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114250:	e8 6e 47 00 00       	call   f01189c3 <GP>
f0114255:	83 c4 10             	add    $0x10,%esp
f0114258:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f011425b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0114262:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0114269:	e8 9b 97 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011426e:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0114271:	83 ec 0c             	sub    $0xc,%esp
f0114274:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0114279:	e8 ee cc fe ff       	call   f0100f6c <cprintf>
f011427e:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0114281:	6a 03                	push   $0x3
f0114283:	68 00 00 90 02       	push   $0x2900000
f0114288:	68 00 00 80 02       	push   $0x2800000
f011428d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114290:	e8 3b 54 ff ff       	call   f01096d0 <cut_paste_pages>
f0114295:	83 c4 10             	add    $0x10,%esp
f0114298:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f011429b:	e8 69 97 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01142a0:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f01142a3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01142aa:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01142ae:	75 08                	jne    f01142b8 <test_cut_paste_pages+0x212>
f01142b0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142b3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01142b6:	74 2b                	je     f01142e3 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01142b8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142bb:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01142be:	83 ec 0c             	sub    $0xc,%esp
f01142c1:	50                   	push   %eax
f01142c2:	ff 75 b4             	pushl  -0x4c(%ebp)
f01142c5:	68 e8 c7 12 f0       	push   $0xf012c7e8
f01142ca:	68 04 02 00 00       	push   $0x204
f01142cf:	68 42 c3 12 f0       	push   $0xf012c342
f01142d4:	e8 de c1 fe ff       	call   f01004b7 <_warn>
f01142d9:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01142dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f01142e3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01142e7:	74 04                	je     f01142ed <test_cut_paste_pages+0x247>
f01142e9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01142ed:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01142f4:	83 ec 08             	sub    $0x8,%esp
f01142f7:	6a 00                	push   $0x0
f01142f9:	6a 01                	push   $0x1
f01142fb:	6a 00                	push   $0x0
f01142fd:	68 ff 0f 00 00       	push   $0xfff
f0114302:	ff 75 bc             	pushl  -0x44(%ebp)
f0114305:	6a 01                	push   $0x1
f0114307:	68 00 30 00 00       	push   $0x3000
f011430c:	68 00 00 90 02       	push   $0x2900000
f0114311:	68 00 00 80 02       	push   $0x2800000
f0114316:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114319:	e8 72 47 00 00       	call   f0118a90 <CCP>
f011431e:	83 c4 30             	add    $0x30,%esp
f0114321:	83 f8 01             	cmp    $0x1,%eax
f0114324:	74 21                	je     f0114347 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0114326:	83 ec 04             	sub    $0x4,%esp
f0114329:	68 3c c8 12 f0       	push   $0xf012c83c
f011432e:	68 0c 02 00 00       	push   $0x20c
f0114333:	68 42 c3 12 f0       	push   $0xf012c342
f0114338:	e8 7a c1 fe ff       	call   f01004b7 <_warn>
f011433d:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0114340:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0114347:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011434b:	74 04                	je     f0114351 <test_cut_paste_pages+0x2ab>
f011434d:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0114351:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0114358:	83 ec 04             	sub    $0x4,%esp
f011435b:	6a 00                	push   $0x0
f011435d:	68 00 00 90 02       	push   $0x2900000
f0114362:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114365:	e8 b7 41 00 00       	call   f0118521 <CB>
f011436a:	83 c4 10             	add    $0x10,%esp
f011436d:	85 c0                	test   %eax,%eax
f011436f:	0f 84 f6 00 00 00    	je     f011446b <test_cut_paste_pages+0x3c5>
f0114375:	83 ec 04             	sub    $0x4,%esp
f0114378:	6a 00                	push   $0x0
f011437a:	68 00 10 90 02       	push   $0x2901000
f011437f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114382:	e8 9a 41 00 00       	call   f0118521 <CB>
f0114387:	83 c4 10             	add    $0x10,%esp
f011438a:	85 c0                	test   %eax,%eax
f011438c:	0f 84 d9 00 00 00    	je     f011446b <test_cut_paste_pages+0x3c5>
f0114392:	83 ec 04             	sub    $0x4,%esp
f0114395:	6a 00                	push   $0x0
f0114397:	68 00 20 90 02       	push   $0x2902000
f011439c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011439f:	e8 7d 41 00 00       	call   f0118521 <CB>
f01143a4:	83 c4 10             	add    $0x10,%esp
f01143a7:	85 c0                	test   %eax,%eax
f01143a9:	0f 84 bc 00 00 00    	je     f011446b <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01143af:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f01143b6:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01143bd:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01143c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01143c7:	8a 00                	mov    (%eax),%al
f01143c9:	3c 61                	cmp    $0x61,%al
f01143cb:	75 12                	jne    f01143df <test_cut_paste_pages+0x339>
f01143cd:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01143d0:	8a 00                	mov    (%eax),%al
f01143d2:	3c 62                	cmp    $0x62,%al
f01143d4:	75 09                	jne    f01143df <test_cut_paste_pages+0x339>
f01143d6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01143d9:	8a 00                	mov    (%eax),%al
f01143db:	3c 63                	cmp    $0x63,%al
f01143dd:	74 21                	je     f0114400 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01143df:	83 ec 04             	sub    $0x4,%esp
f01143e2:	68 88 c8 12 f0       	push   $0xf012c888
f01143e7:	68 19 02 00 00       	push   $0x219
f01143ec:	68 42 c3 12 f0       	push   $0xf012c342
f01143f1:	e8 c1 c0 fe ff       	call   f01004b7 <_warn>
f01143f6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01143f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114400:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114404:	74 04                	je     f011440a <test_cut_paste_pages+0x364>
f0114406:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011440a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0114411:	83 ec 04             	sub    $0x4,%esp
f0114414:	6a 01                	push   $0x1
f0114416:	68 00 10 90 02       	push   $0x2901000
f011441b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011441e:	e8 fe 40 00 00       	call   f0118521 <CB>
f0114423:	83 c4 10             	add    $0x10,%esp
f0114426:	85 c0                	test   %eax,%eax
f0114428:	74 41                	je     f011446b <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f011442a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011442d:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0114430:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114433:	8a 00                	mov    (%eax),%al
f0114435:	3c 79                	cmp    $0x79,%al
f0114437:	74 21                	je     f011445a <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0114439:	83 ec 04             	sub    $0x4,%esp
f011443c:	68 88 c8 12 f0       	push   $0xf012c888
f0114441:	68 24 02 00 00       	push   $0x224
f0114446:	68 42 c3 12 f0       	push   $0xf012c342
f011444b:	e8 67 c0 fe ff       	call   f01004b7 <_warn>
f0114450:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114453:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f011445a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011445e:	74 04                	je     f0114464 <test_cut_paste_pages+0x3be>
f0114460:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114464:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f011446b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011446e:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0114471:	6a 02                	push   $0x2
f0114473:	68 00 f0 bf 02       	push   $0x2bff000
f0114478:	68 00 10 90 02       	push   $0x2901000
f011447d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114480:	e8 4b 52 ff ff       	call   f01096d0 <cut_paste_pages>
f0114485:	83 c4 10             	add    $0x10,%esp
f0114488:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011448b:	e8 79 95 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0114490:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0114493:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0114497:	75 0b                	jne    f01144a4 <test_cut_paste_pages+0x3fe>
f0114499:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011449c:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011449f:	83 f8 01             	cmp    $0x1,%eax
f01144a2:	74 2b                	je     f01144cf <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01144a4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01144a7:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01144aa:	83 ec 0c             	sub    $0xc,%esp
f01144ad:	50                   	push   %eax
f01144ae:	ff 75 b4             	pushl  -0x4c(%ebp)
f01144b1:	68 e8 c7 12 f0       	push   $0xf012c7e8
f01144b6:	68 35 02 00 00       	push   $0x235
f01144bb:	68 42 c3 12 f0       	push   $0xf012c342
f01144c0:	e8 f2 bf fe ff       	call   f01004b7 <_warn>
f01144c5:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01144c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01144cf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01144d3:	74 04                	je     f01144d9 <test_cut_paste_pages+0x433>
f01144d5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01144d9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01144e0:	83 ec 08             	sub    $0x8,%esp
f01144e3:	6a 00                	push   $0x0
f01144e5:	6a 01                	push   $0x1
f01144e7:	6a 00                	push   $0x0
f01144e9:	68 ff 0f 00 00       	push   $0xfff
f01144ee:	ff 75 bc             	pushl  -0x44(%ebp)
f01144f1:	6a 01                	push   $0x1
f01144f3:	68 00 20 00 00       	push   $0x2000
f01144f8:	68 00 f0 bf 02       	push   $0x2bff000
f01144fd:	68 00 10 90 02       	push   $0x2901000
f0114502:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114505:	e8 86 45 00 00       	call   f0118a90 <CCP>
f011450a:	83 c4 30             	add    $0x30,%esp
f011450d:	83 f8 01             	cmp    $0x1,%eax
f0114510:	74 21                	je     f0114533 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0114512:	83 ec 04             	sub    $0x4,%esp
f0114515:	68 3c c8 12 f0       	push   $0xf012c83c
f011451a:	68 3d 02 00 00       	push   $0x23d
f011451f:	68 42 c3 12 f0       	push   $0xf012c342
f0114524:	e8 8e bf fe ff       	call   f01004b7 <_warn>
f0114529:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011452c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0114533:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114537:	74 04                	je     f011453d <test_cut_paste_pages+0x497>
f0114539:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011453d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0114544:	83 ec 04             	sub    $0x4,%esp
f0114547:	6a 00                	push   $0x0
f0114549:	68 ff f7 bf 02       	push   $0x2bff7ff
f011454e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114551:	e8 cb 3f 00 00       	call   f0118521 <CB>
f0114556:	83 c4 10             	add    $0x10,%esp
f0114559:	85 c0                	test   %eax,%eax
f011455b:	74 6b                	je     f01145c8 <test_cut_paste_pages+0x522>
f011455d:	83 ec 04             	sub    $0x4,%esp
f0114560:	6a 00                	push   $0x0
f0114562:	68 ff 0f c0 02       	push   $0x2c00fff
f0114567:	ff 75 d4             	pushl  -0x2c(%ebp)
f011456a:	e8 b2 3f 00 00       	call   f0118521 <CB>
f011456f:	83 c4 10             	add    $0x10,%esp
f0114572:	85 c0                	test   %eax,%eax
f0114574:	74 52                	je     f01145c8 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0114576:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f011457d:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0114584:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114587:	8a 00                	mov    (%eax),%al
f0114589:	3c 79                	cmp    $0x79,%al
f011458b:	75 09                	jne    f0114596 <test_cut_paste_pages+0x4f0>
f011458d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114590:	8a 00                	mov    (%eax),%al
f0114592:	3c 63                	cmp    $0x63,%al
f0114594:	74 21                	je     f01145b7 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0114596:	83 ec 04             	sub    $0x4,%esp
f0114599:	68 88 c8 12 f0       	push   $0xf012c888
f011459e:	68 49 02 00 00       	push   $0x249
f01145a3:	68 42 c3 12 f0       	push   $0xf012c342
f01145a8:	e8 0a bf fe ff       	call   f01004b7 <_warn>
f01145ad:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01145b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01145bb:	74 04                	je     f01145c1 <test_cut_paste_pages+0x51b>
f01145bd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01145c1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01145c8:	83 ec 0c             	sub    $0xc,%esp
f01145cb:	68 c1 c8 12 f0       	push   $0xf012c8c1
f01145d0:	e8 97 c9 fe ff       	call   f0100f6c <cprintf>
f01145d5:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f01145d8:	83 ec 0c             	sub    $0xc,%esp
f01145db:	68 d0 c8 12 f0       	push   $0xf012c8d0
f01145e0:	e8 87 c9 fe ff       	call   f0100f6c <cprintf>
f01145e5:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01145e8:	83 ec 04             	sub    $0x4,%esp
f01145eb:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01145f1:	50                   	push   %eax
f01145f2:	68 f9 c8 12 f0       	push   $0xf012c8f9
f01145f7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01145fd:	50                   	push   %eax
f01145fe:	e8 51 e5 00 00       	call   f0122b54 <strcconcat>
f0114603:	83 c4 10             	add    $0x10,%esp
f0114606:	83 ec 0c             	sub    $0xc,%esp
f0114609:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011460f:	50                   	push   %eax
f0114610:	e8 c7 d8 fe ff       	call   f0101edc <execute_command>
f0114615:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0114618:	83 ec 04             	sub    $0x4,%esp
f011461b:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0114621:	50                   	push   %eax
f0114622:	68 04 c9 12 f0       	push   $0xf012c904
f0114627:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011462d:	50                   	push   %eax
f011462e:	e8 21 e5 00 00       	call   f0122b54 <strcconcat>
f0114633:	83 c4 10             	add    $0x10,%esp
f0114636:	83 ec 0c             	sub    $0xc,%esp
f0114639:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f011463f:	50                   	push   %eax
f0114640:	e8 97 d8 fe ff       	call   f0101edc <execute_command>
f0114645:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0114648:	83 ec 04             	sub    $0x4,%esp
f011464b:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0114651:	50                   	push   %eax
f0114652:	68 0f c9 12 f0       	push   $0xf012c90f
f0114657:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011465d:	50                   	push   %eax
f011465e:	e8 f1 e4 00 00       	call   f0122b54 <strcconcat>
f0114663:	83 c4 10             	add    $0x10,%esp
f0114666:	83 ec 0c             	sub    $0xc,%esp
f0114669:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011466f:	50                   	push   %eax
f0114670:	e8 67 d8 fe ff       	call   f0101edc <execute_command>
f0114675:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0114678:	83 ec 04             	sub    $0x4,%esp
f011467b:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0114681:	50                   	push   %eax
f0114682:	68 1a c9 12 f0       	push   $0xf012c91a
f0114687:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011468d:	50                   	push   %eax
f011468e:	e8 c1 e4 00 00       	call   f0122b54 <strcconcat>
f0114693:	83 c4 10             	add    $0x10,%esp
f0114696:	83 ec 0c             	sub    $0xc,%esp
f0114699:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011469f:	50                   	push   %eax
f01146a0:	e8 37 d8 fe ff       	call   f0101edc <execute_command>
f01146a5:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f01146a8:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f01146af:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146b2:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f01146b5:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f01146bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146bf:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f01146c2:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f01146c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146cc:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f01146cf:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f01146d6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146d9:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f01146dc:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f01146e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146e6:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01146e9:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01146f0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146f3:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01146f6:	83 ec 08             	sub    $0x8,%esp
f01146f9:	68 00 00 c0 01       	push   $0x1c00000
f01146fe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114701:	e8 bd 42 00 00       	call   f01189c3 <GP>
f0114706:	83 c4 10             	add    $0x10,%esp
f0114709:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f011470c:	83 ec 08             	sub    $0x8,%esp
f011470f:	68 00 00 40 01       	push   $0x1400000
f0114714:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114717:	e8 a7 42 00 00       	call   f01189c3 <GP>
f011471c:	83 c4 10             	add    $0x10,%esp
f011471f:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0114722:	e8 e2 92 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0114727:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f011472a:	6a 01                	push   $0x1
f011472c:	68 00 00 40 01       	push   $0x1400000
f0114731:	68 00 00 c0 01       	push   $0x1c00000
f0114736:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114739:	e8 92 4f ff ff       	call   f01096d0 <cut_paste_pages>
f011473e:	83 c4 10             	add    $0x10,%esp
f0114741:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0114744:	e8 c0 92 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0114749:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011474c:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0114750:	75 08                	jne    f011475a <test_cut_paste_pages+0x6b4>
f0114752:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114755:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0114758:	74 2b                	je     f0114785 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011475a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011475d:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0114760:	83 ec 0c             	sub    $0xc,%esp
f0114763:	50                   	push   %eax
f0114764:	ff 75 b4             	pushl  -0x4c(%ebp)
f0114767:	68 28 c9 12 f0       	push   $0xf012c928
f011476c:	68 6c 02 00 00       	push   $0x26c
f0114771:	68 42 c3 12 f0       	push   $0xf012c342
f0114776:	e8 3c bd fe ff       	call   f01004b7 <_warn>
f011477b:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011477e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0114785:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114789:	74 04                	je     f011478f <test_cut_paste_pages+0x6e9>
f011478b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011478f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0114796:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f011479d:	83 ec 08             	sub    $0x8,%esp
f01147a0:	6a 00                	push   $0x0
f01147a2:	68 ff 0f 00 00       	push   $0xfff
f01147a7:	ff 75 a4             	pushl  -0x5c(%ebp)
f01147aa:	68 ff 0f 00 00       	push   $0xfff
f01147af:	ff 75 a0             	pushl  -0x60(%ebp)
f01147b2:	6a 01                	push   $0x1
f01147b4:	68 00 10 00 00       	push   $0x1000
f01147b9:	68 00 00 40 01       	push   $0x1400000
f01147be:	68 00 00 c0 01       	push   $0x1c00000
f01147c3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01147c6:	e8 c5 42 00 00       	call   f0118a90 <CCP>
f01147cb:	83 c4 30             	add    $0x30,%esp
f01147ce:	83 f8 01             	cmp    $0x1,%eax
f01147d1:	74 28                	je     f01147fb <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01147d3:	83 ec 04             	sub    $0x4,%esp
f01147d6:	68 3c c8 12 f0       	push   $0xf012c83c
f01147db:	68 75 02 00 00       	push   $0x275
f01147e0:	68 42 c3 12 f0       	push   $0xf012c342
f01147e5:	e8 cd bc fe ff       	call   f01004b7 <_warn>
f01147ea:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01147ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01147f4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01147fb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01147ff:	74 04                	je     f0114805 <test_cut_paste_pages+0x75f>
f0114801:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0114805:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f011480c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114810:	0f 84 92 00 00 00    	je     f01148a8 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0114816:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011481d:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0114824:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f011482b:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0114832:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0114839:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114840:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114843:	8a 00                	mov    (%eax),%al
f0114845:	3c 61                	cmp    $0x61,%al
f0114847:	75 2d                	jne    f0114876 <test_cut_paste_pages+0x7d0>
f0114849:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011484c:	8a 00                	mov    (%eax),%al
f011484e:	3c 78                	cmp    $0x78,%al
f0114850:	75 24                	jne    f0114876 <test_cut_paste_pages+0x7d0>
f0114852:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114855:	8a 00                	mov    (%eax),%al
f0114857:	3c 62                	cmp    $0x62,%al
f0114859:	75 1b                	jne    f0114876 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011485b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011485e:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114860:	3c 79                	cmp    $0x79,%al
f0114862:	75 12                	jne    f0114876 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0114864:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114867:	8a 00                	mov    (%eax),%al
f0114869:	3c 63                	cmp    $0x63,%al
f011486b:	75 09                	jne    f0114876 <test_cut_paste_pages+0x7d0>
f011486d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114870:	8a 00                	mov    (%eax),%al
f0114872:	3c 7a                	cmp    $0x7a,%al
f0114874:	74 21                	je     f0114897 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0114876:	83 ec 04             	sub    $0x4,%esp
f0114879:	68 88 c8 12 f0       	push   $0xf012c888
f011487e:	68 87 02 00 00       	push   $0x287
f0114883:	68 42 c3 12 f0       	push   $0xf012c342
f0114888:	e8 2a bc fe ff       	call   f01004b7 <_warn>
f011488d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114890:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114897:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011489b:	74 04                	je     f01148a1 <test_cut_paste_pages+0x7fb>
f011489d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148a1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f01148a8:	e8 5c 91 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01148ad:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f01148b0:	6a 03                	push   $0x3
f01148b2:	68 00 f0 bf 01       	push   $0x1bff000
f01148b7:	68 00 00 40 01       	push   $0x1400000
f01148bc:	ff 75 d4             	pushl  -0x2c(%ebp)
f01148bf:	e8 0c 4e ff ff       	call   f01096d0 <cut_paste_pages>
f01148c4:	83 c4 10             	add    $0x10,%esp
f01148c7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01148ca:	e8 3a 91 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01148cf:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01148d2:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01148d6:	75 08                	jne    f01148e0 <test_cut_paste_pages+0x83a>
f01148d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01148db:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01148de:	74 2b                	je     f011490b <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01148e0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01148e3:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01148e6:	83 ec 0c             	sub    $0xc,%esp
f01148e9:	50                   	push   %eax
f01148ea:	ff 75 b4             	pushl  -0x4c(%ebp)
f01148ed:	68 28 c9 12 f0       	push   $0xf012c928
f01148f2:	68 96 02 00 00       	push   $0x296
f01148f7:	68 42 c3 12 f0       	push   $0xf012c342
f01148fc:	e8 b6 bb fe ff       	call   f01004b7 <_warn>
f0114901:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0114904:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011490b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011490f:	74 04                	je     f0114915 <test_cut_paste_pages+0x86f>
f0114911:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0114915:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f011491c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0114923:	83 ec 04             	sub    $0x4,%esp
f0114926:	6a 00                	push   $0x0
f0114928:	68 00 00 40 01       	push   $0x1400000
f011492d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114930:	e8 ec 3b 00 00       	call   f0118521 <CB>
f0114935:	83 c4 10             	add    $0x10,%esp
f0114938:	83 f8 01             	cmp    $0x1,%eax
f011493b:	0f 85 80 00 00 00    	jne    f01149c1 <test_cut_paste_pages+0x91b>
f0114941:	83 ec 04             	sub    $0x4,%esp
f0114944:	6a 00                	push   $0x0
f0114946:	68 00 10 40 01       	push   $0x1401000
f011494b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011494e:	e8 ce 3b 00 00       	call   f0118521 <CB>
f0114953:	83 c4 10             	add    $0x10,%esp
f0114956:	83 f8 01             	cmp    $0x1,%eax
f0114959:	75 66                	jne    f01149c1 <test_cut_paste_pages+0x91b>
f011495b:	83 ec 04             	sub    $0x4,%esp
f011495e:	6a 00                	push   $0x0
f0114960:	68 00 20 40 01       	push   $0x1402000
f0114965:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114968:	e8 b4 3b 00 00       	call   f0118521 <CB>
f011496d:	83 c4 10             	add    $0x10,%esp
f0114970:	83 f8 01             	cmp    $0x1,%eax
f0114973:	75 4c                	jne    f01149c1 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0114975:	83 ec 04             	sub    $0x4,%esp
f0114978:	6a 00                	push   $0x0
f011497a:	68 00 f0 bf 01       	push   $0x1bff000
f011497f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114982:	e8 9a 3b 00 00       	call   f0118521 <CB>
f0114987:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f011498a:	85 c0                	test   %eax,%eax
f011498c:	75 33                	jne    f01149c1 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f011498e:	83 ec 04             	sub    $0x4,%esp
f0114991:	6a 00                	push   $0x0
f0114993:	68 00 00 c0 01       	push   $0x1c00000
f0114998:	ff 75 d4             	pushl  -0x2c(%ebp)
f011499b:	e8 81 3b 00 00       	call   f0118521 <CB>
f01149a0:	83 c4 10             	add    $0x10,%esp
f01149a3:	83 f8 01             	cmp    $0x1,%eax
f01149a6:	75 19                	jne    f01149c1 <test_cut_paste_pages+0x91b>
f01149a8:	83 ec 04             	sub    $0x4,%esp
f01149ab:	6a 00                	push   $0x0
f01149ad:	68 00 10 c0 01       	push   $0x1c01000
f01149b2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01149b5:	e8 67 3b 00 00       	call   f0118521 <CB>
f01149ba:	83 c4 10             	add    $0x10,%esp
f01149bd:	85 c0                	test   %eax,%eax
f01149bf:	74 28                	je     f01149e9 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f01149c1:	83 ec 04             	sub    $0x4,%esp
f01149c4:	68 88 c9 12 f0       	push   $0xf012c988
f01149c9:	68 9f 02 00 00       	push   $0x29f
f01149ce:	68 42 c3 12 f0       	push   $0xf012c342
f01149d3:	e8 df ba fe ff       	call   f01004b7 <_warn>
f01149d8:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01149db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01149e2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01149e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01149ed:	74 04                	je     f01149f3 <test_cut_paste_pages+0x94d>
f01149ef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01149f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01149fa:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01149fe:	0f 84 99 00 00 00    	je     f0114a9d <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0114a04:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0114a0b:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0114a12:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0114a19:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0114a20:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0114a27:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114a2e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a31:	8a 00                	mov    (%eax),%al
f0114a33:	3c 61                	cmp    $0x61,%al
f0114a35:	75 2d                	jne    f0114a64 <test_cut_paste_pages+0x9be>
f0114a37:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114a3a:	8a 00                	mov    (%eax),%al
f0114a3c:	3c 78                	cmp    $0x78,%al
f0114a3e:	75 24                	jne    f0114a64 <test_cut_paste_pages+0x9be>
f0114a40:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114a43:	8a 00                	mov    (%eax),%al
f0114a45:	3c 62                	cmp    $0x62,%al
f0114a47:	75 1b                	jne    f0114a64 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0114a49:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114a4c:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114a4e:	3c 79                	cmp    $0x79,%al
f0114a50:	75 12                	jne    f0114a64 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0114a52:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114a55:	8a 00                	mov    (%eax),%al
f0114a57:	3c 63                	cmp    $0x63,%al
f0114a59:	75 09                	jne    f0114a64 <test_cut_paste_pages+0x9be>
f0114a5b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114a5e:	8a 00                	mov    (%eax),%al
f0114a60:	3c 7a                	cmp    $0x7a,%al
f0114a62:	74 28                	je     f0114a8c <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0114a64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0114a6b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0114a72:	83 ec 04             	sub    $0x4,%esp
f0114a75:	68 88 c8 12 f0       	push   $0xf012c888
f0114a7a:	68 b3 02 00 00       	push   $0x2b3
f0114a7f:	68 42 c3 12 f0       	push   $0xf012c342
f0114a84:	e8 2e ba fe ff       	call   f01004b7 <_warn>
f0114a89:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0114a8c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114a90:	74 04                	je     f0114a96 <test_cut_paste_pages+0x9f0>
f0114a92:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a96:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0114a9d:	83 ec 0c             	sub    $0xc,%esp
f0114aa0:	68 c1 c9 12 f0       	push   $0xf012c9c1
f0114aa5:	e8 c2 c4 fe ff       	call   f0100f6c <cprintf>
f0114aaa:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0114aad:	83 ec 08             	sub    $0x8,%esp
f0114ab0:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114ab3:	68 d0 c9 12 f0       	push   $0xf012c9d0
f0114ab8:	e8 af c4 fe ff       	call   f0100f6c <cprintf>
f0114abd:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114ac0:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114ac4:	75 10                	jne    f0114ad6 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0114ac6:	83 ec 0c             	sub    $0xc,%esp
f0114ac9:	68 04 ca 12 f0       	push   $0xf012ca04
f0114ace:	e8 99 c4 fe ff       	call   f0100f6c <cprintf>
f0114ad3:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114ad6:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f0114adb:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114ade:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114ae1:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114ae4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114ae9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114aec:	5b                   	pop    %ebx
f0114aed:	5e                   	pop    %esi
f0114aee:	5f                   	pop    %edi
f0114aef:	5d                   	pop    %ebp
f0114af0:	c3                   	ret    

f0114af1 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0114af1:	55                   	push   %ebp
f0114af2:	89 e5                	mov    %esp,%ebp
f0114af4:	57                   	push   %edi
f0114af5:	56                   	push   %esi
f0114af6:	53                   	push   %ebx
f0114af7:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114afd:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0114b03:	bb 44 ca 12 f0       	mov    $0xf012ca44,%ebx
f0114b08:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114b0d:	89 c7                	mov    %eax,%edi
f0114b0f:	89 de                	mov    %ebx,%esi
f0114b11:	89 d1                	mov    %edx,%ecx
f0114b13:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114b15:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0114b1b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114b20:	b0 00                	mov    $0x0,%al
f0114b22:	89 d7                	mov    %edx,%edi
f0114b24:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114b26:	6a 00                	push   $0x0
f0114b28:	6a 0a                	push   $0xa
f0114b2a:	6a 14                	push   $0x14
f0114b2c:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0114b32:	50                   	push   %eax
f0114b33:	e8 38 4f ff ff       	call   f0109a70 <env_create>
f0114b38:	83 c4 10             	add    $0x10,%esp
f0114b3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114b3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114b41:	8b 40 64             	mov    0x64(%eax),%eax
f0114b44:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0114b47:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114b4a:	8b 40 68             	mov    0x68(%eax),%eax
f0114b4d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0114b53:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0114b59:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0114b5c:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0114b63:	75 70 20 
f0114b66:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0114b6d:	00 00 00 
f0114b70:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0114b76:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114b7b:	b8 00 00 00 00       	mov    $0x0,%eax
f0114b80:	89 d7                	mov    %edx,%edi
f0114b82:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114b84:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114b87:	8b 40 10             	mov    0x10(%eax),%eax
f0114b8a:	83 ec 08             	sub    $0x8,%esp
f0114b8d:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0114b93:	52                   	push   %edx
f0114b94:	50                   	push   %eax
f0114b95:	e8 e1 de 00 00       	call   f0122a7b <ltostr>
f0114b9a:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114b9d:	83 ec 04             	sub    $0x4,%esp
f0114ba0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114ba6:	50                   	push   %eax
f0114ba7:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0114bad:	50                   	push   %eax
f0114bae:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0114bb4:	50                   	push   %eax
f0114bb5:	e8 9a df 00 00       	call   f0122b54 <strcconcat>
f0114bba:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0114bbd:	83 ec 0c             	sub    $0xc,%esp
f0114bc0:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114bc3:	e8 94 3e 00 00       	call   f0118a5c <ClearUserSpace>
f0114bc8:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0114bcb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0114bd2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0114bd9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0114be0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0114be7:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114bee:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0114bf5:	83 ec 0c             	sub    $0xc,%esp
f0114bf8:	68 78 ca 12 f0       	push   $0xf012ca78
f0114bfd:	e8 6a c3 fe ff       	call   f0100f6c <cprintf>
f0114c02:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114c05:	83 ec 04             	sub    $0x4,%esp
f0114c08:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114c0e:	50                   	push   %eax
f0114c0f:	68 ae ca 12 f0       	push   $0xf012caae
f0114c14:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114c1a:	50                   	push   %eax
f0114c1b:	e8 34 df 00 00       	call   f0122b54 <strcconcat>
f0114c20:	83 c4 10             	add    $0x10,%esp
f0114c23:	83 ec 0c             	sub    $0xc,%esp
f0114c26:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114c2c:	50                   	push   %eax
f0114c2d:	e8 aa d2 fe ff       	call   f0101edc <execute_command>
f0114c32:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0114c35:	83 ec 04             	sub    $0x4,%esp
f0114c38:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114c3e:	50                   	push   %eax
f0114c3f:	68 b3 ca 12 f0       	push   $0xf012cab3
f0114c44:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114c4a:	50                   	push   %eax
f0114c4b:	e8 04 df 00 00       	call   f0122b54 <strcconcat>
f0114c50:	83 c4 10             	add    $0x10,%esp
f0114c53:	83 ec 0c             	sub    $0xc,%esp
f0114c56:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114c5c:	50                   	push   %eax
f0114c5d:	e8 7a d2 fe ff       	call   f0101edc <execute_command>
f0114c62:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0114c65:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0114c6b:	bb b9 cd 12 f0       	mov    $0xf012cdb9,%ebx
f0114c70:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114c75:	89 c7                	mov    %eax,%edi
f0114c77:	89 de                	mov    %ebx,%esi
f0114c79:	89 d1                	mov    %edx,%ecx
f0114c7b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114c7d:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0114c83:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114c88:	b0 00                	mov    $0x0,%al
f0114c8a:	89 d7                	mov    %edx,%edi
f0114c8c:	f3 aa                	rep stos %al,%es:(%edi)
f0114c8e:	83 ec 0c             	sub    $0xc,%esp
f0114c91:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0114c97:	50                   	push   %eax
f0114c98:	e8 3f d2 fe ff       	call   f0101edc <execute_command>
f0114c9d:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0114ca0:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0114ca6:	bb 1d ce 12 f0       	mov    $0xf012ce1d,%ebx
f0114cab:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114cb0:	89 c7                	mov    %eax,%edi
f0114cb2:	89 de                	mov    %ebx,%esi
f0114cb4:	89 d1                	mov    %edx,%ecx
f0114cb6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114cb8:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0114cbe:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114cc3:	b0 00                	mov    $0x0,%al
f0114cc5:	89 d7                	mov    %edx,%edi
f0114cc7:	f3 aa                	rep stos %al,%es:(%edi)
f0114cc9:	83 ec 0c             	sub    $0xc,%esp
f0114ccc:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0114cd2:	50                   	push   %eax
f0114cd3:	e8 04 d2 fe ff       	call   f0101edc <execute_command>
f0114cd8:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0114cdb:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114ce1:	bb 81 ce 12 f0       	mov    $0xf012ce81,%ebx
f0114ce6:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ceb:	89 c7                	mov    %eax,%edi
f0114ced:	89 de                	mov    %ebx,%esi
f0114cef:	89 d1                	mov    %edx,%ecx
f0114cf1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114cf3:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0114cf9:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114cfe:	b0 00                	mov    $0x0,%al
f0114d00:	89 d7                	mov    %edx,%edi
f0114d02:	f3 aa                	rep stos %al,%es:(%edi)
f0114d04:	83 ec 0c             	sub    $0xc,%esp
f0114d07:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114d0d:	50                   	push   %eax
f0114d0e:	e8 c9 d1 fe ff       	call   f0101edc <execute_command>
f0114d13:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0114d16:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0114d1c:	bb e5 ce 12 f0       	mov    $0xf012cee5,%ebx
f0114d21:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114d26:	89 c7                	mov    %eax,%edi
f0114d28:	89 de                	mov    %ebx,%esi
f0114d2a:	89 d1                	mov    %edx,%ecx
f0114d2c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114d2e:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0114d34:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114d39:	b0 00                	mov    $0x0,%al
f0114d3b:	89 d7                	mov    %edx,%edi
f0114d3d:	f3 aa                	rep stos %al,%es:(%edi)
f0114d3f:	83 ec 0c             	sub    $0xc,%esp
f0114d42:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0114d48:	50                   	push   %eax
f0114d49:	e8 8e d1 fe ff       	call   f0101edc <execute_command>
f0114d4e:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0114d51:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0114d57:	bb 49 cf 12 f0       	mov    $0xf012cf49,%ebx
f0114d5c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114d61:	89 c7                	mov    %eax,%edi
f0114d63:	89 de                	mov    %ebx,%esi
f0114d65:	89 d1                	mov    %edx,%ecx
f0114d67:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114d69:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0114d6f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114d74:	b0 00                	mov    $0x0,%al
f0114d76:	89 d7                	mov    %edx,%edi
f0114d78:	f3 aa                	rep stos %al,%es:(%edi)
f0114d7a:	83 ec 0c             	sub    $0xc,%esp
f0114d7d:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0114d83:	50                   	push   %eax
f0114d84:	e8 53 d1 fe ff       	call   f0101edc <execute_command>
f0114d89:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0114d8c:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0114d92:	bb ad cf 12 f0       	mov    $0xf012cfad,%ebx
f0114d97:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114d9c:	89 c7                	mov    %eax,%edi
f0114d9e:	89 de                	mov    %ebx,%esi
f0114da0:	89 d1                	mov    %edx,%ecx
f0114da2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114da4:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0114daa:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114daf:	b0 00                	mov    $0x0,%al
f0114db1:	89 d7                	mov    %edx,%edi
f0114db3:	f3 aa                	rep stos %al,%es:(%edi)
f0114db5:	83 ec 0c             	sub    $0xc,%esp
f0114db8:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0114dbe:	50                   	push   %eax
f0114dbf:	e8 18 d1 fe ff       	call   f0101edc <execute_command>
f0114dc4:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0114dc7:	83 ec 04             	sub    $0x4,%esp
f0114dca:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114dd0:	50                   	push   %eax
f0114dd1:	68 bb ca 12 f0       	push   $0xf012cabb
f0114dd6:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114ddc:	50                   	push   %eax
f0114ddd:	e8 72 dd 00 00       	call   f0122b54 <strcconcat>
f0114de2:	83 c4 10             	add    $0x10,%esp
f0114de5:	83 ec 0c             	sub    $0xc,%esp
f0114de8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114dee:	50                   	push   %eax
f0114def:	e8 e8 d0 fe ff       	call   f0101edc <execute_command>
f0114df4:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0114df7:	83 ec 04             	sub    $0x4,%esp
f0114dfa:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114e00:	50                   	push   %eax
f0114e01:	68 c5 ca 12 f0       	push   $0xf012cac5
f0114e06:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114e0c:	50                   	push   %eax
f0114e0d:	e8 42 dd 00 00       	call   f0122b54 <strcconcat>
f0114e12:	83 c4 10             	add    $0x10,%esp
f0114e15:	83 ec 0c             	sub    $0xc,%esp
f0114e18:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114e1e:	50                   	push   %eax
f0114e1f:	e8 b8 d0 fe ff       	call   f0101edc <execute_command>
f0114e24:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0114e27:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114e2d:	bb 11 d0 12 f0       	mov    $0xf012d011,%ebx
f0114e32:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114e37:	89 c7                	mov    %eax,%edi
f0114e39:	89 de                	mov    %ebx,%esi
f0114e3b:	89 d1                	mov    %edx,%ecx
f0114e3d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114e3f:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0114e45:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114e4a:	b0 00                	mov    $0x0,%al
f0114e4c:	89 d7                	mov    %edx,%edi
f0114e4e:	f3 aa                	rep stos %al,%es:(%edi)
f0114e50:	83 ec 0c             	sub    $0xc,%esp
f0114e53:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114e59:	50                   	push   %eax
f0114e5a:	e8 7d d0 fe ff       	call   f0101edc <execute_command>
f0114e5f:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0114e62:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114e68:	bb 75 d0 12 f0       	mov    $0xf012d075,%ebx
f0114e6d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114e72:	89 c7                	mov    %eax,%edi
f0114e74:	89 de                	mov    %ebx,%esi
f0114e76:	89 d1                	mov    %edx,%ecx
f0114e78:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114e7a:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0114e80:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114e85:	b0 00                	mov    $0x0,%al
f0114e87:	89 d7                	mov    %edx,%edi
f0114e89:	f3 aa                	rep stos %al,%es:(%edi)
f0114e8b:	83 ec 0c             	sub    $0xc,%esp
f0114e8e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114e94:	50                   	push   %eax
f0114e95:	e8 42 d0 fe ff       	call   f0101edc <execute_command>
f0114e9a:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0114e9d:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0114ea3:	bb d9 d0 12 f0       	mov    $0xf012d0d9,%ebx
f0114ea8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ead:	89 c7                	mov    %eax,%edi
f0114eaf:	89 de                	mov    %ebx,%esi
f0114eb1:	89 d1                	mov    %edx,%ecx
f0114eb3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114eb5:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0114ebb:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114ec0:	b0 00                	mov    $0x0,%al
f0114ec2:	89 d7                	mov    %edx,%edi
f0114ec4:	f3 aa                	rep stos %al,%es:(%edi)
f0114ec6:	83 ec 0c             	sub    $0xc,%esp
f0114ec9:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0114ecf:	50                   	push   %eax
f0114ed0:	e8 07 d0 fe ff       	call   f0101edc <execute_command>
f0114ed5:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0114ed8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0114edf:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0114ee6:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0114eed:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0114ef4:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0114efb:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0114f02:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0114f09:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0114f10:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0114f17:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0114f1e:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0114f25:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0114f2c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0114f2f:	8a 00                	mov    (%eax),%al
f0114f31:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0114f37:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114f3a:	8a 00                	mov    (%eax),%al
f0114f3c:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0114f42:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114f45:	8a 00                	mov    (%eax),%al
f0114f47:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114f4d:	e8 b7 8a ff ff       	call   f010da09 <sys_calculate_free_frames>
f0114f52:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0114f55:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f58:	89 d0                	mov    %edx,%eax
f0114f5a:	01 c0                	add    %eax,%eax
f0114f5c:	01 d0                	add    %edx,%eax
f0114f5e:	01 c0                	add    %eax,%eax
f0114f60:	50                   	push   %eax
f0114f61:	68 00 00 10 00       	push   $0x100000
f0114f66:	6a 00                	push   $0x0
f0114f68:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114f6b:	e8 7a 47 ff ff       	call   f01096ea <copy_paste_chunk>
f0114f70:	83 c4 10             	add    $0x10,%esp
f0114f73:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f76:	e8 8e 8a ff ff       	call   f010da09 <sys_calculate_free_frames>
f0114f7b:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0114f7e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0114f85:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0114f89:	75 08                	jne    f0114f93 <test_copy_paste_chunk+0x4a2>
f0114f8b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114f8e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0114f91:	74 2b                	je     f0114fbe <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114f93:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114f96:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0114f99:	83 ec 0c             	sub    $0xc,%esp
f0114f9c:	50                   	push   %eax
f0114f9d:	ff 75 88             	pushl  -0x78(%ebp)
f0114fa0:	68 d4 ca 12 f0       	push   $0xf012cad4
f0114fa5:	68 06 03 00 00       	push   $0x306
f0114faa:	68 42 c3 12 f0       	push   $0xf012c342
f0114faf:	e8 03 b5 fe ff       	call   f01004b7 <_warn>
f0114fb4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fb7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0114fbe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114fc2:	74 04                	je     f0114fc8 <test_copy_paste_chunk+0x4d7>
f0114fc4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114fc8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0114fcf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114fd2:	8a 00                	mov    (%eax),%al
f0114fd4:	3c 61                	cmp    $0x61,%al
f0114fd6:	75 75                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0114fd8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114fdb:	8a 00                	mov    (%eax),%al
f0114fdd:	3c 78                	cmp    $0x78,%al
f0114fdf:	75 6c                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0114fe1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fe4:	8a 00                	mov    (%eax),%al
f0114fe6:	3c 62                	cmp    $0x62,%al
f0114fe8:	75 63                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0114fea:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114fed:	8a 00                	mov    (%eax),%al
f0114fef:	3c 79                	cmp    $0x79,%al
f0114ff1:	75 5a                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0114ff3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114ff6:	8a 00                	mov    (%eax),%al
f0114ff8:	3c 63                	cmp    $0x63,%al
f0114ffa:	75 51                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0114ffc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114fff:	8a 00                	mov    (%eax),%al
f0115001:	3c 7a                	cmp    $0x7a,%al
f0115003:	75 48                	jne    f011504d <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0115005:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115008:	8a 00                	mov    (%eax),%al
f011500a:	3c 64                	cmp    $0x64,%al
f011500c:	75 3f                	jne    f011504d <test_copy_paste_chunk+0x55c>
f011500e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0115011:	8a 10                	mov    (%eax),%dl
f0115013:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0115019:	38 c2                	cmp    %al,%dl
f011501b:	75 30                	jne    f011504d <test_copy_paste_chunk+0x55c>
f011501d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0115020:	8a 00                	mov    (%eax),%al
f0115022:	3c 65                	cmp    $0x65,%al
f0115024:	75 27                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0115026:	8b 45 98             	mov    -0x68(%ebp),%eax
f0115029:	8a 10                	mov    (%eax),%dl
f011502b:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0115031:	38 c2                	cmp    %al,%dl
f0115033:	75 18                	jne    f011504d <test_copy_paste_chunk+0x55c>
f0115035:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0115038:	8a 00                	mov    (%eax),%al
f011503a:	3c 66                	cmp    $0x66,%al
f011503c:	75 0f                	jne    f011504d <test_copy_paste_chunk+0x55c>
f011503e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0115041:	8a 10                	mov    (%eax),%dl
f0115043:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0115049:	38 c2                	cmp    %al,%dl
f011504b:	74 21                	je     f011506e <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011504d:	83 ec 04             	sub    $0x4,%esp
f0115050:	68 38 cb 12 f0       	push   $0xf012cb38
f0115055:	68 0f 03 00 00       	push   $0x30f
f011505a:	68 42 c3 12 f0       	push   $0xf012c342
f011505f:	e8 53 b4 fe ff       	call   f01004b7 <_warn>
f0115064:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115067:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011506e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115072:	74 04                	je     f0115078 <test_copy_paste_chunk+0x587>
f0115074:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115078:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f011507f:	83 ec 0c             	sub    $0xc,%esp
f0115082:	68 72 cb 12 f0       	push   $0xf012cb72
f0115087:	e8 e0 be fe ff       	call   f0100f6c <cprintf>
f011508c:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f011508f:	83 ec 0c             	sub    $0xc,%esp
f0115092:	68 84 cb 12 f0       	push   $0xf012cb84
f0115097:	e8 d0 be fe ff       	call   f0100f6c <cprintf>
f011509c:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f011509f:	83 ec 04             	sub    $0x4,%esp
f01150a2:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01150a8:	50                   	push   %eax
f01150a9:	68 ba cb 12 f0       	push   $0xf012cbba
f01150ae:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01150b4:	50                   	push   %eax
f01150b5:	e8 9a da 00 00       	call   f0122b54 <strcconcat>
f01150ba:	83 c4 10             	add    $0x10,%esp
f01150bd:	83 ec 0c             	sub    $0xc,%esp
f01150c0:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01150c6:	50                   	push   %eax
f01150c7:	e8 10 ce fe ff       	call   f0101edc <execute_command>
f01150cc:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01150cf:	83 ec 04             	sub    $0x4,%esp
f01150d2:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01150d8:	50                   	push   %eax
f01150d9:	68 c4 cb 12 f0       	push   $0xf012cbc4
f01150de:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01150e4:	50                   	push   %eax
f01150e5:	e8 6a da 00 00       	call   f0122b54 <strcconcat>
f01150ea:	83 c4 10             	add    $0x10,%esp
f01150ed:	83 ec 0c             	sub    $0xc,%esp
f01150f0:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01150f6:	50                   	push   %eax
f01150f7:	e8 e0 cd fe ff       	call   f0101edc <execute_command>
f01150fc:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f01150ff:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0115105:	bb 3d d1 12 f0       	mov    $0xf012d13d,%ebx
f011510a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011510f:	89 c7                	mov    %eax,%edi
f0115111:	89 de                	mov    %ebx,%esi
f0115113:	89 d1                	mov    %edx,%ecx
f0115115:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115117:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f011511d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115122:	b0 00                	mov    $0x0,%al
f0115124:	89 d7                	mov    %edx,%edi
f0115126:	f3 aa                	rep stos %al,%es:(%edi)
f0115128:	83 ec 0c             	sub    $0xc,%esp
f011512b:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0115131:	50                   	push   %eax
f0115132:	e8 a5 cd fe ff       	call   f0101edc <execute_command>
f0115137:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f011513a:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0115140:	bb a1 d1 12 f0       	mov    $0xf012d1a1,%ebx
f0115145:	ba 0f 00 00 00       	mov    $0xf,%edx
f011514a:	89 c7                	mov    %eax,%edi
f011514c:	89 de                	mov    %ebx,%esi
f011514e:	89 d1                	mov    %edx,%ecx
f0115150:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115152:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0115158:	b9 55 00 00 00       	mov    $0x55,%ecx
f011515d:	b0 00                	mov    $0x0,%al
f011515f:	89 d7                	mov    %edx,%edi
f0115161:	f3 aa                	rep stos %al,%es:(%edi)
f0115163:	83 ec 0c             	sub    $0xc,%esp
f0115166:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011516c:	50                   	push   %eax
f011516d:	e8 6a cd fe ff       	call   f0101edc <execute_command>
f0115172:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0115175:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011517b:	bb 05 d2 12 f0       	mov    $0xf012d205,%ebx
f0115180:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115185:	89 c7                	mov    %eax,%edi
f0115187:	89 de                	mov    %ebx,%esi
f0115189:	89 d1                	mov    %edx,%ecx
f011518b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011518d:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0115193:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115198:	b0 00                	mov    $0x0,%al
f011519a:	89 d7                	mov    %edx,%edi
f011519c:	f3 aa                	rep stos %al,%es:(%edi)
f011519e:	83 ec 0c             	sub    $0xc,%esp
f01151a1:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01151a7:	50                   	push   %eax
f01151a8:	e8 2f cd fe ff       	call   f0101edc <execute_command>
f01151ad:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01151b0:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01151b6:	bb 69 d2 12 f0       	mov    $0xf012d269,%ebx
f01151bb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01151c0:	89 c7                	mov    %eax,%edi
f01151c2:	89 de                	mov    %ebx,%esi
f01151c4:	89 d1                	mov    %edx,%ecx
f01151c6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01151c8:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01151ce:	b9 55 00 00 00       	mov    $0x55,%ecx
f01151d3:	b0 00                	mov    $0x0,%al
f01151d5:	89 d7                	mov    %edx,%edi
f01151d7:	f3 aa                	rep stos %al,%es:(%edi)
f01151d9:	83 ec 0c             	sub    $0xc,%esp
f01151dc:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01151e2:	50                   	push   %eax
f01151e3:	e8 f4 cc fe ff       	call   f0101edc <execute_command>
f01151e8:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01151eb:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01151f1:	bb cd d2 12 f0       	mov    $0xf012d2cd,%ebx
f01151f6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01151fb:	89 c7                	mov    %eax,%edi
f01151fd:	89 de                	mov    %ebx,%esi
f01151ff:	89 d1                	mov    %edx,%ecx
f0115201:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115203:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0115209:	b9 55 00 00 00       	mov    $0x55,%ecx
f011520e:	b0 00                	mov    $0x0,%al
f0115210:	89 d7                	mov    %edx,%edi
f0115212:	f3 aa                	rep stos %al,%es:(%edi)
f0115214:	83 ec 0c             	sub    $0xc,%esp
f0115217:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011521d:	50                   	push   %eax
f011521e:	e8 b9 cc fe ff       	call   f0101edc <execute_command>
f0115223:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0115226:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011522c:	bb 31 d3 12 f0       	mov    $0xf012d331,%ebx
f0115231:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115236:	89 c7                	mov    %eax,%edi
f0115238:	89 de                	mov    %ebx,%esi
f011523a:	89 d1                	mov    %edx,%ecx
f011523c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011523e:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0115244:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115249:	b0 00                	mov    $0x0,%al
f011524b:	89 d7                	mov    %edx,%edi
f011524d:	f3 aa                	rep stos %al,%es:(%edi)
f011524f:	83 ec 0c             	sub    $0xc,%esp
f0115252:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0115258:	50                   	push   %eax
f0115259:	e8 7e cc fe ff       	call   f0101edc <execute_command>
f011525e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0115261:	83 ec 04             	sub    $0x4,%esp
f0115264:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011526a:	50                   	push   %eax
f011526b:	68 ce cb 12 f0       	push   $0xf012cbce
f0115270:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0115276:	50                   	push   %eax
f0115277:	e8 d8 d8 00 00       	call   f0122b54 <strcconcat>
f011527c:	83 c4 10             	add    $0x10,%esp
f011527f:	83 ec 0c             	sub    $0xc,%esp
f0115282:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0115288:	50                   	push   %eax
f0115289:	e8 4e cc fe ff       	call   f0101edc <execute_command>
f011528e:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0115291:	83 ec 04             	sub    $0x4,%esp
f0115294:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011529a:	50                   	push   %eax
f011529b:	68 d8 cb 12 f0       	push   $0xf012cbd8
f01152a0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01152a6:	50                   	push   %eax
f01152a7:	e8 a8 d8 00 00       	call   f0122b54 <strcconcat>
f01152ac:	83 c4 10             	add    $0x10,%esp
f01152af:	83 ec 0c             	sub    $0xc,%esp
f01152b2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01152b8:	50                   	push   %eax
f01152b9:	e8 1e cc fe ff       	call   f0101edc <execute_command>
f01152be:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01152c1:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01152c7:	bb 95 d3 12 f0       	mov    $0xf012d395,%ebx
f01152cc:	ba 0f 00 00 00       	mov    $0xf,%edx
f01152d1:	89 c7                	mov    %eax,%edi
f01152d3:	89 de                	mov    %ebx,%esi
f01152d5:	89 d1                	mov    %edx,%ecx
f01152d7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01152d9:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01152df:	b9 55 00 00 00       	mov    $0x55,%ecx
f01152e4:	b0 00                	mov    $0x0,%al
f01152e6:	89 d7                	mov    %edx,%edi
f01152e8:	f3 aa                	rep stos %al,%es:(%edi)
f01152ea:	83 ec 0c             	sub    $0xc,%esp
f01152ed:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01152f3:	50                   	push   %eax
f01152f4:	e8 e3 cb fe ff       	call   f0101edc <execute_command>
f01152f9:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01152fc:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0115302:	bb f9 d3 12 f0       	mov    $0xf012d3f9,%ebx
f0115307:	ba 0f 00 00 00       	mov    $0xf,%edx
f011530c:	89 c7                	mov    %eax,%edi
f011530e:	89 de                	mov    %ebx,%esi
f0115310:	89 d1                	mov    %edx,%ecx
f0115312:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115314:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011531a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011531f:	b0 00                	mov    $0x0,%al
f0115321:	89 d7                	mov    %edx,%edi
f0115323:	f3 aa                	rep stos %al,%es:(%edi)
f0115325:	83 ec 0c             	sub    $0xc,%esp
f0115328:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011532e:	50                   	push   %eax
f011532f:	e8 a8 cb fe ff       	call   f0101edc <execute_command>
f0115334:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0115337:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011533d:	bb 5d d4 12 f0       	mov    $0xf012d45d,%ebx
f0115342:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115347:	89 c7                	mov    %eax,%edi
f0115349:	89 de                	mov    %ebx,%esi
f011534b:	89 d1                	mov    %edx,%ecx
f011534d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011534f:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0115355:	b9 55 00 00 00       	mov    $0x55,%ecx
f011535a:	b0 00                	mov    $0x0,%al
f011535c:	89 d7                	mov    %edx,%edi
f011535e:	f3 aa                	rep stos %al,%es:(%edi)
f0115360:	83 ec 0c             	sub    $0xc,%esp
f0115363:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0115369:	50                   	push   %eax
f011536a:	e8 6d cb fe ff       	call   f0101edc <execute_command>
f011536f:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0115372:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0115379:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0115380:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0115387:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f011538e:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0115395:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f011539c:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f01153a3:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01153aa:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01153b1:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f01153b8:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01153bf:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01153c6:	8b 45 90             	mov    -0x70(%ebp),%eax
f01153c9:	8a 00                	mov    (%eax),%al
f01153cb:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01153d1:	e8 33 86 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01153d6:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f01153d9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01153dc:	89 d0                	mov    %edx,%eax
f01153de:	01 c0                	add    %eax,%eax
f01153e0:	01 d0                	add    %edx,%eax
f01153e2:	01 c0                	add    %eax,%eax
f01153e4:	50                   	push   %eax
f01153e5:	68 00 00 40 00       	push   $0x400000
f01153ea:	68 00 00 20 00       	push   $0x200000
f01153ef:	ff 75 d4             	pushl  -0x2c(%ebp)
f01153f2:	e8 f3 42 ff ff       	call   f01096ea <copy_paste_chunk>
f01153f7:	83 c4 10             	add    $0x10,%esp
f01153fa:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01153fd:	e8 07 86 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115402:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0115405:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011540c:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0115410:	75 08                	jne    f011541a <test_copy_paste_chunk+0x929>
f0115412:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0115415:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0115418:	74 2b                	je     f0115445 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011541a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011541d:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0115420:	83 ec 0c             	sub    $0xc,%esp
f0115423:	50                   	push   %eax
f0115424:	ff 75 80             	pushl  -0x80(%ebp)
f0115427:	68 e4 cb 12 f0       	push   $0xf012cbe4
f011542c:	68 3f 03 00 00       	push   $0x33f
f0115431:	68 42 c3 12 f0       	push   $0xf012c342
f0115436:	e8 7c b0 fe ff       	call   f01004b7 <_warn>
f011543b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011543e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0115445:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115449:	74 04                	je     f011544f <test_copy_paste_chunk+0x95e>
f011544b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011544f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0115456:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f011545d:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0115460:	83 ec 08             	sub    $0x8,%esp
f0115463:	6a 01                	push   $0x1
f0115465:	6a 07                	push   $0x7
f0115467:	6a 07                	push   $0x7
f0115469:	6a 07                	push   $0x7
f011546b:	6a 07                	push   $0x7
f011546d:	6a 01                	push   $0x1
f011546f:	68 00 20 00 00       	push   $0x2000
f0115474:	68 00 00 40 00       	push   $0x400000
f0115479:	68 00 00 20 00       	push   $0x200000
f011547e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115481:	e8 0a 36 00 00       	call   f0118a90 <CCP>
f0115486:	83 c4 30             	add    $0x30,%esp
f0115489:	83 f8 01             	cmp    $0x1,%eax
f011548c:	74 2b                	je     f01154b9 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011548e:	83 ec 04             	sub    $0x4,%esp
f0115491:	68 38 cc 12 f0       	push   $0xf012cc38
f0115496:	68 48 03 00 00       	push   $0x348
f011549b:	68 42 c3 12 f0       	push   $0xf012c342
f01154a0:	e8 12 b0 fe ff       	call   f01004b7 <_warn>
f01154a5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01154a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f01154af:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f01154b6:	00 00 00 
		}
		if (correct) eval += 5 ;
f01154b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01154bd:	74 04                	je     f01154c3 <test_copy_paste_chunk+0x9d2>
f01154bf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f01154ca:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01154cd:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f01154d0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01154d3:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f01154d6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01154d9:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f01154dc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01154df:	8a 00                	mov    (%eax),%al
f01154e1:	3c 61                	cmp    $0x61,%al
f01154e3:	75 69                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f01154e5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01154e8:	8a 00                	mov    (%eax),%al
f01154ea:	3c 61                	cmp    $0x61,%al
f01154ec:	75 60                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f01154ee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01154f1:	8a 00                	mov    (%eax),%al
f01154f3:	3c 79                	cmp    $0x79,%al
f01154f5:	75 57                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f01154f7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01154fa:	8a 00                	mov    (%eax),%al
f01154fc:	3c 62                	cmp    $0x62,%al
f01154fe:	75 4e                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f0115500:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0115503:	8a 00                	mov    (%eax),%al
f0115505:	3c 63                	cmp    $0x63,%al
f0115507:	75 45                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f0115509:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011550c:	8a 00                	mov    (%eax),%al
f011550e:	3c 7a                	cmp    $0x7a,%al
f0115510:	75 3c                	jne    f011554e <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0115512:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115515:	8a 00                	mov    (%eax),%al
f0115517:	3c 77                	cmp    $0x77,%al
f0115519:	75 33                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f011551b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011551e:	8a 00                	mov    (%eax),%al
f0115520:	3c 64                	cmp    $0x64,%al
f0115522:	75 2a                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f0115524:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0115527:	8a 00                	mov    (%eax),%al
f0115529:	3c 65                	cmp    $0x65,%al
f011552b:	75 21                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f011552d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0115530:	8a 00                	mov    (%eax),%al
f0115532:	3c 65                	cmp    $0x65,%al
f0115534:	75 18                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f0115536:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0115539:	8a 00                	mov    (%eax),%al
f011553b:	3c 66                	cmp    $0x66,%al
f011553d:	75 0f                	jne    f011554e <test_copy_paste_chunk+0xa5d>
f011553f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0115542:	8a 10                	mov    (%eax),%dl
f0115544:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011554a:	38 c2                	cmp    %al,%dl
f011554c:	74 21                	je     f011556f <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011554e:	83 ec 04             	sub    $0x4,%esp
f0115551:	68 38 cb 12 f0       	push   $0xf012cb38
f0115556:	68 56 03 00 00       	push   $0x356
f011555b:	68 42 c3 12 f0       	push   $0xf012c342
f0115560:	e8 52 af fe ff       	call   f01004b7 <_warn>
f0115565:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115568:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011556f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115573:	74 04                	je     f0115579 <test_copy_paste_chunk+0xa88>
f0115575:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115579:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0115580:	8b 45 98             	mov    -0x68(%ebp),%eax
f0115583:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115586:	e8 7e 84 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011558b:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011558e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115591:	89 c2                	mov    %eax,%edx
f0115593:	01 d2                	add    %edx,%edx
f0115595:	01 d0                	add    %edx,%eax
f0115597:	50                   	push   %eax
f0115598:	68 00 08 20 00       	push   $0x200800
f011559d:	68 00 08 40 00       	push   $0x400800
f01155a2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01155a5:	e8 40 41 ff ff       	call   f01096ea <copy_paste_chunk>
f01155aa:	83 c4 10             	add    $0x10,%esp
f01155ad:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01155b0:	e8 54 84 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01155b5:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01155b8:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01155bc:	75 08                	jne    f01155c6 <test_copy_paste_chunk+0xad5>
f01155be:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01155c1:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01155c4:	74 2b                	je     f01155f1 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01155c6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01155c9:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01155cc:	83 ec 0c             	sub    $0xc,%esp
f01155cf:	50                   	push   %eax
f01155d0:	ff 75 80             	pushl  -0x80(%ebp)
f01155d3:	68 e4 cb 12 f0       	push   $0xf012cbe4
f01155d8:	68 66 03 00 00       	push   $0x366
f01155dd:	68 42 c3 12 f0       	push   $0xf012c342
f01155e2:	e8 d0 ae fe ff       	call   f01004b7 <_warn>
f01155e7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155ea:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01155f1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01155f5:	74 04                	je     f01155fb <test_copy_paste_chunk+0xb0a>
f01155f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01155fb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0115602:	83 ec 08             	sub    $0x8,%esp
f0115605:	6a 01                	push   $0x1
f0115607:	6a 07                	push   $0x7
f0115609:	6a 07                	push   $0x7
f011560b:	6a 07                	push   $0x7
f011560d:	6a 07                	push   $0x7
f011560f:	6a 01                	push   $0x1
f0115611:	68 00 20 00 00       	push   $0x2000
f0115616:	68 00 00 20 00       	push   $0x200000
f011561b:	68 00 00 40 00       	push   $0x400000
f0115620:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115623:	e8 68 34 00 00       	call   f0118a90 <CCP>
f0115628:	83 c4 30             	add    $0x30,%esp
f011562b:	83 f8 01             	cmp    $0x1,%eax
f011562e:	74 21                	je     f0115651 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0115630:	83 ec 04             	sub    $0x4,%esp
f0115633:	68 84 cc 12 f0       	push   $0xf012cc84
f0115638:	68 6e 03 00 00       	push   $0x36e
f011563d:	68 42 c3 12 f0       	push   $0xf012c342
f0115642:	e8 70 ae fe ff       	call   f01004b7 <_warn>
f0115647:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011564a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0115651:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115655:	74 04                	je     f011565b <test_copy_paste_chunk+0xb6a>
f0115657:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011565b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0115662:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115665:	8a 00                	mov    (%eax),%al
f0115667:	3c 61                	cmp    $0x61,%al
f0115669:	75 69                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f011566b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011566e:	8a 00                	mov    (%eax),%al
f0115670:	3c 61                	cmp    $0x61,%al
f0115672:	75 60                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f0115674:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115677:	8a 00                	mov    (%eax),%al
f0115679:	3c 79                	cmp    $0x79,%al
f011567b:	75 57                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f011567d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0115680:	8a 00                	mov    (%eax),%al
f0115682:	3c 62                	cmp    $0x62,%al
f0115684:	75 4e                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f0115686:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0115689:	8a 00                	mov    (%eax),%al
f011568b:	3c 7a                	cmp    $0x7a,%al
f011568d:	75 45                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f011568f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115692:	8a 00                	mov    (%eax),%al
f0115694:	3c 7a                	cmp    $0x7a,%al
f0115696:	75 3c                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0115698:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011569b:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011569d:	3c 64                	cmp    $0x64,%al
f011569f:	75 33                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01156a1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01156a4:	8a 00                	mov    (%eax),%al
f01156a6:	3c 64                	cmp    $0x64,%al
f01156a8:	75 2a                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f01156aa:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01156ad:	8a 00                	mov    (%eax),%al
f01156af:	3c 65                	cmp    $0x65,%al
f01156b1:	75 21                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f01156b3:	8b 45 98             	mov    -0x68(%ebp),%eax
f01156b6:	8a 00                	mov    (%eax),%al
f01156b8:	3c 78                	cmp    $0x78,%al
f01156ba:	75 18                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f01156bc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01156bf:	8a 00                	mov    (%eax),%al
f01156c1:	3c 66                	cmp    $0x66,%al
f01156c3:	75 0f                	jne    f01156d4 <test_copy_paste_chunk+0xbe3>
f01156c5:	8b 45 90             	mov    -0x70(%ebp),%eax
f01156c8:	8a 10                	mov    (%eax),%dl
f01156ca:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01156d0:	38 c2                	cmp    %al,%dl
f01156d2:	74 21                	je     f01156f5 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01156d4:	83 ec 04             	sub    $0x4,%esp
f01156d7:	68 38 cb 12 f0       	push   $0xf012cb38
f01156dc:	68 77 03 00 00       	push   $0x377
f01156e1:	68 42 c3 12 f0       	push   $0xf012c342
f01156e6:	e8 cc ad fe ff       	call   f01004b7 <_warn>
f01156eb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01156ee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01156f5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01156f9:	74 04                	je     f01156ff <test_copy_paste_chunk+0xc0e>
f01156fb:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01156ff:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0115706:	83 ec 0c             	sub    $0xc,%esp
f0115709:	68 cf cc 12 f0       	push   $0xf012cccf
f011570e:	e8 59 b8 fe ff       	call   f0100f6c <cprintf>
f0115713:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0115716:	83 ec 0c             	sub    $0xc,%esp
f0115719:	68 e0 cc 12 f0       	push   $0xf012cce0
f011571e:	e8 49 b8 fe ff       	call   f0100f6c <cprintf>
f0115723:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0115726:	83 ec 04             	sub    $0x4,%esp
f0115729:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011572f:	50                   	push   %eax
f0115730:	68 14 cd 12 f0       	push   $0xf012cd14
f0115735:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011573b:	50                   	push   %eax
f011573c:	e8 13 d4 00 00       	call   f0122b54 <strcconcat>
f0115741:	83 c4 10             	add    $0x10,%esp
f0115744:	83 ec 0c             	sub    $0xc,%esp
f0115747:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011574d:	50                   	push   %eax
f011574e:	e8 89 c7 fe ff       	call   f0101edc <execute_command>
f0115753:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0115756:	83 ec 04             	sub    $0x4,%esp
f0115759:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011575f:	50                   	push   %eax
f0115760:	68 1e cd 12 f0       	push   $0xf012cd1e
f0115765:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011576b:	50                   	push   %eax
f011576c:	e8 e3 d3 00 00       	call   f0122b54 <strcconcat>
f0115771:	83 c4 10             	add    $0x10,%esp
f0115774:	83 ec 0c             	sub    $0xc,%esp
f0115777:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011577d:	50                   	push   %eax
f011577e:	e8 59 c7 fe ff       	call   f0101edc <execute_command>
f0115783:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0115786:	83 ec 04             	sub    $0x4,%esp
f0115789:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011578f:	50                   	push   %eax
f0115790:	68 28 cd 12 f0       	push   $0xf012cd28
f0115795:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011579b:	50                   	push   %eax
f011579c:	e8 b3 d3 00 00       	call   f0122b54 <strcconcat>
f01157a1:	83 c4 10             	add    $0x10,%esp
f01157a4:	83 ec 0c             	sub    $0xc,%esp
f01157a7:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01157ad:	50                   	push   %eax
f01157ae:	e8 29 c7 fe ff       	call   f0101edc <execute_command>
f01157b3:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f01157b6:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01157bc:	bb c1 d4 12 f0       	mov    $0xf012d4c1,%ebx
f01157c1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01157c6:	89 c7                	mov    %eax,%edi
f01157c8:	89 de                	mov    %ebx,%esi
f01157ca:	89 d1                	mov    %edx,%ecx
f01157cc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01157ce:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01157d4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01157d9:	b0 00                	mov    $0x0,%al
f01157db:	89 d7                	mov    %edx,%edi
f01157dd:	f3 aa                	rep stos %al,%es:(%edi)
f01157df:	83 ec 0c             	sub    $0xc,%esp
f01157e2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01157e8:	50                   	push   %eax
f01157e9:	e8 ee c6 fe ff       	call   f0101edc <execute_command>
f01157ee:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f01157f1:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01157f7:	bb 25 d5 12 f0       	mov    $0xf012d525,%ebx
f01157fc:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115801:	89 c7                	mov    %eax,%edi
f0115803:	89 de                	mov    %ebx,%esi
f0115805:	89 d1                	mov    %edx,%ecx
f0115807:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115809:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011580f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115814:	b0 00                	mov    $0x0,%al
f0115816:	89 d7                	mov    %edx,%edi
f0115818:	f3 aa                	rep stos %al,%es:(%edi)
f011581a:	83 ec 0c             	sub    $0xc,%esp
f011581d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0115823:	50                   	push   %eax
f0115824:	e8 b3 c6 fe ff       	call   f0101edc <execute_command>
f0115829:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f011582c:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0115832:	bb 89 d5 12 f0       	mov    $0xf012d589,%ebx
f0115837:	ba 0f 00 00 00       	mov    $0xf,%edx
f011583c:	89 c7                	mov    %eax,%edi
f011583e:	89 de                	mov    %ebx,%esi
f0115840:	89 d1                	mov    %edx,%ecx
f0115842:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115844:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011584a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011584f:	b0 00                	mov    $0x0,%al
f0115851:	89 d7                	mov    %edx,%edi
f0115853:	f3 aa                	rep stos %al,%es:(%edi)
f0115855:	83 ec 0c             	sub    $0xc,%esp
f0115858:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011585e:	50                   	push   %eax
f011585f:	e8 78 c6 fe ff       	call   f0101edc <execute_command>
f0115864:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115867:	e8 9d 81 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011586c:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011586f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115872:	89 d0                	mov    %edx,%eax
f0115874:	01 c0                	add    %eax,%eax
f0115876:	01 d0                	add    %edx,%eax
f0115878:	c1 e0 02             	shl    $0x2,%eax
f011587b:	50                   	push   %eax
f011587c:	68 00 00 90 00       	push   $0x900000
f0115881:	68 00 00 80 00       	push   $0x800000
f0115886:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115889:	e8 5c 3e ff ff       	call   f01096ea <copy_paste_chunk>
f011588e:	83 c4 10             	add    $0x10,%esp
f0115891:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115897:	e8 6d 81 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011589c:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011589f:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01158a6:	75 0b                	jne    f01158b3 <test_copy_paste_chunk+0xdc2>
f01158a8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01158ab:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01158ae:	83 f8 03             	cmp    $0x3,%eax
f01158b1:	74 2e                	je     f01158e1 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01158b3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01158b6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01158b9:	83 ec 0c             	sub    $0xc,%esp
f01158bc:	50                   	push   %eax
f01158bd:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01158c3:	68 e4 cb 12 f0       	push   $0xf012cbe4
f01158c8:	68 95 03 00 00       	push   $0x395
f01158cd:	68 42 c3 12 f0       	push   $0xf012c342
f01158d2:	e8 e0 ab fe ff       	call   f01004b7 <_warn>
f01158d7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01158e1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01158e5:	74 04                	je     f01158eb <test_copy_paste_chunk+0xdfa>
f01158e7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158eb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f01158f2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01158f9:	83 ec 08             	sub    $0x8,%esp
f01158fc:	6a 01                	push   $0x1
f01158fe:	6a 07                	push   $0x7
f0115900:	6a 07                	push   $0x7
f0115902:	6a 07                	push   $0x7
f0115904:	6a 07                	push   $0x7
f0115906:	6a 01                	push   $0x1
f0115908:	68 00 30 00 00       	push   $0x3000
f011590d:	68 00 00 90 00       	push   $0x900000
f0115912:	68 00 00 80 00       	push   $0x800000
f0115917:	ff 75 d4             	pushl  -0x2c(%ebp)
f011591a:	e8 71 31 00 00       	call   f0118a90 <CCP>
f011591f:	83 c4 30             	add    $0x30,%esp
f0115922:	83 f8 01             	cmp    $0x1,%eax
f0115925:	74 28                	je     f011594f <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0115927:	83 ec 04             	sub    $0x4,%esp
f011592a:	68 84 cc 12 f0       	push   $0xf012cc84
f011592f:	68 9e 03 00 00       	push   $0x39e
f0115934:	68 42 c3 12 f0       	push   $0xf012c342
f0115939:	e8 79 ab fe ff       	call   f01004b7 <_warn>
f011593e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115941:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0115948:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f011594f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115953:	74 04                	je     f0115959 <test_copy_paste_chunk+0xe68>
f0115955:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115959:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0115960:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0115964:	0f 84 9e 00 00 00    	je     f0115a08 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f011596a:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0115971:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0115978:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f011597f:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0115986:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f011598d:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0115994:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115997:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f011599a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011599d:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f01159a0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01159a3:	8a 00                	mov    (%eax),%al
f01159a5:	3c 61                	cmp    $0x61,%al
f01159a7:	75 2d                	jne    f01159d6 <test_copy_paste_chunk+0xee5>
f01159a9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01159ac:	8a 00                	mov    (%eax),%al
f01159ae:	3c 61                	cmp    $0x61,%al
f01159b0:	75 24                	jne    f01159d6 <test_copy_paste_chunk+0xee5>
f01159b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01159b5:	8a 00                	mov    (%eax),%al
f01159b7:	3c 79                	cmp    $0x79,%al
f01159b9:	75 1b                	jne    f01159d6 <test_copy_paste_chunk+0xee5>
f01159bb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01159be:	8a 00                	mov    (%eax),%al
f01159c0:	3c 62                	cmp    $0x62,%al
f01159c2:	75 12                	jne    f01159d6 <test_copy_paste_chunk+0xee5>
f01159c4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01159c7:	8a 00                	mov    (%eax),%al
f01159c9:	3c 63                	cmp    $0x63,%al
f01159cb:	75 09                	jne    f01159d6 <test_copy_paste_chunk+0xee5>
f01159cd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01159d0:	8a 00                	mov    (%eax),%al
f01159d2:	3c 7a                	cmp    $0x7a,%al
f01159d4:	74 21                	je     f01159f7 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01159d6:	83 ec 04             	sub    $0x4,%esp
f01159d9:	68 38 cb 12 f0       	push   $0xf012cb38
f01159de:	68 b0 03 00 00       	push   $0x3b0
f01159e3:	68 42 c3 12 f0       	push   $0xf012c342
f01159e8:	e8 ca aa fe ff       	call   f01004b7 <_warn>
f01159ed:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01159f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f01159f7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01159fb:	74 04                	je     f0115a01 <test_copy_paste_chunk+0xf10>
f01159fd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0115a01:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115a08:	e8 fc 7f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115a0d:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0115a10:	6a 00                	push   $0x0
f0115a12:	6a 02                	push   $0x2
f0115a14:	68 00 10 90 00       	push   $0x901000
f0115a19:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115a1c:	e8 b1 2b 00 00       	call   f01185d2 <SB>
f0115a21:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0115a24:	6a 00                	push   $0x0
f0115a26:	6a 02                	push   $0x2
f0115a28:	68 00 20 90 00       	push   $0x902000
f0115a2d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115a30:	e8 9d 2b 00 00       	call   f01185d2 <SB>
f0115a35:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0115a38:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115a3b:	c1 e0 03             	shl    $0x3,%eax
f0115a3e:	50                   	push   %eax
f0115a3f:	68 00 f0 bf 00       	push   $0xbff000
f0115a44:	68 00 10 90 00       	push   $0x901000
f0115a49:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115a4c:	e8 99 3c ff ff       	call   f01096ea <copy_paste_chunk>
f0115a51:	83 c4 10             	add    $0x10,%esp
f0115a54:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115a5a:	e8 aa 7f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115a5f:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0115a62:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0115a69:	75 0b                	jne    f0115a76 <test_copy_paste_chunk+0xf85>
f0115a6b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0115a6e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0115a71:	83 f8 03             	cmp    $0x3,%eax
f0115a74:	74 2e                	je     f0115aa4 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0115a76:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0115a79:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0115a7c:	83 ec 0c             	sub    $0xc,%esp
f0115a7f:	50                   	push   %eax
f0115a80:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0115a86:	68 e4 cb 12 f0       	push   $0xf012cbe4
f0115a8b:	68 c0 03 00 00       	push   $0x3c0
f0115a90:	68 42 c3 12 f0       	push   $0xf012c342
f0115a95:	e8 1d aa fe ff       	call   f01004b7 <_warn>
f0115a9a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a9d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0115aa4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115aa8:	74 04                	je     f0115aae <test_copy_paste_chunk+0xfbd>
f0115aaa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115aae:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0115ab5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0115abc:	83 ec 08             	sub    $0x8,%esp
f0115abf:	6a 01                	push   $0x1
f0115ac1:	6a 07                	push   $0x7
f0115ac3:	6a 03                	push   $0x3
f0115ac5:	6a 07                	push   $0x7
f0115ac7:	6a 03                	push   $0x3
f0115ac9:	6a 01                	push   $0x1
f0115acb:	68 00 20 00 00       	push   $0x2000
f0115ad0:	68 00 f0 bf 00       	push   $0xbff000
f0115ad5:	68 00 10 90 00       	push   $0x901000
f0115ada:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115add:	e8 ae 2f 00 00       	call   f0118a90 <CCP>
f0115ae2:	83 c4 30             	add    $0x30,%esp
f0115ae5:	83 f8 01             	cmp    $0x1,%eax
f0115ae8:	74 28                	je     f0115b12 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0115aea:	83 ec 04             	sub    $0x4,%esp
f0115aed:	68 84 cc 12 f0       	push   $0xf012cc84
f0115af2:	68 c9 03 00 00       	push   $0x3c9
f0115af7:	68 42 c3 12 f0       	push   $0xf012c342
f0115afc:	e8 b6 a9 fe ff       	call   f01004b7 <_warn>
f0115b01:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115b04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0115b0b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0115b12:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115b16:	74 04                	je     f0115b1c <test_copy_paste_chunk+0x102b>
f0115b18:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115b1c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0115b23:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0115b27:	74 72                	je     f0115b9b <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0115b29:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0115b30:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0115b37:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0115b3e:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0115b45:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115b48:	8a 00                	mov    (%eax),%al
f0115b4a:	3c 62                	cmp    $0x62,%al
f0115b4c:	75 1b                	jne    f0115b69 <test_copy_paste_chunk+0x1078>
f0115b4e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115b51:	8a 00                	mov    (%eax),%al
f0115b53:	3c 62                	cmp    $0x62,%al
f0115b55:	75 12                	jne    f0115b69 <test_copy_paste_chunk+0x1078>
f0115b57:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115b5a:	8a 00                	mov    (%eax),%al
f0115b5c:	3c 7a                	cmp    $0x7a,%al
f0115b5e:	75 09                	jne    f0115b69 <test_copy_paste_chunk+0x1078>
f0115b60:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0115b63:	8a 00                	mov    (%eax),%al
f0115b65:	3c 7a                	cmp    $0x7a,%al
f0115b67:	74 21                	je     f0115b8a <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0115b69:	83 ec 04             	sub    $0x4,%esp
f0115b6c:	68 38 cb 12 f0       	push   $0xf012cb38
f0115b71:	68 d5 03 00 00       	push   $0x3d5
f0115b76:	68 42 c3 12 f0       	push   $0xf012c342
f0115b7b:	e8 37 a9 fe ff       	call   f01004b7 <_warn>
f0115b80:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115b83:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0115b8a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115b8e:	74 04                	je     f0115b94 <test_copy_paste_chunk+0x10a3>
f0115b90:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0115b94:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0115b9b:	83 ec 0c             	sub    $0xc,%esp
f0115b9e:	68 32 cd 12 f0       	push   $0xf012cd32
f0115ba3:	e8 c4 b3 fe ff       	call   f0100f6c <cprintf>
f0115ba8:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0115bab:	83 ec 08             	sub    $0x8,%esp
f0115bae:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115bb1:	68 44 cd 12 f0       	push   $0xf012cd44
f0115bb6:	e8 b1 b3 fe ff       	call   f0100f6c <cprintf>
f0115bbb:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115bbe:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115bc2:	75 10                	jne    f0115bd4 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0115bc4:	83 ec 0c             	sub    $0xc,%esp
f0115bc7:	68 78 cd 12 f0       	push   $0xf012cd78
f0115bcc:	e8 9b b3 fe ff       	call   f0100f6c <cprintf>
f0115bd1:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115bd4:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f0115bd9:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0115bdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115bdf:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115be2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115be7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115bea:	5b                   	pop    %ebx
f0115beb:	5e                   	pop    %esi
f0115bec:	5f                   	pop    %edi
f0115bed:	5d                   	pop    %ebp
f0115bee:	c3                   	ret    

f0115bef <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0115bef:	55                   	push   %ebp
f0115bf0:	89 e5                	mov    %esp,%ebp
f0115bf2:	57                   	push   %edi
f0115bf3:	56                   	push   %esi
f0115bf4:	53                   	push   %ebx
f0115bf5:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115bfb:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0115c01:	bb 44 ca 12 f0       	mov    $0xf012ca44,%ebx
f0115c06:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115c0b:	89 c7                	mov    %eax,%edi
f0115c0d:	89 de                	mov    %ebx,%esi
f0115c0f:	89 d1                	mov    %edx,%ecx
f0115c11:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115c13:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0115c19:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115c1e:	b0 00                	mov    $0x0,%al
f0115c20:	89 d7                	mov    %edx,%edi
f0115c22:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115c24:	6a 00                	push   $0x0
f0115c26:	6a 0a                	push   $0xa
f0115c28:	6a 14                	push   $0x14
f0115c2a:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0115c30:	50                   	push   %eax
f0115c31:	e8 3a 3e ff ff       	call   f0109a70 <env_create>
f0115c36:	83 c4 10             	add    $0x10,%esp
f0115c39:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115c3c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c3f:	8b 40 64             	mov    0x64(%eax),%eax
f0115c42:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0115c45:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c48:	8b 40 68             	mov    0x68(%eax),%eax
f0115c4b:	89 45 80             	mov    %eax,-0x80(%ebp)
f0115c4e:	8b 45 80             	mov    -0x80(%ebp),%eax
f0115c51:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0115c54:	83 ec 0c             	sub    $0xc,%esp
f0115c57:	ff 75 cc             	pushl  -0x34(%ebp)
f0115c5a:	e8 fd 2d 00 00       	call   f0118a5c <ClearUserSpace>
f0115c5f:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115c62:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0115c69:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0115c70:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0115c77:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0115c7b:	83 ec 0c             	sub    $0xc,%esp
f0115c7e:	68 f0 d5 12 f0       	push   $0xf012d5f0
f0115c83:	e8 e4 b2 fe ff       	call   f0100f6c <cprintf>
f0115c88:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0115c8b:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0115c92:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0115c99:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115c9c:	8a 00                	mov    (%eax),%al
f0115c9e:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0115ca4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115ca7:	8a 00                	mov    (%eax),%al
f0115ca9:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115caf:	e8 55 7d ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115cb4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0115cb7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115cba:	89 d0                	mov    %edx,%eax
f0115cbc:	01 c0                	add    %eax,%eax
f0115cbe:	01 d0                	add    %edx,%eax
f0115cc0:	01 c0                	add    %eax,%eax
f0115cc2:	83 ec 0c             	sub    $0xc,%esp
f0115cc5:	6a 02                	push   $0x2
f0115cc7:	50                   	push   %eax
f0115cc8:	68 00 40 10 f0       	push   $0xf0104000
f0115ccd:	68 00 00 10 f0       	push   $0xf0100000
f0115cd2:	ff 75 cc             	pushl  -0x34(%ebp)
f0115cd5:	e8 2a 3a ff ff       	call   f0109704 <share_chunk>
f0115cda:	83 c4 20             	add    $0x20,%esp
f0115cdd:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115ce0:	e8 24 7d ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115ce5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0115ce8:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0115cec:	75 08                	jne    f0115cf6 <test_share_chunk+0x107>
f0115cee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115cf1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0115cf4:	74 28                	je     f0115d1e <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0115cf6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115cf9:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115cfc:	83 ec 0c             	sub    $0xc,%esp
f0115cff:	50                   	push   %eax
f0115d00:	ff 75 b0             	pushl  -0x50(%ebp)
f0115d03:	68 1c d6 12 f0       	push   $0xf012d61c
f0115d08:	68 11 04 00 00       	push   $0x411
f0115d0d:	68 42 c3 12 f0       	push   $0xf012c342
f0115d12:	e8 a0 a7 fe ff       	call   f01004b7 <_warn>
f0115d17:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d1a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d1e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d22:	74 04                	je     f0115d28 <test_share_chunk+0x139>
f0115d24:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d28:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0115d2c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115d2f:	c1 e0 03             	shl    $0x3,%eax
f0115d32:	83 ec 08             	sub    $0x8,%esp
f0115d35:	68 fd 00 00 00       	push   $0xfd
f0115d3a:	6a 07                	push   $0x7
f0115d3c:	6a 03                	push   $0x3
f0115d3e:	6a 07                	push   $0x7
f0115d40:	6a 03                	push   $0x3
f0115d42:	6a 01                	push   $0x1
f0115d44:	50                   	push   %eax
f0115d45:	68 00 40 10 f0       	push   $0xf0104000
f0115d4a:	68 00 00 10 f0       	push   $0xf0100000
f0115d4f:	ff 75 cc             	pushl  -0x34(%ebp)
f0115d52:	e8 39 2d 00 00       	call   f0118a90 <CCP>
f0115d57:	83 c4 30             	add    $0x30,%esp
f0115d5a:	85 c0                	test   %eax,%eax
f0115d5c:	75 1e                	jne    f0115d7c <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115d5e:	83 ec 04             	sub    $0x4,%esp
f0115d61:	68 78 d6 12 f0       	push   $0xf012d678
f0115d66:	68 19 04 00 00       	push   $0x419
f0115d6b:	68 42 c3 12 f0       	push   $0xf012c342
f0115d70:	e8 42 a7 fe ff       	call   f01004b7 <_warn>
f0115d75:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115d78:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d7c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d80:	74 04                	je     f0115d86 <test_share_chunk+0x197>
f0115d82:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0115d86:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115d89:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0115d8c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115d8f:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0115d92:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115d95:	8a 00                	mov    (%eax),%al
f0115d97:	3c 41                	cmp    $0x41,%al
f0115d99:	75 09                	jne    f0115da4 <test_share_chunk+0x1b5>
f0115d9b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115d9e:	8a 00                	mov    (%eax),%al
f0115da0:	3c 42                	cmp    $0x42,%al
f0115da2:	74 1e                	je     f0115dc2 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0115da4:	83 ec 04             	sub    $0x4,%esp
f0115da7:	68 c0 d6 12 f0       	push   $0xf012d6c0
f0115dac:	68 23 04 00 00       	push   $0x423
f0115db1:	68 42 c3 12 f0       	push   $0xf012c342
f0115db6:	e8 fc a6 fe ff       	call   f01004b7 <_warn>
f0115dbb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115dbe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115dc2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115dc6:	74 04                	je     f0115dcc <test_share_chunk+0x1dd>
f0115dc8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115dcc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0115dd0:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0115dd6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115dd9:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0115ddb:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0115de1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115de4:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0115de6:	83 ec 0c             	sub    $0xc,%esp
f0115de9:	68 f5 d6 12 f0       	push   $0xf012d6f5
f0115dee:	e8 79 b1 fe ff       	call   f0100f6c <cprintf>
f0115df3:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0115df6:	83 ec 0c             	sub    $0xc,%esp
f0115df9:	68 04 d7 12 f0       	push   $0xf012d704
f0115dfe:	e8 69 b1 fe ff       	call   f0100f6c <cprintf>
f0115e03:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115e06:	e8 fe 7b ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115e0b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0115e0e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115e11:	c1 e0 05             	shl    $0x5,%eax
f0115e14:	83 ec 0c             	sub    $0xc,%esp
f0115e17:	68 02 0e 00 00       	push   $0xe02
f0115e1c:	50                   	push   %eax
f0115e1d:	68 00 00 00 40       	push   $0x40000000
f0115e22:	68 00 00 00 f0       	push   $0xf0000000
f0115e27:	ff 75 cc             	pushl  -0x34(%ebp)
f0115e2a:	e8 d5 38 ff ff       	call   f0109704 <share_chunk>
f0115e2f:	83 c4 20             	add    $0x20,%esp
f0115e32:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115e35:	e8 cf 7b ff ff       	call   f010da09 <sys_calculate_free_frames>
f0115e3a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0115e3d:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0115e41:	75 1f                	jne    f0115e62 <test_share_chunk+0x273>
f0115e43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115e46:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115e49:	89 c1                	mov    %eax,%ecx
f0115e4b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115e4e:	c1 e0 05             	shl    $0x5,%eax
f0115e51:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115e54:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115e5b:	99                   	cltd   
f0115e5c:	f7 fb                	idiv   %ebx
f0115e5e:	39 c1                	cmp    %eax,%ecx
f0115e60:	74 28                	je     f0115e8a <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0115e62:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115e65:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115e68:	83 ec 0c             	sub    $0xc,%esp
f0115e6b:	50                   	push   %eax
f0115e6c:	ff 75 a8             	pushl  -0x58(%ebp)
f0115e6f:	68 40 d7 12 f0       	push   $0xf012d740
f0115e74:	68 3b 04 00 00       	push   $0x43b
f0115e79:	68 42 c3 12 f0       	push   $0xf012c342
f0115e7e:	e8 34 a6 fe ff       	call   f01004b7 <_warn>
f0115e83:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e86:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e8a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e8e:	74 04                	je     f0115e94 <test_share_chunk+0x2a5>
f0115e90:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e94:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0115e98:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0115e9f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115ea2:	c1 e0 05             	shl    $0x5,%eax
f0115ea5:	83 ec 08             	sub    $0x8,%esp
f0115ea8:	6a 02                	push   $0x2
f0115eaa:	6a 07                	push   $0x7
f0115eac:	6a 03                	push   $0x3
f0115eae:	68 07 0e 00 00       	push   $0xe07
f0115eb3:	68 03 0e 00 00       	push   $0xe03
f0115eb8:	6a ff                	push   $0xffffffff
f0115eba:	50                   	push   %eax
f0115ebb:	68 00 00 00 40       	push   $0x40000000
f0115ec0:	68 00 00 00 f0       	push   $0xf0000000
f0115ec5:	ff 75 cc             	pushl  -0x34(%ebp)
f0115ec8:	e8 c3 2b 00 00       	call   f0118a90 <CCP>
f0115ecd:	83 c4 30             	add    $0x30,%esp
f0115ed0:	85 c0                	test   %eax,%eax
f0115ed2:	75 25                	jne    f0115ef9 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115ed4:	83 ec 04             	sub    $0x4,%esp
f0115ed7:	68 78 d6 12 f0       	push   $0xf012d678
f0115edc:	68 44 04 00 00       	push   $0x444
f0115ee1:	68 42 c3 12 f0       	push   $0xf012c342
f0115ee6:	e8 cc a5 fe ff       	call   f01004b7 <_warn>
f0115eeb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115eee:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0115ef2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0115ef9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115efc:	89 d0                	mov    %edx,%eax
f0115efe:	01 c0                	add    %eax,%eax
f0115f00:	01 d0                	add    %edx,%eax
f0115f02:	c1 e0 02             	shl    $0x2,%eax
f0115f05:	83 ec 08             	sub    $0x8,%esp
f0115f08:	6a 02                	push   $0x2
f0115f0a:	6a 07                	push   $0x7
f0115f0c:	6a 03                	push   $0x3
f0115f0e:	68 07 0e 00 00       	push   $0xe07
f0115f13:	68 03 0e 00 00       	push   $0xe03
f0115f18:	6a 02                	push   $0x2
f0115f1a:	50                   	push   %eax
f0115f1b:	68 00 00 00 40       	push   $0x40000000
f0115f20:	68 00 00 00 f0       	push   $0xf0000000
f0115f25:	ff 75 cc             	pushl  -0x34(%ebp)
f0115f28:	e8 63 2b 00 00       	call   f0118a90 <CCP>
f0115f2d:	83 c4 30             	add    $0x30,%esp
f0115f30:	85 c0                	test   %eax,%eax
f0115f32:	75 1e                	jne    f0115f52 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115f34:	83 ec 04             	sub    $0x4,%esp
f0115f37:	68 78 d6 12 f0       	push   $0xf012d678
f0115f3c:	68 4b 04 00 00       	push   $0x44b
f0115f41:	68 42 c3 12 f0       	push   $0xf012c342
f0115f46:	e8 6c a5 fe ff       	call   f01004b7 <_warn>
f0115f4b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115f4e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f52:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f56:	74 04                	je     f0115f5c <test_share_chunk+0x36d>
f0115f58:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f5c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0115f60:	b8 30 64 5c f0       	mov    $0xf05c6430,%eax
f0115f65:	05 00 00 00 10       	add    $0x10000000,%eax
f0115f6a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0115f6d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115f70:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0115f75:	83 ec 08             	sub    $0x8,%esp
f0115f78:	6a 02                	push   $0x2
f0115f7a:	6a 07                	push   $0x7
f0115f7c:	6a 03                	push   $0x3
f0115f7e:	68 07 0e 00 00       	push   $0xe07
f0115f83:	68 03 0e 00 00       	push   $0xe03
f0115f88:	6a 02                	push   $0x2
f0115f8a:	50                   	push   %eax
f0115f8b:	68 00 00 0a 40       	push   $0x400a0000
f0115f90:	68 00 00 0a f0       	push   $0xf00a0000
f0115f95:	ff 75 cc             	pushl  -0x34(%ebp)
f0115f98:	e8 f3 2a 00 00       	call   f0118a90 <CCP>
f0115f9d:	83 c4 30             	add    $0x30,%esp
f0115fa0:	85 c0                	test   %eax,%eax
f0115fa2:	75 1e                	jne    f0115fc2 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115fa4:	83 ec 04             	sub    $0x4,%esp
f0115fa7:	68 78 d6 12 f0       	push   $0xf012d678
f0115fac:	68 55 04 00 00       	push   $0x455
f0115fb1:	68 42 c3 12 f0       	push   $0xf012c342
f0115fb6:	e8 fc a4 fe ff       	call   f01004b7 <_warn>
f0115fbb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115fbe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115fc2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fc6:	74 04                	je     f0115fcc <test_share_chunk+0x3dd>
f0115fc8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115fcc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0115fd0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0115fd4:	0f 84 a4 00 00 00    	je     f011607e <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0115fda:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0115fe1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115fe4:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0115fe7:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0115fee:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115ff1:	8a 00                	mov    (%eax),%al
f0115ff3:	3c 41                	cmp    $0x41,%al
f0115ff5:	75 09                	jne    f0116000 <test_share_chunk+0x411>
f0115ff7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115ffa:	8a 00                	mov    (%eax),%al
f0115ffc:	3c 41                	cmp    $0x41,%al
f0115ffe:	74 1e                	je     f011601e <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0116000:	83 ec 04             	sub    $0x4,%esp
f0116003:	68 c0 d6 12 f0       	push   $0xf012d6c0
f0116008:	68 62 04 00 00       	push   $0x462
f011600d:	68 42 c3 12 f0       	push   $0xf012c342
f0116012:	e8 a0 a4 fe ff       	call   f01004b7 <_warn>
f0116017:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011601a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011601e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116022:	74 04                	je     f0116028 <test_share_chunk+0x439>
f0116024:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0116028:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f011602c:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0116033:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116036:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0116039:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0116040:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116043:	8a 00                	mov    (%eax),%al
f0116045:	3c 43                	cmp    $0x43,%al
f0116047:	75 09                	jne    f0116052 <test_share_chunk+0x463>
f0116049:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011604c:	8a 00                	mov    (%eax),%al
f011604e:	3c 43                	cmp    $0x43,%al
f0116050:	74 1e                	je     f0116070 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0116052:	83 ec 04             	sub    $0x4,%esp
f0116055:	68 c0 d6 12 f0       	push   $0xf012d6c0
f011605a:	68 6d 04 00 00       	push   $0x46d
f011605f:	68 42 c3 12 f0       	push   $0xf012c342
f0116064:	e8 4e a4 fe ff       	call   f01004b7 <_warn>
f0116069:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011606c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0116070:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116074:	74 04                	je     f011607a <test_share_chunk+0x48b>
f0116076:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011607a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011607e:	83 ec 0c             	sub    $0xc,%esp
f0116081:	68 cf cc 12 f0       	push   $0xf012cccf
f0116086:	e8 e1 ae fe ff       	call   f0100f6c <cprintf>
f011608b:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f011608e:	83 ec 0c             	sub    $0xc,%esp
f0116091:	68 90 d7 12 f0       	push   $0xf012d790
f0116096:	e8 d1 ae fe ff       	call   f0100f6c <cprintf>
f011609b:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011609e:	e8 66 79 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01160a3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01160a6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01160a9:	89 d0                	mov    %edx,%eax
f01160ab:	c1 e0 03             	shl    $0x3,%eax
f01160ae:	01 d0                	add    %edx,%eax
f01160b0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01160b7:	01 d0                	add    %edx,%eax
f01160b9:	c1 e0 03             	shl    $0x3,%eax
f01160bc:	83 ec 0c             	sub    $0xc,%esp
f01160bf:	6a 06                	push   $0x6
f01160c1:	50                   	push   %eax
f01160c2:	6a 00                	push   $0x0
f01160c4:	68 00 00 00 40       	push   $0x40000000
f01160c9:	ff 75 cc             	pushl  -0x34(%ebp)
f01160cc:	e8 33 36 ff ff       	call   f0109704 <share_chunk>
f01160d1:	83 c4 20             	add    $0x20,%esp
f01160d4:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01160d7:	e8 2d 79 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01160dc:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01160df:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f01160e3:	75 0b                	jne    f01160f0 <test_share_chunk+0x501>
f01160e5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01160e8:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01160eb:	83 f8 01             	cmp    $0x1,%eax
f01160ee:	74 28                	je     f0116118 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01160f0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01160f3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01160f6:	83 ec 0c             	sub    $0xc,%esp
f01160f9:	50                   	push   %eax
f01160fa:	ff 75 a0             	pushl  -0x60(%ebp)
f01160fd:	68 40 d7 12 f0       	push   $0xf012d740
f0116102:	68 83 04 00 00       	push   $0x483
f0116107:	68 42 c3 12 f0       	push   $0xf012c342
f011610c:	e8 a6 a3 fe ff       	call   f01004b7 <_warn>
f0116111:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116114:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116118:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011611c:	74 04                	je     f0116122 <test_share_chunk+0x533>
f011611e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116122:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0116126:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011612d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116130:	05 00 80 02 00       	add    $0x28000,%eax
f0116135:	c1 e0 02             	shl    $0x2,%eax
f0116138:	83 ec 08             	sub    $0x8,%esp
f011613b:	6a 02                	push   $0x2
f011613d:	6a 07                	push   $0x7
f011613f:	6a 03                	push   $0x3
f0116141:	6a 07                	push   $0x7
f0116143:	6a 07                	push   $0x7
f0116145:	6a ff                	push   $0xffffffff
f0116147:	50                   	push   %eax
f0116148:	6a 00                	push   $0x0
f011614a:	68 00 00 00 40       	push   $0x40000000
f011614f:	ff 75 cc             	pushl  -0x34(%ebp)
f0116152:	e8 39 29 00 00       	call   f0118a90 <CCP>
f0116157:	83 c4 30             	add    $0x30,%esp
f011615a:	85 c0                	test   %eax,%eax
f011615c:	75 25                	jne    f0116183 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011615e:	83 ec 04             	sub    $0x4,%esp
f0116161:	68 78 d6 12 f0       	push   $0xf012d678
f0116166:	68 8c 04 00 00       	push   $0x48c
f011616b:	68 42 c3 12 f0       	push   $0xf012c342
f0116170:	e8 42 a3 fe ff       	call   f01004b7 <_warn>
f0116175:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116178:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011617c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0116183:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116186:	89 d0                	mov    %edx,%eax
f0116188:	01 c0                	add    %eax,%eax
f011618a:	01 d0                	add    %edx,%eax
f011618c:	c1 e0 02             	shl    $0x2,%eax
f011618f:	83 ec 08             	sub    $0x8,%esp
f0116192:	6a 02                	push   $0x2
f0116194:	6a 07                	push   $0x7
f0116196:	6a 03                	push   $0x3
f0116198:	6a 07                	push   $0x7
f011619a:	6a 07                	push   $0x7
f011619c:	6a 03                	push   $0x3
f011619e:	50                   	push   %eax
f011619f:	6a 00                	push   $0x0
f01161a1:	68 00 00 00 40       	push   $0x40000000
f01161a6:	ff 75 cc             	pushl  -0x34(%ebp)
f01161a9:	e8 e2 28 00 00       	call   f0118a90 <CCP>
f01161ae:	83 c4 30             	add    $0x30,%esp
f01161b1:	85 c0                	test   %eax,%eax
f01161b3:	75 1e                	jne    f01161d3 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01161b5:	83 ec 04             	sub    $0x4,%esp
f01161b8:	68 78 d6 12 f0       	push   $0xf012d678
f01161bd:	68 93 04 00 00       	push   $0x493
f01161c2:	68 42 c3 12 f0       	push   $0xf012c342
f01161c7:	e8 eb a2 fe ff       	call   f01004b7 <_warn>
f01161cc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01161cf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01161d3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161d7:	74 04                	je     f01161dd <test_share_chunk+0x5ee>
f01161d9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01161dd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01161e1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01161e4:	89 d0                	mov    %edx,%eax
f01161e6:	01 c0                	add    %eax,%eax
f01161e8:	01 d0                	add    %edx,%eax
f01161ea:	c1 e0 02             	shl    $0x2,%eax
f01161ed:	f7 d8                	neg    %eax
f01161ef:	05 00 00 0a 00       	add    $0xa0000,%eax
f01161f4:	83 ec 08             	sub    $0x8,%esp
f01161f7:	6a 02                	push   $0x2
f01161f9:	6a 07                	push   $0x7
f01161fb:	6a 03                	push   $0x3
f01161fd:	6a 07                	push   $0x7
f01161ff:	6a 07                	push   $0x7
f0116201:	6a 02                	push   $0x2
f0116203:	50                   	push   %eax
f0116204:	68 00 30 00 00       	push   $0x3000
f0116209:	68 00 30 00 40       	push   $0x40003000
f011620e:	ff 75 cc             	pushl  -0x34(%ebp)
f0116211:	e8 7a 28 00 00       	call   f0118a90 <CCP>
f0116216:	83 c4 30             	add    $0x30,%esp
f0116219:	85 c0                	test   %eax,%eax
f011621b:	75 1e                	jne    f011623b <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011621d:	83 ec 04             	sub    $0x4,%esp
f0116220:	68 78 d6 12 f0       	push   $0xf012d678
f0116225:	68 9b 04 00 00       	push   $0x49b
f011622a:	68 42 c3 12 f0       	push   $0xf012c342
f011622f:	e8 83 a2 fe ff       	call   f01004b7 <_warn>
f0116234:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116237:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011623b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011623f:	74 04                	je     f0116245 <test_share_chunk+0x656>
f0116241:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116245:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0116249:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011624c:	c1 e0 02             	shl    $0x2,%eax
f011624f:	83 ec 08             	sub    $0x8,%esp
f0116252:	6a 02                	push   $0x2
f0116254:	6a 07                	push   $0x7
f0116256:	6a 03                	push   $0x3
f0116258:	6a 07                	push   $0x7
f011625a:	6a 07                	push   $0x7
f011625c:	6a 03                	push   $0x3
f011625e:	50                   	push   %eax
f011625f:	68 00 00 0a 00       	push   $0xa0000
f0116264:	68 00 00 0a 40       	push   $0x400a0000
f0116269:	ff 75 cc             	pushl  -0x34(%ebp)
f011626c:	e8 1f 28 00 00       	call   f0118a90 <CCP>
f0116271:	83 c4 30             	add    $0x30,%esp
f0116274:	85 c0                	test   %eax,%eax
f0116276:	75 1e                	jne    f0116296 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0116278:	83 ec 04             	sub    $0x4,%esp
f011627b:	68 78 d6 12 f0       	push   $0xf012d678
f0116280:	68 a3 04 00 00       	push   $0x4a3
f0116285:	68 42 c3 12 f0       	push   $0xf012c342
f011628a:	e8 28 a2 fe ff       	call   f01004b7 <_warn>
f011628f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116292:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116296:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011629a:	74 04                	je     f01162a0 <test_share_chunk+0x6b1>
f011629c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162a0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01162a4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01162a8:	0f 84 92 00 00 00    	je     f0116340 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01162ae:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f01162b5:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01162bc:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01162c3:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01162ca:	8b 45 98             	mov    -0x68(%ebp),%eax
f01162cd:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01162d0:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f01162d7:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01162de:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01162e1:	8a 00                	mov    (%eax),%al
f01162e3:	3c 41                	cmp    $0x41,%al
f01162e5:	75 2d                	jne    f0116314 <test_share_chunk+0x725>
f01162e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01162ea:	8a 00                	mov    (%eax),%al
f01162ec:	3c 41                	cmp    $0x41,%al
f01162ee:	75 24                	jne    f0116314 <test_share_chunk+0x725>
f01162f0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01162f3:	8a 00                	mov    (%eax),%al
f01162f5:	3c 41                	cmp    $0x41,%al
f01162f7:	75 1b                	jne    f0116314 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01162f9:	8b 45 98             	mov    -0x68(%ebp),%eax
f01162fc:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01162fe:	3c 44                	cmp    $0x44,%al
f0116300:	75 12                	jne    f0116314 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0116302:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116305:	8a 00                	mov    (%eax),%al
f0116307:	3c 44                	cmp    $0x44,%al
f0116309:	75 09                	jne    f0116314 <test_share_chunk+0x725>
f011630b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011630e:	8a 00                	mov    (%eax),%al
f0116310:	3c 44                	cmp    $0x44,%al
f0116312:	74 1e                	je     f0116332 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0116314:	83 ec 04             	sub    $0x4,%esp
f0116317:	68 c0 d6 12 f0       	push   $0xf012d6c0
f011631c:	68 b5 04 00 00       	push   $0x4b5
f0116321:	68 42 c3 12 f0       	push   $0xf012c342
f0116326:	e8 8c a1 fe ff       	call   f01004b7 <_warn>
f011632b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011632e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0116332:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116336:	74 04                	je     f011633c <test_share_chunk+0x74d>
f0116338:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011633c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0116340:	83 ec 0c             	sub    $0xc,%esp
f0116343:	68 32 cd 12 f0       	push   $0xf012cd32
f0116348:	e8 1f ac fe ff       	call   f0100f6c <cprintf>
f011634d:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0116350:	83 ec 0c             	sub    $0xc,%esp
f0116353:	68 cc d7 12 f0       	push   $0xf012d7cc
f0116358:	e8 0f ac fe ff       	call   f0100f6c <cprintf>
f011635d:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116360:	e8 a4 76 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116365:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0116368:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011636b:	89 d0                	mov    %edx,%eax
f011636d:	01 c0                	add    %eax,%eax
f011636f:	01 d0                	add    %edx,%eax
f0116371:	01 c0                	add    %eax,%eax
f0116373:	01 d0                	add    %edx,%eax
f0116375:	83 ec 0c             	sub    $0xc,%esp
f0116378:	6a 04                	push   $0x4
f011637a:	50                   	push   %eax
f011637b:	68 00 fc 3f 00       	push   $0x3ffc00
f0116380:	68 00 fc 09 00       	push   $0x9fc00
f0116385:	ff 75 cc             	pushl  -0x34(%ebp)
f0116388:	e8 77 33 ff ff       	call   f0109704 <share_chunk>
f011638d:	83 c4 20             	add    $0x20,%esp
f0116390:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116393:	e8 71 76 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116398:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011639b:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011639f:	75 0b                	jne    f01163ac <test_share_chunk+0x7bd>
f01163a1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01163a4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01163a7:	83 f8 01             	cmp    $0x1,%eax
f01163aa:	74 28                	je     f01163d4 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01163ac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01163af:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01163b2:	83 ec 0c             	sub    $0xc,%esp
f01163b5:	50                   	push   %eax
f01163b6:	ff 75 8c             	pushl  -0x74(%ebp)
f01163b9:	68 40 d7 12 f0       	push   $0xf012d740
f01163be:	68 cb 04 00 00       	push   $0x4cb
f01163c3:	68 42 c3 12 f0       	push   $0xf012c342
f01163c8:	e8 ea a0 fe ff       	call   f01004b7 <_warn>
f01163cd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163d0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01163d4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01163d8:	74 04                	je     f01163de <test_share_chunk+0x7ef>
f01163da:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01163de:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01163e2:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01163e9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01163ec:	89 d0                	mov    %edx,%eax
f01163ee:	01 c0                	add    %eax,%eax
f01163f0:	01 d0                	add    %edx,%eax
f01163f2:	c1 e0 02             	shl    $0x2,%eax
f01163f5:	83 ec 08             	sub    $0x8,%esp
f01163f8:	6a 02                	push   $0x2
f01163fa:	6a 07                	push   $0x7
f01163fc:	6a 07                	push   $0x7
f01163fe:	6a 07                	push   $0x7
f0116400:	6a 05                	push   $0x5
f0116402:	6a ff                	push   $0xffffffff
f0116404:	50                   	push   %eax
f0116405:	68 00 f0 3f 00       	push   $0x3ff000
f011640a:	68 00 f0 09 00       	push   $0x9f000
f011640f:	ff 75 cc             	pushl  -0x34(%ebp)
f0116412:	e8 79 26 00 00       	call   f0118a90 <CCP>
f0116417:	83 c4 30             	add    $0x30,%esp
f011641a:	85 c0                	test   %eax,%eax
f011641c:	75 25                	jne    f0116443 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011641e:	83 ec 04             	sub    $0x4,%esp
f0116421:	68 78 d6 12 f0       	push   $0xf012d678
f0116426:	68 d4 04 00 00       	push   $0x4d4
f011642b:	68 42 c3 12 f0       	push   $0xf012c342
f0116430:	e8 82 a0 fe ff       	call   f01004b7 <_warn>
f0116435:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116438:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011643c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0116443:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116447:	74 04                	je     f011644d <test_share_chunk+0x85e>
f0116449:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011644d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0116451:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116454:	c1 e0 02             	shl    $0x2,%eax
f0116457:	83 ec 08             	sub    $0x8,%esp
f011645a:	6a 02                	push   $0x2
f011645c:	6a 07                	push   $0x7
f011645e:	6a 07                	push   $0x7
f0116460:	6a 07                	push   $0x7
f0116462:	6a 05                	push   $0x5
f0116464:	6a 03                	push   $0x3
f0116466:	50                   	push   %eax
f0116467:	68 00 f0 3f 00       	push   $0x3ff000
f011646c:	68 00 f0 09 00       	push   $0x9f000
f0116471:	ff 75 cc             	pushl  -0x34(%ebp)
f0116474:	e8 17 26 00 00       	call   f0118a90 <CCP>
f0116479:	83 c4 30             	add    $0x30,%esp
f011647c:	85 c0                	test   %eax,%eax
f011647e:	75 1e                	jne    f011649e <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0116480:	83 ec 04             	sub    $0x4,%esp
f0116483:	68 78 d6 12 f0       	push   $0xf012d678
f0116488:	68 dd 04 00 00       	push   $0x4dd
f011648d:	68 42 c3 12 f0       	push   $0xf012c342
f0116492:	e8 20 a0 fe ff       	call   f01004b7 <_warn>
f0116497:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011649a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011649e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164a2:	74 04                	je     f01164a8 <test_share_chunk+0x8b9>
f01164a4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01164a8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01164ac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01164af:	c1 e0 03             	shl    $0x3,%eax
f01164b2:	83 ec 08             	sub    $0x8,%esp
f01164b5:	6a 02                	push   $0x2
f01164b7:	6a 07                	push   $0x7
f01164b9:	6a 07                	push   $0x7
f01164bb:	6a 07                	push   $0x7
f01164bd:	6a 05                	push   $0x5
f01164bf:	6a 04                	push   $0x4
f01164c1:	50                   	push   %eax
f01164c2:	68 00 00 40 00       	push   $0x400000
f01164c7:	68 00 00 0a 00       	push   $0xa0000
f01164cc:	ff 75 cc             	pushl  -0x34(%ebp)
f01164cf:	e8 bc 25 00 00       	call   f0118a90 <CCP>
f01164d4:	83 c4 30             	add    $0x30,%esp
f01164d7:	85 c0                	test   %eax,%eax
f01164d9:	75 1e                	jne    f01164f9 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01164db:	83 ec 04             	sub    $0x4,%esp
f01164de:	68 78 d6 12 f0       	push   $0xf012d678
f01164e3:	68 e5 04 00 00       	push   $0x4e5
f01164e8:	68 42 c3 12 f0       	push   $0xf012c342
f01164ed:	e8 c5 9f fe ff       	call   f01004b7 <_warn>
f01164f2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01164f5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01164f9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164fd:	74 04                	je     f0116503 <test_share_chunk+0x914>
f01164ff:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116503:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0116507:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011650b:	0f 84 b2 00 00 00    	je     f01165c3 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0116511:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0116518:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f011651f:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0116526:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f011652d:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0116534:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f011653b:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0116542:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0116549:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011654c:	8a 00                	mov    (%eax),%al
f011654e:	3c 44                	cmp    $0x44,%al
f0116550:	75 45                	jne    f0116597 <test_share_chunk+0x9a8>
f0116552:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116555:	8a 00                	mov    (%eax),%al
f0116557:	3c 44                	cmp    $0x44,%al
f0116559:	75 3c                	jne    f0116597 <test_share_chunk+0x9a8>
f011655b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011655e:	8a 00                	mov    (%eax),%al
f0116560:	3c 44                	cmp    $0x44,%al
f0116562:	75 33                	jne    f0116597 <test_share_chunk+0x9a8>
f0116564:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116567:	8a 00                	mov    (%eax),%al
f0116569:	3c 44                	cmp    $0x44,%al
f011656b:	75 2a                	jne    f0116597 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011656d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116570:	8a 10                	mov    (%eax),%dl
f0116572:	8b 45 90             	mov    -0x70(%ebp),%eax
f0116575:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0116577:	38 c2                	cmp    %al,%dl
f0116579:	75 1c                	jne    f0116597 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011657b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011657e:	8a 10                	mov    (%eax),%dl
f0116580:	8b 45 88             	mov    -0x78(%ebp),%eax
f0116583:	8a 00                	mov    (%eax),%al
f0116585:	38 c2                	cmp    %al,%dl
f0116587:	75 0e                	jne    f0116597 <test_share_chunk+0x9a8>
f0116589:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011658c:	8a 10                	mov    (%eax),%dl
f011658e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0116591:	8a 00                	mov    (%eax),%al
f0116593:	38 c2                	cmp    %al,%dl
f0116595:	74 1e                	je     f01165b5 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0116597:	83 ec 04             	sub    $0x4,%esp
f011659a:	68 c0 d6 12 f0       	push   $0xf012d6c0
f011659f:	68 fa 04 00 00       	push   $0x4fa
f01165a4:	68 42 c3 12 f0       	push   $0xf012c342
f01165a9:	e8 09 9f fe ff       	call   f01004b7 <_warn>
f01165ae:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01165b1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01165b5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01165b9:	74 04                	je     f01165bf <test_share_chunk+0x9d0>
f01165bb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01165bf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f01165c3:	83 ec 0c             	sub    $0xc,%esp
f01165c6:	68 04 d8 12 f0       	push   $0xf012d804
f01165cb:	e8 9c a9 fe ff       	call   f0100f6c <cprintf>
f01165d0:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f01165d3:	83 ec 08             	sub    $0x8,%esp
f01165d6:	ff 75 e4             	pushl  -0x1c(%ebp)
f01165d9:	68 14 d8 12 f0       	push   $0xf012d814
f01165de:	e8 89 a9 fe ff       	call   f0100f6c <cprintf>
f01165e3:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01165e6:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01165ea:	75 10                	jne    f01165fc <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01165ec:	83 ec 0c             	sub    $0xc,%esp
f01165ef:	68 44 d8 12 f0       	push   $0xf012d844
f01165f4:	e8 73 a9 fe ff       	call   f0100f6c <cprintf>
f01165f9:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01165fc:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f0116601:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0116604:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116607:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011660a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011660f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116612:	5b                   	pop    %ebx
f0116613:	5e                   	pop    %esi
f0116614:	5f                   	pop    %edi
f0116615:	5d                   	pop    %ebp
f0116616:	c3                   	ret    

f0116617 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0116617:	55                   	push   %ebp
f0116618:	89 e5                	mov    %esp,%ebp
f011661a:	57                   	push   %edi
f011661b:	56                   	push   %esi
f011661c:	53                   	push   %ebx
f011661d:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0116623:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0116629:	bb 44 ca 12 f0       	mov    $0xf012ca44,%ebx
f011662e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116633:	89 c7                	mov    %eax,%edi
f0116635:	89 de                	mov    %ebx,%esi
f0116637:	89 d1                	mov    %edx,%ecx
f0116639:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011663b:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0116641:	b9 23 00 00 00       	mov    $0x23,%ecx
f0116646:	b0 00                	mov    $0x0,%al
f0116648:	89 d7                	mov    %edx,%edi
f011664a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011664c:	6a 00                	push   $0x0
f011664e:	6a 0a                	push   $0xa
f0116650:	6a 14                	push   $0x14
f0116652:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0116658:	50                   	push   %eax
f0116659:	e8 12 34 ff ff       	call   f0109a70 <env_create>
f011665e:	83 c4 10             	add    $0x10,%esp
f0116661:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116664:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116667:	8b 40 64             	mov    0x64(%eax),%eax
f011666a:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f011666d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116670:	8b 40 68             	mov    0x68(%eax),%eax
f0116673:	89 45 90             	mov    %eax,-0x70(%ebp)
f0116676:	8b 45 90             	mov    -0x70(%ebp),%eax
f0116679:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f011667c:	83 ec 0c             	sub    $0xc,%esp
f011667f:	ff 75 cc             	pushl  -0x34(%ebp)
f0116682:	e8 d5 23 00 00       	call   f0118a5c <ClearUserSpace>
f0116687:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011668a:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0116691:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0116698:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011669f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f01166a3:	83 ec 0c             	sub    $0xc,%esp
f01166a6:	68 80 d8 12 f0       	push   $0xf012d880
f01166ab:	e8 bc a8 fe ff       	call   f0100f6c <cprintf>
f01166b0:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f01166b3:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f01166ba:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f01166c1:	eb 03                	jmp    f01166c6 <test_allocate_chunk+0xaf>
f01166c3:	ff 4d e4             	decl   -0x1c(%ebp)
f01166c6:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01166cd:	76 09                	jbe    f01166d8 <test_allocate_chunk+0xc1>
f01166cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01166d2:	8a 00                	mov    (%eax),%al
f01166d4:	84 c0                	test   %al,%al
f01166d6:	74 eb                	je     f01166c3 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f01166d8:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01166df:	75 06                	jne    f01166e7 <test_allocate_chunk+0xd0>
f01166e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01166e4:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01166e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01166ea:	8a 00                	mov    (%eax),%al
f01166ec:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01166f2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01166f5:	8a 00                	mov    (%eax),%al
f01166f7:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f01166fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116700:	8a 00                	mov    (%eax),%al
f0116702:	0f be c0             	movsbl %al,%eax
f0116705:	83 ec 08             	sub    $0x8,%esp
f0116708:	50                   	push   %eax
f0116709:	68 aa d8 12 f0       	push   $0xf012d8aa
f011670e:	e8 59 a8 fe ff       	call   f0100f6c <cprintf>
f0116713:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0116716:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116719:	8a 00                	mov    (%eax),%al
f011671b:	0f be c0             	movsbl %al,%eax
f011671e:	83 ec 08             	sub    $0x8,%esp
f0116721:	50                   	push   %eax
f0116722:	68 b6 d8 12 f0       	push   $0xf012d8b6
f0116727:	e8 40 a8 fe ff       	call   f0100f6c <cprintf>
f011672c:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f011672f:	83 ec 08             	sub    $0x8,%esp
f0116732:	68 00 f0 bf ef       	push   $0xefbff000
f0116737:	ff 75 cc             	pushl  -0x34(%ebp)
f011673a:	e8 84 22 00 00       	call   f01189c3 <GP>
f011673f:	83 c4 10             	add    $0x10,%esp
f0116742:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116745:	e8 bf 72 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011674a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f011674d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116750:	c1 e0 02             	shl    $0x2,%eax
f0116753:	6a 02                	push   $0x2
f0116755:	50                   	push   %eax
f0116756:	68 00 f0 bf ef       	push   $0xefbff000
f011675b:	ff 75 cc             	pushl  -0x34(%ebp)
f011675e:	e8 bb 2f ff ff       	call   f010971e <allocate_chunk>
f0116763:	83 c4 10             	add    $0x10,%esp
f0116766:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116769:	e8 9b 72 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011676e:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0116771:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0116775:	75 08                	jne    f011677f <test_allocate_chunk+0x168>
f0116777:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011677a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011677d:	74 2a                	je     f01167a9 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011677f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116782:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116785:	83 ec 08             	sub    $0x8,%esp
f0116788:	6a 00                	push   $0x0
f011678a:	50                   	push   %eax
f011678b:	ff 75 b0             	pushl  -0x50(%ebp)
f011678e:	68 c4 d8 12 f0       	push   $0xf012d8c4
f0116793:	68 3a 05 00 00       	push   $0x53a
f0116798:	68 42 c3 12 f0       	push   $0xf012c342
f011679d:	e8 15 9d fe ff       	call   f01004b7 <_warn>
f01167a2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01167a5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01167a9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01167ad:	74 04                	je     f01167b3 <test_allocate_chunk+0x19c>
f01167af:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01167b3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01167b7:	e8 4d 72 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01167bc:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f01167bf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01167c2:	01 c0                	add    %eax,%eax
f01167c4:	89 c1                	mov    %eax,%ecx
f01167c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01167c9:	89 d0                	mov    %edx,%eax
f01167cb:	c1 e0 02             	shl    $0x2,%eax
f01167ce:	01 d0                	add    %edx,%eax
f01167d0:	f7 d8                	neg    %eax
f01167d2:	2d 00 00 40 10       	sub    $0x10400000,%eax
f01167d7:	6a 02                	push   $0x2
f01167d9:	51                   	push   %ecx
f01167da:	50                   	push   %eax
f01167db:	ff 75 cc             	pushl  -0x34(%ebp)
f01167de:	e8 3b 2f ff ff       	call   f010971e <allocate_chunk>
f01167e3:	83 c4 10             	add    $0x10,%esp
f01167e6:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01167e9:	e8 1b 72 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01167ee:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01167f1:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01167f5:	75 08                	jne    f01167ff <test_allocate_chunk+0x1e8>
f01167f7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01167fa:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01167fd:	74 2a                	je     f0116829 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01167ff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116802:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116805:	83 ec 08             	sub    $0x8,%esp
f0116808:	6a 00                	push   $0x0
f011680a:	50                   	push   %eax
f011680b:	ff 75 b0             	pushl  -0x50(%ebp)
f011680e:	68 c4 d8 12 f0       	push   $0xf012d8c4
f0116813:	68 48 05 00 00       	push   $0x548
f0116818:	68 42 c3 12 f0       	push   $0xf012c342
f011681d:	e8 95 9c fe ff       	call   f01004b7 <_warn>
f0116822:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116825:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0116829:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011682d:	74 04                	je     f0116833 <test_allocate_chunk+0x21c>
f011682f:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116833:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0116837:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011683a:	c1 e0 02             	shl    $0x2,%eax
f011683d:	83 ec 08             	sub    $0x8,%esp
f0116840:	6a 03                	push   $0x3
f0116842:	6a 00                	push   $0x0
f0116844:	6a 00                	push   $0x0
f0116846:	68 ff 0f 00 00       	push   $0xfff
f011684b:	ff 75 b8             	pushl  -0x48(%ebp)
f011684e:	6a 01                	push   $0x1
f0116850:	50                   	push   %eax
f0116851:	68 00 f0 bf ef       	push   $0xefbff000
f0116856:	6a 00                	push   $0x0
f0116858:	ff 75 cc             	pushl  -0x34(%ebp)
f011685b:	e8 30 22 00 00       	call   f0118a90 <CCP>
f0116860:	83 c4 30             	add    $0x30,%esp
f0116863:	85 c0                	test   %eax,%eax
f0116865:	75 1e                	jne    f0116885 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116867:	83 ec 04             	sub    $0x4,%esp
f011686a:	68 2c d9 12 f0       	push   $0xf012d92c
f011686f:	68 50 05 00 00       	push   $0x550
f0116874:	68 42 c3 12 f0       	push   $0xf012c342
f0116879:	e8 39 9c fe ff       	call   f01004b7 <_warn>
f011687e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116881:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0116885:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116889:	74 04                	je     f011688f <test_allocate_chunk+0x278>
f011688b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011688f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0116893:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116896:	8a 10                	mov    (%eax),%dl
f0116898:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f011689e:	38 c2                	cmp    %al,%dl
f01168a0:	75 0f                	jne    f01168b1 <test_allocate_chunk+0x29a>
f01168a2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01168a5:	8a 10                	mov    (%eax),%dl
f01168a7:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f01168ad:	38 c2                	cmp    %al,%dl
f01168af:	74 1e                	je     f01168cf <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01168b1:	83 ec 04             	sub    $0x4,%esp
f01168b4:	68 78 d9 12 f0       	push   $0xf012d978
f01168b9:	68 58 05 00 00       	push   $0x558
f01168be:	68 42 c3 12 f0       	push   $0xf012c342
f01168c3:	e8 ef 9b fe ff       	call   f01004b7 <_warn>
f01168c8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01168cb:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01168cf:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01168d3:	74 04                	je     f01168d9 <test_allocate_chunk+0x2c2>
f01168d5:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01168d9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01168dd:	83 ec 0c             	sub    $0xc,%esp
f01168e0:	68 f5 d6 12 f0       	push   $0xf012d6f5
f01168e5:	e8 82 a6 fe ff       	call   f0100f6c <cprintf>
f01168ea:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f01168ed:	83 ec 0c             	sub    $0xc,%esp
f01168f0:	68 b0 d9 12 f0       	push   $0xf012d9b0
f01168f5:	e8 72 a6 fe ff       	call   f0100f6c <cprintf>
f01168fa:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01168fd:	e8 07 71 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116902:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0116905:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116908:	c1 e0 05             	shl    $0x5,%eax
f011690b:	68 02 0e 00 00       	push   $0xe02
f0116910:	50                   	push   %eax
f0116911:	6a 00                	push   $0x0
f0116913:	ff 75 cc             	pushl  -0x34(%ebp)
f0116916:	e8 03 2e ff ff       	call   f010971e <allocate_chunk>
f011691b:	83 c4 10             	add    $0x10,%esp
f011691e:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116921:	e8 e3 70 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116926:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0116929:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011692d:	75 36                	jne    f0116965 <test_allocate_chunk+0x34e>
f011692f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116932:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116935:	89 c1                	mov    %eax,%ecx
f0116937:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011693a:	c1 e0 05             	shl    $0x5,%eax
f011693d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116940:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116947:	99                   	cltd   
f0116948:	f7 fe                	idiv   %esi
f011694a:	89 c3                	mov    %eax,%ebx
f011694c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011694f:	c1 e0 05             	shl    $0x5,%eax
f0116952:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116955:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011695c:	99                   	cltd   
f011695d:	f7 fe                	idiv   %esi
f011695f:	01 d8                	add    %ebx,%eax
f0116961:	39 c1                	cmp    %eax,%ecx
f0116963:	74 54                	je     f01169b9 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0116965:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116968:	c1 e0 05             	shl    $0x5,%eax
f011696b:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011696e:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116975:	99                   	cltd   
f0116976:	f7 ff                	idiv   %edi
f0116978:	89 c1                	mov    %eax,%ecx
f011697a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011697d:	c1 e0 05             	shl    $0x5,%eax
f0116980:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116983:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011698a:	99                   	cltd   
f011698b:	f7 fe                	idiv   %esi
f011698d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0116990:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116993:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116996:	83 ec 08             	sub    $0x8,%esp
f0116999:	52                   	push   %edx
f011699a:	50                   	push   %eax
f011699b:	ff 75 a8             	pushl  -0x58(%ebp)
f011699e:	68 f0 d9 12 f0       	push   $0xf012d9f0
f01169a3:	68 6d 05 00 00       	push   $0x56d
f01169a8:	68 42 c3 12 f0       	push   $0xf012c342
f01169ad:	e8 05 9b fe ff       	call   f01004b7 <_warn>
f01169b2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169b5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01169b9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01169bd:	74 04                	je     f01169c3 <test_allocate_chunk+0x3ac>
f01169bf:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01169c3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01169c7:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01169ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169d1:	c1 e0 05             	shl    $0x5,%eax
f01169d4:	83 ec 08             	sub    $0x8,%esp
f01169d7:	6a 03                	push   $0x3
f01169d9:	6a 00                	push   $0x0
f01169db:	6a 00                	push   $0x0
f01169dd:	68 07 0e 00 00       	push   $0xe07
f01169e2:	68 03 0e 00 00       	push   $0xe03
f01169e7:	6a 01                	push   $0x1
f01169e9:	50                   	push   %eax
f01169ea:	6a 00                	push   $0x0
f01169ec:	6a 00                	push   $0x0
f01169ee:	ff 75 cc             	pushl  -0x34(%ebp)
f01169f1:	e8 9a 20 00 00       	call   f0118a90 <CCP>
f01169f6:	83 c4 30             	add    $0x30,%esp
f01169f9:	85 c0                	test   %eax,%eax
f01169fb:	75 25                	jne    f0116a22 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01169fd:	83 ec 04             	sub    $0x4,%esp
f0116a00:	68 2c d9 12 f0       	push   $0xf012d92c
f0116a05:	68 76 05 00 00       	push   $0x576
f0116a0a:	68 42 c3 12 f0       	push   $0xf012c342
f0116a0f:	e8 a3 9a fe ff       	call   f01004b7 <_warn>
f0116a14:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116a17:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116a1b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0116a22:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116a26:	74 04                	je     f0116a2c <test_allocate_chunk+0x415>
f0116a28:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116a2c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0116a30:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0116a34:	74 5a                	je     f0116a90 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0116a36:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116a39:	01 c0                	add    %eax,%eax
f0116a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0116a3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116a41:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0116a44:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116a47:	01 c0                	add    %eax,%eax
f0116a49:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0116a4c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116a4f:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0116a52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116a55:	8a 00                	mov    (%eax),%al
f0116a57:	3c 4b                	cmp    $0x4b,%al
f0116a59:	75 09                	jne    f0116a64 <test_allocate_chunk+0x44d>
f0116a5b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116a5e:	8a 00                	mov    (%eax),%al
f0116a60:	3c 4d                	cmp    $0x4d,%al
f0116a62:	74 1e                	je     f0116a82 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0116a64:	83 ec 04             	sub    $0x4,%esp
f0116a67:	68 78 d9 12 f0       	push   $0xf012d978
f0116a6c:	68 84 05 00 00       	push   $0x584
f0116a71:	68 42 c3 12 f0       	push   $0xf012c342
f0116a76:	e8 3c 9a fe ff       	call   f01004b7 <_warn>
f0116a7b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0116a7e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0116a82:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116a86:	74 04                	je     f0116a8c <test_allocate_chunk+0x475>
f0116a88:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0116a8c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0116a90:	83 ec 0c             	sub    $0xc,%esp
f0116a93:	68 cf cc 12 f0       	push   $0xf012cccf
f0116a98:	e8 cf a4 fe ff       	call   f0100f6c <cprintf>
f0116a9d:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0116aa0:	83 ec 0c             	sub    $0xc,%esp
f0116aa3:	68 50 da 12 f0       	push   $0xf012da50
f0116aa8:	e8 bf a4 fe ff       	call   f0100f6c <cprintf>
f0116aad:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116ab0:	e8 54 6f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116ab5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0116ab8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116abb:	c1 e0 06             	shl    $0x6,%eax
f0116abe:	89 c2                	mov    %eax,%edx
f0116ac0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ac3:	c1 e0 05             	shl    $0x5,%eax
f0116ac6:	6a 00                	push   $0x0
f0116ac8:	52                   	push   %edx
f0116ac9:	50                   	push   %eax
f0116aca:	ff 75 cc             	pushl  -0x34(%ebp)
f0116acd:	e8 4c 2c ff ff       	call   f010971e <allocate_chunk>
f0116ad2:	83 c4 10             	add    $0x10,%esp
f0116ad5:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116ad8:	e8 2c 6f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116add:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0116ae0:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0116ae4:	75 36                	jne    f0116b1c <test_allocate_chunk+0x505>
f0116ae6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116ae9:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116aec:	89 c1                	mov    %eax,%ecx
f0116aee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116af1:	c1 e0 06             	shl    $0x6,%eax
f0116af4:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116af7:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116afe:	99                   	cltd   
f0116aff:	f7 ff                	idiv   %edi
f0116b01:	89 c3                	mov    %eax,%ebx
f0116b03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b06:	c1 e0 06             	shl    $0x6,%eax
f0116b09:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116b0c:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116b13:	99                   	cltd   
f0116b14:	f7 fe                	idiv   %esi
f0116b16:	01 d8                	add    %ebx,%eax
f0116b18:	39 c1                	cmp    %eax,%ecx
f0116b1a:	74 54                	je     f0116b70 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0116b1c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b1f:	c1 e0 06             	shl    $0x6,%eax
f0116b22:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116b25:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116b2c:	99                   	cltd   
f0116b2d:	f7 fb                	idiv   %ebx
f0116b2f:	89 c1                	mov    %eax,%ecx
f0116b31:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b34:	c1 e0 06             	shl    $0x6,%eax
f0116b37:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116b3a:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116b41:	99                   	cltd   
f0116b42:	f7 ff                	idiv   %edi
f0116b44:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0116b47:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116b4a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116b4d:	83 ec 08             	sub    $0x8,%esp
f0116b50:	52                   	push   %edx
f0116b51:	50                   	push   %eax
f0116b52:	ff 75 a4             	pushl  -0x5c(%ebp)
f0116b55:	68 f0 d9 12 f0       	push   $0xf012d9f0
f0116b5a:	68 9a 05 00 00       	push   $0x59a
f0116b5f:	68 42 c3 12 f0       	push   $0xf012c342
f0116b64:	e8 4e 99 fe ff       	call   f01004b7 <_warn>
f0116b69:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b6c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0116b70:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116b74:	74 04                	je     f0116b7a <test_allocate_chunk+0x563>
f0116b76:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0116b7a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0116b7e:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0116b85:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b88:	c1 e0 06             	shl    $0x6,%eax
f0116b8b:	89 c2                	mov    %eax,%edx
f0116b8d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b90:	c1 e0 05             	shl    $0x5,%eax
f0116b93:	83 ec 08             	sub    $0x8,%esp
f0116b96:	6a 03                	push   $0x3
f0116b98:	6a 00                	push   $0x0
f0116b9a:	6a 00                	push   $0x0
f0116b9c:	68 07 0e 00 00       	push   $0xe07
f0116ba1:	6a 01                	push   $0x1
f0116ba3:	6a 01                	push   $0x1
f0116ba5:	52                   	push   %edx
f0116ba6:	50                   	push   %eax
f0116ba7:	6a 00                	push   $0x0
f0116ba9:	ff 75 cc             	pushl  -0x34(%ebp)
f0116bac:	e8 df 1e 00 00       	call   f0118a90 <CCP>
f0116bb1:	83 c4 30             	add    $0x30,%esp
f0116bb4:	85 c0                	test   %eax,%eax
f0116bb6:	75 25                	jne    f0116bdd <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116bb8:	83 ec 04             	sub    $0x4,%esp
f0116bbb:	68 2c d9 12 f0       	push   $0xf012d92c
f0116bc0:	68 a3 05 00 00       	push   $0x5a3
f0116bc5:	68 42 c3 12 f0       	push   $0xf012c342
f0116bca:	e8 e8 98 fe ff       	call   f01004b7 <_warn>
f0116bcf:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116bd2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116bd6:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0116bdd:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116be1:	74 04                	je     f0116be7 <test_allocate_chunk+0x5d0>
f0116be3:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116be7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0116beb:	83 ec 0c             	sub    $0xc,%esp
f0116bee:	68 32 cd 12 f0       	push   $0xf012cd32
f0116bf3:	e8 74 a3 fe ff       	call   f0100f6c <cprintf>
f0116bf8:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0116bfb:	83 ec 0c             	sub    $0xc,%esp
f0116bfe:	68 90 da 12 f0       	push   $0xf012da90
f0116c03:	e8 64 a3 fe ff       	call   f0100f6c <cprintf>
f0116c08:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116c0b:	e8 f9 6d ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116c10:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0116c13:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116c16:	c1 e0 06             	shl    $0x6,%eax
f0116c19:	68 06 0e 00 00       	push   $0xe06
f0116c1e:	50                   	push   %eax
f0116c1f:	68 00 00 00 80       	push   $0x80000000
f0116c24:	ff 75 cc             	pushl  -0x34(%ebp)
f0116c27:	e8 f2 2a ff ff       	call   f010971e <allocate_chunk>
f0116c2c:	83 c4 10             	add    $0x10,%esp
f0116c2f:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116c32:	e8 d2 6d ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116c37:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0116c3a:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0116c3e:	75 36                	jne    f0116c76 <test_allocate_chunk+0x65f>
f0116c40:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116c43:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116c46:	89 c1                	mov    %eax,%ecx
f0116c48:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116c4b:	c1 e0 06             	shl    $0x6,%eax
f0116c4e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116c51:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116c58:	99                   	cltd   
f0116c59:	f7 fb                	idiv   %ebx
f0116c5b:	89 c3                	mov    %eax,%ebx
f0116c5d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116c60:	c1 e0 06             	shl    $0x6,%eax
f0116c63:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116c66:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116c6d:	99                   	cltd   
f0116c6e:	f7 fe                	idiv   %esi
f0116c70:	01 d8                	add    %ebx,%eax
f0116c72:	39 c1                	cmp    %eax,%ecx
f0116c74:	74 54                	je     f0116cca <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0116c76:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116c79:	c1 e0 06             	shl    $0x6,%eax
f0116c7c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116c7f:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116c86:	99                   	cltd   
f0116c87:	f7 ff                	idiv   %edi
f0116c89:	89 c1                	mov    %eax,%ecx
f0116c8b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116c8e:	c1 e0 06             	shl    $0x6,%eax
f0116c91:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116c94:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116c9b:	99                   	cltd   
f0116c9c:	f7 fb                	idiv   %ebx
f0116c9e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0116ca1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116ca4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116ca7:	83 ec 08             	sub    $0x8,%esp
f0116caa:	52                   	push   %edx
f0116cab:	50                   	push   %eax
f0116cac:	ff 75 9c             	pushl  -0x64(%ebp)
f0116caf:	68 f0 d9 12 f0       	push   $0xf012d9f0
f0116cb4:	68 b9 05 00 00       	push   $0x5b9
f0116cb9:	68 42 c3 12 f0       	push   $0xf012c342
f0116cbe:	e8 f4 97 fe ff       	call   f01004b7 <_warn>
f0116cc3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116cc6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0116cca:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116cce:	74 04                	je     f0116cd4 <test_allocate_chunk+0x6bd>
f0116cd0:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0116cd4:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0116cd8:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0116cdf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ce2:	c1 e0 06             	shl    $0x6,%eax
f0116ce5:	83 ec 08             	sub    $0x8,%esp
f0116ce8:	6a 03                	push   $0x3
f0116cea:	6a 00                	push   $0x0
f0116cec:	6a 00                	push   $0x0
f0116cee:	68 07 0e 00 00       	push   $0xe07
f0116cf3:	68 07 0e 00 00       	push   $0xe07
f0116cf8:	6a 01                	push   $0x1
f0116cfa:	50                   	push   %eax
f0116cfb:	68 00 00 00 80       	push   $0x80000000
f0116d00:	6a 00                	push   $0x0
f0116d02:	ff 75 cc             	pushl  -0x34(%ebp)
f0116d05:	e8 86 1d 00 00       	call   f0118a90 <CCP>
f0116d0a:	83 c4 30             	add    $0x30,%esp
f0116d0d:	85 c0                	test   %eax,%eax
f0116d0f:	75 25                	jne    f0116d36 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116d11:	83 ec 04             	sub    $0x4,%esp
f0116d14:	68 2c d9 12 f0       	push   $0xf012d92c
f0116d19:	68 c2 05 00 00       	push   $0x5c2
f0116d1e:	68 42 c3 12 f0       	push   $0xf012c342
f0116d23:	e8 8f 97 fe ff       	call   f01004b7 <_warn>
f0116d28:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116d2b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116d2f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0116d36:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116d3a:	74 04                	je     f0116d40 <test_allocate_chunk+0x729>
f0116d3c:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116d40:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0116d44:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0116d48:	74 6f                	je     f0116db9 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0116d4a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116d4d:	01 c0                	add    %eax,%eax
f0116d4f:	05 00 00 00 80       	add    $0x80000000,%eax
f0116d54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0116d57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116d5a:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0116d5d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116d60:	89 d0                	mov    %edx,%eax
f0116d62:	c1 e0 02             	shl    $0x2,%eax
f0116d65:	01 d0                	add    %edx,%eax
f0116d67:	01 c0                	add    %eax,%eax
f0116d69:	01 d0                	add    %edx,%eax
f0116d6b:	01 c0                	add    %eax,%eax
f0116d6d:	05 00 00 00 80       	add    $0x80000000,%eax
f0116d72:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0116d75:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116d78:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0116d7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116d7e:	8a 00                	mov    (%eax),%al
f0116d80:	3c 4b                	cmp    $0x4b,%al
f0116d82:	75 09                	jne    f0116d8d <test_allocate_chunk+0x776>
f0116d84:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116d87:	8a 00                	mov    (%eax),%al
f0116d89:	3c 4d                	cmp    $0x4d,%al
f0116d8b:	74 1e                	je     f0116dab <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0116d8d:	83 ec 04             	sub    $0x4,%esp
f0116d90:	68 78 d9 12 f0       	push   $0xf012d978
f0116d95:	68 d0 05 00 00       	push   $0x5d0
f0116d9a:	68 42 c3 12 f0       	push   $0xf012c342
f0116d9f:	e8 13 97 fe ff       	call   f01004b7 <_warn>
f0116da4:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0116da7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0116dab:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116daf:	74 04                	je     f0116db5 <test_allocate_chunk+0x79e>
f0116db1:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0116db5:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0116db9:	83 ec 0c             	sub    $0xc,%esp
f0116dbc:	68 04 d8 12 f0       	push   $0xf012d804
f0116dc1:	e8 a6 a1 fe ff       	call   f0100f6c <cprintf>
f0116dc6:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0116dc9:	83 ec 0c             	sub    $0xc,%esp
f0116dcc:	68 cc da 12 f0       	push   $0xf012dacc
f0116dd1:	e8 96 a1 fe ff       	call   f0100f6c <cprintf>
f0116dd6:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116dd9:	e8 2b 6c ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116dde:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0116de1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116de4:	89 d0                	mov    %edx,%eax
f0116de6:	01 c0                	add    %eax,%eax
f0116de8:	01 d0                	add    %edx,%eax
f0116dea:	01 c0                	add    %eax,%eax
f0116dec:	01 d0                	add    %edx,%eax
f0116dee:	68 04 0e 00 00       	push   $0xe04
f0116df3:	50                   	push   %eax
f0116df4:	68 00 fc 3f 40       	push   $0x403ffc00
f0116df9:	ff 75 cc             	pushl  -0x34(%ebp)
f0116dfc:	e8 1d 29 ff ff       	call   f010971e <allocate_chunk>
f0116e01:	83 c4 10             	add    $0x10,%esp
f0116e04:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116e07:	e8 fd 6b ff ff       	call   f010da09 <sys_calculate_free_frames>
f0116e0c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0116e0f:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0116e13:	75 0b                	jne    f0116e20 <test_allocate_chunk+0x809>
f0116e15:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116e18:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116e1b:	83 f8 05             	cmp    $0x5,%eax
f0116e1e:	74 2a                	je     f0116e4a <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0116e20:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116e23:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116e26:	83 ec 08             	sub    $0x8,%esp
f0116e29:	6a 05                	push   $0x5
f0116e2b:	50                   	push   %eax
f0116e2c:	ff 75 98             	pushl  -0x68(%ebp)
f0116e2f:	68 f0 d9 12 f0       	push   $0xf012d9f0
f0116e34:	68 e7 05 00 00       	push   $0x5e7
f0116e39:	68 42 c3 12 f0       	push   $0xf012c342
f0116e3e:	e8 74 96 fe ff       	call   f01004b7 <_warn>
f0116e43:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116e46:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0116e4a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116e4e:	74 04                	je     f0116e54 <test_allocate_chunk+0x83d>
f0116e50:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116e54:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0116e58:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0116e5f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116e62:	89 d0                	mov    %edx,%eax
f0116e64:	01 c0                	add    %eax,%eax
f0116e66:	01 d0                	add    %edx,%eax
f0116e68:	c1 e0 02             	shl    $0x2,%eax
f0116e6b:	83 ec 08             	sub    $0x8,%esp
f0116e6e:	6a 03                	push   $0x3
f0116e70:	6a 00                	push   $0x0
f0116e72:	6a 00                	push   $0x0
f0116e74:	68 07 0e 00 00       	push   $0xe07
f0116e79:	68 05 0e 00 00       	push   $0xe05
f0116e7e:	6a 01                	push   $0x1
f0116e80:	50                   	push   %eax
f0116e81:	68 00 f0 3f 40       	push   $0x403ff000
f0116e86:	6a 00                	push   $0x0
f0116e88:	ff 75 cc             	pushl  -0x34(%ebp)
f0116e8b:	e8 00 1c 00 00       	call   f0118a90 <CCP>
f0116e90:	83 c4 30             	add    $0x30,%esp
f0116e93:	85 c0                	test   %eax,%eax
f0116e95:	75 25                	jne    f0116ebc <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116e97:	83 ec 04             	sub    $0x4,%esp
f0116e9a:	68 2c d9 12 f0       	push   $0xf012d92c
f0116e9f:	68 f0 05 00 00       	push   $0x5f0
f0116ea4:	68 42 c3 12 f0       	push   $0xf012c342
f0116ea9:	e8 09 96 fe ff       	call   f01004b7 <_warn>
f0116eae:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116eb1:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116eb5:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0116ebc:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116ec0:	74 04                	je     f0116ec6 <test_allocate_chunk+0x8af>
f0116ec2:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0116ec6:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0116eca:	83 ec 0c             	sub    $0xc,%esp
f0116ecd:	68 03 db 12 f0       	push   $0xf012db03
f0116ed2:	e8 95 a0 fe ff       	call   f0100f6c <cprintf>
f0116ed7:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0116eda:	83 ec 08             	sub    $0x8,%esp
f0116edd:	ff 75 e0             	pushl  -0x20(%ebp)
f0116ee0:	68 14 db 12 f0       	push   $0xf012db14
f0116ee5:	e8 82 a0 fe ff       	call   f0100f6c <cprintf>
f0116eea:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116eed:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0116ef1:	75 10                	jne    f0116f03 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0116ef3:	83 ec 0c             	sub    $0xc,%esp
f0116ef6:	68 48 db 12 f0       	push   $0xf012db48
f0116efb:	e8 6c a0 fe ff       	call   f0100f6c <cprintf>
f0116f00:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116f03:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f0116f08:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0116f0b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116f0e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116f11:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116f16:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116f19:	5b                   	pop    %ebx
f0116f1a:	5e                   	pop    %esi
f0116f1b:	5f                   	pop    %edi
f0116f1c:	5d                   	pop    %ebp
f0116f1d:	c3                   	ret    

f0116f1e <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0116f1e:	55                   	push   %ebp
f0116f1f:	89 e5                	mov    %esp,%ebp
f0116f21:	57                   	push   %edi
f0116f22:	56                   	push   %esi
f0116f23:	53                   	push   %ebx
f0116f24:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0116f2a:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0116f2d:	bb 44 ca 12 f0       	mov    $0xf012ca44,%ebx
f0116f32:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116f37:	89 c7                	mov    %eax,%edi
f0116f39:	89 de                	mov    %ebx,%esi
f0116f3b:	89 d1                	mov    %edx,%ecx
f0116f3d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116f3f:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0116f42:	b9 23 00 00 00       	mov    $0x23,%ecx
f0116f47:	b0 00                	mov    $0x0,%al
f0116f49:	89 d7                	mov    %edx,%edi
f0116f4b:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0116f4d:	6a 00                	push   $0x0
f0116f4f:	6a 0a                	push   $0xa
f0116f51:	6a 14                	push   $0x14
f0116f53:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0116f56:	50                   	push   %eax
f0116f57:	e8 14 2b ff ff       	call   f0109a70 <env_create>
f0116f5c:	83 c4 10             	add    $0x10,%esp
f0116f5f:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116f62:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116f65:	8b 40 64             	mov    0x64(%eax),%eax
f0116f68:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0116f6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116f6e:	8b 40 68             	mov    0x68(%eax),%eax
f0116f71:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0116f74:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116f77:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0116f7a:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0116f81:	75 70 20 
f0116f84:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0116f8b:	00 00 00 
f0116f8e:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0116f91:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116f96:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f9b:	89 d7                	mov    %edx,%edi
f0116f9d:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116f9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116fa2:	8b 40 10             	mov    0x10(%eax),%eax
f0116fa5:	83 ec 08             	sub    $0x8,%esp
f0116fa8:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0116fae:	52                   	push   %edx
f0116faf:	50                   	push   %eax
f0116fb0:	e8 c6 ba 00 00       	call   f0122a7b <ltostr>
f0116fb5:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116fb8:	83 ec 04             	sub    $0x4,%esp
f0116fbb:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116fc1:	50                   	push   %eax
f0116fc2:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0116fc8:	50                   	push   %eax
f0116fc9:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0116fcf:	50                   	push   %eax
f0116fd0:	e8 7f bb 00 00       	call   f0122b54 <strcconcat>
f0116fd5:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0116fd8:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0116fdf:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0116fe6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0116fed:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0116ff4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0116ff8:	83 ec 0c             	sub    $0xc,%esp
f0116ffb:	ff 75 d8             	pushl  -0x28(%ebp)
f0116ffe:	e8 59 1a 00 00       	call   f0118a5c <ClearUserSpace>
f0117003:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0117006:	83 ec 0c             	sub    $0xc,%esp
f0117009:	68 88 db 12 f0       	push   $0xf012db88
f011700e:	e8 59 9f fe ff       	call   f0100f6c <cprintf>
f0117013:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0117016:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117019:	c1 e0 03             	shl    $0x3,%eax
f011701c:	83 ec 04             	sub    $0x4,%esp
f011701f:	50                   	push   %eax
f0117020:	6a 00                	push   $0x0
f0117022:	ff 75 d8             	pushl  -0x28(%ebp)
f0117025:	e8 28 27 ff ff       	call   f0109752 <calculate_required_frames>
f011702a:	83 c4 10             	add    $0x10,%esp
f011702d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0117030:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0117034:	74 23                	je     f0117059 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0117036:	83 ec 0c             	sub    $0xc,%esp
f0117039:	6a 03                	push   $0x3
f011703b:	ff 75 c8             	pushl  -0x38(%ebp)
f011703e:	68 bc db 12 f0       	push   $0xf012dbbc
f0117043:	68 29 06 00 00       	push   $0x629
f0117048:	68 42 c3 12 f0       	push   $0xf012c342
f011704d:	e8 65 94 fe ff       	call   f01004b7 <_warn>
f0117052:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117055:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117059:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011705d:	74 04                	je     f0117063 <test_calculate_required_frames+0x145>
f011705f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117063:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0117067:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011706a:	c1 e0 02             	shl    $0x2,%eax
f011706d:	83 ec 04             	sub    $0x4,%esp
f0117070:	50                   	push   %eax
f0117071:	6a 00                	push   $0x0
f0117073:	ff 75 d8             	pushl  -0x28(%ebp)
f0117076:	e8 d7 26 ff ff       	call   f0109752 <calculate_required_frames>
f011707b:	83 c4 10             	add    $0x10,%esp
f011707e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0117081:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0117088:	74 26                	je     f01170b0 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f011708a:	83 ec 0c             	sub    $0xc,%esp
f011708d:	68 01 04 00 00       	push   $0x401
f0117092:	ff 75 c8             	pushl  -0x38(%ebp)
f0117095:	68 bc db 12 f0       	push   $0xf012dbbc
f011709a:	68 33 06 00 00       	push   $0x633
f011709f:	68 42 c3 12 f0       	push   $0xf012c342
f01170a4:	e8 0e 94 fe ff       	call   f01004b7 <_warn>
f01170a9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01170ac:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01170b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01170b4:	74 04                	je     f01170ba <test_calculate_required_frames+0x19c>
f01170b6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01170ba:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01170be:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01170c1:	c1 e0 0a             	shl    $0xa,%eax
f01170c4:	83 ec 04             	sub    $0x4,%esp
f01170c7:	50                   	push   %eax
f01170c8:	6a 00                	push   $0x0
f01170ca:	ff 75 d8             	pushl  -0x28(%ebp)
f01170cd:	e8 80 26 ff ff       	call   f0109752 <calculate_required_frames>
f01170d2:	83 c4 10             	add    $0x10,%esp
f01170d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f01170d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01170db:	c1 e0 0a             	shl    $0xa,%eax
f01170de:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01170e1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01170e8:	99                   	cltd   
f01170e9:	f7 fb                	idiv   %ebx
f01170eb:	89 c1                	mov    %eax,%ecx
f01170ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01170f0:	c1 e0 0a             	shl    $0xa,%eax
f01170f3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01170f6:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01170fd:	99                   	cltd   
f01170fe:	f7 fe                	idiv   %esi
f0117100:	01 c8                	add    %ecx,%eax
f0117102:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117105:	74 4c                	je     f0117153 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0117107:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011710a:	c1 e0 0a             	shl    $0xa,%eax
f011710d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117110:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0117117:	99                   	cltd   
f0117118:	f7 fb                	idiv   %ebx
f011711a:	89 c1                	mov    %eax,%ecx
f011711c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011711f:	c1 e0 0a             	shl    $0xa,%eax
f0117122:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117125:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011712c:	99                   	cltd   
f011712d:	f7 fe                	idiv   %esi
f011712f:	01 c8                	add    %ecx,%eax
f0117131:	83 ec 0c             	sub    $0xc,%esp
f0117134:	50                   	push   %eax
f0117135:	ff 75 c8             	pushl  -0x38(%ebp)
f0117138:	68 bc db 12 f0       	push   $0xf012dbbc
f011713d:	68 3d 06 00 00       	push   $0x63d
f0117142:	68 42 c3 12 f0       	push   $0xf012c342
f0117147:	e8 6b 93 fe ff       	call   f01004b7 <_warn>
f011714c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011714f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117153:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117157:	74 04                	je     f011715d <test_calculate_required_frames+0x23f>
f0117159:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011715d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0117161:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117164:	89 d0                	mov    %edx,%eax
f0117166:	01 c0                	add    %eax,%eax
f0117168:	01 d0                	add    %edx,%eax
f011716a:	01 c0                	add    %eax,%eax
f011716c:	83 ec 04             	sub    $0x4,%esp
f011716f:	50                   	push   %eax
f0117170:	68 00 10 00 00       	push   $0x1000
f0117175:	ff 75 d8             	pushl  -0x28(%ebp)
f0117178:	e8 d5 25 ff ff       	call   f0109752 <calculate_required_frames>
f011717d:	83 c4 10             	add    $0x10,%esp
f0117180:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0117183:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0117187:	74 23                	je     f01171ac <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0117189:	83 ec 0c             	sub    $0xc,%esp
f011718c:	6a 03                	push   $0x3
f011718e:	ff 75 c8             	pushl  -0x38(%ebp)
f0117191:	68 bc db 12 f0       	push   $0xf012dbbc
f0117196:	68 49 06 00 00       	push   $0x649
f011719b:	68 42 c3 12 f0       	push   $0xf012c342
f01171a0:	e8 12 93 fe ff       	call   f01004b7 <_warn>
f01171a5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01171a8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01171ac:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01171b0:	74 04                	je     f01171b6 <test_calculate_required_frames+0x298>
f01171b2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01171b6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01171ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01171bd:	89 c2                	mov    %eax,%edx
f01171bf:	01 d2                	add    %edx,%edx
f01171c1:	01 d0                	add    %edx,%eax
f01171c3:	83 ec 04             	sub    $0x4,%esp
f01171c6:	50                   	push   %eax
f01171c7:	68 00 18 00 00       	push   $0x1800
f01171cc:	ff 75 d8             	pushl  -0x28(%ebp)
f01171cf:	e8 7e 25 ff ff       	call   f0109752 <calculate_required_frames>
f01171d4:	83 c4 10             	add    $0x10,%esp
f01171d7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01171da:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01171de:	74 23                	je     f0117203 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01171e0:	83 ec 0c             	sub    $0xc,%esp
f01171e3:	6a 03                	push   $0x3
f01171e5:	ff 75 c8             	pushl  -0x38(%ebp)
f01171e8:	68 bc db 12 f0       	push   $0xf012dbbc
f01171ed:	68 53 06 00 00       	push   $0x653
f01171f2:	68 42 c3 12 f0       	push   $0xf012c342
f01171f7:	e8 bb 92 fe ff       	call   f01004b7 <_warn>
f01171fc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01171ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117203:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117207:	74 04                	je     f011720d <test_calculate_required_frames+0x2ef>
f0117209:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011720d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0117211:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117214:	89 d0                	mov    %edx,%eax
f0117216:	c1 e0 02             	shl    $0x2,%eax
f0117219:	01 d0                	add    %edx,%eax
f011721b:	01 c0                	add    %eax,%eax
f011721d:	83 ec 04             	sub    $0x4,%esp
f0117220:	50                   	push   %eax
f0117221:	68 00 00 40 00       	push   $0x400000
f0117226:	ff 75 d8             	pushl  -0x28(%ebp)
f0117229:	e8 24 25 ff ff       	call   f0109752 <calculate_required_frames>
f011722e:	83 c4 10             	add    $0x10,%esp
f0117231:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0117234:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f011723b:	74 26                	je     f0117263 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f011723d:	83 ec 0c             	sub    $0xc,%esp
f0117240:	68 03 0a 00 00       	push   $0xa03
f0117245:	ff 75 c8             	pushl  -0x38(%ebp)
f0117248:	68 bc db 12 f0       	push   $0xf012dbbc
f011724d:	68 5d 06 00 00       	push   $0x65d
f0117252:	68 42 c3 12 f0       	push   $0xf012c342
f0117257:	e8 5b 92 fe ff       	call   f01004b7 <_warn>
f011725c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011725f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117263:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117267:	74 04                	je     f011726d <test_calculate_required_frames+0x34f>
f0117269:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011726d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0117271:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117274:	01 c0                	add    %eax,%eax
f0117276:	83 ec 04             	sub    $0x4,%esp
f0117279:	50                   	push   %eax
f011727a:	68 00 00 70 00       	push   $0x700000
f011727f:	ff 75 d8             	pushl  -0x28(%ebp)
f0117282:	e8 cb 24 ff ff       	call   f0109752 <calculate_required_frames>
f0117287:	83 c4 10             	add    $0x10,%esp
f011728a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f011728d:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0117294:	74 26                	je     f01172bc <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0117296:	83 ec 0c             	sub    $0xc,%esp
f0117299:	68 02 02 00 00       	push   $0x202
f011729e:	ff 75 c8             	pushl  -0x38(%ebp)
f01172a1:	68 bc db 12 f0       	push   $0xf012dbbc
f01172a6:	68 69 06 00 00       	push   $0x669
f01172ab:	68 42 c3 12 f0       	push   $0xf012c342
f01172b0:	e8 02 92 fe ff       	call   f01004b7 <_warn>
f01172b5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01172b8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01172bc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01172c0:	74 04                	je     f01172c6 <test_calculate_required_frames+0x3a8>
f01172c2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01172c6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01172ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01172cd:	83 ec 04             	sub    $0x4,%esp
f01172d0:	50                   	push   %eax
f01172d1:	68 ff ff 3f 00       	push   $0x3fffff
f01172d6:	ff 75 d8             	pushl  -0x28(%ebp)
f01172d9:	e8 74 24 ff ff       	call   f0109752 <calculate_required_frames>
f01172de:	83 c4 10             	add    $0x10,%esp
f01172e1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f01172e4:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01172e8:	74 23                	je     f011730d <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01172ea:	83 ec 0c             	sub    $0xc,%esp
f01172ed:	6a 04                	push   $0x4
f01172ef:	ff 75 c8             	pushl  -0x38(%ebp)
f01172f2:	68 bc db 12 f0       	push   $0xf012dbbc
f01172f7:	68 73 06 00 00       	push   $0x673
f01172fc:	68 42 c3 12 f0       	push   $0xf012c342
f0117301:	e8 b1 91 fe ff       	call   f01004b7 <_warn>
f0117306:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117309:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011730d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117311:	74 04                	je     f0117317 <test_calculate_required_frames+0x3f9>
f0117313:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117317:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011731b:	83 ec 0c             	sub    $0xc,%esp
f011731e:	68 f5 d6 12 f0       	push   $0xf012d6f5
f0117323:	e8 44 9c fe ff       	call   f0100f6c <cprintf>
f0117328:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011732b:	83 ec 0c             	sub    $0xc,%esp
f011732e:	68 14 dc 12 f0       	push   $0xf012dc14
f0117333:	e8 34 9c fe ff       	call   f0100f6c <cprintf>
f0117338:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011733b:	83 ec 04             	sub    $0x4,%esp
f011733e:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0117344:	50                   	push   %eax
f0117345:	68 ae ca 12 f0       	push   $0xf012caae
f011734a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117350:	50                   	push   %eax
f0117351:	e8 fe b7 00 00       	call   f0122b54 <strcconcat>
f0117356:	83 c4 10             	add    $0x10,%esp
f0117359:	83 ec 0c             	sub    $0xc,%esp
f011735c:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0117362:	50                   	push   %eax
f0117363:	e8 74 ab fe ff       	call   f0101edc <execute_command>
f0117368:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f011736b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011736e:	c1 e0 03             	shl    $0x3,%eax
f0117371:	83 ec 04             	sub    $0x4,%esp
f0117374:	50                   	push   %eax
f0117375:	6a 00                	push   $0x0
f0117377:	ff 75 d8             	pushl  -0x28(%ebp)
f011737a:	e8 d3 23 ff ff       	call   f0109752 <calculate_required_frames>
f011737f:	83 c4 10             	add    $0x10,%esp
f0117382:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0117385:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011738c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011738f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117392:	74 24                	je     f01173b8 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0117394:	83 ec 0c             	sub    $0xc,%esp
f0117397:	ff 75 c4             	pushl  -0x3c(%ebp)
f011739a:	ff 75 c8             	pushl  -0x38(%ebp)
f011739d:	68 bc db 12 f0       	push   $0xf012dbbc
f01173a2:	68 87 06 00 00       	push   $0x687
f01173a7:	68 42 c3 12 f0       	push   $0xf012c342
f01173ac:	e8 06 91 fe ff       	call   f01004b7 <_warn>
f01173b1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01173b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01173b8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01173bc:	74 04                	je     f01173c2 <test_calculate_required_frames+0x4a4>
f01173be:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01173c2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01173c6:	83 ec 04             	sub    $0x4,%esp
f01173c9:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01173cf:	50                   	push   %eax
f01173d0:	68 bb ca 12 f0       	push   $0xf012cabb
f01173d5:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01173db:	50                   	push   %eax
f01173dc:	e8 73 b7 00 00       	call   f0122b54 <strcconcat>
f01173e1:	83 c4 10             	add    $0x10,%esp
f01173e4:	83 ec 0c             	sub    $0xc,%esp
f01173e7:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01173ed:	50                   	push   %eax
f01173ee:	e8 e9 aa fe ff       	call   f0101edc <execute_command>
f01173f3:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01173f6:	83 ec 04             	sub    $0x4,%esp
f01173f9:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01173ff:	50                   	push   %eax
f0117400:	68 48 dc 12 f0       	push   $0xf012dc48
f0117405:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011740b:	50                   	push   %eax
f011740c:	e8 43 b7 00 00       	call   f0122b54 <strcconcat>
f0117411:	83 c4 10             	add    $0x10,%esp
f0117414:	83 ec 0c             	sub    $0xc,%esp
f0117417:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011741d:	50                   	push   %eax
f011741e:	e8 b9 aa fe ff       	call   f0101edc <execute_command>
f0117423:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0117426:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117429:	c1 e0 03             	shl    $0x3,%eax
f011742c:	83 ec 04             	sub    $0x4,%esp
f011742f:	50                   	push   %eax
f0117430:	6a 00                	push   $0x0
f0117432:	ff 75 d8             	pushl  -0x28(%ebp)
f0117435:	e8 18 23 ff ff       	call   f0109752 <calculate_required_frames>
f011743a:	83 c4 10             	add    $0x10,%esp
f011743d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0117440:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0117447:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011744a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011744d:	74 24                	je     f0117473 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011744f:	83 ec 0c             	sub    $0xc,%esp
f0117452:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117455:	ff 75 c8             	pushl  -0x38(%ebp)
f0117458:	68 bc db 12 f0       	push   $0xf012dbbc
f011745d:	68 95 06 00 00       	push   $0x695
f0117462:	68 42 c3 12 f0       	push   $0xf012c342
f0117467:	e8 4b 90 fe ff       	call   f01004b7 <_warn>
f011746c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011746f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117473:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117477:	74 04                	je     f011747d <test_calculate_required_frames+0x55f>
f0117479:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011747d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0117481:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117484:	c1 e0 0a             	shl    $0xa,%eax
f0117487:	83 ec 04             	sub    $0x4,%esp
f011748a:	50                   	push   %eax
f011748b:	6a 00                	push   $0x0
f011748d:	ff 75 d8             	pushl  -0x28(%ebp)
f0117490:	e8 bd 22 ff ff       	call   f0109752 <calculate_required_frames>
f0117495:	83 c4 10             	add    $0x10,%esp
f0117498:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f011749b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011749e:	c1 e0 0a             	shl    $0xa,%eax
f01174a1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01174a4:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01174ab:	99                   	cltd   
f01174ac:	f7 fb                	idiv   %ebx
f01174ae:	89 c1                	mov    %eax,%ecx
f01174b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01174b3:	c1 e0 0a             	shl    $0xa,%eax
f01174b6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01174b9:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01174c0:	99                   	cltd   
f01174c1:	f7 fe                	idiv   %esi
f01174c3:	01 c8                	add    %ecx,%eax
f01174c5:	83 e8 05             	sub    $0x5,%eax
f01174c8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f01174cb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01174ce:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01174d1:	74 24                	je     f01174f7 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01174d3:	83 ec 0c             	sub    $0xc,%esp
f01174d6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01174d9:	ff 75 c8             	pushl  -0x38(%ebp)
f01174dc:	68 bc db 12 f0       	push   $0xf012dbbc
f01174e1:	68 a0 06 00 00       	push   $0x6a0
f01174e6:	68 42 c3 12 f0       	push   $0xf012c342
f01174eb:	e8 c7 8f fe ff       	call   f01004b7 <_warn>
f01174f0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01174f3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01174f7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01174fb:	74 04                	je     f0117501 <test_calculate_required_frames+0x5e3>
f01174fd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117501:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0117505:	83 ec 04             	sub    $0x4,%esp
f0117508:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011750e:	50                   	push   %eax
f011750f:	68 54 dc 12 f0       	push   $0xf012dc54
f0117514:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011751a:	50                   	push   %eax
f011751b:	e8 34 b6 00 00       	call   f0122b54 <strcconcat>
f0117520:	83 c4 10             	add    $0x10,%esp
f0117523:	83 ec 0c             	sub    $0xc,%esp
f0117526:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011752c:	50                   	push   %eax
f011752d:	e8 aa a9 fe ff       	call   f0101edc <execute_command>
f0117532:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0117535:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117538:	89 c2                	mov    %eax,%edx
f011753a:	01 d2                	add    %edx,%edx
f011753c:	01 d0                	add    %edx,%eax
f011753e:	83 ec 04             	sub    $0x4,%esp
f0117541:	50                   	push   %eax
f0117542:	68 00 18 00 00       	push   $0x1800
f0117547:	ff 75 d8             	pushl  -0x28(%ebp)
f011754a:	e8 03 22 ff ff       	call   f0109752 <calculate_required_frames>
f011754f:	83 c4 10             	add    $0x10,%esp
f0117552:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0117555:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011755c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011755f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117562:	74 24                	je     f0117588 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0117564:	83 ec 0c             	sub    $0xc,%esp
f0117567:	ff 75 c4             	pushl  -0x3c(%ebp)
f011756a:	ff 75 c8             	pushl  -0x38(%ebp)
f011756d:	68 bc db 12 f0       	push   $0xf012dbbc
f0117572:	68 af 06 00 00       	push   $0x6af
f0117577:	68 42 c3 12 f0       	push   $0xf012c342
f011757c:	e8 36 8f fe ff       	call   f01004b7 <_warn>
f0117581:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117584:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117588:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011758c:	74 04                	je     f0117592 <test_calculate_required_frames+0x674>
f011758e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117592:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0117596:	83 ec 04             	sub    $0x4,%esp
f0117599:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011759f:	50                   	push   %eax
f01175a0:	68 14 cd 12 f0       	push   $0xf012cd14
f01175a5:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01175ab:	50                   	push   %eax
f01175ac:	e8 a3 b5 00 00       	call   f0122b54 <strcconcat>
f01175b1:	83 c4 10             	add    $0x10,%esp
f01175b4:	83 ec 0c             	sub    $0xc,%esp
f01175b7:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01175bd:	50                   	push   %eax
f01175be:	e8 19 a9 fe ff       	call   f0101edc <execute_command>
f01175c3:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01175c6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01175c9:	89 d0                	mov    %edx,%eax
f01175cb:	c1 e0 02             	shl    $0x2,%eax
f01175ce:	01 d0                	add    %edx,%eax
f01175d0:	01 c0                	add    %eax,%eax
f01175d2:	83 ec 04             	sub    $0x4,%esp
f01175d5:	50                   	push   %eax
f01175d6:	68 00 00 40 00       	push   $0x400000
f01175db:	ff 75 d8             	pushl  -0x28(%ebp)
f01175de:	e8 6f 21 ff ff       	call   f0109752 <calculate_required_frames>
f01175e3:	83 c4 10             	add    $0x10,%esp
f01175e6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01175e9:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01175f0:	74 26                	je     f0117618 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01175f2:	83 ec 0c             	sub    $0xc,%esp
f01175f5:	68 03 0a 00 00       	push   $0xa03
f01175fa:	ff 75 c8             	pushl  -0x38(%ebp)
f01175fd:	68 bc db 12 f0       	push   $0xf012dbbc
f0117602:	68 bb 06 00 00       	push   $0x6bb
f0117607:	68 42 c3 12 f0       	push   $0xf012c342
f011760c:	e8 a6 8e fe ff       	call   f01004b7 <_warn>
f0117611:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117614:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117618:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011761c:	74 04                	je     f0117622 <test_calculate_required_frames+0x704>
f011761e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117622:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0117626:	83 ec 04             	sub    $0x4,%esp
f0117629:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011762f:	50                   	push   %eax
f0117630:	68 1e cd 12 f0       	push   $0xf012cd1e
f0117635:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011763b:	50                   	push   %eax
f011763c:	e8 13 b5 00 00       	call   f0122b54 <strcconcat>
f0117641:	83 c4 10             	add    $0x10,%esp
f0117644:	83 ec 0c             	sub    $0xc,%esp
f0117647:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011764d:	50                   	push   %eax
f011764e:	e8 89 a8 fe ff       	call   f0101edc <execute_command>
f0117653:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0117656:	83 ec 04             	sub    $0x4,%esp
f0117659:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011765f:	50                   	push   %eax
f0117660:	68 5c dc 12 f0       	push   $0xf012dc5c
f0117665:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011766b:	50                   	push   %eax
f011766c:	e8 e3 b4 00 00       	call   f0122b54 <strcconcat>
f0117671:	83 c4 10             	add    $0x10,%esp
f0117674:	83 ec 0c             	sub    $0xc,%esp
f0117677:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011767d:	50                   	push   %eax
f011767e:	e8 59 a8 fe ff       	call   f0101edc <execute_command>
f0117683:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0117686:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117689:	01 c0                	add    %eax,%eax
f011768b:	83 ec 04             	sub    $0x4,%esp
f011768e:	50                   	push   %eax
f011768f:	68 00 00 70 00       	push   $0x700000
f0117694:	ff 75 d8             	pushl  -0x28(%ebp)
f0117697:	e8 b6 20 ff ff       	call   f0109752 <calculate_required_frames>
f011769c:	83 c4 10             	add    $0x10,%esp
f011769f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f01176a2:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f01176a9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01176ac:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01176af:	74 24                	je     f01176d5 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01176b1:	83 ec 0c             	sub    $0xc,%esp
f01176b4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01176b7:	ff 75 c8             	pushl  -0x38(%ebp)
f01176ba:	68 bc db 12 f0       	push   $0xf012dbbc
f01176bf:	68 cb 06 00 00       	push   $0x6cb
f01176c4:	68 42 c3 12 f0       	push   $0xf012c342
f01176c9:	e8 e9 8d fe ff       	call   f01004b7 <_warn>
f01176ce:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01176d1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01176d5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01176d9:	74 04                	je     f01176df <test_calculate_required_frames+0x7c1>
f01176db:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01176df:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01176e3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01176e6:	83 ec 04             	sub    $0x4,%esp
f01176e9:	50                   	push   %eax
f01176ea:	68 ff ff 3f 00       	push   $0x3fffff
f01176ef:	ff 75 d8             	pushl  -0x28(%ebp)
f01176f2:	e8 5b 20 ff ff       	call   f0109752 <calculate_required_frames>
f01176f7:	83 c4 10             	add    $0x10,%esp
f01176fa:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f01176fd:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0117704:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117707:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011770a:	74 24                	je     f0117730 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011770c:	83 ec 0c             	sub    $0xc,%esp
f011770f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117712:	ff 75 c8             	pushl  -0x38(%ebp)
f0117715:	68 bc db 12 f0       	push   $0xf012dbbc
f011771a:	68 d6 06 00 00       	push   $0x6d6
f011771f:	68 42 c3 12 f0       	push   $0xf012c342
f0117724:	e8 8e 8d fe ff       	call   f01004b7 <_warn>
f0117729:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011772c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117730:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117734:	74 04                	je     f011773a <test_calculate_required_frames+0x81c>
f0117736:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011773a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011773e:	83 ec 0c             	sub    $0xc,%esp
f0117741:	68 cf cc 12 f0       	push   $0xf012cccf
f0117746:	e8 21 98 fe ff       	call   f0100f6c <cprintf>
f011774b:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f011774e:	83 ec 08             	sub    $0x8,%esp
f0117751:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117754:	68 68 dc 12 f0       	push   $0xf012dc68
f0117759:	e8 0e 98 fe ff       	call   f0100f6c <cprintf>
f011775e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0117761:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0117765:	75 10                	jne    f0117777 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0117767:	83 ec 0c             	sub    $0xc,%esp
f011776a:	68 a8 dc 12 f0       	push   $0xf012dca8
f011776f:	e8 f8 97 fe ff       	call   f0100f6c <cprintf>
f0117774:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0117777:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f011777c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011777f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117782:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0117785:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011778a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011778d:	5b                   	pop    %ebx
f011778e:	5e                   	pop    %esi
f011778f:	5f                   	pop    %edi
f0117790:	5d                   	pop    %ebp
f0117791:	c3                   	ret    

f0117792 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0117792:	55                   	push   %ebp
f0117793:	89 e5                	mov    %esp,%ebp
f0117795:	57                   	push   %edi
f0117796:	56                   	push   %esi
f0117797:	53                   	push   %ebx
f0117798:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011779e:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01177a1:	bb 44 ca 12 f0       	mov    $0xf012ca44,%ebx
f01177a6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01177ab:	89 c7                	mov    %eax,%edi
f01177ad:	89 de                	mov    %ebx,%esi
f01177af:	89 d1                	mov    %edx,%ecx
f01177b1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01177b3:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01177b6:	b9 23 00 00 00       	mov    $0x23,%ecx
f01177bb:	b0 00                	mov    $0x0,%al
f01177bd:	89 d7                	mov    %edx,%edi
f01177bf:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01177c1:	6a 00                	push   $0x0
f01177c3:	6a 0a                	push   $0xa
f01177c5:	6a 14                	push   $0x14
f01177c7:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01177ca:	50                   	push   %eax
f01177cb:	e8 a0 22 ff ff       	call   f0109a70 <env_create>
f01177d0:	83 c4 10             	add    $0x10,%esp
f01177d3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01177d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01177d9:	8b 40 64             	mov    0x64(%eax),%eax
f01177dc:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f01177df:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01177e2:	8b 40 68             	mov    0x68(%eax),%eax
f01177e5:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01177e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01177eb:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01177ee:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01177f5:	75 70 20 
f01177f8:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01177ff:	00 00 00 
f0117802:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0117805:	b9 03 00 00 00       	mov    $0x3,%ecx
f011780a:	b8 00 00 00 00       	mov    $0x0,%eax
f011780f:	89 d7                	mov    %edx,%edi
f0117811:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0117813:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117816:	8b 40 10             	mov    0x10(%eax),%eax
f0117819:	83 ec 08             	sub    $0x8,%esp
f011781c:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0117822:	52                   	push   %edx
f0117823:	50                   	push   %eax
f0117824:	e8 52 b2 00 00       	call   f0122a7b <ltostr>
f0117829:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011782c:	83 ec 04             	sub    $0x4,%esp
f011782f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117835:	50                   	push   %eax
f0117836:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f011783c:	50                   	push   %eax
f011783d:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0117843:	50                   	push   %eax
f0117844:	e8 0b b3 00 00       	call   f0122b54 <strcconcat>
f0117849:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011784c:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0117853:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f011785a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0117861:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0117865:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011786c:	00 00 00 
	uint32 num_tables = 0;
f011786f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117876:	00 00 00 
	ClearUserSpace(proc_directory);
f0117879:	83 ec 0c             	sub    $0xc,%esp
f011787c:	ff 75 d8             	pushl  -0x28(%ebp)
f011787f:	e8 d8 11 00 00       	call   f0118a5c <ClearUserSpace>
f0117884:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0117887:	83 ec 0c             	sub    $0xc,%esp
f011788a:	68 88 db 12 f0       	push   $0xf012db88
f011788f:	e8 d8 96 fe ff       	call   f0100f6c <cprintf>
f0117894:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0117897:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011789a:	c1 e0 03             	shl    $0x3,%eax
f011789d:	89 c2                	mov    %eax,%edx
f011789f:	83 ec 0c             	sub    $0xc,%esp
f01178a2:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01178a8:	50                   	push   %eax
f01178a9:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01178af:	50                   	push   %eax
f01178b0:	52                   	push   %edx
f01178b1:	6a 00                	push   $0x0
f01178b3:	ff 75 d8             	pushl  -0x28(%ebp)
f01178b6:	e8 7d 1e ff ff       	call   f0109738 <calculate_allocated_space>
f01178bb:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01178be:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01178c4:	85 c0                	test   %eax,%eax
f01178c6:	74 27                	je     f01178ef <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01178c8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01178ce:	83 ec 0c             	sub    $0xc,%esp
f01178d1:	6a 00                	push   $0x0
f01178d3:	50                   	push   %eax
f01178d4:	68 f4 dc 12 f0       	push   $0xf012dcf4
f01178d9:	68 0b 07 00 00       	push   $0x70b
f01178de:	68 42 c3 12 f0       	push   $0xf012c342
f01178e3:	e8 cf 8b fe ff       	call   f01004b7 <_warn>
f01178e8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01178eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01178ef:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01178f5:	85 c0                	test   %eax,%eax
f01178f7:	74 27                	je     f0117920 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01178f9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01178ff:	83 ec 0c             	sub    $0xc,%esp
f0117902:	6a 00                	push   $0x0
f0117904:	50                   	push   %eax
f0117905:	68 54 dd 12 f0       	push   $0xf012dd54
f011790a:	68 10 07 00 00       	push   $0x710
f011790f:	68 42 c3 12 f0       	push   $0xf012c342
f0117914:	e8 9e 8b fe ff       	call   f01004b7 <_warn>
f0117919:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011791c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117920:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117924:	74 04                	je     f011792a <test_calculate_allocated_space+0x198>
f0117926:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011792a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f011792e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117935:	00 00 00 
		num_pages = 0;
f0117938:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011793f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0117942:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117945:	c1 e0 02             	shl    $0x2,%eax
f0117948:	89 c2                	mov    %eax,%edx
f011794a:	83 ec 0c             	sub    $0xc,%esp
f011794d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117953:	50                   	push   %eax
f0117954:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011795a:	50                   	push   %eax
f011795b:	52                   	push   %edx
f011795c:	6a 00                	push   $0x0
f011795e:	ff 75 d8             	pushl  -0x28(%ebp)
f0117961:	e8 d2 1d ff ff       	call   f0109738 <calculate_allocated_space>
f0117966:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117969:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011796f:	85 c0                	test   %eax,%eax
f0117971:	74 27                	je     f011799a <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117973:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117979:	83 ec 0c             	sub    $0xc,%esp
f011797c:	6a 00                	push   $0x0
f011797e:	50                   	push   %eax
f011797f:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117984:	68 1c 07 00 00       	push   $0x71c
f0117989:	68 42 c3 12 f0       	push   $0xf012c342
f011798e:	e8 24 8b fe ff       	call   f01004b7 <_warn>
f0117993:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117996:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011799a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01179a0:	85 c0                	test   %eax,%eax
f01179a2:	74 27                	je     f01179cb <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01179a4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01179aa:	83 ec 0c             	sub    $0xc,%esp
f01179ad:	6a 00                	push   $0x0
f01179af:	50                   	push   %eax
f01179b0:	68 54 dd 12 f0       	push   $0xf012dd54
f01179b5:	68 21 07 00 00       	push   $0x721
f01179ba:	68 42 c3 12 f0       	push   $0xf012c342
f01179bf:	e8 f3 8a fe ff       	call   f01004b7 <_warn>
f01179c4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01179c7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01179cb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01179cf:	74 04                	je     f01179d5 <test_calculate_allocated_space+0x243>
f01179d1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01179d5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01179d9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01179e0:	00 00 00 
		num_pages = 0;
f01179e3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01179ea:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01179ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01179f0:	c1 e0 0a             	shl    $0xa,%eax
f01179f3:	89 c2                	mov    %eax,%edx
f01179f5:	83 ec 0c             	sub    $0xc,%esp
f01179f8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01179fe:	50                   	push   %eax
f01179ff:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117a05:	50                   	push   %eax
f0117a06:	52                   	push   %edx
f0117a07:	6a 00                	push   $0x0
f0117a09:	ff 75 d8             	pushl  -0x28(%ebp)
f0117a0c:	e8 27 1d ff ff       	call   f0109738 <calculate_allocated_space>
f0117a11:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117a14:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117a1a:	85 c0                	test   %eax,%eax
f0117a1c:	74 27                	je     f0117a45 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117a1e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117a24:	83 ec 0c             	sub    $0xc,%esp
f0117a27:	6a 00                	push   $0x0
f0117a29:	50                   	push   %eax
f0117a2a:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117a2f:	68 2d 07 00 00       	push   $0x72d
f0117a34:	68 42 c3 12 f0       	push   $0xf012c342
f0117a39:	e8 79 8a fe ff       	call   f01004b7 <_warn>
f0117a3e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117a41:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117a45:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117a4b:	85 c0                	test   %eax,%eax
f0117a4d:	74 27                	je     f0117a76 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117a4f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117a55:	83 ec 0c             	sub    $0xc,%esp
f0117a58:	6a 00                	push   $0x0
f0117a5a:	50                   	push   %eax
f0117a5b:	68 54 dd 12 f0       	push   $0xf012dd54
f0117a60:	68 32 07 00 00       	push   $0x732
f0117a65:	68 42 c3 12 f0       	push   $0xf012c342
f0117a6a:	e8 48 8a fe ff       	call   f01004b7 <_warn>
f0117a6f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117a72:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117a76:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117a7a:	74 04                	je     f0117a80 <test_calculate_allocated_space+0x2ee>
f0117a7c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117a80:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0117a84:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117a8b:	00 00 00 
		num_pages = 0;
f0117a8e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117a95:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0117a98:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117a9b:	89 d0                	mov    %edx,%eax
f0117a9d:	01 c0                	add    %eax,%eax
f0117a9f:	01 d0                	add    %edx,%eax
f0117aa1:	01 c0                	add    %eax,%eax
f0117aa3:	05 00 10 00 00       	add    $0x1000,%eax
f0117aa8:	89 c2                	mov    %eax,%edx
f0117aaa:	83 ec 0c             	sub    $0xc,%esp
f0117aad:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117ab3:	50                   	push   %eax
f0117ab4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117aba:	50                   	push   %eax
f0117abb:	52                   	push   %edx
f0117abc:	68 00 10 00 00       	push   $0x1000
f0117ac1:	ff 75 d8             	pushl  -0x28(%ebp)
f0117ac4:	e8 6f 1c ff ff       	call   f0109738 <calculate_allocated_space>
f0117ac9:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117acc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117ad2:	85 c0                	test   %eax,%eax
f0117ad4:	74 27                	je     f0117afd <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117ad6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117adc:	83 ec 0c             	sub    $0xc,%esp
f0117adf:	6a 00                	push   $0x0
f0117ae1:	50                   	push   %eax
f0117ae2:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117ae7:	68 3f 07 00 00       	push   $0x73f
f0117aec:	68 42 c3 12 f0       	push   $0xf012c342
f0117af1:	e8 c1 89 fe ff       	call   f01004b7 <_warn>
f0117af6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117af9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117afd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117b03:	85 c0                	test   %eax,%eax
f0117b05:	74 27                	je     f0117b2e <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117b07:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117b0d:	83 ec 0c             	sub    $0xc,%esp
f0117b10:	6a 00                	push   $0x0
f0117b12:	50                   	push   %eax
f0117b13:	68 54 dd 12 f0       	push   $0xf012dd54
f0117b18:	68 44 07 00 00       	push   $0x744
f0117b1d:	68 42 c3 12 f0       	push   $0xf012c342
f0117b22:	e8 90 89 fe ff       	call   f01004b7 <_warn>
f0117b27:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117b2a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117b2e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117b32:	74 04                	je     f0117b38 <test_calculate_allocated_space+0x3a6>
f0117b34:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117b38:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0117b3c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117b43:	00 00 00 
		num_pages = 0;
f0117b46:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117b4d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0117b50:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117b53:	89 c2                	mov    %eax,%edx
f0117b55:	01 d2                	add    %edx,%edx
f0117b57:	01 d0                	add    %edx,%eax
f0117b59:	05 00 18 00 00       	add    $0x1800,%eax
f0117b5e:	89 c2                	mov    %eax,%edx
f0117b60:	83 ec 0c             	sub    $0xc,%esp
f0117b63:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117b69:	50                   	push   %eax
f0117b6a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117b70:	50                   	push   %eax
f0117b71:	52                   	push   %edx
f0117b72:	68 00 18 00 00       	push   $0x1800
f0117b77:	ff 75 d8             	pushl  -0x28(%ebp)
f0117b7a:	e8 b9 1b ff ff       	call   f0109738 <calculate_allocated_space>
f0117b7f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117b82:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117b88:	85 c0                	test   %eax,%eax
f0117b8a:	74 27                	je     f0117bb3 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117b8c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117b92:	83 ec 0c             	sub    $0xc,%esp
f0117b95:	6a 00                	push   $0x0
f0117b97:	50                   	push   %eax
f0117b98:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117b9d:	68 50 07 00 00       	push   $0x750
f0117ba2:	68 42 c3 12 f0       	push   $0xf012c342
f0117ba7:	e8 0b 89 fe ff       	call   f01004b7 <_warn>
f0117bac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117baf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117bb3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117bb9:	85 c0                	test   %eax,%eax
f0117bbb:	74 27                	je     f0117be4 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117bbd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117bc3:	83 ec 0c             	sub    $0xc,%esp
f0117bc6:	6a 00                	push   $0x0
f0117bc8:	50                   	push   %eax
f0117bc9:	68 54 dd 12 f0       	push   $0xf012dd54
f0117bce:	68 55 07 00 00       	push   $0x755
f0117bd3:	68 42 c3 12 f0       	push   $0xf012c342
f0117bd8:	e8 da 88 fe ff       	call   f01004b7 <_warn>
f0117bdd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117be0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117be4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117be8:	74 04                	je     f0117bee <test_calculate_allocated_space+0x45c>
f0117bea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117bee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0117bf2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117bf9:	00 00 00 
		num_pages = 0;
f0117bfc:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117c03:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0117c06:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117c09:	89 d0                	mov    %edx,%eax
f0117c0b:	c1 e0 02             	shl    $0x2,%eax
f0117c0e:	01 d0                	add    %edx,%eax
f0117c10:	01 c0                	add    %eax,%eax
f0117c12:	05 00 00 40 00       	add    $0x400000,%eax
f0117c17:	89 c2                	mov    %eax,%edx
f0117c19:	83 ec 0c             	sub    $0xc,%esp
f0117c1c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117c22:	50                   	push   %eax
f0117c23:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117c29:	50                   	push   %eax
f0117c2a:	52                   	push   %edx
f0117c2b:	68 00 00 40 00       	push   $0x400000
f0117c30:	ff 75 d8             	pushl  -0x28(%ebp)
f0117c33:	e8 00 1b ff ff       	call   f0109738 <calculate_allocated_space>
f0117c38:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117c3b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117c41:	85 c0                	test   %eax,%eax
f0117c43:	74 27                	je     f0117c6c <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117c45:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117c4b:	83 ec 0c             	sub    $0xc,%esp
f0117c4e:	6a 00                	push   $0x0
f0117c50:	50                   	push   %eax
f0117c51:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117c56:	68 61 07 00 00       	push   $0x761
f0117c5b:	68 42 c3 12 f0       	push   $0xf012c342
f0117c60:	e8 52 88 fe ff       	call   f01004b7 <_warn>
f0117c65:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117c68:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117c6c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117c72:	85 c0                	test   %eax,%eax
f0117c74:	74 27                	je     f0117c9d <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117c76:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117c7c:	83 ec 0c             	sub    $0xc,%esp
f0117c7f:	6a 00                	push   $0x0
f0117c81:	50                   	push   %eax
f0117c82:	68 54 dd 12 f0       	push   $0xf012dd54
f0117c87:	68 66 07 00 00       	push   $0x766
f0117c8c:	68 42 c3 12 f0       	push   $0xf012c342
f0117c91:	e8 21 88 fe ff       	call   f01004b7 <_warn>
f0117c96:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117c99:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117c9d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117ca1:	74 04                	je     f0117ca7 <test_calculate_allocated_space+0x515>
f0117ca3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117ca7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0117cab:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117cb2:	00 00 00 
		num_pages = 0;
f0117cb5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117cbc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0117cbf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117cc2:	05 00 00 38 00       	add    $0x380000,%eax
f0117cc7:	01 c0                	add    %eax,%eax
f0117cc9:	89 c2                	mov    %eax,%edx
f0117ccb:	83 ec 0c             	sub    $0xc,%esp
f0117cce:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117cd4:	50                   	push   %eax
f0117cd5:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117cdb:	50                   	push   %eax
f0117cdc:	52                   	push   %edx
f0117cdd:	68 00 00 70 00       	push   $0x700000
f0117ce2:	ff 75 d8             	pushl  -0x28(%ebp)
f0117ce5:	e8 4e 1a ff ff       	call   f0109738 <calculate_allocated_space>
f0117cea:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117ced:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117cf3:	85 c0                	test   %eax,%eax
f0117cf5:	74 27                	je     f0117d1e <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117cf7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117cfd:	83 ec 0c             	sub    $0xc,%esp
f0117d00:	6a 00                	push   $0x0
f0117d02:	50                   	push   %eax
f0117d03:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117d08:	68 73 07 00 00       	push   $0x773
f0117d0d:	68 42 c3 12 f0       	push   $0xf012c342
f0117d12:	e8 a0 87 fe ff       	call   f01004b7 <_warn>
f0117d17:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117d1a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117d1e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117d24:	85 c0                	test   %eax,%eax
f0117d26:	74 27                	je     f0117d4f <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117d28:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117d2e:	83 ec 0c             	sub    $0xc,%esp
f0117d31:	6a 00                	push   $0x0
f0117d33:	50                   	push   %eax
f0117d34:	68 54 dd 12 f0       	push   $0xf012dd54
f0117d39:	68 78 07 00 00       	push   $0x778
f0117d3e:	68 42 c3 12 f0       	push   $0xf012c342
f0117d43:	e8 6f 87 fe ff       	call   f01004b7 <_warn>
f0117d48:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117d4b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117d4f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117d53:	74 04                	je     f0117d59 <test_calculate_allocated_space+0x5c7>
f0117d55:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117d59:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0117d5d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117d64:	00 00 00 
		num_pages = 0;
f0117d67:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117d6e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0117d71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117d74:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0117d79:	89 c2                	mov    %eax,%edx
f0117d7b:	83 ec 0c             	sub    $0xc,%esp
f0117d7e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117d84:	50                   	push   %eax
f0117d85:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117d8b:	50                   	push   %eax
f0117d8c:	52                   	push   %edx
f0117d8d:	68 ff ff 3f 00       	push   $0x3fffff
f0117d92:	ff 75 d8             	pushl  -0x28(%ebp)
f0117d95:	e8 9e 19 ff ff       	call   f0109738 <calculate_allocated_space>
f0117d9a:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117d9d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117da3:	85 c0                	test   %eax,%eax
f0117da5:	74 27                	je     f0117dce <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117da7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117dad:	83 ec 0c             	sub    $0xc,%esp
f0117db0:	6a 00                	push   $0x0
f0117db2:	50                   	push   %eax
f0117db3:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117db8:	68 84 07 00 00       	push   $0x784
f0117dbd:	68 42 c3 12 f0       	push   $0xf012c342
f0117dc2:	e8 f0 86 fe ff       	call   f01004b7 <_warn>
f0117dc7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117dca:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117dce:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117dd4:	85 c0                	test   %eax,%eax
f0117dd6:	74 27                	je     f0117dff <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117dd8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117dde:	83 ec 0c             	sub    $0xc,%esp
f0117de1:	6a 00                	push   $0x0
f0117de3:	50                   	push   %eax
f0117de4:	68 54 dd 12 f0       	push   $0xf012dd54
f0117de9:	68 89 07 00 00       	push   $0x789
f0117dee:	68 42 c3 12 f0       	push   $0xf012c342
f0117df3:	e8 bf 86 fe ff       	call   f01004b7 <_warn>
f0117df8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117dfb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117dff:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117e03:	74 04                	je     f0117e09 <test_calculate_allocated_space+0x677>
f0117e05:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117e09:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0117e0d:	83 ec 0c             	sub    $0xc,%esp
f0117e10:	68 f5 d6 12 f0       	push   $0xf012d6f5
f0117e15:	e8 52 91 fe ff       	call   f0100f6c <cprintf>
f0117e1a:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0117e1d:	83 ec 0c             	sub    $0xc,%esp
f0117e20:	68 14 dc 12 f0       	push   $0xf012dc14
f0117e25:	e8 42 91 fe ff       	call   f0100f6c <cprintf>
f0117e2a:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0117e2d:	83 ec 04             	sub    $0x4,%esp
f0117e30:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0117e36:	50                   	push   %eax
f0117e37:	68 ae ca 12 f0       	push   $0xf012caae
f0117e3c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117e42:	50                   	push   %eax
f0117e43:	e8 0c ad 00 00       	call   f0122b54 <strcconcat>
f0117e48:	83 c4 10             	add    $0x10,%esp
f0117e4b:	83 ec 0c             	sub    $0xc,%esp
f0117e4e:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0117e54:	50                   	push   %eax
f0117e55:	e8 82 a0 fe ff       	call   f0101edc <execute_command>
f0117e5a:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0117e5d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117e64:	00 00 00 
		num_pages = 0;
f0117e67:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117e6e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0117e71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117e74:	c1 e0 03             	shl    $0x3,%eax
f0117e77:	89 c2                	mov    %eax,%edx
f0117e79:	83 ec 0c             	sub    $0xc,%esp
f0117e7c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117e82:	50                   	push   %eax
f0117e83:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117e89:	50                   	push   %eax
f0117e8a:	52                   	push   %edx
f0117e8b:	6a 00                	push   $0x0
f0117e8d:	ff 75 d8             	pushl  -0x28(%ebp)
f0117e90:	e8 a3 18 ff ff       	call   f0109738 <calculate_allocated_space>
f0117e95:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0117e98:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0117e9f:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117ea6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117eac:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117eaf:	74 28                	je     f0117ed9 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0117eb1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117eb7:	83 ec 0c             	sub    $0xc,%esp
f0117eba:	ff 75 c8             	pushl  -0x38(%ebp)
f0117ebd:	50                   	push   %eax
f0117ebe:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117ec3:	68 a0 07 00 00       	push   $0x7a0
f0117ec8:	68 42 c3 12 f0       	push   $0xf012c342
f0117ecd:	e8 e5 85 fe ff       	call   f01004b7 <_warn>
f0117ed2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117ed5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117ed9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117edf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117ee2:	74 28                	je     f0117f0c <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117ee4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117eea:	83 ec 0c             	sub    $0xc,%esp
f0117eed:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117ef0:	50                   	push   %eax
f0117ef1:	68 54 dd 12 f0       	push   $0xf012dd54
f0117ef6:	68 a5 07 00 00       	push   $0x7a5
f0117efb:	68 42 c3 12 f0       	push   $0xf012c342
f0117f00:	e8 b2 85 fe ff       	call   f01004b7 <_warn>
f0117f05:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117f08:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117f0c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117f10:	74 04                	je     f0117f16 <test_calculate_allocated_space+0x784>
f0117f12:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117f16:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0117f1a:	83 ec 04             	sub    $0x4,%esp
f0117f1d:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0117f23:	50                   	push   %eax
f0117f24:	68 bb ca 12 f0       	push   $0xf012cabb
f0117f29:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117f2f:	50                   	push   %eax
f0117f30:	e8 1f ac 00 00       	call   f0122b54 <strcconcat>
f0117f35:	83 c4 10             	add    $0x10,%esp
f0117f38:	83 ec 0c             	sub    $0xc,%esp
f0117f3b:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0117f41:	50                   	push   %eax
f0117f42:	e8 95 9f fe ff       	call   f0101edc <execute_command>
f0117f47:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0117f4a:	83 ec 04             	sub    $0x4,%esp
f0117f4d:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0117f53:	50                   	push   %eax
f0117f54:	68 48 dc 12 f0       	push   $0xf012dc48
f0117f59:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117f5f:	50                   	push   %eax
f0117f60:	e8 ef ab 00 00       	call   f0122b54 <strcconcat>
f0117f65:	83 c4 10             	add    $0x10,%esp
f0117f68:	83 ec 0c             	sub    $0xc,%esp
f0117f6b:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0117f71:	50                   	push   %eax
f0117f72:	e8 65 9f fe ff       	call   f0101edc <execute_command>
f0117f77:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0117f7a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117f81:	00 00 00 
		num_pages = 0;
f0117f84:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117f8b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0117f8e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117f91:	c1 e0 03             	shl    $0x3,%eax
f0117f94:	89 c2                	mov    %eax,%edx
f0117f96:	83 ec 0c             	sub    $0xc,%esp
f0117f99:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117f9f:	50                   	push   %eax
f0117fa0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117fa6:	50                   	push   %eax
f0117fa7:	52                   	push   %edx
f0117fa8:	6a 00                	push   $0x0
f0117faa:	ff 75 d8             	pushl  -0x28(%ebp)
f0117fad:	e8 86 17 ff ff       	call   f0109738 <calculate_allocated_space>
f0117fb2:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0117fb5:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0117fbc:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117fc3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117fc9:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117fcc:	74 28                	je     f0117ff6 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0117fce:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117fd4:	83 ec 0c             	sub    $0xc,%esp
f0117fd7:	ff 75 c8             	pushl  -0x38(%ebp)
f0117fda:	50                   	push   %eax
f0117fdb:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0117fe0:	68 b6 07 00 00       	push   $0x7b6
f0117fe5:	68 42 c3 12 f0       	push   $0xf012c342
f0117fea:	e8 c8 84 fe ff       	call   f01004b7 <_warn>
f0117fef:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117ff2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117ff6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117ffc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117fff:	74 28                	je     f0118029 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0118001:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118007:	83 ec 0c             	sub    $0xc,%esp
f011800a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011800d:	50                   	push   %eax
f011800e:	68 54 dd 12 f0       	push   $0xf012dd54
f0118013:	68 bb 07 00 00       	push   $0x7bb
f0118018:	68 42 c3 12 f0       	push   $0xf012c342
f011801d:	e8 95 84 fe ff       	call   f01004b7 <_warn>
f0118022:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118025:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118029:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011802d:	74 04                	je     f0118033 <test_calculate_allocated_space+0x8a1>
f011802f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0118033:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0118037:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011803e:	00 00 00 
		num_pages = 0;
f0118041:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0118048:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011804b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011804e:	c1 e0 0a             	shl    $0xa,%eax
f0118051:	89 c2                	mov    %eax,%edx
f0118053:	83 ec 0c             	sub    $0xc,%esp
f0118056:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011805c:	50                   	push   %eax
f011805d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0118063:	50                   	push   %eax
f0118064:	52                   	push   %edx
f0118065:	6a 00                	push   $0x0
f0118067:	ff 75 d8             	pushl  -0x28(%ebp)
f011806a:	e8 c9 16 ff ff       	call   f0109738 <calculate_allocated_space>
f011806f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0118072:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0118079:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0118080:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0118086:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0118089:	74 28                	je     f01180b3 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011808b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0118091:	83 ec 0c             	sub    $0xc,%esp
f0118094:	ff 75 c8             	pushl  -0x38(%ebp)
f0118097:	50                   	push   %eax
f0118098:	68 f4 dc 12 f0       	push   $0xf012dcf4
f011809d:	68 c9 07 00 00       	push   $0x7c9
f01180a2:	68 42 c3 12 f0       	push   $0xf012c342
f01180a7:	e8 0b 84 fe ff       	call   f01004b7 <_warn>
f01180ac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01180af:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01180b3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01180b9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01180bc:	74 28                	je     f01180e6 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01180be:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01180c4:	83 ec 0c             	sub    $0xc,%esp
f01180c7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01180ca:	50                   	push   %eax
f01180cb:	68 54 dd 12 f0       	push   $0xf012dd54
f01180d0:	68 ce 07 00 00       	push   $0x7ce
f01180d5:	68 42 c3 12 f0       	push   $0xf012c342
f01180da:	e8 d8 83 fe ff       	call   f01004b7 <_warn>
f01180df:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01180e2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01180e6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01180ea:	74 04                	je     f01180f0 <test_calculate_allocated_space+0x95e>
f01180ec:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01180f0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01180f4:	83 ec 04             	sub    $0x4,%esp
f01180f7:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01180fd:	50                   	push   %eax
f01180fe:	68 54 dc 12 f0       	push   $0xf012dc54
f0118103:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0118109:	50                   	push   %eax
f011810a:	e8 45 aa 00 00       	call   f0122b54 <strcconcat>
f011810f:	83 c4 10             	add    $0x10,%esp
f0118112:	83 ec 0c             	sub    $0xc,%esp
f0118115:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011811b:	50                   	push   %eax
f011811c:	e8 bb 9d fe ff       	call   f0101edc <execute_command>
f0118121:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0118124:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011812b:	00 00 00 
		num_pages = 0;
f011812e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0118135:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0118138:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011813b:	89 c2                	mov    %eax,%edx
f011813d:	01 d2                	add    %edx,%edx
f011813f:	01 d0                	add    %edx,%eax
f0118141:	05 00 18 00 00       	add    $0x1800,%eax
f0118146:	89 c2                	mov    %eax,%edx
f0118148:	83 ec 0c             	sub    $0xc,%esp
f011814b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0118151:	50                   	push   %eax
f0118152:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0118158:	50                   	push   %eax
f0118159:	52                   	push   %edx
f011815a:	68 00 18 00 00       	push   $0x1800
f011815f:	ff 75 d8             	pushl  -0x28(%ebp)
f0118162:	e8 d1 15 ff ff       	call   f0109738 <calculate_allocated_space>
f0118167:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011816a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0118171:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0118178:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011817e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0118181:	74 28                	je     f01181ab <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0118183:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0118189:	83 ec 0c             	sub    $0xc,%esp
f011818c:	ff 75 c8             	pushl  -0x38(%ebp)
f011818f:	50                   	push   %eax
f0118190:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0118195:	68 df 07 00 00       	push   $0x7df
f011819a:	68 42 c3 12 f0       	push   $0xf012c342
f011819f:	e8 13 83 fe ff       	call   f01004b7 <_warn>
f01181a4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01181a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01181ab:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01181b1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01181b4:	74 28                	je     f01181de <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01181b6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01181bc:	83 ec 0c             	sub    $0xc,%esp
f01181bf:	ff 75 c4             	pushl  -0x3c(%ebp)
f01181c2:	50                   	push   %eax
f01181c3:	68 54 dd 12 f0       	push   $0xf012dd54
f01181c8:	68 e4 07 00 00       	push   $0x7e4
f01181cd:	68 42 c3 12 f0       	push   $0xf012c342
f01181d2:	e8 e0 82 fe ff       	call   f01004b7 <_warn>
f01181d7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01181da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01181de:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01181e2:	74 04                	je     f01181e8 <test_calculate_allocated_space+0xa56>
f01181e4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01181e8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01181ec:	83 ec 04             	sub    $0x4,%esp
f01181ef:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01181f5:	50                   	push   %eax
f01181f6:	68 14 cd 12 f0       	push   $0xf012cd14
f01181fb:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0118201:	50                   	push   %eax
f0118202:	e8 4d a9 00 00       	call   f0122b54 <strcconcat>
f0118207:	83 c4 10             	add    $0x10,%esp
f011820a:	83 ec 0c             	sub    $0xc,%esp
f011820d:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0118213:	50                   	push   %eax
f0118214:	e8 c3 9c fe ff       	call   f0101edc <execute_command>
f0118219:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f011821c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0118223:	00 00 00 
		num_pages = 0;
f0118226:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011822d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0118230:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0118233:	89 d0                	mov    %edx,%eax
f0118235:	c1 e0 02             	shl    $0x2,%eax
f0118238:	01 d0                	add    %edx,%eax
f011823a:	01 c0                	add    %eax,%eax
f011823c:	05 00 00 40 00       	add    $0x400000,%eax
f0118241:	89 c2                	mov    %eax,%edx
f0118243:	83 ec 0c             	sub    $0xc,%esp
f0118246:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011824c:	50                   	push   %eax
f011824d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0118253:	50                   	push   %eax
f0118254:	52                   	push   %edx
f0118255:	68 00 00 40 00       	push   $0x400000
f011825a:	ff 75 d8             	pushl  -0x28(%ebp)
f011825d:	e8 d6 14 ff ff       	call   f0109738 <calculate_allocated_space>
f0118262:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0118265:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011826c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0118273:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0118279:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011827c:	74 28                	je     f01182a6 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011827e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0118284:	83 ec 0c             	sub    $0xc,%esp
f0118287:	ff 75 c8             	pushl  -0x38(%ebp)
f011828a:	50                   	push   %eax
f011828b:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0118290:	68 f4 07 00 00       	push   $0x7f4
f0118295:	68 42 c3 12 f0       	push   $0xf012c342
f011829a:	e8 18 82 fe ff       	call   f01004b7 <_warn>
f011829f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01182a2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01182a6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01182ac:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01182af:	74 28                	je     f01182d9 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01182b1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01182b7:	83 ec 0c             	sub    $0xc,%esp
f01182ba:	ff 75 c4             	pushl  -0x3c(%ebp)
f01182bd:	50                   	push   %eax
f01182be:	68 54 dd 12 f0       	push   $0xf012dd54
f01182c3:	68 f9 07 00 00       	push   $0x7f9
f01182c8:	68 42 c3 12 f0       	push   $0xf012c342
f01182cd:	e8 e5 81 fe ff       	call   f01004b7 <_warn>
f01182d2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01182d5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01182d9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01182dd:	74 04                	je     f01182e3 <test_calculate_allocated_space+0xb51>
f01182df:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01182e3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01182e7:	83 ec 04             	sub    $0x4,%esp
f01182ea:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01182f0:	50                   	push   %eax
f01182f1:	68 1e cd 12 f0       	push   $0xf012cd1e
f01182f6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01182fc:	50                   	push   %eax
f01182fd:	e8 52 a8 00 00       	call   f0122b54 <strcconcat>
f0118302:	83 c4 10             	add    $0x10,%esp
f0118305:	83 ec 0c             	sub    $0xc,%esp
f0118308:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011830e:	50                   	push   %eax
f011830f:	e8 c8 9b fe ff       	call   f0101edc <execute_command>
f0118314:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0118317:	83 ec 04             	sub    $0x4,%esp
f011831a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0118320:	50                   	push   %eax
f0118321:	68 5c dc 12 f0       	push   $0xf012dc5c
f0118326:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011832c:	50                   	push   %eax
f011832d:	e8 22 a8 00 00       	call   f0122b54 <strcconcat>
f0118332:	83 c4 10             	add    $0x10,%esp
f0118335:	83 ec 0c             	sub    $0xc,%esp
f0118338:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011833e:	50                   	push   %eax
f011833f:	e8 98 9b fe ff       	call   f0101edc <execute_command>
f0118344:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0118347:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011834e:	00 00 00 
		num_pages = 0;
f0118351:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0118358:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011835b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011835e:	05 00 00 38 00       	add    $0x380000,%eax
f0118363:	01 c0                	add    %eax,%eax
f0118365:	89 c2                	mov    %eax,%edx
f0118367:	83 ec 0c             	sub    $0xc,%esp
f011836a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0118370:	50                   	push   %eax
f0118371:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0118377:	50                   	push   %eax
f0118378:	52                   	push   %edx
f0118379:	68 00 00 70 00       	push   $0x700000
f011837e:	ff 75 d8             	pushl  -0x28(%ebp)
f0118381:	e8 b2 13 ff ff       	call   f0109738 <calculate_allocated_space>
f0118386:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0118389:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0118390:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0118397:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011839d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01183a0:	74 28                	je     f01183ca <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01183a2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01183a8:	83 ec 0c             	sub    $0xc,%esp
f01183ab:	ff 75 c8             	pushl  -0x38(%ebp)
f01183ae:	50                   	push   %eax
f01183af:	68 f4 dc 12 f0       	push   $0xf012dcf4
f01183b4:	68 0b 08 00 00       	push   $0x80b
f01183b9:	68 42 c3 12 f0       	push   $0xf012c342
f01183be:	e8 f4 80 fe ff       	call   f01004b7 <_warn>
f01183c3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01183c6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01183ca:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01183d0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01183d3:	74 28                	je     f01183fd <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01183d5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01183db:	83 ec 0c             	sub    $0xc,%esp
f01183de:	ff 75 c4             	pushl  -0x3c(%ebp)
f01183e1:	50                   	push   %eax
f01183e2:	68 54 dd 12 f0       	push   $0xf012dd54
f01183e7:	68 10 08 00 00       	push   $0x810
f01183ec:	68 42 c3 12 f0       	push   $0xf012c342
f01183f1:	e8 c1 80 fe ff       	call   f01004b7 <_warn>
f01183f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01183f9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01183fd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118401:	74 04                	je     f0118407 <test_calculate_allocated_space+0xc75>
f0118403:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0118407:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f011840b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0118412:	00 00 00 
		num_pages = 0;
f0118415:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011841c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011841f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118422:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0118427:	89 c2                	mov    %eax,%edx
f0118429:	83 ec 0c             	sub    $0xc,%esp
f011842c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0118432:	50                   	push   %eax
f0118433:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0118439:	50                   	push   %eax
f011843a:	52                   	push   %edx
f011843b:	68 ff ff 3f 00       	push   $0x3fffff
f0118440:	ff 75 d8             	pushl  -0x28(%ebp)
f0118443:	e8 f0 12 ff ff       	call   f0109738 <calculate_allocated_space>
f0118448:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011844b:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0118452:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0118459:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011845f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0118462:	74 28                	je     f011848c <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0118464:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011846a:	83 ec 0c             	sub    $0xc,%esp
f011846d:	ff 75 c8             	pushl  -0x38(%ebp)
f0118470:	50                   	push   %eax
f0118471:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0118476:	68 1e 08 00 00       	push   $0x81e
f011847b:	68 42 c3 12 f0       	push   $0xf012c342
f0118480:	e8 32 80 fe ff       	call   f01004b7 <_warn>
f0118485:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118488:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011848c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118492:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118495:	74 28                	je     f01184bf <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0118497:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011849d:	83 ec 0c             	sub    $0xc,%esp
f01184a0:	ff 75 c4             	pushl  -0x3c(%ebp)
f01184a3:	50                   	push   %eax
f01184a4:	68 54 dd 12 f0       	push   $0xf012dd54
f01184a9:	68 23 08 00 00       	push   $0x823
f01184ae:	68 42 c3 12 f0       	push   $0xf012c342
f01184b3:	e8 ff 7f fe ff       	call   f01004b7 <_warn>
f01184b8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01184bb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01184bf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01184c3:	74 04                	je     f01184c9 <test_calculate_allocated_space+0xd37>
f01184c5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01184c9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01184cd:	83 ec 0c             	sub    $0xc,%esp
f01184d0:	68 cf cc 12 f0       	push   $0xf012cccf
f01184d5:	e8 92 8a fe ff       	call   f0100f6c <cprintf>
f01184da:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f01184dd:	83 ec 08             	sub    $0x8,%esp
f01184e0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01184e3:	68 b0 dd 12 f0       	push   $0xf012ddb0
f01184e8:	e8 7f 8a fe ff       	call   f0100f6c <cprintf>
f01184ed:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01184f0:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01184f4:	75 10                	jne    f0118506 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f01184f6:	83 ec 0c             	sub    $0xc,%esp
f01184f9:	68 f0 dd 12 f0       	push   $0xf012ddf0
f01184fe:	e8 69 8a fe ff       	call   f0100f6c <cprintf>
f0118503:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0118506:	a1 84 3b 5a f0       	mov    0xf05a3b84,%eax
f011850b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011850e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118511:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0118514:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0118519:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011851c:	5b                   	pop    %ebx
f011851d:	5e                   	pop    %esi
f011851e:	5f                   	pop    %edi
f011851f:	5d                   	pop    %ebp
f0118520:	c3                   	ret    

f0118521 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0118521:	55                   	push   %ebp
f0118522:	89 e5                	mov    %esp,%ebp
f0118524:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0118527:	8b 45 10             	mov    0x10(%ebp),%eax
f011852a:	ba 01 00 00 00       	mov    $0x1,%edx
f011852f:	88 c1                	mov    %al,%cl
f0118531:	d3 e2                	shl    %cl,%edx
f0118533:	89 d0                	mov    %edx,%eax
f0118535:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0118538:	8b 45 0c             	mov    0xc(%ebp),%eax
f011853b:	c1 e8 16             	shr    $0x16,%eax
f011853e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118545:	8b 45 08             	mov    0x8(%ebp),%eax
f0118548:	01 d0                	add    %edx,%eax
f011854a:	8b 00                	mov    (%eax),%eax
f011854c:	83 e0 01             	and    $0x1,%eax
f011854f:	85 c0                	test   %eax,%eax
f0118551:	75 07                	jne    f011855a <CB+0x39>
f0118553:	b8 00 00 00 00       	mov    $0x0,%eax
f0118558:	eb 76                	jmp    f01185d0 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011855a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011855d:	c1 e8 16             	shr    $0x16,%eax
f0118560:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118567:	8b 45 08             	mov    0x8(%ebp),%eax
f011856a:	01 d0                	add    %edx,%eax
f011856c:	8b 00                	mov    (%eax),%eax
f011856e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118573:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118576:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118579:	c1 e8 0c             	shr    $0xc,%eax
f011857c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011857f:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0118584:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0118587:	72 17                	jb     f01185a0 <CB+0x7f>
f0118589:	ff 75 f0             	pushl  -0x10(%ebp)
f011858c:	68 3c de 12 f0       	push   $0xf012de3c
f0118591:	68 3e 08 00 00       	push   $0x83e
f0118596:	68 42 c3 12 f0       	push   $0xf012c342
f011859b:	e8 7a 7d fe ff       	call   f010031a <_panic>
f01185a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01185a3:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01185a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f01185ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01185ae:	c1 e8 0c             	shr    $0xc,%eax
f01185b1:	25 ff 03 00 00       	and    $0x3ff,%eax
f01185b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01185bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01185c0:	01 d0                	add    %edx,%eax
f01185c2:	8b 00                	mov    (%eax),%eax
f01185c4:	23 45 f4             	and    -0xc(%ebp),%eax
f01185c7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01185ca:	0f 94 c0             	sete   %al
f01185cd:	0f b6 c0             	movzbl %al,%eax
}
f01185d0:	c9                   	leave  
f01185d1:	c3                   	ret    

f01185d2 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f01185d2:	55                   	push   %ebp
f01185d3:	89 e5                	mov    %esp,%ebp
f01185d5:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01185d8:	8b 45 10             	mov    0x10(%ebp),%eax
f01185db:	ba 01 00 00 00       	mov    $0x1,%edx
f01185e0:	88 c1                	mov    %al,%cl
f01185e2:	d3 e2                	shl    %cl,%edx
f01185e4:	89 d0                	mov    %edx,%eax
f01185e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01185e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01185ec:	c1 e8 16             	shr    $0x16,%eax
f01185ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01185f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01185f9:	01 d0                	add    %edx,%eax
f01185fb:	8b 00                	mov    (%eax),%eax
f01185fd:	83 e0 01             	and    $0x1,%eax
f0118600:	85 c0                	test   %eax,%eax
f0118602:	75 0a                	jne    f011860e <SB+0x3c>
f0118604:	b8 00 00 00 00       	mov    $0x0,%eax
f0118609:	e9 cd 00 00 00       	jmp    f01186db <SB+0x109>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011860e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118611:	c1 e8 16             	shr    $0x16,%eax
f0118614:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011861b:	8b 45 08             	mov    0x8(%ebp),%eax
f011861e:	01 d0                	add    %edx,%eax
f0118620:	8b 00                	mov    (%eax),%eax
f0118622:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118627:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011862a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011862d:	c1 e8 0c             	shr    $0xc,%eax
f0118630:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0118633:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0118638:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011863b:	72 17                	jb     f0118654 <SB+0x82>
f011863d:	ff 75 f0             	pushl  -0x10(%ebp)
f0118640:	68 3c de 12 f0       	push   $0xf012de3c
f0118645:	68 46 08 00 00       	push   $0x846
f011864a:	68 42 c3 12 f0       	push   $0xf012c342
f011864f:	e8 c6 7c fe ff       	call   f010031a <_panic>
f0118654:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118657:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011865c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
f011865f:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
f0118663:	74 3c                	je     f01186a1 <SB+0xcf>
f0118665:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118668:	c1 e8 0c             	shr    $0xc,%eax
f011866b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0118670:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118677:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011867a:	01 d0                	add    %edx,%eax
f011867c:	8b 55 0c             	mov    0xc(%ebp),%edx
f011867f:	c1 ea 0c             	shr    $0xc,%edx
f0118682:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118688:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f011868f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0118692:	01 ca                	add    %ecx,%edx
f0118694:	8b 12                	mov    (%edx),%edx
f0118696:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118699:	f7 d1                	not    %ecx
f011869b:	21 ca                	and    %ecx,%edx
f011869d:	89 10                	mov    %edx,(%eax)
f011869f:	eb 35                	jmp    f01186d6 <SB+0x104>
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
f01186a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01186a4:	c1 e8 0c             	shr    $0xc,%eax
f01186a7:	25 ff 03 00 00       	and    $0x3ff,%eax
f01186ac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01186b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01186b6:	01 c2                	add    %eax,%edx
f01186b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01186bb:	c1 e8 0c             	shr    $0xc,%eax
f01186be:	25 ff 03 00 00       	and    $0x3ff,%eax
f01186c3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01186ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01186cd:	01 c8                	add    %ecx,%eax
f01186cf:	8b 00                	mov    (%eax),%eax
f01186d1:	0b 45 f4             	or     -0xc(%ebp),%eax
f01186d4:	89 02                	mov    %eax,(%edx)
	return 0;
f01186d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01186db:	c9                   	leave  
f01186dc:	c3                   	ret    

f01186dd <CPs>:
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f01186dd:	55                   	push   %ebp
f01186de:	89 e5                	mov    %esp,%ebp
f01186e0:	83 ec 28             	sub    $0x28,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01186e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01186e6:	c1 e8 16             	shr    $0x16,%eax
f01186e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01186f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01186f3:	01 d0                	add    %edx,%eax
f01186f5:	8b 00                	mov    (%eax),%eax
f01186f7:	83 e0 01             	and    $0x1,%eax
f01186fa:	85 c0                	test   %eax,%eax
f01186fc:	75 0a                	jne    f0118708 <CPs+0x2b>
f01186fe:	b8 00 00 00 00       	mov    $0x0,%eax
f0118703:	e9 b8 00 00 00       	jmp    f01187c0 <CPs+0xe3>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0118708:	8b 45 0c             	mov    0xc(%ebp),%eax
f011870b:	c1 e8 16             	shr    $0x16,%eax
f011870e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118715:	8b 45 08             	mov    0x8(%ebp),%eax
f0118718:	01 d0                	add    %edx,%eax
f011871a:	8b 00                	mov    (%eax),%eax
f011871c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118721:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118724:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118727:	c1 e8 0c             	shr    $0xc,%eax
f011872a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011872d:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0118732:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0118735:	72 17                	jb     f011874e <CPs+0x71>
f0118737:	ff 75 f0             	pushl  -0x10(%ebp)
f011873a:	68 3c de 12 f0       	push   $0xf012de3c
f011873f:	68 4f 08 00 00       	push   $0x84f
f0118744:	68 42 c3 12 f0       	push   $0xf012c342
f0118749:	e8 cc 7b fe ff       	call   f010031a <_panic>
f011874e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118751:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0118756:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (int i = 0 ; i < 12 ; i++)
f0118759:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118760:	eb 53                	jmp    f01187b5 <CPs+0xd8>
	{
		uint32 mask = 1<<i;
f0118762:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118765:	ba 01 00 00 00       	mov    $0x1,%edx
f011876a:	88 c1                	mov    %al,%cl
f011876c:	d3 e2                	shl    %cl,%edx
f011876e:	89 d0                	mov    %edx,%eax
f0118770:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (!(which & mask))	continue ;
f0118773:	8b 45 14             	mov    0x14(%ebp),%eax
f0118776:	23 45 e4             	and    -0x1c(%ebp),%eax
f0118779:	85 c0                	test   %eax,%eax
f011877b:	74 34                	je     f01187b1 <CPs+0xd4>
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
f011877d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118780:	c1 e8 0c             	shr    $0xc,%eax
f0118783:	25 ff 03 00 00       	and    $0x3ff,%eax
f0118788:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011878f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118792:	01 d0                	add    %edx,%eax
f0118794:	8b 00                	mov    (%eax),%eax
f0118796:	33 45 10             	xor    0x10(%ebp),%eax
f0118799:	23 45 e4             	and    -0x1c(%ebp),%eax
f011879c:	85 c0                	test   %eax,%eax
f011879e:	0f 94 c0             	sete   %al
f01187a1:	88 45 e3             	mov    %al,-0x1d(%ebp)
		if (!c) return 0;
f01187a4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01187a8:	75 08                	jne    f01187b2 <CPs+0xd5>
f01187aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01187af:	eb 0f                	jmp    f01187c0 <CPs+0xe3>
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
	{
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
f01187b1:	90                   	nop
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
f01187b2:	ff 45 f4             	incl   -0xc(%ebp)
f01187b5:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
f01187b9:	7e a7                	jle    f0118762 <CPs+0x85>
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
		if (!c) return 0;
	}
	return 1;
f01187bb:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01187c0:	c9                   	leave  
f01187c1:	c3                   	ret    

f01187c2 <CA>:

int CA(uint32 *ptr_dir, uint32 va)
{
f01187c2:	55                   	push   %ebp
f01187c3:	89 e5                	mov    %esp,%ebp
f01187c5:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01187c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01187cb:	c1 e8 16             	shr    $0x16,%eax
f01187ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01187d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01187d8:	01 d0                	add    %edx,%eax
f01187da:	8b 00                	mov    (%eax),%eax
f01187dc:	83 e0 01             	and    $0x1,%eax
f01187df:	85 c0                	test   %eax,%eax
f01187e1:	75 07                	jne    f01187ea <CA+0x28>
f01187e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01187e8:	eb 6f                	jmp    f0118859 <CA+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01187ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01187ed:	c1 e8 16             	shr    $0x16,%eax
f01187f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01187f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01187fa:	01 d0                	add    %edx,%eax
f01187fc:	8b 00                	mov    (%eax),%eax
f01187fe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118803:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0118806:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118809:	c1 e8 0c             	shr    $0xc,%eax
f011880c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011880f:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0118814:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0118817:	72 17                	jb     f0118830 <CA+0x6e>
f0118819:	ff 75 f4             	pushl  -0xc(%ebp)
f011881c:	68 3c de 12 f0       	push   $0xf012de3c
f0118821:	68 5e 08 00 00       	push   $0x85e
f0118826:	68 42 c3 12 f0       	push   $0xf012c342
f011882b:	e8 ea 7a fe ff       	call   f010031a <_panic>
f0118830:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118833:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0118838:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
f011883b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011883e:	c1 e8 0c             	shr    $0xc,%eax
f0118841:	25 ff 03 00 00       	and    $0x3ff,%eax
f0118846:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011884d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118850:	01 d0                	add    %edx,%eax
f0118852:	8b 00                	mov    (%eax),%eax
f0118854:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0118859:	c9                   	leave  
f011885a:	c3                   	ret    

f011885b <CE>:

int CE(uint32 *_d, uint32 va)
{
f011885b:	55                   	push   %ebp
f011885c:	89 e5                	mov    %esp,%ebp
f011885e:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0118861:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118864:	c1 e8 16             	shr    $0x16,%eax
f0118867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011886e:	8b 45 08             	mov    0x8(%ebp),%eax
f0118871:	01 d0                	add    %edx,%eax
f0118873:	8b 00                	mov    (%eax),%eax
f0118875:	83 e0 01             	and    $0x1,%eax
f0118878:	85 c0                	test   %eax,%eax
f011887a:	75 07                	jne    f0118883 <CE+0x28>
f011887c:	b8 00 00 00 00       	mov    $0x0,%eax
f0118881:	eb 7a                	jmp    f01188fd <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0118883:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118886:	c1 e8 16             	shr    $0x16,%eax
f0118889:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118890:	8b 45 08             	mov    0x8(%ebp),%eax
f0118893:	01 d0                	add    %edx,%eax
f0118895:	8b 00                	mov    (%eax),%eax
f0118897:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011889c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011889f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188a2:	c1 e8 0c             	shr    $0xc,%eax
f01188a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01188a8:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f01188ad:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01188b0:	72 17                	jb     f01188c9 <CE+0x6e>
f01188b2:	ff 75 f4             	pushl  -0xc(%ebp)
f01188b5:	68 3c de 12 f0       	push   $0xf012de3c
f01188ba:	68 65 08 00 00       	push   $0x865
f01188bf:	68 42 c3 12 f0       	push   $0xf012c342
f01188c4:	e8 51 7a fe ff       	call   f010031a <_panic>
f01188c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01188d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f01188d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01188d7:	c1 e8 0c             	shr    $0xc,%eax
f01188da:	25 ff 03 00 00       	and    $0x3ff,%eax
f01188df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01188e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01188e9:	01 d0                	add    %edx,%eax
f01188eb:	8b 00                	mov    (%eax),%eax
f01188ed:	85 c0                	test   %eax,%eax
f01188ef:	74 07                	je     f01188f8 <CE+0x9d>
f01188f1:	b8 00 00 00 00       	mov    $0x0,%eax
f01188f6:	eb 05                	jmp    f01188fd <CE+0xa2>
	return 1;
f01188f8:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01188fd:	c9                   	leave  
f01188fe:	c3                   	ret    

f01188ff <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f01188ff:	55                   	push   %ebp
f0118900:	89 e5                	mov    %esp,%ebp
f0118902:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 pd_entry = pd[((((uint32) (va)) >> 22) & 0x3FF)];
f0118905:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118908:	c1 e8 16             	shr    $0x16,%eax
f011890b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118912:	8b 45 08             	mov    0x8(%ebp),%eax
f0118915:	01 d0                	add    %edx,%eax
f0118917:	8b 00                	mov    (%eax),%eax
f0118919:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if ( (pd_entry & 1) == 1)
f011891c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011891f:	83 e0 01             	and    $0x1,%eax
f0118922:	85 c0                	test   %eax,%eax
f0118924:	0f 84 92 00 00 00    	je     f01189bc <CP+0xbd>
	{
		uint32 *t = NULL;
f011892a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		t = (STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(pd_entry)));
f0118931:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118934:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118939:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011893c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011893f:	c1 e8 0c             	shr    $0xc,%eax
f0118942:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0118945:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f011894a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f011894d:	72 17                	jb     f0118966 <CP+0x67>
f011894f:	ff 75 ec             	pushl  -0x14(%ebp)
f0118952:	68 3c de 12 f0       	push   $0xf012de3c
f0118957:	68 71 08 00 00       	push   $0x871
f011895c:	68 42 c3 12 f0       	push   $0xf012c342
f0118961:	e8 b4 79 fe ff       	call   f010031a <_panic>
f0118966:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118969:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011896e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf("va =%x, ENTRY after PERM = %x, perm to set = %x, perm to clear = %x\n", va, t[PTX(va)]&0x00000FFF, ps, pc);

		if (((t[((((uint32) (va)) >> 12) & 0x3FF)]&ps) == ps)&&((~(t[((((uint32) (va)) >> 12) & 0x3FF)])&pc) == pc))
f0118971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118974:	c1 e8 0c             	shr    $0xc,%eax
f0118977:	25 ff 03 00 00       	and    $0x3ff,%eax
f011897c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118983:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118986:	01 d0                	add    %edx,%eax
f0118988:	8b 00                	mov    (%eax),%eax
f011898a:	23 45 10             	and    0x10(%ebp),%eax
f011898d:	3b 45 10             	cmp    0x10(%ebp),%eax
f0118990:	75 2a                	jne    f01189bc <CP+0xbd>
f0118992:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118995:	c1 e8 0c             	shr    $0xc,%eax
f0118998:	25 ff 03 00 00       	and    $0x3ff,%eax
f011899d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01189a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01189a7:	01 d0                	add    %edx,%eax
f01189a9:	8b 00                	mov    (%eax),%eax
f01189ab:	f7 d0                	not    %eax
f01189ad:	23 45 14             	and    0x14(%ebp),%eax
f01189b0:	3b 45 14             	cmp    0x14(%ebp),%eax
f01189b3:	75 07                	jne    f01189bc <CP+0xbd>
			return 1;
f01189b5:	b8 01 00 00 00       	mov    $0x1,%eax
f01189ba:	eb 05                	jmp    f01189c1 <CP+0xc2>
	}
	return 0;
f01189bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01189c1:	c9                   	leave  
f01189c2:	c3                   	ret    

f01189c3 <GP>:

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f01189c3:	55                   	push   %ebp
f01189c4:	89 e5                	mov    %esp,%ebp
f01189c6:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01189c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01189cc:	c1 e8 16             	shr    $0x16,%eax
f01189cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01189d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01189d9:	01 d0                	add    %edx,%eax
f01189db:	8b 00                	mov    (%eax),%eax
f01189dd:	83 e0 01             	and    $0x1,%eax
f01189e0:	85 c0                	test   %eax,%eax
f01189e2:	75 07                	jne    f01189eb <GP+0x28>
f01189e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01189e9:	eb 6f                	jmp    f0118a5a <GP+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01189eb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01189ee:	c1 e8 16             	shr    $0x16,%eax
f01189f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01189f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01189fb:	01 d0                	add    %edx,%eax
f01189fd:	8b 00                	mov    (%eax),%eax
f01189ff:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118a04:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0118a07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118a0a:	c1 e8 0c             	shr    $0xc,%eax
f0118a0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118a10:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0118a15:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0118a18:	72 17                	jb     f0118a31 <GP+0x6e>
f0118a1a:	ff 75 f4             	pushl  -0xc(%ebp)
f0118a1d:	68 3c de 12 f0       	push   $0xf012de3c
f0118a22:	68 7e 08 00 00       	push   $0x87e
f0118a27:	68 42 c3 12 f0       	push   $0xf012c342
f0118a2c:	e8 e9 78 fe ff       	call   f010031a <_panic>
f0118a31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118a34:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0118a39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
f0118a3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118a3f:	c1 e8 0c             	shr    $0xc,%eax
f0118a42:	25 ff 03 00 00       	and    $0x3ff,%eax
f0118a47:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118a4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a51:	01 d0                	add    %edx,%eax
f0118a53:	8b 00                	mov    (%eax),%eax
f0118a55:	25 ff 0f 00 00       	and    $0xfff,%eax
}
f0118a5a:	c9                   	leave  
f0118a5b:	c3                   	ret    

f0118a5c <ClearUserSpace>:

void ClearUserSpace(uint32 *ptr_dir)
{
f0118a5c:	55                   	push   %ebp
f0118a5d:	89 e5                	mov    %esp,%ebp
f0118a5f:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0118a62:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0118a69:	eb 18                	jmp    f0118a83 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0118a6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0118a6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118a75:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a78:	01 d0                	add    %edx,%eax
f0118a7a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0118a80:	ff 45 fc             	incl   -0x4(%ebp)
f0118a83:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0118a86:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0118a8b:	76 de                	jbe    f0118a6b <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0118a8d:	90                   	nop
f0118a8e:	c9                   	leave  
f0118a8f:	c3                   	ret    

f0118a90 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0118a90:	55                   	push   %ebp
f0118a91:	89 e5                	mov    %esp,%ebp
f0118a93:	83 ec 38             	sub    $0x38,%esp
f0118a96:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0118a99:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0118a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0118aa7:	8b 45 10             	mov    0x10(%ebp),%eax
f0118aaa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118aaf:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0118ab2:	e9 ea 01 00 00       	jmp    f0118ca1 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0118ab7:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0118abb:	74 44                	je     f0118b01 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0118abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ac0:	83 ec 04             	sub    $0x4,%esp
f0118ac3:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0118ac6:	52                   	push   %edx
f0118ac7:	50                   	push   %eax
f0118ac8:	ff 75 08             	pushl  0x8(%ebp)
f0118acb:	e8 fa fb fe ff       	call   f01086ca <get_frame_info>
f0118ad0:	83 c4 10             	add    $0x10,%esp
f0118ad3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0118ad6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118ad9:	85 c0                	test   %eax,%eax
f0118adb:	75 24                	jne    f0118b01 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0118add:	83 ec 04             	sub    $0x4,%esp
f0118ae0:	68 6c de 12 f0       	push   $0xf012de6c
f0118ae5:	68 99 08 00 00       	push   $0x899
f0118aea:	68 42 c3 12 f0       	push   $0xf012c342
f0118aef:	e8 c3 79 fe ff       	call   f01004b7 <_warn>
f0118af4:	83 c4 10             	add    $0x10,%esp
				return 0;
f0118af7:	b8 00 00 00 00       	mov    $0x0,%eax
f0118afc:	e9 b6 01 00 00       	jmp    f0118cb7 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0118b01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118b04:	83 ec 04             	sub    $0x4,%esp
f0118b07:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0118b0a:	52                   	push   %edx
f0118b0b:	50                   	push   %eax
f0118b0c:	ff 75 08             	pushl  0x8(%ebp)
f0118b0f:	e8 b6 fb fe ff       	call   f01086ca <get_frame_info>
f0118b14:	83 c4 10             	add    $0x10,%esp
f0118b17:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0118b1a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118b1d:	85 c0                	test   %eax,%eax
f0118b1f:	75 24                	jne    f0118b45 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0118b21:	83 ec 04             	sub    $0x4,%esp
f0118b24:	68 98 de 12 f0       	push   $0xf012de98
f0118b29:	68 a0 08 00 00       	push   $0x8a0
f0118b2e:	68 42 c3 12 f0       	push   $0xf012c342
f0118b33:	e8 7f 79 fe ff       	call   f01004b7 <_warn>
f0118b38:	83 c4 10             	add    $0x10,%esp
			return 0;
f0118b3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0118b40:	e9 72 01 00 00       	jmp    f0118cb7 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0118b45:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0118b49:	75 70                	jne    f0118bbb <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0118b4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118b4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118b51:	c1 ea 0c             	shr    $0xc,%edx
f0118b54:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118b5a:	c1 e2 02             	shl    $0x2,%edx
f0118b5d:	01 d0                	add    %edx,%eax
f0118b5f:	8b 00                	mov    (%eax),%eax
f0118b61:	c1 e8 0c             	shr    $0xc,%eax
f0118b64:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0118b67:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118b6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0118b6d:	c1 ea 0c             	shr    $0xc,%edx
f0118b70:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118b76:	c1 e2 02             	shl    $0x2,%edx
f0118b79:	01 d0                	add    %edx,%eax
f0118b7b:	8b 00                	mov    (%eax),%eax
f0118b7d:	c1 e8 0c             	shr    $0xc,%eax
f0118b80:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0118b83:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118b86:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0118b89:	74 30                	je     f0118bbb <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0118b8b:	83 ec 04             	sub    $0x4,%esp
f0118b8e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118b91:	ff 75 e8             	pushl  -0x18(%ebp)
f0118b94:	ff 75 f0             	pushl  -0x10(%ebp)
f0118b97:	ff 75 f4             	pushl  -0xc(%ebp)
f0118b9a:	68 c4 de 12 f0       	push   $0xf012dec4
f0118b9f:	68 aa 08 00 00       	push   $0x8aa
f0118ba4:	68 42 c3 12 f0       	push   $0xf012c342
f0118ba9:	e8 09 79 fe ff       	call   f01004b7 <_warn>
f0118bae:	83 c4 20             	add    $0x20,%esp
				return 0;
f0118bb1:	b8 00 00 00 00       	mov    $0x0,%eax
f0118bb6:	e9 fc 00 00 00       	jmp    f0118cb7 <CCP+0x227>
			}
		}
		if (ref != -1)
f0118bbb:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0118bbf:	74 52                	je     f0118c13 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0118bc1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118bc5:	74 0e                	je     f0118bd5 <CCP+0x145>
f0118bc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118bca:	8b 40 08             	mov    0x8(%eax),%eax
f0118bcd:	0f b7 c0             	movzwl %ax,%eax
f0118bd0:	3b 45 18             	cmp    0x18(%ebp),%eax
f0118bd3:	74 3e                	je     f0118c13 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0118bd5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118bd9:	74 0b                	je     f0118be6 <CCP+0x156>
f0118bdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118bde:	8b 40 08             	mov    0x8(%eax),%eax
f0118be1:	0f b7 c0             	movzwl %ax,%eax
f0118be4:	eb 05                	jmp    f0118beb <CCP+0x15b>
f0118be6:	b8 00 00 00 00       	mov    $0x0,%eax
f0118beb:	83 ec 0c             	sub    $0xc,%esp
f0118bee:	50                   	push   %eax
f0118bef:	ff 75 f0             	pushl  -0x10(%ebp)
f0118bf2:	68 20 df 12 f0       	push   $0xf012df20
f0118bf7:	68 b2 08 00 00       	push   $0x8b2
f0118bfc:	68 42 c3 12 f0       	push   $0xf012c342
f0118c01:	e8 b1 78 fe ff       	call   f01004b7 <_warn>
f0118c06:	83 c4 20             	add    $0x20,%esp
				return 0;
f0118c09:	b8 00 00 00 00       	mov    $0x0,%eax
f0118c0e:	e9 a4 00 00 00       	jmp    f0118cb7 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0118c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118c16:	ff 75 20             	pushl  0x20(%ebp)
f0118c19:	ff 75 1c             	pushl  0x1c(%ebp)
f0118c1c:	50                   	push   %eax
f0118c1d:	ff 75 08             	pushl  0x8(%ebp)
f0118c20:	e8 b8 fa ff ff       	call   f01186dd <CPs>
f0118c25:	83 c4 10             	add    $0x10,%esp
f0118c28:	85 c0                	test   %eax,%eax
f0118c2a:	7f 21                	jg     f0118c4d <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0118c2c:	83 ec 04             	sub    $0x4,%esp
f0118c2f:	68 90 df 12 f0       	push   $0xf012df90
f0118c34:	68 b8 08 00 00       	push   $0x8b8
f0118c39:	68 42 c3 12 f0       	push   $0xf012c342
f0118c3e:	e8 74 78 fe ff       	call   f01004b7 <_warn>
f0118c43:	83 c4 10             	add    $0x10,%esp
			return 0;
f0118c46:	b8 00 00 00 00       	mov    $0x0,%eax
f0118c4b:	eb 6a                	jmp    f0118cb7 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0118c4d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0118c51:	74 3a                	je     f0118c8d <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0118c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118c56:	ff 75 28             	pushl  0x28(%ebp)
f0118c59:	ff 75 24             	pushl  0x24(%ebp)
f0118c5c:	50                   	push   %eax
f0118c5d:	ff 75 08             	pushl  0x8(%ebp)
f0118c60:	e8 78 fa ff ff       	call   f01186dd <CPs>
f0118c65:	83 c4 10             	add    $0x10,%esp
f0118c68:	85 c0                	test   %eax,%eax
f0118c6a:	7f 21                	jg     f0118c8d <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0118c6c:	83 ec 04             	sub    $0x4,%esp
f0118c6f:	68 d8 df 12 f0       	push   $0xf012dfd8
f0118c74:	68 bf 08 00 00       	push   $0x8bf
f0118c79:	68 42 c3 12 f0       	push   $0xf012c342
f0118c7e:	e8 34 78 fe ff       	call   f01004b7 <_warn>
f0118c83:	83 c4 10             	add    $0x10,%esp
				return 0;
f0118c86:	b8 00 00 00 00       	mov    $0x0,%eax
f0118c8b:	eb 2a                	jmp    f0118cb7 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0118c8d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0118c91:	74 07                	je     f0118c9a <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0118c93:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0118c9a:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0118ca1:	8b 55 10             	mov    0x10(%ebp),%edx
f0118ca4:	8b 45 14             	mov    0x14(%ebp),%eax
f0118ca7:	01 d0                	add    %edx,%eax
f0118ca9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118cac:	0f 87 05 fe ff ff    	ja     f0118ab7 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0118cb2:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118cb7:	c9                   	leave  
f0118cb8:	c3                   	ret    

f0118cb9 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0118cb9:	55                   	push   %ebp
f0118cba:	89 e5                	mov    %esp,%ebp
f0118cbc:	57                   	push   %edi
f0118cbd:	56                   	push   %esi
f0118cbe:	53                   	push   %ebx
f0118cbf:	81 ec 4c 03 00 00    	sub    $0x34c,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f0118cc5:	a0 d4 fd 17 f0       	mov    0xf017fdd4,%al
f0118cca:	84 c0                	test   %al,%al
f0118ccc:	0f 84 38 0a 00 00    	je     f011970a <test_priority_normal_and_higher+0xa51>
		uint32 fact_WS[15];
		uint32 fact_TimeStamp[15];
		uint32 hello_WS[10];
		uint32 hello_TimeStamp[10];

		firstTime = 0;
f0118cd2:	c6 05 d4 fd 17 f0 00 	movb   $0x0,0xf017fdd4
		char command[100] = "load fos_add 20";
f0118cd9:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0118cdf:	bb 94 e2 12 f0       	mov    $0xf012e294,%ebx
f0118ce4:	ba 04 00 00 00       	mov    $0x4,%edx
f0118ce9:	89 c7                	mov    %eax,%edi
f0118ceb:	89 de                	mov    %ebx,%esi
f0118ced:	89 d1                	mov    %edx,%ecx
f0118cef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0118cf1:	8d 95 24 fe ff ff    	lea    -0x1dc(%ebp),%edx
f0118cf7:	b9 15 00 00 00       	mov    $0x15,%ecx
f0118cfc:	b8 00 00 00 00       	mov    $0x0,%eax
f0118d01:	89 d7                	mov    %edx,%edi
f0118d03:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f0118d05:	83 ec 0c             	sub    $0xc,%esp
f0118d08:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0118d0e:	50                   	push   %eax
f0118d0f:	e8 c8 91 fe ff       	call   f0101edc <execute_command>
f0118d14:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 15";
f0118d17:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0118d1d:	bb f8 e2 12 f0       	mov    $0xf012e2f8,%ebx
f0118d22:	ba 0d 00 00 00       	mov    $0xd,%edx
f0118d27:	89 c7                	mov    %eax,%edi
f0118d29:	89 de                	mov    %ebx,%esi
f0118d2b:	89 d1                	mov    %edx,%ecx
f0118d2d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0118d2f:	8d 95 85 fe ff ff    	lea    -0x17b(%ebp),%edx
f0118d35:	b9 57 00 00 00       	mov    $0x57,%ecx
f0118d3a:	b0 00                	mov    $0x0,%al
f0118d3c:	89 d7                	mov    %edx,%edi
f0118d3e:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f0118d40:	83 ec 0c             	sub    $0xc,%esp
f0118d43:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0118d49:	50                   	push   %eax
f0118d4a:	e8 8d 91 fe ff       	call   f0101edc <execute_command>
f0118d4f:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 10";
f0118d52:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0118d58:	bb 5c e3 12 f0       	mov    $0xf012e35c,%ebx
f0118d5d:	ba 17 00 00 00       	mov    $0x17,%edx
f0118d62:	89 c7                	mov    %eax,%edi
f0118d64:	89 de                	mov    %ebx,%esi
f0118d66:	89 d1                	mov    %edx,%ecx
f0118d68:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0118d6a:	8d 95 f3 fe ff ff    	lea    -0x10d(%ebp),%edx
f0118d70:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f0118d75:	b0 00                	mov    $0x0,%al
f0118d77:	89 d7                	mov    %edx,%edi
f0118d79:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f0118d7b:	83 ec 0c             	sub    $0xc,%esp
f0118d7e:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0118d84:	50                   	push   %eax
f0118d85:	e8 52 91 fe ff       	call   f0101edc <execute_command>
f0118d8a:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(16, &addEnv, 0);
f0118d8d:	83 ec 04             	sub    $0x4,%esp
f0118d90:	6a 00                	push   $0x0
f0118d92:	8d 45 ac             	lea    -0x54(%ebp),%eax
f0118d95:	50                   	push   %eax
f0118d96:	6a 10                	push   $0x10
f0118d98:	e8 23 1a ff ff       	call   f010a7c0 <envid2env>
f0118d9d:	83 c4 10             	add    $0x10,%esp
		envid2env(17, &factEnv, 0);
f0118da0:	83 ec 04             	sub    $0x4,%esp
f0118da3:	6a 00                	push   $0x0
f0118da5:	8d 45 a8             	lea    -0x58(%ebp),%eax
f0118da8:	50                   	push   %eax
f0118da9:	6a 11                	push   $0x11
f0118dab:	e8 10 1a ff ff       	call   f010a7c0 <envid2env>
f0118db0:	83 c4 10             	add    $0x10,%esp
		envid2env(18, &helloEnv, 0);
f0118db3:	83 ec 04             	sub    $0x4,%esp
f0118db6:	6a 00                	push   $0x0
f0118db8:	8d 45 a4             	lea    -0x5c(%ebp),%eax
f0118dbb:	50                   	push   %eax
f0118dbc:	6a 12                	push   $0x12
f0118dbe:	e8 fd 19 ff ff       	call   f010a7c0 <envid2env>
f0118dc3:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f0118dc6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118dc9:	85 c0                	test   %eax,%eax
f0118dcb:	74 0e                	je     f0118ddb <test_priority_normal_and_higher+0x122>
f0118dcd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118dd0:	85 c0                	test   %eax,%eax
f0118dd2:	74 07                	je     f0118ddb <test_priority_normal_and_higher+0x122>
f0118dd4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118dd7:	85 c0                	test   %eax,%eax
f0118dd9:	75 14                	jne    f0118def <test_priority_normal_and_higher+0x136>
			panic("Loading programs failed\n");
f0118ddb:	83 ec 04             	sub    $0x4,%esp
f0118dde:	68 18 e0 12 f0       	push   $0xf012e018
f0118de3:	6a 29                	push   $0x29
f0118de5:	68 31 e0 12 f0       	push   $0xf012e031
f0118dea:	e8 2b 75 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0118def:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118df2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118df8:	83 f8 14             	cmp    $0x14,%eax
f0118dfb:	75 1c                	jne    f0118e19 <test_priority_normal_and_higher+0x160>
f0118dfd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118e00:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118e06:	83 f8 0f             	cmp    $0xf,%eax
f0118e09:	75 0e                	jne    f0118e19 <test_priority_normal_and_higher+0x160>
f0118e0b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118e0e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118e14:	83 f8 0a             	cmp    $0xa,%eax
f0118e17:	74 32                	je     f0118e4b <test_priority_normal_and_higher+0x192>
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );
f0118e19:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118e1c:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0118e22:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118e25:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0118e2b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118e2e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118e34:	83 ec 08             	sub    $0x8,%esp
f0118e37:	51                   	push   %ecx
f0118e38:	52                   	push   %edx
f0118e39:	50                   	push   %eax
f0118e3a:	68 4c e0 12 f0       	push   $0xf012e04c
f0118e3f:	6a 2c                	push   $0x2c
f0118e41:	68 31 e0 12 f0       	push   $0xf012e031
f0118e46:	e8 cf 74 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f0118e4b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0118e52:	eb 47                	jmp    f0118e9b <test_priority_normal_and_higher+0x1e2>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f0118e54:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0118e57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118e5a:	89 d0                	mov    %edx,%eax
f0118e5c:	01 c0                	add    %eax,%eax
f0118e5e:	01 d0                	add    %edx,%eax
f0118e60:	c1 e0 03             	shl    $0x3,%eax
f0118e63:	01 c8                	add    %ecx,%eax
f0118e65:	05 88 00 00 00       	add    $0x88,%eax
f0118e6a:	8b 10                	mov    (%eax),%edx
f0118e6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118e6f:	89 94 85 74 fd ff ff 	mov    %edx,-0x28c(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f0118e76:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0118e79:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118e7c:	89 d0                	mov    %edx,%eax
f0118e7e:	01 c0                	add    %eax,%eax
f0118e80:	01 d0                	add    %edx,%eax
f0118e82:	c1 e0 03             	shl    $0x3,%eax
f0118e85:	01 c8                	add    %ecx,%eax
f0118e87:	05 90 00 00 00       	add    $0x90,%eax
f0118e8c:	8b 10                	mov    (%eax),%edx
f0118e8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118e91:	89 94 85 c4 fd ff ff 	mov    %edx,-0x23c(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );

		for(int i = 0; i < 20; i++)
f0118e98:	ff 45 e4             	incl   -0x1c(%ebp)
f0118e9b:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f0118e9f:	7e b3                	jle    f0118e54 <test_priority_normal_and_higher+0x19b>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0118ea1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0118ea8:	eb 47                	jmp    f0118ef1 <test_priority_normal_and_higher+0x238>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f0118eaa:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0118ead:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118eb0:	89 d0                	mov    %edx,%eax
f0118eb2:	01 c0                	add    %eax,%eax
f0118eb4:	01 d0                	add    %edx,%eax
f0118eb6:	c1 e0 03             	shl    $0x3,%eax
f0118eb9:	01 c8                	add    %ecx,%eax
f0118ebb:	05 88 00 00 00       	add    $0x88,%eax
f0118ec0:	8b 10                	mov    (%eax),%edx
f0118ec2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118ec5:	89 94 85 fc fc ff ff 	mov    %edx,-0x304(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f0118ecc:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0118ecf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118ed2:	89 d0                	mov    %edx,%eax
f0118ed4:	01 c0                	add    %eax,%eax
f0118ed6:	01 d0                	add    %edx,%eax
f0118ed8:	c1 e0 03             	shl    $0x3,%eax
f0118edb:	01 c8                	add    %ecx,%eax
f0118edd:	05 90 00 00 00       	add    $0x90,%eax
f0118ee2:	8b 10                	mov    (%eax),%edx
f0118ee4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118ee7:	89 94 85 38 fd ff ff 	mov    %edx,-0x2c8(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0118eee:	ff 45 e0             	incl   -0x20(%ebp)
f0118ef1:	83 7d e0 0e          	cmpl   $0xe,-0x20(%ebp)
f0118ef5:	7e b3                	jle    f0118eaa <test_priority_normal_and_higher+0x1f1>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0118ef7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0118efe:	eb 47                	jmp    f0118f47 <test_priority_normal_and_higher+0x28e>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f0118f00:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0118f03:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0118f06:	89 d0                	mov    %edx,%eax
f0118f08:	01 c0                	add    %eax,%eax
f0118f0a:	01 d0                	add    %edx,%eax
f0118f0c:	c1 e0 03             	shl    $0x3,%eax
f0118f0f:	01 c8                	add    %ecx,%eax
f0118f11:	05 88 00 00 00       	add    $0x88,%eax
f0118f16:	8b 10                	mov    (%eax),%edx
f0118f18:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118f1b:	89 94 85 ac fc ff ff 	mov    %edx,-0x354(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f0118f22:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0118f25:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0118f28:	89 d0                	mov    %edx,%eax
f0118f2a:	01 c0                	add    %eax,%eax
f0118f2c:	01 d0                	add    %edx,%eax
f0118f2e:	c1 e0 03             	shl    $0x3,%eax
f0118f31:	01 c8                	add    %ecx,%eax
f0118f33:	05 90 00 00 00       	add    $0x90,%eax
f0118f38:	8b 10                	mov    (%eax),%edx
f0118f3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118f3d:	89 94 85 d4 fc ff ff 	mov    %edx,-0x32c(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0118f44:	ff 45 dc             	incl   -0x24(%ebp)
f0118f47:	83 7d dc 09          	cmpl   $0x9,-0x24(%ebp)
f0118f4b:	7e b3                	jle    f0118f00 <test_priority_normal_and_higher+0x247>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f0118f4d:	e8 b7 4a ff ff       	call   f010da09 <sys_calculate_free_frames>
f0118f52:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		int freeDiskFrames = pf_calculate_free_frames();
f0118f55:	e8 e6 b8 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0118f5a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f0118f5d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118f60:	83 ec 08             	sub    $0x8,%esp
f0118f63:	6a 03                	push   $0x3
f0118f65:	50                   	push   %eax
f0118f66:	e8 44 2f ff ff       	call   f010beaf <set_program_priority>
f0118f6b:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f0118f6e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f71:	83 ec 08             	sub    $0x8,%esp
f0118f74:	6a 03                	push   $0x3
f0118f76:	50                   	push   %eax
f0118f77:	e8 33 2f ff ff       	call   f010beaf <set_program_priority>
f0118f7c:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f0118f7f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118f82:	83 ec 08             	sub    $0x8,%esp
f0118f85:	6a 03                	push   $0x3
f0118f87:	50                   	push   %eax
f0118f88:	e8 22 2f ff ff       	call   f010beaf <set_program_priority>
f0118f8d:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0118f90:	e8 ab b8 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0118f95:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0118f98:	74 14                	je     f0118fae <test_priority_normal_and_higher+0x2f5>
f0118f9a:	83 ec 04             	sub    $0x4,%esp
f0118f9d:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0118fa2:	6a 48                	push   $0x48
f0118fa4:	68 31 e0 12 f0       	push   $0xf012e031
f0118fa9:	e8 6c 73 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0118fae:	e8 56 4a ff ff       	call   f010da09 <sys_calculate_free_frames>
f0118fb3:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0118fb6:	74 14                	je     f0118fcc <test_priority_normal_and_higher+0x313>
f0118fb8:	83 ec 04             	sub    $0x4,%esp
f0118fbb:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0118fc0:	6a 49                	push   $0x49
f0118fc2:	68 31 e0 12 f0       	push   $0xf012e031
f0118fc7:	e8 4e 73 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0118fcc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118fcf:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118fd5:	83 f8 14             	cmp    $0x14,%eax
f0118fd8:	75 1c                	jne    f0118ff6 <test_priority_normal_and_higher+0x33d>
f0118fda:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fdd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118fe3:	83 f8 0f             	cmp    $0xf,%eax
f0118fe6:	75 0e                	jne    f0118ff6 <test_priority_normal_and_higher+0x33d>
f0118fe8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118feb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118ff1:	83 f8 0a             	cmp    $0xa,%eax
f0118ff4:	74 14                	je     f011900a <test_priority_normal_and_higher+0x351>
			panic("The programs' working set size should not change after setting priority to normal\n");
f0118ff6:	83 ec 04             	sub    $0x4,%esp
f0118ff9:	68 e0 e0 12 f0       	push   $0xf012e0e0
f0118ffe:	6a 4c                	push   $0x4c
f0119000:	68 31 e0 12 f0       	push   $0xf012e031
f0119005:	e8 10 73 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f011900a:	e8 fa 49 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011900f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119012:	e8 29 b8 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119017:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Above Normal // Should change only helloWorld as none of the rest is full
		set_program_priority(addEnv, 4);
f011901a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011901d:	83 ec 08             	sub    $0x8,%esp
f0119020:	6a 04                	push   $0x4
f0119022:	50                   	push   %eax
f0119023:	e8 87 2e ff ff       	call   f010beaf <set_program_priority>
f0119028:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 4);
f011902b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011902e:	83 ec 08             	sub    $0x8,%esp
f0119031:	6a 04                	push   $0x4
f0119033:	50                   	push   %eax
f0119034:	e8 76 2e ff ff       	call   f010beaf <set_program_priority>
f0119039:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f011903c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011903f:	83 ec 08             	sub    $0x8,%esp
f0119042:	6a 04                	push   $0x4
f0119044:	50                   	push   %eax
f0119045:	e8 65 2e ff ff       	call   f010beaf <set_program_priority>
f011904a:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f011904d:	e8 ee b7 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119052:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0119055:	74 14                	je     f011906b <test_priority_normal_and_higher+0x3b2>
f0119057:	83 ec 04             	sub    $0x4,%esp
f011905a:	68 b4 e0 12 f0       	push   $0xf012e0b4
f011905f:	6a 56                	push   $0x56
f0119061:	68 31 e0 12 f0       	push   $0xf012e031
f0119066:	e8 af 72 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly%x\n");
f011906b:	e8 99 49 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119070:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0119073:	74 14                	je     f0119089 <test_priority_normal_and_higher+0x3d0>
f0119075:	83 ec 04             	sub    $0x4,%esp
f0119078:	68 34 e1 12 f0       	push   $0xf012e134
f011907d:	6a 57                	push   $0x57
f011907f:	68 31 e0 12 f0       	push   $0xf012e031
f0119084:	e8 91 72 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0119089:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011908c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119092:	83 f8 14             	cmp    $0x14,%eax
f0119095:	75 1c                	jne    f01190b3 <test_priority_normal_and_higher+0x3fa>
f0119097:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011909a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01190a0:	83 f8 0f             	cmp    $0xf,%eax
f01190a3:	75 0e                	jne    f01190b3 <test_priority_normal_and_higher+0x3fa>
f01190a5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01190a8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01190ae:	83 f8 14             	cmp    $0x14,%eax
f01190b1:	74 14                	je     f01190c7 <test_priority_normal_and_higher+0x40e>
			panic("The programs' working set size should be doubled only if it is full\n");
f01190b3:	83 ec 04             	sub    $0x4,%esp
f01190b6:	68 64 e1 12 f0       	push   $0xf012e164
f01190bb:	6a 5a                	push   $0x5a
f01190bd:	68 31 e0 12 f0       	push   $0xf012e031
f01190c2:	e8 53 72 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f01190c7:	e8 3d 49 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01190cc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01190cf:	e8 6c b7 fe ff       	call   f0104840 <pf_calculate_free_frames>
f01190d4:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set priority to above normal --> nothing should change (1 time only)
		set_program_priority(helloEnv, 4);
f01190d7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01190da:	83 ec 08             	sub    $0x8,%esp
f01190dd:	6a 04                	push   $0x4
f01190df:	50                   	push   %eax
f01190e0:	e8 ca 2d ff ff       	call   f010beaf <set_program_priority>
f01190e5:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01190e8:	e8 53 b7 fe ff       	call   f0104840 <pf_calculate_free_frames>
f01190ed:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01190f0:	74 14                	je     f0119106 <test_priority_normal_and_higher+0x44d>
f01190f2:	83 ec 04             	sub    $0x4,%esp
f01190f5:	68 b4 e0 12 f0       	push   $0xf012e0b4
f01190fa:	6a 62                	push   $0x62
f01190fc:	68 31 e0 12 f0       	push   $0xf012e031
f0119101:	e8 14 72 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0119106:	e8 fe 48 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011910b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011910e:	74 14                	je     f0119124 <test_priority_normal_and_higher+0x46b>
f0119110:	83 ec 04             	sub    $0x4,%esp
f0119113:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119118:	6a 63                	push   $0x63
f011911a:	68 31 e0 12 f0       	push   $0xf012e031
f011911f:	e8 f6 71 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0119124:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119127:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011912d:	83 f8 14             	cmp    $0x14,%eax
f0119130:	75 1c                	jne    f011914e <test_priority_normal_and_higher+0x495>
f0119132:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119135:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011913b:	83 f8 0f             	cmp    $0xf,%eax
f011913e:	75 0e                	jne    f011914e <test_priority_normal_and_higher+0x495>
f0119140:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119143:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119149:	83 f8 14             	cmp    $0x14,%eax
f011914c:	74 14                	je     f0119162 <test_priority_normal_and_higher+0x4a9>
			panic("The programs' working set size should be doubled only once\n");
f011914e:	83 ec 04             	sub    $0x4,%esp
f0119151:	68 ac e1 12 f0       	push   $0xf012e1ac
f0119156:	6a 66                	push   $0x66
f0119158:	68 31 e0 12 f0       	push   $0xf012e031
f011915d:	e8 b8 71 fe ff       	call   f010031a <_panic>


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f0119162:	c7 45 d8 0a 00 00 00 	movl   $0xa,-0x28(%ebp)
f0119169:	eb 1c                	jmp    f0119187 <test_priority_normal_and_higher+0x4ce>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f011916b:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f011916e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0119171:	89 d0                	mov    %edx,%eax
f0119173:	01 c0                	add    %eax,%eax
f0119175:	01 d0                	add    %edx,%eax
f0119177:	c1 e0 03             	shl    $0x3,%eax
f011917a:	01 c8                	add    %ecx,%eax
f011917c:	05 8c 00 00 00       	add    $0x8c,%eax
f0119181:	c6 00 00             	movb   $0x0,(%eax)
		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f0119184:	ff 45 d8             	incl   -0x28(%ebp)
f0119187:	83 7d d8 13          	cmpl   $0x13,-0x28(%ebp)
f011918b:	7e de                	jle    f011916b <test_priority_normal_and_higher+0x4b2>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f011918d:	e8 77 48 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119192:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119195:	e8 a6 b6 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011919a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		set_program_priority(helloEnv, 4);
f011919d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01191a0:	83 ec 08             	sub    $0x8,%esp
f01191a3:	6a 04                	push   $0x4
f01191a5:	50                   	push   %eax
f01191a6:	e8 04 2d ff ff       	call   f010beaf <set_program_priority>
f01191ab:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01191ae:	e8 8d b6 fe ff       	call   f0104840 <pf_calculate_free_frames>
f01191b3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01191b6:	74 14                	je     f01191cc <test_priority_normal_and_higher+0x513>
f01191b8:	83 ec 04             	sub    $0x4,%esp
f01191bb:	68 b4 e0 12 f0       	push   $0xf012e0b4
f01191c0:	6a 73                	push   $0x73
f01191c2:	68 31 e0 12 f0       	push   $0xf012e031
f01191c7:	e8 4e 71 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f01191cc:	e8 38 48 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01191d1:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01191d4:	74 14                	je     f01191ea <test_priority_normal_and_higher+0x531>
f01191d6:	83 ec 04             	sub    $0x4,%esp
f01191d9:	68 b4 e0 12 f0       	push   $0xf012e0b4
f01191de:	6a 74                	push   $0x74
f01191e0:	68 31 e0 12 f0       	push   $0xf012e031
f01191e5:	e8 30 71 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f01191ea:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01191ed:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01191f3:	83 f8 14             	cmp    $0x14,%eax
f01191f6:	75 1c                	jne    f0119214 <test_priority_normal_and_higher+0x55b>
f01191f8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01191fb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119201:	83 f8 0f             	cmp    $0xf,%eax
f0119204:	75 0e                	jne    f0119214 <test_priority_normal_and_higher+0x55b>
f0119206:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119209:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011920f:	83 f8 14             	cmp    $0x14,%eax
f0119212:	74 14                	je     f0119228 <test_priority_normal_and_higher+0x56f>
			panic("The programs' working set size should be doubled only once\n");
f0119214:	83 ec 04             	sub    $0x4,%esp
f0119217:	68 ac e1 12 f0       	push   $0xf012e1ac
f011921c:	6a 77                	push   $0x77
f011921e:	68 31 e0 12 f0       	push   $0xf012e031
f0119223:	e8 f2 70 fe ff       	call   f010031a <_panic>

		for(int i = 10; i < 15; i++)
f0119228:	c7 45 d4 0a 00 00 00 	movl   $0xa,-0x2c(%ebp)
f011922f:	eb 1c                	jmp    f011924d <test_priority_normal_and_higher+0x594>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f0119231:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0119234:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0119237:	89 d0                	mov    %edx,%eax
f0119239:	01 c0                	add    %eax,%eax
f011923b:	01 d0                	add    %edx,%eax
f011923d:	c1 e0 03             	shl    $0x3,%eax
f0119240:	01 c8                	add    %ecx,%eax
f0119242:	05 8c 00 00 00       	add    $0x8c,%eax
f0119247:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");

		for(int i = 10; i < 15; i++)
f011924a:	ff 45 d4             	incl   -0x2c(%ebp)
f011924d:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f0119251:	7e de                	jle    f0119231 <test_priority_normal_and_higher+0x578>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f0119253:	e8 b1 47 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119258:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011925b:	e8 e0 b5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119260:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f0119263:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119266:	83 ec 08             	sub    $0x8,%esp
f0119269:	6a 05                	push   $0x5
f011926b:	50                   	push   %eax
f011926c:	e8 3e 2c ff ff       	call   f010beaf <set_program_priority>
f0119271:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 5);
f0119274:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119277:	83 ec 08             	sub    $0x8,%esp
f011927a:	6a 05                	push   $0x5
f011927c:	50                   	push   %eax
f011927d:	e8 2d 2c ff ff       	call   f010beaf <set_program_priority>
f0119282:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119285:	e8 b6 b5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011928a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011928d:	74 17                	je     f01192a6 <test_priority_normal_and_higher+0x5ed>
f011928f:	83 ec 04             	sub    $0x4,%esp
f0119292:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119297:	68 82 00 00 00       	push   $0x82
f011929c:	68 31 e0 12 f0       	push   $0xf012e031
f01192a1:	e8 74 70 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f01192a6:	e8 5e 47 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01192ab:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01192ae:	74 17                	je     f01192c7 <test_priority_normal_and_higher+0x60e>
f01192b0:	83 ec 04             	sub    $0x4,%esp
f01192b3:	68 b4 e0 12 f0       	push   $0xf012e0b4
f01192b8:	68 83 00 00 00       	push   $0x83
f01192bd:	68 31 e0 12 f0       	push   $0xf012e031
f01192c2:	e8 53 70 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f01192c7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01192ca:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01192d0:	83 f8 14             	cmp    $0x14,%eax
f01192d3:	75 1c                	jne    f01192f1 <test_priority_normal_and_higher+0x638>
f01192d5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01192d8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01192de:	83 f8 1e             	cmp    $0x1e,%eax
f01192e1:	75 0e                	jne    f01192f1 <test_priority_normal_and_higher+0x638>
f01192e3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01192e6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01192ec:	83 f8 28             	cmp    $0x28,%eax
f01192ef:	74 17                	je     f0119308 <test_priority_normal_and_higher+0x64f>
			panic("The programs' working set size should be doubled if full\n");
f01192f1:	83 ec 04             	sub    $0x4,%esp
f01192f4:	68 e8 e1 12 f0       	push   $0xf012e1e8
f01192f9:	68 86 00 00 00       	push   $0x86
f01192fe:	68 31 e0 12 f0       	push   $0xf012e031
f0119303:	e8 12 70 fe ff       	call   f010031a <_panic>

		for(int i = 20; i < 40; i++)
f0119308:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
f011930f:	eb 1c                	jmp    f011932d <test_priority_normal_and_higher+0x674>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f0119311:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0119314:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0119317:	89 d0                	mov    %edx,%eax
f0119319:	01 c0                	add    %eax,%eax
f011931b:	01 d0                	add    %edx,%eax
f011931d:	c1 e0 03             	shl    $0x3,%eax
f0119320:	01 c8                	add    %ecx,%eax
f0119322:	05 8c 00 00 00       	add    $0x8c,%eax
f0119327:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 20; i < 40; i++)
f011932a:	ff 45 d0             	incl   -0x30(%ebp)
f011932d:	83 7d d0 27          	cmpl   $0x27,-0x30(%ebp)
f0119331:	7e de                	jle    f0119311 <test_priority_normal_and_higher+0x658>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f0119333:	e8 d1 46 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119338:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011933b:	e8 00 b5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119340:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f0119343:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119346:	83 ec 08             	sub    $0x8,%esp
f0119349:	6a 05                	push   $0x5
f011934b:	50                   	push   %eax
f011934c:	e8 5e 2b ff ff       	call   f010beaf <set_program_priority>
f0119351:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f0119354:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119357:	83 ec 08             	sub    $0x8,%esp
f011935a:	6a 04                	push   $0x4
f011935c:	50                   	push   %eax
f011935d:	e8 4d 2b ff ff       	call   f010beaf <set_program_priority>
f0119362:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119365:	e8 d6 b4 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011936a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011936d:	74 17                	je     f0119386 <test_priority_normal_and_higher+0x6cd>
f011936f:	83 ec 04             	sub    $0x4,%esp
f0119372:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119377:	68 91 00 00 00       	push   $0x91
f011937c:	68 31 e0 12 f0       	push   $0xf012e031
f0119381:	e8 94 6f fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0119386:	e8 7e 46 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011938b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011938e:	74 17                	je     f01193a7 <test_priority_normal_and_higher+0x6ee>
f0119390:	83 ec 04             	sub    $0x4,%esp
f0119393:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119398:	68 92 00 00 00       	push   $0x92
f011939d:	68 31 e0 12 f0       	push   $0xf012e031
f01193a2:	e8 73 6f fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f01193a7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01193aa:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01193b0:	83 f8 14             	cmp    $0x14,%eax
f01193b3:	75 1c                	jne    f01193d1 <test_priority_normal_and_higher+0x718>
f01193b5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01193b8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01193be:	83 f8 1e             	cmp    $0x1e,%eax
f01193c1:	75 0e                	jne    f01193d1 <test_priority_normal_and_higher+0x718>
f01193c3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01193c6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01193cc:	83 f8 28             	cmp    $0x28,%eax
f01193cf:	74 17                	je     f01193e8 <test_priority_normal_and_higher+0x72f>
			panic("The programs' working set size should be doubled if full\n");
f01193d1:	83 ec 04             	sub    $0x4,%esp
f01193d4:	68 e8 e1 12 f0       	push   $0xf012e1e8
f01193d9:	68 95 00 00 00       	push   $0x95
f01193de:	68 31 e0 12 f0       	push   $0xf012e031
f01193e3:	e8 32 6f fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 30; i++)
f01193e8:	c7 45 cc 0f 00 00 00 	movl   $0xf,-0x34(%ebp)
f01193ef:	eb 1c                	jmp    f011940d <test_priority_normal_and_higher+0x754>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f01193f1:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f01193f4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01193f7:	89 d0                	mov    %edx,%eax
f01193f9:	01 c0                	add    %eax,%eax
f01193fb:	01 d0                	add    %edx,%eax
f01193fd:	c1 e0 03             	shl    $0x3,%eax
f0119400:	01 c8                	add    %ecx,%eax
f0119402:	05 8c 00 00 00       	add    $0x8c,%eax
f0119407:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 30; i++)
f011940a:	ff 45 cc             	incl   -0x34(%ebp)
f011940d:	83 7d cc 1d          	cmpl   $0x1d,-0x34(%ebp)
f0119411:	7e de                	jle    f01193f1 <test_priority_normal_and_higher+0x738>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f0119413:	e8 f1 45 ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119418:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011941b:	e8 20 b4 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119420:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f0119423:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119426:	83 ec 08             	sub    $0x8,%esp
f0119429:	6a 05                	push   $0x5
f011942b:	50                   	push   %eax
f011942c:	e8 7e 2a ff ff       	call   f010beaf <set_program_priority>
f0119431:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f0119434:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119437:	83 ec 08             	sub    $0x8,%esp
f011943a:	6a 04                	push   $0x4
f011943c:	50                   	push   %eax
f011943d:	e8 6d 2a ff ff       	call   f010beaf <set_program_priority>
f0119442:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119445:	e8 f6 b3 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011944a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011944d:	74 17                	je     f0119466 <test_priority_normal_and_higher+0x7ad>
f011944f:	83 ec 04             	sub    $0x4,%esp
f0119452:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119457:	68 a0 00 00 00       	push   $0xa0
f011945c:	68 31 e0 12 f0       	push   $0xf012e031
f0119461:	e8 b4 6e fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0119466:	e8 9e 45 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011946b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011946e:	74 17                	je     f0119487 <test_priority_normal_and_higher+0x7ce>
f0119470:	83 ec 04             	sub    $0x4,%esp
f0119473:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119478:	68 a1 00 00 00       	push   $0xa1
f011947d:	68 31 e0 12 f0       	push   $0xf012e031
f0119482:	e8 93 6e fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
f0119487:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011948a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119490:	83 f8 14             	cmp    $0x14,%eax
f0119493:	75 1c                	jne    f01194b1 <test_priority_normal_and_higher+0x7f8>
f0119495:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119498:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011949e:	83 f8 3c             	cmp    $0x3c,%eax
f01194a1:	75 0e                	jne    f01194b1 <test_priority_normal_and_higher+0x7f8>
f01194a3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01194a6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01194ac:	83 f8 28             	cmp    $0x28,%eax
f01194af:	74 17                	je     f01194c8 <test_priority_normal_and_higher+0x80f>
			panic("The programs' working set size should be doubled if full\n");
f01194b1:	83 ec 04             	sub    $0x4,%esp
f01194b4:	68 e8 e1 12 f0       	push   $0xf012e1e8
f01194b9:	68 a4 00 00 00       	push   $0xa4
f01194be:	68 31 e0 12 f0       	push   $0xf012e031
f01194c3:	e8 52 6e fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 60; i++)
f01194c8:	c7 45 c8 0f 00 00 00 	movl   $0xf,-0x38(%ebp)
f01194cf:	eb 1c                	jmp    f01194ed <test_priority_normal_and_higher+0x834>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
f01194d1:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f01194d4:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01194d7:	89 d0                	mov    %edx,%eax
f01194d9:	01 c0                	add    %eax,%eax
f01194db:	01 d0                	add    %edx,%eax
f01194dd:	c1 e0 03             	shl    $0x3,%eax
f01194e0:	01 c8                	add    %ecx,%eax
f01194e2:	05 8c 00 00 00       	add    $0x8c,%eax
f01194e7:	c6 00 01             	movb   $0x1,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 60; i++)
f01194ea:	ff 45 c8             	incl   -0x38(%ebp)
f01194ed:	83 7d c8 3b          	cmpl   $0x3b,-0x38(%ebp)
f01194f1:	7e de                	jle    f01194d1 <test_priority_normal_and_higher+0x818>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f01194f3:	c7 45 c4 0a 00 00 00 	movl   $0xa,-0x3c(%ebp)
f01194fa:	eb 1c                	jmp    f0119518 <test_priority_normal_and_higher+0x85f>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
f01194fc:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f01194ff:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0119502:	89 d0                	mov    %edx,%eax
f0119504:	01 c0                	add    %eax,%eax
f0119506:	01 d0                	add    %edx,%eax
f0119508:	c1 e0 03             	shl    $0x3,%eax
f011950b:	01 c8                	add    %ecx,%eax
f011950d:	05 8c 00 00 00       	add    $0x8c,%eax
f0119512:	c6 00 01             	movb   $0x1,(%eax)

		for(int i = 15; i < 60; i++)
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f0119515:	ff 45 c4             	incl   -0x3c(%ebp)
f0119518:	83 7d c4 27          	cmpl   $0x27,-0x3c(%ebp)
f011951c:	7e de                	jle    f01194fc <test_priority_normal_and_higher+0x843>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f011951e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0119525:	eb 7d                	jmp    f01195a4 <test_priority_normal_and_higher+0x8eb>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0119527:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011952a:	8b 8c 85 74 fd ff ff 	mov    -0x28c(%ebp,%eax,4),%ecx
f0119531:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f0119534:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0119537:	89 d0                	mov    %edx,%eax
f0119539:	01 c0                	add    %eax,%eax
f011953b:	01 d0                	add    %edx,%eax
f011953d:	c1 e0 03             	shl    $0x3,%eax
f0119540:	01 d8                	add    %ebx,%eax
f0119542:	05 88 00 00 00       	add    $0x88,%eax
f0119547:	8b 00                	mov    (%eax),%eax
f0119549:	39 c1                	cmp    %eax,%ecx
f011954b:	74 17                	je     f0119564 <test_priority_normal_and_higher+0x8ab>
				panic("Working set should be moved properly to the new one");
f011954d:	83 ec 04             	sub    $0x4,%esp
f0119550:	68 24 e2 12 f0       	push   $0xf012e224
f0119555:	68 b2 00 00 00       	push   $0xb2
f011955a:	68 31 e0 12 f0       	push   $0xf012e031
f011955f:	e8 b6 6d fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0119564:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119567:	8b 8c 85 c4 fd ff ff 	mov    -0x23c(%ebp,%eax,4),%ecx
f011956e:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f0119571:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0119574:	89 d0                	mov    %edx,%eax
f0119576:	01 c0                	add    %eax,%eax
f0119578:	01 d0                	add    %edx,%eax
f011957a:	c1 e0 03             	shl    $0x3,%eax
f011957d:	01 d8                	add    %ebx,%eax
f011957f:	05 90 00 00 00       	add    $0x90,%eax
f0119584:	8b 00                	mov    (%eax),%eax
f0119586:	39 c1                	cmp    %eax,%ecx
f0119588:	74 17                	je     f01195a1 <test_priority_normal_and_higher+0x8e8>
				panic("Working set should be moved properly to the new one");
f011958a:	83 ec 04             	sub    $0x4,%esp
f011958d:	68 24 e2 12 f0       	push   $0xf012e224
f0119592:	68 b5 00 00 00       	push   $0xb5
f0119597:	68 31 e0 12 f0       	push   $0xf012e031
f011959c:	e8 79 6d fe ff       	call   f010031a <_panic>
		for(int i = 10; i < 40; i++)
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f01195a1:	ff 45 c0             	incl   -0x40(%ebp)
f01195a4:	83 7d c0 13          	cmpl   $0x13,-0x40(%ebp)
f01195a8:	0f 8e 79 ff ff ff    	jle    f0119527 <test_priority_normal_and_higher+0x86e>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f01195ae:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01195b5:	eb 7d                	jmp    f0119634 <test_priority_normal_and_higher+0x97b>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f01195b7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01195ba:	8b 8c 85 fc fc ff ff 	mov    -0x304(%ebp,%eax,4),%ecx
f01195c1:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f01195c4:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01195c7:	89 d0                	mov    %edx,%eax
f01195c9:	01 c0                	add    %eax,%eax
f01195cb:	01 d0                	add    %edx,%eax
f01195cd:	c1 e0 03             	shl    $0x3,%eax
f01195d0:	01 d8                	add    %ebx,%eax
f01195d2:	05 88 00 00 00       	add    $0x88,%eax
f01195d7:	8b 00                	mov    (%eax),%eax
f01195d9:	39 c1                	cmp    %eax,%ecx
f01195db:	74 17                	je     f01195f4 <test_priority_normal_and_higher+0x93b>
				panic("Working set should be moved properly to the new one");
f01195dd:	83 ec 04             	sub    $0x4,%esp
f01195e0:	68 24 e2 12 f0       	push   $0xf012e224
f01195e5:	68 bb 00 00 00       	push   $0xbb
f01195ea:	68 31 e0 12 f0       	push   $0xf012e031
f01195ef:	e8 26 6d fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f01195f4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01195f7:	8b 8c 85 38 fd ff ff 	mov    -0x2c8(%ebp,%eax,4),%ecx
f01195fe:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119601:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0119604:	89 d0                	mov    %edx,%eax
f0119606:	01 c0                	add    %eax,%eax
f0119608:	01 d0                	add    %edx,%eax
f011960a:	c1 e0 03             	shl    $0x3,%eax
f011960d:	01 d8                	add    %ebx,%eax
f011960f:	05 90 00 00 00       	add    $0x90,%eax
f0119614:	8b 00                	mov    (%eax),%eax
f0119616:	39 c1                	cmp    %eax,%ecx
f0119618:	74 17                	je     f0119631 <test_priority_normal_and_higher+0x978>
				panic("Working set should be moved properly to the new one");
f011961a:	83 ec 04             	sub    $0x4,%esp
f011961d:	68 24 e2 12 f0       	push   $0xf012e224
f0119622:	68 be 00 00 00       	push   $0xbe
f0119627:	68 31 e0 12 f0       	push   $0xf012e031
f011962c:	e8 e9 6c fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0119631:	ff 45 bc             	incl   -0x44(%ebp)
f0119634:	83 7d bc 0e          	cmpl   $0xe,-0x44(%ebp)
f0119638:	0f 8e 79 ff ff ff    	jle    f01195b7 <test_priority_normal_and_higher+0x8fe>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f011963e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f0119645:	eb 7d                	jmp    f01196c4 <test_priority_normal_and_higher+0xa0b>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0119647:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011964a:	8b 8c 85 ac fc ff ff 	mov    -0x354(%ebp,%eax,4),%ecx
f0119651:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0119654:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0119657:	89 d0                	mov    %edx,%eax
f0119659:	01 c0                	add    %eax,%eax
f011965b:	01 d0                	add    %edx,%eax
f011965d:	c1 e0 03             	shl    $0x3,%eax
f0119660:	01 d8                	add    %ebx,%eax
f0119662:	05 88 00 00 00       	add    $0x88,%eax
f0119667:	8b 00                	mov    (%eax),%eax
f0119669:	39 c1                	cmp    %eax,%ecx
f011966b:	74 17                	je     f0119684 <test_priority_normal_and_higher+0x9cb>
				panic("Working set should be moved properly to the new one");
f011966d:	83 ec 04             	sub    $0x4,%esp
f0119670:	68 24 e2 12 f0       	push   $0xf012e224
f0119675:	68 c4 00 00 00       	push   $0xc4
f011967a:	68 31 e0 12 f0       	push   $0xf012e031
f011967f:	e8 96 6c fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0119684:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119687:	8b 8c 85 d4 fc ff ff 	mov    -0x32c(%ebp,%eax,4),%ecx
f011968e:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0119691:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0119694:	89 d0                	mov    %edx,%eax
f0119696:	01 c0                	add    %eax,%eax
f0119698:	01 d0                	add    %edx,%eax
f011969a:	c1 e0 03             	shl    $0x3,%eax
f011969d:	01 d8                	add    %ebx,%eax
f011969f:	05 90 00 00 00       	add    $0x90,%eax
f01196a4:	8b 00                	mov    (%eax),%eax
f01196a6:	39 c1                	cmp    %eax,%ecx
f01196a8:	74 17                	je     f01196c1 <test_priority_normal_and_higher+0xa08>
				panic("Working set should be moved properly to the new one");
f01196aa:	83 ec 04             	sub    $0x4,%esp
f01196ad:	68 24 e2 12 f0       	push   $0xf012e224
f01196b2:	68 c7 00 00 00       	push   $0xc7
f01196b7:	68 31 e0 12 f0       	push   $0xf012e031
f01196bc:	e8 59 6c fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f01196c1:	ff 45 b8             	incl   -0x48(%ebp)
f01196c4:	83 7d b8 09          	cmpl   $0x9,-0x48(%ebp)
f01196c8:	0f 8e 79 ff ff ff    	jle    f0119647 <test_priority_normal_and_higher+0x98e>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		char command4[100] = "runall";
f01196ce:	c7 85 40 ff ff ff 72 	movl   $0x616e7572,-0xc0(%ebp)
f01196d5:	75 6e 61 
f01196d8:	c7 85 44 ff ff ff 6c 	movl   $0x6c6c,-0xbc(%ebp)
f01196df:	6c 00 00 
f01196e2:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f01196e8:	b9 17 00 00 00       	mov    $0x17,%ecx
f01196ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01196f2:	89 d7                	mov    %edx,%edi
f01196f4:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f01196f6:	83 ec 0c             	sub    $0xc,%esp
f01196f9:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f01196ff:	50                   	push   %eax
f0119700:	e8 d7 87 fe ff       	call   f0101edc <execute_command>
f0119705:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
	}
#endif
}
f0119708:	eb 10                	jmp    f011971a <test_priority_normal_and_higher+0xa61>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
f011970a:	83 ec 0c             	sub    $0xc,%esp
f011970d:	68 58 e2 12 f0       	push   $0xf012e258
f0119712:	e8 55 78 fe ff       	call   f0100f6c <cprintf>
f0119717:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f011971a:	90                   	nop
f011971b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011971e:	5b                   	pop    %ebx
f011971f:	5e                   	pop    %esi
f0119720:	5f                   	pop    %edi
f0119721:	5d                   	pop    %ebp
f0119722:	c3                   	ret    

f0119723 <test_priority_normal_and_lower>:

void test_priority_normal_and_lower()
{
f0119723:	55                   	push   %ebp
f0119724:	89 e5                	mov    %esp,%ebp
f0119726:	57                   	push   %edi
f0119727:	56                   	push   %esi
f0119728:	53                   	push   %ebx
f0119729:	81 ec ac 04 00 00    	sub    $0x4ac,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f011972f:	a0 d4 fd 17 f0       	mov    0xf017fdd4,%al
f0119734:	84 c0                	test   %al,%al
f0119736:	0f 84 1b 0a 00 00    	je     f011a157 <test_priority_normal_and_lower+0xa34>
		uint32 fact_WS[30];
		uint32 fact_TimeStamp[30];
		uint32 hello_WS[40];
		uint32 hello_TimeStamp[40];

		firstTime = 0;
f011973c:	c6 05 d4 fd 17 f0 00 	movb   $0x0,0xf017fdd4
		char command[100] = "load fos_add 20";
f0119743:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f0119749:	bb 94 e2 12 f0       	mov    $0xf012e294,%ebx
f011974e:	ba 04 00 00 00       	mov    $0x4,%edx
f0119753:	89 c7                	mov    %eax,%edi
f0119755:	89 de                	mov    %ebx,%esi
f0119757:	89 d1                	mov    %edx,%ecx
f0119759:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011975b:	8d 95 00 fc ff ff    	lea    -0x400(%ebp),%edx
f0119761:	b9 15 00 00 00       	mov    $0x15,%ecx
f0119766:	b8 00 00 00 00       	mov    $0x0,%eax
f011976b:	89 d7                	mov    %edx,%edi
f011976d:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f011976f:	83 ec 0c             	sub    $0xc,%esp
f0119772:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f0119778:	50                   	push   %eax
f0119779:	e8 5e 87 fe ff       	call   f0101edc <execute_command>
f011977e:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 30";
f0119781:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f0119787:	bb 9c e5 12 f0       	mov    $0xf012e59c,%ebx
f011978c:	ba 0d 00 00 00       	mov    $0xd,%edx
f0119791:	89 c7                	mov    %eax,%edi
f0119793:	89 de                	mov    %ebx,%esi
f0119795:	89 d1                	mov    %edx,%ecx
f0119797:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0119799:	8d 95 61 fc ff ff    	lea    -0x39f(%ebp),%edx
f011979f:	b9 57 00 00 00       	mov    $0x57,%ecx
f01197a4:	b0 00                	mov    $0x0,%al
f01197a6:	89 d7                	mov    %edx,%edi
f01197a8:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f01197aa:	83 ec 0c             	sub    $0xc,%esp
f01197ad:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f01197b3:	50                   	push   %eax
f01197b4:	e8 23 87 fe ff       	call   f0101edc <execute_command>
f01197b9:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 40";
f01197bc:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f01197c2:	bb 00 e6 12 f0       	mov    $0xf012e600,%ebx
f01197c7:	ba 17 00 00 00       	mov    $0x17,%edx
f01197cc:	89 c7                	mov    %eax,%edi
f01197ce:	89 de                	mov    %ebx,%esi
f01197d0:	89 d1                	mov    %edx,%ecx
f01197d2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01197d4:	8d 95 cf fc ff ff    	lea    -0x331(%ebp),%edx
f01197da:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f01197df:	b0 00                	mov    $0x0,%al
f01197e1:	89 d7                	mov    %edx,%edi
f01197e3:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f01197e5:	83 ec 0c             	sub    $0xc,%esp
f01197e8:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f01197ee:	50                   	push   %eax
f01197ef:	e8 e8 86 fe ff       	call   f0101edc <execute_command>
f01197f4:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(4096, &addEnv, 0);
f01197f7:	83 ec 04             	sub    $0x4,%esp
f01197fa:	6a 00                	push   $0x0
f01197fc:	8d 45 b8             	lea    -0x48(%ebp),%eax
f01197ff:	50                   	push   %eax
f0119800:	68 00 10 00 00       	push   $0x1000
f0119805:	e8 b6 0f ff ff       	call   f010a7c0 <envid2env>
f011980a:	83 c4 10             	add    $0x10,%esp
		envid2env(4097, &factEnv, 0);
f011980d:	83 ec 04             	sub    $0x4,%esp
f0119810:	6a 00                	push   $0x0
f0119812:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0119815:	50                   	push   %eax
f0119816:	68 01 10 00 00       	push   $0x1001
f011981b:	e8 a0 0f ff ff       	call   f010a7c0 <envid2env>
f0119820:	83 c4 10             	add    $0x10,%esp
		envid2env(4098, &helloEnv, 0);
f0119823:	83 ec 04             	sub    $0x4,%esp
f0119826:	6a 00                	push   $0x0
f0119828:	8d 45 b0             	lea    -0x50(%ebp),%eax
f011982b:	50                   	push   %eax
f011982c:	68 02 10 00 00       	push   $0x1002
f0119831:	e8 8a 0f ff ff       	call   f010a7c0 <envid2env>
f0119836:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f0119839:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011983c:	85 c0                	test   %eax,%eax
f011983e:	74 0e                	je     f011984e <test_priority_normal_and_lower+0x12b>
f0119840:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119843:	85 c0                	test   %eax,%eax
f0119845:	74 07                	je     f011984e <test_priority_normal_and_lower+0x12b>
f0119847:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011984a:	85 c0                	test   %eax,%eax
f011984c:	75 17                	jne    f0119865 <test_priority_normal_and_lower+0x142>
			panic("Loading programs failed\n");
f011984e:	83 ec 04             	sub    $0x4,%esp
f0119851:	68 18 e0 12 f0       	push   $0xf012e018
f0119856:	68 f2 00 00 00       	push   $0xf2
f011985b:	68 31 e0 12 f0       	push   $0xf012e031
f0119860:	e8 b5 6a fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0119865:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119868:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011986e:	83 f8 14             	cmp    $0x14,%eax
f0119871:	75 1c                	jne    f011988f <test_priority_normal_and_lower+0x16c>
f0119873:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119876:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011987c:	83 f8 1e             	cmp    $0x1e,%eax
f011987f:	75 0e                	jne    f011988f <test_priority_normal_and_lower+0x16c>
f0119881:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119884:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011988a:	83 f8 28             	cmp    $0x28,%eax
f011988d:	74 17                	je     f01198a6 <test_priority_normal_and_lower+0x183>
			panic("The programs should be initially loaded with the given working set size\n");
f011988f:	83 ec 04             	sub    $0x4,%esp
f0119892:	68 c0 e3 12 f0       	push   $0xf012e3c0
f0119897:	68 f5 00 00 00       	push   $0xf5
f011989c:	68 31 e0 12 f0       	push   $0xf012e031
f01198a1:	e8 74 6a fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f01198a6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01198ad:	eb 47                	jmp    f01198f6 <test_priority_normal_and_lower+0x1d3>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f01198af:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f01198b2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01198b5:	89 d0                	mov    %edx,%eax
f01198b7:	01 c0                	add    %eax,%eax
f01198b9:	01 d0                	add    %edx,%eax
f01198bb:	c1 e0 03             	shl    $0x3,%eax
f01198be:	01 c8                	add    %ecx,%eax
f01198c0:	05 88 00 00 00       	add    $0x88,%eax
f01198c5:	8b 10                	mov    (%eax),%edx
f01198c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01198ca:	89 94 85 50 fb ff ff 	mov    %edx,-0x4b0(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f01198d1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f01198d4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01198d7:	89 d0                	mov    %edx,%eax
f01198d9:	01 c0                	add    %eax,%eax
f01198db:	01 d0                	add    %edx,%eax
f01198dd:	c1 e0 03             	shl    $0x3,%eax
f01198e0:	01 c8                	add    %ecx,%eax
f01198e2:	05 90 00 00 00       	add    $0x90,%eax
f01198e7:	8b 10                	mov    (%eax),%edx
f01198e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01198ec:	89 94 85 a0 fb ff ff 	mov    %edx,-0x460(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs should be initially loaded with the given working set size\n");

		for(int i = 0; i < 20; i++)
f01198f3:	ff 45 e4             	incl   -0x1c(%ebp)
f01198f6:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f01198fa:	7e b3                	jle    f01198af <test_priority_normal_and_lower+0x18c>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f01198fc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0119903:	eb 47                	jmp    f011994c <test_priority_normal_and_lower+0x229>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f0119905:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f0119908:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011990b:	89 d0                	mov    %edx,%eax
f011990d:	01 c0                	add    %eax,%eax
f011990f:	01 d0                	add    %edx,%eax
f0119911:	c1 e0 03             	shl    $0x3,%eax
f0119914:	01 c8                	add    %ecx,%eax
f0119916:	05 88 00 00 00       	add    $0x88,%eax
f011991b:	8b 10                	mov    (%eax),%edx
f011991d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119920:	89 94 85 80 fd ff ff 	mov    %edx,-0x280(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f0119927:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f011992a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011992d:	89 d0                	mov    %edx,%eax
f011992f:	01 c0                	add    %eax,%eax
f0119931:	01 d0                	add    %edx,%eax
f0119933:	c1 e0 03             	shl    $0x3,%eax
f0119936:	01 c8                	add    %ecx,%eax
f0119938:	05 90 00 00 00       	add    $0x90,%eax
f011993d:	8b 10                	mov    (%eax),%edx
f011993f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119942:	89 94 85 f8 fd ff ff 	mov    %edx,-0x208(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f0119949:	ff 45 e0             	incl   -0x20(%ebp)
f011994c:	83 7d e0 1d          	cmpl   $0x1d,-0x20(%ebp)
f0119950:	7e b3                	jle    f0119905 <test_priority_normal_and_lower+0x1e2>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f0119952:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0119959:	eb 47                	jmp    f01199a2 <test_priority_normal_and_lower+0x27f>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f011995b:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f011995e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0119961:	89 d0                	mov    %edx,%eax
f0119963:	01 c0                	add    %eax,%eax
f0119965:	01 d0                	add    %edx,%eax
f0119967:	c1 e0 03             	shl    $0x3,%eax
f011996a:	01 c8                	add    %ecx,%eax
f011996c:	05 88 00 00 00       	add    $0x88,%eax
f0119971:	8b 10                	mov    (%eax),%edx
f0119973:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119976:	89 94 85 70 fe ff ff 	mov    %edx,-0x190(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f011997d:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f0119980:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0119983:	89 d0                	mov    %edx,%eax
f0119985:	01 c0                	add    %eax,%eax
f0119987:	01 d0                	add    %edx,%eax
f0119989:	c1 e0 03             	shl    $0x3,%eax
f011998c:	01 c8                	add    %ecx,%eax
f011998e:	05 90 00 00 00       	add    $0x90,%eax
f0119993:	8b 10                	mov    (%eax),%edx
f0119995:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119998:	89 94 85 10 ff ff ff 	mov    %edx,-0xf0(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f011999f:	ff 45 dc             	incl   -0x24(%ebp)
f01199a2:	83 7d dc 27          	cmpl   $0x27,-0x24(%ebp)
f01199a6:	7e b3                	jle    f011995b <test_priority_normal_and_lower+0x238>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f01199a8:	e8 5c 40 ff ff       	call   f010da09 <sys_calculate_free_frames>
f01199ad:	89 45 c0             	mov    %eax,-0x40(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f01199b0:	e8 8b ae fe ff       	call   f0104840 <pf_calculate_free_frames>
f01199b5:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f01199b8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01199bb:	83 ec 08             	sub    $0x8,%esp
f01199be:	6a 03                	push   $0x3
f01199c0:	50                   	push   %eax
f01199c1:	e8 e9 24 ff ff       	call   f010beaf <set_program_priority>
f01199c6:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f01199c9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01199cc:	83 ec 08             	sub    $0x8,%esp
f01199cf:	6a 03                	push   $0x3
f01199d1:	50                   	push   %eax
f01199d2:	e8 d8 24 ff ff       	call   f010beaf <set_program_priority>
f01199d7:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f01199da:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01199dd:	83 ec 08             	sub    $0x8,%esp
f01199e0:	6a 03                	push   $0x3
f01199e2:	50                   	push   %eax
f01199e3:	e8 c7 24 ff ff       	call   f010beaf <set_program_priority>
f01199e8:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01199eb:	e8 50 ae fe ff       	call   f0104840 <pf_calculate_free_frames>
f01199f0:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f01199f3:	74 17                	je     f0119a0c <test_priority_normal_and_lower+0x2e9>
f01199f5:	83 ec 04             	sub    $0x4,%esp
f01199f8:	68 b4 e0 12 f0       	push   $0xf012e0b4
f01199fd:	68 11 01 00 00       	push   $0x111
f0119a02:	68 31 e0 12 f0       	push   $0xf012e031
f0119a07:	e8 0e 69 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0119a0c:	e8 f8 3f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119a11:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0119a14:	74 17                	je     f0119a2d <test_priority_normal_and_lower+0x30a>
f0119a16:	83 ec 04             	sub    $0x4,%esp
f0119a19:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119a1e:	68 12 01 00 00       	push   $0x112
f0119a23:	68 31 e0 12 f0       	push   $0xf012e031
f0119a28:	e8 ed 68 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0119a2d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119a30:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119a36:	83 f8 14             	cmp    $0x14,%eax
f0119a39:	75 1c                	jne    f0119a57 <test_priority_normal_and_lower+0x334>
f0119a3b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119a3e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119a44:	83 f8 1e             	cmp    $0x1e,%eax
f0119a47:	75 0e                	jne    f0119a57 <test_priority_normal_and_lower+0x334>
f0119a49:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119a4c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119a52:	83 f8 28             	cmp    $0x28,%eax
f0119a55:	74 17                	je     f0119a6e <test_priority_normal_and_lower+0x34b>
			panic("The programs' working set size should not change after setting priority to normal\n");
f0119a57:	83 ec 04             	sub    $0x4,%esp
f0119a5a:	68 e0 e0 12 f0       	push   $0xf012e0e0
f0119a5f:	68 15 01 00 00       	push   $0x115
f0119a64:	68 31 e0 12 f0       	push   $0xf012e031
f0119a69:	e8 ac 68 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0119a6e:	e8 96 3f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119a73:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119a76:	e8 c5 ad fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119a7b:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0119a7e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119a81:	83 ec 08             	sub    $0x8,%esp
f0119a84:	6a 02                	push   $0x2
f0119a86:	50                   	push   %eax
f0119a87:	e8 23 24 ff ff       	call   f010beaf <set_program_priority>
f0119a8c:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0119a8f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119a92:	83 ec 08             	sub    $0x8,%esp
f0119a95:	6a 02                	push   $0x2
f0119a97:	50                   	push   %eax
f0119a98:	e8 12 24 ff ff       	call   f010beaf <set_program_priority>
f0119a9d:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f0119aa0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119aa3:	83 ec 08             	sub    $0x8,%esp
f0119aa6:	6a 02                	push   $0x2
f0119aa8:	50                   	push   %eax
f0119aa9:	e8 01 24 ff ff       	call   f010beaf <set_program_priority>
f0119aae:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119ab1:	e8 8a ad fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119ab6:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0119ab9:	74 17                	je     f0119ad2 <test_priority_normal_and_lower+0x3af>
f0119abb:	83 ec 04             	sub    $0x4,%esp
f0119abe:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119ac3:	68 1f 01 00 00       	push   $0x11f
f0119ac8:	68 31 e0 12 f0       	push   $0xf012e031
f0119acd:	e8 48 68 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0119ad2:	e8 32 3f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119ad7:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0119ada:	74 21                	je     f0119afd <test_priority_normal_and_lower+0x3da>
f0119adc:	e8 28 3f ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119ae1:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0119ae4:	29 c2                	sub    %eax,%edx
f0119ae6:	89 d0                	mov    %edx,%eax
f0119ae8:	50                   	push   %eax
f0119ae9:	68 34 e1 12 f0       	push   $0xf012e134
f0119aee:	68 20 01 00 00       	push   $0x120
f0119af3:	68 31 e0 12 f0       	push   $0xf012e031
f0119af8:	e8 1d 68 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0119afd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119b00:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119b06:	83 f8 0a             	cmp    $0xa,%eax
f0119b09:	75 1c                	jne    f0119b27 <test_priority_normal_and_lower+0x404>
f0119b0b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119b0e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119b14:	83 f8 0f             	cmp    $0xf,%eax
f0119b17:	75 0e                	jne    f0119b27 <test_priority_normal_and_lower+0x404>
f0119b19:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119b1c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119b22:	83 f8 14             	cmp    $0x14,%eax
f0119b25:	74 17                	je     f0119b3e <test_priority_normal_and_lower+0x41b>
			panic("The programs' working set size should be doubled only if it is full\n");
f0119b27:	83 ec 04             	sub    $0x4,%esp
f0119b2a:	68 64 e1 12 f0       	push   $0xf012e164
f0119b2f:	68 23 01 00 00       	push   $0x123
f0119b34:	68 31 e0 12 f0       	push   $0xf012e031
f0119b39:	e8 dc 67 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0119b3e:	e8 c6 3e ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119b43:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119b46:	e8 f5 ac fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119b4b:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0119b4e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119b51:	83 ec 08             	sub    $0x8,%esp
f0119b54:	6a 02                	push   $0x2
f0119b56:	50                   	push   %eax
f0119b57:	e8 53 23 ff ff       	call   f010beaf <set_program_priority>
f0119b5c:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0119b5f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119b62:	83 ec 08             	sub    $0x8,%esp
f0119b65:	6a 02                	push   $0x2
f0119b67:	50                   	push   %eax
f0119b68:	e8 42 23 ff ff       	call   f010beaf <set_program_priority>
f0119b6d:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f0119b70:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119b73:	83 ec 08             	sub    $0x8,%esp
f0119b76:	6a 02                	push   $0x2
f0119b78:	50                   	push   %eax
f0119b79:	e8 31 23 ff ff       	call   f010beaf <set_program_priority>
f0119b7e:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119b81:	e8 ba ac fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119b86:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0119b89:	74 17                	je     f0119ba2 <test_priority_normal_and_lower+0x47f>
f0119b8b:	83 ec 04             	sub    $0x4,%esp
f0119b8e:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119b93:	68 2d 01 00 00       	push   $0x12d
f0119b98:	68 31 e0 12 f0       	push   $0xf012e031
f0119b9d:	e8 78 67 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0119ba2:	e8 62 3e ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119ba7:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0119baa:	74 21                	je     f0119bcd <test_priority_normal_and_lower+0x4aa>
f0119bac:	e8 58 3e ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119bb1:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0119bb4:	29 c2                	sub    %eax,%edx
f0119bb6:	89 d0                	mov    %edx,%eax
f0119bb8:	50                   	push   %eax
f0119bb9:	68 34 e1 12 f0       	push   $0xf012e134
f0119bbe:	68 2e 01 00 00       	push   $0x12e
f0119bc3:	68 31 e0 12 f0       	push   $0xf012e031
f0119bc8:	e8 4d 67 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0119bcd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119bd0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119bd6:	83 f8 0a             	cmp    $0xa,%eax
f0119bd9:	75 1c                	jne    f0119bf7 <test_priority_normal_and_lower+0x4d4>
f0119bdb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119bde:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119be4:	83 f8 0f             	cmp    $0xf,%eax
f0119be7:	75 0e                	jne    f0119bf7 <test_priority_normal_and_lower+0x4d4>
f0119be9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119bec:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119bf2:	83 f8 0a             	cmp    $0xa,%eax
f0119bf5:	74 17                	je     f0119c0e <test_priority_normal_and_lower+0x4eb>
			panic("The programs' working set size should be doubled only if it is full\n");
f0119bf7:	83 ec 04             	sub    $0x4,%esp
f0119bfa:	68 64 e1 12 f0       	push   $0xf012e164
f0119bff:	68 31 01 00 00       	push   $0x131
f0119c04:	68 31 e0 12 f0       	push   $0xf012e031
f0119c09:	e8 0c 67 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 10; i++)
f0119c0e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0119c15:	eb 7d                	jmp    f0119c94 <test_priority_normal_and_lower+0x571>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0119c17:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119c1a:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0119c21:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119c24:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0119c27:	89 d0                	mov    %edx,%eax
f0119c29:	01 c0                	add    %eax,%eax
f0119c2b:	01 d0                	add    %edx,%eax
f0119c2d:	c1 e0 03             	shl    $0x3,%eax
f0119c30:	01 d8                	add    %ebx,%eax
f0119c32:	05 88 00 00 00       	add    $0x88,%eax
f0119c37:	8b 00                	mov    (%eax),%eax
f0119c39:	39 c1                	cmp    %eax,%ecx
f0119c3b:	74 17                	je     f0119c54 <test_priority_normal_and_lower+0x531>
				panic("Working set should be moved properly to the new one");
f0119c3d:	83 ec 04             	sub    $0x4,%esp
f0119c40:	68 24 e2 12 f0       	push   $0xf012e224
f0119c45:	68 36 01 00 00       	push   $0x136
f0119c4a:	68 31 e0 12 f0       	push   $0xf012e031
f0119c4f:	e8 c6 66 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0119c54:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119c57:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0119c5e:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119c61:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0119c64:	89 d0                	mov    %edx,%eax
f0119c66:	01 c0                	add    %eax,%eax
f0119c68:	01 d0                	add    %edx,%eax
f0119c6a:	c1 e0 03             	shl    $0x3,%eax
f0119c6d:	01 d8                	add    %ebx,%eax
f0119c6f:	05 90 00 00 00       	add    $0x90,%eax
f0119c74:	8b 00                	mov    (%eax),%eax
f0119c76:	39 c1                	cmp    %eax,%ecx
f0119c78:	74 17                	je     f0119c91 <test_priority_normal_and_lower+0x56e>
				panic("Working set should be moved properly to the new one");
f0119c7a:	83 ec 04             	sub    $0x4,%esp
f0119c7d:	68 24 e2 12 f0       	push   $0xf012e224
f0119c82:	68 39 01 00 00       	push   $0x139
f0119c87:	68 31 e0 12 f0       	push   $0xf012e031
f0119c8c:	e8 89 66 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs' working set size should be doubled only if it is full\n");

		for(int i = 0; i < 10; i++)
f0119c91:	ff 45 d8             	incl   -0x28(%ebp)
f0119c94:	83 7d d8 09          	cmpl   $0x9,-0x28(%ebp)
f0119c98:	0f 8e 79 ff ff ff    	jle    f0119c17 <test_priority_normal_and_lower+0x4f4>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0119c9e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0119ca5:	eb 7d                	jmp    f0119d24 <test_priority_normal_and_lower+0x601>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0119ca7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119caa:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f0119cb1:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119cb4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0119cb7:	89 d0                	mov    %edx,%eax
f0119cb9:	01 c0                	add    %eax,%eax
f0119cbb:	01 d0                	add    %edx,%eax
f0119cbd:	c1 e0 03             	shl    $0x3,%eax
f0119cc0:	01 d8                	add    %ebx,%eax
f0119cc2:	05 88 00 00 00       	add    $0x88,%eax
f0119cc7:	8b 00                	mov    (%eax),%eax
f0119cc9:	39 c1                	cmp    %eax,%ecx
f0119ccb:	74 17                	je     f0119ce4 <test_priority_normal_and_lower+0x5c1>
				panic("Working set should be moved properly to the new one");
f0119ccd:	83 ec 04             	sub    $0x4,%esp
f0119cd0:	68 24 e2 12 f0       	push   $0xf012e224
f0119cd5:	68 3f 01 00 00       	push   $0x13f
f0119cda:	68 31 e0 12 f0       	push   $0xf012e031
f0119cdf:	e8 36 66 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f0119ce4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119ce7:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f0119cee:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119cf1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0119cf4:	89 d0                	mov    %edx,%eax
f0119cf6:	01 c0                	add    %eax,%eax
f0119cf8:	01 d0                	add    %edx,%eax
f0119cfa:	c1 e0 03             	shl    $0x3,%eax
f0119cfd:	01 d8                	add    %ebx,%eax
f0119cff:	05 90 00 00 00       	add    $0x90,%eax
f0119d04:	8b 00                	mov    (%eax),%eax
f0119d06:	39 c1                	cmp    %eax,%ecx
f0119d08:	74 17                	je     f0119d21 <test_priority_normal_and_lower+0x5fe>
				panic("Working set should be moved properly to the new one");
f0119d0a:	83 ec 04             	sub    $0x4,%esp
f0119d0d:	68 24 e2 12 f0       	push   $0xf012e224
f0119d12:	68 42 01 00 00       	push   $0x142
f0119d17:	68 31 e0 12 f0       	push   $0xf012e031
f0119d1c:	e8 f9 65 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0119d21:	ff 45 d4             	incl   -0x2c(%ebp)
f0119d24:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f0119d28:	0f 8e 79 ff ff ff    	jle    f0119ca7 <test_priority_normal_and_lower+0x584>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0119d2e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0119d35:	eb 7d                	jmp    f0119db4 <test_priority_normal_and_lower+0x691>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0119d37:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119d3a:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0119d41:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0119d44:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0119d47:	89 d0                	mov    %edx,%eax
f0119d49:	01 c0                	add    %eax,%eax
f0119d4b:	01 d0                	add    %edx,%eax
f0119d4d:	c1 e0 03             	shl    $0x3,%eax
f0119d50:	01 d8                	add    %ebx,%eax
f0119d52:	05 88 00 00 00       	add    $0x88,%eax
f0119d57:	8b 00                	mov    (%eax),%eax
f0119d59:	39 c1                	cmp    %eax,%ecx
f0119d5b:	74 17                	je     f0119d74 <test_priority_normal_and_lower+0x651>
				panic("Working set should be moved properly to the new one");
f0119d5d:	83 ec 04             	sub    $0x4,%esp
f0119d60:	68 24 e2 12 f0       	push   $0xf012e224
f0119d65:	68 48 01 00 00       	push   $0x148
f0119d6a:	68 31 e0 12 f0       	push   $0xf012e031
f0119d6f:	e8 a6 65 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0119d74:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119d77:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0119d7e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0119d81:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0119d84:	89 d0                	mov    %edx,%eax
f0119d86:	01 c0                	add    %eax,%eax
f0119d88:	01 d0                	add    %edx,%eax
f0119d8a:	c1 e0 03             	shl    $0x3,%eax
f0119d8d:	01 d8                	add    %ebx,%eax
f0119d8f:	05 90 00 00 00       	add    $0x90,%eax
f0119d94:	8b 00                	mov    (%eax),%eax
f0119d96:	39 c1                	cmp    %eax,%ecx
f0119d98:	74 17                	je     f0119db1 <test_priority_normal_and_lower+0x68e>
				panic("Working set should be moved properly to the new one");
f0119d9a:	83 ec 04             	sub    $0x4,%esp
f0119d9d:	68 24 e2 12 f0       	push   $0xf012e224
f0119da2:	68 4b 01 00 00       	push   $0x14b
f0119da7:	68 31 e0 12 f0       	push   $0xf012e031
f0119dac:	e8 69 65 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0119db1:	ff 45 d0             	incl   -0x30(%ebp)
f0119db4:	83 7d d0 09          	cmpl   $0x9,-0x30(%ebp)
f0119db8:	0f 8e 79 ff ff ff    	jle    f0119d37 <test_priority_normal_and_lower+0x614>
			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		// Set priority to low
		freeFrames = sys_calculate_free_frames();
f0119dbe:	e8 46 3c ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119dc3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119dc6:	e8 75 aa fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119dcb:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0119dce:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119dd1:	83 ec 08             	sub    $0x8,%esp
f0119dd4:	6a 01                	push   $0x1
f0119dd6:	50                   	push   %eax
f0119dd7:	e8 d3 20 ff ff       	call   f010beaf <set_program_priority>
f0119ddc:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 1);
f0119ddf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119de2:	83 ec 08             	sub    $0x8,%esp
f0119de5:	6a 01                	push   $0x1
f0119de7:	50                   	push   %eax
f0119de8:	e8 c2 20 ff ff       	call   f010beaf <set_program_priority>
f0119ded:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 1);
f0119df0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119df3:	83 ec 08             	sub    $0x8,%esp
f0119df6:	6a 01                	push   $0x1
f0119df8:	50                   	push   %eax
f0119df9:	e8 b1 20 ff ff       	call   f010beaf <set_program_priority>
f0119dfe:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119e01:	e8 3a aa fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119e06:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0119e09:	74 17                	je     f0119e22 <test_priority_normal_and_lower+0x6ff>
f0119e0b:	83 ec 04             	sub    $0x4,%esp
f0119e0e:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119e13:	68 54 01 00 00       	push   $0x154
f0119e18:	68 31 e0 12 f0       	push   $0xf012e031
f0119e1d:	e8 f8 64 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != (5+3+5)) panic("Old working set and extra pages in WS should be removed properly %d\n");
f0119e22:	e8 e2 3b ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119e27:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0119e2a:	83 f8 0d             	cmp    $0xd,%eax
f0119e2d:	74 17                	je     f0119e46 <test_priority_normal_and_lower+0x723>
f0119e2f:	83 ec 04             	sub    $0x4,%esp
f0119e32:	68 0c e4 12 f0       	push   $0xf012e40c
f0119e37:	68 55 01 00 00       	push   $0x155
f0119e3c:	68 31 e0 12 f0       	push   $0xf012e031
f0119e41:	e8 d4 64 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 5 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0119e46:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119e49:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119e4f:	83 f8 05             	cmp    $0x5,%eax
f0119e52:	75 1c                	jne    f0119e70 <test_priority_normal_and_lower+0x74d>
f0119e54:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119e57:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119e5d:	83 f8 07             	cmp    $0x7,%eax
f0119e60:	75 0e                	jne    f0119e70 <test_priority_normal_and_lower+0x74d>
f0119e62:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119e65:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119e6b:	83 f8 05             	cmp    $0x5,%eax
f0119e6e:	74 17                	je     f0119e87 <test_priority_normal_and_lower+0x764>
			panic("The programs' working set size should be half\n");
f0119e70:	83 ec 04             	sub    $0x4,%esp
f0119e73:	68 54 e4 12 f0       	push   $0xf012e454
f0119e78:	68 58 01 00 00       	push   $0x158
f0119e7d:	68 31 e0 12 f0       	push   $0xf012e031
f0119e82:	e8 93 64 fe ff       	call   f010031a <_panic>


		freeFrames = sys_calculate_free_frames();
f0119e87:	e8 7d 3b ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119e8c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e8f:	e8 ac a9 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119e94:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0119e97:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119e9a:	83 ec 08             	sub    $0x8,%esp
f0119e9d:	6a 01                	push   $0x1
f0119e9f:	50                   	push   %eax
f0119ea0:	e8 0a 20 ff ff       	call   f010beaf <set_program_priority>
f0119ea5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119ea8:	e8 93 a9 fe ff       	call   f0104840 <pf_calculate_free_frames>
f0119ead:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0119eb0:	74 17                	je     f0119ec9 <test_priority_normal_and_lower+0x7a6>
f0119eb2:	83 ec 04             	sub    $0x4,%esp
f0119eb5:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119eba:	68 5e 01 00 00       	push   $0x15e
f0119ebf:	68 31 e0 12 f0       	push   $0xf012e031
f0119ec4:	e8 51 64 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");
f0119ec9:	e8 3b 3b ff ff       	call   f010da09 <sys_calculate_free_frames>
f0119ece:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0119ed1:	83 f8 03             	cmp    $0x3,%eax
f0119ed4:	74 17                	je     f0119eed <test_priority_normal_and_lower+0x7ca>
f0119ed6:	83 ec 04             	sub    $0x4,%esp
f0119ed9:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0119ede:	68 5f 01 00 00       	push   $0x15f
f0119ee3:	68 31 e0 12 f0       	push   $0xf012e031
f0119ee8:	e8 2d 64 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0119eed:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119ef0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119ef6:	83 f8 02             	cmp    $0x2,%eax
f0119ef9:	75 1c                	jne    f0119f17 <test_priority_normal_and_lower+0x7f4>
f0119efb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119efe:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119f04:	83 f8 07             	cmp    $0x7,%eax
f0119f07:	75 0e                	jne    f0119f17 <test_priority_normal_and_lower+0x7f4>
f0119f09:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119f0c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119f12:	83 f8 05             	cmp    $0x5,%eax
f0119f15:	74 17                	je     f0119f2e <test_priority_normal_and_lower+0x80b>
			panic("The programs' working set size should be doubled if full\n");
f0119f17:	83 ec 04             	sub    $0x4,%esp
f0119f1a:	68 e8 e1 12 f0       	push   $0xf012e1e8
f0119f1f:	68 62 01 00 00       	push   $0x162
f0119f24:	68 31 e0 12 f0       	push   $0xf012e031
f0119f29:	e8 ec 63 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 2; i++)
f0119f2e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0119f35:	e9 83 00 00 00       	jmp    f0119fbd <test_priority_normal_and_lower+0x89a>
		{
			if(add_WS[i+8] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0119f3a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119f3d:	83 c0 08             	add    $0x8,%eax
f0119f40:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0119f47:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119f4a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0119f4d:	89 d0                	mov    %edx,%eax
f0119f4f:	01 c0                	add    %eax,%eax
f0119f51:	01 d0                	add    %edx,%eax
f0119f53:	c1 e0 03             	shl    $0x3,%eax
f0119f56:	01 d8                	add    %ebx,%eax
f0119f58:	05 88 00 00 00       	add    $0x88,%eax
f0119f5d:	8b 00                	mov    (%eax),%eax
f0119f5f:	39 c1                	cmp    %eax,%ecx
f0119f61:	74 17                	je     f0119f7a <test_priority_normal_and_lower+0x857>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119f63:	83 ec 04             	sub    $0x4,%esp
f0119f66:	68 84 e4 12 f0       	push   $0xf012e484
f0119f6b:	68 67 01 00 00       	push   $0x167
f0119f70:	68 31 e0 12 f0       	push   $0xf012e031
f0119f75:	e8 a0 63 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0119f7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119f7d:	83 c0 08             	add    $0x8,%eax
f0119f80:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0119f87:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119f8a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0119f8d:	89 d0                	mov    %edx,%eax
f0119f8f:	01 c0                	add    %eax,%eax
f0119f91:	01 d0                	add    %edx,%eax
f0119f93:	c1 e0 03             	shl    $0x3,%eax
f0119f96:	01 d8                	add    %ebx,%eax
f0119f98:	05 90 00 00 00       	add    $0x90,%eax
f0119f9d:	8b 00                	mov    (%eax),%eax
f0119f9f:	39 c1                	cmp    %eax,%ecx
f0119fa1:	74 17                	je     f0119fba <test_priority_normal_and_lower+0x897>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119fa3:	83 ec 04             	sub    $0x4,%esp
f0119fa6:	68 84 e4 12 f0       	push   $0xf012e484
f0119fab:	68 6a 01 00 00       	push   $0x16a
f0119fb0:	68 31 e0 12 f0       	push   $0xf012e031
f0119fb5:	e8 60 63 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 0; i < 2; i++)
f0119fba:	ff 45 cc             	incl   -0x34(%ebp)
f0119fbd:	83 7d cc 01          	cmpl   $0x1,-0x34(%ebp)
f0119fc1:	0f 8e 73 ff ff ff    	jle    f0119f3a <test_priority_normal_and_lower+0x817>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f0119fc7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0119fce:	e9 83 00 00 00       	jmp    f011a056 <test_priority_normal_and_lower+0x933>
		{
			if(fact_WS[i+3] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0119fd3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119fd6:	83 c0 03             	add    $0x3,%eax
f0119fd9:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f0119fe0:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119fe3:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0119fe6:	89 d0                	mov    %edx,%eax
f0119fe8:	01 c0                	add    %eax,%eax
f0119fea:	01 d0                	add    %edx,%eax
f0119fec:	c1 e0 03             	shl    $0x3,%eax
f0119fef:	01 d8                	add    %ebx,%eax
f0119ff1:	05 88 00 00 00       	add    $0x88,%eax
f0119ff6:	8b 00                	mov    (%eax),%eax
f0119ff8:	39 c1                	cmp    %eax,%ecx
f0119ffa:	74 17                	je     f011a013 <test_priority_normal_and_lower+0x8f0>
				panic("%d Working set should be moved properly to the new one, removed pages are chosen based on replacement policy", i);
f0119ffc:	ff 75 c8             	pushl  -0x38(%ebp)
f0119fff:	68 f0 e4 12 f0       	push   $0xf012e4f0
f011a004:	68 70 01 00 00       	push   $0x170
f011a009:	68 31 e0 12 f0       	push   $0xf012e031
f011a00e:	e8 07 63 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f011a013:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a016:	83 c0 03             	add    $0x3,%eax
f011a019:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f011a020:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f011a023:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011a026:	89 d0                	mov    %edx,%eax
f011a028:	01 c0                	add    %eax,%eax
f011a02a:	01 d0                	add    %edx,%eax
f011a02c:	c1 e0 03             	shl    $0x3,%eax
f011a02f:	01 d8                	add    %ebx,%eax
f011a031:	05 90 00 00 00       	add    $0x90,%eax
f011a036:	8b 00                	mov    (%eax),%eax
f011a038:	39 c1                	cmp    %eax,%ecx
f011a03a:	74 17                	je     f011a053 <test_priority_normal_and_lower+0x930>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f011a03c:	83 ec 04             	sub    $0x4,%esp
f011a03f:	68 84 e4 12 f0       	push   $0xf012e484
f011a044:	68 73 01 00 00       	push   $0x173
f011a049:	68 31 e0 12 f0       	push   $0xf012e031
f011a04e:	e8 c7 62 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f011a053:	ff 45 c8             	incl   -0x38(%ebp)
f011a056:	83 7d c8 06          	cmpl   $0x6,-0x38(%ebp)
f011a05a:	0f 8e 73 ff ff ff    	jle    f0119fd3 <test_priority_normal_and_lower+0x8b0>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f011a060:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011a067:	e9 83 00 00 00       	jmp    f011a0ef <test_priority_normal_and_lower+0x9cc>
		{
			if(hello_WS[i+5] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f011a06c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a06f:	83 c0 05             	add    $0x5,%eax
f011a072:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f011a079:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011a07c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011a07f:	89 d0                	mov    %edx,%eax
f011a081:	01 c0                	add    %eax,%eax
f011a083:	01 d0                	add    %edx,%eax
f011a085:	c1 e0 03             	shl    $0x3,%eax
f011a088:	01 d8                	add    %ebx,%eax
f011a08a:	05 88 00 00 00       	add    $0x88,%eax
f011a08f:	8b 00                	mov    (%eax),%eax
f011a091:	39 c1                	cmp    %eax,%ecx
f011a093:	74 17                	je     f011a0ac <test_priority_normal_and_lower+0x989>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f011a095:	83 ec 04             	sub    $0x4,%esp
f011a098:	68 84 e4 12 f0       	push   $0xf012e484
f011a09d:	68 79 01 00 00       	push   $0x179
f011a0a2:	68 31 e0 12 f0       	push   $0xf012e031
f011a0a7:	e8 6e 62 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f011a0ac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a0af:	83 c0 05             	add    $0x5,%eax
f011a0b2:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f011a0b9:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011a0bc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011a0bf:	89 d0                	mov    %edx,%eax
f011a0c1:	01 c0                	add    %eax,%eax
f011a0c3:	01 d0                	add    %edx,%eax
f011a0c5:	c1 e0 03             	shl    $0x3,%eax
f011a0c8:	01 d8                	add    %ebx,%eax
f011a0ca:	05 90 00 00 00       	add    $0x90,%eax
f011a0cf:	8b 00                	mov    (%eax),%eax
f011a0d1:	39 c1                	cmp    %eax,%ecx
f011a0d3:	74 17                	je     f011a0ec <test_priority_normal_and_lower+0x9c9>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f011a0d5:	83 ec 04             	sub    $0x4,%esp
f011a0d8:	68 84 e4 12 f0       	push   $0xf012e484
f011a0dd:	68 7c 01 00 00       	push   $0x17c
f011a0e2:	68 31 e0 12 f0       	push   $0xf012e031
f011a0e7:	e8 2e 62 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f011a0ec:	ff 45 c4             	incl   -0x3c(%ebp)
f011a0ef:	83 7d c4 04          	cmpl   $0x4,-0x3c(%ebp)
f011a0f3:	0f 8e 73 ff ff ff    	jle    f011a06c <test_priority_normal_and_lower+0x949>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		set_program_priority(addEnv, 5);
f011a0f9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a0fc:	83 ec 08             	sub    $0x8,%esp
f011a0ff:	6a 05                	push   $0x5
f011a101:	50                   	push   %eax
f011a102:	e8 a8 1d ff ff       	call   f010beaf <set_program_priority>
f011a107:	83 c4 10             	add    $0x10,%esp
		set_program_priority(addEnv, 5);
f011a10a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a10d:	83 ec 08             	sub    $0x8,%esp
f011a110:	6a 05                	push   $0x5
f011a112:	50                   	push   %eax
f011a113:	e8 97 1d ff ff       	call   f010beaf <set_program_priority>
f011a118:	83 c4 10             	add    $0x10,%esp

		char command4[100] = "runall";
f011a11b:	c7 85 1c fd ff ff 72 	movl   $0x616e7572,-0x2e4(%ebp)
f011a122:	75 6e 61 
f011a125:	c7 85 20 fd ff ff 6c 	movl   $0x6c6c,-0x2e0(%ebp)
f011a12c:	6c 00 00 
f011a12f:	8d 95 24 fd ff ff    	lea    -0x2dc(%ebp),%edx
f011a135:	b9 17 00 00 00       	mov    $0x17,%ecx
f011a13a:	b8 00 00 00 00       	mov    $0x0,%eax
f011a13f:	89 d7                	mov    %edx,%edi
f011a141:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f011a143:	83 ec 0c             	sub    $0xc,%esp
f011a146:	8d 85 1c fd ff ff    	lea    -0x2e4(%ebp),%eax
f011a14c:	50                   	push   %eax
f011a14d:	e8 8a 7d fe ff       	call   f0101edc <execute_command>
f011a152:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
	}
#endif
}
f011a155:	eb 10                	jmp    f011a167 <test_priority_normal_and_lower+0xa44>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
f011a157:	83 ec 0c             	sub    $0xc,%esp
f011a15a:	68 60 e5 12 f0       	push   $0xf012e560
f011a15f:	e8 08 6e fe ff       	call   f0100f6c <cprintf>
f011a164:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f011a167:	90                   	nop
f011a168:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011a16b:	5b                   	pop    %ebx
f011a16c:	5e                   	pop    %esi
f011a16d:	5f                   	pop    %edi
f011a16e:	5d                   	pop    %ebp
f011a16f:	c3                   	ret    

f011a170 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f011a170:	55                   	push   %ebp
f011a171:	89 e5                	mov    %esp,%ebp
f011a173:	57                   	push   %edi
f011a174:	53                   	push   %ebx
f011a175:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a17b:	83 ec 0c             	sub    $0xc,%esp
f011a17e:	68 80 e6 12 f0       	push   $0xf012e680
f011a183:	e8 e4 6d fe ff       	call   f0100f6c <cprintf>
f011a188:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a18b:	83 ec 0c             	sub    $0xc,%esp
f011a18e:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011a193:	e8 d4 6d fe ff       	call   f0100f6c <cprintf>
f011a198:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a19b:	83 ec 0c             	sub    $0xc,%esp
f011a19e:	68 80 e6 12 f0       	push   $0xf012e680
f011a1a3:	e8 c4 6d fe ff       	call   f0100f6c <cprintf>
f011a1a8:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a1ab:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f011a1af:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f011a1b3:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f011a1b9:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f011a1bf:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a1c6:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f011a1cd:	e8 37 38 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a1d2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f011a1d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011a1dc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f011a1e3:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f011a1e9:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a1ee:	b8 00 00 00 00       	mov    $0x0,%eax
f011a1f3:	89 d7                	mov    %edx,%edi
f011a1f5:	f3 ab                	rep stos %eax,%es:(%edi)
	correct = 1 ;
f011a1f7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f011a1fe:	e8 06 38 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a203:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a206:	e8 35 a6 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a20b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f011a20e:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f011a215:	83 ec 0c             	sub    $0xc,%esp
f011a218:	ff 75 cc             	pushl  -0x34(%ebp)
f011a21b:	e8 96 e8 fe ff       	call   f0108ab6 <kmalloc>
f011a220:	83 c4 10             	add    $0x10,%esp
f011a223:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f011a229:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011a22f:	85 c0                	test   %eax,%eax
f011a231:	74 17                	je     f011a24a <test_kmalloc+0xda>
f011a233:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a23a:	83 ec 0c             	sub    $0xc,%esp
f011a23d:	68 0c e7 12 f0       	push   $0xf012e70c
f011a242:	e8 25 6d fe ff       	call   f0100f6c <cprintf>
f011a247:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a24a:	e8 f1 a5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a24f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a252:	74 17                	je     f011a26b <test_kmalloc+0xfb>
f011a254:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a25b:	83 ec 0c             	sub    $0xc,%esp
f011a25e:	68 40 e7 12 f0       	push   $0xf012e740
f011a263:	e8 04 6d fe ff       	call   f0100f6c <cprintf>
f011a268:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a26b:	e8 99 37 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a270:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011a273:	74 17                	je     f011a28c <test_kmalloc+0x11c>
f011a275:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a27c:	83 ec 0c             	sub    $0xc,%esp
f011a27f:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a284:	e8 e3 6c fe ff       	call   f0100f6c <cprintf>
f011a289:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a28c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a290:	74 04                	je     f011a296 <test_kmalloc+0x126>
f011a292:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011a296:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a29d:	e8 67 37 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a2a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a2a5:	e8 96 a5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a2aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a2ad:	83 ec 0c             	sub    $0xc,%esp
f011a2b0:	68 00 fc 1f 00       	push   $0x1ffc00
f011a2b5:	e8 fc e7 fe ff       	call   f0108ab6 <kmalloc>
f011a2ba:	83 c4 10             	add    $0x10,%esp
f011a2bd:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a2c3:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011a2c9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a2ce:	74 17                	je     f011a2e7 <test_kmalloc+0x177>
f011a2d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a2d7:	83 ec 0c             	sub    $0xc,%esp
f011a2da:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a2df:	e8 88 6c fe ff       	call   f0100f6c <cprintf>
f011a2e4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a2e7:	e8 54 a5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a2ec:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a2ef:	74 17                	je     f011a308 <test_kmalloc+0x198>
f011a2f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a2f8:	83 ec 0c             	sub    $0xc,%esp
f011a2fb:	68 40 e7 12 f0       	push   $0xf012e740
f011a300:	e8 67 6c fe ff       	call   f0100f6c <cprintf>
f011a305:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a308:	e8 fc 36 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a30d:	89 c2                	mov    %eax,%edx
f011a30f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a312:	29 d0                	sub    %edx,%eax
f011a314:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a319:	7f 17                	jg     f011a332 <test_kmalloc+0x1c2>
f011a31b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a322:	83 ec 0c             	sub    $0xc,%esp
f011a325:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a32a:	e8 3d 6c fe ff       	call   f0100f6c <cprintf>
f011a32f:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a332:	e8 d2 36 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a337:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a33a:	e8 01 a5 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a33f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a342:	83 ec 0c             	sub    $0xc,%esp
f011a345:	68 00 fc 1f 00       	push   $0x1ffc00
f011a34a:	e8 67 e7 fe ff       	call   f0108ab6 <kmalloc>
f011a34f:	83 c4 10             	add    $0x10,%esp
f011a352:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a358:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011a35e:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a363:	74 17                	je     f011a37c <test_kmalloc+0x20c>
f011a365:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a36c:	83 ec 0c             	sub    $0xc,%esp
f011a36f:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a374:	e8 f3 6b fe ff       	call   f0100f6c <cprintf>
f011a379:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a37c:	e8 bf a4 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a381:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a384:	74 17                	je     f011a39d <test_kmalloc+0x22d>
f011a386:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a38d:	83 ec 0c             	sub    $0xc,%esp
f011a390:	68 40 e7 12 f0       	push   $0xf012e740
f011a395:	e8 d2 6b fe ff       	call   f0100f6c <cprintf>
f011a39a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a39d:	e8 67 36 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a3a2:	89 c2                	mov    %eax,%edx
f011a3a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a3a7:	29 d0                	sub    %edx,%eax
f011a3a9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a3ae:	7f 17                	jg     f011a3c7 <test_kmalloc+0x257>
f011a3b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a3b7:	83 ec 0c             	sub    $0xc,%esp
f011a3ba:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a3bf:	e8 a8 6b fe ff       	call   f0100f6c <cprintf>
f011a3c4:	83 c4 10             	add    $0x10,%esp

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011a3c7:	e8 3d 36 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a3cc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a3cf:	e8 6c a4 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a3d4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo-1);
f011a3d7:	83 ec 0c             	sub    $0xc,%esp
f011a3da:	68 ff 07 00 00       	push   $0x7ff
f011a3df:	e8 d2 e6 fe ff       	call   f0108ab6 <kmalloc>
f011a3e4:	83 c4 10             	add    $0x10,%esp
f011a3e7:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a3ed:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011a3f3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a3f8:	76 28                	jbe    f011a422 <test_kmalloc+0x2b2>
f011a3fa:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f011a400:	83 ec 0c             	sub    $0xc,%esp
f011a403:	6a 00                	push   $0x0
f011a405:	e8 a2 e6 fe ff       	call   f0108aac <sbrk>
f011a40a:	83 c4 10             	add    $0x10,%esp
f011a40d:	39 c3                	cmp    %eax,%ebx
f011a40f:	73 11                	jae    f011a422 <test_kmalloc+0x2b2>
f011a411:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011a417:	89 c2                	mov    %eax,%edx
f011a419:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011a41e:	39 c2                	cmp    %eax,%edx
f011a420:	72 17                	jb     f011a439 <test_kmalloc+0x2c9>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a422:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a429:	83 ec 0c             	sub    $0xc,%esp
f011a42c:	68 40 e8 12 f0       	push   $0xf012e840
f011a431:	e8 36 6b fe ff       	call   f0100f6c <cprintf>
f011a436:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a439:	e8 02 a4 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a43e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a441:	74 17                	je     f011a45a <test_kmalloc+0x2ea>
f011a443:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a44a:	83 ec 0c             	sub    $0xc,%esp
f011a44d:	68 40 e7 12 f0       	push   $0xf012e740
f011a452:	e8 15 6b fe ff       	call   f0100f6c <cprintf>
f011a457:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011a45a:	e8 aa 35 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a45f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a462:	e8 d9 a3 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a467:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo-1);
f011a46a:	83 ec 0c             	sub    $0xc,%esp
f011a46d:	68 ff 07 00 00       	push   $0x7ff
f011a472:	e8 3f e6 fe ff       	call   f0108ab6 <kmalloc>
f011a477:	83 c4 10             	add    $0x10,%esp
f011a47a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a480:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011a486:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a48b:	76 28                	jbe    f011a4b5 <test_kmalloc+0x345>
f011a48d:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011a493:	83 ec 0c             	sub    $0xc,%esp
f011a496:	6a 00                	push   $0x0
f011a498:	e8 0f e6 fe ff       	call   f0108aac <sbrk>
f011a49d:	83 c4 10             	add    $0x10,%esp
f011a4a0:	39 c3                	cmp    %eax,%ebx
f011a4a2:	73 11                	jae    f011a4b5 <test_kmalloc+0x345>
f011a4a4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011a4aa:	89 c2                	mov    %eax,%edx
f011a4ac:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011a4b1:	39 c2                	cmp    %eax,%edx
f011a4b3:	72 17                	jb     f011a4cc <test_kmalloc+0x35c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a4b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a4bc:	83 ec 0c             	sub    $0xc,%esp
f011a4bf:	68 40 e8 12 f0       	push   $0xf012e840
f011a4c4:	e8 a3 6a fe ff       	call   f0100f6c <cprintf>
f011a4c9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4cc:	e8 6f a3 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a4d1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a4d4:	74 17                	je     f011a4ed <test_kmalloc+0x37d>
f011a4d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a4dd:	83 ec 0c             	sub    $0xc,%esp
f011a4e0:	68 40 e7 12 f0       	push   $0xf012e740
f011a4e5:	e8 82 6a fe ff       	call   f0100f6c <cprintf>
f011a4ea:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a4ed:	e8 17 35 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a4f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a4f5:	e8 46 a3 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a4fa:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f011a4fd:	83 ec 0c             	sub    $0xc,%esp
f011a500:	68 00 1c 00 00       	push   $0x1c00
f011a505:	e8 ac e5 fe ff       	call   f0108ab6 <kmalloc>
f011a50a:	83 c4 10             	add    $0x10,%esp
f011a50d:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a513:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011a519:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a51e:	74 17                	je     f011a537 <test_kmalloc+0x3c7>
f011a520:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a527:	83 ec 0c             	sub    $0xc,%esp
f011a52a:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a52f:	e8 38 6a fe ff       	call   f0100f6c <cprintf>
f011a534:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a537:	e8 04 a3 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a53c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a53f:	74 17                	je     f011a558 <test_kmalloc+0x3e8>
f011a541:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a548:	83 ec 0c             	sub    $0xc,%esp
f011a54b:	68 40 e7 12 f0       	push   $0xf012e740
f011a550:	e8 17 6a fe ff       	call   f0100f6c <cprintf>
f011a555:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a558:	e8 ac 34 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a55d:	89 c2                	mov    %eax,%edx
f011a55f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a562:	29 d0                	sub    %edx,%eax
f011a564:	83 f8 01             	cmp    $0x1,%eax
f011a567:	7f 17                	jg     f011a580 <test_kmalloc+0x410>
f011a569:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a570:	83 ec 0c             	sub    $0xc,%esp
f011a573:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a578:	e8 ef 69 fe ff       	call   f0100f6c <cprintf>
f011a57d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a580:	e8 84 34 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a585:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a588:	e8 b3 a2 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a58d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011a590:	83 ec 0c             	sub    $0xc,%esp
f011a593:	68 00 fc 2f 00       	push   $0x2ffc00
f011a598:	e8 19 e5 fe ff       	call   f0108ab6 <kmalloc>
f011a59d:	83 c4 10             	add    $0x10,%esp
f011a5a0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a5a6:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011a5ac:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a5b1:	74 17                	je     f011a5ca <test_kmalloc+0x45a>
f011a5b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a5ba:	83 ec 0c             	sub    $0xc,%esp
f011a5bd:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a5c2:	e8 a5 69 fe ff       	call   f0100f6c <cprintf>
f011a5c7:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5ca:	e8 71 a2 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a5cf:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a5d2:	74 17                	je     f011a5eb <test_kmalloc+0x47b>
f011a5d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a5db:	83 ec 0c             	sub    $0xc,%esp
f011a5de:	68 40 e7 12 f0       	push   $0xf012e740
f011a5e3:	e8 84 69 fe ff       	call   f0100f6c <cprintf>
f011a5e8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a5eb:	e8 19 34 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a5f0:	89 c2                	mov    %eax,%edx
f011a5f2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a5f5:	29 d0                	sub    %edx,%eax
f011a5f7:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a5fc:	7f 17                	jg     f011a615 <test_kmalloc+0x4a5>
f011a5fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a605:	83 ec 0c             	sub    $0xc,%esp
f011a608:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a60d:	e8 5a 69 fe ff       	call   f0100f6c <cprintf>
f011a612:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a615:	e8 ef 33 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a61a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a61d:	e8 1e a2 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a622:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011a625:	83 ec 0c             	sub    $0xc,%esp
f011a628:	68 00 fc 5f 00       	push   $0x5ffc00
f011a62d:	e8 84 e4 fe ff       	call   f0108ab6 <kmalloc>
f011a632:	83 c4 10             	add    $0x10,%esp
f011a635:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a63b:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011a641:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a646:	74 17                	je     f011a65f <test_kmalloc+0x4ef>
f011a648:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a64f:	83 ec 0c             	sub    $0xc,%esp
f011a652:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a657:	e8 10 69 fe ff       	call   f0100f6c <cprintf>
f011a65c:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a65f:	e8 dc a1 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a664:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a667:	74 17                	je     f011a680 <test_kmalloc+0x510>
f011a669:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a670:	83 ec 0c             	sub    $0xc,%esp
f011a673:	68 40 e7 12 f0       	push   $0xf012e740
f011a678:	e8 ef 68 fe ff       	call   f0100f6c <cprintf>
f011a67d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a680:	e8 84 33 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a685:	89 c2                	mov    %eax,%edx
f011a687:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a68a:	29 d0                	sub    %edx,%eax
f011a68c:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a691:	7f 17                	jg     f011a6aa <test_kmalloc+0x53a>
f011a693:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a69a:	83 ec 0c             	sub    $0xc,%esp
f011a69d:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a6a2:	e8 c5 68 fe ff       	call   f0100f6c <cprintf>
f011a6a7:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a6aa:	e8 5a 33 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a6af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a6b2:	e8 89 a1 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a6b7:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f011a6ba:	83 ec 0c             	sub    $0xc,%esp
f011a6bd:	68 00 38 00 00       	push   $0x3800
f011a6c2:	e8 ef e3 fe ff       	call   f0108ab6 <kmalloc>
f011a6c7:	83 c4 10             	add    $0x10,%esp
f011a6ca:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a6d0:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011a6d6:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a6db:	74 17                	je     f011a6f4 <test_kmalloc+0x584>
f011a6dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a6e4:	83 ec 0c             	sub    $0xc,%esp
f011a6e7:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a6ec:	e8 7b 68 fe ff       	call   f0100f6c <cprintf>
f011a6f1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6f4:	e8 47 a1 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a6f9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a6fc:	74 17                	je     f011a715 <test_kmalloc+0x5a5>
f011a6fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a705:	83 ec 0c             	sub    $0xc,%esp
f011a708:	68 40 e7 12 f0       	push   $0xf012e740
f011a70d:	e8 5a 68 fe ff       	call   f0100f6c <cprintf>
f011a712:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a715:	e8 ef 32 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a71a:	89 c2                	mov    %eax,%edx
f011a71c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a71f:	29 d0                	sub    %edx,%eax
f011a721:	83 f8 03             	cmp    $0x3,%eax
f011a724:	7f 17                	jg     f011a73d <test_kmalloc+0x5cd>
f011a726:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a72d:	83 ec 0c             	sub    $0xc,%esp
f011a730:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a735:	e8 32 68 fe ff       	call   f0100f6c <cprintf>
f011a73a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f011a73d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a741:	74 04                	je     f011a747 <test_kmalloc+0x5d7>
f011a743:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011a747:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	{

		freeFrames = (int)sys_calculate_free_frames() ;
f011a74e:	e8 b6 32 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011a753:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a756:	e8 e5 a0 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011a75b:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f011a75e:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f011a765:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011a76b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f011a76e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a771:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a774:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f011a776:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011a779:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a77c:	01 c2                	add    %eax,%edx
f011a77e:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a781:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f011a783:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011a789:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f011a78c:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f011a793:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011a796:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a799:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f011a79c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a79f:	01 c0                	add    %eax,%eax
f011a7a1:	89 c2                	mov    %eax,%edx
f011a7a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a7a6:	01 c2                	add    %eax,%edx
f011a7a8:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011a7ac:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011a7af:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011a7b5:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f011a7b8:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011a7bf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a7c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a7c5:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f011a7c7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011a7ca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a7d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a7d4:	01 c2                	add    %eax,%edx
f011a7d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a7d9:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f011a7db:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011a7e1:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f011a7e4:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f011a7eb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a7ee:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a7f1:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f011a7f3:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011a7f6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a7f9:	01 c2                	add    %eax,%edx
f011a7fb:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a7fe:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f011a800:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011a806:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f011a809:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f011a810:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a813:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a816:	88 10                	mov    %dl,(%eax)
f011a818:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011a81b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a81e:	66 89 42 02          	mov    %ax,0x2(%edx)
f011a822:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a825:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a828:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f011a82b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a82e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a835:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a838:	01 c2                	add    %eax,%edx
f011a83a:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a83d:	88 02                	mov    %al,(%edx)
f011a83f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a842:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a849:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a84c:	01 c2                	add    %eax,%edx
f011a84e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011a852:	66 89 42 02          	mov    %ax,0x2(%edx)
f011a856:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a859:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a860:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a863:	01 c2                	add    %eax,%edx
f011a865:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a868:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f011a86b:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f011a872:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011a878:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f011a87b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a87e:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a881:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f011a883:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011a886:	89 c2                	mov    %eax,%edx
f011a888:	c1 ea 1f             	shr    $0x1f,%edx
f011a88b:	01 d0                	add    %edx,%eax
f011a88d:	d1 f8                	sar    %eax
f011a88f:	89 c2                	mov    %eax,%edx
f011a891:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a894:	01 c2                	add    %eax,%edx
f011a896:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a899:	88 c1                	mov    %al,%cl
f011a89b:	c0 e9 07             	shr    $0x7,%cl
f011a89e:	01 c8                	add    %ecx,%eax
f011a8a0:	d0 f8                	sar    %al
f011a8a2:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011a8a4:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a8a7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a8aa:	01 c2                	add    %eax,%edx
f011a8ac:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a8af:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011a8b1:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011a8b7:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f011a8ba:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011a8c1:	8b 55 98             	mov    -0x68(%ebp),%edx
f011a8c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a8c7:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f011a8ca:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a8cd:	01 c0                	add    %eax,%eax
f011a8cf:	89 c2                	mov    %eax,%edx
f011a8d1:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a8d4:	01 c2                	add    %eax,%edx
f011a8d6:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011a8da:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a8dd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a8e0:	8a 00                	mov    (%eax),%al
f011a8e2:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a8e5:	75 0f                	jne    f011a8f6 <test_kmalloc+0x786>
f011a8e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011a8ea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a8ed:	01 d0                	add    %edx,%eax
f011a8ef:	8a 00                	mov    (%eax),%al
f011a8f1:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a8f4:	74 17                	je     f011a90d <test_kmalloc+0x79d>
f011a8f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a8fd:	83 ec 0c             	sub    $0xc,%esp
f011a900:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011a905:	e8 62 66 fe ff       	call   f0100f6c <cprintf>
f011a90a:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a90d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a910:	66 8b 00             	mov    (%eax),%ax
f011a913:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011a917:	75 15                	jne    f011a92e <test_kmalloc+0x7be>
f011a919:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a91c:	01 c0                	add    %eax,%eax
f011a91e:	89 c2                	mov    %eax,%edx
f011a920:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a923:	01 d0                	add    %edx,%eax
f011a925:	66 8b 00             	mov    (%eax),%ax
f011a928:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011a92c:	74 17                	je     f011a945 <test_kmalloc+0x7d5>
f011a92e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a935:	83 ec 0c             	sub    $0xc,%esp
f011a938:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011a93d:	e8 2a 66 fe ff       	call   f0100f6c <cprintf>
f011a942:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a945:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a948:	8b 00                	mov    (%eax),%eax
f011a94a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011a94d:	75 16                	jne    f011a965 <test_kmalloc+0x7f5>
f011a94f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011a952:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a959:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a95c:	01 d0                	add    %edx,%eax
f011a95e:	8b 00                	mov    (%eax),%eax
f011a960:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011a963:	74 17                	je     f011a97c <test_kmalloc+0x80c>
f011a965:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a96c:	83 ec 0c             	sub    $0xc,%esp
f011a96f:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011a974:	e8 f3 65 fe ff       	call   f0100f6c <cprintf>
f011a979:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a97c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a97f:	8a 00                	mov    (%eax),%al
f011a981:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a984:	75 0f                	jne    f011a995 <test_kmalloc+0x825>
f011a986:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011a989:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a98c:	01 d0                	add    %edx,%eax
f011a98e:	8a 00                	mov    (%eax),%al
f011a990:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a993:	74 17                	je     f011a9ac <test_kmalloc+0x83c>
f011a995:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a99c:	83 ec 0c             	sub    $0xc,%esp
f011a99f:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011a9a4:	e8 c3 65 fe ff       	call   f0100f6c <cprintf>
f011a9a9:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a9ac:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a9af:	8a 00                	mov    (%eax),%al
f011a9b1:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a9b4:	75 16                	jne    f011a9cc <test_kmalloc+0x85c>
f011a9b6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a9b9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a9c0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a9c3:	01 d0                	add    %edx,%eax
f011a9c5:	8a 00                	mov    (%eax),%al
f011a9c7:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a9ca:	74 17                	je     f011a9e3 <test_kmalloc+0x873>
f011a9cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a9d3:	83 ec 0c             	sub    $0xc,%esp
f011a9d6:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011a9db:	e8 8c 65 fe ff       	call   f0100f6c <cprintf>
f011a9e0:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a9e3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a9e6:	66 8b 40 02          	mov    0x2(%eax),%ax
f011a9ea:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011a9ee:	75 19                	jne    f011aa09 <test_kmalloc+0x899>
f011a9f0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a9f3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a9fa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a9fd:	01 d0                	add    %edx,%eax
f011a9ff:	66 8b 40 02          	mov    0x2(%eax),%ax
f011aa03:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011aa07:	74 17                	je     f011aa20 <test_kmalloc+0x8b0>
f011aa09:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aa10:	83 ec 0c             	sub    $0xc,%esp
f011aa13:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011aa18:	e8 4f 65 fe ff       	call   f0100f6c <cprintf>
f011aa1d:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011aa20:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011aa23:	8b 40 04             	mov    0x4(%eax),%eax
f011aa26:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011aa29:	75 17                	jne    f011aa42 <test_kmalloc+0x8d2>
f011aa2b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011aa2e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011aa35:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011aa38:	01 d0                	add    %edx,%eax
f011aa3a:	8b 40 04             	mov    0x4(%eax),%eax
f011aa3d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011aa40:	74 17                	je     f011aa59 <test_kmalloc+0x8e9>
f011aa42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aa49:	83 ec 0c             	sub    $0xc,%esp
f011aa4c:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011aa51:	e8 16 65 fe ff       	call   f0100f6c <cprintf>
f011aa56:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011aa59:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011aa5c:	8a 00                	mov    (%eax),%al
f011aa5e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011aa61:	75 34                	jne    f011aa97 <test_kmalloc+0x927>
f011aa63:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011aa66:	89 c2                	mov    %eax,%edx
f011aa68:	c1 ea 1f             	shr    $0x1f,%edx
f011aa6b:	01 d0                	add    %edx,%eax
f011aa6d:	d1 f8                	sar    %eax
f011aa6f:	89 c2                	mov    %eax,%edx
f011aa71:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011aa74:	01 d0                	add    %edx,%eax
f011aa76:	8a 10                	mov    (%eax),%dl
f011aa78:	8a 45 ea             	mov    -0x16(%ebp),%al
f011aa7b:	88 c1                	mov    %al,%cl
f011aa7d:	c0 e9 07             	shr    $0x7,%cl
f011aa80:	01 c8                	add    %ecx,%eax
f011aa82:	d0 f8                	sar    %al
f011aa84:	38 c2                	cmp    %al,%dl
f011aa86:	75 0f                	jne    f011aa97 <test_kmalloc+0x927>
f011aa88:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011aa8b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011aa8e:	01 d0                	add    %edx,%eax
f011aa90:	8a 00                	mov    (%eax),%al
f011aa92:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011aa95:	74 17                	je     f011aaae <test_kmalloc+0x93e>
f011aa97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aa9e:	83 ec 0c             	sub    $0xc,%esp
f011aaa1:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011aaa6:	e8 c1 64 fe ff       	call   f0100f6c <cprintf>
f011aaab:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011aaae:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aab1:	66 8b 00             	mov    (%eax),%ax
f011aab4:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011aab8:	75 15                	jne    f011aacf <test_kmalloc+0x95f>
f011aaba:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011aabd:	01 c0                	add    %eax,%eax
f011aabf:	89 c2                	mov    %eax,%edx
f011aac1:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aac4:	01 d0                	add    %edx,%eax
f011aac6:	66 8b 00             	mov    (%eax),%ax
f011aac9:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011aacd:	74 17                	je     f011aae6 <test_kmalloc+0x976>
f011aacf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aad6:	83 ec 0c             	sub    $0xc,%esp
f011aad9:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011aade:	e8 89 64 fe ff       	call   f0100f6c <cprintf>
f011aae3:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aae6:	e8 1e 2f ff ff       	call   f010da09 <sys_calculate_free_frames>
f011aaeb:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011aaee:	74 17                	je     f011ab07 <test_kmalloc+0x997>
f011aaf0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aaf7:	83 ec 0c             	sub    $0xc,%esp
f011aafa:	68 ac e7 12 f0       	push   $0xf012e7ac
f011aaff:	e8 68 64 fe ff       	call   f0100f6c <cprintf>
f011ab04:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab07:	e8 34 9d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ab0c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011ab0f:	74 17                	je     f011ab28 <test_kmalloc+0x9b8>
f011ab11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ab18:	83 ec 0c             	sub    $0xc,%esp
f011ab1b:	68 40 e7 12 f0       	push   $0xf012e740
f011ab20:	e8 47 64 fe ff       	call   f0100f6c <cprintf>
f011ab25:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f011ab28:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ab2c:	74 04                	je     f011ab32 <test_kmalloc+0x9c2>
f011ab2e:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f011ab32:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011ab39:	e8 cb 2e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ab3e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ab41:	e8 fa 9c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ab46:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 2*PAGE_SIZE) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f011ab49:	c7 45 90 00 a0 2f 07 	movl   $0x72fa000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap);
f011ab50:	83 ec 0c             	sub    $0xc,%esp
f011ab53:	ff 75 90             	pushl  -0x70(%ebp)
f011ab56:	e8 5b df fe ff       	call   f0108ab6 <kmalloc>
f011ab5b:	83 c4 10             	add    $0x10,%esp
f011ab5e:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f011ab64:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011ab6a:	85 c0                	test   %eax,%eax
f011ab6c:	74 17                	je     f011ab85 <test_kmalloc+0xa15>
f011ab6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ab75:	83 ec 0c             	sub    $0xc,%esp
f011ab78:	68 0c e7 12 f0       	push   $0xf012e70c
f011ab7d:	e8 ea 63 fe ff       	call   f0100f6c <cprintf>
f011ab82:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab85:	e8 b6 9c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ab8a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011ab8d:	74 17                	je     f011aba6 <test_kmalloc+0xa36>
f011ab8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ab96:	83 ec 0c             	sub    $0xc,%esp
f011ab99:	68 40 e7 12 f0       	push   $0xf012e740
f011ab9e:	e8 c9 63 fe ff       	call   f0100f6c <cprintf>
f011aba3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aba6:	e8 5e 2e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011abab:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011abae:	74 17                	je     f011abc7 <test_kmalloc+0xa57>
f011abb0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011abb7:	83 ec 0c             	sub    $0xc,%esp
f011abba:	68 ac e7 12 f0       	push   $0xf012e7ac
f011abbf:	e8 a8 63 fe ff       	call   f0100f6c <cprintf>
f011abc4:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011abc7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011abcb:	74 04                	je     f011abd1 <test_kmalloc+0xa61>
f011abcd:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011abd1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f011abd8:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011abde:	05 00 40 00 00       	add    $0x4000,%eax
f011abe3:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011abe6:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f011abed:	eb 6a                	jmp    f011ac59 <test_kmalloc+0xae9>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f011abef:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011abf4:	83 ec 04             	sub    $0x4,%esp
f011abf7:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f011abfd:	52                   	push   %edx
f011abfe:	ff 75 ec             	pushl  -0x14(%ebp)
f011ac01:	50                   	push   %eax
f011ac02:	e8 06 d8 fe ff       	call   f010840d <get_page_table>
f011ac07:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011ac0a:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ac10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ac13:	c1 ea 0c             	shr    $0xc,%edx
f011ac16:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011ac1c:	c1 e2 02             	shl    $0x2,%edx
f011ac1f:	01 d0                	add    %edx,%eax
f011ac21:	8b 00                	mov    (%eax),%eax
f011ac23:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ac28:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011ac2b:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ac2e:	83 e0 04             	and    $0x4,%eax
f011ac31:	85 c0                	test   %eax,%eax
f011ac33:	74 1d                	je     f011ac52 <test_kmalloc+0xae2>
			{
				if (correct)
f011ac35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ac39:	74 17                	je     f011ac52 <test_kmalloc+0xae2>
				{
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011ac3b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ac42:	83 ec 0c             	sub    $0xc,%esp
f011ac45:	68 00 e9 12 f0       	push   $0xf012e900
f011ac4a:	e8 1d 63 fe ff       	call   f0100f6c <cprintf>
f011ac4f:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011ac52:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011ac59:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ac5c:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ac5f:	72 8e                	jb     f011abef <test_kmalloc+0xa7f>
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011ac61:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ac65:	74 04                	je     f011ac6b <test_kmalloc+0xafb>
f011ac67:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f011ac6b:	83 ec 08             	sub    $0x8,%esp
f011ac6e:	ff 75 f4             	pushl  -0xc(%ebp)
f011ac71:	68 4c e9 12 f0       	push   $0xf012e94c
f011ac76:	e8 f1 62 fe ff       	call   f0100f6c <cprintf>
f011ac7b:	83 c4 10             	add    $0x10,%esp

	return 1;
f011ac7e:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011ac83:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011ac86:	5b                   	pop    %ebx
f011ac87:	5f                   	pop    %edi
f011ac88:	5d                   	pop    %ebp
f011ac89:	c3                   	ret    

f011ac8a <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f011ac8a:	55                   	push   %ebp
f011ac8b:	89 e5                	mov    %esp,%ebp
f011ac8d:	57                   	push   %edi
f011ac8e:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011ac91:	83 ec 0c             	sub    $0xc,%esp
f011ac94:	68 80 e6 12 f0       	push   $0xf012e680
f011ac99:	e8 ce 62 fe ff       	call   f0100f6c <cprintf>
f011ac9e:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011aca1:	83 ec 0c             	sub    $0xc,%esp
f011aca4:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011aca9:	e8 be 62 fe ff       	call   f0100f6c <cprintf>
f011acae:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011acb1:	83 ec 0c             	sub    $0xc,%esp
f011acb4:	68 80 e6 12 f0       	push   $0xf012e680
f011acb9:	e8 ae 62 fe ff       	call   f0100f6c <cprintf>
f011acbe:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011acc1:	8d 55 98             	lea    -0x68(%ebp),%edx
f011acc4:	b9 14 00 00 00       	mov    $0x14,%ecx
f011acc9:	b8 00 00 00 00       	mov    $0x0,%eax
f011acce:	89 d7                	mov    %edx,%edi
f011acd0:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f011acd2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011acd9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011ace0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ace7:	e8 1d 2d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011acec:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011acef:	e8 4c 9b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011acf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011acf7:	83 ec 0c             	sub    $0xc,%esp
f011acfa:	68 00 fc 0f 00       	push   $0xffc00
f011acff:	e8 b2 dd fe ff       	call   f0108ab6 <kmalloc>
f011ad04:	83 c4 10             	add    $0x10,%esp
f011ad07:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ad0a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ad0d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ad12:	74 17                	je     f011ad2b <test_kmalloc_firstfit1+0xa1>
f011ad14:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ad1b:	83 ec 0c             	sub    $0xc,%esp
f011ad1e:	68 78 e9 12 f0       	push   $0xf012e978
f011ad23:	e8 44 62 fe ff       	call   f0100f6c <cprintf>
f011ad28:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad2b:	e8 10 9b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ad30:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ad33:	74 17                	je     f011ad4c <test_kmalloc_firstfit1+0xc2>
f011ad35:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ad3c:	83 ec 0c             	sub    $0xc,%esp
f011ad3f:	68 40 e7 12 f0       	push   $0xf012e740
f011ad44:	e8 23 62 fe ff       	call   f0100f6c <cprintf>
f011ad49:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ad4c:	e8 b8 2c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ad51:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ad54:	29 c2                	sub    %eax,%edx
f011ad56:	89 d0                	mov    %edx,%eax
f011ad58:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ad5d:	77 17                	ja     f011ad76 <test_kmalloc_firstfit1+0xec>
f011ad5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ad66:	83 ec 0c             	sub    $0xc,%esp
f011ad69:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011ad6e:	e8 f9 61 fe ff       	call   f0100f6c <cprintf>
f011ad73:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ad76:	e8 8e 2c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ad7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ad7e:	e8 bd 9a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ad83:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f011ad86:	83 ec 0c             	sub    $0xc,%esp
f011ad89:	68 00 fc 0f 00       	push   $0xffc00
f011ad8e:	e8 23 dd fe ff       	call   f0108ab6 <kmalloc>
f011ad93:	83 c4 10             	add    $0x10,%esp
f011ad96:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ad99:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011ad9c:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011ada1:	74 17                	je     f011adba <test_kmalloc_firstfit1+0x130>
f011ada3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011adaa:	83 ec 0c             	sub    $0xc,%esp
f011adad:	68 78 e9 12 f0       	push   $0xf012e978
f011adb2:	e8 b5 61 fe ff       	call   f0100f6c <cprintf>
f011adb7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011adba:	e8 81 9a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011adbf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011adc2:	74 17                	je     f011addb <test_kmalloc_firstfit1+0x151>
f011adc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011adcb:	83 ec 0c             	sub    $0xc,%esp
f011adce:	68 40 e7 12 f0       	push   $0xf012e740
f011add3:	e8 94 61 fe ff       	call   f0100f6c <cprintf>
f011add8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011addb:	e8 29 2c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ade0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ade3:	29 c2                	sub    %eax,%edx
f011ade5:	89 d0                	mov    %edx,%eax
f011ade7:	3d ff 00 00 00       	cmp    $0xff,%eax
f011adec:	77 17                	ja     f011ae05 <test_kmalloc_firstfit1+0x17b>
f011adee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011adf5:	83 ec 0c             	sub    $0xc,%esp
f011adf8:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011adfd:	e8 6a 61 fe ff       	call   f0100f6c <cprintf>
f011ae02:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ae05:	e8 ff 2b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ae0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ae0d:	e8 2e 9a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ae12:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f011ae15:	83 ec 0c             	sub    $0xc,%esp
f011ae18:	68 00 fc 0f 00       	push   $0xffc00
f011ae1d:	e8 94 dc fe ff       	call   f0108ab6 <kmalloc>
f011ae22:	83 c4 10             	add    $0x10,%esp
f011ae25:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ae28:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ae2b:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011ae30:	74 17                	je     f011ae49 <test_kmalloc_firstfit1+0x1bf>
f011ae32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ae39:	83 ec 0c             	sub    $0xc,%esp
f011ae3c:	68 78 e9 12 f0       	push   $0xf012e978
f011ae41:	e8 26 61 fe ff       	call   f0100f6c <cprintf>
f011ae46:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae49:	e8 f2 99 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ae4e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ae51:	74 17                	je     f011ae6a <test_kmalloc_firstfit1+0x1e0>
f011ae53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ae5a:	83 ec 0c             	sub    $0xc,%esp
f011ae5d:	68 40 e7 12 f0       	push   $0xf012e740
f011ae62:	e8 05 61 fe ff       	call   f0100f6c <cprintf>
f011ae67:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ae6a:	e8 9a 2b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ae6f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ae72:	29 c2                	sub    %eax,%edx
f011ae74:	89 d0                	mov    %edx,%eax
f011ae76:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ae7b:	77 17                	ja     f011ae94 <test_kmalloc_firstfit1+0x20a>
f011ae7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ae84:	83 ec 0c             	sub    $0xc,%esp
f011ae87:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011ae8c:	e8 db 60 fe ff       	call   f0100f6c <cprintf>
f011ae91:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ae94:	e8 70 2b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ae99:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ae9c:	e8 9f 99 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011aea1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f011aea4:	83 ec 0c             	sub    $0xc,%esp
f011aea7:	68 00 fc 0f 00       	push   $0xffc00
f011aeac:	e8 05 dc fe ff       	call   f0108ab6 <kmalloc>
f011aeb1:	83 c4 10             	add    $0x10,%esp
f011aeb4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011aeb7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011aeba:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011aebf:	74 17                	je     f011aed8 <test_kmalloc_firstfit1+0x24e>
f011aec1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aec8:	83 ec 0c             	sub    $0xc,%esp
f011aecb:	68 78 e9 12 f0       	push   $0xf012e978
f011aed0:	e8 97 60 fe ff       	call   f0100f6c <cprintf>
f011aed5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aed8:	e8 63 99 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011aedd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011aee0:	74 17                	je     f011aef9 <test_kmalloc_firstfit1+0x26f>
f011aee2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aee9:	83 ec 0c             	sub    $0xc,%esp
f011aeec:	68 40 e7 12 f0       	push   $0xf012e740
f011aef1:	e8 76 60 fe ff       	call   f0100f6c <cprintf>
f011aef6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011aef9:	e8 0b 2b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011aefe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011af01:	29 c2                	sub    %eax,%edx
f011af03:	89 d0                	mov    %edx,%eax
f011af05:	3d ff 00 00 00       	cmp    $0xff,%eax
f011af0a:	77 17                	ja     f011af23 <test_kmalloc_firstfit1+0x299>
f011af0c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011af13:	83 ec 0c             	sub    $0xc,%esp
f011af16:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011af1b:	e8 4c 60 fe ff       	call   f0100f6c <cprintf>
f011af20:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011af23:	e8 e1 2a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011af28:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011af2b:	e8 10 99 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011af30:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f011af33:	83 ec 0c             	sub    $0xc,%esp
f011af36:	68 00 fc 1f 00       	push   $0x1ffc00
f011af3b:	e8 76 db fe ff       	call   f0108ab6 <kmalloc>
f011af40:	83 c4 10             	add    $0x10,%esp
f011af43:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011af46:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011af49:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011af4e:	74 17                	je     f011af67 <test_kmalloc_firstfit1+0x2dd>
f011af50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011af57:	83 ec 0c             	sub    $0xc,%esp
f011af5a:	68 78 e9 12 f0       	push   $0xf012e978
f011af5f:	e8 08 60 fe ff       	call   f0100f6c <cprintf>
f011af64:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af67:	e8 d4 98 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011af6c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011af6f:	74 17                	je     f011af88 <test_kmalloc_firstfit1+0x2fe>
f011af71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011af78:	83 ec 0c             	sub    $0xc,%esp
f011af7b:	68 40 e7 12 f0       	push   $0xf012e740
f011af80:	e8 e7 5f fe ff       	call   f0100f6c <cprintf>
f011af85:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011af88:	e8 7c 2a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011af8d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011af90:	29 c2                	sub    %eax,%edx
f011af92:	89 d0                	mov    %edx,%eax
f011af94:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af99:	77 17                	ja     f011afb2 <test_kmalloc_firstfit1+0x328>
f011af9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011afa2:	83 ec 0c             	sub    $0xc,%esp
f011afa5:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011afaa:	e8 bd 5f fe ff       	call   f0100f6c <cprintf>
f011afaf:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011afb2:	e8 52 2a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011afb7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011afba:	e8 81 98 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011afbf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f011afc2:	83 ec 0c             	sub    $0xc,%esp
f011afc5:	68 00 fc 1f 00       	push   $0x1ffc00
f011afca:	e8 e7 da fe ff       	call   f0108ab6 <kmalloc>
f011afcf:	83 c4 10             	add    $0x10,%esp
f011afd2:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011afd5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011afd8:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f011afdd:	74 17                	je     f011aff6 <test_kmalloc_firstfit1+0x36c>
f011afdf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011afe6:	83 ec 0c             	sub    $0xc,%esp
f011afe9:	68 78 e9 12 f0       	push   $0xf012e978
f011afee:	e8 79 5f fe ff       	call   f0100f6c <cprintf>
f011aff3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aff6:	e8 45 98 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011affb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011affe:	74 17                	je     f011b017 <test_kmalloc_firstfit1+0x38d>
f011b000:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b007:	83 ec 0c             	sub    $0xc,%esp
f011b00a:	68 40 e7 12 f0       	push   $0xf012e740
f011b00f:	e8 58 5f fe ff       	call   f0100f6c <cprintf>
f011b014:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b017:	e8 ed 29 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b01c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b01f:	29 c2                	sub    %eax,%edx
f011b021:	89 d0                	mov    %edx,%eax
f011b023:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b028:	77 17                	ja     f011b041 <test_kmalloc_firstfit1+0x3b7>
f011b02a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b031:	83 ec 0c             	sub    $0xc,%esp
f011b034:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b039:	e8 2e 5f fe ff       	call   f0100f6c <cprintf>
f011b03e:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b041:	e8 c3 29 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b046:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b049:	e8 f2 97 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b04e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b051:	83 ec 0c             	sub    $0xc,%esp
f011b054:	68 00 fc 2f 00       	push   $0x2ffc00
f011b059:	e8 58 da fe ff       	call   f0108ab6 <kmalloc>
f011b05e:	83 c4 10             	add    $0x10,%esp
f011b061:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b064:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011b067:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f011b06c:	74 17                	je     f011b085 <test_kmalloc_firstfit1+0x3fb>
f011b06e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b075:	83 ec 0c             	sub    $0xc,%esp
f011b078:	68 78 e9 12 f0       	push   $0xf012e978
f011b07d:	e8 ea 5e fe ff       	call   f0100f6c <cprintf>
f011b082:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b085:	e8 b6 97 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b08a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b08d:	74 17                	je     f011b0a6 <test_kmalloc_firstfit1+0x41c>
f011b08f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b096:	83 ec 0c             	sub    $0xc,%esp
f011b099:	68 40 e7 12 f0       	push   $0xf012e740
f011b09e:	e8 c9 5e fe ff       	call   f0100f6c <cprintf>
f011b0a3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b0a6:	e8 5e 29 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b0ab:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b0ae:	29 c2                	sub    %eax,%edx
f011b0b0:	89 d0                	mov    %edx,%eax
f011b0b2:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b0b7:	77 17                	ja     f011b0d0 <test_kmalloc_firstfit1+0x446>
f011b0b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b0c0:	83 ec 0c             	sub    $0xc,%esp
f011b0c3:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b0c8:	e8 9f 5e fe ff       	call   f0100f6c <cprintf>
f011b0cd:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b0d0:	e8 34 29 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b0d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b0d8:	e8 63 97 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b0dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f011b0e0:	83 ec 0c             	sub    $0xc,%esp
f011b0e3:	68 00 fc 2f 00       	push   $0x2ffc00
f011b0e8:	e8 c9 d9 fe ff       	call   f0108ab6 <kmalloc>
f011b0ed:	83 c4 10             	add    $0x10,%esp
f011b0f0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b0f3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011b0f6:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f011b0fb:	74 17                	je     f011b114 <test_kmalloc_firstfit1+0x48a>
f011b0fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b104:	83 ec 0c             	sub    $0xc,%esp
f011b107:	68 78 e9 12 f0       	push   $0xf012e978
f011b10c:	e8 5b 5e fe ff       	call   f0100f6c <cprintf>
f011b111:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b114:	e8 27 97 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b119:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b11c:	74 17                	je     f011b135 <test_kmalloc_firstfit1+0x4ab>
f011b11e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b125:	83 ec 0c             	sub    $0xc,%esp
f011b128:	68 40 e7 12 f0       	push   $0xf012e740
f011b12d:	e8 3a 5e fe ff       	call   f0100f6c <cprintf>
f011b132:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b135:	e8 cf 28 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b13a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b13d:	29 c2                	sub    %eax,%edx
f011b13f:	89 d0                	mov    %edx,%eax
f011b141:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b146:	77 17                	ja     f011b15f <test_kmalloc_firstfit1+0x4d5>
f011b148:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b14f:	83 ec 0c             	sub    $0xc,%esp
f011b152:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b157:	e8 10 5e fe ff       	call   f0100f6c <cprintf>
f011b15c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b15f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b163:	74 04                	je     f011b169 <test_kmalloc_firstfit1+0x4df>
f011b165:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b169:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b170:	e8 94 28 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b175:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b178:	e8 c3 96 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b17d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011b180:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b183:	83 ec 0c             	sub    $0xc,%esp
f011b186:	50                   	push   %eax
f011b187:	e8 44 d9 fe ff       	call   f0108ad0 <kfree>
f011b18c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b18f:	e8 ac 96 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b194:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b197:	74 17                	je     f011b1b0 <test_kmalloc_firstfit1+0x526>
f011b199:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b1a0:	83 ec 0c             	sub    $0xc,%esp
f011b1a3:	68 40 e7 12 f0       	push   $0xf012e740
f011b1a8:	e8 bf 5d fe ff       	call   f0100f6c <cprintf>
f011b1ad:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011b1b0:	e8 54 28 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b1b5:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b1b8:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b1bd:	77 17                	ja     f011b1d6 <test_kmalloc_firstfit1+0x54c>
f011b1bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b1c6:	83 ec 0c             	sub    $0xc,%esp
f011b1c9:	68 bd e9 12 f0       	push   $0xf012e9bd
f011b1ce:	e8 99 5d fe ff       	call   f0100f6c <cprintf>
f011b1d3:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b1d6:	e8 2e 28 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b1db:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b1de:	e8 5d 96 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b1e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f011b1e6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b1e9:	83 ec 0c             	sub    $0xc,%esp
f011b1ec:	50                   	push   %eax
f011b1ed:	e8 de d8 fe ff       	call   f0108ad0 <kfree>
f011b1f2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b1f5:	e8 46 96 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b1fa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b1fd:	74 17                	je     f011b216 <test_kmalloc_firstfit1+0x58c>
f011b1ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b206:	83 ec 0c             	sub    $0xc,%esp
f011b209:	68 40 e7 12 f0       	push   $0xf012e740
f011b20e:	e8 59 5d fe ff       	call   f0100f6c <cprintf>
f011b213:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f011b216:	e8 ee 27 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b21b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b21e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b223:	77 17                	ja     f011b23c <test_kmalloc_firstfit1+0x5b2>
f011b225:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b22c:	83 ec 0c             	sub    $0xc,%esp
f011b22f:	68 bd e9 12 f0       	push   $0xf012e9bd
f011b234:	e8 33 5d fe ff       	call   f0100f6c <cprintf>
f011b239:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b23c:	e8 c8 27 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b241:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b244:	e8 f7 95 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b249:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011b24c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011b24f:	83 ec 0c             	sub    $0xc,%esp
f011b252:	50                   	push   %eax
f011b253:	e8 78 d8 fe ff       	call   f0108ad0 <kfree>
f011b258:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b25b:	e8 e0 95 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b260:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b263:	74 17                	je     f011b27c <test_kmalloc_firstfit1+0x5f2>
f011b265:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b26c:	83 ec 0c             	sub    $0xc,%esp
f011b26f:	68 40 e7 12 f0       	push   $0xf012e740
f011b274:	e8 f3 5c fe ff       	call   f0100f6c <cprintf>
f011b279:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f011b27c:	e8 88 27 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b281:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b284:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b289:	77 17                	ja     f011b2a2 <test_kmalloc_firstfit1+0x618>
f011b28b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b292:	83 ec 0c             	sub    $0xc,%esp
f011b295:	68 bd e9 12 f0       	push   $0xf012e9bd
f011b29a:	e8 cd 5c fe ff       	call   f0100f6c <cprintf>
f011b29f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b2a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b2a6:	74 04                	je     f011b2ac <test_kmalloc_firstfit1+0x622>
f011b2a8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b2ac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b2b3:	e8 51 27 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b2b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b2bb:	e8 80 95 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b2c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f011b2c3:	83 ec 0c             	sub    $0xc,%esp
f011b2c6:	68 00 fc 07 00       	push   $0x7fc00
f011b2cb:	e8 e6 d7 fe ff       	call   f0108ab6 <kmalloc>
f011b2d0:	83 c4 10             	add    $0x10,%esp
f011b2d3:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b2d6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011b2d9:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011b2de:	74 17                	je     f011b2f7 <test_kmalloc_firstfit1+0x66d>
f011b2e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b2e7:	83 ec 0c             	sub    $0xc,%esp
f011b2ea:	68 78 e9 12 f0       	push   $0xf012e978
f011b2ef:	e8 78 5c fe ff       	call   f0100f6c <cprintf>
f011b2f4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2f7:	e8 44 95 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b2fc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b2ff:	74 17                	je     f011b318 <test_kmalloc_firstfit1+0x68e>
f011b301:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b308:	83 ec 0c             	sub    $0xc,%esp
f011b30b:	68 40 e7 12 f0       	push   $0xf012e740
f011b310:	e8 57 5c fe ff       	call   f0100f6c <cprintf>
f011b315:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b318:	e8 ec 26 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b31d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b320:	29 c2                	sub    %eax,%edx
f011b322:	89 d0                	mov    %edx,%eax
f011b324:	83 f8 7f             	cmp    $0x7f,%eax
f011b327:	77 17                	ja     f011b340 <test_kmalloc_firstfit1+0x6b6>
f011b329:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b330:	83 ec 0c             	sub    $0xc,%esp
f011b333:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b338:	e8 2f 5c fe ff       	call   f0100f6c <cprintf>
f011b33d:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b340:	e8 c4 26 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b345:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b348:	e8 f3 94 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b34d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f011b350:	83 ec 0c             	sub    $0xc,%esp
f011b353:	68 00 fc 0f 00       	push   $0xffc00
f011b358:	e8 59 d7 fe ff       	call   f0108ab6 <kmalloc>
f011b35d:	83 c4 10             	add    $0x10,%esp
f011b360:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b363:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b366:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b36b:	74 17                	je     f011b384 <test_kmalloc_firstfit1+0x6fa>
f011b36d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b374:	83 ec 0c             	sub    $0xc,%esp
f011b377:	68 78 e9 12 f0       	push   $0xf012e978
f011b37c:	e8 eb 5b fe ff       	call   f0100f6c <cprintf>
f011b381:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b384:	e8 b7 94 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b389:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b38c:	74 17                	je     f011b3a5 <test_kmalloc_firstfit1+0x71b>
f011b38e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b395:	83 ec 0c             	sub    $0xc,%esp
f011b398:	68 40 e7 12 f0       	push   $0xf012e740
f011b39d:	e8 ca 5b fe ff       	call   f0100f6c <cprintf>
f011b3a2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b3a5:	e8 5f 26 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b3aa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b3ad:	29 c2                	sub    %eax,%edx
f011b3af:	89 d0                	mov    %edx,%eax
f011b3b1:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b3b6:	77 17                	ja     f011b3cf <test_kmalloc_firstfit1+0x745>
f011b3b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b3bf:	83 ec 0c             	sub    $0xc,%esp
f011b3c2:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b3c7:	e8 a0 5b fe ff       	call   f0100f6c <cprintf>
f011b3cc:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b3cf:	e8 35 26 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b3d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b3d7:	e8 64 94 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b3dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f011b3df:	83 ec 0c             	sub    $0xc,%esp
f011b3e2:	68 00 fc 03 00       	push   $0x3fc00
f011b3e7:	e8 ca d6 fe ff       	call   f0108ab6 <kmalloc>
f011b3ec:	83 c4 10             	add    $0x10,%esp
f011b3ef:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b3f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b3f5:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f011b3fa:	74 17                	je     f011b413 <test_kmalloc_firstfit1+0x789>
f011b3fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b403:	83 ec 0c             	sub    $0xc,%esp
f011b406:	68 78 e9 12 f0       	push   $0xf012e978
f011b40b:	e8 5c 5b fe ff       	call   f0100f6c <cprintf>
f011b410:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b413:	e8 28 94 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b418:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b41b:	74 17                	je     f011b434 <test_kmalloc_firstfit1+0x7aa>
f011b41d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b424:	83 ec 0c             	sub    $0xc,%esp
f011b427:	68 40 e7 12 f0       	push   $0xf012e740
f011b42c:	e8 3b 5b fe ff       	call   f0100f6c <cprintf>
f011b431:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b434:	e8 d0 25 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b439:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b43c:	29 c2                	sub    %eax,%edx
f011b43e:	89 d0                	mov    %edx,%eax
f011b440:	83 f8 3f             	cmp    $0x3f,%eax
f011b443:	77 17                	ja     f011b45c <test_kmalloc_firstfit1+0x7d2>
f011b445:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b44c:	83 ec 0c             	sub    $0xc,%esp
f011b44f:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b454:	e8 13 5b fe ff       	call   f0100f6c <cprintf>
f011b459:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b45c:	e8 a8 25 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b461:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b464:	e8 d7 93 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b469:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f011b46c:	83 ec 0c             	sub    $0xc,%esp
f011b46f:	68 00 00 20 00       	push   $0x200000
f011b474:	e8 3d d6 fe ff       	call   f0108ab6 <kmalloc>
f011b479:	83 c4 10             	add    $0x10,%esp
f011b47c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b47f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b482:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f011b487:	74 17                	je     f011b4a0 <test_kmalloc_firstfit1+0x816>
f011b489:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b490:	83 ec 0c             	sub    $0xc,%esp
f011b493:	68 78 e9 12 f0       	push   $0xf012e978
f011b498:	e8 cf 5a fe ff       	call   f0100f6c <cprintf>
f011b49d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b4a0:	e8 64 25 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b4a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b4a8:	29 c2                	sub    %eax,%edx
f011b4aa:	89 d0                	mov    %edx,%eax
f011b4ac:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b4b1:	77 17                	ja     f011b4ca <test_kmalloc_firstfit1+0x840>
f011b4b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b4ba:	83 ec 0c             	sub    $0xc,%esp
f011b4bd:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b4c2:	e8 a5 5a fe ff       	call   f0100f6c <cprintf>
f011b4c7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b4ca:	e8 71 93 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b4cf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b4d2:	74 17                	je     f011b4eb <test_kmalloc_firstfit1+0x861>
f011b4d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b4db:	83 ec 0c             	sub    $0xc,%esp
f011b4de:	68 40 e7 12 f0       	push   $0xf012e740
f011b4e3:	e8 84 5a fe ff       	call   f0100f6c <cprintf>
f011b4e8:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f011b4eb:	e8 19 25 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b4f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b4f3:	e8 48 93 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b4f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f011b4fb:	83 ec 0c             	sub    $0xc,%esp
f011b4fe:	68 00 fc 3f 00       	push   $0x3ffc00
f011b503:	e8 ae d5 fe ff       	call   f0108ab6 <kmalloc>
f011b508:	83 c4 10             	add    $0x10,%esp
f011b50b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b50e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b511:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f011b516:	74 17                	je     f011b52f <test_kmalloc_firstfit1+0x8a5>
f011b518:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b51f:	83 ec 0c             	sub    $0xc,%esp
f011b522:	68 78 e9 12 f0       	push   $0xf012e978
f011b527:	e8 40 5a fe ff       	call   f0100f6c <cprintf>
f011b52c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b52f:	e8 0c 93 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b534:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b537:	74 17                	je     f011b550 <test_kmalloc_firstfit1+0x8c6>
f011b539:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b540:	83 ec 0c             	sub    $0xc,%esp
f011b543:	68 40 e7 12 f0       	push   $0xf012e740
f011b548:	e8 1f 5a fe ff       	call   f0100f6c <cprintf>
f011b54d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b550:	e8 b4 24 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b555:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b558:	29 c2                	sub    %eax,%edx
f011b55a:	89 d0                	mov    %edx,%eax
f011b55c:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f011b561:	77 17                	ja     f011b57a <test_kmalloc_firstfit1+0x8f0>
f011b563:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b56a:	83 ec 0c             	sub    $0xc,%esp
f011b56d:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b572:	e8 f5 59 fe ff       	call   f0100f6c <cprintf>
f011b577:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f011b57a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b57e:	74 04                	je     f011b584 <test_kmalloc_firstfit1+0x8fa>
f011b580:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011b584:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b58b:	e8 79 24 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b590:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b593:	e8 a8 92 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b598:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f011b59b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b59e:	83 ec 0c             	sub    $0xc,%esp
f011b5a1:	50                   	push   %eax
f011b5a2:	e8 29 d5 fe ff       	call   f0108ad0 <kfree>
f011b5a7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5aa:	e8 91 92 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b5af:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b5b2:	74 17                	je     f011b5cb <test_kmalloc_firstfit1+0x941>
f011b5b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b5bb:	83 ec 0c             	sub    $0xc,%esp
f011b5be:	68 40 e7 12 f0       	push   $0xf012e740
f011b5c3:	e8 a4 59 fe ff       	call   f0100f6c <cprintf>
f011b5c8:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011b5cb:	e8 39 24 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b5d0:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b5d3:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b5d8:	77 17                	ja     f011b5f1 <test_kmalloc_firstfit1+0x967>
f011b5da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b5e1:	83 ec 0c             	sub    $0xc,%esp
f011b5e4:	68 bd e9 12 f0       	push   $0xf012e9bd
f011b5e9:	e8 7e 59 fe ff       	call   f0100f6c <cprintf>
f011b5ee:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f011b5f1:	e8 13 24 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b5f6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b5f9:	e8 42 92 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b5fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f011b601:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b604:	83 ec 0c             	sub    $0xc,%esp
f011b607:	50                   	push   %eax
f011b608:	e8 c3 d4 fe ff       	call   f0108ad0 <kfree>
f011b60d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b610:	e8 2b 92 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b615:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b618:	74 17                	je     f011b631 <test_kmalloc_firstfit1+0x9a7>
f011b61a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b621:	83 ec 0c             	sub    $0xc,%esp
f011b624:	68 40 e7 12 f0       	push   $0xf012e740
f011b629:	e8 3e 59 fe ff       	call   f0100f6c <cprintf>
f011b62e:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011b631:	e8 d3 23 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b636:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b639:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b63e:	77 17                	ja     f011b657 <test_kmalloc_firstfit1+0x9cd>
f011b640:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b647:	83 ec 0c             	sub    $0xc,%esp
f011b64a:	68 bd e9 12 f0       	push   $0xf012e9bd
f011b64f:	e8 18 59 fe ff       	call   f0100f6c <cprintf>
f011b654:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b657:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b65b:	74 04                	je     f011b661 <test_kmalloc_firstfit1+0x9d7>
f011b65d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b661:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b668:	e8 9c 23 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b66d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b670:	e8 cb 91 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b675:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f011b678:	83 ec 0c             	sub    $0xc,%esp
f011b67b:	68 00 00 10 00       	push   $0x100000
f011b680:	e8 31 d4 fe ff       	call   f0108ab6 <kmalloc>
f011b685:	83 c4 10             	add    $0x10,%esp
f011b688:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b68b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b68e:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f011b693:	74 17                	je     f011b6ac <test_kmalloc_firstfit1+0xa22>
f011b695:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b69c:	83 ec 0c             	sub    $0xc,%esp
f011b69f:	68 78 e9 12 f0       	push   $0xf012e978
f011b6a4:	e8 c3 58 fe ff       	call   f0100f6c <cprintf>
f011b6a9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b6ac:	e8 8f 91 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b6b1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b6b4:	74 17                	je     f011b6cd <test_kmalloc_firstfit1+0xa43>
f011b6b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b6bd:	83 ec 0c             	sub    $0xc,%esp
f011b6c0:	68 40 e7 12 f0       	push   $0xf012e740
f011b6c5:	e8 a2 58 fe ff       	call   f0100f6c <cprintf>
f011b6ca:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b6cd:	e8 37 23 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b6d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b6d5:	29 c2                	sub    %eax,%edx
f011b6d7:	89 d0                	mov    %edx,%eax
f011b6d9:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b6de:	77 17                	ja     f011b6f7 <test_kmalloc_firstfit1+0xa6d>
f011b6e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b6e7:	83 ec 0c             	sub    $0xc,%esp
f011b6ea:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b6ef:	e8 78 58 fe ff       	call   f0100f6c <cprintf>
f011b6f4:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011b6f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b6fb:	74 04                	je     f011b701 <test_kmalloc_firstfit1+0xa77>
f011b6fd:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f011b701:	83 ec 08             	sub    $0x8,%esp
f011b704:	ff 75 f4             	pushl  -0xc(%ebp)
f011b707:	68 cc e9 12 f0       	push   $0xf012e9cc
f011b70c:	e8 5b 58 fe ff       	call   f0100f6c <cprintf>
f011b711:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b714:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011b719:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011b71c:	c9                   	leave  
f011b71d:	c3                   	ret    

f011b71e <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f011b71e:	55                   	push   %ebp
f011b71f:	89 e5                	mov    %esp,%ebp
f011b721:	57                   	push   %edi
f011b722:	53                   	push   %ebx
f011b723:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b726:	83 ec 0c             	sub    $0xc,%esp
f011b729:	68 80 e6 12 f0       	push   $0xf012e680
f011b72e:	e8 39 58 fe ff       	call   f0100f6c <cprintf>
f011b733:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b736:	83 ec 0c             	sub    $0xc,%esp
f011b739:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011b73e:	e8 29 58 fe ff       	call   f0100f6c <cprintf>
f011b743:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b746:	83 ec 0c             	sub    $0xc,%esp
f011b749:	68 80 e6 12 f0       	push   $0xf012e680
f011b74e:	e8 19 58 fe ff       	call   f0100f6c <cprintf>
f011b753:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011b756:	8d 55 98             	lea    -0x68(%ebp),%edx
f011b759:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b75e:	b8 00 00 00 00       	mov    $0x0,%eax
f011b763:	89 d7                	mov    %edx,%edi
f011b765:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f011b767:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011b76e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011b775:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f011b77c:	83 ec 0c             	sub    $0xc,%esp
f011b77f:	68 01 e0 ff 07       	push   $0x7ffe001
f011b784:	e8 2d d3 fe ff       	call   f0108ab6 <kmalloc>
f011b789:	83 c4 10             	add    $0x10,%esp
f011b78c:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011b78f:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b792:	85 c0                	test   %eax,%eax
f011b794:	74 17                	je     f011b7ad <test_kmalloc_firstfit2+0x8f>
f011b796:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b79d:	83 ec 0c             	sub    $0xc,%esp
f011b7a0:	68 04 ea 12 f0       	push   $0xf012ea04
f011b7a5:	e8 c2 57 fe ff       	call   f0100f6c <cprintf>
f011b7aa:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b7ad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b7b1:	74 04                	je     f011b7b7 <test_kmalloc_firstfit2+0x99>
f011b7b3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b7b7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b7be:	e8 46 22 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b7c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b7c6:	e8 75 90 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b7cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b7ce:	83 ec 0c             	sub    $0xc,%esp
f011b7d1:	68 00 fc 1f 00       	push   $0x1ffc00
f011b7d6:	e8 db d2 fe ff       	call   f0108ab6 <kmalloc>
f011b7db:	83 c4 10             	add    $0x10,%esp
f011b7de:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b7e1:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b7e4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b7e9:	74 17                	je     f011b802 <test_kmalloc_firstfit2+0xe4>
f011b7eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b7f2:	83 ec 0c             	sub    $0xc,%esp
f011b7f5:	68 78 e9 12 f0       	push   $0xf012e978
f011b7fa:	e8 6d 57 fe ff       	call   f0100f6c <cprintf>
f011b7ff:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b802:	e8 39 90 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b807:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b80a:	74 17                	je     f011b823 <test_kmalloc_firstfit2+0x105>
f011b80c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b813:	83 ec 0c             	sub    $0xc,%esp
f011b816:	68 40 e7 12 f0       	push   $0xf012e740
f011b81b:	e8 4c 57 fe ff       	call   f0100f6c <cprintf>
f011b820:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b823:	e8 e1 21 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b828:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b82b:	29 c2                	sub    %eax,%edx
f011b82d:	89 d0                	mov    %edx,%eax
f011b82f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b834:	77 17                	ja     f011b84d <test_kmalloc_firstfit2+0x12f>
f011b836:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b83d:	83 ec 0c             	sub    $0xc,%esp
f011b840:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b845:	e8 22 57 fe ff       	call   f0100f6c <cprintf>
f011b84a:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b84d:	e8 b7 21 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b852:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b855:	e8 e6 8f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b85a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b85d:	83 ec 0c             	sub    $0xc,%esp
f011b860:	68 00 fc 1f 00       	push   $0x1ffc00
f011b865:	e8 4c d2 fe ff       	call   f0108ab6 <kmalloc>
f011b86a:	83 c4 10             	add    $0x10,%esp
f011b86d:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b870:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b873:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b878:	74 17                	je     f011b891 <test_kmalloc_firstfit2+0x173>
f011b87a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b881:	83 ec 0c             	sub    $0xc,%esp
f011b884:	68 78 e9 12 f0       	push   $0xf012e978
f011b889:	e8 de 56 fe ff       	call   f0100f6c <cprintf>
f011b88e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b891:	e8 aa 8f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b896:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b899:	74 17                	je     f011b8b2 <test_kmalloc_firstfit2+0x194>
f011b89b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b8a2:	83 ec 0c             	sub    $0xc,%esp
f011b8a5:	68 40 e7 12 f0       	push   $0xf012e740
f011b8aa:	e8 bd 56 fe ff       	call   f0100f6c <cprintf>
f011b8af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b8b2:	e8 52 21 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b8b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b8ba:	29 c2                	sub    %eax,%edx
f011b8bc:	89 d0                	mov    %edx,%eax
f011b8be:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b8c3:	77 17                	ja     f011b8dc <test_kmalloc_firstfit2+0x1be>
f011b8c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b8cc:	83 ec 0c             	sub    $0xc,%esp
f011b8cf:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011b8d4:	e8 93 56 fe ff       	call   f0100f6c <cprintf>
f011b8d9:	83 c4 10             	add    $0x10,%esp

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b8dc:	e8 28 21 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b8e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b8e4:	e8 57 8f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b8e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*kilo);
f011b8ec:	83 ec 0c             	sub    $0xc,%esp
f011b8ef:	68 00 04 00 00       	push   $0x400
f011b8f4:	e8 bd d1 fe ff       	call   f0108ab6 <kmalloc>
f011b8f9:	83 c4 10             	add    $0x10,%esp
f011b8fc:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b8ff:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b902:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b907:	76 22                	jbe    f011b92b <test_kmalloc_firstfit2+0x20d>
f011b909:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f011b90c:	83 ec 0c             	sub    $0xc,%esp
f011b90f:	6a 00                	push   $0x0
f011b911:	e8 96 d1 fe ff       	call   f0108aac <sbrk>
f011b916:	83 c4 10             	add    $0x10,%esp
f011b919:	39 c3                	cmp    %eax,%ebx
f011b91b:	73 0e                	jae    f011b92b <test_kmalloc_firstfit2+0x20d>
f011b91d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b920:	89 c2                	mov    %eax,%edx
f011b922:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b927:	39 c2                	cmp    %eax,%edx
f011b929:	72 17                	jb     f011b942 <test_kmalloc_firstfit2+0x224>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b92b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b932:	83 ec 0c             	sub    $0xc,%esp
f011b935:	68 40 e8 12 f0       	push   $0xf012e840
f011b93a:	e8 2d 56 fe ff       	call   f0100f6c <cprintf>
f011b93f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b942:	e8 f9 8e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b947:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b94a:	74 17                	je     f011b963 <test_kmalloc_firstfit2+0x245>
f011b94c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b953:	83 ec 0c             	sub    $0xc,%esp
f011b956:	68 40 e7 12 f0       	push   $0xf012e740
f011b95b:	e8 0c 56 fe ff       	call   f0100f6c <cprintf>
f011b960:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b963:	e8 a1 20 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b968:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b96b:	e8 d0 8e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b970:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f011b973:	83 ec 0c             	sub    $0xc,%esp
f011b976:	68 00 08 00 00       	push   $0x800
f011b97b:	e8 36 d1 fe ff       	call   f0108ab6 <kmalloc>
f011b980:	83 c4 10             	add    $0x10,%esp
f011b983:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b986:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b989:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b98e:	76 22                	jbe    f011b9b2 <test_kmalloc_firstfit2+0x294>
f011b990:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011b993:	83 ec 0c             	sub    $0xc,%esp
f011b996:	6a 00                	push   $0x0
f011b998:	e8 0f d1 fe ff       	call   f0108aac <sbrk>
f011b99d:	83 c4 10             	add    $0x10,%esp
f011b9a0:	39 c3                	cmp    %eax,%ebx
f011b9a2:	73 0e                	jae    f011b9b2 <test_kmalloc_firstfit2+0x294>
f011b9a4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b9a7:	89 c2                	mov    %eax,%edx
f011b9a9:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b9ae:	39 c2                	cmp    %eax,%edx
f011b9b0:	72 17                	jb     f011b9c9 <test_kmalloc_firstfit2+0x2ab>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b9b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b9b9:	83 ec 0c             	sub    $0xc,%esp
f011b9bc:	68 40 e8 12 f0       	push   $0xf012e840
f011b9c1:	e8 a6 55 fe ff       	call   f0100f6c <cprintf>
f011b9c6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9c9:	e8 72 8e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b9ce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b9d1:	74 17                	je     f011b9ea <test_kmalloc_firstfit2+0x2cc>
f011b9d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b9da:	83 ec 0c             	sub    $0xc,%esp
f011b9dd:	68 40 e7 12 f0       	push   $0xf012e740
f011b9e2:	e8 85 55 fe ff       	call   f0100f6c <cprintf>
f011b9e7:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b9ea:	e8 1a 20 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011b9ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b9f2:	e8 49 8e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011b9f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(1*kilo);
f011b9fa:	83 ec 0c             	sub    $0xc,%esp
f011b9fd:	68 00 04 00 00       	push   $0x400
f011ba02:	e8 af d0 fe ff       	call   f0108ab6 <kmalloc>
f011ba07:	83 c4 10             	add    $0x10,%esp
f011ba0a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011ba0d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ba10:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011ba15:	76 22                	jbe    f011ba39 <test_kmalloc_firstfit2+0x31b>
f011ba17:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ba1a:	83 ec 0c             	sub    $0xc,%esp
f011ba1d:	6a 00                	push   $0x0
f011ba1f:	e8 88 d0 fe ff       	call   f0108aac <sbrk>
f011ba24:	83 c4 10             	add    $0x10,%esp
f011ba27:	39 c3                	cmp    %eax,%ebx
f011ba29:	73 0e                	jae    f011ba39 <test_kmalloc_firstfit2+0x31b>
f011ba2b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ba2e:	89 c2                	mov    %eax,%edx
f011ba30:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011ba35:	39 c2                	cmp    %eax,%edx
f011ba37:	72 17                	jb     f011ba50 <test_kmalloc_firstfit2+0x332>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011ba39:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba40:	83 ec 0c             	sub    $0xc,%esp
f011ba43:	68 40 e8 12 f0       	push   $0xf012e840
f011ba48:	e8 1f 55 fe ff       	call   f0100f6c <cprintf>
f011ba4d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba50:	e8 eb 8d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ba55:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ba58:	74 17                	je     f011ba71 <test_kmalloc_firstfit2+0x353>
f011ba5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba61:	83 ec 0c             	sub    $0xc,%esp
f011ba64:	68 40 e7 12 f0       	push   $0xf012e740
f011ba69:	e8 fe 54 fe ff       	call   f0100f6c <cprintf>
f011ba6e:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB Hole in Dynamic Allocator Area
		freeFrames = (int)sys_calculate_free_frames() ;
f011ba71:	e8 93 1f ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ba76:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ba79:	e8 c2 8d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ba7e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f011ba81:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ba84:	83 ec 0c             	sub    $0xc,%esp
f011ba87:	50                   	push   %eax
f011ba88:	e8 43 d0 fe ff       	call   f0108ad0 <kfree>
f011ba8d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba90:	e8 ab 8d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ba95:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ba98:	74 17                	je     f011bab1 <test_kmalloc_firstfit2+0x393>
f011ba9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011baa1:	83 ec 0c             	sub    $0xc,%esp
f011baa4:	68 40 e7 12 f0       	push   $0xf012e740
f011baa9:	e8 be 54 fe ff       	call   f0100f6c <cprintf>
f011baae:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011bab1:	e8 53 1f ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bab6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011bab9:	74 17                	je     f011bad2 <test_kmalloc_firstfit2+0x3b4>
f011babb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bac2:	83 ec 0c             	sub    $0xc,%esp
f011bac5:	68 4c ea 12 f0       	push   $0xf012ea4c
f011baca:	e8 9d 54 fe ff       	call   f0100f6c <cprintf>
f011bacf:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bad2:	e8 32 1f ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bad7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bada:	e8 61 8d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011badf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bae2:	83 ec 0c             	sub    $0xc,%esp
f011bae5:	68 00 1c 00 00       	push   $0x1c00
f011baea:	e8 c7 cf fe ff       	call   f0108ab6 <kmalloc>
f011baef:	83 c4 10             	add    $0x10,%esp
f011baf2:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011baf5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011baf8:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bafd:	74 17                	je     f011bb16 <test_kmalloc_firstfit2+0x3f8>
f011baff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb06:	83 ec 0c             	sub    $0xc,%esp
f011bb09:	68 78 e9 12 f0       	push   $0xf012e978
f011bb0e:	e8 59 54 fe ff       	call   f0100f6c <cprintf>
f011bb13:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb16:	e8 25 8d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bb1b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bb1e:	74 17                	je     f011bb37 <test_kmalloc_firstfit2+0x419>
f011bb20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb27:	83 ec 0c             	sub    $0xc,%esp
f011bb2a:	68 40 e7 12 f0       	push   $0xf012e740
f011bb2f:	e8 38 54 fe ff       	call   f0100f6c <cprintf>
f011bb34:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bb37:	e8 cd 1e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bb3c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011bb3f:	29 c2                	sub    %eax,%edx
f011bb41:	89 d0                	mov    %edx,%eax
f011bb43:	83 f8 01             	cmp    $0x1,%eax
f011bb46:	77 17                	ja     f011bb5f <test_kmalloc_firstfit2+0x441>
f011bb48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb4f:	83 ec 0c             	sub    $0xc,%esp
f011bb52:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011bb57:	e8 10 54 fe ff       	call   f0100f6c <cprintf>
f011bb5c:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011bb5f:	e8 a5 1e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bb64:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bb67:	e8 d4 8c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bb6c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f011bb6f:	8b 45 98             	mov    -0x68(%ebp),%eax
f011bb72:	83 ec 0c             	sub    $0xc,%esp
f011bb75:	50                   	push   %eax
f011bb76:	e8 55 cf fe ff       	call   f0108ad0 <kfree>
f011bb7b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb7e:	e8 bd 8c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bb83:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bb86:	74 17                	je     f011bb9f <test_kmalloc_firstfit2+0x481>
f011bb88:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb8f:	83 ec 0c             	sub    $0xc,%esp
f011bb92:	68 40 e7 12 f0       	push   $0xf012e740
f011bb97:	e8 d0 53 fe ff       	call   f0100f6c <cprintf>
f011bb9c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f011bb9f:	e8 65 1e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bba4:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bba7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bbac:	77 17                	ja     f011bbc5 <test_kmalloc_firstfit2+0x4a7>
f011bbae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bbb5:	83 ec 0c             	sub    $0xc,%esp
f011bbb8:	68 bd e9 12 f0       	push   $0xf012e9bd
f011bbbd:	e8 aa 53 fe ff       	call   f0100f6c <cprintf>
f011bbc2:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bbc5:	e8 3f 1e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bbca:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bbcd:	e8 6e 8c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bbd2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bbd5:	83 ec 0c             	sub    $0xc,%esp
f011bbd8:	68 00 fc 2f 00       	push   $0x2ffc00
f011bbdd:	e8 d4 ce fe ff       	call   f0108ab6 <kmalloc>
f011bbe2:	83 c4 10             	add    $0x10,%esp
f011bbe5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bbe8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011bbeb:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bbf0:	74 17                	je     f011bc09 <test_kmalloc_firstfit2+0x4eb>
f011bbf2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bbf9:	83 ec 0c             	sub    $0xc,%esp
f011bbfc:	68 78 e9 12 f0       	push   $0xf012e978
f011bc01:	e8 66 53 fe ff       	call   f0100f6c <cprintf>
f011bc06:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc09:	e8 32 8c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bc0e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bc11:	74 17                	je     f011bc2a <test_kmalloc_firstfit2+0x50c>
f011bc13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc1a:	83 ec 0c             	sub    $0xc,%esp
f011bc1d:	68 40 e7 12 f0       	push   $0xf012e740
f011bc22:	e8 45 53 fe ff       	call   f0100f6c <cprintf>
f011bc27:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bc2a:	e8 da 1d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bc2f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011bc32:	29 c2                	sub    %eax,%edx
f011bc34:	89 d0                	mov    %edx,%eax
f011bc36:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bc3b:	77 17                	ja     f011bc54 <test_kmalloc_firstfit2+0x536>
f011bc3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc44:	83 ec 0c             	sub    $0xc,%esp
f011bc47:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011bc4c:	e8 1b 53 fe ff       	call   f0100f6c <cprintf>
f011bc51:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bc54:	e8 b0 1d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bc59:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bc5c:	e8 df 8b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bc61:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f011bc64:	83 ec 0c             	sub    $0xc,%esp
f011bc67:	68 00 18 20 00       	push   $0x201800
f011bc6c:	e8 45 ce fe ff       	call   f0108ab6 <kmalloc>
f011bc71:	83 c4 10             	add    $0x10,%esp
f011bc74:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bc77:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bc7a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011bc7f:	74 17                	je     f011bc98 <test_kmalloc_firstfit2+0x57a>
f011bc81:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc88:	83 ec 0c             	sub    $0xc,%esp
f011bc8b:	68 78 e9 12 f0       	push   $0xf012e978
f011bc90:	e8 d7 52 fe ff       	call   f0100f6c <cprintf>
f011bc95:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc98:	e8 a3 8b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bc9d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bca0:	74 17                	je     f011bcb9 <test_kmalloc_firstfit2+0x59b>
f011bca2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bca9:	83 ec 0c             	sub    $0xc,%esp
f011bcac:	68 40 e7 12 f0       	push   $0xf012e740
f011bcb1:	e8 b6 52 fe ff       	call   f0100f6c <cprintf>
f011bcb6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bcb9:	e8 4b 1d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bcbe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011bcc1:	29 c2                	sub    %eax,%edx
f011bcc3:	89 d0                	mov    %edx,%eax
f011bcc5:	3d 01 02 00 00       	cmp    $0x201,%eax
f011bcca:	77 17                	ja     f011bce3 <test_kmalloc_firstfit2+0x5c5>
f011bccc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bcd3:	83 ec 0c             	sub    $0xc,%esp
f011bcd6:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011bcdb:	e8 8c 52 fe ff       	call   f0100f6c <cprintf>
f011bce0:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011bce3:	e8 21 1d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bce8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bceb:	e8 50 8b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bcf0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011bcf3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011bcf6:	83 ec 0c             	sub    $0xc,%esp
f011bcf9:	50                   	push   %eax
f011bcfa:	e8 d1 cd fe ff       	call   f0108ad0 <kfree>
f011bcff:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd02:	e8 39 8b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bd07:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bd0a:	74 17                	je     f011bd23 <test_kmalloc_firstfit2+0x605>
f011bd0c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd13:	83 ec 0c             	sub    $0xc,%esp
f011bd16:	68 40 e7 12 f0       	push   $0xf012e740
f011bd1b:	e8 4c 52 fe ff       	call   f0100f6c <cprintf>
f011bd20:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f011bd23:	e8 e1 1c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bd28:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bd2b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bd30:	77 17                	ja     f011bd49 <test_kmalloc_firstfit2+0x62b>
f011bd32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd39:	83 ec 0c             	sub    $0xc,%esp
f011bd3c:	68 bd e9 12 f0       	push   $0xf012e9bd
f011bd41:	e8 26 52 fe ff       	call   f0100f6c <cprintf>
f011bd46:	83 c4 10             	add    $0x10,%esp

		//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011bd49:	e8 bb 1c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bd4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bd51:	e8 ea 8a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bd56:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f011bd59:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011bd5c:	83 ec 0c             	sub    $0xc,%esp
f011bd5f:	50                   	push   %eax
f011bd60:	e8 6b cd fe ff       	call   f0108ad0 <kfree>
f011bd65:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd68:	e8 d3 8a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bd6d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bd70:	74 17                	je     f011bd89 <test_kmalloc_firstfit2+0x66b>
f011bd72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd79:	83 ec 0c             	sub    $0xc,%esp
f011bd7c:	68 40 e7 12 f0       	push   $0xf012e740
f011bd81:	e8 e6 51 fe ff       	call   f0100f6c <cprintf>
f011bd86:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011bd89:	e8 7b 1c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bd8e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011bd91:	74 17                	je     f011bdaa <test_kmalloc_firstfit2+0x68c>
f011bd93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd9a:	83 ec 0c             	sub    $0xc,%esp
f011bd9d:	68 4c ea 12 f0       	push   $0xf012ea4c
f011bda2:	e8 c5 51 fe ff       	call   f0100f6c <cprintf>
f011bda7:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011bdaa:	e8 5a 1c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bdaf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bdb2:	e8 89 8a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bdb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011bdba:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011bdbd:	83 ec 0c             	sub    $0xc,%esp
f011bdc0:	50                   	push   %eax
f011bdc1:	e8 0a cd fe ff       	call   f0108ad0 <kfree>
f011bdc6:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f011bdc9:	e8 3b 1c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bdce:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bdd1:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bdd6:	77 17                	ja     f011bdef <test_kmalloc_firstfit2+0x6d1>
f011bdd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bddf:	83 ec 0c             	sub    $0xc,%esp
f011bde2:	68 bd e9 12 f0       	push   $0xf012e9bd
f011bde7:	e8 80 51 fe ff       	call   f0100f6c <cprintf>
f011bdec:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bdef:	e8 4c 8a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bdf4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bdf7:	74 17                	je     f011be10 <test_kmalloc_firstfit2+0x6f2>
f011bdf9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be00:	83 ec 0c             	sub    $0xc,%esp
f011be03:	68 40 e7 12 f0       	push   $0xf012e740
f011be08:	e8 5f 51 fe ff       	call   f0100f6c <cprintf>
f011be0d:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011be10:	e8 f4 1b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011be15:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011be18:	e8 23 8a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011be1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f011be20:	83 ec 0c             	sub    $0xc,%esp
f011be23:	68 00 fc 4f 00       	push   $0x4ffc00
f011be28:	e8 89 cc fe ff       	call   f0108ab6 <kmalloc>
f011be2d:	83 c4 10             	add    $0x10,%esp
f011be30:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011be33:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011be36:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f011be3b:	74 17                	je     f011be54 <test_kmalloc_firstfit2+0x736>
f011be3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be44:	83 ec 0c             	sub    $0xc,%esp
f011be47:	68 78 e9 12 f0       	push   $0xf012e978
f011be4c:	e8 1b 51 fe ff       	call   f0100f6c <cprintf>
f011be51:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be54:	e8 e7 89 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011be59:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011be5c:	74 17                	je     f011be75 <test_kmalloc_firstfit2+0x757>
f011be5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be65:	83 ec 0c             	sub    $0xc,%esp
f011be68:	68 40 e7 12 f0       	push   $0xf012e740
f011be6d:	e8 fa 50 fe ff       	call   f0100f6c <cprintf>
f011be72:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011be75:	e8 8f 1b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011be7a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011be7d:	29 c2                	sub    %eax,%edx
f011be7f:	89 d0                	mov    %edx,%eax
f011be81:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f011be86:	77 17                	ja     f011be9f <test_kmalloc_firstfit2+0x781>
f011be88:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be8f:	83 ec 0c             	sub    $0xc,%esp
f011be92:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011be97:	e8 d0 50 fe ff       	call   f0100f6c <cprintf>
f011be9c:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011be9f:	e8 65 1b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bea4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bea7:	e8 94 89 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011beac:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f011beaf:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011beb2:	83 ec 0c             	sub    $0xc,%esp
f011beb5:	50                   	push   %eax
f011beb6:	e8 15 cc fe ff       	call   f0108ad0 <kfree>
f011bebb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bebe:	e8 7d 89 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bec3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bec6:	74 17                	je     f011bedf <test_kmalloc_firstfit2+0x7c1>
f011bec8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011becf:	83 ec 0c             	sub    $0xc,%esp
f011bed2:	68 40 e7 12 f0       	push   $0xf012e740
f011bed7:	e8 90 50 fe ff       	call   f0100f6c <cprintf>
f011bedc:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong free: \n"); }
f011bedf:	e8 25 1b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bee4:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bee7:	83 f8 01             	cmp    $0x1,%eax
f011beea:	77 17                	ja     f011bf03 <test_kmalloc_firstfit2+0x7e5>
f011beec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bef3:	83 ec 0c             	sub    $0xc,%esp
f011bef6:	68 bd e9 12 f0       	push   $0xf012e9bd
f011befb:	e8 6c 50 fe ff       	call   f0100f6c <cprintf>
f011bf00:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011bf03:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bf07:	74 04                	je     f011bf0d <test_kmalloc_firstfit2+0x7ef>
f011bf09:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011bf0d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bf14:	e8 f0 1a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bf19:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bf1c:	e8 1f 89 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bf21:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f011bf24:	83 ec 0c             	sub    $0xc,%esp
f011bf27:	68 00 04 70 00       	push   $0x700400
f011bf2c:	e8 85 cb fe ff       	call   f0108ab6 <kmalloc>
f011bf31:	83 c4 10             	add    $0x10,%esp
f011bf34:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bf37:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011bf3a:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bf3f:	74 17                	je     f011bf58 <test_kmalloc_firstfit2+0x83a>
f011bf41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bf48:	83 ec 0c             	sub    $0xc,%esp
f011bf4b:	68 78 e9 12 f0       	push   $0xf012e978
f011bf50:	e8 17 50 fe ff       	call   f0100f6c <cprintf>
f011bf55:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf58:	e8 e3 88 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bf5d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bf60:	74 17                	je     f011bf79 <test_kmalloc_firstfit2+0x85b>
f011bf62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bf69:	83 ec 0c             	sub    $0xc,%esp
f011bf6c:	68 40 e7 12 f0       	push   $0xf012e740
f011bf71:	e8 f6 4f fe ff       	call   f0100f6c <cprintf>
f011bf76:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bf79:	e8 8b 1a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bf7e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011bf81:	29 c2                	sub    %eax,%edx
f011bf83:	89 d0                	mov    %edx,%eax
f011bf85:	3d 00 07 00 00       	cmp    $0x700,%eax
f011bf8a:	77 17                	ja     f011bfa3 <test_kmalloc_firstfit2+0x885>
f011bf8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bf93:	83 ec 0c             	sub    $0xc,%esp
f011bf96:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011bf9b:	e8 cc 4f fe ff       	call   f0100f6c <cprintf>
f011bfa0:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bfa3:	e8 61 1a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011bfa8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bfab:	e8 90 88 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bfb0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f011bfb3:	83 ec 0c             	sub    $0xc,%esp
f011bfb6:	68 00 0c 00 00       	push   $0xc00
f011bfbb:	e8 f6 ca fe ff       	call   f0108ab6 <kmalloc>
f011bfc0:	83 c4 10             	add    $0x10,%esp
f011bfc3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bfc6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011bfc9:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f011bfce:	74 17                	je     f011bfe7 <test_kmalloc_firstfit2+0x8c9>
f011bfd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bfd7:	83 ec 0c             	sub    $0xc,%esp
f011bfda:	68 78 e9 12 f0       	push   $0xf012e978
f011bfdf:	e8 88 4f fe ff       	call   f0100f6c <cprintf>
f011bfe4:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bfe7:	e8 54 88 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011bfec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bfef:	74 17                	je     f011c008 <test_kmalloc_firstfit2+0x8ea>
f011bff1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bff8:	83 ec 0c             	sub    $0xc,%esp
f011bffb:	68 40 e7 12 f0       	push   $0xf012e740
f011c000:	e8 67 4f fe ff       	call   f0100f6c <cprintf>
f011c005:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("Wrong allocation: \n"); }
f011c008:	e8 fc 19 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c00d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011c010:	75 17                	jne    f011c029 <test_kmalloc_firstfit2+0x90b>
f011c012:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c019:	83 ec 0c             	sub    $0xc,%esp
f011c01c:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011c021:	e8 46 4f fe ff       	call   f0100f6c <cprintf>
f011c026:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011c029:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c02d:	74 04                	je     f011c033 <test_kmalloc_firstfit2+0x915>
f011c02f:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011c033:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011c03a:	e8 ca 19 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c03f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c042:	e8 f9 87 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c047:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011c04a:	83 ec 0c             	sub    $0xc,%esp
f011c04d:	68 00 04 00 00       	push   $0x400
f011c052:	e8 5f ca fe ff       	call   f0108ab6 <kmalloc>
f011c057:	83 c4 10             	add    $0x10,%esp
f011c05a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011c05d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011c060:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c063:	39 c2                	cmp    %eax,%edx
f011c065:	72 10                	jb     f011c077 <test_kmalloc_firstfit2+0x959>
f011c067:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c06a:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011c06d:	81 c2 00 04 00 00    	add    $0x400,%edx
f011c073:	39 d0                	cmp    %edx,%eax
f011c075:	76 17                	jbe    f011c08e <test_kmalloc_firstfit2+0x970>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011c077:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c07e:	83 ec 0c             	sub    $0xc,%esp
f011c081:	68 78 e9 12 f0       	push   $0xf012e978
f011c086:	e8 e1 4e fe ff       	call   f0100f6c <cprintf>
f011c08b:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c08e:	e8 ad 87 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c093:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011c096:	74 17                	je     f011c0af <test_kmalloc_firstfit2+0x991>
f011c098:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c09f:	83 ec 0c             	sub    $0xc,%esp
f011c0a2:	68 40 e7 12 f0       	push   $0xf012e740
f011c0a7:	e8 c0 4e fe ff       	call   f0100f6c <cprintf>
f011c0ac:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011c0af:	e8 55 19 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c0b4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011c0b7:	74 17                	je     f011c0d0 <test_kmalloc_firstfit2+0x9b2>
f011c0b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c0c0:	83 ec 0c             	sub    $0xc,%esp
f011c0c3:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011c0c8:	e8 9f 4e fe ff       	call   f0100f6c <cprintf>
f011c0cd:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011c0d0:	e8 34 19 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c0d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c0d8:	e8 63 87 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c0dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f011c0e0:	83 ec 0c             	sub    $0xc,%esp
f011c0e3:	68 00 04 00 00       	push   $0x400
f011c0e8:	e8 c9 c9 fe ff       	call   f0108ab6 <kmalloc>
f011c0ed:	83 c4 10             	add    $0x10,%esp
f011c0f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011c0f3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c0f6:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011c0f9:	81 c2 00 04 00 00    	add    $0x400,%edx
f011c0ff:	39 d0                	cmp    %edx,%eax
f011c101:	72 10                	jb     f011c113 <test_kmalloc_firstfit2+0x9f5>
f011c103:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c106:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011c109:	81 c2 00 08 00 00    	add    $0x800,%edx
f011c10f:	39 d0                	cmp    %edx,%eax
f011c111:	76 17                	jbe    f011c12a <test_kmalloc_firstfit2+0xa0c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011c113:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c11a:	83 ec 0c             	sub    $0xc,%esp
f011c11d:	68 78 e9 12 f0       	push   $0xf012e978
f011c122:	e8 45 4e fe ff       	call   f0100f6c <cprintf>
f011c127:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c12a:	e8 11 87 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c12f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011c132:	74 17                	je     f011c14b <test_kmalloc_firstfit2+0xa2d>
f011c134:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c13b:	83 ec 0c             	sub    $0xc,%esp
f011c13e:	68 40 e7 12 f0       	push   $0xf012e740
f011c143:	e8 24 4e fe ff       	call   f0100f6c <cprintf>
f011c148:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011c14b:	e8 b9 18 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c150:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011c153:	74 17                	je     f011c16c <test_kmalloc_firstfit2+0xa4e>
f011c155:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c15c:	83 ec 0c             	sub    $0xc,%esp
f011c15f:	68 a9 e9 12 f0       	push   $0xf012e9a9
f011c164:	e8 03 4e fe ff       	call   f0100f6c <cprintf>
f011c169:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f011c16c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c170:	74 04                	je     f011c176 <test_kmalloc_firstfit2+0xa58>
f011c172:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011c176:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011c17d:	83 ec 0c             	sub    $0xc,%esp
f011c180:	68 00 e0 1f 07       	push   $0x71fe000
f011c185:	e8 2c c9 fe ff       	call   f0108ab6 <kmalloc>
f011c18a:	83 c4 10             	add    $0x10,%esp
f011c18d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f011c190:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c193:	85 c0                	test   %eax,%eax
f011c195:	74 17                	je     f011c1ae <test_kmalloc_firstfit2+0xa90>
f011c197:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c19e:	83 ec 0c             	sub    $0xc,%esp
f011c1a1:	68 a8 ea 12 f0       	push   $0xf012eaa8
f011c1a6:	e8 c1 4d fe ff       	call   f0100f6c <cprintf>
f011c1ab:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f011c1ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c1b2:	74 04                	je     f011c1b8 <test_kmalloc_firstfit2+0xa9a>
f011c1b4:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011c1b8:	83 ec 08             	sub    $0x8,%esp
f011c1bb:	ff 75 f4             	pushl  -0xc(%ebp)
f011c1be:	68 0c eb 12 f0       	push   $0xf012eb0c
f011c1c3:	e8 a4 4d fe ff       	call   f0100f6c <cprintf>
f011c1c8:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c1cb:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011c1d0:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011c1d3:	5b                   	pop    %ebx
f011c1d4:	5f                   	pop    %edi
f011c1d5:	5d                   	pop    %ebp
f011c1d6:	c3                   	ret    

f011c1d7 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011c1d7:	55                   	push   %ebp
f011c1d8:	89 e5                	mov    %esp,%ebp
f011c1da:	57                   	push   %edi
f011c1db:	53                   	push   %ebx
f011c1dc:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011c1e2:	83 ec 0c             	sub    $0xc,%esp
f011c1e5:	68 80 e6 12 f0       	push   $0xf012e680
f011c1ea:	e8 7d 4d fe ff       	call   f0100f6c <cprintf>
f011c1ef:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c1f2:	83 ec 0c             	sub    $0xc,%esp
f011c1f5:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011c1fa:	e8 6d 4d fe ff       	call   f0100f6c <cprintf>
f011c1ff:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011c202:	83 ec 0c             	sub    $0xc,%esp
f011c205:	68 80 e6 12 f0       	push   $0xf012e680
f011c20a:	e8 5d 4d fe ff       	call   f0100f6c <cprintf>
f011c20f:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011c212:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011c216:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f011c21a:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011c220:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f011c226:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011c22d:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011c234:	e8 d0 17 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c239:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011c23c:	8d 95 68 ff ff ff    	lea    -0x98(%ebp),%edx
f011c242:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c247:	b8 00 00 00 00       	mov    $0x0,%eax
f011c24c:	89 d7                	mov    %edx,%edi
f011c24e:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011c250:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f011c256:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c25b:	b8 00 00 00 00       	mov    $0x0,%eax
f011c260:	89 d7                	mov    %edx,%edi
f011c262:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011c264:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011c26b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011c272:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011c279:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
f011c27f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c284:	b8 00 00 00 00       	mov    $0x0,%eax
f011c289:	89 d7                	mov    %edx,%edi
f011c28b:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//[BLOCK ALLOCATOR]
		{
			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c28d:	e8 77 17 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c292:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c295:	e8 a6 85 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c29a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f011c29d:	83 ec 0c             	sub    $0xc,%esp
f011c2a0:	68 00 08 00 00       	push   $0x800
f011c2a5:	e8 0c c8 fe ff       	call   f0108ab6 <kmalloc>
f011c2aa:	83 c4 10             	add    $0x10,%esp
f011c2ad:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c2b3:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c2b9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c2be:	76 28                	jbe    f011c2e8 <test_kfree_bestfirstfit+0x111>
f011c2c0:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011c2c6:	83 ec 0c             	sub    $0xc,%esp
f011c2c9:	6a 00                	push   $0x0
f011c2cb:	e8 dc c7 fe ff       	call   f0108aac <sbrk>
f011c2d0:	83 c4 10             	add    $0x10,%esp
f011c2d3:	39 c3                	cmp    %eax,%ebx
f011c2d5:	73 11                	jae    f011c2e8 <test_kfree_bestfirstfit+0x111>
f011c2d7:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c2dd:	89 c2                	mov    %eax,%edx
f011c2df:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c2e4:	39 c2                	cmp    %eax,%edx
f011c2e6:	72 17                	jb     f011c2ff <test_kfree_bestfirstfit+0x128>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c2e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c2ef:	83 ec 0c             	sub    $0xc,%esp
f011c2f2:	68 40 e8 12 f0       	push   $0xf012e840
f011c2f7:	e8 70 4c fe ff       	call   f0100f6c <cprintf>
f011c2fc:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c2ff:	e8 3c 85 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c304:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c307:	74 17                	je     f011c320 <test_kfree_bestfirstfit+0x149>
f011c309:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c310:	83 ec 0c             	sub    $0xc,%esp
f011c313:	68 40 e7 12 f0       	push   $0xf012e740
f011c318:	e8 4f 4c fe ff       	call   f0100f6c <cprintf>
f011c31d:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011c320:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011c327:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011c32a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c330:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011c333:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c33a:	eb 0e                	jmp    f011c34a <test_kfree_bestfirstfit+0x173>
			{
				ptr[i] = 2 ;
f011c33c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c33f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c342:	01 d0                	add    %edx,%eax
f011c344:	c6 00 02             	movb   $0x2,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011c347:	ff 45 f4             	incl   -0xc(%ebp)
f011c34a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c350:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c353:	7f e7                	jg     f011c33c <test_kfree_bestfirstfit+0x165>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c355:	e8 af 16 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c35a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c35d:	e8 de 84 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c362:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c365:	83 ec 0c             	sub    $0xc,%esp
f011c368:	68 00 08 00 00       	push   $0x800
f011c36d:	e8 44 c7 fe ff       	call   f0108ab6 <kmalloc>
f011c372:	83 c4 10             	add    $0x10,%esp
f011c375:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c37b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c381:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c386:	76 28                	jbe    f011c3b0 <test_kfree_bestfirstfit+0x1d9>
f011c388:	8b 9d d4 fe ff ff    	mov    -0x12c(%ebp),%ebx
f011c38e:	83 ec 0c             	sub    $0xc,%esp
f011c391:	6a 00                	push   $0x0
f011c393:	e8 14 c7 fe ff       	call   f0108aac <sbrk>
f011c398:	83 c4 10             	add    $0x10,%esp
f011c39b:	39 c3                	cmp    %eax,%ebx
f011c39d:	73 11                	jae    f011c3b0 <test_kfree_bestfirstfit+0x1d9>
f011c39f:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c3a5:	89 c2                	mov    %eax,%edx
f011c3a7:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c3ac:	39 c2                	cmp    %eax,%edx
f011c3ae:	72 17                	jb     f011c3c7 <test_kfree_bestfirstfit+0x1f0>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c3b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3b7:	83 ec 0c             	sub    $0xc,%esp
f011c3ba:	68 40 e8 12 f0       	push   $0xf012e840
f011c3bf:	e8 a8 4b fe ff       	call   f0100f6c <cprintf>
f011c3c4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c3c7:	e8 74 84 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c3cc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c3cf:	74 17                	je     f011c3e8 <test_kfree_bestfirstfit+0x211>
f011c3d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3d8:	83 ec 0c             	sub    $0xc,%esp
f011c3db:	68 40 e7 12 f0       	push   $0xf012e740
f011c3e0:	e8 87 4b fe ff       	call   f0100f6c <cprintf>
f011c3e5:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011c3e8:	c7 85 74 ff ff ff ff 	movl   $0x7ff,-0x8c(%ebp)
f011c3ef:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011c3f2:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c3f8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011c3fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c402:	eb 0e                	jmp    f011c412 <test_kfree_bestfirstfit+0x23b>
			{
				ptr[i] = 3 ;
f011c404:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c407:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c40a:	01 d0                	add    %edx,%eax
f011c40c:	c6 00 03             	movb   $0x3,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011c40f:	ff 45 f4             	incl   -0xc(%ebp)
f011c412:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011c418:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c41b:	7f e7                	jg     f011c404 <test_kfree_bestfirstfit+0x22d>
		}

		//[PAGE ALLOCATOR]
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011c41d:	e8 e7 15 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c422:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c425:	e8 16 84 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c42a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011c42d:	83 ec 0c             	sub    $0xc,%esp
f011c430:	68 00 fc 1f 00       	push   $0x1ffc00
f011c435:	e8 7c c6 fe ff       	call   f0108ab6 <kmalloc>
f011c43a:	83 c4 10             	add    $0x10,%esp
f011c43d:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c443:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011c449:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011c44e:	74 17                	je     f011c467 <test_kfree_bestfirstfit+0x290>
f011c450:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c457:	83 ec 0c             	sub    $0xc,%esp
f011c45a:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011c45f:	e8 08 4b fe ff       	call   f0100f6c <cprintf>
f011c464:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c467:	e8 d4 83 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c46c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c46f:	74 17                	je     f011c488 <test_kfree_bestfirstfit+0x2b1>
f011c471:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c478:	83 ec 0c             	sub    $0xc,%esp
f011c47b:	68 40 e7 12 f0       	push   $0xf012e740
f011c480:	e8 e7 4a fe ff       	call   f0100f6c <cprintf>
f011c485:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c488:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c48b:	e8 79 15 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c490:	29 c3                	sub    %eax,%ebx
f011c492:	89 d8                	mov    %ebx,%eax
f011c494:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c499:	77 17                	ja     f011c4b2 <test_kfree_bestfirstfit+0x2db>
f011c49b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4a2:	83 ec 0c             	sub    $0xc,%esp
f011c4a5:	68 ac e7 12 f0       	push   $0xf012e7ac
f011c4aa:	e8 bd 4a fe ff       	call   f0100f6c <cprintf>
f011c4af:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011c4b2:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011c4b9:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011c4bc:	e8 48 15 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c4c1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c4c4:	e8 77 83 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c4c9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011c4cc:	83 ec 0c             	sub    $0xc,%esp
f011c4cf:	68 00 fc 1f 00       	push   $0x1ffc00
f011c4d4:	e8 dd c5 fe ff       	call   f0108ab6 <kmalloc>
f011c4d9:	83 c4 10             	add    $0x10,%esp
f011c4dc:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c4e2:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011c4e8:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011c4ed:	74 17                	je     f011c506 <test_kfree_bestfirstfit+0x32f>
f011c4ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4f6:	83 ec 0c             	sub    $0xc,%esp
f011c4f9:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011c4fe:	e8 69 4a fe ff       	call   f0100f6c <cprintf>
f011c503:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c506:	e8 35 83 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c50b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c50e:	74 17                	je     f011c527 <test_kfree_bestfirstfit+0x350>
f011c510:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c517:	83 ec 0c             	sub    $0xc,%esp
f011c51a:	68 40 e7 12 f0       	push   $0xf012e740
f011c51f:	e8 48 4a fe ff       	call   f0100f6c <cprintf>
f011c524:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c527:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c52a:	e8 da 14 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c52f:	29 c3                	sub    %eax,%ebx
f011c531:	89 d8                	mov    %ebx,%eax
f011c533:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c538:	77 17                	ja     f011c551 <test_kfree_bestfirstfit+0x37a>
f011c53a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c541:	83 ec 0c             	sub    $0xc,%esp
f011c544:	68 ac e7 12 f0       	push   $0xf012e7ac
f011c549:	e8 1e 4a fe ff       	call   f0100f6c <cprintf>
f011c54e:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f011c551:	c7 85 6c ff ff ff ff 	movl   $0x1ffbff,-0x94(%ebp)
f011c558:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011c55b:	e8 a9 14 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c560:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c563:	e8 d8 82 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c568:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011c56b:	83 ec 0c             	sub    $0xc,%esp
f011c56e:	68 00 1c 00 00       	push   $0x1c00
f011c573:	e8 3e c5 fe ff       	call   f0108ab6 <kmalloc>
f011c578:	83 c4 10             	add    $0x10,%esp
f011c57b:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c581:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011c587:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c58c:	74 17                	je     f011c5a5 <test_kfree_bestfirstfit+0x3ce>
f011c58e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c595:	83 ec 0c             	sub    $0xc,%esp
f011c598:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011c59d:	e8 ca 49 fe ff       	call   f0100f6c <cprintf>
f011c5a2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c5a5:	e8 96 82 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c5aa:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c5ad:	74 17                	je     f011c5c6 <test_kfree_bestfirstfit+0x3ef>
f011c5af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c5b6:	83 ec 0c             	sub    $0xc,%esp
f011c5b9:	68 40 e7 12 f0       	push   $0xf012e740
f011c5be:	e8 a9 49 fe ff       	call   f0100f6c <cprintf>
f011c5c3:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c5c6:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c5c9:	e8 3b 14 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c5ce:	29 c3                	sub    %eax,%ebx
f011c5d0:	89 d8                	mov    %ebx,%eax
f011c5d2:	83 f8 01             	cmp    $0x1,%eax
f011c5d5:	77 17                	ja     f011c5ee <test_kfree_bestfirstfit+0x417>
f011c5d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c5de:	83 ec 0c             	sub    $0xc,%esp
f011c5e1:	68 ac e7 12 f0       	push   $0xf012e7ac
f011c5e6:	e8 81 49 fe ff       	call   f0100f6c <cprintf>
f011c5eb:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011c5ee:	c7 85 78 ff ff ff ff 	movl   $0x1bff,-0x88(%ebp)
f011c5f5:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011c5f8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011c5fe:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011c601:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c608:	eb 0e                	jmp    f011c618 <test_kfree_bestfirstfit+0x441>
			{
				ptr[i] = 4 ;
f011c60a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c60d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c610:	01 d0                	add    %edx,%eax
f011c612:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011c615:	ff 45 f4             	incl   -0xc(%ebp)
f011c618:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c61e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c621:	7f e7                	jg     f011c60a <test_kfree_bestfirstfit+0x433>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f011c623:	e8 e1 13 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c628:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c62b:	e8 10 82 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c630:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011c633:	83 ec 0c             	sub    $0xc,%esp
f011c636:	68 00 fc 2f 00       	push   $0x2ffc00
f011c63b:	e8 76 c4 fe ff       	call   f0108ab6 <kmalloc>
f011c640:	83 c4 10             	add    $0x10,%esp
f011c643:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c649:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011c64f:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011c654:	74 17                	je     f011c66d <test_kfree_bestfirstfit+0x496>
f011c656:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c65d:	83 ec 0c             	sub    $0xc,%esp
f011c660:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011c665:	e8 02 49 fe ff       	call   f0100f6c <cprintf>
f011c66a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c66d:	e8 ce 81 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c672:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c675:	74 17                	je     f011c68e <test_kfree_bestfirstfit+0x4b7>
f011c677:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c67e:	83 ec 0c             	sub    $0xc,%esp
f011c681:	68 40 e7 12 f0       	push   $0xf012e740
f011c686:	e8 e1 48 fe ff       	call   f0100f6c <cprintf>
f011c68b:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c68e:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c691:	e8 73 13 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c696:	29 c3                	sub    %eax,%ebx
f011c698:	89 d8                	mov    %ebx,%eax
f011c69a:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c69f:	77 17                	ja     f011c6b8 <test_kfree_bestfirstfit+0x4e1>
f011c6a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c6a8:	83 ec 0c             	sub    $0xc,%esp
f011c6ab:	68 ac e7 12 f0       	push   $0xf012e7ac
f011c6b0:	e8 b7 48 fe ff       	call   f0100f6c <cprintf>
f011c6b5:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f011c6b8:	c7 85 7c ff ff ff ff 	movl   $0x2ffbff,-0x84(%ebp)
f011c6bf:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011c6c2:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011c6c8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f011c6cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c6d2:	eb 0e                	jmp    f011c6e2 <test_kfree_bestfirstfit+0x50b>
			{
				ptr[i] = 5 ;
f011c6d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c6d7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c6da:	01 d0                	add    %edx,%eax
f011c6dc:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f011c6df:	ff 45 f4             	incl   -0xc(%ebp)
f011c6e2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c6e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c6eb:	7f e7                	jg     f011c6d4 <test_kfree_bestfirstfit+0x4fd>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011c6ed:	e8 17 13 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c6f2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c6f5:	e8 46 81 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c6fa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011c6fd:	83 ec 0c             	sub    $0xc,%esp
f011c700:	68 00 fc 5f 00       	push   $0x5ffc00
f011c705:	e8 ac c3 fe ff       	call   f0108ab6 <kmalloc>
f011c70a:	83 c4 10             	add    $0x10,%esp
f011c70d:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c713:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011c719:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c71e:	74 17                	je     f011c737 <test_kfree_bestfirstfit+0x560>
f011c720:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c727:	83 ec 0c             	sub    $0xc,%esp
f011c72a:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011c72f:	e8 38 48 fe ff       	call   f0100f6c <cprintf>
f011c734:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c737:	e8 04 81 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c73c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c73f:	74 17                	je     f011c758 <test_kfree_bestfirstfit+0x581>
f011c741:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c748:	83 ec 0c             	sub    $0xc,%esp
f011c74b:	68 40 e7 12 f0       	push   $0xf012e740
f011c750:	e8 17 48 fe ff       	call   f0100f6c <cprintf>
f011c755:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c758:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c75b:	e8 a9 12 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c760:	29 c3                	sub    %eax,%ebx
f011c762:	89 d8                	mov    %ebx,%eax
f011c764:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c769:	77 17                	ja     f011c782 <test_kfree_bestfirstfit+0x5ab>
f011c76b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c772:	83 ec 0c             	sub    $0xc,%esp
f011c775:	68 ac e7 12 f0       	push   $0xf012e7ac
f011c77a:	e8 ed 47 fe ff       	call   f0100f6c <cprintf>
f011c77f:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f011c782:	c7 45 80 ff fb 5f 00 	movl   $0x5ffbff,-0x80(%ebp)

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f011c789:	e8 7b 12 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c78e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c791:	e8 aa 80 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c796:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f011c799:	83 ec 0c             	sub    $0xc,%esp
f011c79c:	68 00 38 00 00       	push   $0x3800
f011c7a1:	e8 10 c3 fe ff       	call   f0108ab6 <kmalloc>
f011c7a6:	83 c4 10             	add    $0x10,%esp
f011c7a9:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c7af:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011c7b5:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c7ba:	74 17                	je     f011c7d3 <test_kfree_bestfirstfit+0x5fc>
f011c7bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c7c3:	83 ec 0c             	sub    $0xc,%esp
f011c7c6:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011c7cb:	e8 9c 47 fe ff       	call   f0100f6c <cprintf>
f011c7d0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c7d3:	e8 68 80 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c7d8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c7db:	74 17                	je     f011c7f4 <test_kfree_bestfirstfit+0x61d>
f011c7dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c7e4:	83 ec 0c             	sub    $0xc,%esp
f011c7e7:	68 40 e7 12 f0       	push   $0xf012e740
f011c7ec:	e8 7b 47 fe ff       	call   f0100f6c <cprintf>
f011c7f1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c7f4:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c7f7:	e8 0d 12 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c7fc:	29 c3                	sub    %eax,%ebx
f011c7fe:	89 d8                	mov    %ebx,%eax
f011c800:	83 f8 03             	cmp    $0x3,%eax
f011c803:	77 17                	ja     f011c81c <test_kfree_bestfirstfit+0x645>
f011c805:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c80c:	83 ec 0c             	sub    $0xc,%esp
f011c80f:	68 ac e7 12 f0       	push   $0xf012e7ac
f011c814:	e8 53 47 fe ff       	call   f0100f6c <cprintf>
f011c819:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f011c81c:	c7 45 84 ff 37 00 00 	movl   $0x37ff,-0x7c(%ebp)
			ptr = (char*)ptr_allocations[7];
f011c823:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011c829:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f011c82c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c833:	eb 0e                	jmp    f011c843 <test_kfree_bestfirstfit+0x66c>
			{
				ptr[i] = 7 ;
f011c835:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c838:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c83b:	01 d0                	add    %edx,%eax
f011c83d:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f011c840:	ff 45 f4             	incl   -0xc(%ebp)
f011c843:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c846:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c849:	7f ea                	jg     f011c835 <test_kfree_bestfirstfit+0x65e>
	}

	//kfree some of the allocated spaces [10%]
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c84b:	e8 b9 11 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c850:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c853:	e8 e8 7f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c858:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011c85b:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011c861:	83 ec 0c             	sub    $0xc,%esp
f011c864:	50                   	push   %eax
f011c865:	e8 66 c2 fe ff       	call   f0108ad0 <kfree>
f011c86a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c86d:	e8 ce 7f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c872:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c875:	74 17                	je     f011c88e <test_kfree_bestfirstfit+0x6b7>
f011c877:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c87e:	83 ec 0c             	sub    $0xc,%esp
f011c881:	68 40 e7 12 f0       	push   $0xf012e740
f011c886:	e8 e1 46 fe ff       	call   f0100f6c <cprintf>
f011c88b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c88e:	e8 76 11 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c893:	89 c2                	mov    %eax,%edx
f011c895:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c898:	29 c2                	sub    %eax,%edx
f011c89a:	89 d0                	mov    %edx,%eax
f011c89c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c8a1:	77 17                	ja     f011c8ba <test_kfree_bestfirstfit+0x6e3>
f011c8a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c8aa:	83 ec 0c             	sub    $0xc,%esp
f011c8ad:	68 44 eb 12 f0       	push   $0xf012eb44
f011c8b2:	e8 b5 46 fe ff       	call   f0100f6c <cprintf>
f011c8b7:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB
		freeFrames = sys_calculate_free_frames() ;
f011c8ba:	e8 4a 11 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c8bf:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c8c2:	e8 79 7f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c8c7:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011c8ca:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c8d0:	83 ec 0c             	sub    $0xc,%esp
f011c8d3:	50                   	push   %eax
f011c8d4:	e8 f7 c1 fe ff       	call   f0108ad0 <kfree>
f011c8d9:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c8dc:	e8 5f 7f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c8e1:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c8e4:	74 17                	je     f011c8fd <test_kfree_bestfirstfit+0x726>
f011c8e6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c8ed:	83 ec 0c             	sub    $0xc,%esp
f011c8f0:	68 40 e7 12 f0       	push   $0xf012e740
f011c8f5:	e8 72 46 fe ff       	call   f0100f6c <cprintf>
f011c8fa:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011c8fd:	e8 07 11 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c902:	89 c2                	mov    %eax,%edx
f011c904:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c907:	39 c2                	cmp    %eax,%edx
f011c909:	74 17                	je     f011c922 <test_kfree_bestfirstfit+0x74b>
f011c90b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c912:	83 ec 0c             	sub    $0xc,%esp
f011c915:	68 4c ea 12 f0       	push   $0xf012ea4c
f011c91a:	e8 4d 46 fe ff       	call   f0100f6c <cprintf>
f011c91f:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c922:	e8 e2 10 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c927:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c92a:	e8 11 7f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c92f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011c932:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011c938:	83 ec 0c             	sub    $0xc,%esp
f011c93b:	50                   	push   %eax
f011c93c:	e8 8f c1 fe ff       	call   f0108ad0 <kfree>
f011c941:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c944:	e8 f7 7e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c949:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c94c:	74 17                	je     f011c965 <test_kfree_bestfirstfit+0x78e>
f011c94e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c955:	83 ec 0c             	sub    $0xc,%esp
f011c958:	68 40 e7 12 f0       	push   $0xf012e740
f011c95d:	e8 0a 46 fe ff       	call   f0100f6c <cprintf>
f011c962:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c965:	e8 9f 10 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c96a:	89 c2                	mov    %eax,%edx
f011c96c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c96f:	29 c2                	sub    %eax,%edx
f011c971:	89 d0                	mov    %edx,%eax
f011c973:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c978:	77 17                	ja     f011c991 <test_kfree_bestfirstfit+0x7ba>
f011c97a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c981:	83 ec 0c             	sub    $0xc,%esp
f011c984:	68 44 eb 12 f0       	push   $0xf012eb44
f011c989:	e8 de 45 fe ff       	call   f0100f6c <cprintf>
f011c98e:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c991:	e8 73 10 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c996:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c999:	e8 a2 7e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c99e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011c9a1:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011c9a7:	83 ec 0c             	sub    $0xc,%esp
f011c9aa:	50                   	push   %eax
f011c9ab:	e8 20 c1 fe ff       	call   f0108ad0 <kfree>
f011c9b0:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c9b3:	e8 88 7e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011c9b8:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c9bb:	74 17                	je     f011c9d4 <test_kfree_bestfirstfit+0x7fd>
f011c9bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c9c4:	83 ec 0c             	sub    $0xc,%esp
f011c9c7:	68 40 e7 12 f0       	push   $0xf012e740
f011c9cc:	e8 9b 45 fe ff       	call   f0100f6c <cprintf>
f011c9d1:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c9d4:	e8 30 10 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011c9d9:	89 c2                	mov    %eax,%edx
f011c9db:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c9de:	29 c2                	sub    %eax,%edx
f011c9e0:	89 d0                	mov    %edx,%eax
f011c9e2:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c9e7:	77 17                	ja     f011ca00 <test_kfree_bestfirstfit+0x829>
f011c9e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c9f0:	83 ec 0c             	sub    $0xc,%esp
f011c9f3:	68 44 eb 12 f0       	push   $0xf012eb44
f011c9f8:	e8 6f 45 fe ff       	call   f0100f6c <cprintf>
f011c9fd:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011ca00:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ca04:	74 04                	je     f011ca0a <test_kfree_bestfirstfit+0x833>
f011ca06:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011ca0a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011ca11:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011ca17:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011ca1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ca21:	eb 1e                	jmp    f011ca41 <test_kfree_bestfirstfit+0x86a>
		{
			sums[3] += ptr[i] ;
f011ca23:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011ca29:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ca2c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ca2f:	01 c8                	add    %ecx,%eax
f011ca31:	8a 00                	mov    (%eax),%al
f011ca33:	0f be c0             	movsbl %al,%eax
f011ca36:	01 d0                	add    %edx,%eax
f011ca38:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
	correct = 1 ;
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011ca3e:	ff 45 f4             	incl   -0xc(%ebp)
f011ca41:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011ca47:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ca4a:	7f d7                	jg     f011ca23 <test_kfree_bestfirstfit+0x84c>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011ca4c:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011ca52:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011ca58:	89 c1                	mov    %eax,%ecx
f011ca5a:	01 c9                	add    %ecx,%ecx
f011ca5c:	01 c8                	add    %ecx,%eax
f011ca5e:	39 c2                	cmp    %eax,%edx
f011ca60:	74 17                	je     f011ca79 <test_kfree_bestfirstfit+0x8a2>
f011ca62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ca69:	83 ec 0c             	sub    $0xc,%esp
f011ca6c:	68 7c eb 12 f0       	push   $0xf012eb7c
f011ca71:	e8 f6 44 fe ff       	call   f0100f6c <cprintf>
f011ca76:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011ca79:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011ca7f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011ca82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ca89:	eb 1e                	jmp    f011caa9 <test_kfree_bestfirstfit+0x8d2>
		{
			sums[4] += ptr[i] ;
f011ca8b:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011ca91:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ca94:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ca97:	01 c8                	add    %ecx,%eax
f011ca99:	8a 00                	mov    (%eax),%al
f011ca9b:	0f be c0             	movsbl %al,%eax
f011ca9e:	01 d0                	add    %edx,%eax
f011caa0:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011caa6:	ff 45 f4             	incl   -0xc(%ebp)
f011caa9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011caaf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cab2:	7f d7                	jg     f011ca8b <test_kfree_bestfirstfit+0x8b4>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011cab4:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011caba:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011cac0:	c1 e2 02             	shl    $0x2,%edx
f011cac3:	39 d0                	cmp    %edx,%eax
f011cac5:	74 17                	je     f011cade <test_kfree_bestfirstfit+0x907>
f011cac7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cace:	83 ec 0c             	sub    $0xc,%esp
f011cad1:	68 7c eb 12 f0       	push   $0xf012eb7c
f011cad6:	e8 91 44 fe ff       	call   f0100f6c <cprintf>
f011cadb:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011cade:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011cae4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011cae7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011caee:	eb 1e                	jmp    f011cb0e <test_kfree_bestfirstfit+0x937>
		{
			sums[5] += ptr[i] ;
f011caf0:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011caf6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011caf9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cafc:	01 c8                	add    %ecx,%eax
f011cafe:	8a 00                	mov    (%eax),%al
f011cb00:	0f be c0             	movsbl %al,%eax
f011cb03:	01 d0                	add    %edx,%eax
f011cb05:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011cb0b:	ff 45 f4             	incl   -0xc(%ebp)
f011cb0e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011cb14:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cb17:	7f d7                	jg     f011caf0 <test_kfree_bestfirstfit+0x919>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011cb19:	8b 8d 2c ff ff ff    	mov    -0xd4(%ebp),%ecx
f011cb1f:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
f011cb25:	89 d0                	mov    %edx,%eax
f011cb27:	c1 e0 02             	shl    $0x2,%eax
f011cb2a:	01 d0                	add    %edx,%eax
f011cb2c:	39 c1                	cmp    %eax,%ecx
f011cb2e:	74 17                	je     f011cb47 <test_kfree_bestfirstfit+0x970>
f011cb30:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cb37:	83 ec 0c             	sub    $0xc,%esp
f011cb3a:	68 7c eb 12 f0       	push   $0xf012eb7c
f011cb3f:	e8 28 44 fe ff       	call   f0100f6c <cprintf>
f011cb44:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011cb47:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011cb4d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011cb50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cb57:	eb 1e                	jmp    f011cb77 <test_kfree_bestfirstfit+0x9a0>
		{
			sums[7] += ptr[i] ;
f011cb59:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011cb5f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011cb62:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cb65:	01 c8                	add    %ecx,%eax
f011cb67:	8a 00                	mov    (%eax),%al
f011cb69:	0f be c0             	movsbl %al,%eax
f011cb6c:	01 d0                	add    %edx,%eax
f011cb6e:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011cb74:	ff 45 f4             	incl   -0xc(%ebp)
f011cb77:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011cb7a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cb7d:	7f da                	jg     f011cb59 <test_kfree_bestfirstfit+0x982>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011cb7f:	8b 8d 34 ff ff ff    	mov    -0xcc(%ebp),%ecx
f011cb85:	8b 55 84             	mov    -0x7c(%ebp),%edx
f011cb88:	89 d0                	mov    %edx,%eax
f011cb8a:	01 c0                	add    %eax,%eax
f011cb8c:	01 d0                	add    %edx,%eax
f011cb8e:	01 c0                	add    %eax,%eax
f011cb90:	01 d0                	add    %edx,%eax
f011cb92:	39 c1                	cmp    %eax,%ecx
f011cb94:	74 17                	je     f011cbad <test_kfree_bestfirstfit+0x9d6>
f011cb96:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cb9d:	83 ec 0c             	sub    $0xc,%esp
f011cba0:	68 7c eb 12 f0       	push   $0xf012eb7c
f011cba5:	e8 c2 43 fe ff       	call   f0100f6c <cprintf>
f011cbaa:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011cbad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011cbb1:	74 04                	je     f011cbb7 <test_kfree_bestfirstfit+0x9e0>
f011cbb3:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011cbb7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	{
		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011cbbe:	e8 46 0e ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cbc3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cbc6:	e8 75 7c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cbcb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011cbce:	83 ec 0c             	sub    $0xc,%esp
f011cbd1:	68 00 00 30 00       	push   $0x300000
f011cbd6:	e8 db be fe ff       	call   f0108ab6 <kmalloc>
f011cbdb:	83 c4 10             	add    $0x10,%esp
f011cbde:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cbe4:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011cbea:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011cbef:	74 17                	je     f011cc08 <test_kfree_bestfirstfit+0xa31>
f011cbf1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cbf8:	83 ec 0c             	sub    $0xc,%esp
f011cbfb:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011cc00:	e8 67 43 fe ff       	call   f0100f6c <cprintf>
f011cc05:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cc08:	e8 33 7c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cc0d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cc10:	74 17                	je     f011cc29 <test_kfree_bestfirstfit+0xa52>
f011cc12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cc19:	83 ec 0c             	sub    $0xc,%esp
f011cc1c:	68 40 e7 12 f0       	push   $0xf012e740
f011cc21:	e8 46 43 fe ff       	call   f0100f6c <cprintf>
f011cc26:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cc29:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011cc2c:	e8 d8 0d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cc31:	29 c3                	sub    %eax,%ebx
f011cc33:	89 d8                	mov    %ebx,%eax
f011cc35:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011cc3a:	77 17                	ja     f011cc53 <test_kfree_bestfirstfit+0xa7c>
f011cc3c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cc43:	83 ec 0c             	sub    $0xc,%esp
f011cc46:	68 ac e7 12 f0       	push   $0xf012e7ac
f011cc4b:	e8 1c 43 fe ff       	call   f0100f6c <cprintf>
f011cc50:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011cc53:	c7 45 88 ff ff 2f 00 	movl   $0x2fffff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[8];
f011cc5a:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011cc60:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011cc63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cc6a:	eb 0e                	jmp    f011cc7a <test_kfree_bestfirstfit+0xaa3>
		{
			ptr[i] = 8 ;
f011cc6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cc6f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cc72:	01 d0                	add    %edx,%eax
f011cc74:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011cc77:	ff 45 f4             	incl   -0xc(%ebp)
f011cc7a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cc7d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cc80:	7f ea                	jg     f011cc6c <test_kfree_bestfirstfit+0xa95>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011cc82:	e8 82 0d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cc87:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cc8a:	e8 b1 7b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cc8f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011cc92:	83 ec 0c             	sub    $0xc,%esp
f011cc95:	68 00 00 10 00       	push   $0x100000
f011cc9a:	e8 17 be fe ff       	call   f0108ab6 <kmalloc>
f011cc9f:	83 c4 10             	add    $0x10,%esp
f011cca2:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cca8:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ccae:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011ccb3:	74 17                	je     f011cccc <test_kfree_bestfirstfit+0xaf5>
f011ccb5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ccbc:	83 ec 0c             	sub    $0xc,%esp
f011ccbf:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011ccc4:	e8 a3 42 fe ff       	call   f0100f6c <cprintf>
f011ccc9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cccc:	e8 6f 7b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ccd1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ccd4:	74 17                	je     f011cced <test_kfree_bestfirstfit+0xb16>
f011ccd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ccdd:	83 ec 0c             	sub    $0xc,%esp
f011cce0:	68 40 e7 12 f0       	push   $0xf012e740
f011cce5:	e8 82 42 fe ff       	call   f0100f6c <cprintf>
f011ccea:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cced:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ccf0:	e8 14 0d ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ccf5:	29 c3                	sub    %eax,%ebx
f011ccf7:	89 d8                	mov    %ebx,%eax
f011ccf9:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ccfe:	77 17                	ja     f011cd17 <test_kfree_bestfirstfit+0xb40>
f011cd00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cd07:	83 ec 0c             	sub    $0xc,%esp
f011cd0a:	68 ac e7 12 f0       	push   $0xf012e7ac
f011cd0f:	e8 58 42 fe ff       	call   f0100f6c <cprintf>
f011cd14:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011cd17:	c7 45 90 ff ff 0f 00 	movl   $0xfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011cd1e:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011cd24:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011cd27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cd2e:	eb 0e                	jmp    f011cd3e <test_kfree_bestfirstfit+0xb67>
		{
			ptr[i] = 10 ;
f011cd30:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cd33:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cd36:	01 d0                	add    %edx,%eax
f011cd38:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011cd3b:	ff 45 f4             	incl   -0xc(%ebp)
f011cd3e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cd41:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cd44:	7f ea                	jg     f011cd30 <test_kfree_bestfirstfit+0xb59>
		{
			ptr[i] = 10 ;
		}

		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011cd46:	e8 be 0c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cd4b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cd4e:	e8 ed 7a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cd53:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011cd56:	83 ec 0c             	sub    $0xc,%esp
f011cd59:	68 00 04 00 00       	push   $0x400
f011cd5e:	e8 53 bd fe ff       	call   f0108ab6 <kmalloc>
f011cd63:	83 c4 10             	add    $0x10,%esp
f011cd66:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((ptr_allocations[9] < ptr_allocations[2]) || (ptr_allocations[9] > (ptr_allocations[2] + 1*kilo)))
f011cd6c:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
f011cd72:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011cd78:	39 c2                	cmp    %eax,%edx
f011cd7a:	72 16                	jb     f011cd92 <test_kfree_bestfirstfit+0xbbb>
f011cd7c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011cd82:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011cd88:	81 c2 00 04 00 00    	add    $0x400,%edx
f011cd8e:	39 d0                	cmp    %edx,%eax
f011cd90:	76 17                	jbe    f011cda9 <test_kfree_bestfirstfit+0xbd2>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cd92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cd99:	83 ec 0c             	sub    $0xc,%esp
f011cd9c:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011cda1:	e8 c6 41 fe ff       	call   f0100f6c <cprintf>
f011cda6:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cda9:	e8 92 7a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cdae:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cdb1:	74 17                	je     f011cdca <test_kfree_bestfirstfit+0xbf3>
f011cdb3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cdba:	83 ec 0c             	sub    $0xc,%esp
f011cdbd:	68 40 e7 12 f0       	push   $0xf012e740
f011cdc2:	e8 a5 41 fe ff       	call   f0100f6c <cprintf>
f011cdc7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011cdca:	e8 3a 0c ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cdcf:	89 c2                	mov    %eax,%edx
f011cdd1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cdd4:	39 c2                	cmp    %eax,%edx
f011cdd6:	74 17                	je     f011cdef <test_kfree_bestfirstfit+0xc18>
f011cdd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cddf:	83 ec 0c             	sub    $0xc,%esp
f011cde2:	68 b0 eb 12 f0       	push   $0xf012ebb0
f011cde7:	e8 80 41 fe ff       	call   f0100f6c <cprintf>
f011cdec:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011cdef:	c7 45 8c ff 03 00 00 	movl   $0x3ff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[9];
f011cdf6:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011cdfc:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011cdff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ce06:	eb 0e                	jmp    f011ce16 <test_kfree_bestfirstfit+0xc3f>
		{
			ptr[i] = 9 ;
f011ce08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ce0b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ce0e:	01 d0                	add    %edx,%eax
f011ce10:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011ce13:	ff 45 f4             	incl   -0xc(%ebp)
f011ce16:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ce19:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ce1c:	7f ea                	jg     f011ce08 <test_kfree_bestfirstfit+0xc31>
		{
			ptr[i] = 9 ;
		}

	}
	if (correct)	eval+=15 ;
f011ce1e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ce22:	74 04                	je     f011ce28 <test_kfree_bestfirstfit+0xc51>
f011ce24:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011ce28:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	{
		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
		freeFrames = sys_calculate_free_frames() ;
f011ce2f:	e8 d5 0b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ce34:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce37:	e8 04 7a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ce3c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[5]);
f011ce3f:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011ce45:	83 ec 0c             	sub    $0xc,%esp
f011ce48:	50                   	push   %eax
f011ce49:	e8 82 bc fe ff       	call   f0108ad0 <kfree>
f011ce4e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce51:	e8 ea 79 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ce56:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ce59:	74 17                	je     f011ce72 <test_kfree_bestfirstfit+0xc9b>
f011ce5b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ce62:	83 ec 0c             	sub    $0xc,%esp
f011ce65:	68 40 e7 12 f0       	push   $0xf012e740
f011ce6a:	e8 fd 40 fe ff       	call   f0100f6c <cprintf>
f011ce6f:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ce72:	e8 92 0b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011ce77:	89 c2                	mov    %eax,%edx
f011ce79:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ce7c:	29 c2                	sub    %eax,%edx
f011ce7e:	89 d0                	mov    %edx,%eax
f011ce80:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ce85:	77 17                	ja     f011ce9e <test_kfree_bestfirstfit+0xcc7>
f011ce87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ce8e:	83 ec 0c             	sub    $0xc,%esp
f011ce91:	68 44 eb 12 f0       	push   $0xf012eb44
f011ce96:	e8 d1 40 fe ff       	call   f0100f6c <cprintf>
f011ce9b:	83 c4 10             	add    $0x10,%esp

		//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
		freeFrames = sys_calculate_free_frames() ;
f011ce9e:	e8 66 0b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cea3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cea6:	e8 95 79 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ceab:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[4]);
f011ceae:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011ceb4:	83 ec 0c             	sub    $0xc,%esp
f011ceb7:	50                   	push   %eax
f011ceb8:	e8 13 bc fe ff       	call   f0108ad0 <kfree>
f011cebd:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cec0:	e8 7b 79 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cec5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cec8:	74 17                	je     f011cee1 <test_kfree_bestfirstfit+0xd0a>
f011ceca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ced1:	83 ec 0c             	sub    $0xc,%esp
f011ced4:	68 40 e7 12 f0       	push   $0xf012e740
f011ced9:	e8 8e 40 fe ff       	call   f0100f6c <cprintf>
f011cede:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cee1:	e8 23 0b ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cee6:	89 c2                	mov    %eax,%edx
f011cee8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ceeb:	29 c2                	sub    %eax,%edx
f011ceed:	89 d0                	mov    %edx,%eax
f011ceef:	83 f8 01             	cmp    $0x1,%eax
f011cef2:	77 17                	ja     f011cf0b <test_kfree_bestfirstfit+0xd34>
f011cef4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cefb:	83 ec 0c             	sub    $0xc,%esp
f011cefe:	68 44 eb 12 f0       	push   $0xf012eb44
f011cf03:	e8 64 40 fe ff       	call   f0100f6c <cprintf>
f011cf08:	83 c4 10             	add    $0x10,%esp

		//kfree 1 KB [DYNAMIC ALLOCATOR]
		freeFrames = sys_calculate_free_frames() ;
f011cf0b:	e8 f9 0a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cf10:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cf13:	e8 28 79 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cf18:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[9]);
f011cf1b:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011cf21:	83 ec 0c             	sub    $0xc,%esp
f011cf24:	50                   	push   %eax
f011cf25:	e8 a6 bb fe ff       	call   f0108ad0 <kfree>
f011cf2a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf2d:	e8 0e 79 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cf32:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cf35:	74 17                	je     f011cf4e <test_kfree_bestfirstfit+0xd77>
f011cf37:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cf3e:	83 ec 0c             	sub    $0xc,%esp
f011cf41:	68 40 e7 12 f0       	push   $0xf012e740
f011cf46:	e8 21 40 fe ff       	call   f0100f6c <cprintf>
f011cf4b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cf4e:	e8 b6 0a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cf53:	89 c2                	mov    %eax,%edx
f011cf55:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cf58:	39 c2                	cmp    %eax,%edx
f011cf5a:	74 17                	je     f011cf73 <test_kfree_bestfirstfit+0xd9c>
f011cf5c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cf63:	83 ec 0c             	sub    $0xc,%esp
f011cf66:	68 44 eb 12 f0       	push   $0xf012eb44
f011cf6b:	e8 fc 3f fe ff       	call   f0100f6c <cprintf>
f011cf70:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
		freeFrames = sys_calculate_free_frames() ;
f011cf73:	e8 91 0a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cf78:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cf7b:	e8 c0 78 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cf80:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[3]);
f011cf83:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011cf89:	83 ec 0c             	sub    $0xc,%esp
f011cf8c:	50                   	push   %eax
f011cf8d:	e8 3e bb fe ff       	call   f0108ad0 <kfree>
f011cf92:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf95:	e8 a6 78 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cf9a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cf9d:	74 17                	je     f011cfb6 <test_kfree_bestfirstfit+0xddf>
f011cf9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cfa6:	83 ec 0c             	sub    $0xc,%esp
f011cfa9:	68 40 e7 12 f0       	push   $0xf012e740
f011cfae:	e8 b9 3f fe ff       	call   f0100f6c <cprintf>
f011cfb3:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011cfb6:	e8 4e 0a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cfbb:	89 c2                	mov    %eax,%edx
f011cfbd:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cfc0:	39 c2                	cmp    %eax,%edx
f011cfc2:	74 17                	je     f011cfdb <test_kfree_bestfirstfit+0xe04>
f011cfc4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cfcb:	83 ec 0c             	sub    $0xc,%esp
f011cfce:	68 4c ea 12 f0       	push   $0xf012ea4c
f011cfd3:	e8 94 3f fe ff       	call   f0100f6c <cprintf>
f011cfd8:	83 c4 10             	add    $0x10,%esp

		//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
		freeFrames = sys_calculate_free_frames() ;
f011cfdb:	e8 29 0a ff ff       	call   f010da09 <sys_calculate_free_frames>
f011cfe0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cfe3:	e8 58 78 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011cfe8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[7]);
f011cfeb:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011cff1:	83 ec 0c             	sub    $0xc,%esp
f011cff4:	50                   	push   %eax
f011cff5:	e8 d6 ba fe ff       	call   f0108ad0 <kfree>
f011cffa:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cffd:	e8 3e 78 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d002:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d005:	74 17                	je     f011d01e <test_kfree_bestfirstfit+0xe47>
f011d007:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d00e:	83 ec 0c             	sub    $0xc,%esp
f011d011:	68 40 e7 12 f0       	push   $0xf012e740
f011d016:	e8 51 3f fe ff       	call   f0100f6c <cprintf>
f011d01b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011d01e:	e8 e6 09 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d023:	89 c2                	mov    %eax,%edx
f011d025:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d028:	29 c2                	sub    %eax,%edx
f011d02a:	89 d0                	mov    %edx,%eax
f011d02c:	83 f8 03             	cmp    $0x3,%eax
f011d02f:	77 17                	ja     f011d048 <test_kfree_bestfirstfit+0xe71>
f011d031:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d038:	83 ec 0c             	sub    $0xc,%esp
f011d03b:	68 44 eb 12 f0       	push   $0xf012eb44
f011d040:	e8 27 3f fe ff       	call   f0100f6c <cprintf>
f011d045:	83 c4 10             	add    $0x10,%esp

		//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
		freeFrames = sys_calculate_free_frames() ;
f011d048:	e8 bc 09 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d04d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d050:	e8 eb 77 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d055:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[10]);
f011d058:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d05e:	83 ec 0c             	sub    $0xc,%esp
f011d061:	50                   	push   %eax
f011d062:	e8 69 ba fe ff       	call   f0108ad0 <kfree>
f011d067:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d06a:	e8 d1 77 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d06f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d072:	74 17                	je     f011d08b <test_kfree_bestfirstfit+0xeb4>
f011d074:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d07b:	83 ec 0c             	sub    $0xc,%esp
f011d07e:	68 40 e7 12 f0       	push   $0xf012e740
f011d083:	e8 e4 3e fe ff       	call   f0100f6c <cprintf>
f011d088:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011d08b:	e8 79 09 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d090:	89 c2                	mov    %eax,%edx
f011d092:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d095:	29 c2                	sub    %eax,%edx
f011d097:	89 d0                	mov    %edx,%eax
f011d099:	3d ff 00 00 00       	cmp    $0xff,%eax
f011d09e:	77 17                	ja     f011d0b7 <test_kfree_bestfirstfit+0xee0>
f011d0a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d0a7:	83 ec 0c             	sub    $0xc,%esp
f011d0aa:	68 44 eb 12 f0       	push   $0xf012eb44
f011d0af:	e8 b8 3e fe ff       	call   f0100f6c <cprintf>
f011d0b4:	83 c4 10             	add    $0x10,%esp

		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
		freeFrames = sys_calculate_free_frames() ;
f011d0b7:	e8 4d 09 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d0bc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d0bf:	e8 7c 77 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d0c4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[8]);
f011d0c7:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011d0cd:	83 ec 0c             	sub    $0xc,%esp
f011d0d0:	50                   	push   %eax
f011d0d1:	e8 fa b9 fe ff       	call   f0108ad0 <kfree>
f011d0d6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d0d9:	e8 62 77 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d0de:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d0e1:	74 17                	je     f011d0fa <test_kfree_bestfirstfit+0xf23>
f011d0e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d0ea:	83 ec 0c             	sub    $0xc,%esp
f011d0ed:	68 40 e7 12 f0       	push   $0xf012e740
f011d0f2:	e8 75 3e fe ff       	call   f0100f6c <cprintf>
f011d0f7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011d0fa:	e8 0a 09 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d0ff:	89 c2                	mov    %eax,%edx
f011d101:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d104:	29 c2                	sub    %eax,%edx
f011d106:	89 d0                	mov    %edx,%eax
f011d108:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011d10d:	77 17                	ja     f011d126 <test_kfree_bestfirstfit+0xf4f>
f011d10f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d116:	83 ec 0c             	sub    $0xc,%esp
f011d119:	68 44 eb 12 f0       	push   $0xf012eb44
f011d11e:	e8 49 3e fe ff       	call   f0100f6c <cprintf>
f011d123:	83 c4 10             	add    $0x10,%esp

		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011d126:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d12a:	74 04                	je     f011d130 <test_kfree_bestfirstfit+0xf59>
f011d12c:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011d130:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [15%]
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011d137:	83 ec 0c             	sub    $0xc,%esp
f011d13a:	6a 03                	push   $0x3
f011d13c:	e8 df 0c ff ff       	call   f010de20 <sys_bypassPageFault>
f011d141:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011d144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d14b:	e9 af 00 00 00       	jmp    f011d1ff <test_kfree_bestfirstfit+0x1028>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011d150:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011d154:	0f 84 a1 00 00 00    	je     f011d1fb <test_kfree_bestfirstfit+0x1024>
f011d15a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011d15e:	0f 84 97 00 00 00    	je     f011d1fb <test_kfree_bestfirstfit+0x1024>
f011d164:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011d168:	0f 84 8d 00 00 00    	je     f011d1fb <test_kfree_bestfirstfit+0x1024>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011d16e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d171:	8b 84 85 c8 fe ff ff 	mov    -0x138(%ebp,%eax,4),%eax
f011d178:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011d17b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d17e:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011d181:	e8 88 0c ff ff       	call   f010de0e <sys_rcr2>
f011d186:	89 c2                	mov    %eax,%edx
f011d188:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d18b:	39 c2                	cmp    %eax,%edx
f011d18d:	74 1d                	je     f011d1ac <test_kfree_bestfirstfit+0xfd5>
				if (correct)
f011d18f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d193:	74 17                	je     f011d1ac <test_kfree_bestfirstfit+0xfd5>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011d195:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d19c:	83 ec 0c             	sub    $0xc,%esp
f011d19f:	68 28 ec 12 f0       	push   $0xf012ec28
f011d1a4:	e8 c3 3d fe ff       	call   f0100f6c <cprintf>
f011d1a9:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011d1ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d1af:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011d1b6:	89 c2                	mov    %eax,%edx
f011d1b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d1bb:	01 d0                	add    %edx,%eax
f011d1bd:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011d1c0:	e8 49 0c ff ff       	call   f010de0e <sys_rcr2>
f011d1c5:	89 c2                	mov    %eax,%edx
f011d1c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d1ca:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011d1d1:	89 c1                	mov    %eax,%ecx
f011d1d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d1d6:	01 c8                	add    %ecx,%eax
f011d1d8:	39 c2                	cmp    %eax,%edx
f011d1da:	74 20                	je     f011d1fc <test_kfree_bestfirstfit+0x1025>
				if (correct)
f011d1dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d1e0:	74 1a                	je     f011d1fc <test_kfree_bestfirstfit+0x1025>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011d1e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d1e9:	83 ec 0c             	sub    $0xc,%esp
f011d1ec:	68 28 ec 12 f0       	push   $0xf012ec28
f011d1f1:	e8 76 3d fe ff       	call   f0100f6c <cprintf>
f011d1f6:	83 c4 10             	add    $0x10,%esp
f011d1f9:	eb 01                	jmp    f011d1fc <test_kfree_bestfirstfit+0x1025>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011d1fb:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011d1fc:	ff 45 f4             	incl   -0xc(%ebp)
f011d1ff:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011d203:	0f 8e 47 ff ff ff    	jle    f011d150 <test_kfree_bestfirstfit+0xf79>
				if (correct)
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011d209:	83 ec 0c             	sub    $0xc,%esp
f011d20c:	6a 00                	push   $0x0
f011d20e:	e8 0d 0c ff ff       	call   f010de20 <sys_bypassPageFault>
f011d213:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011d216:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d21a:	74 04                	je     f011d220 <test_kfree_bestfirstfit+0x1049>
f011d21c:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011d220:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	//Allocate after kfree ALL [30%]
	{
		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1 KB
		freeFrames = sys_calculate_free_frames() ;
f011d227:	e8 dd 07 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d22c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d22f:	e8 0c 76 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d234:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011d237:	83 ec 0c             	sub    $0xc,%esp
f011d23a:	68 00 04 00 00       	push   $0x400
f011d23f:	e8 72 b8 fe ff       	call   f0108ab6 <kmalloc>
f011d244:	83 c4 10             	add    $0x10,%esp
f011d247:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011d24d:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
f011d253:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011d259:	39 c2                	cmp    %eax,%edx
f011d25b:	72 16                	jb     f011d273 <test_kfree_bestfirstfit+0x109c>
f011d25d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d263:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d269:	81 c2 00 04 00 00    	add    $0x400,%edx
f011d26f:	39 d0                	cmp    %edx,%eax
f011d271:	76 17                	jbe    f011d28a <test_kfree_bestfirstfit+0x10b3>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d273:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d27a:	83 ec 0c             	sub    $0xc,%esp
f011d27d:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011d282:	e8 e5 3c fe ff       	call   f0100f6c <cprintf>
f011d287:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d28a:	e8 b1 75 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d28f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d292:	74 17                	je     f011d2ab <test_kfree_bestfirstfit+0x10d4>
f011d294:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d29b:	83 ec 0c             	sub    $0xc,%esp
f011d29e:	68 40 e7 12 f0       	push   $0xf012e740
f011d2a3:	e8 c4 3c fe ff       	call   f0100f6c <cprintf>
f011d2a8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011d2ab:	e8 59 07 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d2b0:	89 c2                	mov    %eax,%edx
f011d2b2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d2b5:	39 c2                	cmp    %eax,%edx
f011d2b7:	74 17                	je     f011d2d0 <test_kfree_bestfirstfit+0x10f9>
f011d2b9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d2c0:	83 ec 0c             	sub    $0xc,%esp
f011d2c3:	68 b0 eb 12 f0       	push   $0xf012ebb0
f011d2c8:	e8 9f 3c fe ff       	call   f0100f6c <cprintf>
f011d2cd:	83 c4 10             	add    $0x10,%esp
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011d2d0:	c7 45 94 ff 03 00 00 	movl   $0x3ff,-0x6c(%ebp)
		ptr = (char*)ptr_allocations[11];
f011d2d7:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d2dd:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011d2e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d2e7:	eb 0e                	jmp    f011d2f7 <test_kfree_bestfirstfit+0x1120>
		{
			ptr[i] = 11 ;
f011d2e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d2ec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d2ef:	01 d0                	add    %edx,%eax
f011d2f1:	c6 00 0b             	movb   $0xb,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011d2f4:	ff 45 f4             	incl   -0xc(%ebp)
f011d2f7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d2fa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d2fd:	7f ea                	jg     f011d2e9 <test_kfree_bestfirstfit+0x1112>
			ptr[i] = 11 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f011d2ff:	e8 05 07 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d304:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d307:	e8 34 75 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d30c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[12] = kmalloc(2*kilo);
f011d30f:	83 ec 0c             	sub    $0xc,%esp
f011d312:	68 00 08 00 00       	push   $0x800
f011d317:	e8 9a b7 fe ff       	call   f0108ab6 <kmalloc>
f011d31c:	83 c4 10             	add    $0x10,%esp
f011d31f:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
		//expected = ptr_allocations[2] + 1*kilo + sizeOfMetaData();
		//if (ptr_allocations[12] != expected)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011d325:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d32b:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d331:	81 c2 00 04 00 00    	add    $0x400,%edx
f011d337:	39 d0                	cmp    %edx,%eax
f011d339:	72 16                	jb     f011d351 <test_kfree_bestfirstfit+0x117a>
f011d33b:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d341:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d347:	81 c2 00 08 00 00    	add    $0x800,%edx
f011d34d:	39 d0                	cmp    %edx,%eax
f011d34f:	76 35                	jbe    f011d386 <test_kfree_bestfirstfit+0x11af>
		{
			correct = 0;
f011d351:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			cprintf("Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011d358:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d35e:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d364:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011d36a:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d370:	81 c2 00 04 00 00    	add    $0x400,%edx
f011d376:	50                   	push   %eax
f011d377:	51                   	push   %ecx
f011d378:	52                   	push   %edx
f011d379:	68 70 ec 12 f0       	push   $0xf012ec70
f011d37e:	e8 e9 3b fe ff       	call   f0100f6c <cprintf>
f011d383:	83 c4 10             	add    $0x10,%esp
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d386:	e8 b5 74 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d38b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d38e:	74 17                	je     f011d3a7 <test_kfree_bestfirstfit+0x11d0>
f011d390:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d397:	83 ec 0c             	sub    $0xc,%esp
f011d39a:	68 40 e7 12 f0       	push   $0xf012e740
f011d39f:	e8 c8 3b fe ff       	call   f0100f6c <cprintf>
f011d3a4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011d3a7:	e8 5d 06 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d3ac:	89 c2                	mov    %eax,%edx
f011d3ae:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d3b1:	39 c2                	cmp    %eax,%edx
f011d3b3:	74 17                	je     f011d3cc <test_kfree_bestfirstfit+0x11f5>
f011d3b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d3bc:	83 ec 0c             	sub    $0xc,%esp
f011d3bf:	68 b0 eb 12 f0       	push   $0xf012ebb0
f011d3c4:	e8 a3 3b fe ff       	call   f0100f6c <cprintf>
f011d3c9:	83 c4 10             	add    $0x10,%esp
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011d3cc:	c7 45 98 ff 07 00 00 	movl   $0x7ff,-0x68(%ebp)
		ptr = (char*)ptr_allocations[12];
f011d3d3:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d3d9:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011d3dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d3e3:	eb 0e                	jmp    f011d3f3 <test_kfree_bestfirstfit+0x121c>
		{
			ptr[i] = 12 ;
f011d3e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d3e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d3eb:	01 d0                	add    %edx,%eax
f011d3ed:	c6 00 0c             	movb   $0xc,(%eax)
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011d3f0:	ff 45 f4             	incl   -0xc(%ebp)
f011d3f3:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d3f6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d3f9:	7f ea                	jg     f011d3e5 <test_kfree_bestfirstfit+0x120e>
			ptr[i] = 12 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1.5 KB
		freeFrames = sys_calculate_free_frames() ;
f011d3fb:	e8 09 06 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d400:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d403:	e8 38 74 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d408:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[13] = kmalloc(3*kilo/2);
f011d40b:	83 ec 0c             	sub    $0xc,%esp
f011d40e:	68 00 06 00 00       	push   $0x600
f011d413:	e8 9e b6 fe ff       	call   f0108ab6 <kmalloc>
f011d418:	83 c4 10             	add    $0x10,%esp
f011d41b:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
		//if (ptr_allocations[13] != ptr_allocations[12] + 2*kilo + sizeOfMetaData())
		if ((ptr_allocations[13] < ptr_allocations[2] + 3*kilo) || (ptr_allocations[13] > (ptr_allocations[2] + 4*kilo)))
f011d421:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d427:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d42d:	81 c2 00 0c 00 00    	add    $0xc00,%edx
f011d433:	39 d0                	cmp    %edx,%eax
f011d435:	72 16                	jb     f011d44d <test_kfree_bestfirstfit+0x1276>
f011d437:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d43d:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d443:	81 c2 00 10 00 00    	add    $0x1000,%edx
f011d449:	39 d0                	cmp    %edx,%eax
f011d44b:	76 17                	jbe    f011d464 <test_kfree_bestfirstfit+0x128d>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d44d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d454:	83 ec 0c             	sub    $0xc,%esp
f011d457:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011d45c:	e8 0b 3b fe ff       	call   f0100f6c <cprintf>
f011d461:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d464:	e8 d7 73 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d469:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d46c:	74 17                	je     f011d485 <test_kfree_bestfirstfit+0x12ae>
f011d46e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d475:	83 ec 0c             	sub    $0xc,%esp
f011d478:	68 40 e7 12 f0       	push   $0xf012e740
f011d47d:	e8 ea 3a fe ff       	call   f0100f6c <cprintf>
f011d482:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011d485:	e8 7f 05 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d48a:	89 c2                	mov    %eax,%edx
f011d48c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d48f:	39 c2                	cmp    %eax,%edx
f011d491:	74 17                	je     f011d4aa <test_kfree_bestfirstfit+0x12d3>
f011d493:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d49a:	83 ec 0c             	sub    $0xc,%esp
f011d49d:	68 b0 eb 12 f0       	push   $0xf012ebb0
f011d4a2:	e8 c5 3a fe ff       	call   f0100f6c <cprintf>
f011d4a7:	83 c4 10             	add    $0x10,%esp
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011d4aa:	c7 45 9c ff 05 00 00 	movl   $0x5ff,-0x64(%ebp)
		ptr = (char*)ptr_allocations[13];
f011d4b1:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d4b7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011d4ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d4c1:	eb 0e                	jmp    f011d4d1 <test_kfree_bestfirstfit+0x12fa>
		{
			ptr[i] = 13 ;
f011d4c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d4c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d4c9:	01 d0                	add    %edx,%eax
f011d4cb:	c6 00 0d             	movb   $0xd,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011d4ce:	ff 45 f4             	incl   -0xc(%ebp)
f011d4d1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011d4d4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d4d7:	7f ea                	jg     f011d4c3 <test_kfree_bestfirstfit+0x12ec>
			ptr[i] = 13 ;
		}

		//[PAGE ALLOCATOR] Allocate in merged freed space
		//30 MB
		freeFrames = sys_calculate_free_frames() ;
f011d4d9:	e8 2b 05 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d4de:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d4e1:	e8 5a 73 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d4e6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(30*Mega);
f011d4e9:	83 ec 0c             	sub    $0xc,%esp
f011d4ec:	68 00 00 e0 01       	push   $0x1e00000
f011d4f1:	e8 c0 b5 fe ff       	call   f0108ab6 <kmalloc>
f011d4f6:	83 c4 10             	add    $0x10,%esp
f011d4f9:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d4ff:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d505:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011d50a:	74 17                	je     f011d523 <test_kfree_bestfirstfit+0x134c>
f011d50c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d513:	83 ec 0c             	sub    $0xc,%esp
f011d516:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011d51b:	e8 4c 3a fe ff       	call   f0100f6c <cprintf>
f011d520:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d523:	e8 18 73 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d528:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d52b:	74 17                	je     f011d544 <test_kfree_bestfirstfit+0x136d>
f011d52d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d534:	83 ec 0c             	sub    $0xc,%esp
f011d537:	68 40 e7 12 f0       	push   $0xf012e740
f011d53c:	e8 2b 3a fe ff       	call   f0100f6c <cprintf>
f011d541:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011d544:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011d547:	e8 bd 04 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d54c:	29 c3                	sub    %eax,%ebx
f011d54e:	89 d8                	mov    %ebx,%eax
f011d550:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011d555:	77 17                	ja     f011d56e <test_kfree_bestfirstfit+0x1397>
f011d557:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d55e:	83 ec 0c             	sub    $0xc,%esp
f011d561:	68 ac e7 12 f0       	push   $0xf012e7ac
f011d566:	e8 01 3a fe ff       	call   f0100f6c <cprintf>
f011d56b:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011d56e:	c7 45 90 ff ff df 01 	movl   $0x1dfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011d575:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d57b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011d57e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d585:	eb 0e                	jmp    f011d595 <test_kfree_bestfirstfit+0x13be>
		{
			ptr[i] = 10 ;
f011d587:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d58a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d58d:	01 d0                	add    %edx,%eax
f011d58f:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011d592:	ff 45 f4             	incl   -0xc(%ebp)
f011d595:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d598:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d59b:	7f ea                	jg     f011d587 <test_kfree_bestfirstfit+0x13b0>
			ptr[i] = 10 ;
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
f011d59d:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d5a3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011d5a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d5ad:	eb 1e                	jmp    f011d5cd <test_kfree_bestfirstfit+0x13f6>
		{
			sums[10] += ptr[i] ;
f011d5af:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011d5b5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d5b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d5bb:	01 c8                	add    %ecx,%eax
f011d5bd:	8a 00                	mov    (%eax),%al
f011d5bf:	0f be c0             	movsbl %al,%eax
f011d5c2:	01 d0                	add    %edx,%eax
f011d5c4:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011d5ca:	ff 45 f4             	incl   -0xc(%ebp)
f011d5cd:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d5d0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d5d3:	7f da                	jg     f011d5af <test_kfree_bestfirstfit+0x13d8>
		{
			sums[10] += ptr[i] ;
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d5d5:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011d5db:	8b 55 90             	mov    -0x70(%ebp),%edx
f011d5de:	89 d0                	mov    %edx,%eax
f011d5e0:	c1 e0 02             	shl    $0x2,%eax
f011d5e3:	01 d0                	add    %edx,%eax
f011d5e5:	01 c0                	add    %eax,%eax
f011d5e7:	39 c1                	cmp    %eax,%ecx
f011d5e9:	74 17                	je     f011d602 <test_kfree_bestfirstfit+0x142b>
f011d5eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d5f2:	83 ec 0c             	sub    $0xc,%esp
f011d5f5:	68 e0 ec 12 f0       	push   $0xf012ece0
f011d5fa:	e8 6d 39 fe ff       	call   f0100f6c <cprintf>
f011d5ff:	83 c4 10             	add    $0x10,%esp

		//1 KB
		ptr = (char*)ptr_allocations[11];
f011d602:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d608:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011d60b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d612:	eb 1e                	jmp    f011d632 <test_kfree_bestfirstfit+0x145b>
		{
			sums[11] += ptr[i] ;
f011d614:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011d61a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d61d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d620:	01 c8                	add    %ecx,%eax
f011d622:	8a 00                	mov    (%eax),%al
f011d624:	0f be c0             	movsbl %al,%eax
f011d627:	01 d0                	add    %edx,%eax
f011d629:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1 KB
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011d62f:	ff 45 f4             	incl   -0xc(%ebp)
f011d632:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d635:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d638:	7f da                	jg     f011d614 <test_kfree_bestfirstfit+0x143d>
		{
			sums[11] += ptr[i] ;
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d63a:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011d640:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011d643:	89 d0                	mov    %edx,%eax
f011d645:	c1 e0 02             	shl    $0x2,%eax
f011d648:	01 d0                	add    %edx,%eax
f011d64a:	01 c0                	add    %eax,%eax
f011d64c:	01 d0                	add    %edx,%eax
f011d64e:	39 c1                	cmp    %eax,%ecx
f011d650:	74 17                	je     f011d669 <test_kfree_bestfirstfit+0x1492>
f011d652:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d659:	83 ec 0c             	sub    $0xc,%esp
f011d65c:	68 e0 ec 12 f0       	push   $0xf012ece0
f011d661:	e8 06 39 fe ff       	call   f0100f6c <cprintf>
f011d666:	83 c4 10             	add    $0x10,%esp

		//2 KB
		ptr = (char*)ptr_allocations[12];
f011d669:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d66f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011d672:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d679:	eb 1e                	jmp    f011d699 <test_kfree_bestfirstfit+0x14c2>
		{
			sums[12] += ptr[i] ;
f011d67b:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011d681:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d684:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d687:	01 c8                	add    %ecx,%eax
f011d689:	8a 00                	mov    (%eax),%al
f011d68b:	0f be c0             	movsbl %al,%eax
f011d68e:	01 d0                	add    %edx,%eax
f011d690:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//2 KB
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011d696:	ff 45 f4             	incl   -0xc(%ebp)
f011d699:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d69c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d69f:	7f da                	jg     f011d67b <test_kfree_bestfirstfit+0x14a4>
		{
			sums[12] += ptr[i] ;
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d6a1:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011d6a7:	8b 55 98             	mov    -0x68(%ebp),%edx
f011d6aa:	89 d0                	mov    %edx,%eax
f011d6ac:	01 c0                	add    %eax,%eax
f011d6ae:	01 d0                	add    %edx,%eax
f011d6b0:	c1 e0 02             	shl    $0x2,%eax
f011d6b3:	39 c1                	cmp    %eax,%ecx
f011d6b5:	74 17                	je     f011d6ce <test_kfree_bestfirstfit+0x14f7>
f011d6b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d6be:	83 ec 0c             	sub    $0xc,%esp
f011d6c1:	68 e0 ec 12 f0       	push   $0xf012ece0
f011d6c6:	e8 a1 38 fe ff       	call   f0100f6c <cprintf>
f011d6cb:	83 c4 10             	add    $0x10,%esp

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
f011d6ce:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d6d4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011d6d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d6de:	eb 1e                	jmp    f011d6fe <test_kfree_bestfirstfit+0x1527>
		{
			sums[13] += ptr[i] ;
f011d6e0:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f011d6e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d6e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d6ec:	01 c8                	add    %ecx,%eax
f011d6ee:	8a 00                	mov    (%eax),%al
f011d6f0:	0f be c0             	movsbl %al,%eax
f011d6f3:	01 d0                	add    %edx,%eax
f011d6f5:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011d6fb:	ff 45 f4             	incl   -0xc(%ebp)
f011d6fe:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011d701:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d704:	7f da                	jg     f011d6e0 <test_kfree_bestfirstfit+0x1509>
		{
			sums[13] += ptr[i] ;
		}
		if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d706:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f011d70c:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011d70f:	89 d0                	mov    %edx,%eax
f011d711:	01 c0                	add    %eax,%eax
f011d713:	01 d0                	add    %edx,%eax
f011d715:	c1 e0 02             	shl    $0x2,%eax
f011d718:	01 d0                	add    %edx,%eax
f011d71a:	39 c1                	cmp    %eax,%ecx
f011d71c:	74 17                	je     f011d735 <test_kfree_bestfirstfit+0x155e>
f011d71e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d725:	83 ec 0c             	sub    $0xc,%esp
f011d728:	68 e0 ec 12 f0       	push   $0xf012ece0
f011d72d:	e8 3a 38 fe ff       	call   f0100f6c <cprintf>
f011d732:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011d735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d739:	74 04                	je     f011d73f <test_kfree_bestfirstfit+0x1568>
f011d73b:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011d73f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011d746:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011d74d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d754:	eb 4e                	jmp    f011d7a4 <test_kfree_bestfirstfit+0x15cd>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011d756:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011d759:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011d75e:	83 ec 04             	sub    $0x4,%esp
f011d761:	8d 8d c4 fe ff ff    	lea    -0x13c(%ebp),%ecx
f011d767:	51                   	push   %ecx
f011d768:	52                   	push   %edx
f011d769:	50                   	push   %eax
f011d76a:	e8 9e ac fe ff       	call   f010840d <get_page_table>
f011d76f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011d772:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011d778:	85 c0                	test   %eax,%eax
f011d77a:	75 1d                	jne    f011d799 <test_kfree_bestfirstfit+0x15c2>
			{
				if (correct)
f011d77c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d780:	74 17                	je     f011d799 <test_kfree_bestfirstfit+0x15c2>
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011d782:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d789:	83 ec 0c             	sub    $0xc,%esp
f011d78c:	68 0c ed 12 f0       	push   $0xf012ed0c
f011d791:	e8 d6 37 fe ff       	call   f0100f6c <cprintf>
f011d796:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011d799:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011d7a0:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011d7a4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d7a8:	78 ac                	js     f011d756 <test_kfree_bestfirstfit+0x157f>
f011d7aa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d7ae:	7f 09                	jg     f011d7b9 <test_kfree_bestfirstfit+0x15e2>
f011d7b0:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011d7b7:	76 9d                	jbe    f011d756 <test_kfree_bestfirstfit+0x157f>
				if (correct)
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011d7b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d7bd:	74 04                	je     f011d7c3 <test_kfree_bestfirstfit+0x15ec>
f011d7bf:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011d7c3:	83 ec 08             	sub    $0x8,%esp
f011d7c6:	ff 75 f0             	pushl  -0x10(%ebp)
f011d7c9:	68 74 ed 12 f0       	push   $0xf012ed74
f011d7ce:	e8 99 37 fe ff       	call   f0100f6c <cprintf>
f011d7d3:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d7d6:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011d7db:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011d7de:	5b                   	pop    %ebx
f011d7df:	5f                   	pop    %edi
f011d7e0:	5d                   	pop    %ebp
f011d7e1:	c3                   	ret    

f011d7e2 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011d7e2:	55                   	push   %ebp
f011d7e3:	89 e5                	mov    %esp,%ebp
f011d7e5:	57                   	push   %edi
f011d7e6:	53                   	push   %ebx
f011d7e7:	81 ec b0 35 00 00    	sub    $0x35b0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011d7ed:	83 ec 0c             	sub    $0xc,%esp
f011d7f0:	68 80 e6 12 f0       	push   $0xf012e680
f011d7f5:	e8 72 37 fe ff       	call   f0100f6c <cprintf>
f011d7fa:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011d7fd:	83 ec 0c             	sub    $0xc,%esp
f011d800:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011d805:	e8 62 37 fe ff       	call   f0100f6c <cprintf>
f011d80a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011d80d:	83 ec 0c             	sub    $0xc,%esp
f011d810:	68 80 e6 12 f0       	push   $0xf012e680
f011d815:	e8 52 37 fe ff       	call   f0100f6c <cprintf>
f011d81a:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011d81d:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011d821:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011d825:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011d82b:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011d831:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011d838:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011d83f:	e8 c5 01 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d844:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011d847:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011d84d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d852:	b8 00 00 00 00       	mov    $0x0,%eax
f011d857:	89 d7                	mov    %edx,%edi
f011d859:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011d85b:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f011d861:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d866:	b8 00 00 00 00       	mov    $0x0,%eax
f011d86b:	89 d7                	mov    %edx,%edi
f011d86d:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011d86f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011d876:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011d87d:	8d 95 74 fe ff ff    	lea    -0x18c(%ebp),%edx
f011d883:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d888:	b8 00 00 00 00       	mov    $0x0,%eax
f011d88d:	89 d7                	mov    %edx,%edi
f011d88f:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011d891:	e8 73 01 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d896:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d899:	e8 a2 6f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d89e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011d8a1:	83 ec 0c             	sub    $0xc,%esp
f011d8a4:	68 00 fc 1f 00       	push   $0x1ffc00
f011d8a9:	e8 08 b2 fe ff       	call   f0108ab6 <kmalloc>
f011d8ae:	83 c4 10             	add    $0x10,%esp
f011d8b1:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d8b7:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011d8bd:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011d8c2:	74 17                	je     f011d8db <test_kheap_phys_addr+0xf9>
f011d8c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d8cb:	83 ec 0c             	sub    $0xc,%esp
f011d8ce:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011d8d3:	e8 94 36 fe ff       	call   f0100f6c <cprintf>
f011d8d8:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d8db:	e8 60 6f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d8e0:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d8e3:	74 17                	je     f011d8fc <test_kheap_phys_addr+0x11a>
f011d8e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d8ec:	83 ec 0c             	sub    $0xc,%esp
f011d8ef:	68 40 e7 12 f0       	push   $0xf012e740
f011d8f4:	e8 73 36 fe ff       	call   f0100f6c <cprintf>
f011d8f9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011d8fc:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011d8ff:	e8 05 01 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d904:	29 c3                	sub    %eax,%ebx
f011d906:	89 d8                	mov    %ebx,%eax
f011d908:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011d90d:	77 17                	ja     f011d926 <test_kheap_phys_addr+0x144>
f011d90f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d916:	83 ec 0c             	sub    $0xc,%esp
f011d919:	68 ac e7 12 f0       	push   $0xf012e7ac
f011d91e:	e8 49 36 fe ff       	call   f0100f6c <cprintf>
f011d923:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011d926:	e8 de 00 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d92b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d92e:	e8 0d 6f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d933:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011d936:	83 ec 0c             	sub    $0xc,%esp
f011d939:	68 00 fc 1f 00       	push   $0x1ffc00
f011d93e:	e8 73 b1 fe ff       	call   f0108ab6 <kmalloc>
f011d943:	83 c4 10             	add    $0x10,%esp
f011d946:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d94c:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011d952:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011d957:	74 17                	je     f011d970 <test_kheap_phys_addr+0x18e>
f011d959:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d960:	83 ec 0c             	sub    $0xc,%esp
f011d963:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011d968:	e8 ff 35 fe ff       	call   f0100f6c <cprintf>
f011d96d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d970:	e8 cb 6e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d975:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d978:	74 17                	je     f011d991 <test_kheap_phys_addr+0x1af>
f011d97a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d981:	83 ec 0c             	sub    $0xc,%esp
f011d984:	68 40 e7 12 f0       	push   $0xf012e740
f011d989:	e8 de 35 fe ff       	call   f0100f6c <cprintf>
f011d98e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011d991:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011d994:	e8 70 00 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d999:	29 c3                	sub    %eax,%ebx
f011d99b:	89 d8                	mov    %ebx,%eax
f011d99d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011d9a2:	77 17                	ja     f011d9bb <test_kheap_phys_addr+0x1d9>
f011d9a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d9ab:	83 ec 0c             	sub    $0xc,%esp
f011d9ae:	68 ac e7 12 f0       	push   $0xf012e7ac
f011d9b3:	e8 b4 35 fe ff       	call   f0100f6c <cprintf>
f011d9b8:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011d9bb:	e8 49 00 ff ff       	call   f010da09 <sys_calculate_free_frames>
f011d9c0:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011d9c3:	e8 78 6e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011d9c8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011d9cb:	83 ec 0c             	sub    $0xc,%esp
f011d9ce:	68 00 04 00 00       	push   $0x400
f011d9d3:	e8 de b0 fe ff       	call   f0108ab6 <kmalloc>
f011d9d8:	83 c4 10             	add    $0x10,%esp
f011d9db:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011d9e1:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011d9e7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011d9ec:	76 28                	jbe    f011da16 <test_kheap_phys_addr+0x234>
f011d9ee:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011d9f4:	83 ec 0c             	sub    $0xc,%esp
f011d9f7:	6a 00                	push   $0x0
f011d9f9:	e8 ae b0 fe ff       	call   f0108aac <sbrk>
f011d9fe:	83 c4 10             	add    $0x10,%esp
f011da01:	39 c3                	cmp    %eax,%ebx
f011da03:	73 11                	jae    f011da16 <test_kheap_phys_addr+0x234>
f011da05:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011da0b:	89 c2                	mov    %eax,%edx
f011da0d:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011da12:	39 c2                	cmp    %eax,%edx
f011da14:	72 17                	jb     f011da2d <test_kheap_phys_addr+0x24b>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011da16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da1d:	83 ec 0c             	sub    $0xc,%esp
f011da20:	68 40 e8 12 f0       	push   $0xf012e840
f011da25:	e8 42 35 fe ff       	call   f0100f6c <cprintf>
f011da2a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011da2d:	e8 0e 6e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011da32:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011da35:	74 17                	je     f011da4e <test_kheap_phys_addr+0x26c>
f011da37:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da3e:	83 ec 0c             	sub    $0xc,%esp
f011da41:	68 40 e7 12 f0       	push   $0xf012e740
f011da46:	e8 21 35 fe ff       	call   f0100f6c <cprintf>
f011da4b:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011da4e:	e8 b6 ff fe ff       	call   f010da09 <sys_calculate_free_frames>
f011da53:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011da56:	e8 e5 6d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011da5b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011da5e:	83 ec 0c             	sub    $0xc,%esp
f011da61:	68 00 08 00 00       	push   $0x800
f011da66:	e8 4b b0 fe ff       	call   f0108ab6 <kmalloc>
f011da6b:	83 c4 10             	add    $0x10,%esp
f011da6e:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011da74:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011da7a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011da7f:	76 28                	jbe    f011daa9 <test_kheap_phys_addr+0x2c7>
f011da81:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011da87:	83 ec 0c             	sub    $0xc,%esp
f011da8a:	6a 00                	push   $0x0
f011da8c:	e8 1b b0 fe ff       	call   f0108aac <sbrk>
f011da91:	83 c4 10             	add    $0x10,%esp
f011da94:	39 c3                	cmp    %eax,%ebx
f011da96:	73 11                	jae    f011daa9 <test_kheap_phys_addr+0x2c7>
f011da98:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011da9e:	89 c2                	mov    %eax,%edx
f011daa0:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011daa5:	39 c2                	cmp    %eax,%edx
f011daa7:	72 17                	jb     f011dac0 <test_kheap_phys_addr+0x2de>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011daa9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dab0:	83 ec 0c             	sub    $0xc,%esp
f011dab3:	68 40 e8 12 f0       	push   $0xf012e840
f011dab8:	e8 af 34 fe ff       	call   f0100f6c <cprintf>
f011dabd:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dac0:	e8 7b 6d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dac5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dac8:	74 17                	je     f011dae1 <test_kheap_phys_addr+0x2ff>
f011daca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dad1:	83 ec 0c             	sub    $0xc,%esp
f011dad4:	68 40 e7 12 f0       	push   $0xf012e740
f011dad9:	e8 8e 34 fe ff       	call   f0100f6c <cprintf>
f011dade:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011dae1:	e8 23 ff fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dae6:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011dae9:	e8 52 6d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011daee:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011daf1:	83 ec 0c             	sub    $0xc,%esp
f011daf4:	68 00 06 00 00       	push   $0x600
f011daf9:	e8 b8 af fe ff       	call   f0108ab6 <kmalloc>
f011dafe:	83 c4 10             	add    $0x10,%esp
f011db01:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011db07:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011db0d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011db12:	76 28                	jbe    f011db3c <test_kheap_phys_addr+0x35a>
f011db14:	8b 9d 84 fe ff ff    	mov    -0x17c(%ebp),%ebx
f011db1a:	83 ec 0c             	sub    $0xc,%esp
f011db1d:	6a 00                	push   $0x0
f011db1f:	e8 88 af fe ff       	call   f0108aac <sbrk>
f011db24:	83 c4 10             	add    $0x10,%esp
f011db27:	39 c3                	cmp    %eax,%ebx
f011db29:	73 11                	jae    f011db3c <test_kheap_phys_addr+0x35a>
f011db2b:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011db31:	89 c2                	mov    %eax,%edx
f011db33:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011db38:	39 c2                	cmp    %eax,%edx
f011db3a:	72 17                	jb     f011db53 <test_kheap_phys_addr+0x371>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011db3c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011db43:	83 ec 0c             	sub    $0xc,%esp
f011db46:	68 40 e8 12 f0       	push   $0xf012e840
f011db4b:	e8 1c 34 fe ff       	call   f0100f6c <cprintf>
f011db50:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011db53:	e8 e8 6c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011db58:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011db5b:	74 17                	je     f011db74 <test_kheap_phys_addr+0x392>
f011db5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011db64:	83 ec 0c             	sub    $0xc,%esp
f011db67:	68 40 e7 12 f0       	push   $0xf012e740
f011db6c:	e8 fb 33 fe ff       	call   f0100f6c <cprintf>
f011db71:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011db74:	e8 90 fe fe ff       	call   f010da09 <sys_calculate_free_frames>
f011db79:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011db7c:	e8 bf 6c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011db81:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011db84:	83 ec 0c             	sub    $0xc,%esp
f011db87:	68 00 1c 00 00       	push   $0x1c00
f011db8c:	e8 25 af fe ff       	call   f0108ab6 <kmalloc>
f011db91:	83 c4 10             	add    $0x10,%esp
f011db94:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011db9a:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011dba0:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011dba5:	74 17                	je     f011dbbe <test_kheap_phys_addr+0x3dc>
f011dba7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dbae:	83 ec 0c             	sub    $0xc,%esp
f011dbb1:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011dbb6:	e8 b1 33 fe ff       	call   f0100f6c <cprintf>
f011dbbb:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dbbe:	e8 7d 6c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dbc3:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dbc6:	74 17                	je     f011dbdf <test_kheap_phys_addr+0x3fd>
f011dbc8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dbcf:	83 ec 0c             	sub    $0xc,%esp
f011dbd2:	68 40 e7 12 f0       	push   $0xf012e740
f011dbd7:	e8 90 33 fe ff       	call   f0100f6c <cprintf>
f011dbdc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011dbdf:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011dbe2:	e8 22 fe fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dbe7:	29 c3                	sub    %eax,%ebx
f011dbe9:	89 d8                	mov    %ebx,%eax
f011dbeb:	83 f8 01             	cmp    $0x1,%eax
f011dbee:	77 17                	ja     f011dc07 <test_kheap_phys_addr+0x425>
f011dbf0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dbf7:	83 ec 0c             	sub    $0xc,%esp
f011dbfa:	68 ac e7 12 f0       	push   $0xf012e7ac
f011dbff:	e8 68 33 fe ff       	call   f0100f6c <cprintf>
f011dc04:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011dc07:	e8 fd fd fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dc0c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011dc0f:	e8 2c 6c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dc14:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011dc17:	83 ec 0c             	sub    $0xc,%esp
f011dc1a:	68 00 fc 2f 00       	push   $0x2ffc00
f011dc1f:	e8 92 ae fe ff       	call   f0108ab6 <kmalloc>
f011dc24:	83 c4 10             	add    $0x10,%esp
f011dc27:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011dc2d:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011dc33:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011dc38:	74 17                	je     f011dc51 <test_kheap_phys_addr+0x46f>
f011dc3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dc41:	83 ec 0c             	sub    $0xc,%esp
f011dc44:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011dc49:	e8 1e 33 fe ff       	call   f0100f6c <cprintf>
f011dc4e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dc51:	e8 ea 6b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dc56:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dc59:	74 17                	je     f011dc72 <test_kheap_phys_addr+0x490>
f011dc5b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dc62:	83 ec 0c             	sub    $0xc,%esp
f011dc65:	68 40 e7 12 f0       	push   $0xf012e740
f011dc6a:	e8 fd 32 fe ff       	call   f0100f6c <cprintf>
f011dc6f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011dc72:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011dc75:	e8 8f fd fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dc7a:	29 c3                	sub    %eax,%ebx
f011dc7c:	89 d8                	mov    %ebx,%eax
f011dc7e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011dc83:	77 17                	ja     f011dc9c <test_kheap_phys_addr+0x4ba>
f011dc85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dc8c:	83 ec 0c             	sub    $0xc,%esp
f011dc8f:	68 ac e7 12 f0       	push   $0xf012e7ac
f011dc94:	e8 d3 32 fe ff       	call   f0100f6c <cprintf>
f011dc99:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011dc9c:	e8 68 fd fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dca1:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011dca4:	e8 97 6b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dca9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011dcac:	83 ec 0c             	sub    $0xc,%esp
f011dcaf:	68 00 fc 5f 00       	push   $0x5ffc00
f011dcb4:	e8 fd ad fe ff       	call   f0108ab6 <kmalloc>
f011dcb9:	83 c4 10             	add    $0x10,%esp
f011dcbc:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011dcc2:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011dcc8:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011dccd:	74 17                	je     f011dce6 <test_kheap_phys_addr+0x504>
f011dccf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dcd6:	83 ec 0c             	sub    $0xc,%esp
f011dcd9:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011dcde:	e8 89 32 fe ff       	call   f0100f6c <cprintf>
f011dce3:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dce6:	e8 55 6b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dceb:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dcee:	74 17                	je     f011dd07 <test_kheap_phys_addr+0x525>
f011dcf0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dcf7:	83 ec 0c             	sub    $0xc,%esp
f011dcfa:	68 40 e7 12 f0       	push   $0xf012e740
f011dcff:	e8 68 32 fe ff       	call   f0100f6c <cprintf>
f011dd04:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011dd07:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011dd0a:	e8 fa fc fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dd0f:	29 c3                	sub    %eax,%ebx
f011dd11:	89 d8                	mov    %ebx,%eax
f011dd13:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011dd18:	77 17                	ja     f011dd31 <test_kheap_phys_addr+0x54f>
f011dd1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dd21:	83 ec 0c             	sub    $0xc,%esp
f011dd24:	68 ac e7 12 f0       	push   $0xf012e7ac
f011dd29:	e8 3e 32 fe ff       	call   f0100f6c <cprintf>
f011dd2e:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011dd31:	e8 d3 fc fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dd36:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011dd39:	e8 02 6b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dd3e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011dd41:	83 ec 0c             	sub    $0xc,%esp
f011dd44:	68 00 38 00 00       	push   $0x3800
f011dd49:	e8 68 ad fe ff       	call   f0108ab6 <kmalloc>
f011dd4e:	83 c4 10             	add    $0x10,%esp
f011dd51:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011dd57:	8b 85 94 fe ff ff    	mov    -0x16c(%ebp),%eax
f011dd5d:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011dd62:	74 17                	je     f011dd7b <test_kheap_phys_addr+0x599>
f011dd64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dd6b:	83 ec 0c             	sub    $0xc,%esp
f011dd6e:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011dd73:	e8 f4 31 fe ff       	call   f0100f6c <cprintf>
f011dd78:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dd7b:	e8 c0 6a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011dd80:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dd83:	74 17                	je     f011dd9c <test_kheap_phys_addr+0x5ba>
f011dd85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dd8c:	83 ec 0c             	sub    $0xc,%esp
f011dd8f:	68 40 e7 12 f0       	push   $0xf012e740
f011dd94:	e8 d3 31 fe ff       	call   f0100f6c <cprintf>
f011dd99:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011dd9c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011dd9f:	e8 65 fc fe ff       	call   f010da09 <sys_calculate_free_frames>
f011dda4:	29 c3                	sub    %eax,%ebx
f011dda6:	89 d8                	mov    %ebx,%eax
f011dda8:	83 f8 03             	cmp    $0x3,%eax
f011ddab:	77 17                	ja     f011ddc4 <test_kheap_phys_addr+0x5e2>
f011ddad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ddb4:	83 ec 0c             	sub    $0xc,%esp
f011ddb7:	68 ac e7 12 f0       	push   $0xf012e7ac
f011ddbc:	e8 ab 31 fe ff       	call   f0100f6c <cprintf>
f011ddc1:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ddc4:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011ddcb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011ddd2:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ddd9:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011ddde:	05 00 10 00 00       	add    $0x1000,%eax
f011dde3:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011dde6:	8b 45 98             	mov    -0x68(%ebp),%eax
f011dde9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ddec:	eb 2e                	jmp    f011de1c <test_kheap_phys_addr+0x63a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011ddee:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011ddf1:	8d 43 01             	lea    0x1(%ebx),%eax
f011ddf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ddf7:	83 ec 0c             	sub    $0xc,%esp
f011ddfa:	ff 75 e8             	pushl  -0x18(%ebp)
f011ddfd:	e8 02 ad fe ff       	call   f0108b04 <kheap_physical_address>
f011de02:	83 c4 10             	add    $0x10,%esp
f011de05:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011de0c:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011de0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de12:	01 d0                	add    %edx,%eax
f011de14:	05 00 10 00 00       	add    $0x1000,%eax
f011de19:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011de1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de1f:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011de22:	72 ca                	jb     f011ddee <test_kheap_phys_addr+0x60c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011de24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de27:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011de2a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011de31:	8b 45 98             	mov    -0x68(%ebp),%eax
f011de34:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011de37:	e9 ce 00 00 00       	jmp    f011df0a <test_kheap_phys_addr+0x728>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011de3c:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011de41:	83 ec 04             	sub    $0x4,%esp
f011de44:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011de4a:	52                   	push   %edx
f011de4b:	ff 75 e8             	pushl  -0x18(%ebp)
f011de4e:	50                   	push   %eax
f011de4f:	e8 b9 a5 fe ff       	call   f010840d <get_page_table>
f011de54:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011de57:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011de5d:	85 c0                	test   %eax,%eax
f011de5f:	75 1e                	jne    f011de7f <test_kheap_phys_addr+0x69d>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011de61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011de68:	83 ec 04             	sub    $0x4,%esp
f011de6b:	68 98 ed 12 f0       	push   $0xf012ed98
f011de70:	68 30 05 00 00       	push   $0x530
f011de75:	68 f2 ed 12 f0       	push   $0xf012edf2
f011de7a:	e8 9b 24 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011de7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de82:	c1 e8 0c             	shr    $0xc,%eax
f011de85:	25 ff 03 00 00       	and    $0x3ff,%eax
f011de8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011de8d:	eb 62                	jmp    f011def1 <test_kheap_phys_addr+0x70f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011de8f:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011de95:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011de98:	c1 e2 02             	shl    $0x2,%edx
f011de9b:	01 d0                	add    %edx,%eax
f011de9d:	8b 00                	mov    (%eax),%eax
f011de9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011dea4:	89 c2                	mov    %eax,%edx
f011dea6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dea9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011deae:	01 c2                	add    %eax,%edx
f011deb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011deb3:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011deba:	39 c2                	cmp    %eax,%edx
f011debc:	74 1d                	je     f011dedb <test_kheap_phys_addr+0x6f9>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011debe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dec2:	74 17                	je     f011dedb <test_kheap_phys_addr+0x6f9>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011dec4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011decb:	83 ec 0c             	sub    $0xc,%esp
f011dece:	68 0a ee 12 f0       	push   $0xf012ee0a
f011ded3:	e8 94 30 fe ff       	call   f0100f6c <cprintf>
f011ded8:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011dedb:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011dede:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dee1:	01 d0                	add    %edx,%eax
f011dee3:	05 00 10 00 00       	add    $0x1000,%eax
f011dee8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011deeb:	ff 45 e4             	incl   -0x1c(%ebp)
f011deee:	ff 45 f4             	incl   -0xc(%ebp)
f011def1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011def4:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011def7:	7d 11                	jge    f011df0a <test_kheap_phys_addr+0x728>
f011def9:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011df00:	7f 08                	jg     f011df0a <test_kheap_phys_addr+0x728>
f011df02:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011df05:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011df08:	72 85                	jb     f011de8f <test_kheap_phys_addr+0x6ad>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011df0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011df0d:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011df10:	0f 82 26 ff ff ff    	jb     f011de3c <test_kheap_phys_addr+0x65a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011df16:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011df1a:	74 04                	je     f011df20 <test_kheap_phys_addr+0x73e>
f011df1c:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011df20:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011df27:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011df2e:	e9 b0 00 00 00       	jmp    f011dfe3 <test_kheap_phys_addr+0x801>
		{
			va = (uint32)ptr_allocations[i];
f011df33:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011df36:	8b 84 85 74 fe ff ff 	mov    -0x18c(%ebp,%eax,4),%eax
f011df3d:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011df40:	83 ec 0c             	sub    $0xc,%esp
f011df43:	ff 75 90             	pushl  -0x70(%ebp)
f011df46:	e8 b9 ab fe ff       	call   f0108b04 <kheap_physical_address>
f011df4b:	83 c4 10             	add    $0x10,%esp
f011df4e:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011df51:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011df56:	83 ec 04             	sub    $0x4,%esp
f011df59:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011df5f:	52                   	push   %edx
f011df60:	ff 75 90             	pushl  -0x70(%ebp)
f011df63:	50                   	push   %eax
f011df64:	e8 a4 a4 fe ff       	call   f010840d <get_page_table>
f011df69:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011df6c:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011df72:	85 c0                	test   %eax,%eax
f011df74:	75 1e                	jne    f011df94 <test_kheap_phys_addr+0x7b2>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011df76:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011df7d:	83 ec 04             	sub    $0x4,%esp
f011df80:	68 98 ed 12 f0       	push   $0xf012ed98
f011df85:	68 4c 05 00 00       	push   $0x54c
f011df8a:	68 f2 ed 12 f0       	push   $0xf012edf2
f011df8f:	e8 86 23 fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011df94:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011df9a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011df9d:	c1 ea 0c             	shr    $0xc,%edx
f011dfa0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011dfa6:	c1 e2 02             	shl    $0x2,%edx
f011dfa9:	01 d0                	add    %edx,%eax
f011dfab:	8b 00                	mov    (%eax),%eax
f011dfad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011dfb2:	89 c2                	mov    %eax,%edx
f011dfb4:	8b 45 90             	mov    -0x70(%ebp),%eax
f011dfb7:	25 ff 0f 00 00       	and    $0xfff,%eax
f011dfbc:	01 d0                	add    %edx,%eax
f011dfbe:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011dfc1:	74 1d                	je     f011dfe0 <test_kheap_phys_addr+0x7fe>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011dfc3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dfc7:	74 17                	je     f011dfe0 <test_kheap_phys_addr+0x7fe>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011dfc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dfd0:	83 ec 0c             	sub    $0xc,%esp
f011dfd3:	68 0a ee 12 f0       	push   $0xf012ee0a
f011dfd8:	e8 8f 2f fe ff       	call   f0100f6c <cprintf>
f011dfdd:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011dfe0:	ff 45 e0             	incl   -0x20(%ebp)
f011dfe3:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011dfe7:	0f 8e 46 ff ff ff    	jle    f011df33 <test_kheap_phys_addr+0x751>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011dfed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dff1:	74 04                	je     f011dff7 <test_kheap_phys_addr+0x815>
f011dff3:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011dff7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011dffe:	e8 06 fa fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e003:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011e006:	e8 35 68 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e00b:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011e00e:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011e014:	83 ec 0c             	sub    $0xc,%esp
f011e017:	50                   	push   %eax
f011e018:	e8 b3 aa fe ff       	call   f0108ad0 <kfree>
f011e01d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e020:	e8 1b 68 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e025:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011e028:	74 17                	je     f011e041 <test_kheap_phys_addr+0x85f>
f011e02a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e031:	83 ec 0c             	sub    $0xc,%esp
f011e034:	68 40 e7 12 f0       	push   $0xf012e740
f011e039:	e8 2e 2f fe ff       	call   f0100f6c <cprintf>
f011e03e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011e041:	e8 c3 f9 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e046:	89 c2                	mov    %eax,%edx
f011e048:	8b 45 88             	mov    -0x78(%ebp),%eax
f011e04b:	29 c2                	sub    %eax,%edx
f011e04d:	89 d0                	mov    %edx,%eax
f011e04f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011e054:	77 17                	ja     f011e06d <test_kheap_phys_addr+0x88b>
f011e056:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e05d:	83 ec 0c             	sub    $0xc,%esp
f011e060:	68 44 eb 12 f0       	push   $0xf012eb44
f011e065:	e8 02 2f fe ff       	call   f0100f6c <cprintf>
f011e06a:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011e06d:	e8 97 f9 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e072:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e075:	e8 c6 67 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e07a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011e07d:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011e083:	83 ec 0c             	sub    $0xc,%esp
f011e086:	50                   	push   %eax
f011e087:	e8 44 aa fe ff       	call   f0108ad0 <kfree>
f011e08c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e08f:	e8 ac 67 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e094:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011e097:	74 17                	je     f011e0b0 <test_kheap_phys_addr+0x8ce>
f011e099:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e0a0:	83 ec 0c             	sub    $0xc,%esp
f011e0a3:	68 40 e7 12 f0       	push   $0xf012e740
f011e0a8:	e8 bf 2e fe ff       	call   f0100f6c <cprintf>
f011e0ad:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011e0b0:	e8 54 f9 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e0b5:	89 c2                	mov    %eax,%edx
f011e0b7:	8b 45 88             	mov    -0x78(%ebp),%eax
f011e0ba:	29 c2                	sub    %eax,%edx
f011e0bc:	89 d0                	mov    %edx,%eax
f011e0be:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011e0c3:	77 17                	ja     f011e0dc <test_kheap_phys_addr+0x8fa>
f011e0c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e0cc:	83 ec 0c             	sub    $0xc,%esp
f011e0cf:	68 44 eb 12 f0       	push   $0xf012eb44
f011e0d4:	e8 93 2e fe ff       	call   f0100f6c <cprintf>
f011e0d9:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011e0dc:	e8 28 f9 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e0e1:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e0e4:	e8 57 67 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e0e9:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011e0ec:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011e0f2:	83 ec 0c             	sub    $0xc,%esp
f011e0f5:	50                   	push   %eax
f011e0f6:	e8 d5 a9 fe ff       	call   f0108ad0 <kfree>
f011e0fb:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e0fe:	e8 3d 67 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e103:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011e106:	74 17                	je     f011e11f <test_kheap_phys_addr+0x93d>
f011e108:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e10f:	83 ec 0c             	sub    $0xc,%esp
f011e112:	68 40 e7 12 f0       	push   $0xf012e740
f011e117:	e8 50 2e fe ff       	call   f0100f6c <cprintf>
f011e11c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011e11f:	e8 e5 f8 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e124:	89 c2                	mov    %eax,%edx
f011e126:	8b 45 88             	mov    -0x78(%ebp),%eax
f011e129:	29 c2                	sub    %eax,%edx
f011e12b:	89 d0                	mov    %edx,%eax
f011e12d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011e132:	77 17                	ja     f011e14b <test_kheap_phys_addr+0x969>
f011e134:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e13b:	83 ec 0c             	sub    $0xc,%esp
f011e13e:	68 44 eb 12 f0       	push   $0xf012eb44
f011e143:	e8 24 2e fe ff       	call   f0100f6c <cprintf>
f011e148:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011e14b:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011e152:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011e159:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011e15e:	05 00 10 00 00       	add    $0x1000,%eax
f011e163:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011e169:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011e16f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e172:	eb 25                	jmp    f011e199 <test_kheap_phys_addr+0x9b7>
		{
			allPAs[i++] = kheap_physical_address(va);
f011e174:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011e177:	8d 43 01             	lea    0x1(%ebx),%eax
f011e17a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e17d:	83 ec 0c             	sub    $0xc,%esp
f011e180:	ff 75 dc             	pushl  -0x24(%ebp)
f011e183:	e8 7c a9 fe ff       	call   f0108b04 <kheap_physical_address>
f011e188:	83 c4 10             	add    $0x10,%esp
f011e18b:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 startVA = da_limit + PAGE_SIZE;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011e192:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011e199:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e19c:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011e19f:	72 d3                	jb     f011e174 <test_kheap_phys_addr+0x992>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011e1a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e1a4:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
		i = 0;
f011e1aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011e1b1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011e1b7:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e1ba:	e9 f1 00 00 00       	jmp    f011e2b0 <test_kheap_phys_addr+0xace>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011e1bf:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011e1c4:	83 ec 04             	sub    $0x4,%esp
f011e1c7:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011e1cd:	52                   	push   %edx
f011e1ce:	ff 75 dc             	pushl  -0x24(%ebp)
f011e1d1:	50                   	push   %eax
f011e1d2:	e8 36 a2 fe ff       	call   f010840d <get_page_table>
f011e1d7:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e1da:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011e1e0:	85 c0                	test   %eax,%eax
f011e1e2:	75 24                	jne    f011e208 <test_kheap_phys_addr+0xa26>
				if (correct)
f011e1e4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e1e8:	74 1e                	je     f011e208 <test_kheap_phys_addr+0xa26>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e1ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e1f1:	83 ec 04             	sub    $0x4,%esp
f011e1f4:	68 98 ed 12 f0       	push   $0xf012ed98
f011e1f9:	68 86 05 00 00       	push   $0x586
f011e1fe:	68 f2 ed 12 f0       	push   $0xf012edf2
f011e203:	e8 12 21 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011e208:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e20b:	c1 e8 0c             	shr    $0xc,%eax
f011e20e:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e213:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011e216:	eb 78                	jmp    f011e290 <test_kheap_phys_addr+0xaae>
			{
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
f011e218:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011e21e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e221:	c1 e2 02             	shl    $0x2,%edx
f011e224:	01 d0                	add    %edx,%eax
f011e226:	8b 00                	mov    (%eax),%eax
f011e228:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e22d:	89 c1                	mov    %eax,%ecx
f011e22f:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011e235:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e238:	c1 e2 02             	shl    $0x2,%edx
f011e23b:	01 d0                	add    %edx,%eax
f011e23d:	8b 00                	mov    (%eax),%eax
f011e23f:	83 e0 01             	and    $0x1,%eax
f011e242:	85 c0                	test   %eax,%eax
f011e244:	74 0a                	je     f011e250 <test_kheap_phys_addr+0xa6e>
f011e246:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e249:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e24e:	eb 05                	jmp    f011e255 <test_kheap_phys_addr+0xa73>
f011e250:	b8 00 00 00 00       	mov    $0x0,%eax
f011e255:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011e258:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e25b:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011e262:	39 c2                	cmp    %eax,%edx
f011e264:	74 1d                	je     f011e283 <test_kheap_phys_addr+0xaa1>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011e266:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e26a:	74 17                	je     f011e283 <test_kheap_phys_addr+0xaa1>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011e26c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e273:	83 ec 0c             	sub    $0xc,%esp
f011e276:	68 0a ee 12 f0       	push   $0xf012ee0a
f011e27b:	e8 ec 2c fe ff       	call   f0100f6c <cprintf>
f011e280:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011e283:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011e28a:	ff 45 d8             	incl   -0x28(%ebp)
f011e28d:	ff 45 f4             	incl   -0xc(%ebp)
f011e290:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e293:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
f011e299:	7d 15                	jge    f011e2b0 <test_kheap_phys_addr+0xace>
f011e29b:	81 7d d8 ff 03 00 00 	cmpl   $0x3ff,-0x28(%ebp)
f011e2a2:	7f 0c                	jg     f011e2b0 <test_kheap_phys_addr+0xace>
f011e2a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e2a7:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011e2aa:	0f 82 68 ff ff ff    	jb     f011e218 <test_kheap_phys_addr+0xa36>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011e2b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e2b3:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011e2b6:	0f 82 03 ff ff ff    	jb     f011e1bf <test_kheap_phys_addr+0x9dd>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011e2bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e2c0:	74 04                	je     f011e2c6 <test_kheap_phys_addr+0xae4>
f011e2c2:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011e2c6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011e2cd:	c7 45 d4 00 00 00 f6 	movl   $0xf6000000,-0x2c(%ebp)
f011e2d4:	e9 af 00 00 00       	jmp    f011e388 <test_kheap_phys_addr+0xba6>
		{
			pa = kheap_physical_address(va);
f011e2d9:	83 ec 0c             	sub    $0xc,%esp
f011e2dc:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e2df:	e8 20 a8 fe ff       	call   f0108b04 <kheap_physical_address>
f011e2e4:	83 c4 10             	add    $0x10,%esp
f011e2e7:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011e2ed:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011e2f2:	83 ec 04             	sub    $0x4,%esp
f011e2f5:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011e2fb:	52                   	push   %edx
f011e2fc:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e2ff:	50                   	push   %eax
f011e300:	e8 08 a1 fe ff       	call   f010840d <get_page_table>
f011e305:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e308:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011e30e:	85 c0                	test   %eax,%eax
f011e310:	75 24                	jne    f011e336 <test_kheap_phys_addr+0xb54>
				if (correct)
f011e312:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e316:	74 1e                	je     f011e336 <test_kheap_phys_addr+0xb54>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e318:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e31f:	83 ec 04             	sub    $0x4,%esp
f011e322:	68 98 ed 12 f0       	push   $0xf012ed98
f011e327:	68 a1 05 00 00       	push   $0x5a1
f011e32c:	68 f2 ed 12 f0       	push   $0xf012edf2
f011e331:	e8 e4 1f fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011e336:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011e33c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e33f:	c1 ea 0c             	shr    $0xc,%edx
f011e342:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011e348:	c1 e2 02             	shl    $0x2,%edx
f011e34b:	01 d0                	add    %edx,%eax
f011e34d:	8b 00                	mov    (%eax),%eax
f011e34f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e354:	89 c2                	mov    %eax,%edx
f011e356:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e359:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e35e:	01 d0                	add    %edx,%eax
f011e360:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011e366:	74 1d                	je     f011e385 <test_kheap_phys_addr+0xba3>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011e368:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e36c:	74 17                	je     f011e385 <test_kheap_phys_addr+0xba3>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011e36e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e375:	83 ec 0c             	sub    $0xc,%esp
f011e378:	68 0a ee 12 f0       	push   $0xf012ee0a
f011e37d:	e8 ea 2b fe ff       	call   f0100f6c <cprintf>
f011e382:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011e385:	ff 45 d4             	incl   -0x2c(%ebp)
f011e388:	83 ec 0c             	sub    $0xc,%esp
f011e38b:	6a 00                	push   $0x0
f011e38d:	e8 1a a7 fe ff       	call   f0108aac <sbrk>
f011e392:	83 c4 10             	add    $0x10,%esp
f011e395:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011e398:	0f 87 3b ff ff ff    	ja     f011e2d9 <test_kheap_phys_addr+0xaf7>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011e39e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e3a2:	74 04                	je     f011e3a8 <test_kheap_phys_addr+0xbc6>
f011e3a4:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011e3a8:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011e3af:	c7 85 70 ff ff ff 00 	movl   $0xf9001000,-0x90(%ebp)
f011e3b6:	10 00 f9 
		i = 0;
f011e3b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011e3c0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e3c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011e3c9:	eb 0a                	jmp    f011e3d5 <test_kheap_phys_addr+0xbf3>
		{
			i++;
f011e3cb:	ff 45 f4             	incl   -0xc(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011e3ce:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
f011e3d5:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f011e3dc:	76 ed                	jbe    f011e3cb <test_kheap_phys_addr+0xbe9>
		{
			i++;
		}
		int ii = i ;
f011e3de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e3e1:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
		i = 0;
f011e3e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011e3ee:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e3f4:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011e3f7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011e3fe:	e9 13 01 00 00       	jmp    f011e516 <test_kheap_phys_addr+0xd34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011e403:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011e406:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011e40b:	83 ec 04             	sub    $0x4,%esp
f011e40e:	8d 8d 60 fe ff ff    	lea    -0x1a0(%ebp),%ecx
f011e414:	51                   	push   %ecx
f011e415:	52                   	push   %edx
f011e416:	50                   	push   %eax
f011e417:	e8 f1 9f fe ff       	call   f010840d <get_page_table>
f011e41c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e41f:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011e425:	85 c0                	test   %eax,%eax
f011e427:	75 24                	jne    f011e44d <test_kheap_phys_addr+0xc6b>
			{
				if (correct)
f011e429:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e42d:	74 1e                	je     f011e44d <test_kheap_phys_addr+0xc6b>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e42f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e436:	83 ec 04             	sub    $0x4,%esp
f011e439:	68 98 ed 12 f0       	push   $0xf012ed98
f011e43e:	68 c2 05 00 00       	push   $0x5c2
f011e443:	68 f2 ed 12 f0       	push   $0xf012edf2
f011e448:	e8 cd 1e fe ff       	call   f010031a <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011e44d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f011e454:	e9 9a 00 00 00       	jmp    f011e4f3 <test_kheap_phys_addr+0xd11>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011e459:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e45c:	c1 e0 0c             	shl    $0xc,%eax
f011e45f:	89 c2                	mov    %eax,%edx
f011e461:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e467:	01 d0                	add    %edx,%eax
f011e469:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011e46f:	83 ec 0c             	sub    $0xc,%esp
f011e472:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
f011e478:	e8 87 a6 fe ff       	call   f0108b04 <kheap_physical_address>
f011e47d:	83 c4 10             	add    $0x10,%esp
f011e480:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
f011e486:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011e48c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011e48f:	c1 e2 02             	shl    $0x2,%edx
f011e492:	01 d0                	add    %edx,%eax
f011e494:	8b 00                	mov    (%eax),%eax
f011e496:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e49b:	89 c1                	mov    %eax,%ecx
f011e49d:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011e4a3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011e4a6:	c1 e2 02             	shl    $0x2,%edx
f011e4a9:	01 d0                	add    %edx,%eax
f011e4ab:	8b 00                	mov    (%eax),%eax
f011e4ad:	83 e0 01             	and    $0x1,%eax
f011e4b0:	85 c0                	test   %eax,%eax
f011e4b2:	74 0d                	je     f011e4c1 <test_kheap_phys_addr+0xcdf>
f011e4b4:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011e4ba:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e4bf:	eb 05                	jmp    f011e4c6 <test_kheap_phys_addr+0xce4>
f011e4c1:	b8 00 00 00 00       	mov    $0x0,%eax
f011e4c6:	01 c8                	add    %ecx,%eax
f011e4c8:	3b 85 64 ff ff ff    	cmp    -0x9c(%ebp),%eax
f011e4ce:	74 1d                	je     f011e4ed <test_kheap_phys_addr+0xd0b>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011e4d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e4d4:	74 17                	je     f011e4ed <test_kheap_phys_addr+0xd0b>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011e4d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e4dd:	83 ec 0c             	sub    $0xc,%esp
f011e4e0:	68 0a ee 12 f0       	push   $0xf012ee0a
f011e4e5:	e8 82 2a fe ff       	call   f0100f6c <cprintf>
f011e4ea:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011e4ed:	ff 45 cc             	incl   -0x34(%ebp)
f011e4f0:	ff 45 f4             	incl   -0xc(%ebp)
f011e4f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e4f6:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f011e4fc:	7d 0d                	jge    f011e50b <test_kheap_phys_addr+0xd29>
f011e4fe:	81 7d cc ff 03 00 00 	cmpl   $0x3ff,-0x34(%ebp)
f011e505:	0f 8e 4e ff ff ff    	jle    f011e459 <test_kheap_phys_addr+0xc77>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011e50b:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011e512:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011e516:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011e51a:	0f 88 e3 fe ff ff    	js     f011e403 <test_kheap_phys_addr+0xc21>
f011e520:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011e524:	7f 0d                	jg     f011e533 <test_kheap_phys_addr+0xd51>
f011e526:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011e52d:	0f 86 d0 fe ff ff    	jbe    f011e403 <test_kheap_phys_addr+0xc21>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011e533:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e537:	74 04                	je     f011e53d <test_kheap_phys_addr+0xd5b>
f011e539:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011e53d:	83 ec 08             	sub    $0x8,%esp
f011e540:	ff 75 f0             	pushl  -0x10(%ebp)
f011e543:	68 28 ee 12 f0       	push   $0xf012ee28
f011e548:	e8 1f 2a fe ff       	call   f0100f6c <cprintf>
f011e54d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011e550:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011e555:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011e558:	5b                   	pop    %ebx
f011e559:	5f                   	pop    %edi
f011e55a:	5d                   	pop    %ebp
f011e55b:	c3                   	ret    

f011e55c <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011e55c:	55                   	push   %ebp
f011e55d:	89 e5                	mov    %esp,%ebp
f011e55f:	57                   	push   %edi
f011e560:	56                   	push   %esi
f011e561:	53                   	push   %ebx
f011e562:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011e568:	89 e0                	mov    %esp,%eax
f011e56a:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011e56c:	83 ec 0c             	sub    $0xc,%esp
f011e56f:	68 80 e6 12 f0       	push   $0xf012e680
f011e574:	e8 f3 29 fe ff       	call   f0100f6c <cprintf>
f011e579:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011e57c:	83 ec 0c             	sub    $0xc,%esp
f011e57f:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011e584:	e8 e3 29 fe ff       	call   f0100f6c <cprintf>
f011e589:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011e58c:	83 ec 0c             	sub    $0xc,%esp
f011e58f:	68 80 e6 12 f0       	push   $0xf012e680
f011e594:	e8 d3 29 fe ff       	call   f0100f6c <cprintf>
f011e599:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011e59c:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011e5a0:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011e5a4:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011e5aa:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011e5b0:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011e5b7:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011e5be:	e8 46 f4 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e5c3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011e5c6:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011e5cc:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e5d1:	b8 00 00 00 00       	mov    $0x0,%eax
f011e5d6:	89 d7                	mov    %edx,%edi
f011e5d8:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011e5da:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011e5e0:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e5e5:	b8 00 00 00 00       	mov    $0x0,%eax
f011e5ea:	89 d7                	mov    %edx,%edi
f011e5ec:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011e5ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011e5f5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011e5fc:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011e602:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e607:	b8 00 00 00 00       	mov    $0x0,%eax
f011e60c:	89 d7                	mov    %edx,%edi
f011e60e:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011e610:	e8 f4 f3 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e615:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e618:	e8 23 62 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e61d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011e620:	83 ec 0c             	sub    $0xc,%esp
f011e623:	68 00 fc 1f 00       	push   $0x1ffc00
f011e628:	e8 89 a4 fe ff       	call   f0108ab6 <kmalloc>
f011e62d:	83 c4 10             	add    $0x10,%esp
f011e630:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e636:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011e63c:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011e641:	74 17                	je     f011e65a <test_kheap_virt_addr+0xfe>
f011e643:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e64a:	83 ec 0c             	sub    $0xc,%esp
f011e64d:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011e652:	e8 15 29 fe ff       	call   f0100f6c <cprintf>
f011e657:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e65a:	e8 e1 61 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e65f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e662:	74 17                	je     f011e67b <test_kheap_virt_addr+0x11f>
f011e664:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e66b:	83 ec 0c             	sub    $0xc,%esp
f011e66e:	68 40 e7 12 f0       	push   $0xf012e740
f011e673:	e8 f4 28 fe ff       	call   f0100f6c <cprintf>
f011e678:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e67b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e67e:	e8 86 f3 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e683:	29 c3                	sub    %eax,%ebx
f011e685:	89 d8                	mov    %ebx,%eax
f011e687:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011e68c:	77 17                	ja     f011e6a5 <test_kheap_virt_addr+0x149>
f011e68e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e695:	83 ec 0c             	sub    $0xc,%esp
f011e698:	68 ac e7 12 f0       	push   $0xf012e7ac
f011e69d:	e8 ca 28 fe ff       	call   f0100f6c <cprintf>
f011e6a2:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011e6a5:	e8 5f f3 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e6aa:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e6ad:	e8 8e 61 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e6b2:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011e6b5:	83 ec 0c             	sub    $0xc,%esp
f011e6b8:	68 00 fc 1f 00       	push   $0x1ffc00
f011e6bd:	e8 f4 a3 fe ff       	call   f0108ab6 <kmalloc>
f011e6c2:	83 c4 10             	add    $0x10,%esp
f011e6c5:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e6cb:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011e6d1:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011e6d6:	74 17                	je     f011e6ef <test_kheap_virt_addr+0x193>
f011e6d8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e6df:	83 ec 0c             	sub    $0xc,%esp
f011e6e2:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011e6e7:	e8 80 28 fe ff       	call   f0100f6c <cprintf>
f011e6ec:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e6ef:	e8 4c 61 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e6f4:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e6f7:	74 17                	je     f011e710 <test_kheap_virt_addr+0x1b4>
f011e6f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e700:	83 ec 0c             	sub    $0xc,%esp
f011e703:	68 40 e7 12 f0       	push   $0xf012e740
f011e708:	e8 5f 28 fe ff       	call   f0100f6c <cprintf>
f011e70d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e710:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e713:	e8 f1 f2 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e718:	29 c3                	sub    %eax,%ebx
f011e71a:	89 d8                	mov    %ebx,%eax
f011e71c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011e721:	77 17                	ja     f011e73a <test_kheap_virt_addr+0x1de>
f011e723:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e72a:	83 ec 0c             	sub    $0xc,%esp
f011e72d:	68 ac e7 12 f0       	push   $0xf012e7ac
f011e732:	e8 35 28 fe ff       	call   f0100f6c <cprintf>
f011e737:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011e73a:	e8 ca f2 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e73f:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e742:	e8 f9 60 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e747:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011e74a:	83 ec 0c             	sub    $0xc,%esp
f011e74d:	68 00 04 00 00       	push   $0x400
f011e752:	e8 5f a3 fe ff       	call   f0108ab6 <kmalloc>
f011e757:	83 c4 10             	add    $0x10,%esp
f011e75a:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011e760:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011e766:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e76b:	76 28                	jbe    f011e795 <test_kheap_virt_addr+0x239>
f011e76d:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011e773:	83 ec 0c             	sub    $0xc,%esp
f011e776:	6a 00                	push   $0x0
f011e778:	e8 2f a3 fe ff       	call   f0108aac <sbrk>
f011e77d:	83 c4 10             	add    $0x10,%esp
f011e780:	39 c3                	cmp    %eax,%ebx
f011e782:	73 11                	jae    f011e795 <test_kheap_virt_addr+0x239>
f011e784:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011e78a:	89 c2                	mov    %eax,%edx
f011e78c:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011e791:	39 c2                	cmp    %eax,%edx
f011e793:	72 17                	jb     f011e7ac <test_kheap_virt_addr+0x250>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011e795:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e79c:	83 ec 0c             	sub    $0xc,%esp
f011e79f:	68 40 e8 12 f0       	push   $0xf012e840
f011e7a4:	e8 c3 27 fe ff       	call   f0100f6c <cprintf>
f011e7a9:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e7ac:	e8 8f 60 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e7b1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e7b4:	74 17                	je     f011e7cd <test_kheap_virt_addr+0x271>
f011e7b6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e7bd:	83 ec 0c             	sub    $0xc,%esp
f011e7c0:	68 40 e7 12 f0       	push   $0xf012e740
f011e7c5:	e8 a2 27 fe ff       	call   f0100f6c <cprintf>
f011e7ca:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011e7cd:	e8 37 f2 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e7d2:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e7d5:	e8 66 60 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e7da:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011e7dd:	83 ec 0c             	sub    $0xc,%esp
f011e7e0:	68 00 08 00 00       	push   $0x800
f011e7e5:	e8 cc a2 fe ff       	call   f0108ab6 <kmalloc>
f011e7ea:	83 c4 10             	add    $0x10,%esp
f011e7ed:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011e7f3:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011e7f9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e7fe:	76 28                	jbe    f011e828 <test_kheap_virt_addr+0x2cc>
f011e800:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011e806:	83 ec 0c             	sub    $0xc,%esp
f011e809:	6a 00                	push   $0x0
f011e80b:	e8 9c a2 fe ff       	call   f0108aac <sbrk>
f011e810:	83 c4 10             	add    $0x10,%esp
f011e813:	39 c3                	cmp    %eax,%ebx
f011e815:	73 11                	jae    f011e828 <test_kheap_virt_addr+0x2cc>
f011e817:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011e81d:	89 c2                	mov    %eax,%edx
f011e81f:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011e824:	39 c2                	cmp    %eax,%edx
f011e826:	72 17                	jb     f011e83f <test_kheap_virt_addr+0x2e3>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011e828:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e82f:	83 ec 0c             	sub    $0xc,%esp
f011e832:	68 40 e8 12 f0       	push   $0xf012e840
f011e837:	e8 30 27 fe ff       	call   f0100f6c <cprintf>
f011e83c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e83f:	e8 fc 5f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e844:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e847:	74 17                	je     f011e860 <test_kheap_virt_addr+0x304>
f011e849:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e850:	83 ec 0c             	sub    $0xc,%esp
f011e853:	68 40 e7 12 f0       	push   $0xf012e740
f011e858:	e8 0f 27 fe ff       	call   f0100f6c <cprintf>
f011e85d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011e860:	e8 a4 f1 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e865:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e868:	e8 d3 5f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e86d:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011e870:	83 ec 0c             	sub    $0xc,%esp
f011e873:	68 00 06 00 00       	push   $0x600
f011e878:	e8 39 a2 fe ff       	call   f0108ab6 <kmalloc>
f011e87d:	83 c4 10             	add    $0x10,%esp
f011e880:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011e886:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011e88c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e891:	76 28                	jbe    f011e8bb <test_kheap_virt_addr+0x35f>
f011e893:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011e899:	83 ec 0c             	sub    $0xc,%esp
f011e89c:	6a 00                	push   $0x0
f011e89e:	e8 09 a2 fe ff       	call   f0108aac <sbrk>
f011e8a3:	83 c4 10             	add    $0x10,%esp
f011e8a6:	39 c3                	cmp    %eax,%ebx
f011e8a8:	73 11                	jae    f011e8bb <test_kheap_virt_addr+0x35f>
f011e8aa:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011e8b0:	89 c2                	mov    %eax,%edx
f011e8b2:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011e8b7:	39 c2                	cmp    %eax,%edx
f011e8b9:	72 17                	jb     f011e8d2 <test_kheap_virt_addr+0x376>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011e8bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e8c2:	83 ec 0c             	sub    $0xc,%esp
f011e8c5:	68 40 e8 12 f0       	push   $0xf012e840
f011e8ca:	e8 9d 26 fe ff       	call   f0100f6c <cprintf>
f011e8cf:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e8d2:	e8 69 5f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e8d7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e8da:	74 17                	je     f011e8f3 <test_kheap_virt_addr+0x397>
f011e8dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e8e3:	83 ec 0c             	sub    $0xc,%esp
f011e8e6:	68 40 e7 12 f0       	push   $0xf012e740
f011e8eb:	e8 7c 26 fe ff       	call   f0100f6c <cprintf>
f011e8f0:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011e8f3:	e8 11 f1 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e8f8:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e8fb:	e8 40 5f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e900:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011e903:	83 ec 0c             	sub    $0xc,%esp
f011e906:	68 00 1c 00 00       	push   $0x1c00
f011e90b:	e8 a6 a1 fe ff       	call   f0108ab6 <kmalloc>
f011e910:	83 c4 10             	add    $0x10,%esp
f011e913:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e919:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011e91f:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011e924:	74 17                	je     f011e93d <test_kheap_virt_addr+0x3e1>
f011e926:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e92d:	83 ec 0c             	sub    $0xc,%esp
f011e930:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011e935:	e8 32 26 fe ff       	call   f0100f6c <cprintf>
f011e93a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e93d:	e8 fe 5e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e942:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e945:	74 17                	je     f011e95e <test_kheap_virt_addr+0x402>
f011e947:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e94e:	83 ec 0c             	sub    $0xc,%esp
f011e951:	68 40 e7 12 f0       	push   $0xf012e740
f011e956:	e8 11 26 fe ff       	call   f0100f6c <cprintf>
f011e95b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e95e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e961:	e8 a3 f0 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e966:	29 c3                	sub    %eax,%ebx
f011e968:	89 d8                	mov    %ebx,%eax
f011e96a:	83 f8 01             	cmp    $0x1,%eax
f011e96d:	77 17                	ja     f011e986 <test_kheap_virt_addr+0x42a>
f011e96f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e976:	83 ec 0c             	sub    $0xc,%esp
f011e979:	68 ac e7 12 f0       	push   $0xf012e7ac
f011e97e:	e8 e9 25 fe ff       	call   f0100f6c <cprintf>
f011e983:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011e986:	e8 7e f0 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e98b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e98e:	e8 ad 5e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e993:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011e996:	83 ec 0c             	sub    $0xc,%esp
f011e999:	68 00 fc 2f 00       	push   $0x2ffc00
f011e99e:	e8 13 a1 fe ff       	call   f0108ab6 <kmalloc>
f011e9a3:	83 c4 10             	add    $0x10,%esp
f011e9a6:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e9ac:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011e9b2:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011e9b7:	74 17                	je     f011e9d0 <test_kheap_virt_addr+0x474>
f011e9b9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e9c0:	83 ec 0c             	sub    $0xc,%esp
f011e9c3:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011e9c8:	e8 9f 25 fe ff       	call   f0100f6c <cprintf>
f011e9cd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e9d0:	e8 6b 5e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011e9d5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e9d8:	74 17                	je     f011e9f1 <test_kheap_virt_addr+0x495>
f011e9da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e9e1:	83 ec 0c             	sub    $0xc,%esp
f011e9e4:	68 40 e7 12 f0       	push   $0xf012e740
f011e9e9:	e8 7e 25 fe ff       	call   f0100f6c <cprintf>
f011e9ee:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e9f1:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e9f4:	e8 10 f0 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011e9f9:	29 c3                	sub    %eax,%ebx
f011e9fb:	89 d8                	mov    %ebx,%eax
f011e9fd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ea02:	77 17                	ja     f011ea1b <test_kheap_virt_addr+0x4bf>
f011ea04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ea0b:	83 ec 0c             	sub    $0xc,%esp
f011ea0e:	68 ac e7 12 f0       	push   $0xf012e7ac
f011ea13:	e8 54 25 fe ff       	call   f0100f6c <cprintf>
f011ea18:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011ea1b:	e8 e9 ef fe ff       	call   f010da09 <sys_calculate_free_frames>
f011ea20:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ea23:	e8 18 5e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ea28:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011ea2b:	83 ec 0c             	sub    $0xc,%esp
f011ea2e:	68 00 fc 5f 00       	push   $0x5ffc00
f011ea33:	e8 7e a0 fe ff       	call   f0108ab6 <kmalloc>
f011ea38:	83 c4 10             	add    $0x10,%esp
f011ea3b:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ea41:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011ea47:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011ea4c:	74 17                	je     f011ea65 <test_kheap_virt_addr+0x509>
f011ea4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ea55:	83 ec 0c             	sub    $0xc,%esp
f011ea58:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011ea5d:	e8 0a 25 fe ff       	call   f0100f6c <cprintf>
f011ea62:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ea65:	e8 d6 5d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ea6a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ea6d:	74 17                	je     f011ea86 <test_kheap_virt_addr+0x52a>
f011ea6f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ea76:	83 ec 0c             	sub    $0xc,%esp
f011ea79:	68 40 e7 12 f0       	push   $0xf012e740
f011ea7e:	e8 e9 24 fe ff       	call   f0100f6c <cprintf>
f011ea83:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ea86:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ea89:	e8 7b ef fe ff       	call   f010da09 <sys_calculate_free_frames>
f011ea8e:	29 c3                	sub    %eax,%ebx
f011ea90:	89 d8                	mov    %ebx,%eax
f011ea92:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ea97:	77 17                	ja     f011eab0 <test_kheap_virt_addr+0x554>
f011ea99:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eaa0:	83 ec 0c             	sub    $0xc,%esp
f011eaa3:	68 ac e7 12 f0       	push   $0xf012e7ac
f011eaa8:	e8 bf 24 fe ff       	call   f0100f6c <cprintf>
f011eaad:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011eab0:	e8 54 ef fe ff       	call   f010da09 <sys_calculate_free_frames>
f011eab5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011eab8:	e8 83 5d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011eabd:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011eac0:	83 ec 0c             	sub    $0xc,%esp
f011eac3:	68 00 38 00 00       	push   $0x3800
f011eac8:	e8 e9 9f fe ff       	call   f0108ab6 <kmalloc>
f011eacd:	83 c4 10             	add    $0x10,%esp
f011ead0:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ead6:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011eadc:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011eae1:	74 17                	je     f011eafa <test_kheap_virt_addr+0x59e>
f011eae3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eaea:	83 ec 0c             	sub    $0xc,%esp
f011eaed:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011eaf2:	e8 75 24 fe ff       	call   f0100f6c <cprintf>
f011eaf7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011eafa:	e8 41 5d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011eaff:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011eb02:	74 17                	je     f011eb1b <test_kheap_virt_addr+0x5bf>
f011eb04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eb0b:	83 ec 0c             	sub    $0xc,%esp
f011eb0e:	68 40 e7 12 f0       	push   $0xf012e740
f011eb13:	e8 54 24 fe ff       	call   f0100f6c <cprintf>
f011eb18:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011eb1b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011eb1e:	e8 e6 ee fe ff       	call   f010da09 <sys_calculate_free_frames>
f011eb23:	29 c3                	sub    %eax,%ebx
f011eb25:	89 d8                	mov    %ebx,%eax
f011eb27:	83 f8 03             	cmp    $0x3,%eax
f011eb2a:	77 17                	ja     f011eb43 <test_kheap_virt_addr+0x5e7>
f011eb2c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eb33:	83 ec 0c             	sub    $0xc,%esp
f011eb36:	68 ac e7 12 f0       	push   $0xf012e7ac
f011eb3b:	e8 2c 24 fe ff       	call   f0100f6c <cprintf>
f011eb40:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011eb43:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011eb4a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011eb4d:	c1 e8 0c             	shr    $0xc,%eax
f011eb50:	89 c2                	mov    %eax,%edx
f011eb52:	4a                   	dec    %edx
f011eb53:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011eb56:	c1 e0 02             	shl    $0x2,%eax
f011eb59:	8d 50 03             	lea    0x3(%eax),%edx
f011eb5c:	b8 10 00 00 00       	mov    $0x10,%eax
f011eb61:	48                   	dec    %eax
f011eb62:	01 d0                	add    %edx,%eax
f011eb64:	bf 10 00 00 00       	mov    $0x10,%edi
f011eb69:	ba 00 00 00 00       	mov    $0x0,%edx
f011eb6e:	f7 f7                	div    %edi
f011eb70:	6b c0 10             	imul   $0x10,%eax,%eax
f011eb73:	29 c4                	sub    %eax,%esp
f011eb75:	89 e0                	mov    %esp,%eax
f011eb77:	83 c0 03             	add    $0x3,%eax
f011eb7a:	c1 e8 02             	shr    $0x2,%eax
f011eb7d:	c1 e0 02             	shl    $0x2,%eax
f011eb80:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011eb83:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011eb86:	c1 e8 0c             	shr    $0xc,%eax
f011eb89:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011eb8c:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011eb93:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011eb98:	05 00 10 00 00       	add    $0x1000,%eax
f011eb9d:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011eba0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011eba7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ebaa:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ebad:	e9 2d 01 00 00       	jmp    f011ecdf <test_kheap_virt_addr+0x783>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ebb2:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011ebb7:	83 ec 04             	sub    $0x4,%esp
f011ebba:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011ebc0:	52                   	push   %edx
f011ebc1:	ff 75 dc             	pushl  -0x24(%ebp)
f011ebc4:	50                   	push   %eax
f011ebc5:	e8 43 98 fe ff       	call   f010840d <get_page_table>
f011ebca:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ebcd:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ebd3:	85 c0                	test   %eax,%eax
f011ebd5:	75 1e                	jne    f011ebf5 <test_kheap_virt_addr+0x699>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ebd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ebde:	83 ec 04             	sub    $0x4,%esp
f011ebe1:	68 98 ed 12 f0       	push   $0xf012ed98
f011ebe6:	68 5e 06 00 00       	push   $0x65e
f011ebeb:	68 f2 ed 12 f0       	push   $0xf012edf2
f011ebf0:	e8 25 17 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ebf5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ebf8:	c1 e8 0c             	shr    $0xc,%eax
f011ebfb:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ec00:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011ec03:	e9 ba 00 00 00       	jmp    f011ecc2 <test_kheap_virt_addr+0x766>
			{
				uint32 offset = j;
f011ec08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ec0b:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011ec0e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ec14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ec17:	c1 e2 02             	shl    $0x2,%edx
f011ec1a:	01 d0                	add    %edx,%eax
f011ec1c:	8b 00                	mov    (%eax),%eax
f011ec1e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ec23:	89 c2                	mov    %eax,%edx
f011ec25:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ec28:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ec2b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ec2e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ec31:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ec34:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ec37:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ec3a:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ec3d:	83 ec 0c             	sub    $0xc,%esp
f011ec40:	50                   	push   %eax
f011ec41:	e8 a4 9e fe ff       	call   f0108aea <kheap_virtual_address>
f011ec46:	83 c4 10             	add    $0x10,%esp
f011ec49:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011ec4c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ec4f:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ec52:	01 d0                	add    %edx,%eax
f011ec54:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ec57:	74 5c                	je     f011ecb5 <test_kheap_virt_addr+0x759>
				{
					if (correct)
f011ec59:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ec5d:	74 56                	je     f011ecb5 <test_kheap_virt_addr+0x759>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011ec5f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ec62:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ec65:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ec68:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011ec6e:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011ec71:	c1 e1 02             	shl    $0x2,%ecx
f011ec74:	01 ca                	add    %ecx,%edx
f011ec76:	8b 12                	mov    (%edx),%edx
f011ec78:	89 d1                	mov    %edx,%ecx
f011ec7a:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011ec80:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011ec83:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ec86:	01 da                	add    %ebx,%edx
f011ec88:	83 ec 0c             	sub    $0xc,%esp
f011ec8b:	50                   	push   %eax
f011ec8c:	51                   	push   %ecx
f011ec8d:	52                   	push   %edx
f011ec8e:	ff 75 8c             	pushl  -0x74(%ebp)
f011ec91:	68 5c ee 12 f0       	push   $0xf012ee5c
f011ec96:	e8 d1 22 fe ff       	call   f0100f6c <cprintf>
f011ec9b:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011ec9e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eca5:	83 ec 0c             	sub    $0xc,%esp
f011eca8:	68 9f ee 12 f0       	push   $0xf012ee9f
f011ecad:	e8 ba 22 fe ff       	call   f0100f6c <cprintf>
f011ecb2:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011ecb5:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ecbc:	ff 45 d4             	incl   -0x2c(%ebp)
f011ecbf:	ff 45 d8             	incl   -0x28(%ebp)
f011ecc2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ecc5:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ecc8:	7d 15                	jge    f011ecdf <test_kheap_virt_addr+0x783>
f011ecca:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011ecd1:	7f 0c                	jg     f011ecdf <test_kheap_virt_addr+0x783>
f011ecd3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ecd6:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011ecd9:	0f 82 29 ff ff ff    	jb     f011ec08 <test_kheap_virt_addr+0x6ac>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011ecdf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ece2:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011ece5:	0f 82 c7 fe ff ff    	jb     f011ebb2 <test_kheap_virt_addr+0x656>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011eceb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ecef:	74 04                	je     f011ecf5 <test_kheap_virt_addr+0x799>
f011ecf1:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011ecf5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011ecfc:	e8 08 ed fe ff       	call   f010da09 <sys_calculate_free_frames>
f011ed01:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011ed04:	e8 37 5b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ed09:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011ed0c:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ed12:	83 ec 0c             	sub    $0xc,%esp
f011ed15:	50                   	push   %eax
f011ed16:	e8 b5 9d fe ff       	call   f0108ad0 <kfree>
f011ed1b:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ed1e:	e8 1d 5b fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ed23:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ed26:	74 17                	je     f011ed3f <test_kheap_virt_addr+0x7e3>
f011ed28:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ed2f:	83 ec 0c             	sub    $0xc,%esp
f011ed32:	68 40 e7 12 f0       	push   $0xf012e740
f011ed37:	e8 30 22 fe ff       	call   f0100f6c <cprintf>
f011ed3c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ed3f:	e8 c5 ec fe ff       	call   f010da09 <sys_calculate_free_frames>
f011ed44:	89 c2                	mov    %eax,%edx
f011ed46:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ed49:	29 c2                	sub    %eax,%edx
f011ed4b:	89 d0                	mov    %edx,%eax
f011ed4d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ed52:	77 17                	ja     f011ed6b <test_kheap_virt_addr+0x80f>
f011ed54:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ed5b:	83 ec 0c             	sub    $0xc,%esp
f011ed5e:	68 44 eb 12 f0       	push   $0xf012eb44
f011ed63:	e8 04 22 fe ff       	call   f0100f6c <cprintf>
f011ed68:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ed6b:	e8 99 ec fe ff       	call   f010da09 <sys_calculate_free_frames>
f011ed70:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ed73:	e8 c8 5a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ed78:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011ed7b:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ed81:	83 ec 0c             	sub    $0xc,%esp
f011ed84:	50                   	push   %eax
f011ed85:	e8 46 9d fe ff       	call   f0108ad0 <kfree>
f011ed8a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ed8d:	e8 ae 5a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ed92:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ed95:	74 17                	je     f011edae <test_kheap_virt_addr+0x852>
f011ed97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ed9e:	83 ec 0c             	sub    $0xc,%esp
f011eda1:	68 40 e7 12 f0       	push   $0xf012e740
f011eda6:	e8 c1 21 fe ff       	call   f0100f6c <cprintf>
f011edab:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011edae:	e8 56 ec fe ff       	call   f010da09 <sys_calculate_free_frames>
f011edb3:	89 c2                	mov    %eax,%edx
f011edb5:	8b 45 88             	mov    -0x78(%ebp),%eax
f011edb8:	29 c2                	sub    %eax,%edx
f011edba:	89 d0                	mov    %edx,%eax
f011edbc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011edc1:	77 17                	ja     f011edda <test_kheap_virt_addr+0x87e>
f011edc3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011edca:	83 ec 0c             	sub    $0xc,%esp
f011edcd:	68 44 eb 12 f0       	push   $0xf012eb44
f011edd2:	e8 95 21 fe ff       	call   f0100f6c <cprintf>
f011edd7:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011edda:	e8 2a ec fe ff       	call   f010da09 <sys_calculate_free_frames>
f011eddf:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ede2:	e8 59 5a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ede7:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011edea:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011edf0:	83 ec 0c             	sub    $0xc,%esp
f011edf3:	50                   	push   %eax
f011edf4:	e8 d7 9c fe ff       	call   f0108ad0 <kfree>
f011edf9:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011edfc:	e8 3f 5a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011ee01:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ee04:	74 17                	je     f011ee1d <test_kheap_virt_addr+0x8c1>
f011ee06:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ee0d:	83 ec 0c             	sub    $0xc,%esp
f011ee10:	68 40 e7 12 f0       	push   $0xf012e740
f011ee15:	e8 52 21 fe ff       	call   f0100f6c <cprintf>
f011ee1a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ee1d:	e8 e7 eb fe ff       	call   f010da09 <sys_calculate_free_frames>
f011ee22:	89 c2                	mov    %eax,%edx
f011ee24:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ee27:	29 c2                	sub    %eax,%edx
f011ee29:	89 d0                	mov    %edx,%eax
f011ee2b:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ee30:	77 17                	ja     f011ee49 <test_kheap_virt_addr+0x8ed>
f011ee32:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ee39:	83 ec 0c             	sub    $0xc,%esp
f011ee3c:	68 44 eb 12 f0       	push   $0xf012eb44
f011ee41:	e8 26 21 fe ff       	call   f0100f6c <cprintf>
f011ee46:	83 c4 10             	add    $0x10,%esp


	//test kheap_virtual_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ee49:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ee50:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011ee55:	05 00 10 00 00       	add    $0x1000,%eax
f011ee5a:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011ee60:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011ee67:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011ee6e:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011ee71:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ee77:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011ee7a:	eb 44                	jmp    f011eec0 <test_kheap_virt_addr+0x964>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ee7c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ee7f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ee82:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ee85:	83 ec 0c             	sub    $0xc,%esp
f011ee88:	50                   	push   %eax
f011ee89:	e8 5c 9c fe ff       	call   f0108aea <kheap_virtual_address>
f011ee8e:	83 c4 10             	add    $0x10,%esp
f011ee91:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011ee97:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011ee9e:	74 1d                	je     f011eebd <test_kheap_virt_addr+0x961>
			{
				if (correct)
f011eea0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011eea4:	74 17                	je     f011eebd <test_kheap_virt_addr+0x961>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011eea6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eead:	83 ec 0c             	sub    $0xc,%esp
f011eeb0:	68 9f ee 12 f0       	push   $0xf012ee9f
f011eeb5:	e8 b2 20 fe ff       	call   f0100f6c <cprintf>
f011eeba:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011eebd:	ff 45 d0             	incl   -0x30(%ebp)
f011eec0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011eec6:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011eecc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eecf:	39 c2                	cmp    %eax,%edx
f011eed1:	77 a9                	ja     f011ee7c <test_kheap_virt_addr+0x920>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011eed3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011eed9:	05 00 04 00 00       	add    $0x400,%eax
f011eede:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011eee1:	eb 64                	jmp    f011ef47 <test_kheap_virt_addr+0x9eb>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011eee3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eee6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011eee9:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011eeec:	83 ec 0c             	sub    $0xc,%esp
f011eeef:	50                   	push   %eax
f011eef0:	e8 f5 9b fe ff       	call   f0108aea <kheap_virtual_address>
f011eef5:	83 c4 10             	add    $0x10,%esp
f011eef8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011eefe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef01:	c1 e0 0c             	shl    $0xc,%eax
f011ef04:	89 c2                	mov    %eax,%edx
f011ef06:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011ef0c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ef0f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ef12:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ef15:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ef18:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ef1d:	01 c8                	add    %ecx,%eax
f011ef1f:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011ef25:	74 1d                	je     f011ef44 <test_kheap_virt_addr+0x9e8>
			{
				if (correct)
f011ef27:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ef2b:	74 17                	je     f011ef44 <test_kheap_virt_addr+0x9e8>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011ef2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ef34:	83 ec 0c             	sub    $0xc,%esp
f011ef37:	68 9f ee 12 f0       	push   $0xf012ee9f
f011ef3c:	e8 2b 20 fe ff       	call   f0100f6c <cprintf>
f011ef41:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011ef44:	ff 45 d0             	incl   -0x30(%ebp)
f011ef47:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ef4d:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011ef53:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef56:	39 c2                	cmp    %eax,%edx
f011ef58:	77 89                	ja     f011eee3 <test_kheap_virt_addr+0x987>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011ef5a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ef60:	05 02 07 00 00       	add    $0x702,%eax
f011ef65:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011ef68:	eb 44                	jmp    f011efae <test_kheap_virt_addr+0xa52>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ef6a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ef6d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ef70:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ef73:	83 ec 0c             	sub    $0xc,%esp
f011ef76:	50                   	push   %eax
f011ef77:	e8 6e 9b fe ff       	call   f0108aea <kheap_virtual_address>
f011ef7c:	83 c4 10             	add    $0x10,%esp
f011ef7f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011ef85:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011ef8c:	74 1d                	je     f011efab <test_kheap_virt_addr+0xa4f>
			{
				if (correct)
f011ef8e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ef92:	74 17                	je     f011efab <test_kheap_virt_addr+0xa4f>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011ef94:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ef9b:	83 ec 0c             	sub    $0xc,%esp
f011ef9e:	68 9f ee 12 f0       	push   $0xf012ee9f
f011efa3:	e8 c4 1f fe ff       	call   f0100f6c <cprintf>
f011efa8:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011efab:	ff 45 d0             	incl   -0x30(%ebp)
f011efae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011efb4:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011efba:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011efbd:	39 c2                	cmp    %eax,%edx
f011efbf:	77 a9                	ja     f011ef6a <test_kheap_virt_addr+0xa0e>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011efc1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011efc7:	05 02 0d 00 00       	add    $0xd02,%eax
f011efcc:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011efcf:	eb 64                	jmp    f011f035 <test_kheap_virt_addr+0xad9>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011efd1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011efd4:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011efd7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011efda:	83 ec 0c             	sub    $0xc,%esp
f011efdd:	50                   	push   %eax
f011efde:	e8 07 9b fe ff       	call   f0108aea <kheap_virtual_address>
f011efe3:	83 c4 10             	add    $0x10,%esp
f011efe6:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011efec:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011efef:	c1 e0 0c             	shl    $0xc,%eax
f011eff2:	89 c2                	mov    %eax,%edx
f011eff4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011effa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011effd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011f000:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011f003:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011f006:	25 ff 0f 00 00       	and    $0xfff,%eax
f011f00b:	01 c8                	add    %ecx,%eax
f011f00d:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011f013:	74 1d                	je     f011f032 <test_kheap_virt_addr+0xad6>
			{
				if (correct)
f011f015:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f019:	74 17                	je     f011f032 <test_kheap_virt_addr+0xad6>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011f01b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011f022:	83 ec 0c             	sub    $0xc,%esp
f011f025:	68 9f ee 12 f0       	push   $0xf012ee9f
f011f02a:	e8 3d 1f fe ff       	call   f0100f6c <cprintf>
f011f02f:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011f032:	ff 45 d0             	incl   -0x30(%ebp)
f011f035:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011f03b:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011f041:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f044:	39 c2                	cmp    %eax,%edx
f011f046:	77 89                	ja     f011efd1 <test_kheap_virt_addr+0xa75>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011f048:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f04c:	74 04                	je     f011f052 <test_kheap_virt_addr+0xaf6>
f011f04e:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011f052:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011f059:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011f060:	e9 d1 00 00 00       	jmp    f011f136 <test_kheap_virt_addr+0xbda>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011f065:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f011f06a:	83 ec 04             	sub    $0x4,%esp
f011f06d:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011f073:	52                   	push   %edx
f011f074:	ff 75 cc             	pushl  -0x34(%ebp)
f011f077:	50                   	push   %eax
f011f078:	e8 90 93 fe ff       	call   f010840d <get_page_table>
f011f07d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011f080:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011f086:	85 c0                	test   %eax,%eax
f011f088:	75 1e                	jne    f011f0a8 <test_kheap_virt_addr+0xb4c>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011f08a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011f091:	83 ec 04             	sub    $0x4,%esp
f011f094:	68 98 ed 12 f0       	push   $0xf012ed98
f011f099:	68 cb 06 00 00       	push   $0x6cb
f011f09e:	68 f2 ed 12 f0       	push   $0xf012edf2
f011f0a3:	e8 72 12 fe ff       	call   f010031a <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011f0a8:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011f0ae:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011f0b1:	c1 ea 0c             	shr    $0xc,%edx
f011f0b4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011f0ba:	c1 e2 02             	shl    $0x2,%edx
f011f0bd:	01 d0                	add    %edx,%eax
f011f0bf:	8b 00                	mov    (%eax),%eax
f011f0c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f0c6:	89 c2                	mov    %eax,%edx
f011f0c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f0cb:	25 ff 0f 00 00       	and    $0xfff,%eax
f011f0d0:	01 d0                	add    %edx,%eax
f011f0d2:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011f0d8:	83 ec 0c             	sub    $0xc,%esp
f011f0db:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011f0e1:	e8 04 9a fe ff       	call   f0108aea <kheap_virtual_address>
f011f0e6:	83 c4 10             	add    $0x10,%esp
f011f0e9:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011f0ef:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f0f5:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011f0f8:	74 39                	je     f011f133 <test_kheap_virt_addr+0xbd7>
			{
				if (correct)
f011f0fa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f0fe:	74 33                	je     f011f133 <test_kheap_virt_addr+0xbd7>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011f100:	ff 75 cc             	pushl  -0x34(%ebp)
f011f103:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011f109:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011f10f:	68 bc ee 12 f0       	push   $0xf012eebc
f011f114:	e8 53 1e fe ff       	call   f0100f6c <cprintf>
f011f119:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011f11c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011f123:	83 ec 0c             	sub    $0xc,%esp
f011f126:	68 9f ee 12 f0       	push   $0xf012ee9f
f011f12b:	e8 3c 1e fe ff       	call   f0100f6c <cprintf>
f011f130:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011f133:	ff 45 cc             	incl   -0x34(%ebp)
f011f136:	83 ec 0c             	sub    $0xc,%esp
f011f139:	6a 00                	push   $0x0
f011f13b:	e8 6c 99 fe ff       	call   f0108aac <sbrk>
f011f140:	83 c4 10             	add    $0x10,%esp
f011f143:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011f146:	0f 87 19 ff ff ff    	ja     f011f065 <test_kheap_virt_addr+0xb09>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011f14c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f150:	74 04                	je     f011f156 <test_kheap_virt_addr+0xbfa>
f011f152:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011f156:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011f15d:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011f164:	eb 5a                	jmp    f011f1c0 <test_kheap_virt_addr+0xc64>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011f166:	83 ec 0c             	sub    $0xc,%esp
f011f169:	ff 75 c8             	pushl  -0x38(%ebp)
f011f16c:	e8 79 99 fe ff       	call   f0108aea <kheap_virtual_address>
f011f171:	83 c4 10             	add    $0x10,%esp
f011f174:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011f17a:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011f181:	74 36                	je     f011f1b9 <test_kheap_virt_addr+0xc5d>
			{
				if (correct)
f011f183:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f187:	74 30                	je     f011f1b9 <test_kheap_virt_addr+0xc5d>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011f189:	83 ec 04             	sub    $0x4,%esp
f011f18c:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011f192:	ff 75 c8             	pushl  -0x38(%ebp)
f011f195:	68 e8 ee 12 f0       	push   $0xf012eee8
f011f19a:	e8 cd 1d fe ff       	call   f0100f6c <cprintf>
f011f19f:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011f1a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011f1a9:	83 ec 0c             	sub    $0xc,%esp
f011f1ac:	68 9f ee 12 f0       	push   $0xf012ee9f
f011f1b1:	e8 b6 1d fe ff       	call   f0100f6c <cprintf>
f011f1b6:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011f1b9:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011f1c0:	b8 30 64 5c 00       	mov    $0x5c6430,%eax
f011f1c5:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011f1c8:	72 9c                	jb     f011f166 <test_kheap_virt_addr+0xc0a>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011f1ca:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f1ce:	74 04                	je     f011f1d4 <test_kheap_virt_addr+0xc78>
f011f1d0:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011f1d4:	83 ec 08             	sub    $0x8,%esp
f011f1d7:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f1da:	68 04 ef 12 f0       	push   $0xf012ef04
f011f1df:	e8 88 1d fe ff       	call   f0100f6c <cprintf>
f011f1e4:	83 c4 10             	add    $0x10,%esp

	return 1;
f011f1e7:	b8 01 00 00 00       	mov    $0x1,%eax
f011f1ec:	89 f4                	mov    %esi,%esp

}
f011f1ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011f1f1:	5b                   	pop    %ebx
f011f1f2:	5e                   	pop    %esi
f011f1f3:	5f                   	pop    %edi
f011f1f4:	5d                   	pop    %ebp
f011f1f5:	c3                   	ret    

f011f1f6 <test_ksbrk>:


// 2023
int test_ksbrk()
{
f011f1f6:	55                   	push   %ebp
f011f1f7:	89 e5                	mov    %esp,%ebp
f011f1f9:	57                   	push   %edi
f011f1fa:	56                   	push   %esi
f011f1fb:	53                   	push   %ebx
f011f1fc:	81 ec 1c 01 00 00    	sub    $0x11c,%esp

	// malloc some spaces
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	// int lastIndices[20] = {0};
	int sums[20] = {0};
f011f202:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
f011f208:	b9 14 00 00 00       	mov    $0x14,%ecx
f011f20d:	b8 00 00 00 00       	mov    $0x0,%eax
f011f212:	89 d7                	mov    %edx,%edi
f011f214:	f3 ab                	rep stos %eax,%es:(%edi)
	void *ptr_allocations[20] = {0};
f011f216:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011f21c:	b9 14 00 00 00       	mov    $0x14,%ecx
f011f221:	b8 00 00 00 00       	mov    $0x0,%eax
f011f226:	89 d7                	mov    %edx,%edi
f011f228:	f3 ab                	rep stos %eax,%es:(%edi)

	// uint32 inputIncrementValues[] = {0, kilo, 2*kilo, -512, -2 * kilo, -2* kilo, 128, kilo};
	uint32 expectedVAs[] = {
f011f22a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011f230:	bb a0 f4 12 f0       	mov    $0xf012f4a0,%ebx
f011f235:	ba 0a 00 00 00       	mov    $0xa,%edx
f011f23a:	89 c7                	mov    %eax,%edi
f011f23c:	89 de                	mov    %ebx,%esi
f011f23e:	89 d1                	mov    %edx,%ecx
f011f240:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1E00, // 128
			KERNEL_HEAP_START + 0x2000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x0C00, // +6*kilo
	};
	uint32 expectedSbrks[] = {
f011f242:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f011f248:	bb e0 f4 12 f0       	mov    $0xf012f4e0,%ebx
f011f24d:	ba 0a 00 00 00       	mov    $0xa,%edx
f011f252:	89 c7                	mov    %eax,%edi
f011f254:	89 de                	mov    %ebx,%esi
f011f256:	89 d1                	mov    %edx,%ecx
f011f258:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x3000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x4000, // +10*kilo
	};
	uint32 oldBrk, newBrk;
	int eval = 0;
f011f25a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011f261:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	cprintf("STEP A: checking increment with ZERO\n");
f011f268:	83 ec 0c             	sub    $0xc,%esp
f011f26b:	68 38 ef 12 f0       	push   $0xf012ef38
f011f270:	e8 f7 1c fe ff       	call   f0100f6c <cprintf>
f011f275:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames();
f011f278:	e8 8c e7 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f27d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f280:	e8 bb 55 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f285:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[0] = sbrk(0);
f011f288:	83 ec 0c             	sub    $0xc,%esp
f011f28b:	6a 00                	push   $0x0
f011f28d:	e8 1a 98 fe ff       	call   f0108aac <sbrk>
f011f292:	83 c4 10             	add    $0x10,%esp
f011f295:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f29b:	e8 a0 55 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f2a0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f2a3:	74 17                	je     f011f2bc <test_ksbrk+0xc6>
		{
			correct = 0;
f011f2a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f2ac:	83 ec 0c             	sub    $0xc,%esp
f011f2af:	68 60 ef 12 f0       	push   $0xf012ef60
f011f2b4:	e8 b3 1c fe ff       	call   f0100f6c <cprintf>
f011f2b9:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011f2bc:	e8 48 e7 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f2c1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f2c4:	74 17                	je     f011f2dd <test_ksbrk+0xe7>
		{
			correct = 0;
f011f2c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f2cd:	83 ec 0c             	sub    $0xc,%esp
f011f2d0:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f2d5:	e8 92 1c fe ff       	call   f0100f6c <cprintf>
f011f2da:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[0] != expectedVAs[0])
f011f2dd:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011f2e3:	89 c2                	mov    %eax,%edx
f011f2e5:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011f2eb:	39 c2                	cmp    %eax,%edx
f011f2ed:	74 25                	je     f011f314 <test_ksbrk+0x11e>
		{
			correct = 0;
f011f2ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[0], ptr_allocations[0]);
f011f2f6:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011f2fc:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011f302:	83 ec 04             	sub    $0x4,%esp
f011f305:	52                   	push   %edx
f011f306:	50                   	push   %eax
f011f307:	68 08 f0 12 f0       	push   $0xf012f008
f011f30c:	e8 5b 1c fe ff       	call   f0100f6c <cprintf>
f011f311:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f314:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f318:	74 04                	je     f011f31e <test_ksbrk+0x128>
			eval += 5;
f011f31a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP B: checking increment with +ve value\n");
f011f31e:	83 ec 0c             	sub    $0xc,%esp
f011f321:	68 38 f0 12 f0       	push   $0xf012f038
f011f326:	e8 41 1c fe ff       	call   f0100f6c <cprintf>
f011f32b:	83 c4 10             	add    $0x10,%esp
	{ // +1 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f32e:	e8 d6 e6 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f333:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f336:	e8 05 55 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f33b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f33e:	83 ec 0c             	sub    $0xc,%esp
f011f341:	6a 00                	push   $0x0
f011f343:	e8 64 97 fe ff       	call   f0108aac <sbrk>
f011f348:	83 c4 10             	add    $0x10,%esp
f011f34b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[1] = sbrk(kilo);
f011f34e:	83 ec 0c             	sub    $0xc,%esp
f011f351:	68 00 04 00 00       	push   $0x400
f011f356:	e8 51 97 fe ff       	call   f0108aac <sbrk>
f011f35b:	83 c4 10             	add    $0x10,%esp
f011f35e:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		newBrk = (uint32)sbrk(0);
f011f364:	83 ec 0c             	sub    $0xc,%esp
f011f367:	6a 00                	push   $0x0
f011f369:	e8 3e 97 fe ff       	call   f0108aac <sbrk>
f011f36e:	83 c4 10             	add    $0x10,%esp
f011f371:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f374:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f37b:	e8 c0 54 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f380:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f383:	74 17                	je     f011f39c <test_ksbrk+0x1a6>
		{
			correct = 0;
f011f385:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f38c:	83 ec 0c             	sub    $0xc,%esp
f011f38f:	68 60 ef 12 f0       	push   $0xf012ef60
f011f394:	e8 d3 1b fe ff       	call   f0100f6c <cprintf>
f011f399:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011f39c:	e8 68 e6 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f3a1:	89 c2                	mov    %eax,%edx
f011f3a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f3a6:	29 d0                	sub    %edx,%eax
f011f3a8:	83 f8 01             	cmp    $0x1,%eax
f011f3ab:	74 17                	je     f011f3c4 <test_ksbrk+0x1ce>
		{
			correct = 0;
f011f3ad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f3b4:	83 ec 0c             	sub    $0xc,%esp
f011f3b7:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f3bc:	e8 ab 1b fe ff       	call   f0100f6c <cprintf>
f011f3c1:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[1] != expectedVAs[1])
f011f3c4:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011f3ca:	89 c2                	mov    %eax,%edx
f011f3cc:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011f3d2:	39 c2                	cmp    %eax,%edx
f011f3d4:	74 25                	je     f011f3fb <test_ksbrk+0x205>
		{
			correct = 0;
f011f3d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[1], ptr_allocations[1]);
f011f3dd:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011f3e3:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011f3e9:	83 ec 04             	sub    $0x4,%esp
f011f3ec:	52                   	push   %edx
f011f3ed:	50                   	push   %eax
f011f3ee:	68 08 f0 12 f0       	push   $0xf012f008
f011f3f3:	e8 74 1b fe ff       	call   f0100f6c <cprintf>
f011f3f8:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[1])
f011f3fb:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011f401:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f404:	74 21                	je     f011f427 <test_ksbrk+0x231>
		{
			correct = 0;
f011f406:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[1]);
f011f40d:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011f413:	83 ec 04             	sub    $0x4,%esp
f011f416:	50                   	push   %eax
f011f417:	ff 75 d0             	pushl  -0x30(%ebp)
f011f41a:	68 64 f0 12 f0       	push   $0xf012f064
f011f41f:	e8 48 1b fe ff       	call   f0100f6c <cprintf>
f011f424:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f427:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f42b:	74 04                	je     f011f431 <test_ksbrk+0x23b>
			eval += 5;
f011f42d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	{ // +2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f431:	e8 d3 e5 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f436:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f439:	e8 02 54 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f43e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f441:	83 ec 0c             	sub    $0xc,%esp
f011f444:	6a 00                	push   $0x0
f011f446:	e8 61 96 fe ff       	call   f0108aac <sbrk>
f011f44b:	83 c4 10             	add    $0x10,%esp
f011f44e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[2] = sbrk(2 * kilo);
f011f451:	83 ec 0c             	sub    $0xc,%esp
f011f454:	68 00 08 00 00       	push   $0x800
f011f459:	e8 4e 96 fe ff       	call   f0108aac <sbrk>
f011f45e:	83 c4 10             	add    $0x10,%esp
f011f461:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		newBrk = (uint32)sbrk(0);
f011f467:	83 ec 0c             	sub    $0xc,%esp
f011f46a:	6a 00                	push   $0x0
f011f46c:	e8 3b 96 fe ff       	call   f0108aac <sbrk>
f011f471:	83 c4 10             	add    $0x10,%esp
f011f474:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f477:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f47e:	e8 bd 53 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f483:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f486:	74 17                	je     f011f49f <test_ksbrk+0x2a9>
		{
			correct = 0;
f011f488:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f48f:	83 ec 0c             	sub    $0xc,%esp
f011f492:	68 60 ef 12 f0       	push   $0xf012ef60
f011f497:	e8 d0 1a fe ff       	call   f0100f6c <cprintf>
f011f49c:	83 c4 10             	add    $0x10,%esp
		}
		int x = (freeFrames - (int)sys_calculate_free_frames());
f011f49f:	e8 65 e5 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f4a4:	89 c2                	mov    %eax,%edx
f011f4a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f4a9:	29 d0                	sub    %edx,%eax
f011f4ab:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011f4ae:	e8 56 e5 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f4b3:	89 c2                	mov    %eax,%edx
f011f4b5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f4b8:	29 d0                	sub    %edx,%eax
f011f4ba:	83 f8 01             	cmp    $0x1,%eax
f011f4bd:	74 17                	je     f011f4d6 <test_ksbrk+0x2e0>
		{
			correct = 0;
f011f4bf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f4c6:	83 ec 0c             	sub    $0xc,%esp
f011f4c9:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f4ce:	e8 99 1a fe ff       	call   f0100f6c <cprintf>
f011f4d3:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[2] != expectedVAs[2])
f011f4d6:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f4dc:	89 c2                	mov    %eax,%edx
f011f4de:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011f4e4:	39 c2                	cmp    %eax,%edx
f011f4e6:	74 25                	je     f011f50d <test_ksbrk+0x317>
		{
			correct = 0;
f011f4e8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[2], ptr_allocations[2]);
f011f4ef:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011f4f5:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011f4fb:	83 ec 04             	sub    $0x4,%esp
f011f4fe:	52                   	push   %edx
f011f4ff:	50                   	push   %eax
f011f500:	68 08 f0 12 f0       	push   $0xf012f008
f011f505:	e8 62 1a fe ff       	call   f0100f6c <cprintf>
f011f50a:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[2])
f011f50d:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011f513:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f516:	74 21                	je     f011f539 <test_ksbrk+0x343>
		{
			correct = 0;
f011f518:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[2]);
f011f51f:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011f525:	83 ec 04             	sub    $0x4,%esp
f011f528:	50                   	push   %eax
f011f529:	ff 75 d0             	pushl  -0x30(%ebp)
f011f52c:	68 64 f0 12 f0       	push   $0xf012f064
f011f531:	e8 36 1a fe ff       	call   f0100f6c <cprintf>
f011f536:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f539:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f53d:	74 04                	je     f011f543 <test_ksbrk+0x34d>
			eval += 5;
f011f53f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP C: checking increment with -ve value [No Frames to be Deallocated]\n");
f011f543:	83 ec 0c             	sub    $0xc,%esp
f011f546:	68 90 f0 12 f0       	push   $0xf012f090
f011f54b:	e8 1c 1a fe ff       	call   f0100f6c <cprintf>
f011f550:	83 c4 10             	add    $0x10,%esp
	{ // -512 Bytes
		freeFrames = (int)sys_calculate_free_frames();
f011f553:	e8 b1 e4 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f558:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f55b:	e8 e0 52 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f560:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f563:	83 ec 0c             	sub    $0xc,%esp
f011f566:	6a 00                	push   $0x0
f011f568:	e8 3f 95 fe ff       	call   f0108aac <sbrk>
f011f56d:	83 c4 10             	add    $0x10,%esp
f011f570:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[3] = sbrk(-512);
f011f573:	83 ec 0c             	sub    $0xc,%esp
f011f576:	68 00 fe ff ff       	push   $0xfffffe00
f011f57b:	e8 2c 95 fe ff       	call   f0108aac <sbrk>
f011f580:	83 c4 10             	add    $0x10,%esp
f011f583:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		newBrk = (uint32)sbrk(0);
f011f589:	83 ec 0c             	sub    $0xc,%esp
f011f58c:	6a 00                	push   $0x0
f011f58e:	e8 19 95 fe ff       	call   f0108aac <sbrk>
f011f593:	83 c4 10             	add    $0x10,%esp
f011f596:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f599:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f5a0:	e8 9b 52 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f5a5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f5a8:	74 17                	je     f011f5c1 <test_ksbrk+0x3cb>
		{
			correct = 0;
f011f5aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f5b1:	83 ec 0c             	sub    $0xc,%esp
f011f5b4:	68 60 ef 12 f0       	push   $0xf012ef60
f011f5b9:	e8 ae 19 fe ff       	call   f0100f6c <cprintf>
f011f5be:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011f5c1:	e8 43 e4 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f5c6:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f5c9:	74 17                	je     f011f5e2 <test_ksbrk+0x3ec>
		{
			correct = 0;
f011f5cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f5d2:	83 ec 0c             	sub    $0xc,%esp
f011f5d5:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f5da:	e8 8d 19 fe ff       	call   f0100f6c <cprintf>
f011f5df:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[3] != expectedVAs[3])
f011f5e2:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011f5e8:	89 c2                	mov    %eax,%edx
f011f5ea:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f5f0:	39 c2                	cmp    %eax,%edx
f011f5f2:	74 25                	je     f011f619 <test_ksbrk+0x423>
		{
			correct = 0;
f011f5f4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[3], ptr_allocations[3]);
f011f5fb:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f011f601:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f607:	83 ec 04             	sub    $0x4,%esp
f011f60a:	52                   	push   %edx
f011f60b:	50                   	push   %eax
f011f60c:	68 08 f0 12 f0       	push   $0xf012f008
f011f611:	e8 56 19 fe ff       	call   f0100f6c <cprintf>
f011f616:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[3])
f011f619:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011f61f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f622:	74 21                	je     f011f645 <test_ksbrk+0x44f>
		{
			correct = 0;
f011f624:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[3]);
f011f62b:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011f631:	83 ec 04             	sub    $0x4,%esp
f011f634:	50                   	push   %eax
f011f635:	ff 75 d0             	pushl  -0x30(%ebp)
f011f638:	68 64 f0 12 f0       	push   $0xf012f064
f011f63d:	e8 2a 19 fe ff       	call   f0100f6c <cprintf>
f011f642:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f645:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f649:	74 04                	je     f011f64f <test_ksbrk+0x459>
			eval += 10;
f011f64b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f64f:	e8 b5 e3 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f654:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f657:	e8 e4 51 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f65c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f65f:	83 ec 0c             	sub    $0xc,%esp
f011f662:	6a 00                	push   $0x0
f011f664:	e8 43 94 fe ff       	call   f0108aac <sbrk>
f011f669:	83 c4 10             	add    $0x10,%esp
f011f66c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[4] = sbrk(-2 * kilo);
f011f66f:	83 ec 0c             	sub    $0xc,%esp
f011f672:	68 00 f8 ff ff       	push   $0xfffff800
f011f677:	e8 30 94 fe ff       	call   f0108aac <sbrk>
f011f67c:	83 c4 10             	add    $0x10,%esp
f011f67f:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		newBrk = (uint32)sbrk(0);
f011f685:	83 ec 0c             	sub    $0xc,%esp
f011f688:	6a 00                	push   $0x0
f011f68a:	e8 1d 94 fe ff       	call   f0108aac <sbrk>
f011f68f:	83 c4 10             	add    $0x10,%esp
f011f692:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f695:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f69c:	e8 9f 51 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f6a1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f6a4:	74 17                	je     f011f6bd <test_ksbrk+0x4c7>
		{
			correct = 0;
f011f6a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f6ad:	83 ec 0c             	sub    $0xc,%esp
f011f6b0:	68 60 ef 12 f0       	push   $0xf012ef60
f011f6b5:	e8 b2 18 fe ff       	call   f0100f6c <cprintf>
f011f6ba:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011f6bd:	e8 47 e3 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f6c2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f6c5:	74 17                	je     f011f6de <test_ksbrk+0x4e8>
		{
			correct = 0;
f011f6c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f6ce:	83 ec 0c             	sub    $0xc,%esp
f011f6d1:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f6d6:	e8 91 18 fe ff       	call   f0100f6c <cprintf>
f011f6db:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[4] != expectedVAs[4])
f011f6de:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011f6e4:	89 c2                	mov    %eax,%edx
f011f6e6:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011f6ec:	39 c2                	cmp    %eax,%edx
f011f6ee:	74 25                	je     f011f715 <test_ksbrk+0x51f>
		{
			correct = 0;
f011f6f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[4], ptr_allocations[4]);
f011f6f7:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011f6fd:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011f703:	83 ec 04             	sub    $0x4,%esp
f011f706:	52                   	push   %edx
f011f707:	50                   	push   %eax
f011f708:	68 08 f0 12 f0       	push   $0xf012f008
f011f70d:	e8 5a 18 fe ff       	call   f0100f6c <cprintf>
f011f712:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[4])
f011f715:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011f71b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f71e:	74 21                	je     f011f741 <test_ksbrk+0x54b>
		{
			correct = 0;
f011f720:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[4]);
f011f727:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011f72d:	83 ec 04             	sub    $0x4,%esp
f011f730:	50                   	push   %eax
f011f731:	ff 75 d0             	pushl  -0x30(%ebp)
f011f734:	68 64 f0 12 f0       	push   $0xf012f064
f011f739:	e8 2e 18 fe ff       	call   f0100f6c <cprintf>
f011f73e:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f741:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f745:	74 04                	je     f011f74b <test_ksbrk+0x555>
			eval += 10;
f011f747:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP D: checking increment with -ve value [ONE Frame should be Deallocated]\n");
f011f74b:	83 ec 0c             	sub    $0xc,%esp
f011f74e:	68 dc f0 12 f0       	push   $0xf012f0dc
f011f753:	e8 14 18 fe ff       	call   f0100f6c <cprintf>
f011f758:	83 c4 10             	add    $0x10,%esp
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f75b:	e8 a9 e2 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f760:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f763:	e8 d8 50 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f768:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f76b:	83 ec 0c             	sub    $0xc,%esp
f011f76e:	6a 00                	push   $0x0
f011f770:	e8 37 93 fe ff       	call   f0108aac <sbrk>
f011f775:	83 c4 10             	add    $0x10,%esp
f011f778:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[5] = sbrk(-2 * kilo);
f011f77b:	83 ec 0c             	sub    $0xc,%esp
f011f77e:	68 00 f8 ff ff       	push   $0xfffff800
f011f783:	e8 24 93 fe ff       	call   f0108aac <sbrk>
f011f788:	83 c4 10             	add    $0x10,%esp
f011f78b:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		newBrk = (uint32)sbrk(0);
f011f791:	83 ec 0c             	sub    $0xc,%esp
f011f794:	6a 00                	push   $0x0
f011f796:	e8 11 93 fe ff       	call   f0108aac <sbrk>
f011f79b:	83 c4 10             	add    $0x10,%esp
f011f79e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f7a1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f7a8:	e8 93 50 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f7ad:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f7b0:	74 17                	je     f011f7c9 <test_ksbrk+0x5d3>
		{
			correct = 0;
f011f7b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f7b9:	83 ec 0c             	sub    $0xc,%esp
f011f7bc:	68 60 ef 12 f0       	push   $0xf012ef60
f011f7c1:	e8 a6 17 fe ff       	call   f0100f6c <cprintf>
f011f7c6:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 1)
f011f7c9:	e8 3b e2 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f7ce:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011f7d1:	83 f8 01             	cmp    $0x1,%eax
f011f7d4:	74 17                	je     f011f7ed <test_ksbrk+0x5f7>
		{
			correct = 0;
f011f7d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f7dd:	83 ec 0c             	sub    $0xc,%esp
f011f7e0:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f7e5:	e8 82 17 fe ff       	call   f0100f6c <cprintf>
f011f7ea:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[5] != expectedVAs[5])
f011f7ed:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011f7f3:	89 c2                	mov    %eax,%edx
f011f7f5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011f7fb:	39 c2                	cmp    %eax,%edx
f011f7fd:	74 25                	je     f011f824 <test_ksbrk+0x62e>
		{
			correct = 0;
f011f7ff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011f806:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011f80c:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011f812:	83 ec 04             	sub    $0x4,%esp
f011f815:	52                   	push   %edx
f011f816:	50                   	push   %eax
f011f817:	68 08 f0 12 f0       	push   $0xf012f008
f011f81c:	e8 4b 17 fe ff       	call   f0100f6c <cprintf>
f011f821:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[5])
f011f824:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011f82a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f82d:	74 21                	je     f011f850 <test_ksbrk+0x65a>
		{
			correct = 0;
f011f82f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011f836:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011f83c:	83 ec 04             	sub    $0x4,%esp
f011f83f:	50                   	push   %eax
f011f840:	ff 75 d0             	pushl  -0x30(%ebp)
f011f843:	68 64 f0 12 f0       	push   $0xf012f064
f011f848:	e8 1f 17 fe ff       	call   f0100f6c <cprintf>
f011f84d:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f850:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f854:	74 04                	je     f011f85a <test_ksbrk+0x664>
			eval += 15;
f011f856:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP E: checking increment with +ve value [No Frames to be Allocated]\n");
f011f85a:	83 ec 0c             	sub    $0xc,%esp
f011f85d:	68 2c f1 12 f0       	push   $0xf012f12c
f011f862:	e8 05 17 fe ff       	call   f0100f6c <cprintf>
f011f867:	83 c4 10             	add    $0x10,%esp
	{ // 128 Bytes
		freeFrames = (int)(int)sys_calculate_free_frames();
f011f86a:	e8 9a e1 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f86f:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)(int)pf_calculate_free_frames();
f011f872:	e8 c9 4f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f877:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f87a:	83 ec 0c             	sub    $0xc,%esp
f011f87d:	6a 00                	push   $0x0
f011f87f:	e8 28 92 fe ff       	call   f0108aac <sbrk>
f011f884:	83 c4 10             	add    $0x10,%esp
f011f887:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[6] = sbrk(128);
f011f88a:	83 ec 0c             	sub    $0xc,%esp
f011f88d:	68 80 00 00 00       	push   $0x80
f011f892:	e8 15 92 fe ff       	call   f0108aac <sbrk>
f011f897:	83 c4 10             	add    $0x10,%esp
f011f89a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		newBrk = (uint32)sbrk(0);
f011f8a0:	83 ec 0c             	sub    $0xc,%esp
f011f8a3:	6a 00                	push   $0x0
f011f8a5:	e8 02 92 fe ff       	call   f0108aac <sbrk>
f011f8aa:	83 c4 10             	add    $0x10,%esp
f011f8ad:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f8b0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f8b7:	e8 84 4f fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f8bc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f8bf:	74 17                	je     f011f8d8 <test_ksbrk+0x6e2>
		{
			correct = 0;
f011f8c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f8c8:	83 ec 0c             	sub    $0xc,%esp
f011f8cb:	68 60 ef 12 f0       	push   $0xf012ef60
f011f8d0:	e8 97 16 fe ff       	call   f0100f6c <cprintf>
f011f8d5:	83 c4 10             	add    $0x10,%esp
		}
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 0)
f011f8d8:	e8 2c e1 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f8dd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f8e0:	74 17                	je     f011f8f9 <test_ksbrk+0x703>
		{
			correct = 0;
f011f8e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f8e9:	83 ec 0c             	sub    $0xc,%esp
f011f8ec:	68 c8 ef 12 f0       	push   $0xf012efc8
f011f8f1:	e8 76 16 fe ff       	call   f0100f6c <cprintf>
f011f8f6:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[6] != expectedVAs[6])
f011f8f9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011f8ff:	89 c2                	mov    %eax,%edx
f011f901:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011f907:	39 c2                	cmp    %eax,%edx
f011f909:	74 25                	je     f011f930 <test_ksbrk+0x73a>
		{
			correct = 0;
f011f90b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[6], ptr_allocations[6]);
f011f912:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011f918:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011f91e:	83 ec 04             	sub    $0x4,%esp
f011f921:	52                   	push   %edx
f011f922:	50                   	push   %eax
f011f923:	68 08 f0 12 f0       	push   $0xf012f008
f011f928:	e8 3f 16 fe ff       	call   f0100f6c <cprintf>
f011f92d:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[6])
f011f930:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011f936:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f939:	74 21                	je     f011f95c <test_ksbrk+0x766>
		{
			correct = 0;
f011f93b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[6]);
f011f942:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011f948:	83 ec 04             	sub    $0x4,%esp
f011f94b:	50                   	push   %eax
f011f94c:	ff 75 d0             	pushl  -0x30(%ebp)
f011f94f:	68 64 f0 12 f0       	push   $0xf012f064
f011f954:	e8 13 16 fe ff       	call   f0100f6c <cprintf>
f011f959:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f95c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f960:	74 04                	je     f011f966 <test_ksbrk+0x770>
			eval += 15;
f011f962:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP F: checking increment with +ve value [ONE Frame should be Allocated]\n");
f011f966:	83 ec 0c             	sub    $0xc,%esp
f011f969:	68 74 f1 12 f0       	push   $0xf012f174
f011f96e:	e8 f9 15 fe ff       	call   f0100f6c <cprintf>
f011f973:	83 c4 10             	add    $0x10,%esp
	{ // 1 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011f976:	e8 8e e0 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f97b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f97e:	e8 bd 4e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f983:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f986:	83 ec 0c             	sub    $0xc,%esp
f011f989:	6a 00                	push   $0x0
f011f98b:	e8 1c 91 fe ff       	call   f0108aac <sbrk>
f011f990:	83 c4 10             	add    $0x10,%esp
f011f993:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[7] = sbrk(kilo);
f011f996:	83 ec 0c             	sub    $0xc,%esp
f011f999:	68 00 04 00 00       	push   $0x400
f011f99e:	e8 09 91 fe ff       	call   f0108aac <sbrk>
f011f9a3:	83 c4 10             	add    $0x10,%esp
f011f9a6:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		newBrk = (uint32)sbrk(0);
f011f9ac:	83 ec 0c             	sub    $0xc,%esp
f011f9af:	6a 00                	push   $0x0
f011f9b1:	e8 f6 90 fe ff       	call   f0108aac <sbrk>
f011f9b6:	83 c4 10             	add    $0x10,%esp
f011f9b9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f9bc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f9c3:	e8 78 4e fe ff       	call   f0104840 <pf_calculate_free_frames>
f011f9c8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f9cb:	74 17                	je     f011f9e4 <test_ksbrk+0x7ee>
		{
			correct = 0;
f011f9cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f9d4:	83 ec 0c             	sub    $0xc,%esp
f011f9d7:	68 60 ef 12 f0       	push   $0xf012ef60
f011f9dc:	e8 8b 15 fe ff       	call   f0100f6c <cprintf>
f011f9e1:	83 c4 10             	add    $0x10,%esp
		}
		//cprintf("((int)(int)sys_calculate_free_frames() - freeFrames) = %d\n", ((int)(int)sys_calculate_free_frames() - freeFrames));
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 1)
f011f9e4:	e8 20 e0 fe ff       	call   f010da09 <sys_calculate_free_frames>
f011f9e9:	89 c2                	mov    %eax,%edx
f011f9eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f9ee:	29 d0                	sub    %edx,%eax
f011f9f0:	83 f8 01             	cmp    $0x1,%eax
f011f9f3:	74 17                	je     f011fa0c <test_ksbrk+0x816>
		{
			correct = 0;
f011f9f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong allocation: pages are not loaded successfully into memory");
f011f9fc:	83 ec 0c             	sub    $0xc,%esp
f011f9ff:	68 c0 f1 12 f0       	push   $0xf012f1c0
f011fa04:	e8 63 15 fe ff       	call   f0100f6c <cprintf>
f011fa09:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[7] != expectedVAs[7])
f011fa0c:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011fa12:	89 c2                	mov    %eax,%edx
f011fa14:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011fa1a:	39 c2                	cmp    %eax,%edx
f011fa1c:	74 25                	je     f011fa43 <test_ksbrk+0x84d>
		{
			correct = 0;
f011fa1e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011fa25:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011fa2b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011fa31:	83 ec 04             	sub    $0x4,%esp
f011fa34:	52                   	push   %edx
f011fa35:	50                   	push   %eax
f011fa36:	68 04 f2 12 f0       	push   $0xf012f204
f011fa3b:	e8 2c 15 fe ff       	call   f0100f6c <cprintf>
f011fa40:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[7])
f011fa43:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011fa49:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011fa4c:	74 21                	je     f011fa6f <test_ksbrk+0x879>
		{
			correct = 0;
f011fa4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011fa55:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011fa5b:	83 ec 04             	sub    $0x4,%esp
f011fa5e:	50                   	push   %eax
f011fa5f:	ff 75 d0             	pushl  -0x30(%ebp)
f011fa62:	68 38 f2 12 f0       	push   $0xf012f238
f011fa67:	e8 00 15 fe ff       	call   f0100f6c <cprintf>
f011fa6c:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011fa6f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fa73:	74 04                	je     f011fa79 <test_ksbrk+0x883>
			eval += 15;
f011fa75:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP G: checking increment with -ve value [TWO Frames should be Deallocated]\n");
f011fa79:	83 ec 0c             	sub    $0xc,%esp
f011fa7c:	68 68 f2 12 f0       	push   $0xf012f268
f011fa81:	e8 e6 14 fe ff       	call   f0100f6c <cprintf>
f011fa86:	83 c4 10             	add    $0x10,%esp
	{ // -9 KB
		freeFrames = (int)sys_calculate_free_frames();
f011fa89:	e8 7b df fe ff       	call   f010da09 <sys_calculate_free_frames>
f011fa8e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011fa91:	e8 aa 4d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011fa96:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011fa99:	83 ec 0c             	sub    $0xc,%esp
f011fa9c:	6a 00                	push   $0x0
f011fa9e:	e8 09 90 fe ff       	call   f0108aac <sbrk>
f011faa3:	83 c4 10             	add    $0x10,%esp
f011faa6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[8] = sbrk(-9 * kilo);
f011faa9:	83 ec 0c             	sub    $0xc,%esp
f011faac:	68 00 dc ff ff       	push   $0xffffdc00
f011fab1:	e8 f6 8f fe ff       	call   f0108aac <sbrk>
f011fab6:	83 c4 10             	add    $0x10,%esp
f011fab9:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		newBrk = (uint32)sbrk(0);
f011fabf:	83 ec 0c             	sub    $0xc,%esp
f011fac2:	6a 00                	push   $0x0
f011fac4:	e8 e3 8f fe ff       	call   f0108aac <sbrk>
f011fac9:	83 c4 10             	add    $0x10,%esp
f011facc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011facf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011fad6:	e8 65 4d fe ff       	call   f0104840 <pf_calculate_free_frames>
f011fadb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011fade:	74 17                	je     f011faf7 <test_ksbrk+0x901>
		{
			correct = 0;
f011fae0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011fae7:	83 ec 0c             	sub    $0xc,%esp
f011faea:	68 60 ef 12 f0       	push   $0xf012ef60
f011faef:	e8 78 14 fe ff       	call   f0100f6c <cprintf>
f011faf4:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 2)
f011faf7:	e8 0d df fe ff       	call   f010da09 <sys_calculate_free_frames>
f011fafc:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011faff:	83 f8 02             	cmp    $0x2,%eax
f011fb02:	74 17                	je     f011fb1b <test_ksbrk+0x925>
		{
			correct = 0;
f011fb04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong allocation: pages are not loaded successfully into memory");
f011fb0b:	83 ec 0c             	sub    $0xc,%esp
f011fb0e:	68 b8 f2 12 f0       	push   $0xf012f2b8
f011fb13:	e8 54 14 fe ff       	call   f0100f6c <cprintf>
f011fb18:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[8] != expectedVAs[8])
f011fb1b:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011fb21:	89 c2                	mov    %eax,%edx
f011fb23:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011fb29:	39 c2                	cmp    %eax,%edx
f011fb2b:	74 25                	je     f011fb52 <test_ksbrk+0x95c>
		{
			correct = 0;
f011fb2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011fb34:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011fb3a:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011fb40:	83 ec 04             	sub    $0x4,%esp
f011fb43:	52                   	push   %edx
f011fb44:	50                   	push   %eax
f011fb45:	68 fc f2 12 f0       	push   $0xf012f2fc
f011fb4a:	e8 1d 14 fe ff       	call   f0100f6c <cprintf>
f011fb4f:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[8])
f011fb52:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011fb58:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011fb5b:	74 21                	je     f011fb7e <test_ksbrk+0x988>
		{
			correct = 0;
f011fb5d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011fb64:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011fb6a:	83 ec 04             	sub    $0x4,%esp
f011fb6d:	50                   	push   %eax
f011fb6e:	ff 75 d0             	pushl  -0x30(%ebp)
f011fb71:	68 30 f3 12 f0       	push   $0xf012f330
f011fb76:	e8 f1 13 fe ff       	call   f0100f6c <cprintf>
f011fb7b:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011fb7e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fb82:	74 04                	je     f011fb88 <test_ksbrk+0x992>
			eval += 10;
f011fb84:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP H: checking increment with +ve value [THREE Frames should be Allocated]\n");
f011fb88:	83 ec 0c             	sub    $0xc,%esp
f011fb8b:	68 60 f3 12 f0       	push   $0xf012f360
f011fb90:	e8 d7 13 fe ff       	call   f0100f6c <cprintf>
f011fb95:	83 c4 10             	add    $0x10,%esp
	{ // 10 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011fb98:	e8 6c de fe ff       	call   f010da09 <sys_calculate_free_frames>
f011fb9d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011fba0:	e8 9b 4c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011fba5:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011fba8:	83 ec 0c             	sub    $0xc,%esp
f011fbab:	6a 00                	push   $0x0
f011fbad:	e8 fa 8e fe ff       	call   f0108aac <sbrk>
f011fbb2:	83 c4 10             	add    $0x10,%esp
f011fbb5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[9] = sbrk(10*kilo);
f011fbb8:	83 ec 0c             	sub    $0xc,%esp
f011fbbb:	68 00 28 00 00       	push   $0x2800
f011fbc0:	e8 e7 8e fe ff       	call   f0108aac <sbrk>
f011fbc5:	83 c4 10             	add    $0x10,%esp
f011fbc8:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		newBrk = (uint32)sbrk(0);
f011fbce:	83 ec 0c             	sub    $0xc,%esp
f011fbd1:	6a 00                	push   $0x0
f011fbd3:	e8 d4 8e fe ff       	call   f0108aac <sbrk>
f011fbd8:	83 c4 10             	add    $0x10,%esp
f011fbdb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011fbde:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011fbe5:	e8 56 4c fe ff       	call   f0104840 <pf_calculate_free_frames>
f011fbea:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011fbed:	74 17                	je     f011fc06 <test_ksbrk+0xa10>
		{
			correct = 0;
f011fbef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011fbf6:	83 ec 0c             	sub    $0xc,%esp
f011fbf9:	68 60 ef 12 f0       	push   $0xf012ef60
f011fbfe:	e8 69 13 fe ff       	call   f0100f6c <cprintf>
f011fc03:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 3)
f011fc06:	e8 fe dd fe ff       	call   f010da09 <sys_calculate_free_frames>
f011fc0b:	89 c2                	mov    %eax,%edx
f011fc0d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fc10:	29 d0                	sub    %edx,%eax
f011fc12:	83 f8 03             	cmp    $0x3,%eax
f011fc15:	74 17                	je     f011fc2e <test_ksbrk+0xa38>
		{
			correct = 0;
f011fc17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong allocation: pages are not loaded successfully into memory");
f011fc1e:	83 ec 0c             	sub    $0xc,%esp
f011fc21:	68 b0 f3 12 f0       	push   $0xf012f3b0
f011fc26:	e8 41 13 fe ff       	call   f0100f6c <cprintf>
f011fc2b:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[9] != expectedVAs[9])
f011fc2e:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011fc34:	89 c2                	mov    %eax,%edx
f011fc36:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011fc3c:	39 c2                	cmp    %eax,%edx
f011fc3e:	74 25                	je     f011fc65 <test_ksbrk+0xa6f>
		{
			correct = 0;
f011fc40:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011fc47:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011fc4d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011fc53:	83 ec 04             	sub    $0x4,%esp
f011fc56:	52                   	push   %edx
f011fc57:	50                   	push   %eax
f011fc58:	68 f4 f3 12 f0       	push   $0xf012f3f4
f011fc5d:	e8 0a 13 fe ff       	call   f0100f6c <cprintf>
f011fc62:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[9])
f011fc65:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011fc6b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011fc6e:	74 21                	je     f011fc91 <test_ksbrk+0xa9b>
		{
			correct = 0;
f011fc70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011fc77:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011fc7d:	83 ec 04             	sub    $0x4,%esp
f011fc80:	50                   	push   %eax
f011fc81:	ff 75 d0             	pushl  -0x30(%ebp)
f011fc84:	68 28 f4 12 f0       	push   $0xf012f428
f011fc89:	e8 de 12 fe ff       	call   f0100f6c <cprintf>
f011fc8e:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011fc91:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fc95:	74 04                	je     f011fc9b <test_ksbrk+0xaa5>
			eval += 10;
f011fc97:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}

	//cprintf("Test kheap sbrk completed. Evaluation = %d%%\n", eval);
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f011fc9b:	83 ec 08             	sub    $0x8,%esp
f011fc9e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fca1:	68 55 f4 12 f0       	push   $0xf012f455
f011fca6:	e8 c1 12 fe ff       	call   f0100f6c <cprintf>
f011fcab:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011fcae:	83 ec 0c             	sub    $0xc,%esp
f011fcb1:	68 6f f4 12 f0       	push   $0xf012f46f
f011fcb6:	e8 b1 12 fe ff       	call   f0100f6c <cprintf>
f011fcbb:	83 c4 10             	add    $0x10,%esp
	return 0;
f011fcbe:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fcc3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011fcc6:	5b                   	pop    %ebx
f011fcc7:	5e                   	pop    %esi
f011fcc8:	5f                   	pop    %edi
f011fcc9:	5d                   	pop    %ebp
f011fcca:	c3                   	ret    

f011fccb <test_kmalloc_nextfit>:




int test_kmalloc_nextfit()
{
f011fccb:	55                   	push   %ebp
f011fccc:	89 e5                	mov    %esp,%ebp
f011fcce:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fcd4:	83 ec 04             	sub    $0x4,%esp
f011fcd7:	68 08 f5 12 f0       	push   $0xf012f508
f011fcdc:	68 76 08 00 00       	push   $0x876
f011fce1:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fce6:	e8 2f 06 fe ff       	call   f010031a <_panic>

f011fceb <test_kmalloc_bestfit1>:
	return 1;

}

int test_kmalloc_bestfit1()
{
f011fceb:	55                   	push   %ebp
f011fcec:	89 e5                	mov    %esp,%ebp
f011fcee:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fcf1:	83 ec 04             	sub    $0x4,%esp
f011fcf4:	68 08 f5 12 f0       	push   $0xf012f508
f011fcf9:	68 1c 09 00 00       	push   $0x91c
f011fcfe:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fd03:	e8 12 06 fe ff       	call   f010031a <_panic>

f011fd08 <test_kmalloc_bestfit2>:
	return 1;

}

int test_kmalloc_bestfit2()
{
f011fd08:	55                   	push   %ebp
f011fd09:	89 e5                	mov    %esp,%ebp
f011fd0b:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fd0e:	83 ec 04             	sub    $0x4,%esp
f011fd11:	68 08 f5 12 f0       	push   $0xf012f508
f011fd16:	68 c8 09 00 00       	push   $0x9c8
f011fd1b:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fd20:	e8 f5 05 fe ff       	call   f010031a <_panic>

f011fd25 <test_kmalloc_worstfit>:
	return 1;

}

int test_kmalloc_worstfit()
{
f011fd25:	55                   	push   %ebp
f011fd26:	89 e5                	mov    %esp,%ebp
f011fd28:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fd2e:	83 ec 04             	sub    $0x4,%esp
f011fd31:	68 08 f5 12 f0       	push   $0xf012f508
f011fd36:	68 6e 0a 00 00       	push   $0xa6e
f011fd3b:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fd40:	e8 d5 05 fe ff       	call   f010031a <_panic>

f011fd45 <test_kfree>:

	return 1;
}

int test_kfree()
{
f011fd45:	55                   	push   %ebp
f011fd46:	89 e5                	mov    %esp,%ebp
f011fd48:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fd4e:	83 ec 04             	sub    $0x4,%esp
f011fd51:	68 08 f5 12 f0       	push   $0xf012f508
f011fd56:	68 14 0b 00 00       	push   $0xb14
f011fd5b:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fd60:	e8 b5 05 fe ff       	call   f010031a <_panic>

f011fd65 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011fd65:	55                   	push   %ebp
f011fd66:	89 e5                	mov    %esp,%ebp
f011fd68:	57                   	push   %edi
f011fd69:	56                   	push   %esi
f011fd6a:	53                   	push   %ebx
f011fd6b:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011fd71:	a0 dc fd 17 f0       	mov    0xf017fddc,%al
f011fd76:	84 c0                	test   %al,%al
f011fd78:	74 56                	je     f011fdd0 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011fd7a:	c6 05 dc fd 17 f0 00 	movb   $0x0,0xf017fddc
		initFreeFrames = sys_calculate_free_frames() ;
f011fd81:	e8 83 dc fe ff       	call   f010da09 <sys_calculate_free_frames>
f011fd86:	a3 68 62 5c f0       	mov    %eax,0xf05c6268
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011fd8b:	e8 b0 4a fe ff       	call   f0104840 <pf_calculate_free_frames>
f011fd90:	a3 64 62 5c f0       	mov    %eax,0xf05c6264
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011fd95:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011fd9b:	bb 65 f6 12 f0       	mov    $0xf012f665,%ebx
f011fda0:	ba 11 00 00 00       	mov    $0x11,%edx
f011fda5:	89 c7                	mov    %eax,%edi
f011fda7:	89 de                	mov    %ebx,%esi
f011fda9:	89 d1                	mov    %edx,%ecx
f011fdab:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011fdad:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011fdb3:	b9 53 00 00 00       	mov    $0x53,%ecx
f011fdb8:	b0 00                	mov    $0x0,%al
f011fdba:	89 d7                	mov    %edx,%edi
f011fdbc:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011fdbe:	83 ec 0c             	sub    $0xc,%esp
f011fdc1:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011fdc7:	50                   	push   %eax
f011fdc8:	e8 0f 21 fe ff       	call   f0101edc <execute_command>
f011fdcd:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011fdd0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011fdd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011fdde:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f011fde3:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011fde6:	eb 2b                	jmp    f011fe13 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011fde8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fdeb:	83 c0 20             	add    $0x20,%eax
f011fdee:	83 ec 08             	sub    $0x8,%esp
f011fdf1:	68 4d f5 12 f0       	push   $0xf012f54d
f011fdf6:	50                   	push   %eax
f011fdf7:	e8 e5 28 00 00       	call   f01226e1 <strcmp>
f011fdfc:	83 c4 10             	add    $0x10,%esp
f011fdff:	85 c0                	test   %eax,%eax
f011fe01:	75 08                	jne    f011fe0b <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011fe03:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fe06:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011fe09:	eb 2f                	jmp    f011fe3a <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011fe0b:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f011fe10:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011fe13:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fe17:	74 08                	je     f011fe21 <test_three_creation_functions+0xbc>
f011fe19:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fe1c:	8b 40 08             	mov    0x8(%eax),%eax
f011fe1f:	eb 05                	jmp    f011fe26 <test_three_creation_functions+0xc1>
f011fe21:	b8 00 00 00 00       	mov    $0x0,%eax
f011fe26:	a3 88 0e 5a f0       	mov    %eax,0xf05a0e88
f011fe2b:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f011fe30:	85 c0                	test   %eax,%eax
f011fe32:	75 b4                	jne    f011fde8 <test_three_creation_functions+0x83>
f011fe34:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fe38:	75 ae                	jne    f011fde8 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011fe3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fe3d:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f011fe43:	85 c0                	test   %eax,%eax
f011fe45:	74 17                	je     f011fe5e <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011fe47:	83 ec 04             	sub    $0x4,%esp
f011fe4a:	68 58 f5 12 f0       	push   $0xf012f558
f011fe4f:	68 f0 0c 00 00       	push   $0xcf0
f011fe54:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fe59:	e8 bc 04 fe ff       	call   f010031a <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
#else
		int pagesInWS = env_page_ws_get_size(e);
f011fe5e:	83 ec 0c             	sub    $0xc,%esp
f011fe61:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fe64:	e8 f5 8e fe ff       	call   f0108d5e <env_page_ws_get_size>
f011fe69:	83 c4 10             	add    $0x10,%esp
f011fe6c:	89 45 dc             	mov    %eax,-0x24(%ebp)
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011fe6f:	e8 95 db fe ff       	call   f010da09 <sys_calculate_free_frames>
f011fe74:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011fe77:	e8 c4 49 fe ff       	call   f0104840 <pf_calculate_free_frames>
f011fe7c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011fe7f:	a1 64 62 5c f0       	mov    0xf05c6264,%eax
f011fe84:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011fe87:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011fe8a:	74 17                	je     f011fea3 <test_three_creation_functions+0x13e>
f011fe8c:	83 ec 04             	sub    $0x4,%esp
f011fe8f:	68 60 ef 12 f0       	push   $0xf012ef60
f011fe94:	68 fa 0c 00 00       	push   $0xcfa
f011fe99:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fe9e:	e8 77 04 fe ff       	call   f010031a <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011fea3:	a1 68 62 5c f0       	mov    0xf05c6268,%eax
f011fea8:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011feab:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011feae:	83 c2 15             	add    $0x15,%edx
f011feb1:	39 d0                	cmp    %edx,%eax
f011feb3:	74 17                	je     f011fecc <test_three_creation_functions+0x167>
f011feb5:	83 ec 04             	sub    $0x4,%esp
f011feb8:	68 c8 ef 12 f0       	push   $0xf012efc8
f011febd:	68 fc 0c 00 00       	push   $0xcfc
f011fec2:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fec7:	e8 4e 04 fe ff       	call   f010031a <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011fecc:	83 ec 0c             	sub    $0xc,%esp
f011fecf:	68 00 10 00 00       	push   $0x1000
f011fed4:	e8 dd 8b fe ff       	call   f0108ab6 <kmalloc>
f011fed9:	83 c4 10             	add    $0x10,%esp
f011fedc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011fedf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fee2:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011fee7:	74 17                	je     f011ff00 <test_three_creation_functions+0x19b>
f011fee9:	83 ec 04             	sub    $0x4,%esp
f011feec:	68 a8 f5 12 f0       	push   $0xf012f5a8
f011fef1:	68 00 0d 00 00       	push   $0xd00
f011fef6:	68 f2 ed 12 f0       	push   $0xf012edf2
f011fefb:	e8 1a 04 fe ff       	call   f010031a <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011ff00:	83 ec 0c             	sub    $0xc,%esp
f011ff03:	68 18 f6 12 f0       	push   $0xf012f618
f011ff08:	e8 5f 10 fe ff       	call   f0100f6c <cprintf>
f011ff0d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011ff10:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011ff15:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ff18:	5b                   	pop    %ebx
f011ff19:	5e                   	pop    %esi
f011ff1a:	5f                   	pop    %edi
f011ff1b:	5d                   	pop    %ebp
f011ff1c:	c3                   	ret    

f011ff1d <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011ff1d:	55                   	push   %ebp
f011ff1e:	89 e5                	mov    %esp,%ebp
f011ff20:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011ff23:	83 ec 04             	sub    $0x4,%esp
f011ff26:	68 c9 f6 12 f0       	push   $0xf012f6c9
f011ff2b:	68 0e 0d 00 00       	push   $0xd0e
f011ff30:	68 f2 ed 12 f0       	push   $0xf012edf2
f011ff35:	e8 e0 03 fe ff       	call   f010031a <_panic>

f011ff3a <test_kexpand>:

	return 1;

}
int test_kexpand(){
f011ff3a:	55                   	push   %ebp
f011ff3b:	89 e5                	mov    %esp,%ebp
f011ff3d:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011ff40:	83 ec 04             	sub    $0x4,%esp
f011ff43:	68 c9 f6 12 f0       	push   $0xf012f6c9
f011ff48:	68 14 0d 00 00       	push   $0xd14
f011ff4d:	68 f2 ed 12 f0       	push   $0xf012edf2
f011ff52:	e8 c3 03 fe ff       	call   f010031a <_panic>

f011ff57 <test_kshrink>:
	return 1;
}

int test_kshrink(){
f011ff57:	55                   	push   %ebp
f011ff58:	89 e5                	mov    %esp,%ebp
f011ff5a:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011ff5d:	83 ec 04             	sub    $0x4,%esp
f011ff60:	68 c9 f6 12 f0       	push   $0xf012f6c9
f011ff65:	68 19 0d 00 00       	push   $0xd19
f011ff6a:	68 f2 ed 12 f0       	push   $0xf012edf2
f011ff6f:	e8 a6 03 fe ff       	call   f010031a <_panic>

f011ff74 <test_kfreelast>:
	return 1;
}
int test_kfreelast(){
f011ff74:	55                   	push   %ebp
f011ff75:	89 e5                	mov    %esp,%ebp
f011ff77:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011ff7a:	83 ec 04             	sub    $0x4,%esp
f011ff7d:	68 c9 f6 12 f0       	push   $0xf012f6c9
f011ff82:	68 1d 0d 00 00       	push   $0xd1d
f011ff87:	68 f2 ed 12 f0       	push   $0xf012edf2
f011ff8c:	e8 89 03 fe ff       	call   f010031a <_panic>

f011ff91 <test_krealloc>:
	return 1;
}

int test_krealloc() {
f011ff91:	55                   	push   %ebp
f011ff92:	89 e5                	mov    %esp,%ebp
f011ff94:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011ff97:	83 ec 0c             	sub    $0xc,%esp
f011ff9a:	68 80 e6 12 f0       	push   $0xf012e680
f011ff9f:	e8 c8 0f fe ff       	call   f0100f6c <cprintf>
f011ffa4:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011ffa7:	83 ec 0c             	sub    $0xc,%esp
f011ffaa:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011ffaf:	e8 b8 0f fe ff       	call   f0100f6c <cprintf>
f011ffb4:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011ffb7:	83 ec 0c             	sub    $0xc,%esp
f011ffba:	68 80 e6 12 f0       	push   $0xf012e680
f011ffbf:	e8 a8 0f fe ff       	call   f0100f6c <cprintf>
f011ffc4:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011ffc7:	83 ec 04             	sub    $0x4,%esp
f011ffca:	68 c9 f6 12 f0       	push   $0xf012f6c9
f011ffcf:	68 26 0d 00 00       	push   $0xd26
f011ffd4:	68 f2 ed 12 f0       	push   $0xf012edf2
f011ffd9:	e8 3c 03 fe ff       	call   f010031a <_panic>

f011ffde <test_krealloc_BF>:
	return 0;
}


int test_krealloc_BF() {
f011ffde:	55                   	push   %ebp
f011ffdf:	89 e5                	mov    %esp,%ebp
f011ffe1:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011ffe4:	83 ec 0c             	sub    $0xc,%esp
f011ffe7:	68 80 e6 12 f0       	push   $0xf012e680
f011ffec:	e8 7b 0f fe ff       	call   f0100f6c <cprintf>
f011fff1:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011fff4:	83 ec 0c             	sub    $0xc,%esp
f011fff7:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011fffc:	e8 6b 0f fe ff       	call   f0100f6c <cprintf>
f0120001:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f0120004:	83 ec 0c             	sub    $0xc,%esp
f0120007:	68 80 e6 12 f0       	push   $0xf012e680
f012000c:	e8 5b 0f fe ff       	call   f0100f6c <cprintf>
f0120011:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f0120014:	83 ec 04             	sub    $0x4,%esp
f0120017:	68 c9 f6 12 f0       	push   $0xf012f6c9
f012001c:	68 30 0d 00 00       	push   $0xd30
f0120021:	68 f2 ed 12 f0       	push   $0xf012edf2
f0120026:	e8 ef 02 fe ff       	call   f010031a <_panic>

f012002b <test_krealloc_FF1>:
	return 0;
}

int test_krealloc_FF1()
{
f012002b:	55                   	push   %ebp
f012002c:	89 e5                	mov    %esp,%ebp
f012002e:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f0120031:	83 ec 0c             	sub    $0xc,%esp
f0120034:	68 e0 f6 12 f0       	push   $0xf012f6e0
f0120039:	e8 2e 0f fe ff       	call   f0100f6c <cprintf>
f012003e:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [BLOCK ALLOCATOR]******\n") ;
f0120041:	83 ec 0c             	sub    $0xc,%esp
f0120044:	68 18 f7 12 f0       	push   $0xf012f718
f0120049:	e8 1e 0f fe ff       	call   f0100f6c <cprintf>
f012004e:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f0120051:	83 ec 0c             	sub    $0xc,%esp
f0120054:	68 e0 f6 12 f0       	push   $0xf012f6e0
f0120059:	e8 0e 0f fe ff       	call   f0100f6c <cprintf>
f012005e:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f0120061:	83 ec 04             	sub    $0x4,%esp
f0120064:	68 c9 f6 12 f0       	push   $0xf012f6c9
f0120069:	68 3a 0d 00 00       	push   $0xd3a
f012006e:	68 f2 ed 12 f0       	push   $0xf012edf2
f0120073:	e8 a2 02 fe ff       	call   f010031a <_panic>

f0120078 <test_krealloc_FF2>:
	return 0;

}
int test_krealloc_FF2()
{
f0120078:	55                   	push   %ebp
f0120079:	89 e5                	mov    %esp,%ebp
f012007b:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f012007e:	83 ec 0c             	sub    $0xc,%esp
f0120081:	68 e0 f6 12 f0       	push   $0xf012f6e0
f0120086:	e8 e1 0e fe ff       	call   f0100f6c <cprintf>
f012008b:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [PAGE ALLOCATOR]******\n") ;
f012008e:	83 ec 0c             	sub    $0xc,%esp
f0120091:	68 64 f7 12 f0       	push   $0xf012f764
f0120096:	e8 d1 0e fe ff       	call   f0100f6c <cprintf>
f012009b:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f012009e:	83 ec 0c             	sub    $0xc,%esp
f01200a1:	68 e0 f6 12 f0       	push   $0xf012f6e0
f01200a6:	e8 c1 0e fe ff       	call   f0100f6c <cprintf>
f01200ab:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f01200ae:	83 ec 04             	sub    $0x4,%esp
f01200b1:	68 c9 f6 12 f0       	push   $0xf012f6c9
f01200b6:	68 44 0d 00 00       	push   $0xd44
f01200bb:	68 f2 ed 12 f0       	push   $0xf012edf2
f01200c0:	e8 55 02 fe ff       	call   f010031a <_panic>

f01200c5 <test_krealloc_FF3>:
	return 0;
}

int test_krealloc_FF3()
{
f01200c5:	55                   	push   %ebp
f01200c6:	89 e5                	mov    %esp,%ebp
f01200c8:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f01200cb:	83 ec 0c             	sub    $0xc,%esp
f01200ce:	68 e0 f6 12 f0       	push   $0xf012f6e0
f01200d3:	e8 94 0e fe ff       	call   f0100f6c <cprintf>
f01200d8:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [SWITCH FROM PAGE ALLOCATOR TO DYNAMIC ALLOCATOR AND VICE VERSA]******\n") ;
f01200db:	83 ec 0c             	sub    $0xc,%esp
f01200de:	68 ac f7 12 f0       	push   $0xf012f7ac
f01200e3:	e8 84 0e fe ff       	call   f0100f6c <cprintf>
f01200e8:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f01200eb:	83 ec 0c             	sub    $0xc,%esp
f01200ee:	68 e0 f6 12 f0       	push   $0xf012f6e0
f01200f3:	e8 74 0e fe ff       	call   f0100f6c <cprintf>
f01200f8:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f01200fb:	83 ec 04             	sub    $0x4,%esp
f01200fe:	68 c9 f6 12 f0       	push   $0xf012f6c9
f0120103:	68 4e 0d 00 00       	push   $0xd4e
f0120108:	68 f2 ed 12 f0       	push   $0xf012edf2
f012010d:	e8 08 02 fe ff       	call   f010031a <_panic>

f0120112 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f0120112:	55                   	push   %ebp
f0120113:	89 e5                	mov    %esp,%ebp
f0120115:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f0120118:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f012011f:	e9 84 00 00 00       	jmp    f01201a8 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f0120124:	83 ec 08             	sub    $0x8,%esp
f0120127:	ff 75 f4             	pushl  -0xc(%ebp)
f012012a:	68 24 f8 12 f0       	push   $0xf012f824
f012012f:	e8 38 0e fe ff       	call   f0100f6c <cprintf>
f0120134:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0120137:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f012013e:	eb 4c                	jmp    f012018c <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f0120140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120143:	89 d0                	mov    %edx,%eax
f0120145:	c1 e0 02             	shl    $0x2,%eax
f0120148:	01 d0                	add    %edx,%eax
f012014a:	c1 e0 03             	shl    $0x3,%eax
f012014d:	89 c2                	mov    %eax,%edx
f012014f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120152:	01 c2                	add    %eax,%edx
f0120154:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120157:	8b 04 82             	mov    (%edx,%eax,4),%eax
f012015a:	85 c0                	test   %eax,%eax
f012015c:	74 36                	je     f0120194 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f012015e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120161:	89 d0                	mov    %edx,%eax
f0120163:	c1 e0 02             	shl    $0x2,%eax
f0120166:	01 d0                	add    %edx,%eax
f0120168:	c1 e0 03             	shl    $0x3,%eax
f012016b:	89 c2                	mov    %eax,%edx
f012016d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120170:	01 c2                	add    %eax,%edx
f0120172:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120175:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0120178:	83 ec 08             	sub    $0x8,%esp
f012017b:	50                   	push   %eax
f012017c:	68 2c f8 12 f0       	push   $0xf012f82c
f0120181:	e8 e6 0d fe ff       	call   f0100f6c <cprintf>
f0120186:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0120189:	ff 45 f0             	incl   -0x10(%ebp)
f012018c:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0120190:	7e ae                	jle    f0120140 <print_order+0x2e>
f0120192:	eb 01                	jmp    f0120195 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f0120194:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f0120195:	83 ec 0c             	sub    $0xc,%esp
f0120198:	68 31 f8 12 f0       	push   $0xf012f831
f012019d:	e8 ca 0d fe ff       	call   f0100f6c <cprintf>
f01201a2:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f01201a5:	ff 45 f4             	incl   -0xc(%ebp)
f01201a8:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f01201ac:	0f 8e 72 ff ff ff    	jle    f0120124 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f01201b2:	90                   	nop
f01201b3:	c9                   	leave  
f01201b4:	c3                   	ret    

f01201b5 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f01201b5:	55                   	push   %ebp
f01201b6:	89 e5                	mov    %esp,%ebp
f01201b8:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f01201bb:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f01201c2:	83 ec 0c             	sub    $0xc,%esp
f01201c5:	68 00 0e 5a f0       	push   $0xf05a0e00
f01201ca:	e8 52 e9 fe ff       	call   f010eb21 <acquire_spinlock>
f01201cf:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f01201d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f01201d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01201e0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01201e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01201e6:	01 d0                	add    %edx,%eax
f01201e8:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01201eb:	a1 8c 0e 5a f0       	mov    0xf05a0e8c,%eax
f01201f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01201f3:	a1 84 0e 5a f0       	mov    0xf05a0e84,%eax
f01201f8:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f01201fb:	ff 75 e8             	pushl  -0x18(%ebp)
f01201fe:	ff 75 0c             	pushl  0xc(%ebp)
f0120201:	ff 75 08             	pushl  0x8(%ebp)
f0120204:	68 34 f8 12 f0       	push   $0xf012f834
f0120209:	e8 5e 0d fe ff       	call   f0100f6c <cprintf>
f012020e:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0120211:	eb 34                	jmp    f0120247 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f0120213:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120216:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120219:	7d 05                	jge    f0120220 <find_in_range+0x6b>
			{
				i++;
f012021b:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f012021e:	eb 1e                	jmp    f012023e <find_in_range+0x89>
			}
			if (i >= end)
f0120220:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120223:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0120226:	7d 29                	jge    f0120251 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f0120228:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012022b:	8b 40 10             	mov    0x10(%eax),%eax
f012022e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120231:	75 08                	jne    f012023b <find_in_range+0x86>
			{
				ret = i;
f0120233:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120236:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0120239:	eb 17                	jmp    f0120252 <find_in_range+0x9d>
			}
			i++;
f012023b:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f012023e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120241:	8b 40 0c             	mov    0xc(%eax),%eax
f0120244:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0120247:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012024a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f012024d:	7c c4                	jl     f0120213 <find_in_range+0x5e>
f012024f:	eb 01                	jmp    f0120252 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f0120251:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0120252:	83 ec 0c             	sub    $0xc,%esp
f0120255:	68 00 0e 5a f0       	push   $0xf05a0e00
f012025a:	e8 49 e9 fe ff       	call   f010eba8 <release_spinlock>
f012025f:	83 c4 10             	add    $0x10,%esp
	return ret;
f0120262:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120265:	c9                   	leave  
f0120266:	c3                   	ret    

f0120267 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f0120267:	55                   	push   %ebp
f0120268:	89 e5                	mov    %esp,%ebp
f012026a:	57                   	push   %edi
f012026b:	56                   	push   %esi
f012026c:	53                   	push   %ebx
f012026d:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f0120270:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f0120275:	84 c0                	test   %al,%al
f0120277:	0f 84 9b 01 00 00    	je     f0120418 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f012027d:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f0120284:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0120287:	bb ac f9 12 f0       	mov    $0xf012f9ac,%ebx
f012028c:	ba 05 00 00 00       	mov    $0x5,%edx
f0120291:	89 c7                	mov    %eax,%edi
f0120293:	89 de                	mov    %ebx,%esi
f0120295:	89 d1                	mov    %edx,%ecx
f0120297:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f0120299:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01202a0:	e9 44 01 00 00       	jmp    f01203e9 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f01202a5:	6a 00                	push   $0x0
f01202a7:	6a 00                	push   $0x0
f01202a9:	68 f4 01 00 00       	push   $0x1f4
f01202ae:	68 65 f8 12 f0       	push   $0xf012f865
f01202b3:	e8 b8 97 fe ff       	call   f0109a70 <env_create>
f01202b8:	83 c4 10             	add    $0x10,%esp
f01202bb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f01202be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01202c1:	b9 05 00 00 00       	mov    $0x5,%ecx
f01202c6:	99                   	cltd   
f01202c7:	f7 f9                	idiv   %ecx
f01202c9:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f01202cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01202cf:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f01202d3:	83 ec 08             	sub    $0x8,%esp
f01202d6:	50                   	push   %eax
f01202d7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01202da:	e8 c8 63 fe ff       	call   f01066a7 <env_set_nice>
f01202df:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f01202e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01202e6:	75 14                	jne    f01202fc <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f01202e8:	83 ec 04             	sub    $0x4,%esp
f01202eb:	68 6d f8 12 f0       	push   $0xf012f86d
f01202f0:	6a 53                	push   $0x53
f01202f2:	68 86 f8 12 f0       	push   $0xf012f886
f01202f7:	e8 1e 00 fe ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 500)
f01202fc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01202ff:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0120305:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f012030a:	74 14                	je     f0120320 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f012030c:	83 ec 04             	sub    $0x4,%esp
f012030f:	68 a4 f8 12 f0       	push   $0xf012f8a4
f0120314:	6a 55                	push   $0x55
f0120316:	68 86 f8 12 f0       	push   $0xf012f886
f012031b:	e8 fa ff fd ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f0120320:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120323:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f0120327:	83 c0 0a             	add    $0xa,%eax
f012032a:	83 f8 14             	cmp    $0x14,%eax
f012032d:	0f 87 a5 00 00 00    	ja     f01203d8 <test_bsd_nice_0+0x171>
f0120333:	8b 04 85 c0 f9 12 f0 	mov    -0xfed0640(,%eax,4),%eax
f012033a:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f012033c:	a1 3c 0c 5a f0       	mov    0xf05a0c3c,%eax
f0120341:	8d 50 01             	lea    0x1(%eax),%edx
f0120344:	89 15 3c 0c 5a f0    	mov    %edx,0xf05a0c3c
f012034a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012034d:	8b 52 10             	mov    0x10(%edx),%edx
f0120350:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120357:	eb 7f                	jmp    f01203d8 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f0120359:	a1 40 0c 5a f0       	mov    0xf05a0c40,%eax
f012035e:	8d 50 01             	lea    0x1(%eax),%edx
f0120361:	89 15 40 0c 5a f0    	mov    %edx,0xf05a0c40
f0120367:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012036a:	8b 52 10             	mov    0x10(%edx),%edx
f012036d:	83 c0 0a             	add    $0xa,%eax
f0120370:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120377:	eb 5f                	jmp    f01203d8 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f0120379:	a1 44 0c 5a f0       	mov    0xf05a0c44,%eax
f012037e:	8d 50 01             	lea    0x1(%eax),%edx
f0120381:	89 15 44 0c 5a f0    	mov    %edx,0xf05a0c44
f0120387:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012038a:	8b 52 10             	mov    0x10(%edx),%edx
f012038d:	83 c0 14             	add    $0x14,%eax
f0120390:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120397:	eb 3f                	jmp    f01203d8 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f0120399:	a1 48 0c 5a f0       	mov    0xf05a0c48,%eax
f012039e:	8d 50 01             	lea    0x1(%eax),%edx
f01203a1:	89 15 48 0c 5a f0    	mov    %edx,0xf05a0c48
f01203a7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01203aa:	8b 52 10             	mov    0x10(%edx),%edx
f01203ad:	83 c0 1e             	add    $0x1e,%eax
f01203b0:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f01203b7:	eb 1f                	jmp    f01203d8 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f01203b9:	a1 4c 0c 5a f0       	mov    0xf05a0c4c,%eax
f01203be:	8d 50 01             	lea    0x1(%eax),%edx
f01203c1:	89 15 4c 0c 5a f0    	mov    %edx,0xf05a0c4c
f01203c7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01203ca:	8b 52 10             	mov    0x10(%edx),%edx
f01203cd:	83 c0 28             	add    $0x28,%eax
f01203d0:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f01203d7:	90                   	nop
			}
			sched_new_env(env);
f01203d8:	83 ec 0c             	sub    $0xc,%esp
f01203db:	ff 75 d4             	pushl  -0x2c(%ebp)
f01203de:	e8 c2 52 fe ff       	call   f01056a5 <sched_new_env>
f01203e3:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f01203e6:	ff 45 e4             	incl   -0x1c(%ebp)
f01203e9:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f01203ed:	0f 8e b2 fe ff ff    	jle    f01202a5 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01203f3:	83 ec 0c             	sub    $0xc,%esp
f01203f6:	68 d4 f8 12 f0       	push   $0xf012f8d4
f01203fb:	e8 6c 0b fe ff       	call   f0100f6c <cprintf>
f0120400:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0120403:	83 ec 0c             	sub    $0xc,%esp
f0120406:	68 23 f9 12 f0       	push   $0xf012f923
f012040b:	e8 cc 1a fe ff       	call   f0101edc <execute_command>
f0120410:	83 c4 10             	add    $0x10,%esp
f0120413:	e9 c0 00 00 00       	jmp    f01204d8 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f0120418:	83 ec 0c             	sub    $0xc,%esp
f012041b:	68 2a f9 12 f0       	push   $0xf012f92a
f0120420:	e8 47 0b fe ff       	call   f0100f6c <cprintf>
f0120425:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0120428:	e8 f4 59 fe ff       	call   f0105e21 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f012042d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f0120434:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f012043b:	e9 87 00 00 00       	jmp    f01204c7 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0120440:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0120447:	eb 52                	jmp    f012049b <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f0120449:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012044c:	8b 14 85 3c 0c 5a f0 	mov    -0xfa5f3c4(,%eax,4),%edx
f0120453:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0120456:	89 c8                	mov    %ecx,%eax
f0120458:	c1 e0 02             	shl    $0x2,%eax
f012045b:	01 c8                	add    %ecx,%eax
f012045d:	01 c0                	add    %eax,%eax
f012045f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0120462:	01 c8                	add    %ecx,%eax
f0120464:	8b 04 85 80 62 5c f0 	mov    -0xfa39d80(,%eax,4),%eax
f012046b:	83 ec 04             	sub    $0x4,%esp
f012046e:	52                   	push   %edx
f012046f:	ff 75 e0             	pushl  -0x20(%ebp)
f0120472:	50                   	push   %eax
f0120473:	e8 3d fd ff ff       	call   f01201b5 <find_in_range>
f0120478:	83 c4 10             	add    $0x10,%esp
f012047b:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f012047e:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f0120482:	75 14                	jne    f0120498 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f0120484:	83 ec 04             	sub    $0x4,%esp
f0120487:	68 3c f9 12 f0       	push   $0xf012f93c
f012048c:	6a 7b                	push   $0x7b
f012048e:	68 86 f8 12 f0       	push   $0xf012f886
f0120493:	e8 82 fe fd ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0120498:	ff 45 d8             	incl   -0x28(%ebp)
f012049b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012049e:	89 d0                	mov    %edx,%eax
f01204a0:	c1 e0 02             	shl    $0x2,%eax
f01204a3:	01 d0                	add    %edx,%eax
f01204a5:	01 c0                	add    %eax,%eax
f01204a7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01204aa:	01 d0                	add    %edx,%eax
f01204ac:	8b 04 85 80 62 5c f0 	mov    -0xfa39d80(,%eax,4),%eax
f01204b3:	85 c0                	test   %eax,%eax
f01204b5:	75 92                	jne    f0120449 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f01204b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01204ba:	8b 04 85 3c 0c 5a f0 	mov    -0xfa5f3c4(,%eax,4),%eax
f01204c1:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f01204c4:	ff 45 dc             	incl   -0x24(%ebp)
f01204c7:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f01204cb:	0f 8e 6f ff ff ff    	jle    f0120440 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f01204d1:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f01204d8:	83 ec 0c             	sub    $0xc,%esp
f01204db:	68 70 f9 12 f0       	push   $0xf012f970
f01204e0:	e8 87 0a fe ff       	call   f0100f6c <cprintf>
f01204e5:	83 c4 10             	add    $0x10,%esp
}
f01204e8:	90                   	nop
f01204e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01204ec:	5b                   	pop    %ebx
f01204ed:	5e                   	pop    %esi
f01204ee:	5f                   	pop    %edi
f01204ef:	5d                   	pop    %ebp
f01204f0:	c3                   	ret    

f01204f1 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f01204f1:	55                   	push   %ebp
f01204f2:	89 e5                	mov    %esp,%ebp
f01204f4:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f01204f7:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f01204fc:	84 c0                	test   %al,%al
f01204fe:	0f 84 50 01 00 00    	je     f0120654 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f0120504:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f012050b:	6a 00                	push   $0x0
f012050d:	6a 00                	push   $0x0
f012050f:	68 f4 01 00 00       	push   $0x1f4
f0120514:	68 65 f8 12 f0       	push   $0xf012f865
f0120519:	e8 52 95 fe ff       	call   f0109a70 <env_create>
f012051e:	83 c4 10             	add    $0x10,%esp
f0120521:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f0120524:	6a 00                	push   $0x0
f0120526:	6a 00                	push   $0x0
f0120528:	68 f4 01 00 00       	push   $0x1f4
f012052d:	68 14 fa 12 f0       	push   $0xf012fa14
f0120532:	e8 39 95 fe ff       	call   f0109a70 <env_create>
f0120537:	83 c4 10             	add    $0x10,%esp
f012053a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f012053d:	6a 00                	push   $0x0
f012053f:	6a 00                	push   $0x0
f0120541:	68 f4 01 00 00       	push   $0x1f4
f0120546:	68 21 fa 12 f0       	push   $0xf012fa21
f012054b:	e8 20 95 fe ff       	call   f0109a70 <env_create>
f0120550:	83 c4 10             	add    $0x10,%esp
f0120553:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f0120556:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012055a:	74 0c                	je     f0120568 <test_bsd_nice_1+0x77>
f012055c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120560:	74 06                	je     f0120568 <test_bsd_nice_1+0x77>
f0120562:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120566:	75 17                	jne    f012057f <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f0120568:	83 ec 04             	sub    $0x4,%esp
f012056b:	68 6d f8 12 f0       	push   $0xf012f86d
f0120570:	68 8e 00 00 00       	push   $0x8e
f0120575:	68 86 f8 12 f0       	push   $0xf012f886
f012057a:	e8 9b fd fd ff       	call   f010031a <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f012057f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120582:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0120588:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f012058d:	75 20                	jne    f01205af <test_bsd_nice_1+0xbe>
f012058f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120592:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0120598:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f012059d:	75 10                	jne    f01205af <test_bsd_nice_1+0xbe>
f012059f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01205a2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01205a8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01205ad:	74 35                	je     f01205e4 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f01205af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01205b2:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f01205b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01205bb:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f01205c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205c4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01205ca:	83 ec 08             	sub    $0x8,%esp
f01205cd:	51                   	push   %ecx
f01205ce:	52                   	push   %edx
f01205cf:	50                   	push   %eax
f01205d0:	68 30 fa 12 f0       	push   $0xf012fa30
f01205d5:	68 90 00 00 00       	push   $0x90
f01205da:	68 86 f8 12 f0       	push   $0xf012f886
f01205df:	e8 36 fd fd ff       	call   f010031a <_panic>
		sched_new_env(fibEnv);
f01205e4:	83 ec 0c             	sub    $0xc,%esp
f01205e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01205ea:	e8 b6 50 fe ff       	call   f01056a5 <sched_new_env>
f01205ef:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f01205f2:	83 ec 0c             	sub    $0xc,%esp
f01205f5:	ff 75 e8             	pushl  -0x18(%ebp)
f01205f8:	e8 a8 50 fe ff       	call   f01056a5 <sched_new_env>
f01205fd:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f0120600:	83 ec 0c             	sub    $0xc,%esp
f0120603:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120606:	e8 9a 50 fe ff       	call   f01056a5 <sched_new_env>
f012060b:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f012060e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120611:	8b 40 10             	mov    0x10(%eax),%eax
f0120614:	a3 80 62 5c f0       	mov    %eax,0xf05c6280
		prog_orders[1][0] = fibEnv->env_id;
f0120619:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012061c:	8b 40 10             	mov    0x10(%eax),%eax
f012061f:	a3 a8 62 5c f0       	mov    %eax,0xf05c62a8
		prog_orders[2][0] = fibposnEnv->env_id;
f0120624:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120627:	8b 40 10             	mov    0x10(%eax),%eax
f012062a:	a3 d0 62 5c f0       	mov    %eax,0xf05c62d0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f012062f:	83 ec 0c             	sub    $0xc,%esp
f0120632:	68 d4 f8 12 f0       	push   $0xf012f8d4
f0120637:	e8 30 09 fe ff       	call   f0100f6c <cprintf>
f012063c:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f012063f:	83 ec 0c             	sub    $0xc,%esp
f0120642:	68 23 f9 12 f0       	push   $0xf012f923
f0120647:	e8 90 18 fe ff       	call   f0101edc <execute_command>
f012064c:	83 c4 10             	add    $0x10,%esp
f012064f:	e9 9e 00 00 00       	jmp    f01206f2 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f0120654:	83 ec 0c             	sub    $0xc,%esp
f0120657:	68 2a f9 12 f0       	push   $0xf012f92a
f012065c:	e8 0b 09 fe ff       	call   f0100f6c <cprintf>
f0120661:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0120664:	e8 b8 57 fe ff       	call   f0105e21 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f0120669:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f0120670:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f0120677:	83 ec 0c             	sub    $0xc,%esp
f012067a:	68 00 0e 5a f0       	push   $0xf05a0e00
f012067f:	e8 9d e4 fe ff       	call   f010eb21 <acquire_spinlock>
f0120684:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0120687:	a1 8c 0e 5a f0       	mov    0xf05a0e8c,%eax
f012068c:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f012068f:	a1 84 0e 5a f0       	mov    0xf05a0e84,%eax
f0120694:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0120697:	eb 41                	jmp    f01206da <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f0120699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012069c:	89 d0                	mov    %edx,%eax
f012069e:	c1 e0 02             	shl    $0x2,%eax
f01206a1:	01 d0                	add    %edx,%eax
f01206a3:	c1 e0 03             	shl    $0x3,%eax
f01206a6:	05 80 62 5c f0       	add    $0xf05c6280,%eax
f01206ab:	8b 10                	mov    (%eax),%edx
f01206ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01206b0:	8b 40 10             	mov    0x10(%eax),%eax
f01206b3:	39 c2                	cmp    %eax,%edx
f01206b5:	74 17                	je     f01206ce <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f01206b7:	83 ec 04             	sub    $0x4,%esp
f01206ba:	68 3c f9 12 f0       	push   $0xf012f93c
f01206bf:	68 ab 00 00 00       	push   $0xab
f01206c4:	68 86 f8 12 f0       	push   $0xf012f886
f01206c9:	e8 4c fc fd ff       	call   f010031a <_panic>
				i++;
f01206ce:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f01206d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01206d4:	8b 40 0c             	mov    0xc(%eax),%eax
f01206d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01206da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206dd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01206e0:	7c b7                	jl     f0120699 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f01206e2:	83 ec 0c             	sub    $0xc,%esp
f01206e5:	68 00 0e 5a f0       	push   $0xf05a0e00
f01206ea:	e8 b9 e4 fe ff       	call   f010eba8 <release_spinlock>
f01206ef:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f01206f2:	83 ec 0c             	sub    $0xc,%esp
f01206f5:	68 9c fa 12 f0       	push   $0xf012fa9c
f01206fa:	e8 6d 08 fe ff       	call   f0100f6c <cprintf>
f01206ff:	83 c4 10             	add    $0x10,%esp
}
f0120702:	90                   	nop
f0120703:	c9                   	leave  
f0120704:	c3                   	ret    

f0120705 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f0120705:	55                   	push   %ebp
f0120706:	89 e5                	mov    %esp,%ebp
f0120708:	57                   	push   %edi
f0120709:	56                   	push   %esi
f012070a:	53                   	push   %ebx
f012070b:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f012070e:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f0120713:	84 c0                	test   %al,%al
f0120715:	0f 84 ae 01 00 00    	je     f01208c9 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f012071b:	83 ec 0c             	sub    $0xc,%esp
f012071e:	6a 01                	push   $0x1
f0120720:	e8 0d 10 00 00       	call   f0121732 <chksch>
f0120725:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f0120728:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {15, 5, 0, -5, -15};
f012072f:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0120732:	bb 20 fb 12 f0       	mov    $0xf012fb20,%ebx
f0120737:	ba 05 00 00 00       	mov    $0x5,%edx
f012073c:	89 c7                	mov    %eax,%edi
f012073e:	89 de                	mov    %ebx,%esi
f0120740:	89 d1                	mov    %edx,%ecx
f0120742:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f0120744:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f012074b:	e9 4a 01 00 00       	jmp    f012089a <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f0120750:	6a 00                	push   $0x0
f0120752:	6a 00                	push   $0x0
f0120754:	68 10 27 00 00       	push   $0x2710
f0120759:	68 d8 fa 12 f0       	push   $0xf012fad8
f012075e:	e8 0d 93 fe ff       	call   f0109a70 <env_create>
f0120763:	83 c4 10             	add    $0x10,%esp
f0120766:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f0120769:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012076c:	b9 05 00 00 00       	mov    $0x5,%ecx
f0120771:	99                   	cltd   
f0120772:	f7 f9                	idiv   %ecx
f0120774:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f0120777:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012077a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f012077e:	83 ec 08             	sub    $0x8,%esp
f0120781:	50                   	push   %eax
f0120782:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120785:	e8 1d 5f fe ff       	call   f01066a7 <env_set_nice>
f012078a:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f012078d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0120791:	75 17                	jne    f01207aa <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f0120793:	83 ec 04             	sub    $0x4,%esp
f0120796:	68 6d f8 12 f0       	push   $0xf012f86d
f012079b:	68 c1 00 00 00       	push   $0xc1
f01207a0:	68 86 f8 12 f0       	push   $0xf012f886
f01207a5:	e8 70 fb fd ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 10000)
f01207aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207ad:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01207b3:	3d 10 27 00 00       	cmp    $0x2710,%eax
f01207b8:	74 17                	je     f01207d1 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f01207ba:	83 ec 04             	sub    $0x4,%esp
f01207bd:	68 a4 f8 12 f0       	push   $0xf012f8a4
f01207c2:	68 c3 00 00 00       	push   $0xc3
f01207c7:	68 86 f8 12 f0       	push   $0xf012f886
f01207cc:	e8 49 fb fd ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f01207d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01207d4:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f01207d8:	83 c0 0f             	add    $0xf,%eax
f01207db:	83 f8 1e             	cmp    $0x1e,%eax
f01207de:	0f 87 a5 00 00 00    	ja     f0120889 <test_bsd_nice_2+0x184>
f01207e4:	8b 04 85 34 fb 12 f0 	mov    -0xfed04cc(,%eax,4),%eax
f01207eb:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f01207ed:	a1 3c 0c 5a f0       	mov    0xf05a0c3c,%eax
f01207f2:	8d 50 01             	lea    0x1(%eax),%edx
f01207f5:	89 15 3c 0c 5a f0    	mov    %edx,0xf05a0c3c
f01207fb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01207fe:	8b 52 10             	mov    0x10(%edx),%edx
f0120801:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120808:	eb 7f                	jmp    f0120889 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f012080a:	a1 40 0c 5a f0       	mov    0xf05a0c40,%eax
f012080f:	8d 50 01             	lea    0x1(%eax),%edx
f0120812:	89 15 40 0c 5a f0    	mov    %edx,0xf05a0c40
f0120818:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012081b:	8b 52 10             	mov    0x10(%edx),%edx
f012081e:	83 c0 0a             	add    $0xa,%eax
f0120821:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120828:	eb 5f                	jmp    f0120889 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f012082a:	a1 44 0c 5a f0       	mov    0xf05a0c44,%eax
f012082f:	8d 50 01             	lea    0x1(%eax),%edx
f0120832:	89 15 44 0c 5a f0    	mov    %edx,0xf05a0c44
f0120838:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012083b:	8b 52 10             	mov    0x10(%edx),%edx
f012083e:	83 c0 14             	add    $0x14,%eax
f0120841:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120848:	eb 3f                	jmp    f0120889 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f012084a:	a1 48 0c 5a f0       	mov    0xf05a0c48,%eax
f012084f:	8d 50 01             	lea    0x1(%eax),%edx
f0120852:	89 15 48 0c 5a f0    	mov    %edx,0xf05a0c48
f0120858:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012085b:	8b 52 10             	mov    0x10(%edx),%edx
f012085e:	83 c0 1e             	add    $0x1e,%eax
f0120861:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120868:	eb 1f                	jmp    f0120889 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f012086a:	a1 4c 0c 5a f0       	mov    0xf05a0c4c,%eax
f012086f:	8d 50 01             	lea    0x1(%eax),%edx
f0120872:	89 15 4c 0c 5a f0    	mov    %edx,0xf05a0c4c
f0120878:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012087b:	8b 52 10             	mov    0x10(%edx),%edx
f012087e:	83 c0 28             	add    $0x28,%eax
f0120881:	89 14 85 80 62 5c f0 	mov    %edx,-0xfa39d80(,%eax,4)
				break;
f0120888:	90                   	nop
			}
			sched_new_env(env);
f0120889:	83 ec 0c             	sub    $0xc,%esp
f012088c:	ff 75 d4             	pushl  -0x2c(%ebp)
f012088f:	e8 11 4e fe ff       	call   f01056a5 <sched_new_env>
f0120894:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f0120897:	ff 45 e4             	incl   -0x1c(%ebp)
f012089a:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f012089e:	0f 8e ac fe ff ff    	jle    f0120750 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01208a4:	83 ec 0c             	sub    $0xc,%esp
f01208a7:	68 d4 f8 12 f0       	push   $0xf012f8d4
f01208ac:	e8 bb 06 fe ff       	call   f0100f6c <cprintf>
f01208b1:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01208b4:	83 ec 0c             	sub    $0xc,%esp
f01208b7:	68 23 f9 12 f0       	push   $0xf012f923
f01208bc:	e8 1b 16 fe ff       	call   f0101edc <execute_command>
f01208c1:	83 c4 10             	add    $0x10,%esp
f01208c4:	e9 d0 00 00 00       	jmp    f0120999 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f01208c9:	83 ec 0c             	sub    $0xc,%esp
f01208cc:	6a 00                	push   $0x0
f01208ce:	e8 5f 0e 00 00       	call   f0121732 <chksch>
f01208d3:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f01208d6:	83 ec 0c             	sub    $0xc,%esp
f01208d9:	68 2a f9 12 f0       	push   $0xf012f92a
f01208de:	e8 89 06 fe ff       	call   f0100f6c <cprintf>
f01208e3:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f01208e6:	e8 36 55 fe ff       	call   f0105e21 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f01208eb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f01208f2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01208f9:	e9 8a 00 00 00       	jmp    f0120988 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f01208fe:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0120905:	eb 55                	jmp    f012095c <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f0120907:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012090a:	8b 14 85 3c 0c 5a f0 	mov    -0xfa5f3c4(,%eax,4),%edx
f0120911:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0120914:	89 c8                	mov    %ecx,%eax
f0120916:	c1 e0 02             	shl    $0x2,%eax
f0120919:	01 c8                	add    %ecx,%eax
f012091b:	01 c0                	add    %eax,%eax
f012091d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0120920:	01 c8                	add    %ecx,%eax
f0120922:	8b 04 85 80 62 5c f0 	mov    -0xfa39d80(,%eax,4),%eax
f0120929:	83 ec 04             	sub    $0x4,%esp
f012092c:	52                   	push   %edx
f012092d:	ff 75 e0             	pushl  -0x20(%ebp)
f0120930:	50                   	push   %eax
f0120931:	e8 7f f8 ff ff       	call   f01201b5 <find_in_range>
f0120936:	83 c4 10             	add    $0x10,%esp
f0120939:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f012093c:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f0120940:	75 17                	jne    f0120959 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f0120942:	83 ec 04             	sub    $0x4,%esp
f0120945:	68 3c f9 12 f0       	push   $0xf012f93c
f012094a:	68 ea 00 00 00       	push   $0xea
f012094f:	68 86 f8 12 f0       	push   $0xf012f886
f0120954:	e8 c1 f9 fd ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0120959:	ff 45 d8             	incl   -0x28(%ebp)
f012095c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012095f:	89 d0                	mov    %edx,%eax
f0120961:	c1 e0 02             	shl    $0x2,%eax
f0120964:	01 d0                	add    %edx,%eax
f0120966:	01 c0                	add    %eax,%eax
f0120968:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012096b:	01 d0                	add    %edx,%eax
f012096d:	8b 04 85 80 62 5c f0 	mov    -0xfa39d80(,%eax,4),%eax
f0120974:	85 c0                	test   %eax,%eax
f0120976:	75 8f                	jne    f0120907 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f0120978:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012097b:	8b 04 85 3c 0c 5a f0 	mov    -0xfa5f3c4(,%eax,4),%eax
f0120982:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f0120985:	ff 45 dc             	incl   -0x24(%ebp)
f0120988:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f012098c:	0f 8e 6c ff ff ff    	jle    f01208fe <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f0120992:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f0120999:	83 ec 0c             	sub    $0xc,%esp
f012099c:	68 e4 fa 12 f0       	push   $0xf012fae4
f01209a1:	e8 c6 05 fe ff       	call   f0100f6c <cprintf>
f01209a6:	83 c4 10             	add    $0x10,%esp
}
f01209a9:	90                   	nop
f01209aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01209ad:	5b                   	pop    %ebx
f01209ae:	5e                   	pop    %esi
f01209af:	5f                   	pop    %edi
f01209b0:	5d                   	pop    %ebp
f01209b1:	c3                   	ret    

f01209b2 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f01209b2:	55                   	push   %ebp
f01209b3:	89 e5                	mov    %esp,%ebp
f01209b5:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f01209b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f01209be:	8b 45 08             	mov    0x8(%ebp),%eax
f01209c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01209c4:	89 10                	mov    %edx,(%eax)
}
f01209c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01209c9:	c9                   	leave  
f01209ca:	c2 04 00             	ret    $0x4

f01209cd <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f01209cd:	55                   	push   %ebp
f01209ce:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f01209d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01209d3:	85 c0                	test   %eax,%eax
f01209d5:	78 16                	js     f01209ed <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f01209d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01209da:	05 00 20 00 00       	add    $0x2000,%eax
f01209df:	85 c0                	test   %eax,%eax
f01209e1:	79 05                	jns    f01209e8 <fix_round+0x1b>
f01209e3:	05 ff 3f 00 00       	add    $0x3fff,%eax
f01209e8:	c1 f8 0e             	sar    $0xe,%eax
f01209eb:	eb 14                	jmp    f0120a01 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f01209ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01209f0:	2d 00 20 00 00       	sub    $0x2000,%eax
f01209f5:	85 c0                	test   %eax,%eax
f01209f7:	79 05                	jns    f01209fe <fix_round+0x31>
f01209f9:	05 ff 3f 00 00       	add    $0x3fff,%eax
f01209fe:	c1 f8 0e             	sar    $0xe,%eax
}
f0120a01:	5d                   	pop    %ebp
f0120a02:	c3                   	ret    

f0120a03 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f0120a03:	55                   	push   %ebp
f0120a04:	89 e5                	mov    %esp,%ebp
f0120a06:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f0120a09:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120a0d:	79 16                	jns    f0120a25 <fix_scale+0x22>
f0120a0f:	68 b0 fb 12 f0       	push   $0xf012fbb0
f0120a14:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0120a19:	6a 5a                	push   $0x5a
f0120a1b:	68 cc fb 12 f0       	push   $0xf012fbcc
f0120a20:	e8 f5 f8 fd ff       	call   f010031a <_panic>
  return __mk_fix (x.f * n);
f0120a25:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a28:	0f af 45 10          	imul   0x10(%ebp),%eax
f0120a2c:	89 c2                	mov    %eax,%edx
f0120a2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a31:	83 ec 08             	sub    $0x8,%esp
f0120a34:	52                   	push   %edx
f0120a35:	50                   	push   %eax
f0120a36:	e8 77 ff ff ff       	call   f01209b2 <__mk_fix>
f0120a3b:	83 c4 0c             	add    $0xc,%esp
}
f0120a3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a41:	c9                   	leave  
f0120a42:	c2 04 00             	ret    $0x4

f0120a45 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f0120a45:	55                   	push   %ebp
f0120a46:	89 e5                	mov    %esp,%ebp
f0120a48:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f0120a4b:	83 ec 08             	sub    $0x8,%esp
f0120a4e:	68 e0 fb 12 f0       	push   $0xf012fbe0
f0120a53:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120a58:	e8 93 e0 fe ff       	call   f010eaf0 <init_spinlock>
f0120a5d:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f0120a60:	83 ec 0c             	sub    $0xc,%esp
f0120a63:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120a68:	e8 b4 e0 fe ff       	call   f010eb21 <acquire_spinlock>
f0120a6d:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f0120a70:	c7 05 88 0d 5a f0 00 	movl   $0x0,0xf05a0d88
f0120a77:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f0120a7a:	83 ec 0c             	sub    $0xc,%esp
f0120a7d:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120a82:	e8 21 e1 fe ff       	call   f010eba8 <release_spinlock>
f0120a87:	83 c4 10             	add    $0x10,%esp
}
f0120a8a:	90                   	nop
f0120a8b:	c9                   	leave  
f0120a8c:	c3                   	ret    

f0120a8d <inctst>:
void inctst()
{
f0120a8d:	55                   	push   %ebp
f0120a8e:	89 e5                	mov    %esp,%ebp
f0120a90:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f0120a93:	83 ec 0c             	sub    $0xc,%esp
f0120a96:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120a9b:	e8 81 e0 fe ff       	call   f010eb21 <acquire_spinlock>
f0120aa0:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f0120aa3:	a1 88 0d 5a f0       	mov    0xf05a0d88,%eax
f0120aa8:	40                   	inc    %eax
f0120aa9:	a3 88 0d 5a f0       	mov    %eax,0xf05a0d88
	}
	release_spinlock(&tstcntlock);
f0120aae:	83 ec 0c             	sub    $0xc,%esp
f0120ab1:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120ab6:	e8 ed e0 fe ff       	call   f010eba8 <release_spinlock>
f0120abb:	83 c4 10             	add    $0x10,%esp
}
f0120abe:	90                   	nop
f0120abf:	c9                   	leave  
f0120ac0:	c3                   	ret    

f0120ac1 <gettst>:
uint32 gettst()
{
f0120ac1:	55                   	push   %ebp
f0120ac2:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f0120ac4:	a1 88 0d 5a f0       	mov    0xf05a0d88,%eax
}
f0120ac9:	5d                   	pop    %ebp
f0120aca:	c3                   	ret    

f0120acb <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f0120acb:	55                   	push   %ebp
f0120acc:	89 e5                	mov    %esp,%ebp
f0120ace:	83 ec 28             	sub    $0x28,%esp
f0120ad1:	8b 45 14             	mov    0x14(%ebp),%eax
f0120ad4:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f0120ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f0120ade:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f0120ae2:	83 f8 65             	cmp    $0x65,%eax
f0120ae5:	74 5d                	je     f0120b44 <tst+0x79>
f0120ae7:	83 f8 65             	cmp    $0x65,%eax
f0120aea:	7f 0a                	jg     f0120af6 <tst+0x2b>
f0120aec:	83 f8 62             	cmp    $0x62,%eax
f0120aef:	74 73                	je     f0120b64 <tst+0x99>
f0120af1:	e9 91 00 00 00       	jmp    f0120b87 <tst+0xbc>
f0120af6:	83 f8 67             	cmp    $0x67,%eax
f0120af9:	74 29                	je     f0120b24 <tst+0x59>
f0120afb:	83 f8 6c             	cmp    $0x6c,%eax
f0120afe:	0f 85 83 00 00 00    	jne    f0120b87 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f0120b04:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b07:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120b0a:	73 09                	jae    f0120b15 <tst+0x4a>
			chk = 1;
f0120b0c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0120b13:	eb 68                	jmp    f0120b7d <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0120b15:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120b19:	74 62                	je     f0120b7d <tst+0xb2>
			chk = 1;
f0120b1b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120b22:	eb 59                	jmp    f0120b7d <tst+0xb2>
	case 'g':
		if (n > v1)
f0120b24:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b27:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120b2a:	76 09                	jbe    f0120b35 <tst+0x6a>
			chk = 1;
f0120b2c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0120b33:	eb 4b                	jmp    f0120b80 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f0120b35:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120b39:	74 45                	je     f0120b80 <tst+0xb5>
			chk = 1;
f0120b3b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120b42:	eb 3c                	jmp    f0120b80 <tst+0xb5>
	case 'e':
		if (n == v1)
f0120b44:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b47:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120b4a:	75 09                	jne    f0120b55 <tst+0x8a>
			chk = 1;
f0120b4c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0120b53:	eb 2e                	jmp    f0120b83 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f0120b55:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120b59:	74 28                	je     f0120b83 <tst+0xb8>
			chk = 1;
f0120b5b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120b62:	eb 1f                	jmp    f0120b83 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f0120b64:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b67:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120b6a:	72 1a                	jb     f0120b86 <tst+0xbb>
f0120b6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b6f:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120b72:	77 12                	ja     f0120b86 <tst+0xbb>
			chk = 1;
f0120b74:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120b7b:	eb 09                	jmp    f0120b86 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0120b7d:	90                   	nop
f0120b7e:	eb 07                	jmp    f0120b87 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0120b80:	90                   	nop
f0120b81:	eb 04                	jmp    f0120b87 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0120b83:	90                   	nop
f0120b84:	eb 01                	jmp    f0120b87 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f0120b86:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f0120b87:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120b8b:	75 14                	jne    f0120ba1 <tst+0xd6>
f0120b8d:	83 ec 04             	sub    $0x4,%esp
f0120b90:	68 ec fb 12 f0       	push   $0xf012fbec
f0120b95:	6a 48                	push   $0x48
f0120b97:	68 ff fb 12 f0       	push   $0xf012fbff
f0120b9c:	e8 79 f7 fd ff       	call   f010031a <_panic>

	acquire_spinlock(&tstcntlock);
f0120ba1:	83 ec 0c             	sub    $0xc,%esp
f0120ba4:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120ba9:	e8 73 df fe ff       	call   f010eb21 <acquire_spinlock>
f0120bae:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f0120bb1:	a1 88 0d 5a f0       	mov    0xf05a0d88,%eax
f0120bb6:	40                   	inc    %eax
f0120bb7:	a3 88 0d 5a f0       	mov    %eax,0xf05a0d88
	}
	release_spinlock(&tstcntlock);
f0120bbc:	83 ec 0c             	sub    $0xc,%esp
f0120bbf:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120bc4:	e8 df df fe ff       	call   f010eba8 <release_spinlock>
f0120bc9:	83 c4 10             	add    $0x10,%esp

	return;
f0120bcc:	90                   	nop
}
f0120bcd:	c9                   	leave  
f0120bce:	c3                   	ret    

f0120bcf <chktst>:

void chktst(uint32 n)
{
f0120bcf:	55                   	push   %ebp
f0120bd0:	89 e5                	mov    %esp,%ebp
f0120bd2:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f0120bd5:	83 ec 0c             	sub    $0xc,%esp
f0120bd8:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120bdd:	e8 3f df fe ff       	call   f010eb21 <acquire_spinlock>
f0120be2:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0120be5:	a1 88 0d 5a f0       	mov    0xf05a0d88,%eax
f0120bea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f0120bed:	83 ec 0c             	sub    $0xc,%esp
f0120bf0:	68 a0 3b 5a f0       	push   $0xf05a3ba0
f0120bf5:	e8 ae df fe ff       	call   f010eba8 <release_spinlock>
f0120bfa:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f0120bfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c00:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120c03:	75 12                	jne    f0120c17 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0120c05:	83 ec 0c             	sub    $0xc,%esp
f0120c08:	68 18 fc 12 f0       	push   $0xf012fc18
f0120c0d:	e8 5a 03 fe ff       	call   f0100f6c <cprintf>
f0120c12:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0120c15:	eb 14                	jmp    f0120c2b <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0120c17:	83 ec 04             	sub    $0x4,%esp
f0120c1a:	68 44 fc 12 f0       	push   $0xf012fc44
f0120c1f:	6a 5e                	push   $0x5e
f0120c21:	68 ff fb 12 f0       	push   $0xf012fbff
f0120c26:	e8 ef f6 fd ff       	call   f010031a <_panic>
}
f0120c2b:	c9                   	leave  
f0120c2c:	c3                   	ret    

f0120c2d <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0120c2d:	55                   	push   %ebp
f0120c2e:	89 e5                	mov    %esp,%ebp
f0120c30:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0120c33:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0120c37:	77 07                	ja     f0120c40 <nearest_pow2_ceil+0x13>
f0120c39:	b8 01 00 00 00       	mov    $0x1,%eax
f0120c3e:	eb 20                	jmp    f0120c60 <nearest_pow2_ceil+0x33>
	int power = 2;
f0120c40:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0120c47:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0120c4a:	eb 08                	jmp    f0120c54 <nearest_pow2_ceil+0x27>
		power <<= 1;
f0120c4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120c4f:	01 c0                	add    %eax,%eax
f0120c51:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f0120c54:	d1 6d 08             	shrl   0x8(%ebp)
f0120c57:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120c5b:	75 ef                	jne    f0120c4c <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f0120c5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120c60:	c9                   	leave  
f0120c61:	c3                   	ret    

f0120c62 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f0120c62:	55                   	push   %ebp
f0120c63:	89 e5                	mov    %esp,%ebp
f0120c65:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0120c68:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0120c6c:	77 07                	ja     f0120c75 <log2_ceil+0x13>
f0120c6e:	b8 01 00 00 00       	mov    $0x1,%eax
f0120c73:	eb 1b                	jmp    f0120c90 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f0120c75:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0120c7c:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0120c7f:	eb 03                	jmp    f0120c84 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f0120c81:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f0120c84:	d1 6d 08             	shrl   0x8(%ebp)
f0120c87:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120c8b:	75 f4                	jne    f0120c81 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f0120c8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120c90:	c9                   	leave  
f0120c91:	c3                   	ret    

f0120c92 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f0120c92:	55                   	push   %ebp
f0120c93:	89 e5                	mov    %esp,%ebp
f0120c95:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0120c98:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f0120c9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0120ca6:	eb 12                	jmp    f0120cba <fixedPt2Str+0x28>
		mulFactor *= 10;
f0120ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120cab:	89 d0                	mov    %edx,%eax
f0120cad:	c1 e0 02             	shl    $0x2,%eax
f0120cb0:	01 d0                	add    %edx,%eax
f0120cb2:	01 c0                	add    %eax,%eax
f0120cb4:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0120cb7:	ff 45 f0             	incl   -0x10(%ebp)
f0120cba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cbd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120cc0:	7c e6                	jl     f0120ca8 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f0120cc2:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0120cc5:	83 ec 04             	sub    $0x4,%esp
f0120cc8:	ff 75 f4             	pushl  -0xc(%ebp)
f0120ccb:	ff 75 08             	pushl  0x8(%ebp)
f0120cce:	50                   	push   %eax
f0120ccf:	e8 2f fd ff ff       	call   f0120a03 <fix_scale>
f0120cd4:	83 c4 0c             	add    $0xc,%esp
f0120cd7:	83 ec 0c             	sub    $0xc,%esp
f0120cda:	ff 75 dc             	pushl  -0x24(%ebp)
f0120cdd:	e8 eb fc ff ff       	call   f01209cd <fix_round>
f0120ce2:	83 c4 10             	add    $0x10,%esp
f0120ce5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0120ce8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120ceb:	99                   	cltd   
f0120cec:	f7 7d f4             	idivl  -0xc(%ebp)
f0120cef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f0120cf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120cf5:	99                   	cltd   
f0120cf6:	f7 7d f4             	idivl  -0xc(%ebp)
f0120cf9:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f0120cfc:	83 ec 08             	sub    $0x8,%esp
f0120cff:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120d02:	50                   	push   %eax
f0120d03:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120d06:	e8 70 1d 00 00       	call   f0122a7b <ltostr>
f0120d0b:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f0120d0e:	83 ec 08             	sub    $0x8,%esp
f0120d11:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120d14:	50                   	push   %eax
f0120d15:	ff 75 e0             	pushl  -0x20(%ebp)
f0120d18:	e8 5e 1d 00 00       	call   f0122a7b <ltostr>
f0120d1d:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f0120d20:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0120d23:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120d28:	f7 e9                	imul   %ecx
f0120d2a:	c1 fa 02             	sar    $0x2,%edx
f0120d2d:	89 c8                	mov    %ecx,%eax
f0120d2f:	c1 f8 1f             	sar    $0x1f,%eax
f0120d32:	29 c2                	sub    %eax,%edx
f0120d34:	89 d0                	mov    %edx,%eax
f0120d36:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f0120d39:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f0120d40:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f0120d47:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f0120d4d:	eb 31                	jmp    f0120d80 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f0120d4f:	83 ec 04             	sub    $0x4,%esp
f0120d52:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120d55:	50                   	push   %eax
f0120d56:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120d59:	50                   	push   %eax
f0120d5a:	68 60 fc 12 f0       	push   $0xf012fc60
f0120d5f:	e8 f0 1d 00 00       	call   f0122b54 <strcconcat>
f0120d64:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f0120d67:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0120d6a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120d6f:	f7 e9                	imul   %ecx
f0120d71:	c1 fa 02             	sar    $0x2,%edx
f0120d74:	89 c8                	mov    %ecx,%eax
f0120d76:	c1 f8 1f             	sar    $0x1f,%eax
f0120d79:	29 c2                	sub    %eax,%edx
f0120d7b:	89 d0                	mov    %edx,%eax
f0120d7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f0120d80:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120d83:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120d86:	7c c7                	jl     f0120d4f <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f0120d88:	83 ec 04             	sub    $0x4,%esp
f0120d8b:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0120d8e:	50                   	push   %eax
f0120d8f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120d92:	50                   	push   %eax
f0120d93:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120d96:	50                   	push   %eax
f0120d97:	e8 b8 1d 00 00       	call   f0122b54 <strcconcat>
f0120d9c:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f0120d9f:	83 ec 04             	sub    $0x4,%esp
f0120da2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120da5:	50                   	push   %eax
f0120da6:	68 62 fc 12 f0       	push   $0xf012fc62
f0120dab:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120dae:	50                   	push   %eax
f0120daf:	e8 a0 1d 00 00       	call   f0122b54 <strcconcat>
f0120db4:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0120db7:	83 ec 04             	sub    $0x4,%esp
f0120dba:	ff 75 10             	pushl  0x10(%ebp)
f0120dbd:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0120dc0:	50                   	push   %eax
f0120dc1:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120dc4:	50                   	push   %eax
f0120dc5:	e8 8a 1d 00 00       	call   f0122b54 <strcconcat>
f0120dca:	83 c4 10             	add    $0x10,%esp

}
f0120dcd:	90                   	nop
f0120dce:	c9                   	leave  
f0120dcf:	c3                   	ret    

f0120dd0 <sys_utilities>:

int __firstTimeSleep = 1;
struct Channel __tstchan__ ;
struct spinlock __tstchan_lk__;
void sys_utilities(char* utilityName, int value)
{
f0120dd0:	55                   	push   %ebp
f0120dd1:	89 e5                	mov    %esp,%ebp
f0120dd3:	81 ec 88 00 00 00    	sub    $0x88,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0120dd9:	83 ec 0c             	sub    $0xc,%esp
f0120ddc:	68 64 fc 12 f0       	push   $0xf012fc64
f0120de1:	e8 ef 17 00 00       	call   f01225d5 <strlen>
f0120de6:	83 c4 10             	add    $0x10,%esp
f0120de9:	83 ec 04             	sub    $0x4,%esp
f0120dec:	50                   	push   %eax
f0120ded:	68 64 fc 12 f0       	push   $0xf012fc64
f0120df2:	ff 75 08             	pushl  0x8(%ebp)
f0120df5:	e8 1f 19 00 00       	call   f0122719 <strncmp>
f0120dfa:	83 c4 10             	add    $0x10,%esp
f0120dfd:	85 c0                	test   %eax,%eax
f0120dff:	0f 85 84 00 00 00    	jne    f0120e89 <sys_utilities+0xb9>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120e05:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120e08:	50                   	push   %eax
f0120e09:	8d 45 80             	lea    -0x80(%ebp),%eax
f0120e0c:	50                   	push   %eax
f0120e0d:	68 72 fc 12 f0       	push   $0xf012fc72
f0120e12:	ff 75 08             	pushl  0x8(%ebp)
f0120e15:	e8 d0 1d 00 00       	call   f0122bea <strsplit>
f0120e1a:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0120e1d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0120e20:	83 ec 04             	sub    $0x4,%esp
f0120e23:	6a 0a                	push   $0xa
f0120e25:	6a 00                	push   $0x0
f0120e27:	50                   	push   %eax
f0120e28:	e8 08 1b 00 00       	call   f0122935 <strtol>
f0120e2d:	83 c4 10             	add    $0x10,%esp
f0120e30:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f0120e33:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		envid2env(envID, &env, 0);
f0120e3a:	83 ec 04             	sub    $0x4,%esp
f0120e3d:	6a 00                	push   $0x0
f0120e3f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0120e42:	50                   	push   %eax
f0120e43:	ff 75 e0             	pushl  -0x20(%ebp)
f0120e46:	e8 75 99 fe ff       	call   f010a7c0 <envid2env>
f0120e4b:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0120e4e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120e51:	8b 40 10             	mov    0x10(%eax),%eax
f0120e54:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0120e57:	74 19                	je     f0120e72 <sys_utilities+0xa2>
f0120e59:	68 74 fc 12 f0       	push   $0xf012fc74
f0120e5e:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0120e63:	68 a1 00 00 00       	push   $0xa1
f0120e68:	68 ff fb 12 f0       	push   $0xf012fbff
f0120e6d:	e8 a8 f4 fd ff       	call   f010031a <_panic>
		env_set_nice(env, value);
f0120e72:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120e75:	83 ec 08             	sub    $0x8,%esp
f0120e78:	ff 75 0c             	pushl  0xc(%ebp)
f0120e7b:	50                   	push   %eax
f0120e7c:	e8 26 58 fe ff       	call   f01066a7 <env_set_nice>
f0120e81:	83 c4 10             	add    $0x10,%esp
f0120e84:	e9 00 03 00 00       	jmp    f0121189 <sys_utilities+0x3b9>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f0120e89:	83 ec 0c             	sub    $0xc,%esp
f0120e8c:	68 89 fc 12 f0       	push   $0xf012fc89
f0120e91:	e8 3f 17 00 00       	call   f01225d5 <strlen>
f0120e96:	83 c4 10             	add    $0x10,%esp
f0120e99:	83 ec 04             	sub    $0x4,%esp
f0120e9c:	50                   	push   %eax
f0120e9d:	68 89 fc 12 f0       	push   $0xf012fc89
f0120ea2:	ff 75 08             	pushl  0x8(%ebp)
f0120ea5:	e8 6f 18 00 00       	call   f0122719 <strncmp>
f0120eaa:	83 c4 10             	add    $0x10,%esp
f0120ead:	85 c0                	test   %eax,%eax
f0120eaf:	0f 85 a0 01 00 00    	jne    f0121055 <sys_utilities+0x285>
	{
		int* numOfInstances = (int*) value ;
f0120eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120eb8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120ebb:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0120ebe:	50                   	push   %eax
f0120ebf:	8d 45 80             	lea    -0x80(%ebp),%eax
f0120ec2:	50                   	push   %eax
f0120ec3:	68 72 fc 12 f0       	push   $0xf012fc72
f0120ec8:	ff 75 08             	pushl  0x8(%ebp)
f0120ecb:	e8 1a 1d 00 00       	call   f0122bea <strsplit>
f0120ed0:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0120ed3:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0120ed6:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f0120ed9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0120ee0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f0120ee7:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0120eee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120ef1:	8b 00                	mov    (%eax),%eax
f0120ef3:	85 c0                	test   %eax,%eax
f0120ef5:	79 1c                	jns    f0120f13 <sys_utilities+0x143>
		{
			chkAscending = 0;
f0120ef7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0120efe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f01:	8b 00                	mov    (%eax),%eax
f0120f03:	f7 d8                	neg    %eax
f0120f05:	89 c2                	mov    %eax,%edx
f0120f07:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f0a:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0120f0c:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f0120f13:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f0120f1a:	83 ec 0c             	sub    $0xc,%esp
f0120f1d:	68 00 0e 5a f0       	push   $0xf05a0e00
f0120f22:	e8 fa db fe ff       	call   f010eb21 <acquire_spinlock>
f0120f27:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0120f2a:	a1 8c 0e 5a f0       	mov    0xf05a0e8c,%eax
f0120f2f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0120f32:	a1 84 0e 5a f0       	mov    0xf05a0e84,%eax
f0120f37:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0120f3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120f3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0120f40:	eb 6c                	jmp    f0120fae <sys_utilities+0x1de>
			{
				if (strcmp(env->prog_name, progName) != 0)
f0120f42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f45:	83 c0 20             	add    $0x20,%eax
f0120f48:	83 ec 08             	sub    $0x8,%esp
f0120f4b:	ff 75 d8             	pushl  -0x28(%ebp)
f0120f4e:	50                   	push   %eax
f0120f4f:	e8 8d 17 00 00       	call   f01226e1 <strcmp>
f0120f54:	83 c4 10             	add    $0x10,%esp
f0120f57:	85 c0                	test   %eax,%eax
f0120f59:	75 46                	jne    f0120fa1 <sys_utilities+0x1d1>
					continue;
				(*numOfInstances)-- ;
f0120f5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f5e:	8b 00                	mov    (%eax),%eax
f0120f60:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120f63:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f66:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f0120f68:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120f6c:	74 14                	je     f0120f82 <sys_utilities+0x1b2>
				{
					if (prevEnvID > env->env_id)
f0120f6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f71:	8b 40 10             	mov    0x10(%eax),%eax
f0120f74:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120f77:	7d 1d                	jge    f0120f96 <sys_utilities+0x1c6>
					{
						success = 0;
f0120f79:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0120f80:	eb 32                	jmp    f0120fb4 <sys_utilities+0x1e4>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f0120f82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f85:	8b 40 10             	mov    0x10(%eax),%eax
f0120f88:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120f8b:	7e 09                	jle    f0120f96 <sys_utilities+0x1c6>
					{
						success = 0;
f0120f8d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0120f94:	eb 1e                	jmp    f0120fb4 <sys_utilities+0x1e4>
					}
				}
				prevEnvID = env->env_id;
f0120f96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f99:	8b 40 10             	mov    0x10(%eax),%eax
f0120f9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120f9f:	eb 01                	jmp    f0120fa2 <sys_utilities+0x1d2>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0120fa1:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0120fa2:	ff 4d e4             	decl   -0x1c(%ebp)
f0120fa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fa8:	8b 40 0c             	mov    0xc(%eax),%eax
f0120fab:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120fae:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120fb2:	7f 8e                	jg     f0120f42 <sys_utilities+0x172>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f0120fb4:	83 ec 0c             	sub    $0xc,%esp
f0120fb7:	68 00 0e 5a f0       	push   $0xf05a0e00
f0120fbc:	e8 e7 db fe ff       	call   f010eba8 <release_spinlock>
f0120fc1:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f0120fc4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120fc7:	8b 00                	mov    (%eax),%eax
f0120fc9:	85 c0                	test   %eax,%eax
f0120fcb:	75 06                	jne    f0120fd3 <sys_utilities+0x203>
f0120fcd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120fd1:	75 41                	jne    f0121014 <sys_utilities+0x244>
		{
			cprintf("###########################################\n");
f0120fd3:	83 ec 0c             	sub    $0xc,%esp
f0120fd6:	68 9c fc 12 f0       	push   $0xf012fc9c
f0120fdb:	e8 8c ff fd ff       	call   f0100f6c <cprintf>
f0120fe0:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f0120fe3:	83 ec 08             	sub    $0x8,%esp
f0120fe6:	ff 75 d8             	pushl  -0x28(%ebp)
f0120fe9:	68 cc fc 12 f0       	push   $0xf012fccc
f0120fee:	e8 79 ff fd ff       	call   f0100f6c <cprintf>
f0120ff3:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f0120ff6:	83 ec 0c             	sub    $0xc,%esp
f0120ff9:	68 9c fc 12 f0       	push   $0xf012fc9c
f0120ffe:	e8 69 ff fd ff       	call   f0100f6c <cprintf>
f0121003:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f0121006:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121009:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012100f:	e9 75 01 00 00       	jmp    f0121189 <sys_utilities+0x3b9>
		}
		else
		{
			cprintf("####################################################\n");
f0121014:	83 ec 0c             	sub    $0xc,%esp
f0121017:	68 ec fc 12 f0       	push   $0xf012fcec
f012101c:	e8 4b ff fd ff       	call   f0100f6c <cprintf>
f0121021:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f0121024:	83 ec 08             	sub    $0x8,%esp
f0121027:	ff 75 d8             	pushl  -0x28(%ebp)
f012102a:	68 24 fd 12 f0       	push   $0xf012fd24
f012102f:	e8 38 ff fd ff       	call   f0100f6c <cprintf>
f0121034:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f0121037:	83 ec 0c             	sub    $0xc,%esp
f012103a:	68 ec fc 12 f0       	push   $0xf012fcec
f012103f:	e8 28 ff fd ff       	call   f0100f6c <cprintf>
f0121044:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f0121047:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012104a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f0121050:	e9 34 01 00 00       	jmp    f0121189 <sys_utilities+0x3b9>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f0121055:	83 ec 08             	sub    $0x8,%esp
f0121058:	68 47 fd 12 f0       	push   $0xf012fd47
f012105d:	ff 75 08             	pushl  0x8(%ebp)
f0121060:	e8 7c 16 00 00       	call   f01226e1 <strcmp>
f0121065:	83 c4 10             	add    $0x10,%esp
f0121068:	85 c0                	test   %eax,%eax
f012106a:	75 77                	jne    f01210e3 <sys_utilities+0x313>
	{
		if (__firstTimeSleep)
f012106c:	a1 e0 fd 17 f0       	mov    0xf017fde0,%eax
f0121071:	85 c0                	test   %eax,%eax
f0121073:	74 34                	je     f01210a9 <sys_utilities+0x2d9>
		{
			__firstTimeSleep = 0;
f0121075:	c7 05 e0 fd 17 f0 00 	movl   $0x0,0xf017fde0
f012107c:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f012107f:	83 ec 08             	sub    $0x8,%esp
f0121082:	68 51 fd 12 f0       	push   $0xf012fd51
f0121087:	68 60 63 5c f0       	push   $0xf05c6360
f012108c:	e8 50 de fe ff       	call   f010eee1 <init_channel>
f0121091:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f0121094:	83 ec 08             	sub    $0x8,%esp
f0121097:	68 5e fd 12 f0       	push   $0xf012fd5e
f012109c:	68 c0 63 5c f0       	push   $0xf05c63c0
f01210a1:	e8 4a da fe ff       	call   f010eaf0 <init_spinlock>
f01210a6:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f01210a9:	83 ec 0c             	sub    $0xc,%esp
f01210ac:	68 c0 63 5c f0       	push   $0xf05c63c0
f01210b1:	e8 6b da fe ff       	call   f010eb21 <acquire_spinlock>
f01210b6:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f01210b9:	83 ec 08             	sub    $0x8,%esp
f01210bc:	68 c0 63 5c f0       	push   $0xf05c63c0
f01210c1:	68 60 63 5c f0       	push   $0xf05c6360
f01210c6:	e8 43 de fe ff       	call   f010ef0e <sleep>
f01210cb:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f01210ce:	83 ec 0c             	sub    $0xc,%esp
f01210d1:	68 c0 63 5c f0       	push   $0xf05c63c0
f01210d6:	e8 cd da fe ff       	call   f010eba8 <release_spinlock>
f01210db:	83 c4 10             	add    $0x10,%esp
f01210de:	e9 a6 00 00 00       	jmp    f0121189 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f01210e3:	83 ec 08             	sub    $0x8,%esp
f01210e6:	68 70 fd 12 f0       	push   $0xf012fd70
f01210eb:	ff 75 08             	pushl  0x8(%ebp)
f01210ee:	e8 ee 15 00 00       	call   f01226e1 <strcmp>
f01210f3:	83 c4 10             	add    $0x10,%esp
f01210f6:	85 c0                	test   %eax,%eax
f01210f8:	75 12                	jne    f012110c <sys_utilities+0x33c>
	{
		wakeup_one(&__tstchan__);
f01210fa:	83 ec 0c             	sub    $0xc,%esp
f01210fd:	68 60 63 5c f0       	push   $0xf05c6360
f0121102:	e8 74 de fe ff       	call   f010ef7b <wakeup_one>
f0121107:	83 c4 10             	add    $0x10,%esp
f012110a:	eb 7d                	jmp    f0121189 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f012110c:	83 ec 08             	sub    $0x8,%esp
f012110f:	68 7e fd 12 f0       	push   $0xf012fd7e
f0121114:	ff 75 08             	pushl  0x8(%ebp)
f0121117:	e8 c5 15 00 00       	call   f01226e1 <strcmp>
f012111c:	83 c4 10             	add    $0x10,%esp
f012111f:	85 c0                	test   %eax,%eax
f0121121:	75 12                	jne    f0121135 <sys_utilities+0x365>
	{
		wakeup_all(&__tstchan__);
f0121123:	83 ec 0c             	sub    $0xc,%esp
f0121126:	68 60 63 5c f0       	push   $0xf05c6360
f012112b:	e8 cf de fe ff       	call   f010efff <wakeup_all>
f0121130:	83 c4 10             	add    $0x10,%esp
f0121133:	eb 54                	jmp    f0121189 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f0121135:	83 ec 08             	sub    $0x8,%esp
f0121138:	68 8c fd 12 f0       	push   $0xf012fd8c
f012113d:	ff 75 08             	pushl  0x8(%ebp)
f0121140:	e8 9c 15 00 00       	call   f01226e1 <strcmp>
f0121145:	83 c4 10             	add    $0x10,%esp
f0121148:	85 c0                	test   %eax,%eax
f012114a:	75 14                	jne    f0121160 <sys_utilities+0x390>
	{
		int* numOfProcesses = (int*) value ;
f012114c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012114f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f0121152:	a1 6c 63 5c f0       	mov    0xf05c636c,%eax
f0121157:	89 c2                	mov    %eax,%edx
f0121159:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012115c:	89 10                	mov    %edx,(%eax)
f012115e:	eb 29                	jmp    f0121189 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f0121160:	83 ec 08             	sub    $0x8,%esp
f0121163:	68 a1 fd 12 f0       	push   $0xf012fda1
f0121168:	ff 75 08             	pushl  0x8(%ebp)
f012116b:	e8 71 15 00 00       	call   f01226e1 <strcmp>
f0121170:	83 c4 10             	add    $0x10,%esp
f0121173:	85 c0                	test   %eax,%eax
f0121175:	75 12                	jne    f0121189 <sys_utilities+0x3b9>
	{
		int* numOfProcesses = (int*) value ;
f0121177:	8b 45 0c             	mov    0xc(%ebp),%eax
f012117a:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f012117d:	a1 9c 0e 5a f0       	mov    0xf05a0e9c,%eax
f0121182:	89 c2                	mov    %eax,%edx
f0121184:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121187:	89 10                	mov    %edx,(%eax)
	}

	if ((int)value < 0)
f0121189:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012118d:	79 5b                	jns    f01211ea <sys_utilities+0x41a>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f012118f:	83 ec 08             	sub    $0x8,%esp
f0121192:	68 b7 fd 12 f0       	push   $0xf012fdb7
f0121197:	ff 75 08             	pushl  0x8(%ebp)
f012119a:	e8 42 15 00 00       	call   f01226e1 <strcmp>
f012119f:	83 c4 10             	add    $0x10,%esp
f01211a2:	85 c0                	test   %eax,%eax
f01211a4:	75 44                	jne    f01211ea <sys_utilities+0x41a>
		{
			switch (value)
f01211a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01211a9:	83 f8 fc             	cmp    $0xfffffffc,%eax
f01211ac:	74 07                	je     f01211b5 <sys_utilities+0x3e5>
f01211ae:	83 f8 fe             	cmp    $0xfffffffe,%eax
f01211b1:	74 19                	je     f01211cc <sys_utilities+0x3fc>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f01211b3:	eb 35                	jmp    f01211ea <sys_utilities+0x41a>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f01211b5:	83 ec 0c             	sub    $0xc,%esp
f01211b8:	68 c8 fd 12 f0       	push   $0xf012fdc8
f01211bd:	e8 aa fd fd ff       	call   f0100f6c <cprintf>
f01211c2:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f01211c5:	e8 fe d4 fe ff       	call   f010e6c8 <setPageReplacmentAlgorithmFIFO>
				break;
f01211ca:	eb 1e                	jmp    f01211ea <sys_utilities+0x41a>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f01211cc:	83 ec 0c             	sub    $0xc,%esp
f01211cf:	68 38 fe 12 f0       	push   $0xf012fe38
f01211d4:	e8 93 fd fd ff       	call   f0100f6c <cprintf>
f01211d9:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f01211dc:	83 ec 0c             	sub    $0xc,%esp
f01211df:	6a 02                	push   $0x2
f01211e1:	e8 9f d4 fe ff       	call   f010e685 <setPageReplacmentAlgorithmLRU>
f01211e6:	83 c4 10             	add    $0x10,%esp
				break;
f01211e9:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f01211ea:	90                   	nop
f01211eb:	c9                   	leave  
f01211ec:	c3                   	ret    

f01211ed <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f01211ed:	55                   	push   %ebp
f01211ee:	89 e5                	mov    %esp,%ebp
f01211f0:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f01211f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01211f6:	8b 00                	mov    (%eax),%eax
f01211f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f01211fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01211fe:	8b 00                	mov    (%eax),%eax
f0121200:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f0121203:	eb 52                	jmp    f0121257 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f0121205:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121208:	8b 00                	mov    (%eax),%eax
f012120a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f012120d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121210:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121213:	75 12                	jne    f0121227 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f0121215:	83 ec 0c             	sub    $0xc,%esp
f0121218:	68 ac fe 12 f0       	push   $0xf012feac
f012121d:	e8 4a fd fd ff       	call   f0100f6c <cprintf>
f0121222:	83 c4 10             	add    $0x10,%esp
			break;
f0121225:	eb 3f                	jmp    f0121266 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f0121227:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012122b:	74 38                	je     f0121265 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f012122d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121230:	8b 00                	mov    (%eax),%eax
f0121232:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0121235:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121238:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f012123b:	75 12                	jne    f012124f <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f012123d:	83 ec 0c             	sub    $0xc,%esp
f0121240:	68 c8 fe 12 f0       	push   $0xf012fec8
f0121245:	e8 22 fd fd ff       	call   f0100f6c <cprintf>
f012124a:	83 c4 10             	add    $0x10,%esp
			break;
f012124d:	eb 17                	jmp    f0121266 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f012124f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121252:	8b 00                	mov    (%eax),%eax
f0121254:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f0121257:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012125b:	74 09                	je     f0121266 <detect_loop_in_FrameInfo_list+0x79>
f012125d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121261:	75 a2                	jne    f0121205 <detect_loop_in_FrameInfo_list+0x18>
f0121263:	eb 01                	jmp    f0121266 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f0121265:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f0121266:	83 ec 0c             	sub    $0xc,%esp
f0121269:	68 df fe 12 f0       	push   $0xf012fedf
f012126e:	e8 f9 fc fd ff       	call   f0100f6c <cprintf>
f0121273:	83 c4 10             	add    $0x10,%esp
}
f0121276:	90                   	nop
f0121277:	c9                   	leave  
f0121278:	c3                   	ret    

f0121279 <scarce_memory>:

void scarce_memory()
{
f0121279:	55                   	push   %ebp
f012127a:	89 e5                	mov    %esp,%ebp
f012127c:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f012127f:	a1 80 35 5a f0       	mov    0xf05a3580,%eax
f0121284:	ba 64 00 00 00       	mov    $0x64,%edx
f0121289:	29 c2                	sub    %eax,%edx
f012128b:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0121290:	0f af c2             	imul   %edx,%eax
f0121293:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121298:	f7 e2                	mul    %edx
f012129a:	89 d0                	mov    %edx,%eax
f012129c:	c1 e8 05             	shr    $0x5,%eax
f012129f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f01212a2:	a1 80 35 5a f0       	mov    0xf05a3580,%eax
f01212a7:	ba 64 00 00 00       	mov    $0x64,%edx
f01212ac:	29 c2                	sub    %eax,%edx
f01212ae:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f01212b3:	89 d1                	mov    %edx,%ecx
f01212b5:	0f af c8             	imul   %eax,%ecx
f01212b8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01212bd:	f7 e1                	mul    %ecx
f01212bf:	c1 ea 05             	shr    $0x5,%edx
f01212c2:	89 d0                	mov    %edx,%eax
f01212c4:	c1 e0 02             	shl    $0x2,%eax
f01212c7:	01 d0                	add    %edx,%eax
f01212c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01212d0:	01 d0                	add    %edx,%eax
f01212d2:	c1 e0 02             	shl    $0x2,%eax
f01212d5:	29 c1                	sub    %eax,%ecx
f01212d7:	89 ca                	mov    %ecx,%edx
f01212d9:	85 d2                	test   %edx,%edx
f01212db:	74 03                	je     f01212e0 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f01212dd:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f01212e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f01212e7:	83 ec 0c             	sub    $0xc,%esp
f01212ea:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f01212ef:	e8 2d d8 fe ff       	call   f010eb21 <acquire_spinlock>
f01212f4:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f01212f7:	a1 cc 0e 5a f0       	mov    0xf05a0ecc,%eax
f01212fc:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f01212ff:	8b 15 58 36 5a f0    	mov    0xf05a3658,%edx
f0121305:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121308:	29 c2                	sub    %eax,%edx
f012130a:	89 d0                	mov    %edx,%eax
f012130c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f012130f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121312:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121315:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f0121318:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f012131f:	eb 12                	jmp    f0121333 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f0121321:	83 ec 0c             	sub    $0xc,%esp
f0121324:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0121327:	50                   	push   %eax
f0121328:	e8 a3 6e fe ff       	call   f01081d0 <allocate_frame>
f012132d:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0121330:	ff 45 f0             	incl   -0x10(%ebp)
f0121333:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121336:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0121339:	76 e6                	jbe    f0121321 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f012133b:	83 ec 0c             	sub    $0xc,%esp
f012133e:	68 e0 0e 5a f0       	push   $0xf05a0ee0
f0121343:	e8 60 d8 fe ff       	call   f010eba8 <release_spinlock>
f0121348:	83 c4 10             	add    $0x10,%esp

}
f012134b:	90                   	nop
f012134c:	c9                   	leave  
f012134d:	c3                   	ret    

f012134e <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f012134e:	55                   	push   %ebp
f012134f:	89 e5                	mov    %esp,%ebp
f0121351:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f0121354:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f012135b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f0121362:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0121369:	e8 02 94 fe ff       	call   f010a770 <get_cpu_proc>
f012136e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0121371:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121375:	75 19                	jne    f0121390 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f0121377:	68 f9 fe 12 f0       	push   $0xf012fef9
f012137c:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121381:	68 5b 01 00 00       	push   $0x15b
f0121386:	68 ff fb 12 f0       	push   $0xf012fbff
f012138b:	e8 8a ef fd ff       	call   f010031a <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f0121390:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0121394:	0f 85 f7 01 00 00    	jne    f0121591 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x243>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f012139a:	83 ec 0c             	sub    $0xc,%esp
f012139d:	68 00 0e 5a f0       	push   $0xf05a0e00
f01213a2:	e8 7a d7 fe ff       	call   f010eb21 <acquire_spinlock>
f01213a7:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01213aa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01213b1:	e9 e9 00 00 00       	jmp    f012149f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x151>
			{
				struct Env * ptr_ready_env = NULL;
f01213b6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f01213bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01213c0:	83 c0 09             	add    $0x9,%eax
f01213c3:	c1 e0 04             	shl    $0x4,%eax
f01213c6:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f01213cb:	8b 00                	mov    (%eax),%eax
f01213cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01213d0:	e9 81 00 00 00       	jmp    f0121456 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x108>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
f01213d5:	83 ec 0c             	sub    $0xc,%esp
f01213d8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01213db:	e8 7e 79 fe ff       	call   f0108d5e <env_page_ws_get_size>
f01213e0:	83 c4 10             	add    $0x10,%esp
f01213e3:	89 45 cc             	mov    %eax,-0x34(%ebp)
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f01213e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01213e9:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f01213ef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01213f2:	0f af c2             	imul   %edx,%eax
f01213f5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01213fa:	f7 e2                	mul    %edx
f01213fc:	89 d0                	mov    %edx,%eax
f01213fe:	c1 e8 05             	shr    $0x5,%eax
f0121401:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0121404:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121407:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f012140d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121410:	89 d1                	mov    %edx,%ecx
f0121412:	0f af c8             	imul   %eax,%ecx
f0121415:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f012141a:	f7 e1                	mul    %ecx
f012141c:	c1 ea 05             	shr    $0x5,%edx
f012141f:	89 d0                	mov    %edx,%eax
f0121421:	c1 e0 02             	shl    $0x2,%eax
f0121424:	01 d0                	add    %edx,%eax
f0121426:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012142d:	01 d0                	add    %edx,%eax
f012142f:	c1 e0 02             	shl    $0x2,%eax
f0121432:	29 c1                	sub    %eax,%ecx
f0121434:	89 ca                	mov    %ecx,%edx
f0121436:	85 d2                	test   %edx,%edx
f0121438:	74 03                	je     f012143d <calc_no_pages_tobe_removed_from_ready_exit_queues+0xef>
						num_of_pages_to_be_removed++;
f012143a:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f012143d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121440:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0121443:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121446:	83 c0 09             	add    $0x9,%eax
f0121449:	c1 e0 04             	shl    $0x4,%eax
f012144c:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0121451:	8b 00                	mov    (%eax),%eax
f0121453:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0121456:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012145a:	74 08                	je     f0121464 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x116>
f012145c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012145f:	8b 40 08             	mov    0x8(%eax),%eax
f0121462:	eb 05                	jmp    f0121469 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11b>
f0121464:	b8 00 00 00 00       	mov    $0x0,%eax
f0121469:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012146c:	83 c2 09             	add    $0x9,%edx
f012146f:	c1 e2 04             	shl    $0x4,%edx
f0121472:	81 c2 08 0e 5a f0    	add    $0xf05a0e08,%edx
f0121478:	89 02                	mov    %eax,(%edx)
f012147a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012147d:	83 c0 09             	add    $0x9,%eax
f0121480:	c1 e0 04             	shl    $0x4,%eax
f0121483:	05 08 0e 5a f0       	add    $0xf05a0e08,%eax
f0121488:	8b 00                	mov    (%eax),%eax
f012148a:	85 c0                	test   %eax,%eax
f012148c:	0f 85 43 ff ff ff    	jne    f01213d5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
f0121492:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121496:	0f 85 39 ff ff ff    	jne    f01213d5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f012149c:	ff 45 e8             	incl   -0x18(%ebp)
f012149f:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f01214a4:	0f b6 c0             	movzbl %al,%eax
f01214a7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01214aa:	0f 8f 06 ff ff ff    	jg     f01213b6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f01214b0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01214b7:	a1 80 0e 5a f0       	mov    0xf05a0e80,%eax
f01214bc:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01214bf:	eb 1f                	jmp    f01214e0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x192>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
f01214c1:	83 ec 0c             	sub    $0xc,%esp
f01214c4:	ff 75 dc             	pushl  -0x24(%ebp)
f01214c7:	e8 92 78 fe ff       	call   f0108d5e <env_page_ws_get_size>
f01214cc:	83 c4 10             	add    $0x10,%esp
f01214cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f01214d2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01214d5:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01214d8:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f01214dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01214e0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01214e4:	74 08                	je     f01214ee <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a0>
f01214e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01214e9:	8b 40 08             	mov    0x8(%eax),%eax
f01214ec:	eb 05                	jmp    f01214f3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a5>
f01214ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01214f3:	a3 88 0e 5a f0       	mov    %eax,0xf05a0e88
f01214f8:	a1 88 0e 5a f0       	mov    0xf05a0e88,%eax
f01214fd:	85 c0                	test   %eax,%eax
f01214ff:	75 c0                	jne    f01214c1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
f0121501:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121505:	75 ba                	jne    f01214c1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f0121507:	83 ec 0c             	sub    $0xc,%esp
f012150a:	68 00 0e 5a f0       	push   $0xf05a0e00
f012150f:	e8 94 d6 fe ff       	call   f010eba8 <release_spinlock>
f0121514:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f0121517:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f012151b:	0f 84 de 00 00 00    	je     f01215ff <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f0121521:	83 ec 0c             	sub    $0xc,%esp
f0121524:	ff 75 d0             	pushl  -0x30(%ebp)
f0121527:	e8 32 78 fe ff       	call   f0108d5e <env_page_ws_get_size>
f012152c:	83 c4 10             	add    $0x10,%esp
f012152f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0121532:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121535:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f012153b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012153e:	0f af c2             	imul   %edx,%eax
f0121541:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121546:	f7 e2                	mul    %edx
f0121548:	89 d0                	mov    %edx,%eax
f012154a:	c1 e8 05             	shr    $0x5,%eax
f012154d:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0121550:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121553:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f0121559:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012155c:	89 d1                	mov    %edx,%ecx
f012155e:	0f af c8             	imul   %eax,%ecx
f0121561:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121566:	f7 e1                	mul    %ecx
f0121568:	c1 ea 05             	shr    $0x5,%edx
f012156b:	89 d0                	mov    %edx,%eax
f012156d:	c1 e0 02             	shl    $0x2,%eax
f0121570:	01 d0                	add    %edx,%eax
f0121572:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121579:	01 d0                	add    %edx,%eax
f012157b:	c1 e0 02             	shl    $0x2,%eax
f012157e:	29 c1                	sub    %eax,%ecx
f0121580:	89 ca                	mov    %ecx,%edx
f0121582:	85 d2                	test   %edx,%edx
f0121584:	74 03                	je     f0121589 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x23b>
				num_of_pages_to_be_removed++;
f0121586:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0121589:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012158c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f012158f:	eb 6e                	jmp    f01215ff <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f0121591:	83 ec 0c             	sub    $0xc,%esp
f0121594:	ff 75 d0             	pushl  -0x30(%ebp)
f0121597:	e8 c2 77 fe ff       	call   f0108d5e <env_page_ws_get_size>
f012159c:	83 c4 10             	add    $0x10,%esp
f012159f:	89 45 c0             	mov    %eax,-0x40(%ebp)
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f01215a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01215a5:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f01215ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01215ae:	0f af c2             	imul   %edx,%eax
f01215b1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01215b6:	f7 e2                	mul    %edx
f01215b8:	89 d0                	mov    %edx,%eax
f01215ba:	c1 e8 05             	shr    $0x5,%eax
f01215bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f01215c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01215c3:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f01215c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01215cc:	89 d1                	mov    %edx,%ecx
f01215ce:	0f af c8             	imul   %eax,%ecx
f01215d1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01215d6:	f7 e1                	mul    %ecx
f01215d8:	c1 ea 05             	shr    $0x5,%edx
f01215db:	89 d0                	mov    %edx,%eax
f01215dd:	c1 e0 02             	shl    $0x2,%eax
f01215e0:	01 d0                	add    %edx,%eax
f01215e2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01215e9:	01 d0                	add    %edx,%eax
f01215eb:	c1 e0 02             	shl    $0x2,%eax
f01215ee:	29 c1                	sub    %eax,%ecx
f01215f0:	89 ca                	mov    %ecx,%edx
f01215f2:	85 d2                	test   %edx,%edx
f01215f4:	74 03                	je     f01215f9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2ab>
			num_of_pages_to_be_removed++;
f01215f6:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f01215f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01215fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f01215ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121602:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121605:	01 c2                	add    %eax,%edx
f0121607:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012160a:	01 d0                	add    %edx,%eax
}
f012160c:	c9                   	leave  
f012160d:	c3                   	ret    

f012160e <schenv>:


void schenv()
{
f012160e:	55                   	push   %ebp
f012160f:	89 e5                	mov    %esp,%ebp
f0121611:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f0121614:	c6 05 80 3b 5a f0 00 	movb   $0x0,0xf05a3b80
	__ne = NULL;
f012161b:	c7 05 ac 38 5a f0 00 	movl   $0x0,0xf05a38ac
f0121622:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f0121625:	83 ec 0c             	sub    $0xc,%esp
f0121628:	68 00 0e 5a f0       	push   $0xf05a0e00
f012162d:	e8 ef d4 fe ff       	call   f010eb21 <acquire_spinlock>
f0121632:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0121635:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f012163c:	eb 40                	jmp    f012167e <schenv+0x70>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f012163e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121641:	83 c0 09             	add    $0x9,%eax
f0121644:	c1 e0 04             	shl    $0x4,%eax
f0121647:	05 00 0e 5a f0       	add    $0xf05a0e00,%eax
f012164c:	83 ec 0c             	sub    $0xc,%esp
f012164f:	50                   	push   %eax
f0121650:	e8 0b 39 fe ff       	call   f0104f60 <queue_size>
f0121655:	83 c4 10             	add    $0x10,%esp
f0121658:	85 c0                	test   %eax,%eax
f012165a:	74 1f                	je     f012167b <schenv+0x6d>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f012165c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012165f:	83 c0 09             	add    $0x9,%eax
f0121662:	c1 e0 04             	shl    $0x4,%eax
f0121665:	05 04 0e 5a f0       	add    $0xf05a0e04,%eax
f012166a:	8b 00                	mov    (%eax),%eax
f012166c:	a3 ac 38 5a f0       	mov    %eax,0xf05a38ac
				__nl = i;
f0121671:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121674:	a2 80 3b 5a f0       	mov    %al,0xf05a3b80
				break;
f0121679:	eb 10                	jmp    f012168b <schenv+0x7d>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f012167b:	ff 45 f4             	incl   -0xc(%ebp)
f012167e:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f0121683:	0f b6 c0             	movzbl %al,%eax
f0121686:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121689:	7f b3                	jg     f012163e <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f012168b:	83 ec 0c             	sub    $0xc,%esp
f012168e:	68 00 0e 5a f0       	push   $0xf05a0e00
f0121693:	e8 10 d5 fe ff       	call   f010eba8 <release_spinlock>
f0121698:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f012169b:	e8 d0 90 fe ff       	call   f010a770 <get_cpu_proc>
f01216a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f01216a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01216a7:	0f 84 82 00 00 00    	je     f012172f <schenv+0x121>
	{
		if (__ne != NULL)
f01216ad:	a1 ac 38 5a f0       	mov    0xf05a38ac,%eax
f01216b2:	85 c0                	test   %eax,%eax
f01216b4:	74 49                	je     f01216ff <schenv+0xf1>
		{
			if ((__pl + 1) < __nl)
f01216b6:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f01216bb:	0f b6 c0             	movzbl %al,%eax
f01216be:	8d 50 01             	lea    0x1(%eax),%edx
f01216c1:	a0 80 3b 5a f0       	mov    0xf05a3b80,%al
f01216c6:	0f b6 c0             	movzbl %al,%eax
f01216c9:	39 c2                	cmp    %eax,%edx
f01216cb:	7d 62                	jge    f012172f <schenv+0x121>
			{
				__ne = cur_env;
f01216cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216d0:	a3 ac 38 5a f0       	mov    %eax,0xf05a38ac
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f01216d5:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f01216da:	0f b6 c0             	movzbl %al,%eax
f01216dd:	8a 15 00 3b 5a f0    	mov    0xf05a3b00,%dl
f01216e3:	0f b6 d2             	movzbl %dl,%edx
f01216e6:	4a                   	dec    %edx
f01216e7:	39 d0                	cmp    %edx,%eax
f01216e9:	7d 08                	jge    f01216f3 <schenv+0xe5>
f01216eb:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f01216f0:	40                   	inc    %eax
f01216f1:	eb 05                	jmp    f01216f8 <schenv+0xea>
f01216f3:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f01216f8:	a2 80 3b 5a f0       	mov    %al,0xf05a3b80
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f01216fd:	eb 30                	jmp    f012172f <schenv+0x121>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f01216ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121702:	a3 ac 38 5a f0       	mov    %eax,0xf05a38ac
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0121707:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f012170c:	0f b6 c0             	movzbl %al,%eax
f012170f:	8a 15 00 3b 5a f0    	mov    0xf05a3b00,%dl
f0121715:	0f b6 d2             	movzbl %dl,%edx
f0121718:	4a                   	dec    %edx
f0121719:	39 d0                	cmp    %edx,%eax
f012171b:	7d 08                	jge    f0121725 <schenv+0x117>
f012171d:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f0121722:	40                   	inc    %eax
f0121723:	eb 05                	jmp    f012172a <schenv+0x11c>
f0121725:	a0 f1 0d 5a f0       	mov    0xf05a0df1,%al
f012172a:	a2 80 3b 5a f0       	mov    %al,0xf05a3b80
		}
	}
}
f012172f:	90                   	nop
f0121730:	c9                   	leave  
f0121731:	c3                   	ret    

f0121732 <chksch>:

void chksch(uint8 onoff)
{
f0121732:	55                   	push   %ebp
f0121733:	89 e5                	mov    %esp,%ebp
f0121735:	83 ec 18             	sub    $0x18,%esp
f0121738:	8b 45 08             	mov    0x8(%ebp),%eax
f012173b:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f012173e:	e8 f0 4f fe ff       	call   f0106733 <isSchedMethodBSD>
f0121743:	85 c0                	test   %eax,%eax
f0121745:	74 48                	je     f012178f <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f0121747:	e8 95 4f fe ff       	call   f01066e1 <get_load_average>
f012174c:	a3 1c 3b 5a f0       	mov    %eax,0xf05a3b1c
f0121751:	a1 1c 3b 5a f0       	mov    0xf05a3b1c,%eax
f0121756:	a3 5c 36 5a f0       	mov    %eax,0xf05a365c
		acquire_spinlock(&ProcessQueues.qlock);
f012175b:	83 ec 0c             	sub    $0xc,%esp
f012175e:	68 00 0e 5a f0       	push   $0xf05a0e00
f0121763:	e8 b9 d3 fe ff       	call   f010eb21 <acquire_spinlock>
f0121768:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f012176b:	a1 8c 0e 5a f0       	mov    0xf05a0e8c,%eax
f0121770:	a3 60 0f 5a f0       	mov    %eax,0xf05a0f60
		}
		release_spinlock(&ProcessQueues.qlock);
f0121775:	83 ec 0c             	sub    $0xc,%esp
f0121778:	68 00 0e 5a f0       	push   $0xf05a0e00
f012177d:	e8 26 d4 fe ff       	call   f010eba8 <release_spinlock>
f0121782:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f0121785:	c7 05 bc 38 5a f0 01 	movl   $0x1,0xf05a38bc
f012178c:	00 00 00 
	}
	__chkstatus = onoff;
f012178f:	8a 45 f4             	mov    -0xc(%ebp),%al
f0121792:	a2 a8 38 5a f0       	mov    %al,0xf05a38a8
}
f0121797:	90                   	nop
f0121798:	c9                   	leave  
f0121799:	c3                   	ret    

f012179a <chk1>:
void chk1()
{
f012179a:	55                   	push   %ebp
f012179b:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f012179d:	90                   	nop
f012179e:	5d                   	pop    %ebp
f012179f:	c3                   	ret    

f01217a0 <chk2>:
void chk2(struct Env* __se)
{
f01217a0:	55                   	push   %ebp
f01217a1:	89 e5                	mov    %esp,%ebp
f01217a3:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f01217a6:	a0 a8 38 5a f0       	mov    0xf05a38a8,%al
f01217ab:	84 c0                	test   %al,%al
f01217ad:	0f 84 59 03 00 00    	je     f0121b0c <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f01217b3:	e8 7b 4f fe ff       	call   f0106733 <isSchedMethodBSD>
f01217b8:	85 c0                	test   %eax,%eax
f01217ba:	0f 84 4d 03 00 00    	je     f0121b0d <chk2+0x36d>
	{
		__nla = get_load_average();
f01217c0:	e8 1c 4f fe ff       	call   f01066e1 <get_load_average>
f01217c5:	a3 84 35 5a f0       	mov    %eax,0xf05a3584
		acquire_spinlock(&ProcessQueues.qlock);
f01217ca:	83 ec 0c             	sub    $0xc,%esp
f01217cd:	68 00 0e 5a f0       	push   $0xf05a0e00
f01217d2:	e8 4a d3 fe ff       	call   f010eb21 <acquire_spinlock>
f01217d7:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01217da:	a1 8c 0e 5a f0       	mov    0xf05a0e8c,%eax
f01217df:	a3 b0 38 5a f0       	mov    %eax,0xf05a38b0
		}
		release_spinlock(&ProcessQueues.qlock);
f01217e4:	83 ec 0c             	sub    $0xc,%esp
f01217e7:	68 00 0e 5a f0       	push   $0xf05a0e00
f01217ec:	e8 b7 d3 fe ff       	call   f010eba8 <release_spinlock>
f01217f1:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f01217f4:	a1 bc 38 5a f0       	mov    0xf05a38bc,%eax
f01217f9:	85 c0                	test   %eax,%eax
f01217fb:	74 72                	je     f012186f <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f01217fd:	83 ec 0c             	sub    $0xc,%esp
f0121800:	68 00 0e 5a f0       	push   $0xf05a0e00
f0121805:	e8 17 d3 fe ff       	call   f010eb21 <acquire_spinlock>
f012180a:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f012180d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121811:	0f 95 c0             	setne  %al
f0121814:	0f b6 c0             	movzbl %al,%eax
f0121817:	a3 74 3a 5a f0       	mov    %eax,0xf05a3a74
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f012181c:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f0121821:	0f b6 c0             	movzbl %al,%eax
f0121824:	48                   	dec    %eax
f0121825:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121828:	eb 20                	jmp    f012184a <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f012182a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012182d:	83 c0 09             	add    $0x9,%eax
f0121830:	c1 e0 04             	shl    $0x4,%eax
f0121833:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f0121838:	8b 00                	mov    (%eax),%eax
f012183a:	8b 15 74 3a 5a f0    	mov    0xf05a3a74,%edx
f0121840:	01 d0                	add    %edx,%eax
f0121842:	a3 74 3a 5a f0       	mov    %eax,0xf05a3a74
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0121847:	ff 4d f4             	decl   -0xc(%ebp)
f012184a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012184e:	79 da                	jns    f012182a <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f0121850:	c7 05 bc 38 5a f0 00 	movl   $0x0,0xf05a38bc
f0121857:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f012185a:	83 ec 0c             	sub    $0xc,%esp
f012185d:	68 00 0e 5a f0       	push   $0xf05a0e00
f0121862:	e8 41 d3 fe ff       	call   f010eba8 <release_spinlock>
f0121867:	83 c4 10             	add    $0x10,%esp
f012186a:	e9 91 02 00 00       	jmp    f0121b00 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f012186f:	8b 15 60 0f 5a f0    	mov    0xf05a0f60,%edx
f0121875:	a1 b0 38 5a f0       	mov    0xf05a38b0,%eax
f012187a:	39 c2                	cmp    %eax,%edx
f012187c:	74 63                	je     f01218e1 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f012187e:	83 ec 0c             	sub    $0xc,%esp
f0121881:	68 00 0e 5a f0       	push   $0xf05a0e00
f0121886:	e8 96 d2 fe ff       	call   f010eb21 <acquire_spinlock>
f012188b:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f012188e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121892:	0f 95 c0             	setne  %al
f0121895:	0f b6 c0             	movzbl %al,%eax
f0121898:	a3 74 3a 5a f0       	mov    %eax,0xf05a3a74
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f012189d:	a0 00 3b 5a f0       	mov    0xf05a3b00,%al
f01218a2:	0f b6 c0             	movzbl %al,%eax
f01218a5:	48                   	dec    %eax
f01218a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01218a9:	eb 20                	jmp    f01218cb <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f01218ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01218ae:	83 c0 09             	add    $0x9,%eax
f01218b1:	c1 e0 04             	shl    $0x4,%eax
f01218b4:	05 0c 0e 5a f0       	add    $0xf05a0e0c,%eax
f01218b9:	8b 00                	mov    (%eax),%eax
f01218bb:	8b 15 74 3a 5a f0    	mov    0xf05a3a74,%edx
f01218c1:	01 d0                	add    %edx,%eax
f01218c3:	a3 74 3a 5a f0       	mov    %eax,0xf05a3a74
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f01218c8:	ff 4d f0             	decl   -0x10(%ebp)
f01218cb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01218cf:	79 da                	jns    f01218ab <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f01218d1:	83 ec 0c             	sub    $0xc,%esp
f01218d4:	68 00 0e 5a f0       	push   $0xf05a0e00
f01218d9:	e8 ca d2 fe ff       	call   f010eba8 <release_spinlock>
f01218de:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f01218e1:	e8 94 4d fe ff       	call   f010667a <timer_ticks>
f01218e6:	6a 00                	push   $0x0
f01218e8:	68 e8 03 00 00       	push   $0x3e8
f01218ed:	52                   	push   %edx
f01218ee:	50                   	push   %eax
f01218ef:	e8 b4 23 00 00       	call   f0123ca8 <__moddi3>
f01218f4:	83 c4 10             	add    $0x10,%esp
f01218f7:	09 d0                	or     %edx,%eax
f01218f9:	85 c0                	test   %eax,%eax
f01218fb:	75 32                	jne    f012192f <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f01218fd:	8b 15 5c 36 5a f0    	mov    0xf05a365c,%edx
f0121903:	a1 84 35 5a f0       	mov    0xf05a3584,%eax
f0121908:	39 c2                	cmp    %eax,%edx
f012190a:	75 19                	jne    f0121925 <chk2+0x185>
f012190c:	68 09 ff 12 f0       	push   $0xf012ff09
f0121911:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121916:	68 17 02 00 00       	push   $0x217
f012191b:	68 ff fb 12 f0       	push   $0xf012fbff
f0121920:	e8 85 ea fd ff       	call   f01003aa <_panic_all>
				__histla = __nla;
f0121925:	a1 84 35 5a f0       	mov    0xf05a3584,%eax
f012192a:	a3 5c 36 5a f0       	mov    %eax,0xf05a365c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f012192f:	e8 46 4d fe ff       	call   f010667a <timer_ticks>
f0121934:	6a 00                	push   $0x0
f0121936:	6a 64                	push   $0x64
f0121938:	52                   	push   %edx
f0121939:	50                   	push   %eax
f012193a:	e8 69 23 00 00       	call   f0123ca8 <__moddi3>
f012193f:	83 c4 10             	add    $0x10,%esp
f0121942:	09 d0                	or     %edx,%eax
f0121944:	85 c0                	test   %eax,%eax
f0121946:	0f 85 b4 01 00 00    	jne    f0121b00 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f012194c:	8b 0d 1c 3b 5a f0    	mov    0xf05a3b1c,%ecx
f0121952:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121957:	f7 e9                	imul   %ecx
f0121959:	c1 fa 05             	sar    $0x5,%edx
f012195c:	89 c8                	mov    %ecx,%eax
f012195e:	c1 f8 1f             	sar    $0x1f,%eax
f0121961:	29 c2                	sub    %eax,%edx
f0121963:	89 d0                	mov    %edx,%eax
f0121965:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f0121968:	8b 0d 1c 3b 5a f0    	mov    0xf05a3b1c,%ecx
f012196e:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121973:	f7 e9                	imul   %ecx
f0121975:	c1 fa 05             	sar    $0x5,%edx
f0121978:	89 c8                	mov    %ecx,%eax
f012197a:	c1 f8 1f             	sar    $0x1f,%eax
f012197d:	29 c2                	sub    %eax,%edx
f012197f:	89 d0                	mov    %edx,%eax
f0121981:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0121984:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0121987:	89 d0                	mov    %edx,%eax
f0121989:	c1 e0 02             	shl    $0x2,%eax
f012198c:	01 d0                	add    %edx,%eax
f012198e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121995:	01 d0                	add    %edx,%eax
f0121997:	c1 e0 02             	shl    $0x2,%eax
f012199a:	29 c1                	sub    %eax,%ecx
f012199c:	89 c8                	mov    %ecx,%eax
f012199e:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f01219a1:	8b 0d 84 35 5a f0    	mov    0xf05a3584,%ecx
f01219a7:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01219ac:	f7 e9                	imul   %ecx
f01219ae:	c1 fa 05             	sar    $0x5,%edx
f01219b1:	89 c8                	mov    %ecx,%eax
f01219b3:	c1 f8 1f             	sar    $0x1f,%eax
f01219b6:	29 c2                	sub    %eax,%edx
f01219b8:	89 d0                	mov    %edx,%eax
f01219ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f01219bd:	8b 0d 84 35 5a f0    	mov    0xf05a3584,%ecx
f01219c3:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01219c8:	f7 e9                	imul   %ecx
f01219ca:	c1 fa 05             	sar    $0x5,%edx
f01219cd:	89 c8                	mov    %ecx,%eax
f01219cf:	c1 f8 1f             	sar    $0x1f,%eax
f01219d2:	29 c2                	sub    %eax,%edx
f01219d4:	89 d0                	mov    %edx,%eax
f01219d6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01219d9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01219dc:	89 d0                	mov    %edx,%eax
f01219de:	c1 e0 02             	shl    $0x2,%eax
f01219e1:	01 d0                	add    %edx,%eax
f01219e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01219ea:	01 d0                	add    %edx,%eax
f01219ec:	c1 e0 02             	shl    $0x2,%eax
f01219ef:	29 c1                	sub    %eax,%ecx
f01219f1:	89 c8                	mov    %ecx,%eax
f01219f3:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f01219f6:	8b 15 b0 38 5a f0    	mov    0xf05a38b0,%edx
f01219fc:	a1 60 0f 5a f0       	mov    0xf05a0f60,%eax
f0121a01:	39 c2                	cmp    %eax,%edx
f0121a03:	0f 85 ed 00 00 00    	jne    f0121af6 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f0121a09:	a1 74 3a 5a f0       	mov    0xf05a3a74,%eax
f0121a0e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121a11:	7e 5b                	jle    f0121a6e <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0121a13:	a1 74 3a 5a f0       	mov    0xf05a3a74,%eax
f0121a18:	83 ec 08             	sub    $0x8,%esp
f0121a1b:	ff 75 e0             	pushl  -0x20(%ebp)
f0121a1e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121a21:	ff 75 e8             	pushl  -0x18(%ebp)
f0121a24:	ff 75 ec             	pushl  -0x14(%ebp)
f0121a27:	50                   	push   %eax
f0121a28:	68 1c ff 12 f0       	push   $0xf012ff1c
f0121a2d:	e8 3a f5 fd ff       	call   f0100f6c <cprintf>
f0121a32:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f0121a35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a38:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121a3b:	0f 8f b5 00 00 00    	jg     f0121af6 <chk2+0x356>
f0121a41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a44:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121a47:	75 0c                	jne    f0121a55 <chk2+0x2b5>
f0121a49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a4c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121a4f:	0f 8d a1 00 00 00    	jge    f0121af6 <chk2+0x356>
f0121a55:	68 64 ff 12 f0       	push   $0xf012ff64
f0121a5a:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121a5f:	68 2c 02 00 00       	push   $0x22c
f0121a64:	68 ff fb 12 f0       	push   $0xf012fbff
f0121a69:	e8 3c e9 fd ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc < plaint)
f0121a6e:	a1 74 3a 5a f0       	mov    0xf05a3a74,%eax
f0121a73:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121a76:	7d 53                	jge    f0121acb <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0121a78:	a1 74 3a 5a f0       	mov    0xf05a3a74,%eax
f0121a7d:	83 ec 08             	sub    $0x8,%esp
f0121a80:	ff 75 e0             	pushl  -0x20(%ebp)
f0121a83:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121a86:	ff 75 e8             	pushl  -0x18(%ebp)
f0121a89:	ff 75 ec             	pushl  -0x14(%ebp)
f0121a8c:	50                   	push   %eax
f0121a8d:	68 a4 ff 12 f0       	push   $0xf012ffa4
f0121a92:	e8 d5 f4 fd ff       	call   f0100f6c <cprintf>
f0121a97:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f0121a9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a9d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121aa0:	7c 54                	jl     f0121af6 <chk2+0x356>
f0121aa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121aa5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121aa8:	75 08                	jne    f0121ab2 <chk2+0x312>
f0121aaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121aad:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121ab0:	7e 44                	jle    f0121af6 <chk2+0x356>
f0121ab2:	68 ec ff 12 f0       	push   $0xf012ffec
f0121ab7:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121abc:	68 32 02 00 00       	push   $0x232
f0121ac1:	68 ff fb 12 f0       	push   $0xf012fbff
f0121ac6:	e8 df e8 fd ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc == plaint)
f0121acb:	a1 74 3a 5a f0       	mov    0xf05a3a74,%eax
f0121ad0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121ad3:	75 21                	jne    f0121af6 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f0121ad5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ad8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121adb:	74 19                	je     f0121af6 <chk2+0x356>
f0121add:	68 2c 00 13 f0       	push   $0xf013002c
f0121ae2:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121ae7:	68 36 02 00 00       	push   $0x236
f0121aec:	68 ff fb 12 f0       	push   $0xf012fbff
f0121af1:	e8 b4 e8 fd ff       	call   f01003aa <_panic_all>
					}
				}
				__pla = __nla;
f0121af6:	a1 84 35 5a f0       	mov    0xf05a3584,%eax
f0121afb:	a3 1c 3b 5a f0       	mov    %eax,0xf05a3b1c
			}
		}
		__pnexit = __nnexit;
f0121b00:	a1 b0 38 5a f0       	mov    0xf05a38b0,%eax
f0121b05:	a3 60 0f 5a f0       	mov    %eax,0xf05a0f60
f0121b0a:	eb 01                	jmp    f0121b0d <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f0121b0c:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f0121b0d:	c9                   	leave  
f0121b0e:	c3                   	ret    

f0121b0f <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f0121b0f:	55                   	push   %ebp
f0121b10:	89 e5                	mov    %esp,%ebp
f0121b12:	83 ec 18             	sub    $0x18,%esp
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f0121b15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121b1c:	eb 40                	jmp    f0121b5e <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f0121b1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121b21:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0121b27:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0121b2c:	83 ec 08             	sub    $0x8,%esp
f0121b2f:	52                   	push   %edx
f0121b30:	50                   	push   %eax
f0121b31:	e8 a6 01 00 00       	call   f0121cdc <check_va2pa>
f0121b36:	83 c4 10             	add    $0x10,%esp
f0121b39:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121b3c:	74 19                	je     f0121b57 <check_boot_pgdir+0x48>
f0121b3e:	68 40 00 13 f0       	push   $0xf0130040
f0121b43:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121b48:	68 82 02 00 00       	push   $0x282
f0121b4d:	68 ff fb 12 f0       	push   $0xf012fbff
f0121b52:	e8 c3 e7 fd ff       	call   f010031a <_panic>
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f0121b57:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0121b5e:	81 7d f4 00 00 00 10 	cmpl   $0x10000000,-0xc(%ebp)
f0121b65:	75 b7                	jne    f0121b1e <check_boot_pgdir+0xf>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0121b67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121b6e:	e9 81 00 00 00       	jmp    f0121bf4 <check_boot_pgdir+0xe5>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f0121b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121b76:	25 ff 7f 00 00       	and    $0x7fff,%eax
f0121b7b:	85 c0                	test   %eax,%eax
f0121b7d:	74 6d                	je     f0121bec <check_boot_pgdir+0xdd>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f0121b7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121b82:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f0121b88:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0121b8d:	83 ec 08             	sub    $0x8,%esp
f0121b90:	52                   	push   %edx
f0121b91:	50                   	push   %eax
f0121b92:	e8 45 01 00 00       	call   f0121cdc <check_va2pa>
f0121b97:	83 c4 10             	add    $0x10,%esp
f0121b9a:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f0121ba1:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f0121ba8:	77 17                	ja     f0121bc1 <check_boot_pgdir+0xb2>
f0121baa:	ff 75 f0             	pushl  -0x10(%ebp)
f0121bad:	68 78 00 13 f0       	push   $0xf0130078
f0121bb2:	68 8b 02 00 00       	push   $0x28b
f0121bb7:	68 ff fb 12 f0       	push   $0xf012fbff
f0121bbc:	e8 59 e7 fd ff       	call   f010031a <_panic>
f0121bc1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121bc4:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f0121bca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121bcd:	01 ca                	add    %ecx,%edx
f0121bcf:	39 d0                	cmp    %edx,%eax
f0121bd1:	74 1a                	je     f0121bed <check_boot_pgdir+0xde>
f0121bd3:	68 ac 00 13 f0       	push   $0xf01300ac
f0121bd8:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121bdd:	68 8b 02 00 00       	push   $0x28b
f0121be2:	68 ff fb 12 f0       	push   $0xf012fbff
f0121be7:	e8 2e e7 fd ff       	call   f010031a <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f0121bec:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0121bed:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0121bf4:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f0121bfb:	0f 86 72 ff ff ff    	jbe    f0121b73 <check_boot_pgdir+0x64>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0121c01:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121c08:	e9 af 00 00 00       	jmp    f0121cbc <check_boot_pgdir+0x1ad>
		switch (i) {
f0121c0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121c10:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0121c15:	74 11                	je     f0121c28 <check_boot_pgdir+0x119>
f0121c17:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0121c1c:	72 36                	jb     f0121c54 <check_boot_pgdir+0x145>
f0121c1e:	2d bd 03 00 00       	sub    $0x3bd,%eax
f0121c23:	83 f8 02             	cmp    $0x2,%eax
f0121c26:	77 2c                	ja     f0121c54 <check_boot_pgdir+0x145>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f0121c28:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0121c2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121c30:	c1 e2 02             	shl    $0x2,%edx
f0121c33:	01 d0                	add    %edx,%eax
f0121c35:	8b 00                	mov    (%eax),%eax
f0121c37:	85 c0                	test   %eax,%eax
f0121c39:	75 7a                	jne    f0121cb5 <check_boot_pgdir+0x1a6>
f0121c3b:	68 32 01 13 f0       	push   $0xf0130132
f0121c40:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121c45:	68 96 02 00 00       	push   $0x296
f0121c4a:	68 ff fb 12 f0       	push   $0xf012fbff
f0121c4f:	e8 c6 e6 fd ff       	call   f010031a <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f0121c54:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f0121c5b:	76 2c                	jbe    f0121c89 <check_boot_pgdir+0x17a>
				assert(ptr_page_directory[i]);
f0121c5d:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0121c62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121c65:	c1 e2 02             	shl    $0x2,%edx
f0121c68:	01 d0                	add    %edx,%eax
f0121c6a:	8b 00                	mov    (%eax),%eax
f0121c6c:	85 c0                	test   %eax,%eax
f0121c6e:	75 48                	jne    f0121cb8 <check_boot_pgdir+0x1a9>
f0121c70:	68 32 01 13 f0       	push   $0xf0130132
f0121c75:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121c7a:	68 9a 02 00 00       	push   $0x29a
f0121c7f:	68 ff fb 12 f0       	push   $0xf012fbff
f0121c84:	e8 91 e6 fd ff       	call   f010031a <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f0121c89:	a1 7c 3a 5a f0       	mov    0xf05a3a7c,%eax
f0121c8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121c91:	c1 e2 02             	shl    $0x2,%edx
f0121c94:	01 d0                	add    %edx,%eax
f0121c96:	8b 00                	mov    (%eax),%eax
f0121c98:	85 c0                	test   %eax,%eax
f0121c9a:	74 1c                	je     f0121cb8 <check_boot_pgdir+0x1a9>
f0121c9c:	68 48 01 13 f0       	push   $0xf0130148
f0121ca1:	68 b7 fb 12 f0       	push   $0xf012fbb7
f0121ca6:	68 9c 02 00 00       	push   $0x29c
f0121cab:	68 ff fb 12 f0       	push   $0xf012fbff
f0121cb0:	e8 65 e6 fd ff       	call   f010031a <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f0121cb5:	90                   	nop
f0121cb6:	eb 01                	jmp    f0121cb9 <check_boot_pgdir+0x1aa>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f0121cb8:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0121cb9:	ff 45 f4             	incl   -0xc(%ebp)
f0121cbc:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0121cc3:	0f 86 44 ff ff ff    	jbe    f0121c0d <check_boot_pgdir+0xfe>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f0121cc9:	83 ec 0c             	sub    $0xc,%esp
f0121ccc:	68 64 01 13 f0       	push   $0xf0130164
f0121cd1:	e8 96 f2 fd ff       	call   f0100f6c <cprintf>
f0121cd6:	83 c4 10             	add    $0x10,%esp
}
f0121cd9:	90                   	nop
f0121cda:	c9                   	leave  
f0121cdb:	c3                   	ret    

f0121cdc <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f0121cdc:	55                   	push   %ebp
f0121cdd:	89 e5                	mov    %esp,%ebp
f0121cdf:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f0121ce2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ce5:	c1 e8 16             	shr    $0x16,%eax
f0121ce8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121cef:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cf2:	01 d0                	add    %edx,%eax
f0121cf4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f0121cf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121cfa:	8b 00                	mov    (%eax),%eax
f0121cfc:	83 e0 01             	and    $0x1,%eax
f0121cff:	85 c0                	test   %eax,%eax
f0121d01:	75 0a                	jne    f0121d0d <check_va2pa+0x31>
		return ~0;
f0121d03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0121d08:	e9 87 00 00 00       	jmp    f0121d94 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f0121d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d10:	8b 00                	mov    (%eax),%eax
f0121d12:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0121d17:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121d1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121d1d:	c1 e8 0c             	shr    $0xc,%eax
f0121d20:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121d23:	a1 58 36 5a f0       	mov    0xf05a3658,%eax
f0121d28:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0121d2b:	72 17                	jb     f0121d44 <check_va2pa+0x68>
f0121d2d:	ff 75 f0             	pushl  -0x10(%ebp)
f0121d30:	68 88 01 13 f0       	push   $0xf0130188
f0121d35:	68 b2 02 00 00       	push   $0x2b2
f0121d3a:	68 ff fb 12 f0       	push   $0xf012fbff
f0121d3f:	e8 d6 e5 fd ff       	call   f010031a <_panic>
f0121d44:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121d47:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0121d4c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f0121d4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121d52:	c1 e8 0c             	shr    $0xc,%eax
f0121d55:	25 ff 03 00 00       	and    $0x3ff,%eax
f0121d5a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121d61:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121d64:	01 d0                	add    %edx,%eax
f0121d66:	8b 00                	mov    (%eax),%eax
f0121d68:	83 e0 01             	and    $0x1,%eax
f0121d6b:	85 c0                	test   %eax,%eax
f0121d6d:	75 07                	jne    f0121d76 <check_va2pa+0x9a>
		return ~0;
f0121d6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0121d74:	eb 1e                	jmp    f0121d94 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f0121d76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121d79:	c1 e8 0c             	shr    $0xc,%eax
f0121d7c:	25 ff 03 00 00       	and    $0x3ff,%eax
f0121d81:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121d88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121d8b:	01 d0                	add    %edx,%eax
f0121d8d:	8b 00                	mov    (%eax),%eax
f0121d8f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0121d94:	c9                   	leave  
f0121d95:	c3                   	ret    

f0121d96 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f0121d96:	55                   	push   %ebp
f0121d97:	89 e5                	mov    %esp,%ebp
f0121d99:	53                   	push   %ebx
f0121d9a:	83 ec 14             	sub    $0x14,%esp
f0121d9d:	8b 45 10             	mov    0x10(%ebp),%eax
f0121da0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121da3:	8b 45 14             	mov    0x14(%ebp),%eax
f0121da6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f0121da9:	8b 45 18             	mov    0x18(%ebp),%eax
f0121dac:	ba 00 00 00 00       	mov    $0x0,%edx
f0121db1:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f0121db4:	77 55                	ja     f0121e0b <printnum+0x75>
f0121db6:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f0121db9:	72 05                	jb     f0121dc0 <printnum+0x2a>
f0121dbb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0121dbe:	77 4b                	ja     f0121e0b <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f0121dc0:	8b 45 1c             	mov    0x1c(%ebp),%eax
f0121dc3:	8d 58 ff             	lea    -0x1(%eax),%ebx
f0121dc6:	8b 45 18             	mov    0x18(%ebp),%eax
f0121dc9:	ba 00 00 00 00       	mov    $0x0,%edx
f0121dce:	52                   	push   %edx
f0121dcf:	50                   	push   %eax
f0121dd0:	ff 75 f4             	pushl  -0xc(%ebp)
f0121dd3:	ff 75 f0             	pushl  -0x10(%ebp)
f0121dd6:	e8 65 20 00 00       	call   f0123e40 <__udivdi3>
f0121ddb:	83 c4 10             	add    $0x10,%esp
f0121dde:	83 ec 04             	sub    $0x4,%esp
f0121de1:	ff 75 20             	pushl  0x20(%ebp)
f0121de4:	53                   	push   %ebx
f0121de5:	ff 75 18             	pushl  0x18(%ebp)
f0121de8:	52                   	push   %edx
f0121de9:	50                   	push   %eax
f0121dea:	ff 75 0c             	pushl  0xc(%ebp)
f0121ded:	ff 75 08             	pushl  0x8(%ebp)
f0121df0:	e8 a1 ff ff ff       	call   f0121d96 <printnum>
f0121df5:	83 c4 20             	add    $0x20,%esp
f0121df8:	eb 1a                	jmp    f0121e14 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f0121dfa:	83 ec 08             	sub    $0x8,%esp
f0121dfd:	ff 75 0c             	pushl  0xc(%ebp)
f0121e00:	ff 75 20             	pushl  0x20(%ebp)
f0121e03:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e06:	ff d0                	call   *%eax
f0121e08:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f0121e0b:	ff 4d 1c             	decl   0x1c(%ebp)
f0121e0e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f0121e12:	7f e6                	jg     f0121dfa <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f0121e14:	8b 4d 18             	mov    0x18(%ebp),%ecx
f0121e17:	bb 00 00 00 00       	mov    $0x0,%ebx
f0121e1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121e1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121e22:	53                   	push   %ebx
f0121e23:	51                   	push   %ecx
f0121e24:	52                   	push   %edx
f0121e25:	50                   	push   %eax
f0121e26:	e8 25 21 00 00       	call   f0123f50 <__umoddi3>
f0121e2b:	83 c4 10             	add    $0x10,%esp
f0121e2e:	05 d4 03 13 f0       	add    $0xf01303d4,%eax
f0121e33:	8a 00                	mov    (%eax),%al
f0121e35:	0f be c0             	movsbl %al,%eax
f0121e38:	83 ec 08             	sub    $0x8,%esp
f0121e3b:	ff 75 0c             	pushl  0xc(%ebp)
f0121e3e:	50                   	push   %eax
f0121e3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e42:	ff d0                	call   *%eax
f0121e44:	83 c4 10             	add    $0x10,%esp
}
f0121e47:	90                   	nop
f0121e48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121e4b:	c9                   	leave  
f0121e4c:	c3                   	ret    

f0121e4d <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f0121e4d:	55                   	push   %ebp
f0121e4e:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f0121e50:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0121e54:	7e 1c                	jle    f0121e72 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f0121e56:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e59:	8b 00                	mov    (%eax),%eax
f0121e5b:	8d 50 08             	lea    0x8(%eax),%edx
f0121e5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e61:	89 10                	mov    %edx,(%eax)
f0121e63:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e66:	8b 00                	mov    (%eax),%eax
f0121e68:	83 e8 08             	sub    $0x8,%eax
f0121e6b:	8b 50 04             	mov    0x4(%eax),%edx
f0121e6e:	8b 00                	mov    (%eax),%eax
f0121e70:	eb 40                	jmp    f0121eb2 <getuint+0x65>
	else if (lflag)
f0121e72:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121e76:	74 1e                	je     f0121e96 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f0121e78:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e7b:	8b 00                	mov    (%eax),%eax
f0121e7d:	8d 50 04             	lea    0x4(%eax),%edx
f0121e80:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e83:	89 10                	mov    %edx,(%eax)
f0121e85:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e88:	8b 00                	mov    (%eax),%eax
f0121e8a:	83 e8 04             	sub    $0x4,%eax
f0121e8d:	8b 00                	mov    (%eax),%eax
f0121e8f:	ba 00 00 00 00       	mov    $0x0,%edx
f0121e94:	eb 1c                	jmp    f0121eb2 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f0121e96:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e99:	8b 00                	mov    (%eax),%eax
f0121e9b:	8d 50 04             	lea    0x4(%eax),%edx
f0121e9e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ea1:	89 10                	mov    %edx,(%eax)
f0121ea3:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ea6:	8b 00                	mov    (%eax),%eax
f0121ea8:	83 e8 04             	sub    $0x4,%eax
f0121eab:	8b 00                	mov    (%eax),%eax
f0121ead:	ba 00 00 00 00       	mov    $0x0,%edx
}
f0121eb2:	5d                   	pop    %ebp
f0121eb3:	c3                   	ret    

f0121eb4 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f0121eb4:	55                   	push   %ebp
f0121eb5:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f0121eb7:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0121ebb:	7e 1c                	jle    f0121ed9 <getint+0x25>
		return va_arg(*ap, long long);
f0121ebd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ec0:	8b 00                	mov    (%eax),%eax
f0121ec2:	8d 50 08             	lea    0x8(%eax),%edx
f0121ec5:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ec8:	89 10                	mov    %edx,(%eax)
f0121eca:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ecd:	8b 00                	mov    (%eax),%eax
f0121ecf:	83 e8 08             	sub    $0x8,%eax
f0121ed2:	8b 50 04             	mov    0x4(%eax),%edx
f0121ed5:	8b 00                	mov    (%eax),%eax
f0121ed7:	eb 38                	jmp    f0121f11 <getint+0x5d>
	else if (lflag)
f0121ed9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121edd:	74 1a                	je     f0121ef9 <getint+0x45>
		return va_arg(*ap, long);
f0121edf:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ee2:	8b 00                	mov    (%eax),%eax
f0121ee4:	8d 50 04             	lea    0x4(%eax),%edx
f0121ee7:	8b 45 08             	mov    0x8(%ebp),%eax
f0121eea:	89 10                	mov    %edx,(%eax)
f0121eec:	8b 45 08             	mov    0x8(%ebp),%eax
f0121eef:	8b 00                	mov    (%eax),%eax
f0121ef1:	83 e8 04             	sub    $0x4,%eax
f0121ef4:	8b 00                	mov    (%eax),%eax
f0121ef6:	99                   	cltd   
f0121ef7:	eb 18                	jmp    f0121f11 <getint+0x5d>
	else
		return va_arg(*ap, int);
f0121ef9:	8b 45 08             	mov    0x8(%ebp),%eax
f0121efc:	8b 00                	mov    (%eax),%eax
f0121efe:	8d 50 04             	lea    0x4(%eax),%edx
f0121f01:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f04:	89 10                	mov    %edx,(%eax)
f0121f06:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f09:	8b 00                	mov    (%eax),%eax
f0121f0b:	83 e8 04             	sub    $0x4,%eax
f0121f0e:	8b 00                	mov    (%eax),%eax
f0121f10:	99                   	cltd   
}
f0121f11:	5d                   	pop    %ebp
f0121f12:	c3                   	ret    

f0121f13 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f0121f13:	55                   	push   %ebp
f0121f14:	89 e5                	mov    %esp,%ebp
f0121f16:	56                   	push   %esi
f0121f17:	53                   	push   %ebx
f0121f18:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f0121f1b:	eb 17                	jmp    f0121f34 <vprintfmt+0x21>
			if (ch == '\0')
f0121f1d:	85 db                	test   %ebx,%ebx
f0121f1f:	0f 84 c1 03 00 00    	je     f01222e6 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f0121f25:	83 ec 08             	sub    $0x8,%esp
f0121f28:	ff 75 0c             	pushl  0xc(%ebp)
f0121f2b:	53                   	push   %ebx
f0121f2c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f2f:	ff d0                	call   *%eax
f0121f31:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f0121f34:	8b 45 10             	mov    0x10(%ebp),%eax
f0121f37:	8d 50 01             	lea    0x1(%eax),%edx
f0121f3a:	89 55 10             	mov    %edx,0x10(%ebp)
f0121f3d:	8a 00                	mov    (%eax),%al
f0121f3f:	0f b6 d8             	movzbl %al,%ebx
f0121f42:	83 fb 25             	cmp    $0x25,%ebx
f0121f45:	75 d6                	jne    f0121f1d <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f0121f47:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f0121f4b:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f0121f52:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f0121f59:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f0121f60:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f0121f67:	8b 45 10             	mov    0x10(%ebp),%eax
f0121f6a:	8d 50 01             	lea    0x1(%eax),%edx
f0121f6d:	89 55 10             	mov    %edx,0x10(%ebp)
f0121f70:	8a 00                	mov    (%eax),%al
f0121f72:	0f b6 d8             	movzbl %al,%ebx
f0121f75:	8d 43 dd             	lea    -0x23(%ebx),%eax
f0121f78:	83 f8 5b             	cmp    $0x5b,%eax
f0121f7b:	0f 87 3d 03 00 00    	ja     f01222be <vprintfmt+0x3ab>
f0121f81:	8b 04 85 f8 03 13 f0 	mov    -0xfecfc08(,%eax,4),%eax
f0121f88:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f0121f8a:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f0121f8e:	eb d7                	jmp    f0121f67 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f0121f90:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f0121f94:	eb d1                	jmp    f0121f67 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f0121f96:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f0121f9d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121fa0:	89 d0                	mov    %edx,%eax
f0121fa2:	c1 e0 02             	shl    $0x2,%eax
f0121fa5:	01 d0                	add    %edx,%eax
f0121fa7:	01 c0                	add    %eax,%eax
f0121fa9:	01 d8                	add    %ebx,%eax
f0121fab:	83 e8 30             	sub    $0x30,%eax
f0121fae:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f0121fb1:	8b 45 10             	mov    0x10(%ebp),%eax
f0121fb4:	8a 00                	mov    (%eax),%al
f0121fb6:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f0121fb9:	83 fb 2f             	cmp    $0x2f,%ebx
f0121fbc:	7e 3e                	jle    f0121ffc <vprintfmt+0xe9>
f0121fbe:	83 fb 39             	cmp    $0x39,%ebx
f0121fc1:	7f 39                	jg     f0121ffc <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f0121fc3:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f0121fc6:	eb d5                	jmp    f0121f9d <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f0121fc8:	8b 45 14             	mov    0x14(%ebp),%eax
f0121fcb:	83 c0 04             	add    $0x4,%eax
f0121fce:	89 45 14             	mov    %eax,0x14(%ebp)
f0121fd1:	8b 45 14             	mov    0x14(%ebp),%eax
f0121fd4:	83 e8 04             	sub    $0x4,%eax
f0121fd7:	8b 00                	mov    (%eax),%eax
f0121fd9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f0121fdc:	eb 1f                	jmp    f0121ffd <vprintfmt+0xea>

		case '.':
			if (width < 0)
f0121fde:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121fe2:	79 83                	jns    f0121f67 <vprintfmt+0x54>
				width = 0;
f0121fe4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f0121feb:	e9 77 ff ff ff       	jmp    f0121f67 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f0121ff0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f0121ff7:	e9 6b ff ff ff       	jmp    f0121f67 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f0121ffc:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f0121ffd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122001:	0f 89 60 ff ff ff    	jns    f0121f67 <vprintfmt+0x54>
				width = precision, precision = -1;
f0122007:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012200a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f012200d:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f0122014:	e9 4e ff ff ff       	jmp    f0121f67 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f0122019:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f012201c:	e9 46 ff ff ff       	jmp    f0121f67 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f0122021:	8b 45 14             	mov    0x14(%ebp),%eax
f0122024:	83 c0 04             	add    $0x4,%eax
f0122027:	89 45 14             	mov    %eax,0x14(%ebp)
f012202a:	8b 45 14             	mov    0x14(%ebp),%eax
f012202d:	83 e8 04             	sub    $0x4,%eax
f0122030:	8b 00                	mov    (%eax),%eax
f0122032:	83 ec 08             	sub    $0x8,%esp
f0122035:	ff 75 0c             	pushl  0xc(%ebp)
f0122038:	50                   	push   %eax
f0122039:	8b 45 08             	mov    0x8(%ebp),%eax
f012203c:	ff d0                	call   *%eax
f012203e:	83 c4 10             	add    $0x10,%esp
			break;
f0122041:	e9 9b 02 00 00       	jmp    f01222e1 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f0122046:	8b 45 14             	mov    0x14(%ebp),%eax
f0122049:	83 c0 04             	add    $0x4,%eax
f012204c:	89 45 14             	mov    %eax,0x14(%ebp)
f012204f:	8b 45 14             	mov    0x14(%ebp),%eax
f0122052:	83 e8 04             	sub    $0x4,%eax
f0122055:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f0122057:	85 db                	test   %ebx,%ebx
f0122059:	79 02                	jns    f012205d <vprintfmt+0x14a>
				err = -err;
f012205b:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f012205d:	83 fb 64             	cmp    $0x64,%ebx
f0122060:	7f 0b                	jg     f012206d <vprintfmt+0x15a>
f0122062:	8b 34 9d 40 02 13 f0 	mov    -0xfecfdc0(,%ebx,4),%esi
f0122069:	85 f6                	test   %esi,%esi
f012206b:	75 19                	jne    f0122086 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f012206d:	53                   	push   %ebx
f012206e:	68 e5 03 13 f0       	push   $0xf01303e5
f0122073:	ff 75 0c             	pushl  0xc(%ebp)
f0122076:	ff 75 08             	pushl  0x8(%ebp)
f0122079:	e8 70 02 00 00       	call   f01222ee <printfmt>
f012207e:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f0122081:	e9 5b 02 00 00       	jmp    f01222e1 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f0122086:	56                   	push   %esi
f0122087:	68 ee 03 13 f0       	push   $0xf01303ee
f012208c:	ff 75 0c             	pushl  0xc(%ebp)
f012208f:	ff 75 08             	pushl  0x8(%ebp)
f0122092:	e8 57 02 00 00       	call   f01222ee <printfmt>
f0122097:	83 c4 10             	add    $0x10,%esp
			break;
f012209a:	e9 42 02 00 00       	jmp    f01222e1 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f012209f:	8b 45 14             	mov    0x14(%ebp),%eax
f01220a2:	83 c0 04             	add    $0x4,%eax
f01220a5:	89 45 14             	mov    %eax,0x14(%ebp)
f01220a8:	8b 45 14             	mov    0x14(%ebp),%eax
f01220ab:	83 e8 04             	sub    $0x4,%eax
f01220ae:	8b 30                	mov    (%eax),%esi
f01220b0:	85 f6                	test   %esi,%esi
f01220b2:	75 05                	jne    f01220b9 <vprintfmt+0x1a6>
				p = "(null)";
f01220b4:	be f1 03 13 f0       	mov    $0xf01303f1,%esi
			if (width > 0 && padc != '-')
f01220b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01220bd:	7e 6d                	jle    f012212c <vprintfmt+0x219>
f01220bf:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f01220c3:	74 67                	je     f012212c <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f01220c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01220c8:	83 ec 08             	sub    $0x8,%esp
f01220cb:	50                   	push   %eax
f01220cc:	56                   	push   %esi
f01220cd:	e8 26 05 00 00       	call   f01225f8 <strnlen>
f01220d2:	83 c4 10             	add    $0x10,%esp
f01220d5:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f01220d8:	eb 16                	jmp    f01220f0 <vprintfmt+0x1dd>
					putch(padc, putdat);
f01220da:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f01220de:	83 ec 08             	sub    $0x8,%esp
f01220e1:	ff 75 0c             	pushl  0xc(%ebp)
f01220e4:	50                   	push   %eax
f01220e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01220e8:	ff d0                	call   *%eax
f01220ea:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f01220ed:	ff 4d e4             	decl   -0x1c(%ebp)
f01220f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01220f4:	7f e4                	jg     f01220da <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f01220f6:	eb 34                	jmp    f012212c <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f01220f8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01220fc:	74 1c                	je     f012211a <vprintfmt+0x207>
f01220fe:	83 fb 1f             	cmp    $0x1f,%ebx
f0122101:	7e 05                	jle    f0122108 <vprintfmt+0x1f5>
f0122103:	83 fb 7e             	cmp    $0x7e,%ebx
f0122106:	7e 12                	jle    f012211a <vprintfmt+0x207>
					putch('?', putdat);
f0122108:	83 ec 08             	sub    $0x8,%esp
f012210b:	ff 75 0c             	pushl  0xc(%ebp)
f012210e:	6a 3f                	push   $0x3f
f0122110:	8b 45 08             	mov    0x8(%ebp),%eax
f0122113:	ff d0                	call   *%eax
f0122115:	83 c4 10             	add    $0x10,%esp
f0122118:	eb 0f                	jmp    f0122129 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f012211a:	83 ec 08             	sub    $0x8,%esp
f012211d:	ff 75 0c             	pushl  0xc(%ebp)
f0122120:	53                   	push   %ebx
f0122121:	8b 45 08             	mov    0x8(%ebp),%eax
f0122124:	ff d0                	call   *%eax
f0122126:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0122129:	ff 4d e4             	decl   -0x1c(%ebp)
f012212c:	89 f0                	mov    %esi,%eax
f012212e:	8d 70 01             	lea    0x1(%eax),%esi
f0122131:	8a 00                	mov    (%eax),%al
f0122133:	0f be d8             	movsbl %al,%ebx
f0122136:	85 db                	test   %ebx,%ebx
f0122138:	74 24                	je     f012215e <vprintfmt+0x24b>
f012213a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f012213e:	78 b8                	js     f01220f8 <vprintfmt+0x1e5>
f0122140:	ff 4d e0             	decl   -0x20(%ebp)
f0122143:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0122147:	79 af                	jns    f01220f8 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f0122149:	eb 13                	jmp    f012215e <vprintfmt+0x24b>
				putch(' ', putdat);
f012214b:	83 ec 08             	sub    $0x8,%esp
f012214e:	ff 75 0c             	pushl  0xc(%ebp)
f0122151:	6a 20                	push   $0x20
f0122153:	8b 45 08             	mov    0x8(%ebp),%eax
f0122156:	ff d0                	call   *%eax
f0122158:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f012215b:	ff 4d e4             	decl   -0x1c(%ebp)
f012215e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122162:	7f e7                	jg     f012214b <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f0122164:	e9 78 01 00 00       	jmp    f01222e1 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f0122169:	83 ec 08             	sub    $0x8,%esp
f012216c:	ff 75 e8             	pushl  -0x18(%ebp)
f012216f:	8d 45 14             	lea    0x14(%ebp),%eax
f0122172:	50                   	push   %eax
f0122173:	e8 3c fd ff ff       	call   f0121eb4 <getint>
f0122178:	83 c4 10             	add    $0x10,%esp
f012217b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012217e:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f0122181:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122184:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122187:	85 d2                	test   %edx,%edx
f0122189:	79 23                	jns    f01221ae <vprintfmt+0x29b>
				putch('-', putdat);
f012218b:	83 ec 08             	sub    $0x8,%esp
f012218e:	ff 75 0c             	pushl  0xc(%ebp)
f0122191:	6a 2d                	push   $0x2d
f0122193:	8b 45 08             	mov    0x8(%ebp),%eax
f0122196:	ff d0                	call   *%eax
f0122198:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f012219b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012219e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01221a1:	f7 d8                	neg    %eax
f01221a3:	83 d2 00             	adc    $0x0,%edx
f01221a6:	f7 da                	neg    %edx
f01221a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01221ab:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f01221ae:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f01221b5:	e9 bc 00 00 00       	jmp    f0122276 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f01221ba:	83 ec 08             	sub    $0x8,%esp
f01221bd:	ff 75 e8             	pushl  -0x18(%ebp)
f01221c0:	8d 45 14             	lea    0x14(%ebp),%eax
f01221c3:	50                   	push   %eax
f01221c4:	e8 84 fc ff ff       	call   f0121e4d <getuint>
f01221c9:	83 c4 10             	add    $0x10,%esp
f01221cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01221cf:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f01221d2:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f01221d9:	e9 98 00 00 00       	jmp    f0122276 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f01221de:	83 ec 08             	sub    $0x8,%esp
f01221e1:	ff 75 0c             	pushl  0xc(%ebp)
f01221e4:	6a 58                	push   $0x58
f01221e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01221e9:	ff d0                	call   *%eax
f01221eb:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f01221ee:	83 ec 08             	sub    $0x8,%esp
f01221f1:	ff 75 0c             	pushl  0xc(%ebp)
f01221f4:	6a 58                	push   $0x58
f01221f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01221f9:	ff d0                	call   *%eax
f01221fb:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f01221fe:	83 ec 08             	sub    $0x8,%esp
f0122201:	ff 75 0c             	pushl  0xc(%ebp)
f0122204:	6a 58                	push   $0x58
f0122206:	8b 45 08             	mov    0x8(%ebp),%eax
f0122209:	ff d0                	call   *%eax
f012220b:	83 c4 10             	add    $0x10,%esp
			break;
f012220e:	e9 ce 00 00 00       	jmp    f01222e1 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f0122213:	83 ec 08             	sub    $0x8,%esp
f0122216:	ff 75 0c             	pushl  0xc(%ebp)
f0122219:	6a 30                	push   $0x30
f012221b:	8b 45 08             	mov    0x8(%ebp),%eax
f012221e:	ff d0                	call   *%eax
f0122220:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f0122223:	83 ec 08             	sub    $0x8,%esp
f0122226:	ff 75 0c             	pushl  0xc(%ebp)
f0122229:	6a 78                	push   $0x78
f012222b:	8b 45 08             	mov    0x8(%ebp),%eax
f012222e:	ff d0                	call   *%eax
f0122230:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f0122233:	8b 45 14             	mov    0x14(%ebp),%eax
f0122236:	83 c0 04             	add    $0x4,%eax
f0122239:	89 45 14             	mov    %eax,0x14(%ebp)
f012223c:	8b 45 14             	mov    0x14(%ebp),%eax
f012223f:	83 e8 04             	sub    $0x4,%eax
f0122242:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f0122244:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122247:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f012224e:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f0122255:	eb 1f                	jmp    f0122276 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f0122257:	83 ec 08             	sub    $0x8,%esp
f012225a:	ff 75 e8             	pushl  -0x18(%ebp)
f012225d:	8d 45 14             	lea    0x14(%ebp),%eax
f0122260:	50                   	push   %eax
f0122261:	e8 e7 fb ff ff       	call   f0121e4d <getuint>
f0122266:	83 c4 10             	add    $0x10,%esp
f0122269:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012226c:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f012226f:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f0122276:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f012227a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012227d:	83 ec 04             	sub    $0x4,%esp
f0122280:	52                   	push   %edx
f0122281:	ff 75 e4             	pushl  -0x1c(%ebp)
f0122284:	50                   	push   %eax
f0122285:	ff 75 f4             	pushl  -0xc(%ebp)
f0122288:	ff 75 f0             	pushl  -0x10(%ebp)
f012228b:	ff 75 0c             	pushl  0xc(%ebp)
f012228e:	ff 75 08             	pushl  0x8(%ebp)
f0122291:	e8 00 fb ff ff       	call   f0121d96 <printnum>
f0122296:	83 c4 20             	add    $0x20,%esp
			break;
f0122299:	eb 46                	jmp    f01222e1 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f012229b:	83 ec 08             	sub    $0x8,%esp
f012229e:	ff 75 0c             	pushl  0xc(%ebp)
f01222a1:	53                   	push   %ebx
f01222a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01222a5:	ff d0                	call   *%eax
f01222a7:	83 c4 10             	add    $0x10,%esp
			break;
f01222aa:	eb 35                	jmp    f01222e1 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f01222ac:	c6 05 f0 0d 5a f0 00 	movb   $0x0,0xf05a0df0
			break;
f01222b3:	eb 2c                	jmp    f01222e1 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f01222b5:	c6 05 f0 0d 5a f0 01 	movb   $0x1,0xf05a0df0
			break;
f01222bc:	eb 23                	jmp    f01222e1 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f01222be:	83 ec 08             	sub    $0x8,%esp
f01222c1:	ff 75 0c             	pushl  0xc(%ebp)
f01222c4:	6a 25                	push   $0x25
f01222c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01222c9:	ff d0                	call   *%eax
f01222cb:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f01222ce:	ff 4d 10             	decl   0x10(%ebp)
f01222d1:	eb 03                	jmp    f01222d6 <vprintfmt+0x3c3>
f01222d3:	ff 4d 10             	decl   0x10(%ebp)
f01222d6:	8b 45 10             	mov    0x10(%ebp),%eax
f01222d9:	48                   	dec    %eax
f01222da:	8a 00                	mov    (%eax),%al
f01222dc:	3c 25                	cmp    $0x25,%al
f01222de:	75 f3                	jne    f01222d3 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f01222e0:	90                   	nop
		}
	}
f01222e1:	e9 35 fc ff ff       	jmp    f0121f1b <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f01222e6:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f01222e7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01222ea:	5b                   	pop    %ebx
f01222eb:	5e                   	pop    %esi
f01222ec:	5d                   	pop    %ebp
f01222ed:	c3                   	ret    

f01222ee <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f01222ee:	55                   	push   %ebp
f01222ef:	89 e5                	mov    %esp,%ebp
f01222f1:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01222f4:	8d 45 10             	lea    0x10(%ebp),%eax
f01222f7:	83 c0 04             	add    $0x4,%eax
f01222fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f01222fd:	8b 45 10             	mov    0x10(%ebp),%eax
f0122300:	ff 75 f4             	pushl  -0xc(%ebp)
f0122303:	50                   	push   %eax
f0122304:	ff 75 0c             	pushl  0xc(%ebp)
f0122307:	ff 75 08             	pushl  0x8(%ebp)
f012230a:	e8 04 fc ff ff       	call   f0121f13 <vprintfmt>
f012230f:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f0122312:	90                   	nop
f0122313:	c9                   	leave  
f0122314:	c3                   	ret    

f0122315 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f0122315:	55                   	push   %ebp
f0122316:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f0122318:	8b 45 0c             	mov    0xc(%ebp),%eax
f012231b:	8b 40 08             	mov    0x8(%eax),%eax
f012231e:	8d 50 01             	lea    0x1(%eax),%edx
f0122321:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122324:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f0122327:	8b 45 0c             	mov    0xc(%ebp),%eax
f012232a:	8b 10                	mov    (%eax),%edx
f012232c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012232f:	8b 40 04             	mov    0x4(%eax),%eax
f0122332:	39 c2                	cmp    %eax,%edx
f0122334:	73 12                	jae    f0122348 <sprintputch+0x33>
		*b->buf++ = ch;
f0122336:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122339:	8b 00                	mov    (%eax),%eax
f012233b:	8d 48 01             	lea    0x1(%eax),%ecx
f012233e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122341:	89 0a                	mov    %ecx,(%edx)
f0122343:	8b 55 08             	mov    0x8(%ebp),%edx
f0122346:	88 10                	mov    %dl,(%eax)
}
f0122348:	90                   	nop
f0122349:	5d                   	pop    %ebp
f012234a:	c3                   	ret    

f012234b <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f012234b:	55                   	push   %ebp
f012234c:	89 e5                	mov    %esp,%ebp
f012234e:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f0122351:	8b 45 08             	mov    0x8(%ebp),%eax
f0122354:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0122357:	8b 45 0c             	mov    0xc(%ebp),%eax
f012235a:	8d 50 ff             	lea    -0x1(%eax),%edx
f012235d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122360:	01 d0                	add    %edx,%eax
f0122362:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122365:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f012236c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122370:	74 06                	je     f0122378 <vsnprintf+0x2d>
f0122372:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122376:	7f 07                	jg     f012237f <vsnprintf+0x34>
		return -E_INVAL;
f0122378:	b8 03 00 00 00       	mov    $0x3,%eax
f012237d:	eb 20                	jmp    f012239f <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f012237f:	ff 75 14             	pushl  0x14(%ebp)
f0122382:	ff 75 10             	pushl  0x10(%ebp)
f0122385:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0122388:	50                   	push   %eax
f0122389:	68 15 23 12 f0       	push   $0xf0122315
f012238e:	e8 80 fb ff ff       	call   f0121f13 <vprintfmt>
f0122393:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f0122396:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122399:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f012239c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f012239f:	c9                   	leave  
f01223a0:	c3                   	ret    

f01223a1 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f01223a1:	55                   	push   %ebp
f01223a2:	89 e5                	mov    %esp,%ebp
f01223a4:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f01223a7:	8d 45 10             	lea    0x10(%ebp),%eax
f01223aa:	83 c0 04             	add    $0x4,%eax
f01223ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f01223b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01223b3:	ff 75 f4             	pushl  -0xc(%ebp)
f01223b6:	50                   	push   %eax
f01223b7:	ff 75 0c             	pushl  0xc(%ebp)
f01223ba:	ff 75 08             	pushl  0x8(%ebp)
f01223bd:	e8 89 ff ff ff       	call   f012234b <vsnprintf>
f01223c2:	83 c4 10             	add    $0x10,%esp
f01223c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f01223c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01223cb:	c9                   	leave  
f01223cc:	c3                   	ret    

f01223cd <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f01223cd:	55                   	push   %ebp
f01223ce:	89 e5                	mov    %esp,%ebp
f01223d0:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f01223d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01223d7:	74 13                	je     f01223ec <readline+0x1f>
		cprintf("%s", prompt);
f01223d9:	83 ec 08             	sub    $0x8,%esp
f01223dc:	ff 75 08             	pushl  0x8(%ebp)
f01223df:	68 68 05 13 f0       	push   $0xf0130568
f01223e4:	e8 83 eb fd ff       	call   f0100f6c <cprintf>
f01223e9:	83 c4 10             	add    $0x10,%esp

	i = 0;
f01223ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f01223f3:	83 ec 0c             	sub    $0xc,%esp
f01223f6:	6a 00                	push   $0x0
f01223f8:	e8 7c ea fd ff       	call   f0100e79 <iscons>
f01223fd:	83 c4 10             	add    $0x10,%esp
f0122400:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f0122403:	e8 58 ea fd ff       	call   f0100e60 <getchar>
f0122408:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f012240b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012240f:	79 22                	jns    f0122433 <readline+0x66>
			if (c != -E_EOF)
f0122411:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0122415:	0f 84 ad 00 00 00    	je     f01224c8 <readline+0xfb>
				cprintf("read error: %e\n", c);
f012241b:	83 ec 08             	sub    $0x8,%esp
f012241e:	ff 75 ec             	pushl  -0x14(%ebp)
f0122421:	68 6b 05 13 f0       	push   $0xf013056b
f0122426:	e8 41 eb fd ff       	call   f0100f6c <cprintf>
f012242b:	83 c4 10             	add    $0x10,%esp
			break;
f012242e:	e9 95 00 00 00       	jmp    f01224c8 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f0122433:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0122437:	7e 34                	jle    f012246d <readline+0xa0>
f0122439:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0122440:	7f 2b                	jg     f012246d <readline+0xa0>
			if (echoing)
f0122442:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122446:	74 0e                	je     f0122456 <readline+0x89>
				cputchar(c);
f0122448:	83 ec 0c             	sub    $0xc,%esp
f012244b:	ff 75 ec             	pushl  -0x14(%ebp)
f012244e:	e8 f6 e9 fd ff       	call   f0100e49 <cputchar>
f0122453:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0122456:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122459:	8d 50 01             	lea    0x1(%eax),%edx
f012245c:	89 55 f4             	mov    %edx,-0xc(%ebp)
f012245f:	89 c2                	mov    %eax,%edx
f0122461:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122464:	01 d0                	add    %edx,%eax
f0122466:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122469:	88 10                	mov    %dl,(%eax)
f012246b:	eb 56                	jmp    f01224c3 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f012246d:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f0122471:	75 1f                	jne    f0122492 <readline+0xc5>
f0122473:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122477:	7e 19                	jle    f0122492 <readline+0xc5>
			if (echoing)
f0122479:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012247d:	74 0e                	je     f012248d <readline+0xc0>
				cputchar(c);
f012247f:	83 ec 0c             	sub    $0xc,%esp
f0122482:	ff 75 ec             	pushl  -0x14(%ebp)
f0122485:	e8 bf e9 fd ff       	call   f0100e49 <cputchar>
f012248a:	83 c4 10             	add    $0x10,%esp

			i--;
f012248d:	ff 4d f4             	decl   -0xc(%ebp)
f0122490:	eb 31                	jmp    f01224c3 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f0122492:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0122496:	74 0a                	je     f01224a2 <readline+0xd5>
f0122498:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f012249c:	0f 85 61 ff ff ff    	jne    f0122403 <readline+0x36>
			if (echoing)
f01224a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01224a6:	74 0e                	je     f01224b6 <readline+0xe9>
				cputchar(c);
f01224a8:	83 ec 0c             	sub    $0xc,%esp
f01224ab:	ff 75 ec             	pushl  -0x14(%ebp)
f01224ae:	e8 96 e9 fd ff       	call   f0100e49 <cputchar>
f01224b3:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f01224b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01224b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01224bc:	01 d0                	add    %edx,%eax
f01224be:	c6 00 00             	movb   $0x0,(%eax)
			break;
f01224c1:	eb 06                	jmp    f01224c9 <readline+0xfc>
		}
	}
f01224c3:	e9 3b ff ff ff       	jmp    f0122403 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f01224c8:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f01224c9:	90                   	nop
f01224ca:	c9                   	leave  
f01224cb:	c3                   	ret    

f01224cc <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f01224cc:	55                   	push   %ebp
f01224cd:	89 e5                	mov    %esp,%ebp
f01224cf:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f01224d2:	e8 ba b3 fe ff       	call   f010d891 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f01224d7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01224db:	74 13                	je     f01224f0 <atomic_readline+0x24>
			cprintf("%s", prompt);
f01224dd:	83 ec 08             	sub    $0x8,%esp
f01224e0:	ff 75 08             	pushl  0x8(%ebp)
f01224e3:	68 68 05 13 f0       	push   $0xf0130568
f01224e8:	e8 7f ea fd ff       	call   f0100f6c <cprintf>
f01224ed:	83 c4 10             	add    $0x10,%esp

		i = 0;
f01224f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f01224f7:	83 ec 0c             	sub    $0xc,%esp
f01224fa:	6a 00                	push   $0x0
f01224fc:	e8 78 e9 fd ff       	call   f0100e79 <iscons>
f0122501:	83 c4 10             	add    $0x10,%esp
f0122504:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f0122507:	e8 54 e9 fd ff       	call   f0100e60 <getchar>
f012250c:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f012250f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0122513:	79 22                	jns    f0122537 <atomic_readline+0x6b>
				if (c != -E_EOF)
f0122515:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0122519:	0f 84 ad 00 00 00    	je     f01225cc <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f012251f:	83 ec 08             	sub    $0x8,%esp
f0122522:	ff 75 ec             	pushl  -0x14(%ebp)
f0122525:	68 6b 05 13 f0       	push   $0xf013056b
f012252a:	e8 3d ea fd ff       	call   f0100f6c <cprintf>
f012252f:	83 c4 10             	add    $0x10,%esp
				break;
f0122532:	e9 95 00 00 00       	jmp    f01225cc <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f0122537:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f012253b:	7e 34                	jle    f0122571 <atomic_readline+0xa5>
f012253d:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0122544:	7f 2b                	jg     f0122571 <atomic_readline+0xa5>
				if (echoing)
f0122546:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012254a:	74 0e                	je     f012255a <atomic_readline+0x8e>
					cputchar(c);
f012254c:	83 ec 0c             	sub    $0xc,%esp
f012254f:	ff 75 ec             	pushl  -0x14(%ebp)
f0122552:	e8 f2 e8 fd ff       	call   f0100e49 <cputchar>
f0122557:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f012255a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012255d:	8d 50 01             	lea    0x1(%eax),%edx
f0122560:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0122563:	89 c2                	mov    %eax,%edx
f0122565:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122568:	01 d0                	add    %edx,%eax
f012256a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012256d:	88 10                	mov    %dl,(%eax)
f012256f:	eb 56                	jmp    f01225c7 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f0122571:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f0122575:	75 1f                	jne    f0122596 <atomic_readline+0xca>
f0122577:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012257b:	7e 19                	jle    f0122596 <atomic_readline+0xca>
				if (echoing)
f012257d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122581:	74 0e                	je     f0122591 <atomic_readline+0xc5>
					cputchar(c);
f0122583:	83 ec 0c             	sub    $0xc,%esp
f0122586:	ff 75 ec             	pushl  -0x14(%ebp)
f0122589:	e8 bb e8 fd ff       	call   f0100e49 <cputchar>
f012258e:	83 c4 10             	add    $0x10,%esp
				i--;
f0122591:	ff 4d f4             	decl   -0xc(%ebp)
f0122594:	eb 31                	jmp    f01225c7 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f0122596:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f012259a:	74 0a                	je     f01225a6 <atomic_readline+0xda>
f012259c:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f01225a0:	0f 85 61 ff ff ff    	jne    f0122507 <atomic_readline+0x3b>
				if (echoing)
f01225a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01225aa:	74 0e                	je     f01225ba <atomic_readline+0xee>
					cputchar(c);
f01225ac:	83 ec 0c             	sub    $0xc,%esp
f01225af:	ff 75 ec             	pushl  -0x14(%ebp)
f01225b2:	e8 92 e8 fd ff       	call   f0100e49 <cputchar>
f01225b7:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f01225ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01225bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01225c0:	01 d0                	add    %edx,%eax
f01225c2:	c6 00 00             	movb   $0x0,(%eax)
				break;
f01225c5:	eb 06                	jmp    f01225cd <atomic_readline+0x101>
			}
		}
f01225c7:	e9 3b ff ff ff       	jmp    f0122507 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f01225cc:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f01225cd:	e8 cd b2 fe ff       	call   f010d89f <sys_unlock_cons>
}
f01225d2:	90                   	nop
f01225d3:	c9                   	leave  
f01225d4:	c3                   	ret    

f01225d5 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f01225d5:	55                   	push   %ebp
f01225d6:	89 e5                	mov    %esp,%ebp
f01225d8:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f01225db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01225e2:	eb 06                	jmp    f01225ea <strlen+0x15>
		n++;
f01225e4:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f01225e7:	ff 45 08             	incl   0x8(%ebp)
f01225ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01225ed:	8a 00                	mov    (%eax),%al
f01225ef:	84 c0                	test   %al,%al
f01225f1:	75 f1                	jne    f01225e4 <strlen+0xf>
		n++;
	return n;
f01225f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01225f6:	c9                   	leave  
f01225f7:	c3                   	ret    

f01225f8 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f01225f8:	55                   	push   %ebp
f01225f9:	89 e5                	mov    %esp,%ebp
f01225fb:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f01225fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122605:	eb 09                	jmp    f0122610 <strnlen+0x18>
		n++;
f0122607:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f012260a:	ff 45 08             	incl   0x8(%ebp)
f012260d:	ff 4d 0c             	decl   0xc(%ebp)
f0122610:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122614:	74 09                	je     f012261f <strnlen+0x27>
f0122616:	8b 45 08             	mov    0x8(%ebp),%eax
f0122619:	8a 00                	mov    (%eax),%al
f012261b:	84 c0                	test   %al,%al
f012261d:	75 e8                	jne    f0122607 <strnlen+0xf>
		n++;
	return n;
f012261f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122622:	c9                   	leave  
f0122623:	c3                   	ret    

f0122624 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f0122624:	55                   	push   %ebp
f0122625:	89 e5                	mov    %esp,%ebp
f0122627:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f012262a:	8b 45 08             	mov    0x8(%ebp),%eax
f012262d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f0122630:	90                   	nop
f0122631:	8b 45 08             	mov    0x8(%ebp),%eax
f0122634:	8d 50 01             	lea    0x1(%eax),%edx
f0122637:	89 55 08             	mov    %edx,0x8(%ebp)
f012263a:	8b 55 0c             	mov    0xc(%ebp),%edx
f012263d:	8d 4a 01             	lea    0x1(%edx),%ecx
f0122640:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0122643:	8a 12                	mov    (%edx),%dl
f0122645:	88 10                	mov    %dl,(%eax)
f0122647:	8a 00                	mov    (%eax),%al
f0122649:	84 c0                	test   %al,%al
f012264b:	75 e4                	jne    f0122631 <strcpy+0xd>
		/* do nothing */;
	return ret;
f012264d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122650:	c9                   	leave  
f0122651:	c3                   	ret    

f0122652 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f0122652:	55                   	push   %ebp
f0122653:	89 e5                	mov    %esp,%ebp
f0122655:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f0122658:	8b 45 08             	mov    0x8(%ebp),%eax
f012265b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f012265e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122665:	eb 1f                	jmp    f0122686 <strncpy+0x34>
		*dst++ = *src;
f0122667:	8b 45 08             	mov    0x8(%ebp),%eax
f012266a:	8d 50 01             	lea    0x1(%eax),%edx
f012266d:	89 55 08             	mov    %edx,0x8(%ebp)
f0122670:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122673:	8a 12                	mov    (%edx),%dl
f0122675:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f0122677:	8b 45 0c             	mov    0xc(%ebp),%eax
f012267a:	8a 00                	mov    (%eax),%al
f012267c:	84 c0                	test   %al,%al
f012267e:	74 03                	je     f0122683 <strncpy+0x31>
			src++;
f0122680:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f0122683:	ff 45 fc             	incl   -0x4(%ebp)
f0122686:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122689:	3b 45 10             	cmp    0x10(%ebp),%eax
f012268c:	72 d9                	jb     f0122667 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f012268e:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0122691:	c9                   	leave  
f0122692:	c3                   	ret    

f0122693 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f0122693:	55                   	push   %ebp
f0122694:	89 e5                	mov    %esp,%ebp
f0122696:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f0122699:	8b 45 08             	mov    0x8(%ebp),%eax
f012269c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f012269f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01226a3:	74 30                	je     f01226d5 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f01226a5:	eb 16                	jmp    f01226bd <strlcpy+0x2a>
			*dst++ = *src++;
f01226a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01226aa:	8d 50 01             	lea    0x1(%eax),%edx
f01226ad:	89 55 08             	mov    %edx,0x8(%ebp)
f01226b0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01226b3:	8d 4a 01             	lea    0x1(%edx),%ecx
f01226b6:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f01226b9:	8a 12                	mov    (%edx),%dl
f01226bb:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f01226bd:	ff 4d 10             	decl   0x10(%ebp)
f01226c0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01226c4:	74 09                	je     f01226cf <strlcpy+0x3c>
f01226c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01226c9:	8a 00                	mov    (%eax),%al
f01226cb:	84 c0                	test   %al,%al
f01226cd:	75 d8                	jne    f01226a7 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f01226cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01226d2:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f01226d5:	8b 55 08             	mov    0x8(%ebp),%edx
f01226d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01226db:	29 c2                	sub    %eax,%edx
f01226dd:	89 d0                	mov    %edx,%eax
}
f01226df:	c9                   	leave  
f01226e0:	c3                   	ret    

f01226e1 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f01226e1:	55                   	push   %ebp
f01226e2:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f01226e4:	eb 06                	jmp    f01226ec <strcmp+0xb>
		p++, q++;
f01226e6:	ff 45 08             	incl   0x8(%ebp)
f01226e9:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f01226ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01226ef:	8a 00                	mov    (%eax),%al
f01226f1:	84 c0                	test   %al,%al
f01226f3:	74 0e                	je     f0122703 <strcmp+0x22>
f01226f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01226f8:	8a 10                	mov    (%eax),%dl
f01226fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01226fd:	8a 00                	mov    (%eax),%al
f01226ff:	38 c2                	cmp    %al,%dl
f0122701:	74 e3                	je     f01226e6 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f0122703:	8b 45 08             	mov    0x8(%ebp),%eax
f0122706:	8a 00                	mov    (%eax),%al
f0122708:	0f b6 d0             	movzbl %al,%edx
f012270b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012270e:	8a 00                	mov    (%eax),%al
f0122710:	0f b6 c0             	movzbl %al,%eax
f0122713:	29 c2                	sub    %eax,%edx
f0122715:	89 d0                	mov    %edx,%eax
}
f0122717:	5d                   	pop    %ebp
f0122718:	c3                   	ret    

f0122719 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f0122719:	55                   	push   %ebp
f012271a:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f012271c:	eb 09                	jmp    f0122727 <strncmp+0xe>
		n--, p++, q++;
f012271e:	ff 4d 10             	decl   0x10(%ebp)
f0122721:	ff 45 08             	incl   0x8(%ebp)
f0122724:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f0122727:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012272b:	74 17                	je     f0122744 <strncmp+0x2b>
f012272d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122730:	8a 00                	mov    (%eax),%al
f0122732:	84 c0                	test   %al,%al
f0122734:	74 0e                	je     f0122744 <strncmp+0x2b>
f0122736:	8b 45 08             	mov    0x8(%ebp),%eax
f0122739:	8a 10                	mov    (%eax),%dl
f012273b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012273e:	8a 00                	mov    (%eax),%al
f0122740:	38 c2                	cmp    %al,%dl
f0122742:	74 da                	je     f012271e <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f0122744:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122748:	75 07                	jne    f0122751 <strncmp+0x38>
		return 0;
f012274a:	b8 00 00 00 00       	mov    $0x0,%eax
f012274f:	eb 14                	jmp    f0122765 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f0122751:	8b 45 08             	mov    0x8(%ebp),%eax
f0122754:	8a 00                	mov    (%eax),%al
f0122756:	0f b6 d0             	movzbl %al,%edx
f0122759:	8b 45 0c             	mov    0xc(%ebp),%eax
f012275c:	8a 00                	mov    (%eax),%al
f012275e:	0f b6 c0             	movzbl %al,%eax
f0122761:	29 c2                	sub    %eax,%edx
f0122763:	89 d0                	mov    %edx,%eax
}
f0122765:	5d                   	pop    %ebp
f0122766:	c3                   	ret    

f0122767 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f0122767:	55                   	push   %ebp
f0122768:	89 e5                	mov    %esp,%ebp
f012276a:	83 ec 04             	sub    $0x4,%esp
f012276d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122770:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0122773:	eb 12                	jmp    f0122787 <strchr+0x20>
		if (*s == c)
f0122775:	8b 45 08             	mov    0x8(%ebp),%eax
f0122778:	8a 00                	mov    (%eax),%al
f012277a:	3a 45 fc             	cmp    -0x4(%ebp),%al
f012277d:	75 05                	jne    f0122784 <strchr+0x1d>
			return (char *) s;
f012277f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122782:	eb 11                	jmp    f0122795 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f0122784:	ff 45 08             	incl   0x8(%ebp)
f0122787:	8b 45 08             	mov    0x8(%ebp),%eax
f012278a:	8a 00                	mov    (%eax),%al
f012278c:	84 c0                	test   %al,%al
f012278e:	75 e5                	jne    f0122775 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f0122790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122795:	c9                   	leave  
f0122796:	c3                   	ret    

f0122797 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f0122797:	55                   	push   %ebp
f0122798:	89 e5                	mov    %esp,%ebp
f012279a:	83 ec 04             	sub    $0x4,%esp
f012279d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01227a0:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01227a3:	eb 0d                	jmp    f01227b2 <strfind+0x1b>
		if (*s == c)
f01227a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01227a8:	8a 00                	mov    (%eax),%al
f01227aa:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01227ad:	74 0e                	je     f01227bd <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f01227af:	ff 45 08             	incl   0x8(%ebp)
f01227b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01227b5:	8a 00                	mov    (%eax),%al
f01227b7:	84 c0                	test   %al,%al
f01227b9:	75 ea                	jne    f01227a5 <strfind+0xe>
f01227bb:	eb 01                	jmp    f01227be <strfind+0x27>
		if (*s == c)
			break;
f01227bd:	90                   	nop
	return (char *) s;
f01227be:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01227c1:	c9                   	leave  
f01227c2:	c3                   	ret    

f01227c3 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f01227c3:	55                   	push   %ebp
f01227c4:	89 e5                	mov    %esp,%ebp
f01227c6:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f01227c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01227cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f01227cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01227d2:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f01227d5:	eb 0e                	jmp    f01227e5 <memset+0x22>
		*p++ = c;
f01227d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01227da:	8d 50 01             	lea    0x1(%eax),%edx
f01227dd:	89 55 fc             	mov    %edx,-0x4(%ebp)
f01227e0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01227e3:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f01227e5:	ff 4d f8             	decl   -0x8(%ebp)
f01227e8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f01227ec:	79 e9                	jns    f01227d7 <memset+0x14>
		*p++ = c;

	return v;
f01227ee:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01227f1:	c9                   	leave  
f01227f2:	c3                   	ret    

f01227f3 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f01227f3:	55                   	push   %ebp
f01227f4:	89 e5                	mov    %esp,%ebp
f01227f6:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f01227f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01227fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f01227ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0122802:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f0122805:	eb 16                	jmp    f012281d <memcpy+0x2a>
		*d++ = *s++;
f0122807:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012280a:	8d 50 01             	lea    0x1(%eax),%edx
f012280d:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0122810:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122813:	8d 4a 01             	lea    0x1(%edx),%ecx
f0122816:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0122819:	8a 12                	mov    (%edx),%dl
f012281b:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f012281d:	8b 45 10             	mov    0x10(%ebp),%eax
f0122820:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122823:	89 55 10             	mov    %edx,0x10(%ebp)
f0122826:	85 c0                	test   %eax,%eax
f0122828:	75 dd                	jne    f0122807 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f012282a:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012282d:	c9                   	leave  
f012282e:	c3                   	ret    

f012282f <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f012282f:	55                   	push   %ebp
f0122830:	89 e5                	mov    %esp,%ebp
f0122832:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0122835:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122838:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f012283b:	8b 45 08             	mov    0x8(%ebp),%eax
f012283e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f0122841:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122844:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0122847:	73 50                	jae    f0122899 <memmove+0x6a>
f0122849:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012284c:	8b 45 10             	mov    0x10(%ebp),%eax
f012284f:	01 d0                	add    %edx,%eax
f0122851:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0122854:	76 43                	jbe    f0122899 <memmove+0x6a>
		s += n;
f0122856:	8b 45 10             	mov    0x10(%ebp),%eax
f0122859:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f012285c:	8b 45 10             	mov    0x10(%ebp),%eax
f012285f:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f0122862:	eb 10                	jmp    f0122874 <memmove+0x45>
			*--d = *--s;
f0122864:	ff 4d f8             	decl   -0x8(%ebp)
f0122867:	ff 4d fc             	decl   -0x4(%ebp)
f012286a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012286d:	8a 10                	mov    (%eax),%dl
f012286f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122872:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f0122874:	8b 45 10             	mov    0x10(%ebp),%eax
f0122877:	8d 50 ff             	lea    -0x1(%eax),%edx
f012287a:	89 55 10             	mov    %edx,0x10(%ebp)
f012287d:	85 c0                	test   %eax,%eax
f012287f:	75 e3                	jne    f0122864 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f0122881:	eb 23                	jmp    f01228a6 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f0122883:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122886:	8d 50 01             	lea    0x1(%eax),%edx
f0122889:	89 55 f8             	mov    %edx,-0x8(%ebp)
f012288c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012288f:	8d 4a 01             	lea    0x1(%edx),%ecx
f0122892:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0122895:	8a 12                	mov    (%edx),%dl
f0122897:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f0122899:	8b 45 10             	mov    0x10(%ebp),%eax
f012289c:	8d 50 ff             	lea    -0x1(%eax),%edx
f012289f:	89 55 10             	mov    %edx,0x10(%ebp)
f01228a2:	85 c0                	test   %eax,%eax
f01228a4:	75 dd                	jne    f0122883 <memmove+0x54>
			*d++ = *s++;

	return dst;
f01228a6:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01228a9:	c9                   	leave  
f01228aa:	c3                   	ret    

f01228ab <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f01228ab:	55                   	push   %ebp
f01228ac:	89 e5                	mov    %esp,%ebp
f01228ae:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f01228b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01228b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f01228b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01228ba:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f01228bd:	eb 2a                	jmp    f01228e9 <memcmp+0x3e>
		if (*s1 != *s2)
f01228bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01228c2:	8a 10                	mov    (%eax),%dl
f01228c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01228c7:	8a 00                	mov    (%eax),%al
f01228c9:	38 c2                	cmp    %al,%dl
f01228cb:	74 16                	je     f01228e3 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f01228cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01228d0:	8a 00                	mov    (%eax),%al
f01228d2:	0f b6 d0             	movzbl %al,%edx
f01228d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01228d8:	8a 00                	mov    (%eax),%al
f01228da:	0f b6 c0             	movzbl %al,%eax
f01228dd:	29 c2                	sub    %eax,%edx
f01228df:	89 d0                	mov    %edx,%eax
f01228e1:	eb 18                	jmp    f01228fb <memcmp+0x50>
		s1++, s2++;
f01228e3:	ff 45 fc             	incl   -0x4(%ebp)
f01228e6:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f01228e9:	8b 45 10             	mov    0x10(%ebp),%eax
f01228ec:	8d 50 ff             	lea    -0x1(%eax),%edx
f01228ef:	89 55 10             	mov    %edx,0x10(%ebp)
f01228f2:	85 c0                	test   %eax,%eax
f01228f4:	75 c9                	jne    f01228bf <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f01228f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01228fb:	c9                   	leave  
f01228fc:	c3                   	ret    

f01228fd <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f01228fd:	55                   	push   %ebp
f01228fe:	89 e5                	mov    %esp,%ebp
f0122900:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f0122903:	8b 55 08             	mov    0x8(%ebp),%edx
f0122906:	8b 45 10             	mov    0x10(%ebp),%eax
f0122909:	01 d0                	add    %edx,%eax
f012290b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f012290e:	eb 15                	jmp    f0122925 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f0122910:	8b 45 08             	mov    0x8(%ebp),%eax
f0122913:	8a 00                	mov    (%eax),%al
f0122915:	0f b6 d0             	movzbl %al,%edx
f0122918:	8b 45 0c             	mov    0xc(%ebp),%eax
f012291b:	0f b6 c0             	movzbl %al,%eax
f012291e:	39 c2                	cmp    %eax,%edx
f0122920:	74 0d                	je     f012292f <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f0122922:	ff 45 08             	incl   0x8(%ebp)
f0122925:	8b 45 08             	mov    0x8(%ebp),%eax
f0122928:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f012292b:	72 e3                	jb     f0122910 <memfind+0x13>
f012292d:	eb 01                	jmp    f0122930 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f012292f:	90                   	nop
	return (void *) s;
f0122930:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122933:	c9                   	leave  
f0122934:	c3                   	ret    

f0122935 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f0122935:	55                   	push   %ebp
f0122936:	89 e5                	mov    %esp,%ebp
f0122938:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f012293b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f0122942:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0122949:	eb 03                	jmp    f012294e <strtol+0x19>
		s++;
f012294b:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f012294e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122951:	8a 00                	mov    (%eax),%al
f0122953:	3c 20                	cmp    $0x20,%al
f0122955:	74 f4                	je     f012294b <strtol+0x16>
f0122957:	8b 45 08             	mov    0x8(%ebp),%eax
f012295a:	8a 00                	mov    (%eax),%al
f012295c:	3c 09                	cmp    $0x9,%al
f012295e:	74 eb                	je     f012294b <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f0122960:	8b 45 08             	mov    0x8(%ebp),%eax
f0122963:	8a 00                	mov    (%eax),%al
f0122965:	3c 2b                	cmp    $0x2b,%al
f0122967:	75 05                	jne    f012296e <strtol+0x39>
		s++;
f0122969:	ff 45 08             	incl   0x8(%ebp)
f012296c:	eb 13                	jmp    f0122981 <strtol+0x4c>
	else if (*s == '-')
f012296e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122971:	8a 00                	mov    (%eax),%al
f0122973:	3c 2d                	cmp    $0x2d,%al
f0122975:	75 0a                	jne    f0122981 <strtol+0x4c>
		s++, neg = 1;
f0122977:	ff 45 08             	incl   0x8(%ebp)
f012297a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f0122981:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122985:	74 06                	je     f012298d <strtol+0x58>
f0122987:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f012298b:	75 20                	jne    f01229ad <strtol+0x78>
f012298d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122990:	8a 00                	mov    (%eax),%al
f0122992:	3c 30                	cmp    $0x30,%al
f0122994:	75 17                	jne    f01229ad <strtol+0x78>
f0122996:	8b 45 08             	mov    0x8(%ebp),%eax
f0122999:	40                   	inc    %eax
f012299a:	8a 00                	mov    (%eax),%al
f012299c:	3c 78                	cmp    $0x78,%al
f012299e:	75 0d                	jne    f01229ad <strtol+0x78>
		s += 2, base = 16;
f01229a0:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f01229a4:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f01229ab:	eb 28                	jmp    f01229d5 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f01229ad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01229b1:	75 15                	jne    f01229c8 <strtol+0x93>
f01229b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01229b6:	8a 00                	mov    (%eax),%al
f01229b8:	3c 30                	cmp    $0x30,%al
f01229ba:	75 0c                	jne    f01229c8 <strtol+0x93>
		s++, base = 8;
f01229bc:	ff 45 08             	incl   0x8(%ebp)
f01229bf:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f01229c6:	eb 0d                	jmp    f01229d5 <strtol+0xa0>
	else if (base == 0)
f01229c8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01229cc:	75 07                	jne    f01229d5 <strtol+0xa0>
		base = 10;
f01229ce:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f01229d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01229d8:	8a 00                	mov    (%eax),%al
f01229da:	3c 2f                	cmp    $0x2f,%al
f01229dc:	7e 19                	jle    f01229f7 <strtol+0xc2>
f01229de:	8b 45 08             	mov    0x8(%ebp),%eax
f01229e1:	8a 00                	mov    (%eax),%al
f01229e3:	3c 39                	cmp    $0x39,%al
f01229e5:	7f 10                	jg     f01229f7 <strtol+0xc2>
			dig = *s - '0';
f01229e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01229ea:	8a 00                	mov    (%eax),%al
f01229ec:	0f be c0             	movsbl %al,%eax
f01229ef:	83 e8 30             	sub    $0x30,%eax
f01229f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01229f5:	eb 42                	jmp    f0122a39 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f01229f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01229fa:	8a 00                	mov    (%eax),%al
f01229fc:	3c 60                	cmp    $0x60,%al
f01229fe:	7e 19                	jle    f0122a19 <strtol+0xe4>
f0122a00:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a03:	8a 00                	mov    (%eax),%al
f0122a05:	3c 7a                	cmp    $0x7a,%al
f0122a07:	7f 10                	jg     f0122a19 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0122a09:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a0c:	8a 00                	mov    (%eax),%al
f0122a0e:	0f be c0             	movsbl %al,%eax
f0122a11:	83 e8 57             	sub    $0x57,%eax
f0122a14:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122a17:	eb 20                	jmp    f0122a39 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0122a19:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a1c:	8a 00                	mov    (%eax),%al
f0122a1e:	3c 40                	cmp    $0x40,%al
f0122a20:	7e 39                	jle    f0122a5b <strtol+0x126>
f0122a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a25:	8a 00                	mov    (%eax),%al
f0122a27:	3c 5a                	cmp    $0x5a,%al
f0122a29:	7f 30                	jg     f0122a5b <strtol+0x126>
			dig = *s - 'A' + 10;
f0122a2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a2e:	8a 00                	mov    (%eax),%al
f0122a30:	0f be c0             	movsbl %al,%eax
f0122a33:	83 e8 37             	sub    $0x37,%eax
f0122a36:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0122a39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122a3c:	3b 45 10             	cmp    0x10(%ebp),%eax
f0122a3f:	7d 19                	jge    f0122a5a <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0122a41:	ff 45 08             	incl   0x8(%ebp)
f0122a44:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122a47:	0f af 45 10          	imul   0x10(%ebp),%eax
f0122a4b:	89 c2                	mov    %eax,%edx
f0122a4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122a50:	01 d0                	add    %edx,%eax
f0122a52:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f0122a55:	e9 7b ff ff ff       	jmp    f01229d5 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f0122a5a:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f0122a5b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122a5f:	74 08                	je     f0122a69 <strtol+0x134>
		*endptr = (char *) s;
f0122a61:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122a64:	8b 55 08             	mov    0x8(%ebp),%edx
f0122a67:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f0122a69:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0122a6d:	74 07                	je     f0122a76 <strtol+0x141>
f0122a6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122a72:	f7 d8                	neg    %eax
f0122a74:	eb 03                	jmp    f0122a79 <strtol+0x144>
f0122a76:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0122a79:	c9                   	leave  
f0122a7a:	c3                   	ret    

f0122a7b <ltostr>:

void
ltostr(long value, char *str)
{
f0122a7b:	55                   	push   %ebp
f0122a7c:	89 e5                	mov    %esp,%ebp
f0122a7e:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f0122a81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f0122a88:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f0122a8f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122a93:	79 13                	jns    f0122aa8 <ltostr+0x2d>
	{
		neg = 1;
f0122a95:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f0122a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122a9f:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f0122aa2:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f0122aa5:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f0122aa8:	8b 45 08             	mov    0x8(%ebp),%eax
f0122aab:	b9 0a 00 00 00       	mov    $0xa,%ecx
f0122ab0:	99                   	cltd   
f0122ab1:	f7 f9                	idiv   %ecx
f0122ab3:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f0122ab6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122ab9:	8d 50 01             	lea    0x1(%eax),%edx
f0122abc:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0122abf:	89 c2                	mov    %eax,%edx
f0122ac1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122ac4:	01 d0                	add    %edx,%eax
f0122ac6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122ac9:	83 c2 30             	add    $0x30,%edx
f0122acc:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0122ace:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0122ad1:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0122ad6:	f7 e9                	imul   %ecx
f0122ad8:	c1 fa 02             	sar    $0x2,%edx
f0122adb:	89 c8                	mov    %ecx,%eax
f0122add:	c1 f8 1f             	sar    $0x1f,%eax
f0122ae0:	29 c2                	sub    %eax,%edx
f0122ae2:	89 d0                	mov    %edx,%eax
f0122ae4:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f0122ae7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122aeb:	75 bb                	jne    f0122aa8 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0122aed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f0122af4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122af7:	48                   	dec    %eax
f0122af8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0122afb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0122aff:	74 3d                	je     f0122b3e <ltostr+0xc3>
		start = 1 ;
f0122b01:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f0122b08:	eb 34                	jmp    f0122b3e <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0122b0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122b0d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b10:	01 d0                	add    %edx,%eax
f0122b12:	8a 00                	mov    (%eax),%al
f0122b14:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f0122b17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122b1a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b1d:	01 c2                	add    %eax,%edx
f0122b1f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0122b22:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b25:	01 c8                	add    %ecx,%eax
f0122b27:	8a 00                	mov    (%eax),%al
f0122b29:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0122b2b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b31:	01 c2                	add    %eax,%edx
f0122b33:	8a 45 eb             	mov    -0x15(%ebp),%al
f0122b36:	88 02                	mov    %al,(%edx)
		start++ ;
f0122b38:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0122b3b:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0122b3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122b41:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0122b44:	7c c4                	jl     f0122b0a <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f0122b46:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0122b49:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b4c:	01 d0                	add    %edx,%eax
f0122b4e:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0122b51:	90                   	nop
f0122b52:	c9                   	leave  
f0122b53:	c3                   	ret    

f0122b54 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f0122b54:	55                   	push   %ebp
f0122b55:	89 e5                	mov    %esp,%ebp
f0122b57:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0122b5a:	ff 75 08             	pushl  0x8(%ebp)
f0122b5d:	e8 73 fa ff ff       	call   f01225d5 <strlen>
f0122b62:	83 c4 04             	add    $0x4,%esp
f0122b65:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f0122b68:	ff 75 0c             	pushl  0xc(%ebp)
f0122b6b:	e8 65 fa ff ff       	call   f01225d5 <strlen>
f0122b70:	83 c4 04             	add    $0x4,%esp
f0122b73:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0122b76:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f0122b7d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122b84:	eb 17                	jmp    f0122b9d <strcconcat+0x49>
		final[s] = str1[s] ;
f0122b86:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122b89:	8b 45 10             	mov    0x10(%ebp),%eax
f0122b8c:	01 c2                	add    %eax,%edx
f0122b8e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0122b91:	8b 45 08             	mov    0x8(%ebp),%eax
f0122b94:	01 c8                	add    %ecx,%eax
f0122b96:	8a 00                	mov    (%eax),%al
f0122b98:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0122b9a:	ff 45 fc             	incl   -0x4(%ebp)
f0122b9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122ba0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0122ba3:	7c e1                	jl     f0122b86 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f0122ba5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0122bac:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f0122bb3:	eb 1f                	jmp    f0122bd4 <strcconcat+0x80>
		final[s++] = str2[i] ;
f0122bb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122bb8:	8d 50 01             	lea    0x1(%eax),%edx
f0122bbb:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0122bbe:	89 c2                	mov    %eax,%edx
f0122bc0:	8b 45 10             	mov    0x10(%ebp),%eax
f0122bc3:	01 c2                	add    %eax,%edx
f0122bc5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f0122bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122bcb:	01 c8                	add    %ecx,%eax
f0122bcd:	8a 00                	mov    (%eax),%al
f0122bcf:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0122bd1:	ff 45 f8             	incl   -0x8(%ebp)
f0122bd4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122bd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0122bda:	7c d9                	jl     f0122bb5 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0122bdc:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122bdf:	8b 45 10             	mov    0x10(%ebp),%eax
f0122be2:	01 d0                	add    %edx,%eax
f0122be4:	c6 00 00             	movb   $0x0,(%eax)
}
f0122be7:	90                   	nop
f0122be8:	c9                   	leave  
f0122be9:	c3                   	ret    

f0122bea <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0122bea:	55                   	push   %ebp
f0122beb:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0122bed:	8b 45 14             	mov    0x14(%ebp),%eax
f0122bf0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f0122bf6:	8b 45 14             	mov    0x14(%ebp),%eax
f0122bf9:	8b 00                	mov    (%eax),%eax
f0122bfb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122c02:	8b 45 10             	mov    0x10(%ebp),%eax
f0122c05:	01 d0                	add    %edx,%eax
f0122c07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0122c0d:	eb 0c                	jmp    f0122c1b <strsplit+0x31>
			*string++ = 0;
f0122c0f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c12:	8d 50 01             	lea    0x1(%eax),%edx
f0122c15:	89 55 08             	mov    %edx,0x8(%ebp)
f0122c18:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0122c1b:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c1e:	8a 00                	mov    (%eax),%al
f0122c20:	84 c0                	test   %al,%al
f0122c22:	74 18                	je     f0122c3c <strsplit+0x52>
f0122c24:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c27:	8a 00                	mov    (%eax),%al
f0122c29:	0f be c0             	movsbl %al,%eax
f0122c2c:	50                   	push   %eax
f0122c2d:	ff 75 0c             	pushl  0xc(%ebp)
f0122c30:	e8 32 fb ff ff       	call   f0122767 <strchr>
f0122c35:	83 c4 08             	add    $0x8,%esp
f0122c38:	85 c0                	test   %eax,%eax
f0122c3a:	75 d3                	jne    f0122c0f <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0122c3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c3f:	8a 00                	mov    (%eax),%al
f0122c41:	84 c0                	test   %al,%al
f0122c43:	74 5a                	je     f0122c9f <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f0122c45:	8b 45 14             	mov    0x14(%ebp),%eax
f0122c48:	8b 00                	mov    (%eax),%eax
f0122c4a:	83 f8 0f             	cmp    $0xf,%eax
f0122c4d:	75 07                	jne    f0122c56 <strsplit+0x6c>
		{
			return 0;
f0122c4f:	b8 00 00 00 00       	mov    $0x0,%eax
f0122c54:	eb 66                	jmp    f0122cbc <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0122c56:	8b 45 14             	mov    0x14(%ebp),%eax
f0122c59:	8b 00                	mov    (%eax),%eax
f0122c5b:	8d 48 01             	lea    0x1(%eax),%ecx
f0122c5e:	8b 55 14             	mov    0x14(%ebp),%edx
f0122c61:	89 0a                	mov    %ecx,(%edx)
f0122c63:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122c6a:	8b 45 10             	mov    0x10(%ebp),%eax
f0122c6d:	01 c2                	add    %eax,%edx
f0122c6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c72:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0122c74:	eb 03                	jmp    f0122c79 <strsplit+0x8f>
			string++;
f0122c76:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0122c79:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c7c:	8a 00                	mov    (%eax),%al
f0122c7e:	84 c0                	test   %al,%al
f0122c80:	74 8b                	je     f0122c0d <strsplit+0x23>
f0122c82:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c85:	8a 00                	mov    (%eax),%al
f0122c87:	0f be c0             	movsbl %al,%eax
f0122c8a:	50                   	push   %eax
f0122c8b:	ff 75 0c             	pushl  0xc(%ebp)
f0122c8e:	e8 d4 fa ff ff       	call   f0122767 <strchr>
f0122c93:	83 c4 08             	add    $0x8,%esp
f0122c96:	85 c0                	test   %eax,%eax
f0122c98:	74 dc                	je     f0122c76 <strsplit+0x8c>
			string++;
	}
f0122c9a:	e9 6e ff ff ff       	jmp    f0122c0d <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0122c9f:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0122ca0:	8b 45 14             	mov    0x14(%ebp),%eax
f0122ca3:	8b 00                	mov    (%eax),%eax
f0122ca5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122cac:	8b 45 10             	mov    0x10(%ebp),%eax
f0122caf:	01 d0                	add    %edx,%eax
f0122cb1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f0122cb7:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0122cbc:	c9                   	leave  
f0122cbd:	c3                   	ret    

f0122cbe <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0122cbe:	55                   	push   %ebp
f0122cbf:	89 e5                	mov    %esp,%ebp
f0122cc1:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f0122cc4:	83 ec 04             	sub    $0x4,%esp
f0122cc7:	68 7c 05 13 f0       	push   $0xf013057c
f0122ccc:	68 3f 01 00 00       	push   $0x13f
f0122cd1:	68 9e 05 13 f0       	push   $0xf013059e
f0122cd6:	e8 3f d6 fd ff       	call   f010031a <_panic>

f0122cdb <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0122cdb:	55                   	push   %ebp
f0122cdc:	89 e5                	mov    %esp,%ebp
f0122cde:	83 ec 18             	sub    $0x18,%esp
f0122ce1:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0122ce8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122ceb:	89 c2                	mov    %eax,%edx
f0122ced:	ec                   	in     (%dx),%al
f0122cee:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0122cf1:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0122cf4:	0f b6 c0             	movzbl %al,%eax
f0122cf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122cfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122cfd:	25 c0 00 00 00       	and    $0xc0,%eax
f0122d02:	83 f8 40             	cmp    $0x40,%eax
f0122d05:	75 10                	jne    f0122d17 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f0122d07:	83 ec 0c             	sub    $0xc,%esp
f0122d0a:	68 a0 0d 5a f0       	push   $0xf05a0da0
f0122d0f:	e8 67 c2 fe ff       	call   f010ef7b <wakeup_one>
f0122d14:	83 c4 10             	add    $0x10,%esp
	}

}
f0122d17:	90                   	nop
f0122d18:	c9                   	leave  
f0122d19:	c3                   	ret    

f0122d1a <ide_init>:

void ide_init()
{
f0122d1a:	55                   	push   %ebp
f0122d1b:	89 e5                	mov    %esp,%ebp
f0122d1d:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0122d20:	83 ec 08             	sub    $0x8,%esp
f0122d23:	68 db 2c 12 f0       	push   $0xf0122cdb
f0122d28:	6a 0e                	push   $0xe
f0122d2a:	e8 69 a6 fe ff       	call   f010d398 <irq_install_handler>
f0122d2f:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0122d32:	83 ec 08             	sub    $0x8,%esp
f0122d35:	68 ac 05 13 f0       	push   $0xf01305ac
f0122d3a:	68 a0 0d 5a f0       	push   $0xf05a0da0
f0122d3f:	e8 9d c1 fe ff       	call   f010eee1 <init_channel>
f0122d44:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f0122d47:	83 ec 08             	sub    $0x8,%esp
f0122d4a:	68 b9 05 13 f0       	push   $0xf01305b9
f0122d4f:	68 e0 38 5a f0       	push   $0xf05a38e0
f0122d54:	e8 97 bd fe ff       	call   f010eaf0 <init_spinlock>
f0122d59:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f0122d5c:	90                   	nop
f0122d5d:	c9                   	leave  
f0122d5e:	c3                   	ret    

f0122d5f <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0122d5f:	55                   	push   %ebp
f0122d60:	89 e5                	mov    %esp,%ebp
f0122d62:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0122d65:	90                   	nop
f0122d66:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0122d6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122d70:	89 c2                	mov    %eax,%edx
f0122d72:	ec                   	in     (%dx),%al
f0122d73:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0122d76:	8a 45 ef             	mov    -0x11(%ebp),%al
f0122d79:	0f b6 c0             	movzbl %al,%eax
f0122d7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122d7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d82:	25 c0 00 00 00       	and    $0xc0,%eax
f0122d87:	83 f8 40             	cmp    $0x40,%eax
f0122d8a:	75 da                	jne    f0122d66 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0122d8c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122d90:	74 24                	je     f0122db6 <ide_wait_ready+0x57>
f0122d92:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d95:	83 e0 21             	and    $0x21,%eax
f0122d98:	85 c0                	test   %eax,%eax
f0122d9a:	74 1a                	je     f0122db6 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0122d9c:	83 ec 0c             	sub    $0xc,%esp
f0122d9f:	ff 75 f4             	pushl  -0xc(%ebp)
f0122da2:	ff 75 f4             	pushl  -0xc(%ebp)
f0122da5:	68 cc 05 13 f0       	push   $0xf01305cc
f0122daa:	6a 5d                	push   $0x5d
f0122dac:	68 ef 05 13 f0       	push   $0xf01305ef
f0122db1:	e8 64 d5 fd ff       	call   f010031a <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f0122db6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122dbb:	c9                   	leave  
f0122dbc:	c3                   	ret    

f0122dbd <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0122dbd:	55                   	push   %ebp
f0122dbe:	89 e5                	mov    %esp,%ebp
f0122dc0:	57                   	push   %edi
f0122dc1:	53                   	push   %ebx
f0122dc2:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f0122dc5:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0122dcc:	76 16                	jbe    f0122de4 <ide_read+0x27>
f0122dce:	68 fa 05 13 f0       	push   $0xf01305fa
f0122dd3:	68 07 06 13 f0       	push   $0xf0130607
f0122dd8:	6a 68                	push   $0x68
f0122dda:	68 ef 05 13 f0       	push   $0xf01305ef
f0122ddf:	e8 36 d5 fd ff       	call   f010031a <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f0122de4:	83 ec 0c             	sub    $0xc,%esp
f0122de7:	6a 00                	push   $0x0
f0122de9:	e8 71 ff ff ff       	call   f0122d5f <ide_wait_ready>
f0122dee:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0122df1:	8b 45 10             	mov    0x10(%ebp),%eax
f0122df4:	0f b6 c0             	movzbl %al,%eax
f0122df7:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0122dfe:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0122e01:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0122e04:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122e07:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0122e08:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e0b:	0f b6 c0             	movzbl %al,%eax
f0122e0e:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0122e15:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0122e18:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0122e1b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122e1e:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0122e1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e22:	c1 e8 08             	shr    $0x8,%eax
f0122e25:	0f b6 c0             	movzbl %al,%eax
f0122e28:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0122e2f:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0122e32:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0122e35:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0122e38:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0122e39:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e3c:	c1 e8 10             	shr    $0x10,%eax
f0122e3f:	0f b6 c0             	movzbl %al,%eax
f0122e42:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0122e49:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0122e4c:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0122e4f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122e52:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0122e53:	a1 50 0c 5a f0       	mov    0xf05a0c50,%eax
f0122e58:	83 e0 01             	and    $0x1,%eax
f0122e5b:	c1 e0 04             	shl    $0x4,%eax
f0122e5e:	88 c2                	mov    %al,%dl
f0122e60:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e63:	c1 e8 18             	shr    $0x18,%eax
f0122e66:	83 e0 0f             	and    $0xf,%eax
f0122e69:	09 d0                	or     %edx,%eax
f0122e6b:	83 c8 e0             	or     $0xffffffe0,%eax
f0122e6e:	0f b6 c0             	movzbl %al,%eax
f0122e71:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0122e78:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0122e7b:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0122e7e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0122e81:	ee                   	out    %al,(%dx)
f0122e82:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0122e89:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f0122e8d:	8a 45 d7             	mov    -0x29(%ebp),%al
f0122e90:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0122e93:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0122e94:	eb 55                	jmp    f0122eeb <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0122e96:	83 ec 0c             	sub    $0xc,%esp
f0122e99:	6a 01                	push   $0x1
f0122e9b:	e8 bf fe ff ff       	call   f0122d5f <ide_wait_ready>
f0122ea0:	83 c4 10             	add    $0x10,%esp
f0122ea3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0122ea6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122eaa:	79 05                	jns    f0122eb1 <ide_read+0xf4>
			return r;
f0122eac:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122eaf:	eb 45                	jmp    f0122ef6 <ide_read+0x139>
f0122eb1:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0122eb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122ebb:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0122ebe:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0122ec5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122ec8:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0122ecb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0122ece:	89 cb                	mov    %ecx,%ebx
f0122ed0:	89 df                	mov    %ebx,%edi
f0122ed2:	89 c1                	mov    %eax,%ecx
f0122ed4:	fc                   	cld    
f0122ed5:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0122ed7:	89 c8                	mov    %ecx,%eax
f0122ed9:	89 fb                	mov    %edi,%ebx
f0122edb:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0122ede:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0122ee1:	ff 4d 10             	decl   0x10(%ebp)
f0122ee4:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0122eeb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122eef:	75 a5                	jne    f0122e96 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0122ef1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122ef6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0122ef9:	5b                   	pop    %ebx
f0122efa:	5f                   	pop    %edi
f0122efb:	5d                   	pop    %ebp
f0122efc:	c3                   	ret    

f0122efd <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0122efd:	55                   	push   %ebp
f0122efe:	89 e5                	mov    %esp,%ebp
f0122f00:	56                   	push   %esi
f0122f01:	53                   	push   %ebx
f0122f02:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0122f05:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0122f0c:	76 19                	jbe    f0122f27 <ide_write+0x2a>
f0122f0e:	68 fa 05 13 f0       	push   $0xf01305fa
f0122f13:	68 07 06 13 f0       	push   $0xf0130607
f0122f18:	68 82 00 00 00       	push   $0x82
f0122f1d:	68 ef 05 13 f0       	push   $0xf01305ef
f0122f22:	e8 f3 d3 fd ff       	call   f010031a <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f0122f27:	83 ec 0c             	sub    $0xc,%esp
f0122f2a:	6a 00                	push   $0x0
f0122f2c:	e8 2e fe ff ff       	call   f0122d5f <ide_wait_ready>
f0122f31:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f0122f34:	8b 45 10             	mov    0x10(%ebp),%eax
f0122f37:	0f b6 c0             	movzbl %al,%eax
f0122f3a:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0122f41:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0122f44:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0122f47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122f4a:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0122f4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f4e:	0f b6 c0             	movzbl %al,%eax
f0122f51:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0122f58:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0122f5b:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0122f5e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122f61:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0122f62:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f65:	c1 e8 08             	shr    $0x8,%eax
f0122f68:	0f b6 c0             	movzbl %al,%eax
f0122f6b:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0122f72:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0122f75:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0122f78:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0122f7b:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0122f7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f7f:	c1 e8 10             	shr    $0x10,%eax
f0122f82:	0f b6 c0             	movzbl %al,%eax
f0122f85:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0122f8c:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0122f8f:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0122f92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122f95:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0122f96:	a1 50 0c 5a f0       	mov    0xf05a0c50,%eax
f0122f9b:	83 e0 01             	and    $0x1,%eax
f0122f9e:	c1 e0 04             	shl    $0x4,%eax
f0122fa1:	88 c2                	mov    %al,%dl
f0122fa3:	8b 45 08             	mov    0x8(%ebp),%eax
f0122fa6:	c1 e8 18             	shr    $0x18,%eax
f0122fa9:	83 e0 0f             	and    $0xf,%eax
f0122fac:	09 d0                	or     %edx,%eax
f0122fae:	83 c8 e0             	or     $0xffffffe0,%eax
f0122fb1:	0f b6 c0             	movzbl %al,%eax
f0122fb4:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0122fbb:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0122fbe:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0122fc1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0122fc4:	ee                   	out    %al,(%dx)
f0122fc5:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0122fcc:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0122fd0:	8a 45 d7             	mov    -0x29(%ebp),%al
f0122fd3:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0122fd6:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0122fd7:	eb 55                	jmp    f012302e <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0122fd9:	83 ec 0c             	sub    $0xc,%esp
f0122fdc:	6a 01                	push   $0x1
f0122fde:	e8 7c fd ff ff       	call   f0122d5f <ide_wait_ready>
f0122fe3:	83 c4 10             	add    $0x10,%esp
f0122fe6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0122fe9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122fed:	79 05                	jns    f0122ff4 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0122fef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122ff2:	eb 45                	jmp    f0123039 <ide_write+0x13c>
f0122ff4:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0122ffb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122ffe:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0123001:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0123008:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012300b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f012300e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0123011:	89 cb                	mov    %ecx,%ebx
f0123013:	89 de                	mov    %ebx,%esi
f0123015:	89 c1                	mov    %eax,%ecx
f0123017:	fc                   	cld    
f0123018:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f012301a:	89 c8                	mov    %ecx,%eax
f012301c:	89 f3                	mov    %esi,%ebx
f012301e:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0123021:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0123024:	ff 4d 10             	decl   0x10(%ebp)
f0123027:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f012302e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0123032:	75 a5                	jne    f0122fd9 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0123034:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0123039:	8d 65 f8             	lea    -0x8(%ebp),%esp
f012303c:	5b                   	pop    %ebx
f012303d:	5e                   	pop    %esi
f012303e:	5d                   	pop    %ebp
f012303f:	c3                   	ret    

f0123040 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0123040:	55                   	push   %ebp
f0123041:	89 e5                	mov    %esp,%ebp
f0123043:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0123046:	8b 45 08             	mov    0x8(%ebp),%eax
f0123049:	83 e8 04             	sub    $0x4,%eax
f012304c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f012304f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0123052:	8b 00                	mov    (%eax),%eax
f0123054:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0123057:	c9                   	leave  
f0123058:	c3                   	ret    

f0123059 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0123059:	55                   	push   %ebp
f012305a:	89 e5                	mov    %esp,%ebp
f012305c:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f012305f:	8b 45 08             	mov    0x8(%ebp),%eax
f0123062:	83 e8 04             	sub    $0x4,%eax
f0123065:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0123068:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012306b:	8b 00                	mov    (%eax),%eax
f012306d:	83 e0 01             	and    $0x1,%eax
f0123070:	85 c0                	test   %eax,%eax
f0123072:	0f 94 c0             	sete   %al
}
f0123075:	c9                   	leave  
f0123076:	c3                   	ret    

f0123077 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0123077:	55                   	push   %ebp
f0123078:	89 e5                	mov    %esp,%ebp
f012307a:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f012307d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0123084:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123087:	83 f8 02             	cmp    $0x2,%eax
f012308a:	74 2b                	je     f01230b7 <alloc_block+0x40>
f012308c:	83 f8 02             	cmp    $0x2,%eax
f012308f:	7f 07                	jg     f0123098 <alloc_block+0x21>
f0123091:	83 f8 01             	cmp    $0x1,%eax
f0123094:	74 0e                	je     f01230a4 <alloc_block+0x2d>
f0123096:	eb 58                	jmp    f01230f0 <alloc_block+0x79>
f0123098:	83 f8 03             	cmp    $0x3,%eax
f012309b:	74 2d                	je     f01230ca <alloc_block+0x53>
f012309d:	83 f8 04             	cmp    $0x4,%eax
f01230a0:	74 3b                	je     f01230dd <alloc_block+0x66>
f01230a2:	eb 4c                	jmp    f01230f0 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f01230a4:	83 ec 0c             	sub    $0xc,%esp
f01230a7:	ff 75 08             	pushl  0x8(%ebp)
f01230aa:	e8 3c 02 00 00       	call   f01232eb <alloc_block_FF>
f01230af:	83 c4 10             	add    $0x10,%esp
f01230b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01230b5:	eb 4a                	jmp    f0123101 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f01230b7:	83 ec 0c             	sub    $0xc,%esp
f01230ba:	ff 75 08             	pushl  0x8(%ebp)
f01230bd:	e8 c8 0b 00 00       	call   f0123c8a <alloc_block_NF>
f01230c2:	83 c4 10             	add    $0x10,%esp
f01230c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01230c8:	eb 37                	jmp    f0123101 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f01230ca:	83 ec 0c             	sub    $0xc,%esp
f01230cd:	ff 75 08             	pushl  0x8(%ebp)
f01230d0:	e8 7a 06 00 00       	call   f012374f <alloc_block_BF>
f01230d5:	83 c4 10             	add    $0x10,%esp
f01230d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01230db:	eb 24                	jmp    f0123101 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f01230dd:	83 ec 0c             	sub    $0xc,%esp
f01230e0:	ff 75 08             	pushl  0x8(%ebp)
f01230e3:	e8 85 0b 00 00       	call   f0123c6d <alloc_block_WF>
f01230e8:	83 c4 10             	add    $0x10,%esp
f01230eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01230ee:	eb 11                	jmp    f0123101 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f01230f0:	83 ec 0c             	sub    $0xc,%esp
f01230f3:	68 1c 06 13 f0       	push   $0xf013061c
f01230f8:	e8 6f de fd ff       	call   f0100f6c <cprintf>
f01230fd:	83 c4 10             	add    $0x10,%esp
		break;
f0123100:	90                   	nop
	}
	return va;
f0123101:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0123104:	c9                   	leave  
f0123105:	c3                   	ret    

f0123106 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0123106:	55                   	push   %ebp
f0123107:	89 e5                	mov    %esp,%ebp
f0123109:	53                   	push   %ebx
f012310a:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f012310d:	83 ec 0c             	sub    $0xc,%esp
f0123110:	68 3c 06 13 f0       	push   $0xf013063c
f0123115:	e8 52 de fd ff       	call   f0100f6c <cprintf>
f012311a:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f012311d:	83 ec 0c             	sub    $0xc,%esp
f0123120:	68 67 06 13 f0       	push   $0xf0130667
f0123125:	e8 42 de fd ff       	call   f0100f6c <cprintf>
f012312a:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f012312d:	8b 45 08             	mov    0x8(%ebp),%eax
f0123130:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0123133:	eb 37                	jmp    f012316c <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0123135:	83 ec 0c             	sub    $0xc,%esp
f0123138:	ff 75 f4             	pushl  -0xc(%ebp)
f012313b:	e8 19 ff ff ff       	call   f0123059 <is_free_block>
f0123140:	83 c4 10             	add    $0x10,%esp
f0123143:	0f be d8             	movsbl %al,%ebx
f0123146:	83 ec 0c             	sub    $0xc,%esp
f0123149:	ff 75 f4             	pushl  -0xc(%ebp)
f012314c:	e8 ef fe ff ff       	call   f0123040 <get_block_size>
f0123151:	83 c4 10             	add    $0x10,%esp
f0123154:	83 ec 04             	sub    $0x4,%esp
f0123157:	53                   	push   %ebx
f0123158:	50                   	push   %eax
f0123159:	68 7f 06 13 f0       	push   $0xf013067f
f012315e:	e8 09 de fd ff       	call   f0100f6c <cprintf>
f0123163:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0123166:	8b 45 10             	mov    0x10(%ebp),%eax
f0123169:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012316c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123170:	74 07                	je     f0123179 <print_blocks_list+0x73>
f0123172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123175:	8b 00                	mov    (%eax),%eax
f0123177:	eb 05                	jmp    f012317e <print_blocks_list+0x78>
f0123179:	b8 00 00 00 00       	mov    $0x0,%eax
f012317e:	89 45 10             	mov    %eax,0x10(%ebp)
f0123181:	8b 45 10             	mov    0x10(%ebp),%eax
f0123184:	85 c0                	test   %eax,%eax
f0123186:	75 ad                	jne    f0123135 <print_blocks_list+0x2f>
f0123188:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012318c:	75 a7                	jne    f0123135 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f012318e:	83 ec 0c             	sub    $0xc,%esp
f0123191:	68 3c 06 13 f0       	push   $0xf013063c
f0123196:	e8 d1 dd fd ff       	call   f0100f6c <cprintf>
f012319b:	83 c4 10             	add    $0x10,%esp

}
f012319e:	90                   	nop
f012319f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01231a2:	c9                   	leave  
f01231a3:	c3                   	ret    

f01231a4 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f01231a4:	55                   	push   %ebp
f01231a5:	89 e5                	mov    %esp,%ebp
f01231a7:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f01231aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01231ad:	83 e0 01             	and    $0x1,%eax
f01231b0:	85 c0                	test   %eax,%eax
f01231b2:	74 03                	je     f01231b7 <initialize_dynamic_allocator+0x13>
f01231b4:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01231b7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01231bb:	0f 84 f2 00 00 00    	je     f01232b3 <initialize_dynamic_allocator+0x10f>
                return ;
            is_initialized = 1;
f01231c1:	c7 05 54 0c 5a f0 01 	movl   $0x1,0xf05a0c54
f01231c8:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f01231cb:	8b 55 08             	mov    0x8(%ebp),%edx
f01231ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01231d1:	01 d0                	add    %edx,%eax
f01231d3:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f01231d8:	0f 87 d8 00 00 00    	ja     f01232b6 <initialize_dynamic_allocator+0x112>
        return;
    if(daStart < KERNEL_HEAP_START)
f01231de:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f01231e5:	0f 86 ce 00 00 00    	jbe    f01232b9 <initialize_dynamic_allocator+0x115>
        return;


    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01231eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01231ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    beg_block->info = 1;
f01231f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01231f4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    struct Block_Start_End* end_block = (struct Block_Start_End*) (daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End));
f01231fa:	8b 55 08             	mov    0x8(%ebp),%edx
f01231fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123200:	01 d0                	add    %edx,%eax
f0123202:	83 e8 04             	sub    $0x4,%eax
f0123205:	89 45 f0             	mov    %eax,-0x10(%ebp)
    end_block->info = 1;
f0123208:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012320b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0123211:	8b 45 08             	mov    0x8(%ebp),%eax
f0123214:	83 c0 08             	add    $0x8,%eax
f0123217:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f012321a:	8b 45 08             	mov    0x8(%ebp),%eax
f012321d:	83 c0 04             	add    $0x4,%eax
f0123220:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123223:	83 ea 08             	sub    $0x8,%edx
f0123226:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0123228:	8b 55 0c             	mov    0xc(%ebp),%edx
f012322b:	8b 45 08             	mov    0x8(%ebp),%eax
f012322e:	01 d0                	add    %edx,%eax
f0123230:	83 e8 08             	sub    $0x8,%eax
f0123233:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123236:	83 ea 08             	sub    $0x8,%edx
f0123239:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f012323b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012323e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0123244:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0123247:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f012324e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0123252:	75 17                	jne    f012326b <initialize_dynamic_allocator+0xc7>
f0123254:	83 ec 04             	sub    $0x4,%esp
f0123257:	68 98 06 13 f0       	push   $0xf0130698
f012325c:	68 8c 00 00 00       	push   $0x8c
f0123261:	68 bb 06 13 f0       	push   $0xf01306bb
f0123266:	e8 af d0 fd ff       	call   f010031a <_panic>
f012326b:	8b 15 50 0f 5a f0    	mov    0xf05a0f50,%edx
f0123271:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0123274:	89 10                	mov    %edx,(%eax)
f0123276:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0123279:	8b 00                	mov    (%eax),%eax
f012327b:	85 c0                	test   %eax,%eax
f012327d:	74 0d                	je     f012328c <initialize_dynamic_allocator+0xe8>
f012327f:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123284:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0123287:	89 50 04             	mov    %edx,0x4(%eax)
f012328a:	eb 08                	jmp    f0123294 <initialize_dynamic_allocator+0xf0>
f012328c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012328f:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123294:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0123297:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f012329c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012329f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01232a6:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f01232ab:	40                   	inc    %eax
f01232ac:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
f01232b1:	eb 07                	jmp    f01232ba <initialize_dynamic_allocator+0x116>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f01232b3:	90                   	nop
f01232b4:	eb 04                	jmp    f01232ba <initialize_dynamic_allocator+0x116>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f01232b6:	90                   	nop
f01232b7:	eb 01                	jmp    f01232ba <initialize_dynamic_allocator+0x116>
    if(daStart < KERNEL_HEAP_START)
        return;
f01232b9:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f01232ba:	c9                   	leave  
f01232bb:	c3                   	ret    

f01232bc <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f01232bc:	55                   	push   %ebp
f01232bd:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f01232bf:	8b 45 10             	mov    0x10(%ebp),%eax
f01232c2:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f01232c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01232c8:	8d 50 fc             	lea    -0x4(%eax),%edx
f01232cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01232ce:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f01232d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01232d3:	83 e8 04             	sub    $0x4,%eax
f01232d6:	8b 00                	mov    (%eax),%eax
f01232d8:	83 e0 fe             	and    $0xfffffffe,%eax
f01232db:	8d 50 f8             	lea    -0x8(%eax),%edx
f01232de:	8b 45 08             	mov    0x8(%ebp),%eax
f01232e1:	01 c2                	add    %eax,%edx
f01232e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01232e6:	89 02                	mov    %eax,(%edx)
}
f01232e8:	90                   	nop
f01232e9:	5d                   	pop    %ebp
f01232ea:	c3                   	ret    

f01232eb <alloc_block_FF>:

//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size)
{
f01232eb:	55                   	push   %ebp
f01232ec:	89 e5                	mov    %esp,%ebp
f01232ee:	83 ec 48             	sub    $0x48,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01232f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01232f4:	83 e0 01             	and    $0x1,%eax
f01232f7:	85 c0                	test   %eax,%eax
f01232f9:	74 03                	je     f01232fe <alloc_block_FF+0x13>
f01232fb:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01232fe:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0123302:	77 07                	ja     f012330b <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0123304:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f012330b:	a1 54 0c 5a f0       	mov    0xf05a0c54,%eax
f0123310:	85 c0                	test   %eax,%eax
f0123312:	75 73                	jne    f0123387 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0123314:	8b 45 08             	mov    0x8(%ebp),%eax
f0123317:	83 c0 10             	add    $0x10,%eax
f012331a:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f012331d:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0123324:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123327:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012332a:	01 d0                	add    %edx,%eax
f012332c:	48                   	dec    %eax
f012332d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0123330:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123333:	ba 00 00 00 00       	mov    $0x0,%edx
f0123338:	f7 75 ec             	divl   -0x14(%ebp)
f012333b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012333e:	29 d0                	sub    %edx,%eax
f0123340:	c1 e8 0c             	shr    $0xc,%eax
f0123343:	83 ec 0c             	sub    $0xc,%esp
f0123346:	50                   	push   %eax
f0123347:	e8 60 57 fe ff       	call   f0108aac <sbrk>
f012334c:	83 c4 10             	add    $0x10,%esp
f012334f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0123352:	83 ec 0c             	sub    $0xc,%esp
f0123355:	6a 00                	push   $0x0
f0123357:	e8 50 57 fe ff       	call   f0108aac <sbrk>
f012335c:	83 c4 10             	add    $0x10,%esp
f012335f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0123362:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123365:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0123368:	83 ec 08             	sub    $0x8,%esp
f012336b:	50                   	push   %eax
f012336c:	ff 75 e4             	pushl  -0x1c(%ebp)
f012336f:	e8 30 fe ff ff       	call   f01231a4 <initialize_dynamic_allocator>
f0123374:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0123377:	83 ec 0c             	sub    $0xc,%esp
f012337a:	68 d3 06 13 f0       	push   $0xf01306d3
f012337f:	e8 e8 db fd ff       	call   f0100f6c <cprintf>
f0123384:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0123387:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012338b:	75 0a                	jne    f0123397 <alloc_block_FF+0xac>
	        return NULL;
f012338d:	b8 00 00 00 00       	mov    $0x0,%eax
f0123392:	e9 b6 03 00 00       	jmp    f012374d <alloc_block_FF+0x462>
	    }
	    struct BlockElement *blk = NULL;
f0123397:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f012339e:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f01233a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01233a6:	e9 03 03 00 00       	jmp    f01236ae <alloc_block_FF+0x3c3>
	        void *va = (void *)blk;
f01233ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01233ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
	        uint32 blk_size = get_block_size(va);
f01233b1:	83 ec 0c             	sub    $0xc,%esp
f01233b4:	ff 75 cc             	pushl  -0x34(%ebp)
f01233b7:	e8 84 fc ff ff       	call   f0123040 <get_block_size>
f01233bc:	83 c4 10             	add    $0x10,%esp
f01233bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
//	        cprintf("Bloc Size : %d , Size : %d\n",blk_size,size);

	        if (blk_size >= size + 2 * sizeof(uint32)) {
f01233c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01233c5:	83 c0 08             	add    $0x8,%eax
f01233c8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01233cb:	0f 87 d5 02 00 00    	ja     f01236a6 <alloc_block_FF+0x3bb>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f01233d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01233d4:	83 c0 18             	add    $0x18,%eax
f01233d7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01233da:	0f 87 19 02 00 00    	ja     f01235f9 <alloc_block_FF+0x30e>
	            {

	                uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f01233e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01233e3:	2b 45 08             	sub    0x8(%ebp),%eax
f01233e6:	83 e8 08             	sub    $0x8,%eax
f01233e9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	                void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32)); // casting to char because its 1 byte size
f01233ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01233ef:	8d 50 08             	lea    0x8(%eax),%edx
f01233f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01233f5:	01 d0                	add    %edx,%eax
f01233f7:	89 45 c0             	mov    %eax,-0x40(%ebp)
	                set_block_data(va, size + 2 * sizeof(uint32), 1);
f01233fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01233fd:	83 c0 08             	add    $0x8,%eax
f0123400:	83 ec 04             	sub    $0x4,%esp
f0123403:	6a 01                	push   $0x1
f0123405:	50                   	push   %eax
f0123406:	ff 75 cc             	pushl  -0x34(%ebp)
f0123409:	e8 ae fe ff ff       	call   f01232bc <set_block_data>
f012340e:	83 c4 10             	add    $0x10,%esp

	                if (LIST_PREV(blk)==NULL)
f0123411:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123414:	8b 40 04             	mov    0x4(%eax),%eax
f0123417:	85 c0                	test   %eax,%eax
f0123419:	75 68                	jne    f0123483 <alloc_block_FF+0x198>
					{
						LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f012341b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f012341f:	75 17                	jne    f0123438 <alloc_block_FF+0x14d>
f0123421:	83 ec 04             	sub    $0x4,%esp
f0123424:	68 98 06 13 f0       	push   $0xf0130698
f0123429:	68 d0 00 00 00       	push   $0xd0
f012342e:	68 bb 06 13 f0       	push   $0xf01306bb
f0123433:	e8 e2 ce fd ff       	call   f010031a <_panic>
f0123438:	8b 15 50 0f 5a f0    	mov    0xf05a0f50,%edx
f012343e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123441:	89 10                	mov    %edx,(%eax)
f0123443:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123446:	8b 00                	mov    (%eax),%eax
f0123448:	85 c0                	test   %eax,%eax
f012344a:	74 0d                	je     f0123459 <alloc_block_FF+0x16e>
f012344c:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123451:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0123454:	89 50 04             	mov    %edx,0x4(%eax)
f0123457:	eb 08                	jmp    f0123461 <alloc_block_FF+0x176>
f0123459:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012345c:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123461:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123464:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f0123469:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012346c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123473:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123478:	40                   	inc    %eax
f0123479:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
f012347e:	e9 dc 00 00 00       	jmp    f012355f <alloc_block_FF+0x274>
					}
					else if (LIST_NEXT(blk)==NULL)
f0123483:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123486:	8b 00                	mov    (%eax),%eax
f0123488:	85 c0                	test   %eax,%eax
f012348a:	75 65                	jne    f01234f1 <alloc_block_FF+0x206>
					{
						LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f012348c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0123490:	75 17                	jne    f01234a9 <alloc_block_FF+0x1be>
f0123492:	83 ec 04             	sub    $0x4,%esp
f0123495:	68 e4 06 13 f0       	push   $0xf01306e4
f012349a:	68 d4 00 00 00       	push   $0xd4
f012349f:	68 bb 06 13 f0       	push   $0xf01306bb
f01234a4:	e8 71 ce fd ff       	call   f010031a <_panic>
f01234a9:	8b 15 54 0f 5a f0    	mov    0xf05a0f54,%edx
f01234af:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01234b2:	89 50 04             	mov    %edx,0x4(%eax)
f01234b5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01234b8:	8b 40 04             	mov    0x4(%eax),%eax
f01234bb:	85 c0                	test   %eax,%eax
f01234bd:	74 0c                	je     f01234cb <alloc_block_FF+0x1e0>
f01234bf:	a1 54 0f 5a f0       	mov    0xf05a0f54,%eax
f01234c4:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01234c7:	89 10                	mov    %edx,(%eax)
f01234c9:	eb 08                	jmp    f01234d3 <alloc_block_FF+0x1e8>
f01234cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01234ce:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f01234d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01234d6:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f01234db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01234de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01234e4:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f01234e9:	40                   	inc    %eax
f01234ea:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
f01234ef:	eb 6e                	jmp    f012355f <alloc_block_FF+0x274>
					}
					else
					{
						LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f01234f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01234f5:	74 06                	je     f01234fd <alloc_block_FF+0x212>
f01234f7:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f01234fb:	75 17                	jne    f0123514 <alloc_block_FF+0x229>
f01234fd:	83 ec 04             	sub    $0x4,%esp
f0123500:	68 08 07 13 f0       	push   $0xf0130708
f0123505:	68 d8 00 00 00       	push   $0xd8
f012350a:	68 bb 06 13 f0       	push   $0xf01306bb
f012350f:	e8 06 ce fd ff       	call   f010031a <_panic>
f0123514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123517:	8b 10                	mov    (%eax),%edx
f0123519:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012351c:	89 10                	mov    %edx,(%eax)
f012351e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123521:	8b 00                	mov    (%eax),%eax
f0123523:	85 c0                	test   %eax,%eax
f0123525:	74 0b                	je     f0123532 <alloc_block_FF+0x247>
f0123527:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012352a:	8b 00                	mov    (%eax),%eax
f012352c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f012352f:	89 50 04             	mov    %edx,0x4(%eax)
f0123532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123535:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0123538:	89 10                	mov    %edx,(%eax)
f012353a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012353d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123540:	89 50 04             	mov    %edx,0x4(%eax)
f0123543:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123546:	8b 00                	mov    (%eax),%eax
f0123548:	85 c0                	test   %eax,%eax
f012354a:	75 08                	jne    f0123554 <alloc_block_FF+0x269>
f012354c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012354f:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123554:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123559:	40                   	inc    %eax
f012355a:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
					}
					LIST_REMOVE(&freeBlocksList, blk);
f012355f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123563:	75 17                	jne    f012357c <alloc_block_FF+0x291>
f0123565:	83 ec 04             	sub    $0x4,%esp
f0123568:	68 3c 07 13 f0       	push   $0xf013073c
f012356d:	68 da 00 00 00       	push   $0xda
f0123572:	68 bb 06 13 f0       	push   $0xf01306bb
f0123577:	e8 9e cd fd ff       	call   f010031a <_panic>
f012357c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012357f:	8b 00                	mov    (%eax),%eax
f0123581:	85 c0                	test   %eax,%eax
f0123583:	74 10                	je     f0123595 <alloc_block_FF+0x2aa>
f0123585:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123588:	8b 00                	mov    (%eax),%eax
f012358a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012358d:	8b 52 04             	mov    0x4(%edx),%edx
f0123590:	89 50 04             	mov    %edx,0x4(%eax)
f0123593:	eb 0b                	jmp    f01235a0 <alloc_block_FF+0x2b5>
f0123595:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123598:	8b 40 04             	mov    0x4(%eax),%eax
f012359b:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f01235a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01235a3:	8b 40 04             	mov    0x4(%eax),%eax
f01235a6:	85 c0                	test   %eax,%eax
f01235a8:	74 0f                	je     f01235b9 <alloc_block_FF+0x2ce>
f01235aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01235ad:	8b 40 04             	mov    0x4(%eax),%eax
f01235b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01235b3:	8b 12                	mov    (%edx),%edx
f01235b5:	89 10                	mov    %edx,(%eax)
f01235b7:	eb 0a                	jmp    f01235c3 <alloc_block_FF+0x2d8>
f01235b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01235bc:	8b 00                	mov    (%eax),%eax
f01235be:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f01235c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01235c6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01235cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01235cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01235d6:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f01235db:	48                   	dec    %eax
f01235dc:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
					set_block_data(new_block_va, remaining_size, 0);
f01235e1:	83 ec 04             	sub    $0x4,%esp
f01235e4:	6a 00                	push   $0x0
f01235e6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01235e9:	ff 75 c0             	pushl  -0x40(%ebp)
f01235ec:	e8 cb fc ff ff       	call   f01232bc <set_block_data>
f01235f1:	83 c4 10             	add    $0x10,%esp
f01235f4:	e9 a5 00 00 00       	jmp    f012369e <alloc_block_FF+0x3b3>
	            }
	            else
	            {
	            	cprintf("225\n");
f01235f9:	83 ec 0c             	sub    $0xc,%esp
f01235fc:	68 5a 07 13 f0       	push   $0xf013075a
f0123601:	e8 66 d9 fd ff       	call   f0100f6c <cprintf>
f0123606:	83 c4 10             	add    $0x10,%esp
	            	set_block_data(va, blk_size, 1);
f0123609:	83 ec 04             	sub    $0x4,%esp
f012360c:	6a 01                	push   $0x1
f012360e:	ff 75 c8             	pushl  -0x38(%ebp)
f0123611:	ff 75 cc             	pushl  -0x34(%ebp)
f0123614:	e8 a3 fc ff ff       	call   f01232bc <set_block_data>
f0123619:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f012361c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123620:	75 17                	jne    f0123639 <alloc_block_FF+0x34e>
f0123622:	83 ec 04             	sub    $0x4,%esp
f0123625:	68 3c 07 13 f0       	push   $0xf013073c
f012362a:	68 e1 00 00 00       	push   $0xe1
f012362f:	68 bb 06 13 f0       	push   $0xf01306bb
f0123634:	e8 e1 cc fd ff       	call   f010031a <_panic>
f0123639:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012363c:	8b 00                	mov    (%eax),%eax
f012363e:	85 c0                	test   %eax,%eax
f0123640:	74 10                	je     f0123652 <alloc_block_FF+0x367>
f0123642:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123645:	8b 00                	mov    (%eax),%eax
f0123647:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012364a:	8b 52 04             	mov    0x4(%edx),%edx
f012364d:	89 50 04             	mov    %edx,0x4(%eax)
f0123650:	eb 0b                	jmp    f012365d <alloc_block_FF+0x372>
f0123652:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123655:	8b 40 04             	mov    0x4(%eax),%eax
f0123658:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f012365d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123660:	8b 40 04             	mov    0x4(%eax),%eax
f0123663:	85 c0                	test   %eax,%eax
f0123665:	74 0f                	je     f0123676 <alloc_block_FF+0x38b>
f0123667:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012366a:	8b 40 04             	mov    0x4(%eax),%eax
f012366d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123670:	8b 12                	mov    (%edx),%edx
f0123672:	89 10                	mov    %edx,(%eax)
f0123674:	eb 0a                	jmp    f0123680 <alloc_block_FF+0x395>
f0123676:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123679:	8b 00                	mov    (%eax),%eax
f012367b:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f0123680:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123683:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123689:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012368c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123693:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123698:	48                   	dec    %eax
f0123699:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
	            }
	            return va;
f012369e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01236a1:	e9 a7 00 00 00       	jmp    f012374d <alloc_block_FF+0x462>

	 if (size == 0) {
	        return NULL;
	    }
	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f01236a6:	a1 58 0f 5a f0       	mov    0xf05a0f58,%eax
f01236ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01236ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01236b2:	74 07                	je     f01236bb <alloc_block_FF+0x3d0>
f01236b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01236b7:	8b 00                	mov    (%eax),%eax
f01236b9:	eb 05                	jmp    f01236c0 <alloc_block_FF+0x3d5>
f01236bb:	b8 00 00 00 00       	mov    $0x0,%eax
f01236c0:	a3 58 0f 5a f0       	mov    %eax,0xf05a0f58
f01236c5:	a1 58 0f 5a f0       	mov    0xf05a0f58,%eax
f01236ca:	85 c0                	test   %eax,%eax
f01236cc:	0f 85 d9 fc ff ff    	jne    f01233ab <alloc_block_FF+0xc0>
f01236d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01236d6:	0f 85 cf fc ff ff    	jne    f01233ab <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    cprintf("sbrk\n");
f01236dc:	83 ec 0c             	sub    $0xc,%esp
f01236df:	68 5f 07 13 f0       	push   $0xf013075f
f01236e4:	e8 83 d8 fd ff       	call   f0100f6c <cprintf>
f01236e9:	83 c4 10             	add    $0x10,%esp
	    uint32 required_size = size + 2 * sizeof(uint32);
f01236ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01236ef:	83 c0 08             	add    $0x8,%eax
f01236f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01236f5:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01236fc:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01236ff:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123702:	01 d0                	add    %edx,%eax
f0123704:	48                   	dec    %eax
f0123705:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0123708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012370b:	ba 00 00 00 00       	mov    $0x0,%edx
f0123710:	f7 75 d8             	divl   -0x28(%ebp)
f0123713:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123716:	29 d0                	sub    %edx,%eax
f0123718:	c1 e8 0c             	shr    $0xc,%eax
f012371b:	83 ec 0c             	sub    $0xc,%esp
f012371e:	50                   	push   %eax
f012371f:	e8 88 53 fe ff       	call   f0108aac <sbrk>
f0123724:	83 c4 10             	add    $0x10,%esp
f0123727:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f012372a:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f012372e:	75 07                	jne    f0123737 <alloc_block_FF+0x44c>
			return NULL; // Allocation failed
f0123730:	b8 00 00 00 00       	mov    $0x0,%eax
f0123735:	eb 16                	jmp    f012374d <alloc_block_FF+0x462>
		}
		set_block_data(new_mem, required_size, 1);
f0123737:	83 ec 04             	sub    $0x4,%esp
f012373a:	6a 01                	push   $0x1
f012373c:	ff 75 dc             	pushl  -0x24(%ebp)
f012373f:	ff 75 d0             	pushl  -0x30(%ebp)
f0123742:	e8 75 fb ff ff       	call   f01232bc <set_block_data>
f0123747:	83 c4 10             	add    $0x10,%esp
		return new_mem;
f012374a:	8b 45 d0             	mov    -0x30(%ebp),%eax
}
f012374d:	c9                   	leave  
f012374e:	c3                   	ret    

f012374f <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f012374f:	55                   	push   %ebp
f0123750:	89 e5                	mov    %esp,%ebp
f0123752:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - BONUS] [3] DYNAMIC ALLOCATOR - alloc_block_BF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("alloc_block_BF is not implemented yet");
f0123755:	83 ec 04             	sub    $0x4,%esp
f0123758:	68 68 07 13 f0       	push   $0xf0130768
f012375d:	68 f6 00 00 00       	push   $0xf6
f0123762:	68 bb 06 13 f0       	push   $0xf01306bb
f0123767:	e8 ae cb fd ff       	call   f010031a <_panic>

f012376c <merging>:
}

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f012376c:	55                   	push   %ebp
f012376d:	89 e5                	mov    %esp,%ebp
f012376f:	53                   	push   %ebx
f0123770:	83 ec 24             	sub    $0x24,%esp
//	cprintf("273\n");
	bool prev_is_free = 0, next_is_free = 0;
f0123773:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f012377a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0123781:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123785:	74 1e                	je     f01237a5 <merging+0x39>
f0123787:	ff 75 08             	pushl  0x8(%ebp)
f012378a:	e8 b1 f8 ff ff       	call   f0123040 <get_block_size>
f012378f:	83 c4 04             	add    $0x4,%esp
f0123792:	89 c2                	mov    %eax,%edx
f0123794:	8b 45 08             	mov    0x8(%ebp),%eax
f0123797:	01 d0                	add    %edx,%eax
f0123799:	3b 45 10             	cmp    0x10(%ebp),%eax
f012379c:	75 07                	jne    f01237a5 <merging+0x39>
//		cprintf("276\n");
		prev_is_free = 1;
f012379e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f01237a5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01237a9:	74 1e                	je     f01237c9 <merging+0x5d>
f01237ab:	ff 75 10             	pushl  0x10(%ebp)
f01237ae:	e8 8d f8 ff ff       	call   f0123040 <get_block_size>
f01237b3:	83 c4 04             	add    $0x4,%esp
f01237b6:	89 c2                	mov    %eax,%edx
f01237b8:	8b 45 10             	mov    0x10(%ebp),%eax
f01237bb:	01 d0                	add    %edx,%eax
f01237bd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01237c0:	75 07                	jne    f01237c9 <merging+0x5d>
		next_is_free = 1;
f01237c2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}


	if(prev_is_free && next_is_free)
f01237c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01237cd:	0f 84 cc 00 00 00    	je     f012389f <merging+0x133>
f01237d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01237d7:	0f 84 c2 00 00 00    	je     f012389f <merging+0x133>
	{
//		cprintf("284\n");
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f01237dd:	ff 75 08             	pushl  0x8(%ebp)
f01237e0:	e8 5b f8 ff ff       	call   f0123040 <get_block_size>
f01237e5:	83 c4 04             	add    $0x4,%esp
f01237e8:	89 c3                	mov    %eax,%ebx
f01237ea:	ff 75 10             	pushl  0x10(%ebp)
f01237ed:	e8 4e f8 ff ff       	call   f0123040 <get_block_size>
f01237f2:	83 c4 04             	add    $0x4,%esp
f01237f5:	01 c3                	add    %eax,%ebx
f01237f7:	ff 75 0c             	pushl  0xc(%ebp)
f01237fa:	e8 41 f8 ff ff       	call   f0123040 <get_block_size>
f01237ff:	83 c4 04             	add    $0x4,%esp
f0123802:	01 d8                	add    %ebx,%eax
f0123804:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0123807:	6a 00                	push   $0x0
f0123809:	ff 75 ec             	pushl  -0x14(%ebp)
f012380c:	ff 75 08             	pushl  0x8(%ebp)
f012380f:	e8 a8 fa ff ff       	call   f01232bc <set_block_data>
f0123814:	83 c4 0c             	add    $0xc,%esp


		LIST_REMOVE(&freeBlocksList, next_block);
f0123817:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012381b:	75 17                	jne    f0123834 <merging+0xc8>
f012381d:	83 ec 04             	sub    $0x4,%esp
f0123820:	68 3c 07 13 f0       	push   $0xf013073c
f0123825:	68 13 01 00 00       	push   $0x113
f012382a:	68 bb 06 13 f0       	push   $0xf01306bb
f012382f:	e8 e6 ca fd ff       	call   f010031a <_panic>
f0123834:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123837:	8b 00                	mov    (%eax),%eax
f0123839:	85 c0                	test   %eax,%eax
f012383b:	74 10                	je     f012384d <merging+0xe1>
f012383d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123840:	8b 00                	mov    (%eax),%eax
f0123842:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123845:	8b 52 04             	mov    0x4(%edx),%edx
f0123848:	89 50 04             	mov    %edx,0x4(%eax)
f012384b:	eb 0b                	jmp    f0123858 <merging+0xec>
f012384d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123850:	8b 40 04             	mov    0x4(%eax),%eax
f0123853:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123858:	8b 45 0c             	mov    0xc(%ebp),%eax
f012385b:	8b 40 04             	mov    0x4(%eax),%eax
f012385e:	85 c0                	test   %eax,%eax
f0123860:	74 0f                	je     f0123871 <merging+0x105>
f0123862:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123865:	8b 40 04             	mov    0x4(%eax),%eax
f0123868:	8b 55 0c             	mov    0xc(%ebp),%edx
f012386b:	8b 12                	mov    (%edx),%edx
f012386d:	89 10                	mov    %edx,(%eax)
f012386f:	eb 0a                	jmp    f012387b <merging+0x10f>
f0123871:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123874:	8b 00                	mov    (%eax),%eax
f0123876:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f012387b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012387e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123884:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123887:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012388e:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123893:	48                   	dec    %eax
f0123894:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
		next_is_free = 1;
	}


	if(prev_is_free && next_is_free)
	{
f0123899:	90                   	nop
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f012389a:	e9 ea 02 00 00       	jmp    f0123b89 <merging+0x41d>
		set_block_data(prev_block, new_block_size, 0);


		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f012389f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01238a3:	74 3b                	je     f01238e0 <merging+0x174>
	{
//		cprintf("299\n");
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f01238a5:	83 ec 0c             	sub    $0xc,%esp
f01238a8:	ff 75 08             	pushl  0x8(%ebp)
f01238ab:	e8 90 f7 ff ff       	call   f0123040 <get_block_size>
f01238b0:	83 c4 10             	add    $0x10,%esp
f01238b3:	89 c3                	mov    %eax,%ebx
f01238b5:	83 ec 0c             	sub    $0xc,%esp
f01238b8:	ff 75 10             	pushl  0x10(%ebp)
f01238bb:	e8 80 f7 ff ff       	call   f0123040 <get_block_size>
f01238c0:	83 c4 10             	add    $0x10,%esp
f01238c3:	01 d8                	add    %ebx,%eax
f01238c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01238c8:	83 ec 04             	sub    $0x4,%esp
f01238cb:	6a 00                	push   $0x0
f01238cd:	ff 75 e8             	pushl  -0x18(%ebp)
f01238d0:	ff 75 08             	pushl  0x8(%ebp)
f01238d3:	e8 e4 f9 ff ff       	call   f01232bc <set_block_data>
f01238d8:	83 c4 10             	add    $0x10,%esp
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01238db:	e9 a9 02 00 00       	jmp    f0123b89 <merging+0x41d>
//		cprintf("299\n");
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f01238e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01238e4:	0f 84 2d 01 00 00    	je     f0123a17 <merging+0x2ab>
	{
//		cprintf("306\n");
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f01238ea:	83 ec 0c             	sub    $0xc,%esp
f01238ed:	ff 75 10             	pushl  0x10(%ebp)
f01238f0:	e8 4b f7 ff ff       	call   f0123040 <get_block_size>
f01238f5:	83 c4 10             	add    $0x10,%esp
f01238f8:	89 c3                	mov    %eax,%ebx
f01238fa:	83 ec 0c             	sub    $0xc,%esp
f01238fd:	ff 75 0c             	pushl  0xc(%ebp)
f0123900:	e8 3b f7 ff ff       	call   f0123040 <get_block_size>
f0123905:	83 c4 10             	add    $0x10,%esp
f0123908:	01 d8                	add    %ebx,%eax
f012390a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f012390d:	83 ec 04             	sub    $0x4,%esp
f0123910:	6a 00                	push   $0x0
f0123912:	ff 75 e4             	pushl  -0x1c(%ebp)
f0123915:	ff 75 10             	pushl  0x10(%ebp)
f0123918:	e8 9f f9 ff ff       	call   f01232bc <set_block_data>
f012391d:	83 c4 10             	add    $0x10,%esp


		struct BlockElement *va_block = (struct BlockElement *)va;
f0123920:	8b 45 10             	mov    0x10(%ebp),%eax
f0123923:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f0123926:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012392a:	74 06                	je     f0123932 <merging+0x1c6>
f012392c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0123930:	75 17                	jne    f0123949 <merging+0x1dd>
f0123932:	83 ec 04             	sub    $0x4,%esp
f0123935:	68 90 07 13 f0       	push   $0xf0130790
f012393a:	68 26 01 00 00       	push   $0x126
f012393f:	68 bb 06 13 f0       	push   $0xf01306bb
f0123944:	e8 d1 c9 fd ff       	call   f010031a <_panic>
f0123949:	8b 45 0c             	mov    0xc(%ebp),%eax
f012394c:	8b 50 04             	mov    0x4(%eax),%edx
f012394f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123952:	89 50 04             	mov    %edx,0x4(%eax)
f0123955:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123958:	8b 55 0c             	mov    0xc(%ebp),%edx
f012395b:	89 10                	mov    %edx,(%eax)
f012395d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123960:	8b 40 04             	mov    0x4(%eax),%eax
f0123963:	85 c0                	test   %eax,%eax
f0123965:	74 0d                	je     f0123974 <merging+0x208>
f0123967:	8b 45 0c             	mov    0xc(%ebp),%eax
f012396a:	8b 40 04             	mov    0x4(%eax),%eax
f012396d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123970:	89 10                	mov    %edx,(%eax)
f0123972:	eb 08                	jmp    f012397c <merging+0x210>
f0123974:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123977:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f012397c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012397f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123982:	89 50 04             	mov    %edx,0x4(%eax)
f0123985:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f012398a:	40                   	inc    %eax
f012398b:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
		LIST_REMOVE(&freeBlocksList, next_block);
f0123990:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123994:	75 17                	jne    f01239ad <merging+0x241>
f0123996:	83 ec 04             	sub    $0x4,%esp
f0123999:	68 3c 07 13 f0       	push   $0xf013073c
f012399e:	68 27 01 00 00       	push   $0x127
f01239a3:	68 bb 06 13 f0       	push   $0xf01306bb
f01239a8:	e8 6d c9 fd ff       	call   f010031a <_panic>
f01239ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239b0:	8b 00                	mov    (%eax),%eax
f01239b2:	85 c0                	test   %eax,%eax
f01239b4:	74 10                	je     f01239c6 <merging+0x25a>
f01239b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239b9:	8b 00                	mov    (%eax),%eax
f01239bb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01239be:	8b 52 04             	mov    0x4(%edx),%edx
f01239c1:	89 50 04             	mov    %edx,0x4(%eax)
f01239c4:	eb 0b                	jmp    f01239d1 <merging+0x265>
f01239c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239c9:	8b 40 04             	mov    0x4(%eax),%eax
f01239cc:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f01239d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239d4:	8b 40 04             	mov    0x4(%eax),%eax
f01239d7:	85 c0                	test   %eax,%eax
f01239d9:	74 0f                	je     f01239ea <merging+0x27e>
f01239db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239de:	8b 40 04             	mov    0x4(%eax),%eax
f01239e1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01239e4:	8b 12                	mov    (%edx),%edx
f01239e6:	89 10                	mov    %edx,(%eax)
f01239e8:	eb 0a                	jmp    f01239f4 <merging+0x288>
f01239ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239ed:	8b 00                	mov    (%eax),%eax
f01239ef:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f01239f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01239f7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01239fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123a00:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123a07:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123a0c:	48                   	dec    %eax
f0123a0d:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0123a12:	e9 72 01 00 00       	jmp    f0123b89 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f0123a17:	8b 45 10             	mov    0x10(%ebp),%eax
f0123a1a:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0123a1d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123a21:	74 79                	je     f0123a9c <merging+0x330>
f0123a23:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123a27:	74 73                	je     f0123a9c <merging+0x330>
f0123a29:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123a2d:	74 06                	je     f0123a35 <merging+0x2c9>
f0123a2f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123a33:	75 17                	jne    f0123a4c <merging+0x2e0>
f0123a35:	83 ec 04             	sub    $0x4,%esp
f0123a38:	68 08 07 13 f0       	push   $0xf0130708
f0123a3d:	68 2d 01 00 00       	push   $0x12d
f0123a42:	68 bb 06 13 f0       	push   $0xf01306bb
f0123a47:	e8 ce c8 fd ff       	call   f010031a <_panic>
f0123a4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0123a4f:	8b 10                	mov    (%eax),%edx
f0123a51:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123a54:	89 10                	mov    %edx,(%eax)
f0123a56:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123a59:	8b 00                	mov    (%eax),%eax
f0123a5b:	85 c0                	test   %eax,%eax
f0123a5d:	74 0b                	je     f0123a6a <merging+0x2fe>
f0123a5f:	8b 45 08             	mov    0x8(%ebp),%eax
f0123a62:	8b 00                	mov    (%eax),%eax
f0123a64:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123a67:	89 50 04             	mov    %edx,0x4(%eax)
f0123a6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0123a6d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123a70:	89 10                	mov    %edx,(%eax)
f0123a72:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123a75:	8b 55 08             	mov    0x8(%ebp),%edx
f0123a78:	89 50 04             	mov    %edx,0x4(%eax)
f0123a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123a7e:	8b 00                	mov    (%eax),%eax
f0123a80:	85 c0                	test   %eax,%eax
f0123a82:	75 08                	jne    f0123a8c <merging+0x320>
f0123a84:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123a87:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123a8c:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123a91:	40                   	inc    %eax
f0123a92:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
f0123a97:	e9 ce 00 00 00       	jmp    f0123b6a <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0123a9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123aa0:	74 65                	je     f0123b07 <merging+0x39b>
f0123aa2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123aa6:	75 17                	jne    f0123abf <merging+0x353>
f0123aa8:	83 ec 04             	sub    $0x4,%esp
f0123aab:	68 e4 06 13 f0       	push   $0xf01306e4
f0123ab0:	68 2e 01 00 00       	push   $0x12e
f0123ab5:	68 bb 06 13 f0       	push   $0xf01306bb
f0123aba:	e8 5b c8 fd ff       	call   f010031a <_panic>
f0123abf:	8b 15 54 0f 5a f0    	mov    0xf05a0f54,%edx
f0123ac5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123ac8:	89 50 04             	mov    %edx,0x4(%eax)
f0123acb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123ace:	8b 40 04             	mov    0x4(%eax),%eax
f0123ad1:	85 c0                	test   %eax,%eax
f0123ad3:	74 0c                	je     f0123ae1 <merging+0x375>
f0123ad5:	a1 54 0f 5a f0       	mov    0xf05a0f54,%eax
f0123ada:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123add:	89 10                	mov    %edx,(%eax)
f0123adf:	eb 08                	jmp    f0123ae9 <merging+0x37d>
f0123ae1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123ae4:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f0123ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123aec:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123af1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123af4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123afa:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123aff:	40                   	inc    %eax
f0123b00:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
f0123b05:	eb 63                	jmp    f0123b6a <merging+0x3fe>
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0123b07:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123b0b:	75 17                	jne    f0123b24 <merging+0x3b8>
f0123b0d:	83 ec 04             	sub    $0x4,%esp
f0123b10:	68 98 06 13 f0       	push   $0xf0130698
f0123b15:	68 30 01 00 00       	push   $0x130
f0123b1a:	68 bb 06 13 f0       	push   $0xf01306bb
f0123b1f:	e8 f6 c7 fd ff       	call   f010031a <_panic>
f0123b24:	8b 15 50 0f 5a f0    	mov    0xf05a0f50,%edx
f0123b2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123b2d:	89 10                	mov    %edx,(%eax)
f0123b2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123b32:	8b 00                	mov    (%eax),%eax
f0123b34:	85 c0                	test   %eax,%eax
f0123b36:	74 0d                	je     f0123b45 <merging+0x3d9>
f0123b38:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123b3d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123b40:	89 50 04             	mov    %edx,0x4(%eax)
f0123b43:	eb 08                	jmp    f0123b4d <merging+0x3e1>
f0123b45:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123b48:	a3 54 0f 5a f0       	mov    %eax,0xf05a0f54
f0123b4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123b50:	a3 50 0f 5a f0       	mov    %eax,0xf05a0f50
f0123b55:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123b58:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123b5f:	a1 5c 0f 5a f0       	mov    0xf05a0f5c,%eax
f0123b64:	40                   	inc    %eax
f0123b65:	a3 5c 0f 5a f0       	mov    %eax,0xf05a0f5c
		}
		set_block_data(va, get_block_size(va), 0);
f0123b6a:	83 ec 0c             	sub    $0xc,%esp
f0123b6d:	ff 75 10             	pushl  0x10(%ebp)
f0123b70:	e8 cb f4 ff ff       	call   f0123040 <get_block_size>
f0123b75:	83 c4 10             	add    $0x10,%esp
f0123b78:	83 ec 04             	sub    $0x4,%esp
f0123b7b:	6a 00                	push   $0x0
f0123b7d:	50                   	push   %eax
f0123b7e:	ff 75 10             	pushl  0x10(%ebp)
f0123b81:	e8 36 f7 ff ff       	call   f01232bc <set_block_data>
f0123b86:	83 c4 10             	add    $0x10,%esp
	}
}
f0123b89:	90                   	nop
f0123b8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0123b8d:	c9                   	leave  
f0123b8e:	c3                   	ret    

f0123b8f <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0123b8f:	55                   	push   %ebp
f0123b90:	89 e5                	mov    %esp,%ebp
f0123b92:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0123b95:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123b9a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0123b9d:	a1 54 0f 5a f0       	mov    0xf05a0f54,%eax
f0123ba2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0123ba5:	73 1b                	jae    f0123bc2 <free_block+0x33>
//		cprintf("363\n");
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0123ba7:	a1 54 0f 5a f0       	mov    0xf05a0f54,%eax
f0123bac:	83 ec 04             	sub    $0x4,%esp
f0123baf:	ff 75 08             	pushl  0x8(%ebp)
f0123bb2:	6a 00                	push   $0x0
f0123bb4:	50                   	push   %eax
f0123bb5:	e8 b2 fb ff ff       	call   f012376c <merging>
f0123bba:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0123bbd:	e9 8b 00 00 00       	jmp    f0123c4d <free_block+0xbe>

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
//		cprintf("363\n");
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f0123bc2:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123bc7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0123bca:	76 18                	jbe    f0123be4 <free_block+0x55>
//		cprintf("367\n");
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f0123bcc:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123bd1:	83 ec 04             	sub    $0x4,%esp
f0123bd4:	ff 75 08             	pushl  0x8(%ebp)
f0123bd7:	50                   	push   %eax
f0123bd8:	6a 00                	push   $0x0
f0123bda:	e8 8d fb ff ff       	call   f012376c <merging>
f0123bdf:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0123be2:	eb 69                	jmp    f0123c4d <free_block+0xbe>
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
//		cprintf("367\n");
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0123be4:	a1 50 0f 5a f0       	mov    0xf05a0f50,%eax
f0123be9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0123bec:	eb 39                	jmp    f0123c27 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0123bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123bf1:	3b 45 08             	cmp    0x8(%ebp),%eax
f0123bf4:	73 29                	jae    f0123c1f <free_block+0x90>
f0123bf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123bf9:	8b 00                	mov    (%eax),%eax
f0123bfb:	3b 45 08             	cmp    0x8(%ebp),%eax
f0123bfe:	76 1f                	jbe    f0123c1f <free_block+0x90>
//			cprintf("376\n");
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f0123c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123c03:	8b 00                	mov    (%eax),%eax
f0123c05:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f0123c08:	83 ec 04             	sub    $0x4,%esp
f0123c0b:	ff 75 08             	pushl  0x8(%ebp)
f0123c0e:	ff 75 f0             	pushl  -0x10(%ebp)
f0123c11:	ff 75 f4             	pushl  -0xc(%ebp)
f0123c14:	e8 53 fb ff ff       	call   f012376c <merging>
f0123c19:	83 c4 10             	add    $0x10,%esp
			break;
f0123c1c:	90                   	nop
		}
	}
}
f0123c1d:	eb 2e                	jmp    f0123c4d <free_block+0xbe>
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
//		cprintf("367\n");
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0123c1f:	a1 58 0f 5a f0       	mov    0xf05a0f58,%eax
f0123c24:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0123c27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123c2b:	74 07                	je     f0123c34 <free_block+0xa5>
f0123c2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123c30:	8b 00                	mov    (%eax),%eax
f0123c32:	eb 05                	jmp    f0123c39 <free_block+0xaa>
f0123c34:	b8 00 00 00 00       	mov    $0x0,%eax
f0123c39:	a3 58 0f 5a f0       	mov    %eax,0xf05a0f58
f0123c3e:	a1 58 0f 5a f0       	mov    0xf05a0f58,%eax
f0123c43:	85 c0                	test   %eax,%eax
f0123c45:	75 a7                	jne    f0123bee <free_block+0x5f>
f0123c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123c4b:	75 a1                	jne    f0123bee <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0123c4d:	90                   	nop
f0123c4e:	c9                   	leave  
f0123c4f:	c3                   	ret    

f0123c50 <realloc_block_FF>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void* va, uint32 new_size)
{
f0123c50:	55                   	push   %ebp
f0123c51:	89 e5                	mov    %esp,%ebp
f0123c53:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #08] [3] DYNAMIC ALLOCATOR - realloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("realloc_block_FF is not implemented yet");
f0123c56:	83 ec 04             	sub    $0x4,%esp
f0123c59:	68 c8 07 13 f0       	push   $0xf01307c8
f0123c5e:	68 5a 01 00 00       	push   $0x15a
f0123c63:	68 bb 06 13 f0       	push   $0xf01306bb
f0123c68:	e8 ad c6 fd ff       	call   f010031a <_panic>

f0123c6d <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0123c6d:	55                   	push   %ebp
f0123c6e:	89 e5                	mov    %esp,%ebp
f0123c70:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0123c73:	83 ec 04             	sub    $0x4,%esp
f0123c76:	68 f0 07 13 f0       	push   $0xf01307f0
f0123c7b:	68 66 01 00 00       	push   $0x166
f0123c80:	68 bb 06 13 f0       	push   $0xf01306bb
f0123c85:	e8 90 c6 fd ff       	call   f010031a <_panic>

f0123c8a <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0123c8a:	55                   	push   %ebp
f0123c8b:	89 e5                	mov    %esp,%ebp
f0123c8d:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0123c90:	83 ec 04             	sub    $0x4,%esp
f0123c93:	68 18 08 13 f0       	push   $0xf0130818
f0123c98:	68 6f 01 00 00       	push   $0x16f
f0123c9d:	68 bb 06 13 f0       	push   $0xf01306bb
f0123ca2:	e8 73 c6 fd ff       	call   f010031a <_panic>
f0123ca7:	90                   	nop

f0123ca8 <__moddi3>:
f0123ca8:	55                   	push   %ebp
f0123ca9:	57                   	push   %edi
f0123caa:	56                   	push   %esi
f0123cab:	53                   	push   %ebx
f0123cac:	83 ec 2c             	sub    $0x2c,%esp
f0123caf:	8b 74 24 40          	mov    0x40(%esp),%esi
f0123cb3:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0123cb7:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0123cbb:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0123cbf:	89 d8                	mov    %ebx,%eax
f0123cc1:	85 ff                	test   %edi,%edi
f0123cc3:	0f 88 d3 00 00 00    	js     f0123d9c <__moddi3+0xf4>
f0123cc9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0123cd0:	00 
f0123cd1:	85 c0                	test   %eax,%eax
f0123cd3:	0f 88 ab 00 00 00    	js     f0123d84 <__moddi3+0xdc>
f0123cd9:	89 0c 24             	mov    %ecx,(%esp)
f0123cdc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0123ce0:	89 74 24 10          	mov    %esi,0x10(%esp)
f0123ce4:	89 fb                	mov    %edi,%ebx
f0123ce6:	8b 14 24             	mov    (%esp),%edx
f0123ce9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0123ced:	89 d0                	mov    %edx,%eax
f0123cef:	89 54 24 18          	mov    %edx,0x18(%esp)
f0123cf3:	89 ca                	mov    %ecx,%edx
f0123cf5:	8b 0c 24             	mov    (%esp),%ecx
f0123cf8:	89 34 24             	mov    %esi,(%esp)
f0123cfb:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0123cff:	85 d2                	test   %edx,%edx
f0123d01:	75 15                	jne    f0123d18 <__moddi3+0x70>
f0123d03:	89 c7                	mov    %eax,%edi
f0123d05:	39 d8                	cmp    %ebx,%eax
f0123d07:	76 5b                	jbe    f0123d64 <__moddi3+0xbc>
f0123d09:	89 f0                	mov    %esi,%eax
f0123d0b:	89 da                	mov    %ebx,%edx
f0123d0d:	f7 f7                	div    %edi
f0123d0f:	89 d3                	mov    %edx,%ebx
f0123d11:	89 d8                	mov    %ebx,%eax
f0123d13:	31 d2                	xor    %edx,%edx
f0123d15:	eb 09                	jmp    f0123d20 <__moddi3+0x78>
f0123d17:	90                   	nop
f0123d18:	39 fa                	cmp    %edi,%edx
f0123d1a:	76 1c                	jbe    f0123d38 <__moddi3+0x90>
f0123d1c:	89 f0                	mov    %esi,%eax
f0123d1e:	89 fa                	mov    %edi,%edx
f0123d20:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0123d24:	85 c9                	test   %ecx,%ecx
f0123d26:	74 07                	je     f0123d2f <__moddi3+0x87>
f0123d28:	f7 d8                	neg    %eax
f0123d2a:	83 d2 00             	adc    $0x0,%edx
f0123d2d:	f7 da                	neg    %edx
f0123d2f:	83 c4 2c             	add    $0x2c,%esp
f0123d32:	5b                   	pop    %ebx
f0123d33:	5e                   	pop    %esi
f0123d34:	5f                   	pop    %edi
f0123d35:	5d                   	pop    %ebp
f0123d36:	c3                   	ret    
f0123d37:	90                   	nop
f0123d38:	0f bd c2             	bsr    %edx,%eax
f0123d3b:	83 f0 1f             	xor    $0x1f,%eax
f0123d3e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0123d42:	75 6c                	jne    f0123db0 <__moddi3+0x108>
f0123d44:	39 fa                	cmp    %edi,%edx
f0123d46:	72 05                	jb     f0123d4d <__moddi3+0xa5>
f0123d48:	3b 0c 24             	cmp    (%esp),%ecx
f0123d4b:	77 0e                	ja     f0123d5b <__moddi3+0xb3>
f0123d4d:	8b 34 24             	mov    (%esp),%esi
f0123d50:	29 ce                	sub    %ecx,%esi
f0123d52:	19 d3                	sbb    %edx,%ebx
f0123d54:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0123d58:	89 34 24             	mov    %esi,(%esp)
f0123d5b:	8b 04 24             	mov    (%esp),%eax
f0123d5e:	8b 54 24 14          	mov    0x14(%esp),%edx
f0123d62:	eb bc                	jmp    f0123d20 <__moddi3+0x78>
f0123d64:	85 c9                	test   %ecx,%ecx
f0123d66:	75 0b                	jne    f0123d73 <__moddi3+0xcb>
f0123d68:	b8 01 00 00 00       	mov    $0x1,%eax
f0123d6d:	31 d2                	xor    %edx,%edx
f0123d6f:	f7 f1                	div    %ecx
f0123d71:	89 c1                	mov    %eax,%ecx
f0123d73:	89 d8                	mov    %ebx,%eax
f0123d75:	31 d2                	xor    %edx,%edx
f0123d77:	f7 f1                	div    %ecx
f0123d79:	8b 04 24             	mov    (%esp),%eax
f0123d7c:	f7 f1                	div    %ecx
f0123d7e:	89 d3                	mov    %edx,%ebx
f0123d80:	eb 8f                	jmp    f0123d11 <__moddi3+0x69>
f0123d82:	66 90                	xchg   %ax,%ax
f0123d84:	89 c8                	mov    %ecx,%eax
f0123d86:	89 da                	mov    %ebx,%edx
f0123d88:	f7 d8                	neg    %eax
f0123d8a:	83 d2 00             	adc    $0x0,%edx
f0123d8d:	f7 da                	neg    %edx
f0123d8f:	89 04 24             	mov    %eax,(%esp)
f0123d92:	89 54 24 04          	mov    %edx,0x4(%esp)
f0123d96:	e9 45 ff ff ff       	jmp    f0123ce0 <__moddi3+0x38>
f0123d9b:	90                   	nop
f0123d9c:	f7 de                	neg    %esi
f0123d9e:	83 d7 00             	adc    $0x0,%edi
f0123da1:	f7 df                	neg    %edi
f0123da3:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0123daa:	ff 
f0123dab:	e9 21 ff ff ff       	jmp    f0123cd1 <__moddi3+0x29>
f0123db0:	b8 20 00 00 00       	mov    $0x20,%eax
f0123db5:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0123db9:	29 f8                	sub    %edi,%eax
f0123dbb:	89 c6                	mov    %eax,%esi
f0123dbd:	89 44 24 14          	mov    %eax,0x14(%esp)
f0123dc1:	89 f9                	mov    %edi,%ecx
f0123dc3:	d3 e2                	shl    %cl,%edx
f0123dc5:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0123dc9:	89 e8                	mov    %ebp,%eax
f0123dcb:	89 f1                	mov    %esi,%ecx
f0123dcd:	d3 e8                	shr    %cl,%eax
f0123dcf:	09 d0                	or     %edx,%eax
f0123dd1:	89 04 24             	mov    %eax,(%esp)
f0123dd4:	89 ea                	mov    %ebp,%edx
f0123dd6:	89 f9                	mov    %edi,%ecx
f0123dd8:	d3 e2                	shl    %cl,%edx
f0123dda:	89 d7                	mov    %edx,%edi
f0123ddc:	89 da                	mov    %ebx,%edx
f0123dde:	d3 e2                	shl    %cl,%edx
f0123de0:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0123de4:	d3 e5                	shl    %cl,%ebp
f0123de6:	8b 44 24 10          	mov    0x10(%esp),%eax
f0123dea:	89 f1                	mov    %esi,%ecx
f0123dec:	d3 e8                	shr    %cl,%eax
f0123dee:	09 d0                	or     %edx,%eax
f0123df0:	d3 eb                	shr    %cl,%ebx
f0123df2:	89 da                	mov    %ebx,%edx
f0123df4:	f7 34 24             	divl   (%esp)
f0123df7:	89 d3                	mov    %edx,%ebx
f0123df9:	f7 e7                	mul    %edi
f0123dfb:	89 c6                	mov    %eax,%esi
f0123dfd:	89 d1                	mov    %edx,%ecx
f0123dff:	39 d3                	cmp    %edx,%ebx
f0123e01:	72 29                	jb     f0123e2c <__moddi3+0x184>
f0123e03:	74 33                	je     f0123e38 <__moddi3+0x190>
f0123e05:	89 e8                	mov    %ebp,%eax
f0123e07:	29 f0                	sub    %esi,%eax
f0123e09:	19 cb                	sbb    %ecx,%ebx
f0123e0b:	89 de                	mov    %ebx,%esi
f0123e0d:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0123e11:	d3 e6                	shl    %cl,%esi
f0123e13:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0123e17:	89 f9                	mov    %edi,%ecx
f0123e19:	d3 e8                	shr    %cl,%eax
f0123e1b:	09 c6                	or     %eax,%esi
f0123e1d:	89 f0                	mov    %esi,%eax
f0123e1f:	89 f9                	mov    %edi,%ecx
f0123e21:	d3 eb                	shr    %cl,%ebx
f0123e23:	89 da                	mov    %ebx,%edx
f0123e25:	e9 f6 fe ff ff       	jmp    f0123d20 <__moddi3+0x78>
f0123e2a:	66 90                	xchg   %ax,%ax
f0123e2c:	29 f8                	sub    %edi,%eax
f0123e2e:	1b 14 24             	sbb    (%esp),%edx
f0123e31:	89 d1                	mov    %edx,%ecx
f0123e33:	89 c6                	mov    %eax,%esi
f0123e35:	eb ce                	jmp    f0123e05 <__moddi3+0x15d>
f0123e37:	90                   	nop
f0123e38:	39 c5                	cmp    %eax,%ebp
f0123e3a:	72 f0                	jb     f0123e2c <__moddi3+0x184>
f0123e3c:	89 d9                	mov    %ebx,%ecx
f0123e3e:	eb c5                	jmp    f0123e05 <__moddi3+0x15d>

f0123e40 <__udivdi3>:
f0123e40:	55                   	push   %ebp
f0123e41:	57                   	push   %edi
f0123e42:	56                   	push   %esi
f0123e43:	53                   	push   %ebx
f0123e44:	83 ec 1c             	sub    $0x1c,%esp
f0123e47:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0123e4b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0123e4f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0123e53:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0123e57:	89 ca                	mov    %ecx,%edx
f0123e59:	89 f8                	mov    %edi,%eax
f0123e5b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0123e5f:	85 f6                	test   %esi,%esi
f0123e61:	75 2d                	jne    f0123e90 <__udivdi3+0x50>
f0123e63:	39 cf                	cmp    %ecx,%edi
f0123e65:	77 65                	ja     f0123ecc <__udivdi3+0x8c>
f0123e67:	89 fd                	mov    %edi,%ebp
f0123e69:	85 ff                	test   %edi,%edi
f0123e6b:	75 0b                	jne    f0123e78 <__udivdi3+0x38>
f0123e6d:	b8 01 00 00 00       	mov    $0x1,%eax
f0123e72:	31 d2                	xor    %edx,%edx
f0123e74:	f7 f7                	div    %edi
f0123e76:	89 c5                	mov    %eax,%ebp
f0123e78:	31 d2                	xor    %edx,%edx
f0123e7a:	89 c8                	mov    %ecx,%eax
f0123e7c:	f7 f5                	div    %ebp
f0123e7e:	89 c1                	mov    %eax,%ecx
f0123e80:	89 d8                	mov    %ebx,%eax
f0123e82:	f7 f5                	div    %ebp
f0123e84:	89 cf                	mov    %ecx,%edi
f0123e86:	89 fa                	mov    %edi,%edx
f0123e88:	83 c4 1c             	add    $0x1c,%esp
f0123e8b:	5b                   	pop    %ebx
f0123e8c:	5e                   	pop    %esi
f0123e8d:	5f                   	pop    %edi
f0123e8e:	5d                   	pop    %ebp
f0123e8f:	c3                   	ret    
f0123e90:	39 ce                	cmp    %ecx,%esi
f0123e92:	77 28                	ja     f0123ebc <__udivdi3+0x7c>
f0123e94:	0f bd fe             	bsr    %esi,%edi
f0123e97:	83 f7 1f             	xor    $0x1f,%edi
f0123e9a:	75 40                	jne    f0123edc <__udivdi3+0x9c>
f0123e9c:	39 ce                	cmp    %ecx,%esi
f0123e9e:	72 0a                	jb     f0123eaa <__udivdi3+0x6a>
f0123ea0:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0123ea4:	0f 87 9e 00 00 00    	ja     f0123f48 <__udivdi3+0x108>
f0123eaa:	b8 01 00 00 00       	mov    $0x1,%eax
f0123eaf:	89 fa                	mov    %edi,%edx
f0123eb1:	83 c4 1c             	add    $0x1c,%esp
f0123eb4:	5b                   	pop    %ebx
f0123eb5:	5e                   	pop    %esi
f0123eb6:	5f                   	pop    %edi
f0123eb7:	5d                   	pop    %ebp
f0123eb8:	c3                   	ret    
f0123eb9:	8d 76 00             	lea    0x0(%esi),%esi
f0123ebc:	31 ff                	xor    %edi,%edi
f0123ebe:	31 c0                	xor    %eax,%eax
f0123ec0:	89 fa                	mov    %edi,%edx
f0123ec2:	83 c4 1c             	add    $0x1c,%esp
f0123ec5:	5b                   	pop    %ebx
f0123ec6:	5e                   	pop    %esi
f0123ec7:	5f                   	pop    %edi
f0123ec8:	5d                   	pop    %ebp
f0123ec9:	c3                   	ret    
f0123eca:	66 90                	xchg   %ax,%ax
f0123ecc:	89 d8                	mov    %ebx,%eax
f0123ece:	f7 f7                	div    %edi
f0123ed0:	31 ff                	xor    %edi,%edi
f0123ed2:	89 fa                	mov    %edi,%edx
f0123ed4:	83 c4 1c             	add    $0x1c,%esp
f0123ed7:	5b                   	pop    %ebx
f0123ed8:	5e                   	pop    %esi
f0123ed9:	5f                   	pop    %edi
f0123eda:	5d                   	pop    %ebp
f0123edb:	c3                   	ret    
f0123edc:	bd 20 00 00 00       	mov    $0x20,%ebp
f0123ee1:	89 eb                	mov    %ebp,%ebx
f0123ee3:	29 fb                	sub    %edi,%ebx
f0123ee5:	89 f9                	mov    %edi,%ecx
f0123ee7:	d3 e6                	shl    %cl,%esi
f0123ee9:	89 c5                	mov    %eax,%ebp
f0123eeb:	88 d9                	mov    %bl,%cl
f0123eed:	d3 ed                	shr    %cl,%ebp
f0123eef:	89 e9                	mov    %ebp,%ecx
f0123ef1:	09 f1                	or     %esi,%ecx
f0123ef3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0123ef7:	89 f9                	mov    %edi,%ecx
f0123ef9:	d3 e0                	shl    %cl,%eax
f0123efb:	89 c5                	mov    %eax,%ebp
f0123efd:	89 d6                	mov    %edx,%esi
f0123eff:	88 d9                	mov    %bl,%cl
f0123f01:	d3 ee                	shr    %cl,%esi
f0123f03:	89 f9                	mov    %edi,%ecx
f0123f05:	d3 e2                	shl    %cl,%edx
f0123f07:	8b 44 24 08          	mov    0x8(%esp),%eax
f0123f0b:	88 d9                	mov    %bl,%cl
f0123f0d:	d3 e8                	shr    %cl,%eax
f0123f0f:	09 c2                	or     %eax,%edx
f0123f11:	89 d0                	mov    %edx,%eax
f0123f13:	89 f2                	mov    %esi,%edx
f0123f15:	f7 74 24 0c          	divl   0xc(%esp)
f0123f19:	89 d6                	mov    %edx,%esi
f0123f1b:	89 c3                	mov    %eax,%ebx
f0123f1d:	f7 e5                	mul    %ebp
f0123f1f:	39 d6                	cmp    %edx,%esi
f0123f21:	72 19                	jb     f0123f3c <__udivdi3+0xfc>
f0123f23:	74 0b                	je     f0123f30 <__udivdi3+0xf0>
f0123f25:	89 d8                	mov    %ebx,%eax
f0123f27:	31 ff                	xor    %edi,%edi
f0123f29:	e9 58 ff ff ff       	jmp    f0123e86 <__udivdi3+0x46>
f0123f2e:	66 90                	xchg   %ax,%ax
f0123f30:	8b 54 24 08          	mov    0x8(%esp),%edx
f0123f34:	89 f9                	mov    %edi,%ecx
f0123f36:	d3 e2                	shl    %cl,%edx
f0123f38:	39 c2                	cmp    %eax,%edx
f0123f3a:	73 e9                	jae    f0123f25 <__udivdi3+0xe5>
f0123f3c:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0123f3f:	31 ff                	xor    %edi,%edi
f0123f41:	e9 40 ff ff ff       	jmp    f0123e86 <__udivdi3+0x46>
f0123f46:	66 90                	xchg   %ax,%ax
f0123f48:	31 c0                	xor    %eax,%eax
f0123f4a:	e9 37 ff ff ff       	jmp    f0123e86 <__udivdi3+0x46>
f0123f4f:	90                   	nop

f0123f50 <__umoddi3>:
f0123f50:	55                   	push   %ebp
f0123f51:	57                   	push   %edi
f0123f52:	56                   	push   %esi
f0123f53:	53                   	push   %ebx
f0123f54:	83 ec 1c             	sub    $0x1c,%esp
f0123f57:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0123f5b:	8b 74 24 34          	mov    0x34(%esp),%esi
f0123f5f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0123f63:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0123f67:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0123f6b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0123f6f:	89 f3                	mov    %esi,%ebx
f0123f71:	89 fa                	mov    %edi,%edx
f0123f73:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0123f77:	89 34 24             	mov    %esi,(%esp)
f0123f7a:	85 c0                	test   %eax,%eax
f0123f7c:	75 1a                	jne    f0123f98 <__umoddi3+0x48>
f0123f7e:	39 f7                	cmp    %esi,%edi
f0123f80:	0f 86 a2 00 00 00    	jbe    f0124028 <__umoddi3+0xd8>
f0123f86:	89 c8                	mov    %ecx,%eax
f0123f88:	89 f2                	mov    %esi,%edx
f0123f8a:	f7 f7                	div    %edi
f0123f8c:	89 d0                	mov    %edx,%eax
f0123f8e:	31 d2                	xor    %edx,%edx
f0123f90:	83 c4 1c             	add    $0x1c,%esp
f0123f93:	5b                   	pop    %ebx
f0123f94:	5e                   	pop    %esi
f0123f95:	5f                   	pop    %edi
f0123f96:	5d                   	pop    %ebp
f0123f97:	c3                   	ret    
f0123f98:	39 f0                	cmp    %esi,%eax
f0123f9a:	0f 87 ac 00 00 00    	ja     f012404c <__umoddi3+0xfc>
f0123fa0:	0f bd e8             	bsr    %eax,%ebp
f0123fa3:	83 f5 1f             	xor    $0x1f,%ebp
f0123fa6:	0f 84 ac 00 00 00    	je     f0124058 <__umoddi3+0x108>
f0123fac:	bf 20 00 00 00       	mov    $0x20,%edi
f0123fb1:	29 ef                	sub    %ebp,%edi
f0123fb3:	89 fe                	mov    %edi,%esi
f0123fb5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0123fb9:	89 e9                	mov    %ebp,%ecx
f0123fbb:	d3 e0                	shl    %cl,%eax
f0123fbd:	89 d7                	mov    %edx,%edi
f0123fbf:	89 f1                	mov    %esi,%ecx
f0123fc1:	d3 ef                	shr    %cl,%edi
f0123fc3:	09 c7                	or     %eax,%edi
f0123fc5:	89 e9                	mov    %ebp,%ecx
f0123fc7:	d3 e2                	shl    %cl,%edx
f0123fc9:	89 14 24             	mov    %edx,(%esp)
f0123fcc:	89 d8                	mov    %ebx,%eax
f0123fce:	d3 e0                	shl    %cl,%eax
f0123fd0:	89 c2                	mov    %eax,%edx
f0123fd2:	8b 44 24 08          	mov    0x8(%esp),%eax
f0123fd6:	d3 e0                	shl    %cl,%eax
f0123fd8:	89 44 24 04          	mov    %eax,0x4(%esp)
f0123fdc:	8b 44 24 08          	mov    0x8(%esp),%eax
f0123fe0:	89 f1                	mov    %esi,%ecx
f0123fe2:	d3 e8                	shr    %cl,%eax
f0123fe4:	09 d0                	or     %edx,%eax
f0123fe6:	d3 eb                	shr    %cl,%ebx
f0123fe8:	89 da                	mov    %ebx,%edx
f0123fea:	f7 f7                	div    %edi
f0123fec:	89 d3                	mov    %edx,%ebx
f0123fee:	f7 24 24             	mull   (%esp)
f0123ff1:	89 c6                	mov    %eax,%esi
f0123ff3:	89 d1                	mov    %edx,%ecx
f0123ff5:	39 d3                	cmp    %edx,%ebx
f0123ff7:	0f 82 87 00 00 00    	jb     f0124084 <__umoddi3+0x134>
f0123ffd:	0f 84 91 00 00 00    	je     f0124094 <__umoddi3+0x144>
f0124003:	8b 54 24 04          	mov    0x4(%esp),%edx
f0124007:	29 f2                	sub    %esi,%edx
f0124009:	19 cb                	sbb    %ecx,%ebx
f012400b:	89 d8                	mov    %ebx,%eax
f012400d:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0124011:	d3 e0                	shl    %cl,%eax
f0124013:	89 e9                	mov    %ebp,%ecx
f0124015:	d3 ea                	shr    %cl,%edx
f0124017:	09 d0                	or     %edx,%eax
f0124019:	89 e9                	mov    %ebp,%ecx
f012401b:	d3 eb                	shr    %cl,%ebx
f012401d:	89 da                	mov    %ebx,%edx
f012401f:	83 c4 1c             	add    $0x1c,%esp
f0124022:	5b                   	pop    %ebx
f0124023:	5e                   	pop    %esi
f0124024:	5f                   	pop    %edi
f0124025:	5d                   	pop    %ebp
f0124026:	c3                   	ret    
f0124027:	90                   	nop
f0124028:	89 fd                	mov    %edi,%ebp
f012402a:	85 ff                	test   %edi,%edi
f012402c:	75 0b                	jne    f0124039 <__umoddi3+0xe9>
f012402e:	b8 01 00 00 00       	mov    $0x1,%eax
f0124033:	31 d2                	xor    %edx,%edx
f0124035:	f7 f7                	div    %edi
f0124037:	89 c5                	mov    %eax,%ebp
f0124039:	89 f0                	mov    %esi,%eax
f012403b:	31 d2                	xor    %edx,%edx
f012403d:	f7 f5                	div    %ebp
f012403f:	89 c8                	mov    %ecx,%eax
f0124041:	f7 f5                	div    %ebp
f0124043:	89 d0                	mov    %edx,%eax
f0124045:	e9 44 ff ff ff       	jmp    f0123f8e <__umoddi3+0x3e>
f012404a:	66 90                	xchg   %ax,%ax
f012404c:	89 c8                	mov    %ecx,%eax
f012404e:	89 f2                	mov    %esi,%edx
f0124050:	83 c4 1c             	add    $0x1c,%esp
f0124053:	5b                   	pop    %ebx
f0124054:	5e                   	pop    %esi
f0124055:	5f                   	pop    %edi
f0124056:	5d                   	pop    %ebp
f0124057:	c3                   	ret    
f0124058:	3b 04 24             	cmp    (%esp),%eax
f012405b:	72 06                	jb     f0124063 <__umoddi3+0x113>
f012405d:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0124061:	77 0f                	ja     f0124072 <__umoddi3+0x122>
f0124063:	89 f2                	mov    %esi,%edx
f0124065:	29 f9                	sub    %edi,%ecx
f0124067:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012406b:	89 14 24             	mov    %edx,(%esp)
f012406e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0124072:	8b 44 24 04          	mov    0x4(%esp),%eax
f0124076:	8b 14 24             	mov    (%esp),%edx
f0124079:	83 c4 1c             	add    $0x1c,%esp
f012407c:	5b                   	pop    %ebx
f012407d:	5e                   	pop    %esi
f012407e:	5f                   	pop    %edi
f012407f:	5d                   	pop    %ebp
f0124080:	c3                   	ret    
f0124081:	8d 76 00             	lea    0x0(%esi),%esi
f0124084:	2b 04 24             	sub    (%esp),%eax
f0124087:	19 fa                	sbb    %edi,%edx
f0124089:	89 d1                	mov    %edx,%ecx
f012408b:	89 c6                	mov    %eax,%esi
f012408d:	e9 71 ff ff ff       	jmp    f0124003 <__umoddi3+0xb3>
f0124092:	66 90                	xchg   %ax,%ax
f0124094:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0124098:	72 ea                	jb     f0124084 <__umoddi3+0x134>
f012409a:	89 d9                	mov    %ebx,%ecx
f012409c:	e9 62 ff ff ff       	jmp    f0124003 <__umoddi3+0xb3>
